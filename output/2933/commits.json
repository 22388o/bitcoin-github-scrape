[
  {
    "sha": "eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZWQyOWYwZjUwODA2YjljZmU5NjUzNTA5ZTdlZDdmN2VlYmRkM2Uz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-08-24T20:21:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-08-24T20:21:41Z"
      },
      "message": "Squashed 'src/leveldb/' changes from be1b0ff..936b461\n\n936b461 Merge upstream LevelDB 1.13.\n748539c LevelDB 1.13\n\ngit-subtree-dir: src/leveldb\ngit-subtree-split: 936b4613ea4551992e6096b1e05eeefc09a20e3b",
      "tree": {
        "sha": "b7c699c2c085ef911eca46890093d04644eb96c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7c699c2c085ef911eca46890093d04644eb96c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1bb86d6f154da45464eb8b009c298dccd1cb3dab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bb86d6f154da45464eb8b009c298dccd1cb3dab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1bb86d6f154da45464eb8b009c298dccd1cb3dab"
      }
    ],
    "stats": {
      "total": 430,
      "additions": 363,
      "deletions": 67
    },
    "files": [
      {
        "sha": "20c9c4f28751a716e6279940d723e357ba1f088c",
        "filename": "Makefile",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -31,6 +31,7 @@ TESTHARNESS = ./util/testharness.o $(TESTUTIL)\n \n TESTS = \\\n \tarena_test \\\n+\tautocompact_test \\\n \tbloom_test \\\n \tc_test \\\n \tcache_test \\\n@@ -70,7 +71,7 @@ SHARED = $(SHARED1)\n else\n # Update db.h if you change these.\n SHARED_MAJOR = 1\n-SHARED_MINOR = 12\n+SHARED_MINOR = 13\n SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)\n@@ -114,6 +115,9 @@ leveldbutil: db/leveldb_main.o $(LIBOBJECTS)\n arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+autocompact_test: db/autocompact_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) db/autocompact_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n bloom_test: util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n "
      },
      {
        "sha": "d20a2362c30c49d9cc2b1e2f65a2f829905eb3f8",
        "filename": "db/autocompact_test.cc",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/autocompact_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/autocompact_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/autocompact_test.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2013 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/db.h\"\n+#include \"db/db_impl.h\"\n+#include \"leveldb/cache.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+class AutoCompactTest {\n+ public:\n+  std::string dbname_;\n+  Cache* tiny_cache_;\n+  Options options_;\n+  DB* db_;\n+\n+  AutoCompactTest() {\n+    dbname_ = test::TmpDir() + \"/autocompact_test\";\n+    tiny_cache_ = NewLRUCache(100);\n+    options_.block_cache = tiny_cache_;\n+    DestroyDB(dbname_, options_);\n+    options_.create_if_missing = true;\n+    options_.compression = kNoCompression;\n+    ASSERT_OK(DB::Open(options_, dbname_, &db_));\n+  }\n+\n+  ~AutoCompactTest() {\n+    delete db_;\n+    DestroyDB(dbname_, Options());\n+    delete tiny_cache_;\n+  }\n+\n+  std::string Key(int i) {\n+    char buf[100];\n+    snprintf(buf, sizeof(buf), \"key%06d\", i);\n+    return std::string(buf);\n+  }\n+\n+  uint64_t Size(const Slice& start, const Slice& limit) {\n+    Range r(start, limit);\n+    uint64_t size;\n+    db_->GetApproximateSizes(&r, 1, &size);\n+    return size;\n+  }\n+\n+  void DoReads(int n);\n+};\n+\n+static const int kValueSize = 200 * 1024;\n+static const int kTotalSize = 100 * 1024 * 1024;\n+static const int kCount = kTotalSize / kValueSize;\n+\n+// Read through the first n keys repeatedly and check that they get\n+// compacted (verified by checking the size of the key space).\n+void AutoCompactTest::DoReads(int n) {\n+  std::string value(kValueSize, 'x');\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+\n+  // Fill database\n+  for (int i = 0; i < kCount; i++) {\n+    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n+  }\n+  ASSERT_OK(dbi->TEST_CompactMemTable());\n+\n+  // Delete everything\n+  for (int i = 0; i < kCount; i++) {\n+    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n+  }\n+  ASSERT_OK(dbi->TEST_CompactMemTable());\n+\n+  // Get initial measurement of the space we will be reading.\n+  const int64_t initial_size = Size(Key(0), Key(n));\n+  const int64_t initial_other_size = Size(Key(n), Key(kCount));\n+\n+  // Read until size drops significantly.\n+  std::string limit_key = Key(n);\n+  for (int read = 0; true; read++) {\n+    ASSERT_LT(read, 100) << \"Taking too long to compact\";\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    for (iter->SeekToFirst();\n+         iter->Valid() && iter->key().ToString() < limit_key;\n+         iter->Next()) {\n+      // Drop data\n+    }\n+    delete iter;\n+    // Wait a little bit to allow any triggered compactions to complete.\n+    Env::Default()->SleepForMicroseconds(1000000);\n+    uint64_t size = Size(Key(0), Key(n));\n+    fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n+            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n+    if (size <= initial_size/10) {\n+      break;\n+    }\n+  }\n+\n+  // Verify that the size of the key space not touched by the reads\n+  // is pretty much unchanged.\n+  const int64_t final_other_size = Size(Key(n), Key(kCount));\n+  ASSERT_LE(final_other_size, initial_other_size + 1048576);\n+  ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n+}\n+\n+TEST(AutoCompactTest, ReadAll) {\n+  DoReads(kCount);\n+}\n+\n+TEST(AutoCompactTest, ReadHalf) {\n+  DoReads(kCount/2);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "b37ffdfe645cdb7c65e6f4680776b38c668394a9",
        "filename": "db/corruption_test.cc",
        "status": "modified",
        "additions": 22,
        "deletions": 29,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/corruption_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/corruption_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/corruption_test.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -35,6 +35,7 @@ class CorruptionTest {\n   CorruptionTest() {\n     tiny_cache_ = NewLRUCache(100);\n     options_.env = &env_;\n+    options_.block_cache = tiny_cache_;\n     dbname_ = test::TmpDir() + \"/db_test\";\n     DestroyDB(dbname_, options_);\n \n@@ -50,17 +51,14 @@ class CorruptionTest {\n      delete tiny_cache_;\n   }\n \n-  Status TryReopen(Options* options = NULL) {\n+  Status TryReopen() {\n     delete db_;\n     db_ = NULL;\n-    Options opt = (options ? *options : options_);\n-    opt.env = &env_;\n-    opt.block_cache = tiny_cache_;\n-    return DB::Open(opt, dbname_, &db_);\n+    return DB::Open(options_, dbname_, &db_);\n   }\n \n-  void Reopen(Options* options = NULL) {\n-    ASSERT_OK(TryReopen(options));\n+  void Reopen() {\n+    ASSERT_OK(TryReopen());\n   }\n \n   void RepairDB() {\n@@ -92,6 +90,10 @@ class CorruptionTest {\n     for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n       uint64_t key;\n       Slice in(iter->key());\n+      if (in == \"\" || in == \"~\") {\n+        // Ignore boundary keys.\n+        continue;\n+      }\n       if (!ConsumeDecimalNumber(&in, &key) ||\n           !in.empty() ||\n           key < next_expected) {\n@@ -233,7 +235,7 @@ TEST(CorruptionTest, TableFile) {\n   dbi->TEST_CompactRange(1, NULL, NULL);\n \n   Corrupt(kTableFile, 100, 1);\n-  Check(99, 99);\n+  Check(90, 99);\n }\n \n TEST(CorruptionTest, TableFileIndexData) {\n@@ -299,40 +301,31 @@ TEST(CorruptionTest, CompactionInputError) {\n   ASSERT_EQ(1, Property(\"leveldb.num-files-at-level\" + NumberToString(last)));\n \n   Corrupt(kTableFile, 100, 1);\n-  Check(9, 9);\n+  Check(5, 9);\n \n   // Force compactions by writing lots of values\n   Build(10000);\n   Check(10000, 10000);\n }\n \n TEST(CorruptionTest, CompactionInputErrorParanoid) {\n-  Options options;\n-  options.paranoid_checks = true;\n-  options.write_buffer_size = 1048576;\n-  Reopen(&options);\n+  options_.paranoid_checks = true;\n+  options_.write_buffer_size = 512 << 10;\n+  Reopen();\n   DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n \n-  // Fill levels >= 1 so memtable compaction outputs to level 1\n-  for (int level = 1; level < config::kNumLevels; level++) {\n-    dbi->Put(WriteOptions(), \"\", \"begin\");\n-    dbi->Put(WriteOptions(), \"~\", \"end\");\n+  // Make multiple inputs so we need to compact.\n+  for (int i = 0; i < 2; i++) {\n+    Build(10);\n     dbi->TEST_CompactMemTable();\n+    Corrupt(kTableFile, 100, 1);\n+    env_.SleepForMicroseconds(100000);\n   }\n+  dbi->CompactRange(NULL, NULL);\n \n-  Build(10);\n-  dbi->TEST_CompactMemTable();\n-  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level0\"));\n-\n-  Corrupt(kTableFile, 100, 1);\n-  Check(9, 9);\n-\n-  // Write must eventually fail because of corrupted table\n-  Status s;\n+  // Write must fail because of corrupted table\n   std::string tmp1, tmp2;\n-  for (int i = 0; i < 10000 && s.ok(); i++) {\n-    s = db_->Put(WriteOptions(), Key(i, &tmp1), Value(i, &tmp2));\n-  }\n+  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));\n   ASSERT_TRUE(!s.ok()) << \"write did not fail in corrupted paranoid db\";\n }\n "
      },
      {
        "sha": "fa1351038bcb0b1c224dc566fb16d6806966cc62",
        "filename": "db/db_impl.cc",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_impl.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -113,14 +113,14 @@ Options SanitizeOptions(const std::string& dbname,\n   return result;\n }\n \n-DBImpl::DBImpl(const Options& options, const std::string& dbname)\n-    : env_(options.env),\n-      internal_comparator_(options.comparator),\n-      internal_filter_policy_(options.filter_policy),\n-      options_(SanitizeOptions(\n-          dbname, &internal_comparator_, &internal_filter_policy_, options)),\n-      owns_info_log_(options_.info_log != options.info_log),\n-      owns_cache_(options_.block_cache != options.block_cache),\n+DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)\n+    : env_(raw_options.env),\n+      internal_comparator_(raw_options.comparator),\n+      internal_filter_policy_(raw_options.filter_policy),\n+      options_(SanitizeOptions(dbname, &internal_comparator_,\n+                               &internal_filter_policy_, raw_options)),\n+      owns_info_log_(options_.info_log != raw_options.info_log),\n+      owns_cache_(options_.block_cache != raw_options.block_cache),\n       dbname_(dbname),\n       db_lock_(NULL),\n       shutting_down_(NULL),\n@@ -130,6 +130,7 @@ DBImpl::DBImpl(const Options& options, const std::string& dbname)\n       logfile_(NULL),\n       logfile_number_(0),\n       log_(NULL),\n+      seed_(0),\n       tmp_batch_(new WriteBatch),\n       bg_compaction_scheduled_(false),\n       manual_compaction_(NULL),\n@@ -138,7 +139,7 @@ DBImpl::DBImpl(const Options& options, const std::string& dbname)\n   has_imm_.Release_Store(NULL);\n \n   // Reserve ten files or so for other uses and give the rest to TableCache.\n-  const int table_cache_size = options.max_open_files - kNumNonTableCacheFiles;\n+  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;\n   table_cache_ = new TableCache(dbname_, &options_, table_cache_size);\n \n   versions_ = new VersionSet(dbname_, &options_, table_cache_,\n@@ -1027,7 +1028,8 @@ static void CleanupIteratorState(void* arg1, void* arg2) {\n }  // namespace\n \n Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,\n-                                      SequenceNumber* latest_snapshot) {\n+                                      SequenceNumber* latest_snapshot,\n+                                      uint32_t* seed) {\n   IterState* cleanup = new IterState;\n   mutex_.Lock();\n   *latest_snapshot = versions_->LastSequence();\n@@ -1051,13 +1053,15 @@ Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,\n   cleanup->version = versions_->current();\n   internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);\n \n+  *seed = ++seed_;\n   mutex_.Unlock();\n   return internal_iter;\n }\n \n Iterator* DBImpl::TEST_NewInternalIterator() {\n   SequenceNumber ignored;\n-  return NewInternalIterator(ReadOptions(), &ignored);\n+  uint32_t ignored_seed;\n+  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);\n }\n \n int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {\n@@ -1114,12 +1118,21 @@ Status DBImpl::Get(const ReadOptions& options,\n \n Iterator* DBImpl::NewIterator(const ReadOptions& options) {\n   SequenceNumber latest_snapshot;\n-  Iterator* internal_iter = NewInternalIterator(options, &latest_snapshot);\n+  uint32_t seed;\n+  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);\n   return NewDBIterator(\n-      &dbname_, env_, user_comparator(), internal_iter,\n+      this, user_comparator(), iter,\n       (options.snapshot != NULL\n        ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_\n-       : latest_snapshot));\n+       : latest_snapshot),\n+      seed);\n+}\n+\n+void DBImpl::RecordReadSample(Slice key) {\n+  MutexLock l(&mutex_);\n+  if (versions_->current()->RecordReadSample(key)) {\n+    MaybeScheduleCompaction();\n+  }\n }\n \n const Snapshot* DBImpl::GetSnapshot() {"
      },
      {
        "sha": "75fd30abe9a56bd663537baa20b2104b349f645f",
        "filename": "db/db_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_impl.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -59,13 +59,19 @@ class DBImpl : public DB {\n   // file at a level >= 1.\n   int64_t TEST_MaxNextLevelOverlappingBytes();\n \n+  // Record a sample of bytes read at the specified internal key.\n+  // Samples are taken approximately once every config::kReadBytesPeriod\n+  // bytes.\n+  void RecordReadSample(Slice key);\n+\n  private:\n   friend class DB;\n   struct CompactionState;\n   struct Writer;\n \n   Iterator* NewInternalIterator(const ReadOptions&,\n-                                SequenceNumber* latest_snapshot);\n+                                SequenceNumber* latest_snapshot,\n+                                uint32_t* seed);\n \n   Status NewDB();\n \n@@ -135,6 +141,7 @@ class DBImpl : public DB {\n   WritableFile* logfile_;\n   uint64_t logfile_number_;\n   log::Writer* log_;\n+  uint32_t seed_;                // For sampling.\n \n   // Queue of writers.\n   std::deque<Writer*> writers_;"
      },
      {
        "sha": "071a54e3f457a02d726b3c0f53212a92ddf0c8de",
        "filename": "db/db_iter.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 12,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_iter.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_iter.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_iter.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -5,12 +5,14 @@\n #include \"db/db_iter.h\"\n \n #include \"db/filename.h\"\n+#include \"db/db_impl.h\"\n #include \"db/dbformat.h\"\n #include \"leveldb/env.h\"\n #include \"leveldb/iterator.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n+#include \"util/random.h\"\n \n namespace leveldb {\n \n@@ -46,15 +48,16 @@ class DBIter: public Iterator {\n     kReverse\n   };\n \n-  DBIter(const std::string* dbname, Env* env,\n-         const Comparator* cmp, Iterator* iter, SequenceNumber s)\n-      : dbname_(dbname),\n-        env_(env),\n+  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,\n+         uint32_t seed)\n+      : db_(db),\n         user_comparator_(cmp),\n         iter_(iter),\n         sequence_(s),\n         direction_(kForward),\n-        valid_(false) {\n+        valid_(false),\n+        rnd_(seed),\n+        bytes_counter_(RandomPeriod()) {\n   }\n   virtual ~DBIter() {\n     delete iter_;\n@@ -100,8 +103,12 @@ class DBIter: public Iterator {\n     }\n   }\n \n-  const std::string* const dbname_;\n-  Env* const env_;\n+  // Pick next gap with average value of config::kReadBytesPeriod.\n+  ssize_t RandomPeriod() {\n+    return rnd_.Uniform(2*config::kReadBytesPeriod);\n+  }\n+\n+  DBImpl* db_;\n   const Comparator* const user_comparator_;\n   Iterator* const iter_;\n   SequenceNumber const sequence_;\n@@ -112,13 +119,23 @@ class DBIter: public Iterator {\n   Direction direction_;\n   bool valid_;\n \n+  Random rnd_;\n+  ssize_t bytes_counter_;\n+\n   // No copying allowed\n   DBIter(const DBIter&);\n   void operator=(const DBIter&);\n };\n \n inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n-  if (!ParseInternalKey(iter_->key(), ikey)) {\n+  Slice k = iter_->key();\n+  ssize_t n = k.size() + iter_->value().size();\n+  bytes_counter_ -= n;\n+  while (bytes_counter_ < 0) {\n+    bytes_counter_ += RandomPeriod();\n+    db_->RecordReadSample(k);\n+  }\n+  if (!ParseInternalKey(k, ikey)) {\n     status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n     return false;\n   } else {\n@@ -288,12 +305,12 @@ void DBIter::SeekToLast() {\n }  // anonymous namespace\n \n Iterator* NewDBIterator(\n-    const std::string* dbname,\n-    Env* env,\n+    DBImpl* db,\n     const Comparator* user_key_comparator,\n     Iterator* internal_iter,\n-    const SequenceNumber& sequence) {\n-  return new DBIter(dbname, env, user_key_comparator, internal_iter, sequence);\n+    SequenceNumber sequence,\n+    uint32_t seed) {\n+  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);\n }\n \n }  // namespace leveldb"
      },
      {
        "sha": "04927e937badff3b29592ec9266d305c44b85b4c",
        "filename": "db/db_iter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_iter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/db_iter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_iter.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -11,15 +11,17 @@\n \n namespace leveldb {\n \n+class DBImpl;\n+\n // Return a new iterator that converts internal keys (yielded by\n // \"*internal_iter\") that were live at the specified \"sequence\" number\n // into appropriate user keys.\n extern Iterator* NewDBIterator(\n-    const std::string* dbname,\n-    Env* env,\n+    DBImpl* db,\n     const Comparator* user_key_comparator,\n     Iterator* internal_iter,\n-    const SequenceNumber& sequence);\n+    SequenceNumber sequence,\n+    uint32_t seed);\n \n }  // namespace leveldb\n "
      },
      {
        "sha": "5d8a032bd3166d2449cedad45305a123b2c6b180",
        "filename": "db/dbformat.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/dbformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/dbformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/dbformat.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -38,6 +38,9 @@ static const int kL0_StopWritesTrigger = 12;\n // space if the same key space is being repeatedly overwritten.\n static const int kMaxMemCompactLevel = 2;\n \n+// Approximate gap in bytes between samples of data read during iteration.\n+static const int kReadBytesPeriod = 1048576;\n+\n }  // namespace config\n \n class InternalKey;"
      },
      {
        "sha": "66d73be71fbbe1b2af4ba4b1460ee7dcb62f1b96",
        "filename": "db/version_set.cc",
        "status": "modified",
        "additions": 92,
        "deletions": 4,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/version_set.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -289,6 +289,51 @@ static bool NewestFirst(FileMetaData* a, FileMetaData* b) {\n   return a->number > b->number;\n }\n \n+void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n+                                 void* arg,\n+                                 bool (*func)(void*, int, FileMetaData*)) {\n+  // TODO(sanjay): Change Version::Get() to use this function.\n+  const Comparator* ucmp = vset_->icmp_.user_comparator();\n+\n+  // Search level-0 in order from newest to oldest.\n+  std::vector<FileMetaData*> tmp;\n+  tmp.reserve(files_[0].size());\n+  for (uint32_t i = 0; i < files_[0].size(); i++) {\n+    FileMetaData* f = files_[0][i];\n+    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n+        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n+      tmp.push_back(f);\n+    }\n+  }\n+  if (!tmp.empty()) {\n+    std::sort(tmp.begin(), tmp.end(), NewestFirst);\n+    for (uint32_t i = 0; i < tmp.size(); i++) {\n+      if (!(*func)(arg, 0, tmp[i])) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  // Search other levels.\n+  for (int level = 1; level < config::kNumLevels; level++) {\n+    size_t num_files = files_[level].size();\n+    if (num_files == 0) continue;\n+\n+    // Binary search to find earliest index whose largest key >= internal_key.\n+    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n+    if (index < num_files) {\n+      FileMetaData* f = files_[level][index];\n+      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n+        // All of \"f\" is past any data for user_key\n+      } else {\n+        if (!(*func)(arg, level, f)) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n Status Version::Get(const ReadOptions& options,\n                     const LookupKey& k,\n                     std::string* value,\n@@ -401,6 +446,44 @@ bool Version::UpdateStats(const GetStats& stats) {\n   return false;\n }\n \n+bool Version::RecordReadSample(Slice internal_key) {\n+  ParsedInternalKey ikey;\n+  if (!ParseInternalKey(internal_key, &ikey)) {\n+    return false;\n+  }\n+\n+  struct State {\n+    GetStats stats;  // Holds first matching file\n+    int matches;\n+\n+    static bool Match(void* arg, int level, FileMetaData* f) {\n+      State* state = reinterpret_cast<State*>(arg);\n+      state->matches++;\n+      if (state->matches == 1) {\n+        // Remember first match.\n+        state->stats.seek_file = f;\n+        state->stats.seek_file_level = level;\n+      }\n+      // We can stop iterating once we have a second match.\n+      return state->matches < 2;\n+    }\n+  };\n+\n+  State state;\n+  state.matches = 0;\n+  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);\n+\n+  // Must have at least two matches since we want to merge across\n+  // files. But what if we have a single file that contains many\n+  // overwrites and deletions?  Should we have another mechanism for\n+  // finding such files?\n+  if (state.matches >= 2) {\n+    // 1MB cost is about 1 seek (see comment in Builder::Apply).\n+    return UpdateStats(state.stats);\n+  }\n+  return false;\n+}\n+\n void Version::Ref() {\n   ++refs_;\n }\n@@ -435,10 +518,13 @@ int Version::PickLevelForMemTableOutput(\n       if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n         break;\n       }\n-      GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n-      const int64_t sum = TotalFileSize(overlaps);\n-      if (sum > kMaxGrandParentOverlapBytes) {\n-        break;\n+      if (level + 2 < config::kNumLevels) {\n+        // Check that file does not overlap too many grandparent bytes.\n+        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n+        const int64_t sum = TotalFileSize(overlaps);\n+        if (sum > kMaxGrandParentOverlapBytes) {\n+          break;\n+        }\n       }\n       level++;\n     }\n@@ -452,6 +538,8 @@ void Version::GetOverlappingInputs(\n     const InternalKey* begin,\n     const InternalKey* end,\n     std::vector<FileMetaData*>* inputs) {\n+  assert(level >= 0);\n+  assert(level < config::kNumLevels);\n   inputs->clear();\n   Slice user_begin, user_end;\n   if (begin != NULL) {"
      },
      {
        "sha": "20de0e262914cbd538879d55101c5639eb28e1c3",
        "filename": "db/version_set.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/version_set.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -78,6 +78,12 @@ class Version {\n   // REQUIRES: lock is held\n   bool UpdateStats(const GetStats& stats);\n \n+  // Record a sample of bytes read at the specified internal key.\n+  // Samples are taken approximately once every config::kReadBytesPeriod\n+  // bytes.  Returns true if a new compaction may need to be triggered.\n+  // REQUIRES: lock is held\n+  bool RecordReadSample(Slice key);\n+\n   // Reference count management (so Versions do not disappear out from\n   // under live iterators)\n   void Ref();\n@@ -114,6 +120,15 @@ class Version {\n   class LevelFileNumIterator;\n   Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;\n \n+  // Call func(arg, level, f) for every file that overlaps user_key in\n+  // order from newest to oldest.  If an invocation of func returns\n+  // false, makes no more calls.\n+  //\n+  // REQUIRES: user portion of internal_key == user_key.\n+  void ForEachOverlapping(Slice user_key, Slice internal_key,\n+                          void* arg,\n+                          bool (*func)(void*, int, FileMetaData*));\n+\n   VersionSet* vset_;            // VersionSet to which this Version belongs\n   Version* next_;               // Next version in linked list\n   Version* prev_;               // Previous version in linked list"
      },
      {
        "sha": "57c00a5da005881fa2ad0763b0787b20c6b411c1",
        "filename": "include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/leveldb/db.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 12;\n+static const int kMinorVersion = 13;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "0f5dcfac5a4baf51831534b74224c33585b35326",
        "filename": "util/env_posix.cc",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_posix.cc?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -320,8 +320,39 @@ class PosixMmapFile : public WritableFile {\n     return Status::OK();\n   }\n \n-  virtual Status Sync() {\n+  Status SyncDirIfManifest() {\n+    const char* f = filename_.c_str();\n+    const char* sep = strrchr(f, '/');\n+    Slice basename;\n+    std::string dir;\n+    if (sep == NULL) {\n+      dir = \".\";\n+      basename = f;\n+    } else {\n+      dir = std::string(f, sep - f);\n+      basename = sep + 1;\n+    }\n     Status s;\n+    if (basename.starts_with(\"MANIFEST\")) {\n+      int fd = open(dir.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        s = IOError(dir, errno);\n+      } else {\n+        if (fsync(fd) < 0) {\n+          s = IOError(dir, errno);\n+        }\n+        close(fd);\n+      }\n+    }\n+    return s;\n+  }\n+\n+  virtual Status Sync() {\n+    // Ensure new files referred to by the manifest are in the filesystem.\n+    Status s = SyncDirIfManifest();\n+    if (!s.ok()) {\n+      return s;\n+    }\n \n     if (pending_sync_) {\n       // Some unmapped data was not synced"
      },
      {
        "sha": "ddd51b1c7b51743ea34fcfa14a9dec61b38ff577",
        "filename": "util/random.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/util/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3/util/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/random.h?ref=eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "patch": "@@ -16,7 +16,12 @@ class Random {\n  private:\n   uint32_t seed_;\n  public:\n-  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) { }\n+  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {\n+    // Avoid bad seeds.\n+    if (seed_ == 0 || seed_ == 2147483647L) {\n+      seed_ = 1;\n+    }\n+  }\n   uint32_t Next() {\n     static const uint32_t M = 2147483647L;   // 2^31-1\n     static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0"
      }
    ]
  },
  {
    "sha": "877b5e3653f12882e12c75aa0bb5be47f847bd09",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NzdiNWUzNjUzZjEyODgyZTEyYzc1YWEwYmI1YmU0N2Y4NDdiZDA5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-08-24T20:21:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-08-24T20:21:41Z"
      },
      "message": "Merge src/leveldb changes for LevelDB 1.13",
      "tree": {
        "sha": "399b43ec4298fdefe16fd9c33e684b3e58867755",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/399b43ec4298fdefe16fd9c33e684b3e58867755"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/877b5e3653f12882e12c75aa0bb5be47f847bd09",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/877b5e3653f12882e12c75aa0bb5be47f847bd09",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/877b5e3653f12882e12c75aa0bb5be47f847bd09",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/877b5e3653f12882e12c75aa0bb5be47f847bd09/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9e2ef5fbd610fbaa3801440254c39ac4ba8f91d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9e2ef5fbd610fbaa3801440254c39ac4ba8f91d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9e2ef5fbd610fbaa3801440254c39ac4ba8f91d"
      },
      {
        "sha": "eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eed29f0f50806b9cfe9653509e7ed7f7eebdd3e3"
      }
    ],
    "stats": {
      "total": 430,
      "additions": 363,
      "deletions": 67
    },
    "files": [
      {
        "sha": "20c9c4f28751a716e6279940d723e357ba1f088c",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -31,6 +31,7 @@ TESTHARNESS = ./util/testharness.o $(TESTUTIL)\n \n TESTS = \\\n \tarena_test \\\n+\tautocompact_test \\\n \tbloom_test \\\n \tc_test \\\n \tcache_test \\\n@@ -70,7 +71,7 @@ SHARED = $(SHARED1)\n else\n # Update db.h if you change these.\n SHARED_MAJOR = 1\n-SHARED_MINOR = 12\n+SHARED_MINOR = 13\n SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)\n@@ -114,6 +115,9 @@ leveldbutil: db/leveldb_main.o $(LIBOBJECTS)\n arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+autocompact_test: db/autocompact_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) db/autocompact_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n bloom_test: util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n "
      },
      {
        "sha": "d20a2362c30c49d9cc2b1e2f65a2f829905eb3f8",
        "filename": "src/leveldb/db/autocompact_test.cc",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/autocompact_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/autocompact_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/autocompact_test.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2013 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/db.h\"\n+#include \"db/db_impl.h\"\n+#include \"leveldb/cache.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+class AutoCompactTest {\n+ public:\n+  std::string dbname_;\n+  Cache* tiny_cache_;\n+  Options options_;\n+  DB* db_;\n+\n+  AutoCompactTest() {\n+    dbname_ = test::TmpDir() + \"/autocompact_test\";\n+    tiny_cache_ = NewLRUCache(100);\n+    options_.block_cache = tiny_cache_;\n+    DestroyDB(dbname_, options_);\n+    options_.create_if_missing = true;\n+    options_.compression = kNoCompression;\n+    ASSERT_OK(DB::Open(options_, dbname_, &db_));\n+  }\n+\n+  ~AutoCompactTest() {\n+    delete db_;\n+    DestroyDB(dbname_, Options());\n+    delete tiny_cache_;\n+  }\n+\n+  std::string Key(int i) {\n+    char buf[100];\n+    snprintf(buf, sizeof(buf), \"key%06d\", i);\n+    return std::string(buf);\n+  }\n+\n+  uint64_t Size(const Slice& start, const Slice& limit) {\n+    Range r(start, limit);\n+    uint64_t size;\n+    db_->GetApproximateSizes(&r, 1, &size);\n+    return size;\n+  }\n+\n+  void DoReads(int n);\n+};\n+\n+static const int kValueSize = 200 * 1024;\n+static const int kTotalSize = 100 * 1024 * 1024;\n+static const int kCount = kTotalSize / kValueSize;\n+\n+// Read through the first n keys repeatedly and check that they get\n+// compacted (verified by checking the size of the key space).\n+void AutoCompactTest::DoReads(int n) {\n+  std::string value(kValueSize, 'x');\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+\n+  // Fill database\n+  for (int i = 0; i < kCount; i++) {\n+    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n+  }\n+  ASSERT_OK(dbi->TEST_CompactMemTable());\n+\n+  // Delete everything\n+  for (int i = 0; i < kCount; i++) {\n+    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n+  }\n+  ASSERT_OK(dbi->TEST_CompactMemTable());\n+\n+  // Get initial measurement of the space we will be reading.\n+  const int64_t initial_size = Size(Key(0), Key(n));\n+  const int64_t initial_other_size = Size(Key(n), Key(kCount));\n+\n+  // Read until size drops significantly.\n+  std::string limit_key = Key(n);\n+  for (int read = 0; true; read++) {\n+    ASSERT_LT(read, 100) << \"Taking too long to compact\";\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    for (iter->SeekToFirst();\n+         iter->Valid() && iter->key().ToString() < limit_key;\n+         iter->Next()) {\n+      // Drop data\n+    }\n+    delete iter;\n+    // Wait a little bit to allow any triggered compactions to complete.\n+    Env::Default()->SleepForMicroseconds(1000000);\n+    uint64_t size = Size(Key(0), Key(n));\n+    fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n+            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n+    if (size <= initial_size/10) {\n+      break;\n+    }\n+  }\n+\n+  // Verify that the size of the key space not touched by the reads\n+  // is pretty much unchanged.\n+  const int64_t final_other_size = Size(Key(n), Key(kCount));\n+  ASSERT_LE(final_other_size, initial_other_size + 1048576);\n+  ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n+}\n+\n+TEST(AutoCompactTest, ReadAll) {\n+  DoReads(kCount);\n+}\n+\n+TEST(AutoCompactTest, ReadHalf) {\n+  DoReads(kCount/2);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "b37ffdfe645cdb7c65e6f4680776b38c668394a9",
        "filename": "src/leveldb/db/corruption_test.cc",
        "status": "modified",
        "additions": 22,
        "deletions": 29,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/corruption_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/corruption_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/corruption_test.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -35,6 +35,7 @@ class CorruptionTest {\n   CorruptionTest() {\n     tiny_cache_ = NewLRUCache(100);\n     options_.env = &env_;\n+    options_.block_cache = tiny_cache_;\n     dbname_ = test::TmpDir() + \"/db_test\";\n     DestroyDB(dbname_, options_);\n \n@@ -50,17 +51,14 @@ class CorruptionTest {\n      delete tiny_cache_;\n   }\n \n-  Status TryReopen(Options* options = NULL) {\n+  Status TryReopen() {\n     delete db_;\n     db_ = NULL;\n-    Options opt = (options ? *options : options_);\n-    opt.env = &env_;\n-    opt.block_cache = tiny_cache_;\n-    return DB::Open(opt, dbname_, &db_);\n+    return DB::Open(options_, dbname_, &db_);\n   }\n \n-  void Reopen(Options* options = NULL) {\n-    ASSERT_OK(TryReopen(options));\n+  void Reopen() {\n+    ASSERT_OK(TryReopen());\n   }\n \n   void RepairDB() {\n@@ -92,6 +90,10 @@ class CorruptionTest {\n     for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n       uint64_t key;\n       Slice in(iter->key());\n+      if (in == \"\" || in == \"~\") {\n+        // Ignore boundary keys.\n+        continue;\n+      }\n       if (!ConsumeDecimalNumber(&in, &key) ||\n           !in.empty() ||\n           key < next_expected) {\n@@ -233,7 +235,7 @@ TEST(CorruptionTest, TableFile) {\n   dbi->TEST_CompactRange(1, NULL, NULL);\n \n   Corrupt(kTableFile, 100, 1);\n-  Check(99, 99);\n+  Check(90, 99);\n }\n \n TEST(CorruptionTest, TableFileIndexData) {\n@@ -299,40 +301,31 @@ TEST(CorruptionTest, CompactionInputError) {\n   ASSERT_EQ(1, Property(\"leveldb.num-files-at-level\" + NumberToString(last)));\n \n   Corrupt(kTableFile, 100, 1);\n-  Check(9, 9);\n+  Check(5, 9);\n \n   // Force compactions by writing lots of values\n   Build(10000);\n   Check(10000, 10000);\n }\n \n TEST(CorruptionTest, CompactionInputErrorParanoid) {\n-  Options options;\n-  options.paranoid_checks = true;\n-  options.write_buffer_size = 1048576;\n-  Reopen(&options);\n+  options_.paranoid_checks = true;\n+  options_.write_buffer_size = 512 << 10;\n+  Reopen();\n   DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n \n-  // Fill levels >= 1 so memtable compaction outputs to level 1\n-  for (int level = 1; level < config::kNumLevels; level++) {\n-    dbi->Put(WriteOptions(), \"\", \"begin\");\n-    dbi->Put(WriteOptions(), \"~\", \"end\");\n+  // Make multiple inputs so we need to compact.\n+  for (int i = 0; i < 2; i++) {\n+    Build(10);\n     dbi->TEST_CompactMemTable();\n+    Corrupt(kTableFile, 100, 1);\n+    env_.SleepForMicroseconds(100000);\n   }\n+  dbi->CompactRange(NULL, NULL);\n \n-  Build(10);\n-  dbi->TEST_CompactMemTable();\n-  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level0\"));\n-\n-  Corrupt(kTableFile, 100, 1);\n-  Check(9, 9);\n-\n-  // Write must eventually fail because of corrupted table\n-  Status s;\n+  // Write must fail because of corrupted table\n   std::string tmp1, tmp2;\n-  for (int i = 0; i < 10000 && s.ok(); i++) {\n-    s = db_->Put(WriteOptions(), Key(i, &tmp1), Value(i, &tmp2));\n-  }\n+  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));\n   ASSERT_TRUE(!s.ok()) << \"write did not fail in corrupted paranoid db\";\n }\n "
      },
      {
        "sha": "fa1351038bcb0b1c224dc566fb16d6806966cc62",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -113,14 +113,14 @@ Options SanitizeOptions(const std::string& dbname,\n   return result;\n }\n \n-DBImpl::DBImpl(const Options& options, const std::string& dbname)\n-    : env_(options.env),\n-      internal_comparator_(options.comparator),\n-      internal_filter_policy_(options.filter_policy),\n-      options_(SanitizeOptions(\n-          dbname, &internal_comparator_, &internal_filter_policy_, options)),\n-      owns_info_log_(options_.info_log != options.info_log),\n-      owns_cache_(options_.block_cache != options.block_cache),\n+DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)\n+    : env_(raw_options.env),\n+      internal_comparator_(raw_options.comparator),\n+      internal_filter_policy_(raw_options.filter_policy),\n+      options_(SanitizeOptions(dbname, &internal_comparator_,\n+                               &internal_filter_policy_, raw_options)),\n+      owns_info_log_(options_.info_log != raw_options.info_log),\n+      owns_cache_(options_.block_cache != raw_options.block_cache),\n       dbname_(dbname),\n       db_lock_(NULL),\n       shutting_down_(NULL),\n@@ -130,6 +130,7 @@ DBImpl::DBImpl(const Options& options, const std::string& dbname)\n       logfile_(NULL),\n       logfile_number_(0),\n       log_(NULL),\n+      seed_(0),\n       tmp_batch_(new WriteBatch),\n       bg_compaction_scheduled_(false),\n       manual_compaction_(NULL),\n@@ -138,7 +139,7 @@ DBImpl::DBImpl(const Options& options, const std::string& dbname)\n   has_imm_.Release_Store(NULL);\n \n   // Reserve ten files or so for other uses and give the rest to TableCache.\n-  const int table_cache_size = options.max_open_files - kNumNonTableCacheFiles;\n+  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;\n   table_cache_ = new TableCache(dbname_, &options_, table_cache_size);\n \n   versions_ = new VersionSet(dbname_, &options_, table_cache_,\n@@ -1027,7 +1028,8 @@ static void CleanupIteratorState(void* arg1, void* arg2) {\n }  // namespace\n \n Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,\n-                                      SequenceNumber* latest_snapshot) {\n+                                      SequenceNumber* latest_snapshot,\n+                                      uint32_t* seed) {\n   IterState* cleanup = new IterState;\n   mutex_.Lock();\n   *latest_snapshot = versions_->LastSequence();\n@@ -1051,13 +1053,15 @@ Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,\n   cleanup->version = versions_->current();\n   internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);\n \n+  *seed = ++seed_;\n   mutex_.Unlock();\n   return internal_iter;\n }\n \n Iterator* DBImpl::TEST_NewInternalIterator() {\n   SequenceNumber ignored;\n-  return NewInternalIterator(ReadOptions(), &ignored);\n+  uint32_t ignored_seed;\n+  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);\n }\n \n int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {\n@@ -1114,12 +1118,21 @@ Status DBImpl::Get(const ReadOptions& options,\n \n Iterator* DBImpl::NewIterator(const ReadOptions& options) {\n   SequenceNumber latest_snapshot;\n-  Iterator* internal_iter = NewInternalIterator(options, &latest_snapshot);\n+  uint32_t seed;\n+  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);\n   return NewDBIterator(\n-      &dbname_, env_, user_comparator(), internal_iter,\n+      this, user_comparator(), iter,\n       (options.snapshot != NULL\n        ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_\n-       : latest_snapshot));\n+       : latest_snapshot),\n+      seed);\n+}\n+\n+void DBImpl::RecordReadSample(Slice key) {\n+  MutexLock l(&mutex_);\n+  if (versions_->current()->RecordReadSample(key)) {\n+    MaybeScheduleCompaction();\n+  }\n }\n \n const Snapshot* DBImpl::GetSnapshot() {"
      },
      {
        "sha": "75fd30abe9a56bd663537baa20b2104b349f645f",
        "filename": "src/leveldb/db/db_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -59,13 +59,19 @@ class DBImpl : public DB {\n   // file at a level >= 1.\n   int64_t TEST_MaxNextLevelOverlappingBytes();\n \n+  // Record a sample of bytes read at the specified internal key.\n+  // Samples are taken approximately once every config::kReadBytesPeriod\n+  // bytes.\n+  void RecordReadSample(Slice key);\n+\n  private:\n   friend class DB;\n   struct CompactionState;\n   struct Writer;\n \n   Iterator* NewInternalIterator(const ReadOptions&,\n-                                SequenceNumber* latest_snapshot);\n+                                SequenceNumber* latest_snapshot,\n+                                uint32_t* seed);\n \n   Status NewDB();\n \n@@ -135,6 +141,7 @@ class DBImpl : public DB {\n   WritableFile* logfile_;\n   uint64_t logfile_number_;\n   log::Writer* log_;\n+  uint32_t seed_;                // For sampling.\n \n   // Queue of writers.\n   std::deque<Writer*> writers_;"
      },
      {
        "sha": "071a54e3f457a02d726b3c0f53212a92ddf0c8de",
        "filename": "src/leveldb/db/db_iter.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 12,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_iter.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_iter.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_iter.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -5,12 +5,14 @@\n #include \"db/db_iter.h\"\n \n #include \"db/filename.h\"\n+#include \"db/db_impl.h\"\n #include \"db/dbformat.h\"\n #include \"leveldb/env.h\"\n #include \"leveldb/iterator.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n+#include \"util/random.h\"\n \n namespace leveldb {\n \n@@ -46,15 +48,16 @@ class DBIter: public Iterator {\n     kReverse\n   };\n \n-  DBIter(const std::string* dbname, Env* env,\n-         const Comparator* cmp, Iterator* iter, SequenceNumber s)\n-      : dbname_(dbname),\n-        env_(env),\n+  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,\n+         uint32_t seed)\n+      : db_(db),\n         user_comparator_(cmp),\n         iter_(iter),\n         sequence_(s),\n         direction_(kForward),\n-        valid_(false) {\n+        valid_(false),\n+        rnd_(seed),\n+        bytes_counter_(RandomPeriod()) {\n   }\n   virtual ~DBIter() {\n     delete iter_;\n@@ -100,8 +103,12 @@ class DBIter: public Iterator {\n     }\n   }\n \n-  const std::string* const dbname_;\n-  Env* const env_;\n+  // Pick next gap with average value of config::kReadBytesPeriod.\n+  ssize_t RandomPeriod() {\n+    return rnd_.Uniform(2*config::kReadBytesPeriod);\n+  }\n+\n+  DBImpl* db_;\n   const Comparator* const user_comparator_;\n   Iterator* const iter_;\n   SequenceNumber const sequence_;\n@@ -112,13 +119,23 @@ class DBIter: public Iterator {\n   Direction direction_;\n   bool valid_;\n \n+  Random rnd_;\n+  ssize_t bytes_counter_;\n+\n   // No copying allowed\n   DBIter(const DBIter&);\n   void operator=(const DBIter&);\n };\n \n inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n-  if (!ParseInternalKey(iter_->key(), ikey)) {\n+  Slice k = iter_->key();\n+  ssize_t n = k.size() + iter_->value().size();\n+  bytes_counter_ -= n;\n+  while (bytes_counter_ < 0) {\n+    bytes_counter_ += RandomPeriod();\n+    db_->RecordReadSample(k);\n+  }\n+  if (!ParseInternalKey(k, ikey)) {\n     status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n     return false;\n   } else {\n@@ -288,12 +305,12 @@ void DBIter::SeekToLast() {\n }  // anonymous namespace\n \n Iterator* NewDBIterator(\n-    const std::string* dbname,\n-    Env* env,\n+    DBImpl* db,\n     const Comparator* user_key_comparator,\n     Iterator* internal_iter,\n-    const SequenceNumber& sequence) {\n-  return new DBIter(dbname, env, user_key_comparator, internal_iter, sequence);\n+    SequenceNumber sequence,\n+    uint32_t seed) {\n+  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);\n }\n \n }  // namespace leveldb"
      },
      {
        "sha": "04927e937badff3b29592ec9266d305c44b85b4c",
        "filename": "src/leveldb/db/db_iter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_iter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/db_iter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_iter.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -11,15 +11,17 @@\n \n namespace leveldb {\n \n+class DBImpl;\n+\n // Return a new iterator that converts internal keys (yielded by\n // \"*internal_iter\") that were live at the specified \"sequence\" number\n // into appropriate user keys.\n extern Iterator* NewDBIterator(\n-    const std::string* dbname,\n-    Env* env,\n+    DBImpl* db,\n     const Comparator* user_key_comparator,\n     Iterator* internal_iter,\n-    const SequenceNumber& sequence);\n+    SequenceNumber sequence,\n+    uint32_t seed);\n \n }  // namespace leveldb\n "
      },
      {
        "sha": "5d8a032bd3166d2449cedad45305a123b2c6b180",
        "filename": "src/leveldb/db/dbformat.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/dbformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/dbformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/dbformat.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -38,6 +38,9 @@ static const int kL0_StopWritesTrigger = 12;\n // space if the same key space is being repeatedly overwritten.\n static const int kMaxMemCompactLevel = 2;\n \n+// Approximate gap in bytes between samples of data read during iteration.\n+static const int kReadBytesPeriod = 1048576;\n+\n }  // namespace config\n \n class InternalKey;"
      },
      {
        "sha": "66d73be71fbbe1b2af4ba4b1460ee7dcb62f1b96",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 92,
        "deletions": 4,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -289,6 +289,51 @@ static bool NewestFirst(FileMetaData* a, FileMetaData* b) {\n   return a->number > b->number;\n }\n \n+void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n+                                 void* arg,\n+                                 bool (*func)(void*, int, FileMetaData*)) {\n+  // TODO(sanjay): Change Version::Get() to use this function.\n+  const Comparator* ucmp = vset_->icmp_.user_comparator();\n+\n+  // Search level-0 in order from newest to oldest.\n+  std::vector<FileMetaData*> tmp;\n+  tmp.reserve(files_[0].size());\n+  for (uint32_t i = 0; i < files_[0].size(); i++) {\n+    FileMetaData* f = files_[0][i];\n+    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n+        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n+      tmp.push_back(f);\n+    }\n+  }\n+  if (!tmp.empty()) {\n+    std::sort(tmp.begin(), tmp.end(), NewestFirst);\n+    for (uint32_t i = 0; i < tmp.size(); i++) {\n+      if (!(*func)(arg, 0, tmp[i])) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  // Search other levels.\n+  for (int level = 1; level < config::kNumLevels; level++) {\n+    size_t num_files = files_[level].size();\n+    if (num_files == 0) continue;\n+\n+    // Binary search to find earliest index whose largest key >= internal_key.\n+    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n+    if (index < num_files) {\n+      FileMetaData* f = files_[level][index];\n+      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n+        // All of \"f\" is past any data for user_key\n+      } else {\n+        if (!(*func)(arg, level, f)) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n Status Version::Get(const ReadOptions& options,\n                     const LookupKey& k,\n                     std::string* value,\n@@ -401,6 +446,44 @@ bool Version::UpdateStats(const GetStats& stats) {\n   return false;\n }\n \n+bool Version::RecordReadSample(Slice internal_key) {\n+  ParsedInternalKey ikey;\n+  if (!ParseInternalKey(internal_key, &ikey)) {\n+    return false;\n+  }\n+\n+  struct State {\n+    GetStats stats;  // Holds first matching file\n+    int matches;\n+\n+    static bool Match(void* arg, int level, FileMetaData* f) {\n+      State* state = reinterpret_cast<State*>(arg);\n+      state->matches++;\n+      if (state->matches == 1) {\n+        // Remember first match.\n+        state->stats.seek_file = f;\n+        state->stats.seek_file_level = level;\n+      }\n+      // We can stop iterating once we have a second match.\n+      return state->matches < 2;\n+    }\n+  };\n+\n+  State state;\n+  state.matches = 0;\n+  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);\n+\n+  // Must have at least two matches since we want to merge across\n+  // files. But what if we have a single file that contains many\n+  // overwrites and deletions?  Should we have another mechanism for\n+  // finding such files?\n+  if (state.matches >= 2) {\n+    // 1MB cost is about 1 seek (see comment in Builder::Apply).\n+    return UpdateStats(state.stats);\n+  }\n+  return false;\n+}\n+\n void Version::Ref() {\n   ++refs_;\n }\n@@ -435,10 +518,13 @@ int Version::PickLevelForMemTableOutput(\n       if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n         break;\n       }\n-      GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n-      const int64_t sum = TotalFileSize(overlaps);\n-      if (sum > kMaxGrandParentOverlapBytes) {\n-        break;\n+      if (level + 2 < config::kNumLevels) {\n+        // Check that file does not overlap too many grandparent bytes.\n+        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n+        const int64_t sum = TotalFileSize(overlaps);\n+        if (sum > kMaxGrandParentOverlapBytes) {\n+          break;\n+        }\n       }\n       level++;\n     }\n@@ -452,6 +538,8 @@ void Version::GetOverlappingInputs(\n     const InternalKey* begin,\n     const InternalKey* end,\n     std::vector<FileMetaData*>* inputs) {\n+  assert(level >= 0);\n+  assert(level < config::kNumLevels);\n   inputs->clear();\n   Slice user_begin, user_end;\n   if (begin != NULL) {"
      },
      {
        "sha": "20de0e262914cbd538879d55101c5639eb28e1c3",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -78,6 +78,12 @@ class Version {\n   // REQUIRES: lock is held\n   bool UpdateStats(const GetStats& stats);\n \n+  // Record a sample of bytes read at the specified internal key.\n+  // Samples are taken approximately once every config::kReadBytesPeriod\n+  // bytes.  Returns true if a new compaction may need to be triggered.\n+  // REQUIRES: lock is held\n+  bool RecordReadSample(Slice key);\n+\n   // Reference count management (so Versions do not disappear out from\n   // under live iterators)\n   void Ref();\n@@ -114,6 +120,15 @@ class Version {\n   class LevelFileNumIterator;\n   Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;\n \n+  // Call func(arg, level, f) for every file that overlaps user_key in\n+  // order from newest to oldest.  If an invocation of func returns\n+  // false, makes no more calls.\n+  //\n+  // REQUIRES: user portion of internal_key == user_key.\n+  void ForEachOverlapping(Slice user_key, Slice internal_key,\n+                          void* arg,\n+                          bool (*func)(void*, int, FileMetaData*));\n+\n   VersionSet* vset_;            // VersionSet to which this Version belongs\n   Version* next_;               // Next version in linked list\n   Version* prev_;               // Previous version in linked list"
      },
      {
        "sha": "57c00a5da005881fa2ad0763b0787b20c6b411c1",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 12;\n+static const int kMinorVersion = 13;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "0f5dcfac5a4baf51831534b74224c33585b35326",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -320,8 +320,39 @@ class PosixMmapFile : public WritableFile {\n     return Status::OK();\n   }\n \n-  virtual Status Sync() {\n+  Status SyncDirIfManifest() {\n+    const char* f = filename_.c_str();\n+    const char* sep = strrchr(f, '/');\n+    Slice basename;\n+    std::string dir;\n+    if (sep == NULL) {\n+      dir = \".\";\n+      basename = f;\n+    } else {\n+      dir = std::string(f, sep - f);\n+      basename = sep + 1;\n+    }\n     Status s;\n+    if (basename.starts_with(\"MANIFEST\")) {\n+      int fd = open(dir.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        s = IOError(dir, errno);\n+      } else {\n+        if (fsync(fd) < 0) {\n+          s = IOError(dir, errno);\n+        }\n+        close(fd);\n+      }\n+    }\n+    return s;\n+  }\n+\n+  virtual Status Sync() {\n+    // Ensure new files referred to by the manifest are in the filesystem.\n+    Status s = SyncDirIfManifest();\n+    if (!s.ok()) {\n+      return s;\n+    }\n \n     if (pending_sync_) {\n       // Some unmapped data was not synced"
      },
      {
        "sha": "ddd51b1c7b51743ea34fcfa14a9dec61b38ff577",
        "filename": "src/leveldb/util/random.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/util/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/877b5e3653f12882e12c75aa0bb5be47f847bd09/src/leveldb/util/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/random.h?ref=877b5e3653f12882e12c75aa0bb5be47f847bd09",
        "patch": "@@ -16,7 +16,12 @@ class Random {\n  private:\n   uint32_t seed_;\n  public:\n-  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) { }\n+  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {\n+    // Avoid bad seeds.\n+    if (seed_ == 0 || seed_ == 2147483647L) {\n+      seed_ = 1;\n+    }\n+  }\n   uint32_t Next() {\n     static const uint32_t M = 2147483647L;   // 2^31-1\n     static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0"
      }
    ]
  }
]