[
  {
    "sha": "bebb637472d0469037a9f438572fc71db4236d97",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZWJiNjM3NDcyZDA0NjkwMzdhOWY0Mzg1NzJmYzcxZGI0MjM2ZDk3",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-08T15:15:26Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-10T21:13:33Z"
      },
      "message": "tests: Add FuzzedDataProvider fuzzing helper from the Chromium project\n\nSource: https://cs.chromium.org/chromium/src/third_party/libFuzzer/src/utils/FuzzedDataProvider.h?rcl=b9f51dc8c98065df0c8da13c051046f5bab833db",
      "tree": {
        "sha": "e455b3d53422063fe5ffc7ece87c60ecc8d8949d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e455b3d53422063fe5ffc7ece87c60ecc8d8949d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bebb637472d0469037a9f438572fc71db4236d97",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bebb637472d0469037a9f438572fc71db4236d97",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bebb637472d0469037a9f438572fc71db4236d97",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bebb637472d0469037a9f438572fc71db4236d97/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a0164085b001a79b8d37b28751b115322124cfc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a0164085b001a79b8d37b28751b115322124cfc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a0164085b001a79b8d37b28751b115322124cfc"
      }
    ],
    "stats": {
      "total": 252,
      "additions": 249,
      "deletions": 3
    },
    "files": [
      {
        "sha": "b3fcdf3a0685a5ff0e8e0466a375efbf4897a3a7",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bebb637472d0469037a9f438572fc71db4236d97/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bebb637472d0469037a9f438572fc71db4236d97/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=bebb637472d0469037a9f438572fc71db4236d97",
        "patch": "@@ -59,7 +59,8 @@ FUZZ_SUITE = \\\n   test/setup_common.h \\\n   test/setup_common.cpp \\\n   test/fuzz/fuzz.cpp \\\n-  test/fuzz/fuzz.h\n+  test/fuzz/fuzz.h \\\n+  test/fuzz/FuzzedDataProvider.h\n \n FUZZ_SUITE_LD_COMMON = \\\n  $(LIBBITCOIN_SERVER) \\"
      },
      {
        "sha": "1b5b4bb0126965f3f4ffe754cd2134389248aa8f",
        "filename": "src/test/fuzz/FuzzedDataProvider.h",
        "status": "added",
        "additions": 245,
        "deletions": 0,
        "changes": 245,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bebb637472d0469037a9f438572fc71db4236d97/src/test/fuzz/FuzzedDataProvider.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bebb637472d0469037a9f438572fc71db4236d97/src/test/fuzz/FuzzedDataProvider.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/FuzzedDataProvider.h?ref=bebb637472d0469037a9f438572fc71db4236d97",
        "patch": "@@ -0,0 +1,245 @@\n+//===- FuzzedDataProvider.h - Utility header for fuzz targets ---*- C++ -* ===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+// A single header library providing an utility class to break up an array of\n+// bytes. Whenever run on the same input, provides the same output, as long as\n+// its methods are called in the same order, with the same arguments.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_\n+#define LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_\n+\n+#include <limits.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <initializer_list>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+class FuzzedDataProvider {\n+public:\n+  // |data| is an array of length |size| that the FuzzedDataProvider wraps to\n+  // provide more granular access. |data| must outlive the FuzzedDataProvider.\n+  FuzzedDataProvider(const uint8_t *data, size_t size)\n+      : data_ptr_(data), remaining_bytes_(size) {}\n+  ~FuzzedDataProvider() = default;\n+\n+  // Returns a std::vector containing |num_bytes| of input data. If fewer than\n+  // |num_bytes| of data remain, returns a shorter std::vector containing all\n+  // of the data that's left. Can be used with any byte sized type, such as\n+  // char, unsigned char, uint8_t, etc.\n+  template <typename T> std::vector<T> ConsumeBytes(size_t num_bytes) {\n+    num_bytes = std::min(num_bytes, remaining_bytes_);\n+    return ConsumeBytes<T>(num_bytes, num_bytes);\n+  }\n+\n+  // Similar to |ConsumeBytes|, but also appends the terminator value at the end\n+  // of the resulting vector. Useful, when a mutable null-terminated C-string is\n+  // needed, for example. But that is a rare case. Better avoid it, if possible,\n+  // and prefer using |ConsumeBytes| or |ConsumeBytesAsString| methods.\n+  template <typename T>\n+  std::vector<T> ConsumeBytesWithTerminator(size_t num_bytes,\n+                                            T terminator = 0) {\n+    num_bytes = std::min(num_bytes, remaining_bytes_);\n+    std::vector<T> result = ConsumeBytes<T>(num_bytes + 1, num_bytes);\n+    result.back() = terminator;\n+    return result;\n+  }\n+\n+  // Returns a std::string containing |num_bytes| of input data. Using this and\n+  // |.c_str()| on the resulting string is the best way to get an immutable\n+  // null-terminated C string. If fewer than |num_bytes| of data remain, returns\n+  // a shorter std::string containing all of the data that's left.\n+  std::string ConsumeBytesAsString(size_t num_bytes) {\n+    static_assert(sizeof(std::string::value_type) == sizeof(uint8_t),\n+                  \"ConsumeBytesAsString cannot convert the data to a string.\");\n+\n+    num_bytes = std::min(num_bytes, remaining_bytes_);\n+    std::string result(\n+        reinterpret_cast<const std::string::value_type *>(data_ptr_),\n+        num_bytes);\n+    Advance(num_bytes);\n+    return result;\n+  }\n+\n+  // Returns a number in the range [min, max] by consuming bytes from the\n+  // input data. The value might not be uniformly distributed in the given\n+  // range. If there's no input data left, always returns |min|. |min| must\n+  // be less than or equal to |max|.\n+  template <typename T> T ConsumeIntegralInRange(T min, T max) {\n+    static_assert(std::is_integral<T>::value, \"An integral type is required.\");\n+    static_assert(sizeof(T) <= sizeof(uint64_t), \"Unsupported integral type.\");\n+\n+    if (min > max)\n+      abort();\n+\n+    // Use the biggest type possible to hold the range and the result.\n+    uint64_t range = static_cast<uint64_t>(max) - min;\n+    uint64_t result = 0;\n+    size_t offset = 0;\n+\n+    while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&\n+           remaining_bytes_ != 0) {\n+      // Pull bytes off the end of the seed data. Experimentally, this seems to\n+      // allow the fuzzer to more easily explore the input space. This makes\n+      // sense, since it works by modifying inputs that caused new code to run,\n+      // and this data is often used to encode length of data read by\n+      // |ConsumeBytes|. Separating out read lengths makes it easier modify the\n+      // contents of the data that is actually read.\n+      --remaining_bytes_;\n+      result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];\n+      offset += CHAR_BIT;\n+    }\n+\n+    // Avoid division by 0, in case |range + 1| results in overflow.\n+    if (range != std::numeric_limits<decltype(range)>::max())\n+      result = result % (range + 1);\n+\n+    return static_cast<T>(min + result);\n+  }\n+\n+  // Returns a std::string of length from 0 to |max_length|. When it runs out of\n+  // input data, returns what remains of the input. Designed to be more stable\n+  // with respect to a fuzzer inserting characters than just picking a random\n+  // length and then consuming that many bytes with |ConsumeBytes|.\n+  std::string ConsumeRandomLengthString(size_t max_length) {\n+    // Reads bytes from the start of |data_ptr_|. Maps \"\\\\\" to \"\\\", and maps \"\\\"\n+    // followed by anything else to the end of the string. As a result of this\n+    // logic, a fuzzer can insert characters into the string, and the string\n+    // will be lengthened to include those new characters, resulting in a more\n+    // stable fuzzer than picking the length of a string independently from\n+    // picking its contents.\n+    std::string result;\n+\n+    // Reserve the anticipated capaticity to prevent several reallocations.\n+    result.reserve(std::min(max_length, remaining_bytes_));\n+    for (size_t i = 0; i < max_length && remaining_bytes_ != 0; ++i) {\n+      char next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n+      Advance(1);\n+      if (next == '\\\\' && remaining_bytes_ != 0) {\n+        next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n+        Advance(1);\n+        if (next != '\\\\')\n+          break;\n+      }\n+      result += next;\n+    }\n+\n+    result.shrink_to_fit();\n+    return result;\n+  }\n+\n+  // Returns a std::vector containing all remaining bytes of the input data.\n+  template <typename T> std::vector<T> ConsumeRemainingBytes() {\n+    return ConsumeBytes<T>(remaining_bytes_);\n+  }\n+\n+  // Prefer using |ConsumeRemainingBytes| unless you actually need a std::string\n+  // object.\n+  // Returns a std::vector containing all remaining bytes of the input data.\n+  std::string ConsumeRemainingBytesAsString() {\n+    return ConsumeBytesAsString(remaining_bytes_);\n+  }\n+\n+  // Returns a number in the range [Type's min, Type's max]. The value might\n+  // not be uniformly distributed in the given range. If there's no input data\n+  // left, always returns |min|.\n+  template <typename T> T ConsumeIntegral() {\n+    return ConsumeIntegralInRange(std::numeric_limits<T>::min(),\n+                                  std::numeric_limits<T>::max());\n+  }\n+\n+  // Reads one byte and returns a bool, or false when no data remains.\n+  bool ConsumeBool() { return 1 & ConsumeIntegral<uint8_t>(); }\n+\n+  // Returns a copy of a value selected from a fixed-size |array|.\n+  template <typename T, size_t size>\n+  T PickValueInArray(const T (&array)[size]) {\n+    static_assert(size > 0, \"The array must be non empty.\");\n+    return array[ConsumeIntegralInRange<size_t>(0, size - 1)];\n+  }\n+\n+  template <typename T>\n+  T PickValueInArray(std::initializer_list<const T> list) {\n+    // static_assert(list.size() > 0, \"The array must be non empty.\");\n+    return *(list.begin() + ConsumeIntegralInRange<size_t>(0, list.size() - 1));\n+  }\n+\n+  // Return an enum value. The enum must start at 0 and be contiguous. It must\n+  // also contain |kMaxValue| aliased to its largest (inclusive) value. Such as:\n+  // enum class Foo { SomeValue, OtherValue, kMaxValue = OtherValue };\n+  template <typename T> T ConsumeEnum() {\n+    static_assert(std::is_enum<T>::value, \"|T| must be an enum type.\");\n+    return static_cast<T>(ConsumeIntegralInRange<uint32_t>(\n+        0, static_cast<uint32_t>(T::kMaxValue)));\n+  }\n+\n+  // Reports the remaining bytes available for fuzzed input.\n+  size_t remaining_bytes() { return remaining_bytes_; }\n+\n+private:\n+  FuzzedDataProvider(const FuzzedDataProvider &) = delete;\n+  FuzzedDataProvider &operator=(const FuzzedDataProvider &) = delete;\n+\n+  void Advance(size_t num_bytes) {\n+    if (num_bytes > remaining_bytes_)\n+      abort();\n+\n+    data_ptr_ += num_bytes;\n+    remaining_bytes_ -= num_bytes;\n+  }\n+\n+  template <typename T>\n+  std::vector<T> ConsumeBytes(size_t size, size_t num_bytes_to_consume) {\n+    static_assert(sizeof(T) == sizeof(uint8_t), \"Incompatible data type.\");\n+\n+    // The point of using the size-based constructor below is to increase the\n+    // odds of having a vector object with capacity being equal to the length.\n+    // That part is always implementation specific, but at least both libc++ and\n+    // libstdc++ allocate the requested number of bytes in that constructor,\n+    // which seems to be a natural choice for other implementations as well.\n+    // To increase the odds even more, we also call |shrink_to_fit| below.\n+    std::vector<T> result(size);\n+    std::memcpy(result.data(), data_ptr_, num_bytes_to_consume);\n+    Advance(num_bytes_to_consume);\n+\n+    // Even though |shrink_to_fit| is also implementation specific, we expect it\n+    // to provide an additional assurance in case vector's constructor allocated\n+    // a buffer which is larger than the actual amount of data we put inside it.\n+    result.shrink_to_fit();\n+    return result;\n+  }\n+\n+  template <typename TS, typename TU> TS ConvertUnsignedToSigned(TU value) {\n+    static_assert(sizeof(TS) == sizeof(TU), \"Incompatible data types.\");\n+    static_assert(!std::numeric_limits<TU>::is_signed,\n+                  \"Source type must be unsigned.\");\n+\n+    // TODO(Dor1s): change to `if constexpr` once C++17 becomes mainstream.\n+    if (std::numeric_limits<TS>::is_modulo)\n+      return static_cast<TS>(value);\n+\n+    // Avoid using implementation-defined unsigned to signer conversions.\n+    // To learn more, see https://stackoverflow.com/questions/13150449.\n+    if (value <= std::numeric_limits<TS>::max())\n+      return static_cast<TS>(value);\n+    else {\n+      constexpr auto TS_min = std::numeric_limits<TS>::min();\n+      return TS_min + static_cast<char>(value - TS_min);\n+    }\n+  }\n+\n+  const uint8_t *data_ptr_;\n+  size_t remaining_bytes_;\n+};\n+\n+#endif // LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_"
      },
      {
        "sha": "6716cac0fe240bbcb32630eb0db3fc0a0a835ad7",
        "filename": "test/lint/lint-filenames.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bebb637472d0469037a9f438572fc71db4236d97/test/lint/lint-filenames.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bebb637472d0469037a9f438572fc71db4236d97/test/lint/lint-filenames.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-filenames.sh?ref=bebb637472d0469037a9f438572fc71db4236d97",
        "patch": "@@ -12,7 +12,7 @@ export LC_ALL=C\n EXIT_CODE=0\n OUTPUT=$(git ls-files --full-name -- \"*.[cC][pP][pP]\" \"*.[hH]\" \"*.[pP][yY]\" \"*.[sS][hH]\" | \\\n     grep -vE '^[a-z0-9_./-]+$' | \\\n-    grep -vE '^src/(secp256k1|univalue)/')\n+    grep -vE '^src/(secp256k1/|univalue/|test/fuzz/FuzzedDataProvider.h)')\n \n if [[ ${OUTPUT} != \"\" ]]; then\n     echo \"Use only lowercase alphanumerics (a-z0-9), underscores (_), hyphens (-) and dots (.)\""
      },
      {
        "sha": "0d654e796ebc0f1c3317e15bd9f5e0a642ba0403",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bebb637472d0469037a9f438572fc71db4236d97/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bebb637472d0469037a9f438572fc71db4236d97/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=bebb637472d0469037a9f438572fc71db4236d97",
        "patch": "@@ -10,7 +10,7 @@ export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n \n-REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|univalue/)\"\n \n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")"
      }
    ]
  },
  {
    "sha": "7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTUwYWJjYzI5ZGM1ZmRlMjRhMWIzZTU3YzYzMTZlYWJkYTM1ZTJl",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-08T15:17:14Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-12T16:42:21Z"
      },
      "message": "tests: Add EvalScript(...) fuzzing harness",
      "tree": {
        "sha": "6a431a084d9ee914cc0172d4c7c9a98793eb7ab6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a431a084d9ee914cc0172d4c7c9a98793eb7ab6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bebb637472d0469037a9f438572fc71db4236d97",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bebb637472d0469037a9f438572fc71db4236d97",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bebb637472d0469037a9f438572fc71db4236d97"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 37,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b8957e52bdca3f33c3a3d9de8b0029e6ff445868",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
        "patch": "@@ -17,6 +17,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/bloomfilter_deserialize \\\n   test/fuzz/coins_deserialize \\\n   test/fuzz/diskblockindex_deserialize \\\n+  test/fuzz/eval_script \\\n   test/fuzz/inv_deserialize \\\n   test/fuzz/messageheader_deserialize \\\n   test/fuzz/netaddr_deserialize \\\n@@ -299,6 +300,12 @@ test_fuzz_diskblockindex_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_diskblockindex_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_diskblockindex_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n+test_fuzz_eval_script_SOURCES = $(FUZZ_SUITE) test/fuzz/eval_script.cpp\n+test_fuzz_eval_script_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_eval_script_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_eval_script_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_eval_script_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+\n test_fuzz_txoutcompressor_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_txoutcompressor_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTXOUTCOMPRESSOR_DESERIALIZE=1\n test_fuzz_txoutcompressor_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)"
      },
      {
        "sha": "9444cd489ea447e41f1a11c6bb1ce4aa42f217b4",
        "filename": "src/test/fuzz/eval_script.cpp",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e/src/test/fuzz/eval_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e50abcc29dc5fde24a1b3e57c6316eabda35e2e/src/test/fuzz/eval_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/eval_script.cpp?ref=7e50abcc29dc5fde24a1b3e57c6316eabda35e2e",
        "patch": "@@ -0,0 +1,30 @@\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/interpreter.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <limits>\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const unsigned int flags = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+    const std::vector<uint8_t> script_bytes = [&] {\n+        if (fuzzed_data_provider.remaining_bytes() != 0) {\n+            return fuzzed_data_provider.ConsumeRemainingBytes<uint8_t>();\n+        } else {\n+            // Avoid UBSan warning:\n+            //   test/fuzz/FuzzedDataProvider.h:212:17: runtime error: null pointer passed as argument 1, which is declared to never be null\n+            //   /usr/include/string.h:43:28: note: nonnull attribute specified here\n+            return std::vector<uint8_t>();\n+        }\n+    }();\n+    const CScript script(script_bytes.begin(), script_bytes.end());\n+    for (const auto sig_version : {SigVersion::BASE, SigVersion::WITNESS_V0}) {\n+        std::vector<std::vector<unsigned char>> stack;\n+        (void)EvalScript(stack, script, flags, BaseSignatureChecker(), sig_version, nullptr);\n+    }\n+}"
      }
    ]
  }
]