[
  {
    "sha": "fa81c30c6f1adac79517c958090db174eb6aeda2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTgxYzMwYzZmMWFkYWM3OTUxN2M5NTgwOTBkYjE3NGViNmFlZGEy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-18T07:46:01Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T08:32:24Z"
      },
      "message": "refactor: Move pruning/reindex/importing globals to blockstorage\n\nCan be reviewed with --color-moved=dimmed-zebra",
      "tree": {
        "sha": "a83760d0de2e77e6e4ad28877bc3a1616b52461e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a83760d0de2e77e6e4ad28877bc3a1616b52461e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa81c30c6f1adac79517c958090db174eb6aeda2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgz9wv/bN98sN6cX+ITY6STwL2qRv4XLE/ovqDvc6zg6x18s4OHvTTEM3ZbZfLX\nglFwh16x/JwiwV21hqSvFZCXIm/6If3/ssEebTRZlmKjHl+4euh3Xs7tdYc03QEK\n9dTy8qn0MufVLh0YXzvO4N0lRZmJ0GIvz/r4458TVgOV822v2wfwXBbb5wwVdah3\nXsWIpH1xErRk8vQRjIuK2MrBUgOrlGBzsiCoMevIAbS+tQjfTZCcvMO9A3mOE0Qt\nCznhg/meBznPxLLdxgjK7P550wvFwA11dHWN8IW3uzGbRn1hy/tovvtKUsyB6H/j\nt6BtRRsIovU4A+iRDdSa7MWWgol5aUHaj+aBRKA2/l1GXWdKv3Q/KSTOWlBgraO1\nUtSPbaI9GL4yXVps0IIkxbWVJTqcV9VpBcW76zCKzdLsBODOhecl6fVuF1cfuacS\nJ7VUtxju9w5O7RIVLRYLuBFC7/dKA4L0S6ohq8YN97H6dXj7JITtUTCaG83oE9AJ\n3dOFscnJ\n=prtL\n-----END PGP SIGNATURE-----",
        "payload": "tree a83760d0de2e77e6e4ad28877bc3a1616b52461e\nparent 19a56d1519fb493c3e1bd5cad55360b6b80fa52b\nauthor MarcoFalke <falke.marco@gmail.com> 1618731961 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1619512344 +0200\n\nrefactor: Move pruning/reindex/importing globals to blockstorage\n\nCan be reviewed with --color-moved=dimmed-zebra\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa81c30c6f1adac79517c958090db174eb6aeda2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa81c30c6f1adac79517c958090db174eb6aeda2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa81c30c6f1adac79517c958090db174eb6aeda2/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "19a56d1519fb493c3e1bd5cad55360b6b80fa52b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19a56d1519fb493c3e1bd5cad55360b6b80fa52b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/19a56d1519fb493c3e1bd5cad55360b6b80fa52b"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 68,
      "deletions": 62
    },
    "files": [
      {
        "sha": "e8b4cfeda2b641f71cedaf61928cc10a96b9e866",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 41,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -593,47 +593,6 @@ static void BlockNotifyGenesisWait(const CBlockIndex* pBlockIndex)\n     }\n }\n \n-// If we're using -prune with -reindex, then delete block files that will be ignored by the\n-// reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile\n-// is missing, do the same here to delete any later block files after a gap.  Also delete all\n-// rev files since they'll be rewritten by the reindex anyway.  This ensures that vinfoBlockFile\n-// is in sync with what's actually on disk by the time we start downloading, so that pruning\n-// works correctly.\n-static void CleanupBlockRevFiles()\n-{\n-    std::map<std::string, fs::path> mapBlockFiles;\n-\n-    // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n-    // Remove the rev files immediately and insert the blk file paths into an\n-    // ordered map keyed by block file index.\n-    LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    fs::path blocksdir = gArgs.GetBlocksDirPath();\n-    for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n-        if (fs::is_regular_file(*it) &&\n-            it->path().filename().string().length() == 12 &&\n-            it->path().filename().string().substr(8,4) == \".dat\")\n-        {\n-            if (it->path().filename().string().substr(0,3) == \"blk\")\n-                mapBlockFiles[it->path().filename().string().substr(3,5)] = it->path();\n-            else if (it->path().filename().string().substr(0,3) == \"rev\")\n-                remove(it->path());\n-        }\n-    }\n-\n-    // Remove all block files that aren't part of a contiguous set starting at\n-    // zero by walking the ordered map (keys are block file indices) by\n-    // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n-    // start removing block files.\n-    int nContigCounter = 0;\n-    for (const std::pair<const std::string, fs::path>& item : mapBlockFiles) {\n-        if (atoi(item.first) == nContigCounter) {\n-            nContigCounter++;\n-            continue;\n-        }\n-        remove(item.second);\n-    }\n-}\n-\n #if HAVE_SYSTEM\n static void StartupNotify(const ArgsManager& args)\n {"
      },
      {
        "sha": "8ee0fb8d50b7107e2cbadd4040beafef96880ed4",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -15,6 +15,58 @@\n #include <util/system.h>\n #include <validation.h>\n \n+std::atomic_bool fImporting(false);\n+std::atomic_bool fReindex(false);\n+bool fHavePruned = false;\n+bool fPruneMode = false;\n+uint64_t nPruneTarget = 0;\n+\n+bool IsBlockPruned(const CBlockIndex* pblockindex)\n+{\n+    return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);\n+}\n+\n+// If we're using -prune with -reindex, then delete block files that will be ignored by the\n+// reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile\n+// is missing, do the same here to delete any later block files after a gap.  Also delete all\n+// rev files since they'll be rewritten by the reindex anyway.  This ensures that vinfoBlockFile\n+// is in sync with what's actually on disk by the time we start downloading, so that pruning\n+// works correctly.\n+void CleanupBlockRevFiles()\n+{\n+    std::map<std::string, fs::path> mapBlockFiles;\n+\n+    // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n+    // Remove the rev files immediately and insert the blk file paths into an\n+    // ordered map keyed by block file index.\n+    LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n+    fs::path blocksdir = gArgs.GetBlocksDirPath();\n+    for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n+        if (fs::is_regular_file(*it) &&\n+            it->path().filename().string().length() == 12 &&\n+            it->path().filename().string().substr(8,4) == \".dat\")\n+        {\n+            if (it->path().filename().string().substr(0,3) == \"blk\")\n+                mapBlockFiles[it->path().filename().string().substr(3,5)] = it->path();\n+            else if (it->path().filename().string().substr(0,3) == \"rev\")\n+                remove(it->path());\n+        }\n+    }\n+\n+    // Remove all block files that aren't part of a contiguous set starting at\n+    // zero by walking the ordered map (keys are block file indices) by\n+    // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n+    // start removing block files.\n+    int nContigCounter = 0;\n+    for (const std::pair<const std::string, fs::path>& item : mapBlockFiles) {\n+        if (atoi(item.first) == nContigCounter) {\n+            nContigCounter++;\n+            continue;\n+        }\n+        remove(item.second);\n+    }\n+}\n+\n // From validation. TODO move here\n bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false);\n "
      },
      {
        "sha": "a5c822030db2a6dc70565cd6406dd8a2413fa63f",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -25,6 +25,21 @@ struct Params;\n \n static constexpr bool DEFAULT_STOPAFTERBLOCKIMPORT{false};\n \n+extern std::atomic_bool fImporting;\n+extern std::atomic_bool fReindex;\n+/** Pruning-related variables and constants */\n+/** True if any block files have ever been pruned. */\n+extern bool fHavePruned;\n+/** True if we're running in -prune mode. */\n+extern bool fPruneMode;\n+/** Number of MiB of block files that we're trying to stay below. */\n+extern uint64_t nPruneTarget;\n+\n+//! Check whether the block associated with this index entry is pruned or not.\n+bool IsBlockPruned(const CBlockIndex* pblockindex);\n+\n+void CleanupBlockRevFiles();\n+\n /** Functions for disk access for blocks */\n bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);\n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);"
      },
      {
        "sha": "0850d0451a5b4ac3010c31ecff981a397d52a808",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -135,14 +135,9 @@ Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n uint256 g_best_block;\n bool g_parallel_script_checks{false};\n-std::atomic_bool fImporting(false);\n-std::atomic_bool fReindex(false);\n-bool fHavePruned = false;\n-bool fPruneMode = false;\n bool fRequireStandard = true;\n bool fCheckBlockIndex = false;\n bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED;\n-uint64_t nPruneTarget = 0;\n int64_t nMaxTipAge = DEFAULT_MAX_TIP_AGE;\n \n uint256 hashAssumeValid;"
      },
      {
        "sha": "bd5a0b46e5e8483381f1733a68b5e108f471970b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -112,8 +112,6 @@ typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n extern uint256 g_best_block;\n-extern std::atomic_bool fImporting;\n-extern std::atomic_bool fReindex;\n /** Whether there are dedicated script-checking threads running.\n  * False indicates all script checking is done on the main threadMessageHandler thread.\n  */\n@@ -135,13 +133,6 @@ extern arith_uint256 nMinimumChainWork;\n /** Best header we've seen so far (used for getheaders queries' starting points). */\n extern CBlockIndex *pindexBestHeader;\n \n-/** Pruning-related variables and constants */\n-/** True if any block files have ever been pruned. */\n-extern bool fHavePruned;\n-/** True if we're running in -prune mode. */\n-extern bool fPruneMode;\n-/** Number of MiB of block files that we're trying to stay below. */\n-extern uint64_t nPruneTarget;\n /** Documentation for argument 'checklevel'. */\n extern const std::vector<std::string> CHECKLEVEL_DOC;\n \n@@ -1012,12 +1003,6 @@ bool DumpMempool(const CTxMemPool& pool, FopenFn mockable_fopen_function = fsbri\n /** Load the mempool from disk. */\n bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate, FopenFn mockable_fopen_function = fsbridge::fopen);\n \n-//! Check whether the block associated with this index entry is pruned or not.\n-inline bool IsBlockPruned(const CBlockIndex* pblockindex)\n-{\n-    return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);\n-}\n-\n /**\n  * Return the expected assumeutxo value for a given height, if one exists.\n  *"
      },
      {
        "sha": "737d35a397e873f84b3ec13d0a91808ae15f70ce",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa81c30c6f1adac79517c958090db174eb6aeda2/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa81c30c6f1adac79517c958090db174eb6aeda2/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=fa81c30c6f1adac79517c958090db174eb6aeda2",
        "patch": "@@ -43,7 +43,7 @@ KNOWN_VIOLATIONS=(\n     \"src/dbwrapper.cpp.*stoul\"\n     \"src/dbwrapper.cpp:.*vsnprintf\"\n     \"src/httprpc.cpp.*trim\"\n-    \"src/init.cpp:.*atoi\"\n+    \"src/node/blockstorage.cpp:.*atoi\"\n     \"src/qt/rpcconsole.cpp:.*atoi\"\n     \"src/rest.cpp:.*strtol\"\n     \"src/test/dbwrapper_tests.cpp:.*snprintf\""
      }
    ]
  },
  {
    "sha": "fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTI0N2EzMjdmYzdjN2NlYTZiYzhmOTM2MzdiOGJhYmQzMDE1ZmZh",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-18T13:41:08Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T08:32:30Z"
      },
      "message": "refactor: Move block storage globals to blockstorage\n\nHowever, keep a declaration in validation to make it possible to move\nsmaller chunks to blockstorage without breaking compilation.\n\nAlso, expose AbortNode in the header.\n\nCan be reviewed with --color-moved=dimmed-zebra --color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "d35a5f17859dfd23b02f1976a0bddcb80f9fedda",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d35a5f17859dfd23b02f1976a0bddcb80f9fedda"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUj5WQv/UbnT8/7Z7tWv/cPicurZDsTmiRyaGWcyvOBVJV0pWKu0jg0bmJft31Lk\nsNb9tLI9pSQ5VdIcDm52JSPYiho8RqzkxAIBqtDnRo3Wqntu7jGlNW1LpPM2vRMA\n5EqRQ53R+GQAGnm81C398bc8ugViOuBF0ywvJw0di1kFaHZXpwwLflTxS2leddsT\nhtJXHTLfLyxCZdrENfJEzgwaNwXnywmAxqY/977QOyz290HPcDh8w735r/8Yymle\n1NVBvOB7KHLtBV5ruyMqfwj5uaixKB9v2/v60gJ370kHaluX21HTppVGC/bniwUa\n37+rGJL1sKZL/XH9gtZKeml9Z2i1FLdKGCNa0Zw6xbe5+GBqRiJljuVXP8VzQlxq\n9646JFi5oPeBE1Uk2PxV3LrfZvL6vwX2boD4uDFRwygrxEo2qT7ig8C4MIo+4sh0\nFcUJ8HMb2dQSfLIlYCgLkfPs3DQ95omEDecwOsm3bwRSkuty4m+6sRZya5EXyGKS\n0ga2r+7E\n=Cu9r\n-----END PGP SIGNATURE-----",
        "payload": "tree d35a5f17859dfd23b02f1976a0bddcb80f9fedda\nparent fa81c30c6f1adac79517c958090db174eb6aeda2\nauthor MarcoFalke <falke.marco@gmail.com> 1618753268 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1619512350 +0200\n\nrefactor: Move block storage globals to blockstorage\n\nHowever, keep a declaration in validation to make it possible to move\nsmaller chunks to blockstorage without breaking compilation.\n\nAlso, expose AbortNode in the header.\n\nCan be reviewed with --color-moved=dimmed-zebra --color-moved-ws=ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa81c30c6f1adac79517c958090db174eb6aeda2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa81c30c6f1adac79517c958090db174eb6aeda2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa81c30c6f1adac79517c958090db174eb6aeda2"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 30,
      "deletions": 16
    },
    "files": [
      {
        "sha": "d84a3c90298fabb6970627ed9e08e1f747e30ba9",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
        "patch": "@@ -21,6 +21,23 @@ bool fHavePruned = false;\n bool fPruneMode = false;\n uint64_t nPruneTarget = 0;\n \n+// TODO make namespace {\n+RecursiveMutex cs_LastBlockFile;\n+std::vector<CBlockFileInfo> vinfoBlockFile;\n+int nLastBlockFile = 0;\n+/** Global flag to indicate we should check to see if there are\n+*  block/undo files that should be deleted.  Set on startup\n+*  or if we allocate more file space when we're in prune mode\n+*/\n+bool fCheckForPruning = false;\n+\n+/** Dirty block index entries. */\n+std::set<CBlockIndex*> setDirtyBlockIndex;\n+\n+/** Dirty block file entries. */\n+std::set<int> setDirtyFileInfo;\n+// } // namespace\n+\n bool IsBlockPruned(const CBlockIndex* pblockindex)\n {\n     return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);"
      },
      {
        "sha": "1704ae4e0134e2ae57fd32025d8a9d6acec99f24",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
        "patch": "@@ -148,22 +148,16 @@ CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n // Internal stuff\n namespace {\n     CBlockIndex* pindexBestInvalid = nullptr;\n+} // namespace\n \n-    RecursiveMutex cs_LastBlockFile;\n-    std::vector<CBlockFileInfo> vinfoBlockFile;\n-    int nLastBlockFile = 0;\n-    /** Global flag to indicate we should check to see if there are\n-     *  block/undo files that should be deleted.  Set on startup\n-     *  or if we allocate more file space when we're in prune mode\n-     */\n-    bool fCheckForPruning = false;\n-\n-    /** Dirty block index entries. */\n-    std::set<CBlockIndex*> setDirtyBlockIndex;\n-\n-    /** Dirty block file entries. */\n-    std::set<int> setDirtyFileInfo;\n-} // anon namespace\n+// Internal stuff from blockstorage ...\n+extern RecursiveMutex cs_LastBlockFile;\n+extern std::vector<CBlockFileInfo> vinfoBlockFile;\n+extern int nLastBlockFile;\n+extern bool fCheckForPruning;\n+extern std::set<CBlockIndex*> setDirtyBlockIndex;\n+extern std::set<int> setDirtyFileInfo;\n+// ... TODO move fully to blockstorage\n \n CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n {\n@@ -1515,7 +1509,7 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n     return true;\n }\n \n-static bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage = bilingual_str())\n+bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage)\n {\n     AbortNode(strMessage, userMessage);\n     return state.Error(strMessage);"
      },
      {
        "sha": "7c161a1095c3982fbad1b868ce5d99eb83daed60",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa247a327fc7c7cea6bc8f93637b8babd3015ffa/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
        "patch": "@@ -27,6 +27,7 @@\n #include <serialize.h>\n #include <util/check.h>\n #include <util/hasher.h>\n+#include <util/translation.h>\n \n #include <atomic>\n #include <map>\n@@ -161,6 +162,8 @@ void StopScriptCheckWorkerThreads();\n CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock);\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n \n+bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage = bilingual_str{});\n+\n /** Guess verification progress (as a fraction between 0.0=genesis and 1.0=current tip). */\n double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex* pindex);\n "
      }
    ]
  },
  {
    "sha": "fa7e64d58615fffea91cd64dc4a2790221ceff0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTdlNjRkNTg2MTVmZmZlYTkxY2Q2NGRjNGEyNzkwMjIxY2VmZjBh",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-18T14:31:53Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T08:32:54Z"
      },
      "message": "move-only: Move constants to blockstorage",
      "tree": {
        "sha": "146b29200b14b057ee0b9886b25f739ef5b2a454",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/146b29200b14b057ee0b9886b25f739ef5b2a454"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa7e64d58615fffea91cd64dc4a2790221ceff0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjOjwwAqNPRHnw7VazFGfoYGA3a4WulExhPH80sUaTo7D4jz0VkE784y2lOnA+A\nvU3QEKWxqsWqiJnEWipCdT19F+mSMvTVenpfDuA0RJreFOSIR43PRmKpe/PexMPj\nIrXum7gu4WPROiJMAMnIkwiLNR3yaIyxLvBmSxmAPKGVkmi/XgreVlB3LYyQUSAo\nywb6azFHVmQVFQlp/zL2VIfQw8ZjPJWHKrXk38IviPLDzAHBHBiJDVygiXGfdD2R\nzBnEgNalYC5rLFk7x+6KA0qOs6eKbwGPaYE5KDT0YtXSpJshvEHwPIYHoq19wVjP\n56Av6mC9L7bLox/lTwGULzS/CmE72uAgTw4PNeEDaE3kT6Wy7ypm/0RQ96BpAsGM\ncVkdjx9B2GALwod8mMoNU65j1qANIlhw5Bq/DecMefoufcuRylkWlN1Zuw/6/Tno\ndUZ+3wm99/PpQgA8RrbFjJzyd/p2MVOEW+YK2/qyyPHogwxiakCXZBgZ+9z0ug6/\nu0KpeyVS\n=fEqT\n-----END PGP SIGNATURE-----",
        "payload": "tree 146b29200b14b057ee0b9886b25f739ef5b2a454\nparent fa247a327fc7c7cea6bc8f93637b8babd3015ffa\nauthor MarcoFalke <falke.marco@gmail.com> 1618756313 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1619512374 +0200\n\nmove-only: Move constants to blockstorage\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7e64d58615fffea91cd64dc4a2790221ceff0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa7e64d58615fffea91cd64dc4a2790221ceff0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7e64d58615fffea91cd64dc4a2790221ceff0a/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa247a327fc7c7cea6bc8f93637b8babd3015ffa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa247a327fc7c7cea6bc8f93637b8babd3015ffa"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 8,
      "deletions": 6
    },
    "files": [
      {
        "sha": "2cef3abd66d4af945ca17d216e178a6953aba5a3",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "patch": "@@ -25,6 +25,13 @@ struct Params;\n \n static constexpr bool DEFAULT_STOPAFTERBLOCKIMPORT{false};\n \n+/** The pre-allocation chunk size for blk?????.dat files (since 0.8) */\n+static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n+/** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n+static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n+/** The maximum size of a blk?????.dat file (since 0.8) */\n+static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n+\n extern std::atomic_bool fImporting;\n extern std::atomic_bool fReindex;\n /** Pruning-related variables and constants */"
      },
      {
        "sha": "c8a3eab4a4256d4a7a4eeed76eb66e899878598f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "patch": "@@ -66,10 +66,6 @@\n static const unsigned int EXTRA_DESCENDANT_TX_SIZE_LIMIT = 10000;\n /** Maximum kilobytes for transactions to store for processing during reorg */\n static const unsigned int MAX_DISCONNECTED_TX_POOL_SIZE = 20000;\n-/** The pre-allocation chunk size for blk?????.dat files (since 0.8) */\n-static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n-/** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n-static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n /** Time to wait between writing blocks/block index to disk. */\n static constexpr std::chrono::hours DATABASE_WRITE_INTERVAL{1};\n /** Time to wait between flushing chainstate to disk. */"
      },
      {
        "sha": "0e9c6ba198bc2b405489001ac7474cb865386a58",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "patch": "@@ -71,8 +71,6 @@ static const unsigned int DEFAULT_DESCENDANT_LIMIT = 25;\n static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101;\n /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 336;\n-/** The maximum size of a blk?????.dat file (since 0.8) */\n-static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** Maximum number of dedicated script-checking threads allowed */\n static const int MAX_SCRIPTCHECK_THREADS = 15;\n /** -par default (number of script-checking threads, 0 = auto) */"
      },
      {
        "sha": "c8e3c8f819cf240aecfb8049d47fd896b619c6e0",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7e64d58615fffea91cd64dc4a2790221ceff0a/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "patch": "@@ -11,6 +11,7 @@\n #include <vector>\n \n #include <interfaces/chain.h>\n+#include <node/blockstorage.h>\n #include <node/context.h>\n #include <policy/policy.h>\n #include <rpc/server.h>"
      }
    ]
  },
  {
    "sha": "fadafab83379ff10d86ada179c6f9641d19464fe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWRhZmFiODMzNzlmZjEwZDg2YWRhMTc5YzZmOTY0MWQxOTQ2NGZl",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-18T15:09:48Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T08:36:23Z"
      },
      "message": "move-only: Move functions to blockstorage",
      "tree": {
        "sha": "88dd8aafc84abf3c96e261f2a6436e0f3834300e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88dd8aafc84abf3c96e261f2a6436e0f3834300e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fadafab83379ff10d86ada179c6f9641d19464fe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGyBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjnxQv3Vsyzf7BFgxS7peNlskSQ1v9wmCKU9t4MJ3Xby9eKbjbsz3XzZbo+9+G6\nYIubYXm8Gw+lnl+06XKBDCUyu98s3zOLRoR9GMR76JPzGgzYAyo3Y2r8SLuIIk3r\nl+RI4cpMzqPCfJ/duVfZxpWSf9vdQlPV/fMee6y6PXBgUmUhLpVYGw8MjWJxf3Nk\neQv7846YzKcvmOl+k4gfKGyYM3YJ1koHjOv6zlAjUn04AuiW/JwT7llSO8Dbqmlp\nUgt1DP/v6NzXVWKYgtm8xEeJAT4wjer0Ks9Y6GUV8pPWb3bX+Y3Sriy8JyUC+BJw\nGk5WIrqqMhj7WABEkk6TwH2KrOsD110syQvjmJyazQ4Whhp37XS9FI5+N2M7emvj\n558BlsVR/vVQiN1jcm/pfIpmQk+Z/x4UpT2JYBWa17YeIgw4dV+/tCUwQ+0DptKR\nzofJhChELx+Cx0xTrUOaWR8L9VU10RpMoa8RQeSV0Z4XEK+/cgzOdONyqWdgj2kD\nl8t1D6M=\n=9ksF\n-----END PGP SIGNATURE-----",
        "payload": "tree 88dd8aafc84abf3c96e261f2a6436e0f3834300e\nparent fa7e64d58615fffea91cd64dc4a2790221ceff0a\nauthor MarcoFalke <falke.marco@gmail.com> 1618758588 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1619512583 +0200\n\nmove-only: Move functions to blockstorage\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fadafab83379ff10d86ada179c6f9641d19464fe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fadafab83379ff10d86ada179c6f9641d19464fe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fadafab83379ff10d86ada179c6f9641d19464fe/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7e64d58615fffea91cd64dc4a2790221ceff0a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa7e64d58615fffea91cd64dc4a2790221ceff0a"
      }
    ],
    "stats": {
      "total": 531,
      "additions": 267,
      "deletions": 264
    },
    "files": [
      {
        "sha": "50fe3040a1fc38c3d659a63c88ce45fbcde08a73",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fadafab83379ff10d86ada179c6f9641d19464fe/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fadafab83379ff10d86ada179c6f9641d19464fe/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=fadafab83379ff10d86ada179c6f9641d19464fe",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <index/disktxpos.h>\n #include <index/txindex.h>\n+#include <node/blockstorage.h>\n #include <node/ui_interface.h>\n #include <shutdown.h>\n #include <util/system.h>"
      },
      {
        "sha": "39c9acd7c6beeff1b027a029b9762e57338a5e42",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 246,
        "deletions": 2,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fadafab83379ff10d86ada179c6f9641d19464fe/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fadafab83379ff10d86ada179c6f9641d19464fe/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fadafab83379ff10d86ada179c6f9641d19464fe",
        "patch": "@@ -6,12 +6,16 @@\n \n #include <chain.h>\n #include <chainparams.h>\n+#include <clientversion.h>\n+#include <consensus/validation.h>\n #include <flatfile.h>\n #include <fs.h>\n+#include <hash.h>\n #include <pow.h>\n #include <shutdown.h>\n #include <signet.h>\n #include <streams.h>\n+#include <undo.h>\n #include <util/system.h>\n #include <validation.h>\n \n@@ -38,6 +42,10 @@ std::set<CBlockIndex*> setDirtyBlockIndex;\n std::set<int> setDirtyFileInfo;\n // } // namespace\n \n+static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n+static FlatFileSeq BlockFileSeq();\n+static FlatFileSeq UndoFileSeq();\n+\n bool IsBlockPruned(const CBlockIndex* pblockindex)\n {\n     return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);\n@@ -84,8 +92,217 @@ void CleanupBlockRevFiles()\n     }\n }\n \n-// From validation. TODO move here\n-bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false);\n+std::string CBlockFileInfo::ToString() const\n+{\n+    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));\n+}\n+\n+CBlockFileInfo* GetBlockFileInfo(size_t n)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    return &vinfoBlockFile.at(n);\n+}\n+\n+static bool UndoWriteToDisk(const CBlockUndo& blockundo, FlatFilePos& pos, const uint256& hashBlock, const CMessageHeader::MessageStartChars& messageStart)\n+{\n+    // Open history file to append\n+    CAutoFile fileout(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n+    if (fileout.IsNull())\n+        return error(\"%s: OpenUndoFile failed\", __func__);\n+\n+    // Write index header\n+    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());\n+    fileout << messageStart << nSize;\n+\n+    // Write undo data\n+    long fileOutPos = ftell(fileout.Get());\n+    if (fileOutPos < 0)\n+        return error(\"%s: ftell failed\", __func__);\n+    pos.nPos = (unsigned int)fileOutPos;\n+    fileout << blockundo;\n+\n+    // calculate & write checksum\n+    CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n+    hasher << hashBlock;\n+    hasher << blockundo;\n+    fileout << hasher.GetHash();\n+\n+    return true;\n+}\n+\n+bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n+{\n+    FlatFilePos pos = pindex->GetUndoPos();\n+    if (pos.IsNull()) {\n+        return error(\"%s: no undo data available\", __func__);\n+    }\n+\n+    // Open history file to read\n+    CAutoFile filein(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull())\n+        return error(\"%s: OpenUndoFile failed\", __func__);\n+\n+    // Read block\n+    uint256 hashChecksum;\n+    CHashVerifier<CAutoFile> verifier(&filein); // We need a CHashVerifier as reserializing may lose data\n+    try {\n+        verifier << pindex->pprev->GetBlockHash();\n+        verifier >> blockundo;\n+        filein >> hashChecksum;\n+    }\n+    catch (const std::exception& e) {\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n+    }\n+\n+    // Verify checksum\n+    if (hashChecksum != verifier.GetHash())\n+        return error(\"%s: Checksum mismatch\", __func__);\n+\n+    return true;\n+}\n+\n+static void FlushUndoFile(int block_file, bool finalize = false)\n+{\n+    FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n+    if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {\n+        AbortNode(\"Flushing undo file to disk failed. This is likely the result of an I/O error.\");\n+    }\n+}\n+\n+void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)\n+{\n+    LOCK(cs_LastBlockFile);\n+    FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);\n+    if (!BlockFileSeq().Flush(block_pos_old, fFinalize)) {\n+        AbortNode(\"Flushing block file to disk failed. This is likely the result of an I/O error.\");\n+    }\n+    // we do not always flush the undo file, as the chain tip may be lagging behind the incoming blocks,\n+    // e.g. during IBD or a sync after a node going offline\n+    if (!fFinalize || finalize_undo) FlushUndoFile(nLastBlockFile, finalize_undo);\n+}\n+\n+uint64_t CalculateCurrentUsage()\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    uint64_t retval = 0;\n+    for (const CBlockFileInfo &file : vinfoBlockFile) {\n+        retval += file.nSize + file.nUndoSize;\n+    }\n+    return retval;\n+}\n+\n+void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)\n+{\n+    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n+        FlatFilePos pos(*it, 0);\n+        fs::remove(BlockFileSeq().FileName(pos));\n+        fs::remove(UndoFileSeq().FileName(pos));\n+        LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it);\n+    }\n+}\n+\n+static FlatFileSeq BlockFileSeq()\n+{\n+    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"blk\", gArgs.GetBoolArg(\"-fastprune\", false) ? 0x4000 /* 16kb */ : BLOCKFILE_CHUNK_SIZE);\n+}\n+\n+static FlatFileSeq UndoFileSeq()\n+{\n+    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"rev\", UNDOFILE_CHUNK_SIZE);\n+}\n+\n+FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly) {\n+    return BlockFileSeq().Open(pos, fReadOnly);\n+}\n+\n+/** Open an undo file (rev?????.dat) */\n+static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly) {\n+    return UndoFileSeq().Open(pos, fReadOnly);\n+}\n+\n+fs::path GetBlockPosFilename(const FlatFilePos &pos)\n+{\n+    return BlockFileSeq().FileName(pos);\n+}\n+\n+bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;\n+    if (vinfoBlockFile.size() <= nFile) {\n+        vinfoBlockFile.resize(nFile + 1);\n+    }\n+\n+    bool finalize_undo = false;\n+    if (!fKnown) {\n+        while (vinfoBlockFile[nFile].nSize + nAddSize >= (gArgs.GetBoolArg(\"-fastprune\", false) ? 0x10000 /* 64kb */ : MAX_BLOCKFILE_SIZE)) {\n+            // when the undo file is keeping up with the block file, we want to flush it explicitly\n+            // when it is lagging behind (more blocks arrive than are being connected), we let the\n+            // undo block write case handle it\n+            assert(std::addressof(::ChainActive()) == std::addressof(active_chain));\n+            finalize_undo = (vinfoBlockFile[nFile].nHeightLast == (unsigned int)active_chain.Tip()->nHeight);\n+            nFile++;\n+            if (vinfoBlockFile.size() <= nFile) {\n+                vinfoBlockFile.resize(nFile + 1);\n+            }\n+        }\n+        pos.nFile = nFile;\n+        pos.nPos = vinfoBlockFile[nFile].nSize;\n+    }\n+\n+    if ((int)nFile != nLastBlockFile) {\n+        if (!fKnown) {\n+            LogPrint(BCLog::VALIDATION, \"Leaving block file %i: %s\\n\", nLastBlockFile, vinfoBlockFile[nLastBlockFile].ToString());\n+        }\n+        FlushBlockFile(!fKnown, finalize_undo);\n+        nLastBlockFile = nFile;\n+    }\n+\n+    vinfoBlockFile[nFile].AddBlock(nHeight, nTime);\n+    if (fKnown)\n+        vinfoBlockFile[nFile].nSize = std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize);\n+    else\n+        vinfoBlockFile[nFile].nSize += nAddSize;\n+\n+    if (!fKnown) {\n+        bool out_of_space;\n+        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+        if (out_of_space) {\n+            return AbortNode(\"Disk space is too low!\", _(\"Disk space is too low!\"));\n+        }\n+        if (bytes_allocated != 0 && fPruneMode) {\n+            fCheckForPruning = true;\n+        }\n+    }\n+\n+    setDirtyFileInfo.insert(nFile);\n+    return true;\n+}\n+\n+static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize)\n+{\n+    pos.nFile = nFile;\n+\n+    LOCK(cs_LastBlockFile);\n+\n+    pos.nPos = vinfoBlockFile[nFile].nUndoSize;\n+    vinfoBlockFile[nFile].nUndoSize += nAddSize;\n+    setDirtyFileInfo.insert(nFile);\n+\n+    bool out_of_space;\n+    size_t bytes_allocated = UndoFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        return AbortNode(state, \"Disk space is too low!\", _(\"Disk space is too low!\"));\n+    }\n+    if (bytes_allocated != 0 && fPruneMode) {\n+        fCheckForPruning = true;\n+    }\n+\n+    return true;\n+}\n \n static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)\n {\n@@ -110,6 +327,33 @@ static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessa\n     return true;\n }\n \n+bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n+{\n+    // Write undo information to disk\n+    if (pindex->GetUndoPos().IsNull()) {\n+        FlatFilePos _pos;\n+        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))\n+            return error(\"ConnectBlock(): FindUndoPos failed\");\n+        if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))\n+            return AbortNode(state, \"Failed to write undo data\");\n+        // rev files are written in block height order, whereas blk files are written as blocks come in (often out of order)\n+        // we want to flush the rev (undo) file once we've written the last block, which is indicated by the last height\n+        // in the block file info as below; note that this does not catch the case where the undo writes are keeping up\n+        // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n+        // the FindBlockPos function\n+        if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n+            FlushUndoFile(_pos.nFile, true);\n+        }\n+\n+        // update nUndoPos in block index\n+        pindex->nUndoPos = _pos.nPos;\n+        pindex->nStatus |= BLOCK_HAVE_UNDO;\n+        setDirtyBlockIndex.insert(pindex);\n+    }\n+\n+    return true;\n+}\n+\n bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams)\n {\n     block.SetNull();"
      },
      {
        "sha": "14f072fefb4494ad3a080b3752887c1eb26e592a",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fadafab83379ff10d86ada179c6f9641d19464fe/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fadafab83379ff10d86ada179c6f9641d19464fe/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fadafab83379ff10d86ada179c6f9641d19464fe",
        "patch": "@@ -12,7 +12,9 @@\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n \n class ArgsManager;\n+class BlockValidationState;\n class CBlock;\n+class CBlockFileInfo;\n class CBlockIndex;\n class CBlockUndo;\n class CChain;\n@@ -47,13 +49,30 @@ bool IsBlockPruned(const CBlockIndex* pblockindex);\n \n void CleanupBlockRevFiles();\n \n+/** Open a block file (blk?????.dat) */\n+FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n+/** Translation to a filesystem path */\n+fs::path GetBlockPosFilename(const FlatFilePos &pos);\n+\n+/** Get block file info entry for one block file */\n+CBlockFileInfo* GetBlockFileInfo(size_t n);\n+\n+/** Calculate the amount of disk space the block & undo files currently use */\n+uint64_t CalculateCurrentUsage();\n+\n+/**\n+ *  Actually unlink the specified files\n+ */\n+void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune);\n+\n /** Functions for disk access for blocks */\n bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);\n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);\n bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start);\n bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);\n \n bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);\n+bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);\n \n FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);\n "
      },
      {
        "sha": "42c22a94a709c1458b283bd7f993e8683d73a214",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 247,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fadafab83379ff10d86ada179c6f9641d19464fe/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fadafab83379ff10d86ada179c6f9641d19464fe/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fadafab83379ff10d86ada179c6f9641d19464fe",
        "patch": "@@ -153,6 +153,7 @@ extern int nLastBlockFile;\n extern bool fCheckForPruning;\n extern std::set<CBlockIndex*> setDirtyBlockIndex;\n extern std::set<int> setDirtyFileInfo;\n+void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n // ... TODO move fully to blockstorage\n \n CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n@@ -190,9 +191,6 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n                        bool cacheFullScriptStore, PrecomputedTransactionData& txdata,\n                        std::vector<CScriptCheck>* pvChecks = nullptr)\n                        EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n-static FlatFileSeq BlockFileSeq();\n-static FlatFileSeq UndoFileSeq();\n \n bool CheckFinalTx(const CBlockIndex* active_chain_tip, const CTransaction &tx, int flags)\n {\n@@ -1447,64 +1445,6 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n     return true;\n }\n \n-static bool UndoWriteToDisk(const CBlockUndo& blockundo, FlatFilePos& pos, const uint256& hashBlock, const CMessageHeader::MessageStartChars& messageStart)\n-{\n-    // Open history file to append\n-    CAutoFile fileout(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n-        return error(\"%s: OpenUndoFile failed\", __func__);\n-\n-    // Write index header\n-    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());\n-    fileout << messageStart << nSize;\n-\n-    // Write undo data\n-    long fileOutPos = ftell(fileout.Get());\n-    if (fileOutPos < 0)\n-        return error(\"%s: ftell failed\", __func__);\n-    pos.nPos = (unsigned int)fileOutPos;\n-    fileout << blockundo;\n-\n-    // calculate & write checksum\n-    CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n-    hasher << hashBlock;\n-    hasher << blockundo;\n-    fileout << hasher.GetHash();\n-\n-    return true;\n-}\n-\n-bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n-{\n-    FlatFilePos pos = pindex->GetUndoPos();\n-    if (pos.IsNull()) {\n-        return error(\"%s: no undo data available\", __func__);\n-    }\n-\n-    // Open history file to read\n-    CAutoFile filein(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: OpenUndoFile failed\", __func__);\n-\n-    // Read block\n-    uint256 hashChecksum;\n-    CHashVerifier<CAutoFile> verifier(&filein); // We need a CHashVerifier as reserializing may lose data\n-    try {\n-        verifier << pindex->pprev->GetBlockHash();\n-        verifier >> blockundo;\n-        filein >> hashChecksum;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-\n-    // Verify checksum\n-    if (hashChecksum != verifier.GetHash())\n-        return error(\"%s: Checksum mismatch\", __func__);\n-\n-    return true;\n-}\n-\n bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage)\n {\n     AbortNode(strMessage, userMessage);\n@@ -1605,55 +1545,6 @@ DisconnectResult CChainState::DisconnectBlock(const CBlock& block, const CBlockI\n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n-static void FlushUndoFile(int block_file, bool finalize = false)\n-{\n-    FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n-    if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {\n-        AbortNode(\"Flushing undo file to disk failed. This is likely the result of an I/O error.\");\n-    }\n-}\n-\n-static void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)\n-{\n-    LOCK(cs_LastBlockFile);\n-    FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);\n-    if (!BlockFileSeq().Flush(block_pos_old, fFinalize)) {\n-        AbortNode(\"Flushing block file to disk failed. This is likely the result of an I/O error.\");\n-    }\n-    // we do not always flush the undo file, as the chain tip may be lagging behind the incoming blocks,\n-    // e.g. during IBD or a sync after a node going offline\n-    if (!fFinalize || finalize_undo) FlushUndoFile(nLastBlockFile, finalize_undo);\n-}\n-\n-static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize);\n-\n-static bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n-{\n-    // Write undo information to disk\n-    if (pindex->GetUndoPos().IsNull()) {\n-        FlatFilePos _pos;\n-        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))\n-            return error(\"ConnectBlock(): FindUndoPos failed\");\n-        if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))\n-            return AbortNode(state, \"Failed to write undo data\");\n-        // rev files are written in block height order, whereas blk files are written as blocks come in (often out of order)\n-        // we want to flush the rev (undo) file once we've written the last block, which is indicated by the last height\n-        // in the block file info as below; note that this does not catch the case where the undo writes are keeping up\n-        // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n-        // the FindBlockPos function\n-        if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n-            FlushUndoFile(_pos.nFile, true);\n-        }\n-\n-        // update nUndoPos in block index\n-        pindex->nUndoPos = _pos.nPos;\n-        pindex->nStatus |= BLOCK_HAVE_UNDO;\n-        setDirtyBlockIndex.insert(pindex);\n-    }\n-\n-    return true;\n-}\n-\n static CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n \n void StartScriptCheckWorkerThreads(int threads_num)\n@@ -3087,84 +2978,6 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n     }\n }\n \n-// TODO move to blockstorage\n-bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n-{\n-    LOCK(cs_LastBlockFile);\n-\n-    unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;\n-    if (vinfoBlockFile.size() <= nFile) {\n-        vinfoBlockFile.resize(nFile + 1);\n-    }\n-\n-    bool finalize_undo = false;\n-    if (!fKnown) {\n-        while (vinfoBlockFile[nFile].nSize + nAddSize >= (gArgs.GetBoolArg(\"-fastprune\", false) ? 0x10000 /* 64kb */ : MAX_BLOCKFILE_SIZE)) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            assert(std::addressof(::ChainActive()) == std::addressof(active_chain));\n-            finalize_undo = (vinfoBlockFile[nFile].nHeightLast == (unsigned int)active_chain.Tip()->nHeight);\n-            nFile++;\n-            if (vinfoBlockFile.size() <= nFile) {\n-                vinfoBlockFile.resize(nFile + 1);\n-            }\n-        }\n-        pos.nFile = nFile;\n-        pos.nPos = vinfoBlockFile[nFile].nSize;\n-    }\n-\n-    if ((int)nFile != nLastBlockFile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::VALIDATION, \"Leaving block file %i: %s\\n\", nLastBlockFile, vinfoBlockFile[nLastBlockFile].ToString());\n-        }\n-        FlushBlockFile(!fKnown, finalize_undo);\n-        nLastBlockFile = nFile;\n-    }\n-\n-    vinfoBlockFile[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown)\n-        vinfoBlockFile[nFile].nSize = std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize);\n-    else\n-        vinfoBlockFile[nFile].nSize += nAddSize;\n-\n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            return AbortNode(\"Disk space is too low!\", _(\"Disk space is too low!\"));\n-        }\n-        if (bytes_allocated != 0 && fPruneMode) {\n-            fCheckForPruning = true;\n-        }\n-    }\n-\n-    setDirtyFileInfo.insert(nFile);\n-    return true;\n-}\n-\n-static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize)\n-{\n-    pos.nFile = nFile;\n-\n-    LOCK(cs_LastBlockFile);\n-\n-    pos.nPos = vinfoBlockFile[nFile].nUndoSize;\n-    vinfoBlockFile[nFile].nUndoSize += nAddSize;\n-    setDirtyFileInfo.insert(nFile);\n-\n-    bool out_of_space;\n-    size_t bytes_allocated = UndoFileSeq().Allocate(pos, nAddSize, out_of_space);\n-    if (out_of_space) {\n-        return AbortNode(state, \"Disk space is too low!\", _(\"Disk space is too low!\"));\n-    }\n-    if (bytes_allocated != 0 && fPruneMode) {\n-        fCheckForPruning = true;\n-    }\n-\n-    return true;\n-}\n-\n static bool CheckBlockHeader(const CBlockHeader& block, BlockValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n {\n     // Check proof of work matches claimed amount\n@@ -3722,18 +3535,6 @@ bool TestBlockValidity(BlockValidationState& state,\n  * BLOCK PRUNING CODE\n  */\n \n-/* Calculate the amount of disk space the block & undo files currently use */\n-uint64_t CalculateCurrentUsage()\n-{\n-    LOCK(cs_LastBlockFile);\n-\n-    uint64_t retval = 0;\n-    for (const CBlockFileInfo &file : vinfoBlockFile) {\n-        retval += file.nSize + file.nUndoSize;\n-    }\n-    return retval;\n-}\n-\n void BlockManager::PruneOneBlockFile(const int fileNumber)\n {\n     AssertLockHeld(cs_main);\n@@ -3768,17 +3569,6 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)\n     setDirtyFileInfo.insert(fileNumber);\n }\n \n-\n-void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)\n-{\n-    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n-        FlatFilePos pos(*it, 0);\n-        fs::remove(BlockFileSeq().FileName(pos));\n-        fs::remove(UndoFileSeq().FileName(pos));\n-        LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it);\n-    }\n-}\n-\n void BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight, int chain_tip_height)\n {\n     assert(fPruneMode && nManualPruneHeight > 0);\n@@ -3873,30 +3663,6 @@ void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPr\n            nLastBlockWeCanPrune, count);\n }\n \n-static FlatFileSeq BlockFileSeq()\n-{\n-    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"blk\", gArgs.GetBoolArg(\"-fastprune\", false) ? 0x4000 /* 16kb */ : BLOCKFILE_CHUNK_SIZE);\n-}\n-\n-static FlatFileSeq UndoFileSeq()\n-{\n-    return FlatFileSeq(gArgs.GetBlocksDirPath(), \"rev\", UNDOFILE_CHUNK_SIZE);\n-}\n-\n-FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly) {\n-    return BlockFileSeq().Open(pos, fReadOnly);\n-}\n-\n-/** Open an undo file (rev?????.dat) */\n-static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly) {\n-    return UndoFileSeq().Open(pos, fReadOnly);\n-}\n-\n-fs::path GetBlockPosFilename(const FlatFilePos &pos)\n-{\n-    return BlockFileSeq().FileName(pos);\n-}\n-\n CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n@@ -4719,18 +4485,6 @@ bool CChainState::ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)\n     return ret;\n }\n \n-std::string CBlockFileInfo::ToString() const\n-{\n-    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));\n-}\n-\n-CBlockFileInfo* GetBlockFileInfo(size_t n)\n-{\n-    LOCK(cs_LastBlockFile);\n-\n-    return &vinfoBlockFile.at(n);\n-}\n-\n static const uint64_t MEMPOOL_DUMP_VERSION = 1;\n \n bool LoadMempool(CTxMemPool& pool, CChainState& active_chainstate, FopenFn mockable_fopen_function)"
      },
      {
        "sha": "b6acbc2817c3e6497093317048d9cd622568a992",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fadafab83379ff10d86ada179c6f9641d19464fe/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fadafab83379ff10d86ada179c6f9641d19464fe/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fadafab83379ff10d86ada179c6f9641d19464fe",
        "patch": "@@ -135,10 +135,6 @@ extern CBlockIndex *pindexBestHeader;\n /** Documentation for argument 'checklevel'. */\n extern const std::vector<std::string> CHECKLEVEL_DOC;\n \n-/** Open a block file (blk?????.dat) */\n-FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n-/** Translation to a filesystem path */\n-fs::path GetBlockPosFilename(const FlatFilePos &pos);\n /** Unload database information */\n void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);\n /** Run instances of script checking worker threads */\n@@ -165,14 +161,6 @@ bool AbortNode(BlockValidationState& state, const std::string& strMessage, const\n /** Guess verification progress (as a fraction between 0.0=genesis and 1.0=current tip). */\n double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex* pindex);\n \n-/** Calculate the amount of disk space the block & undo files currently use */\n-uint64_t CalculateCurrentUsage();\n-\n-/**\n- *  Actually unlink the specified files\n- */\n-void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune);\n-\n /** Prune block files up to a given height */\n void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeight);\n \n@@ -993,9 +981,6 @@ extern VersionBitsCache versionbitscache;\n  */\n int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n-/** Get block file info entry for one block file */\n-CBlockFileInfo* GetBlockFileInfo(size_t n);\n-\n using FopenFn = std::function<FILE*(const fs::path&, const char*)>;\n \n /** Dump the mempool to disk. */"
      }
    ]
  },
  {
    "sha": "fa09a9eac8d8ab65ce4064c35a9f21349a644982",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTA5YTllYWM4ZDhhYjY1Y2U0MDY0YzM1YTlmMjEzNDlhNjQ0OTgy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-19T06:45:35Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T08:36:41Z"
      },
      "message": "style: Add { } to multi-line if\n\nCan be reviewed with --word-diff-regex=. --ignore-all-space",
      "tree": {
        "sha": "75f71f932ce8c45c47cacf37070b22f6f0dbbc5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75f71f932ce8c45c47cacf37070b22f6f0dbbc5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa09a9eac8d8ab65ce4064c35a9f21349a644982",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjmxgv/dKTRxFXGzUJUrD2i86TFv9dMCRsbN1fvoUVUNf9fWeTQj/Hfn9ha0tGZ\npSb/Iz8Po/S20Z9tDHd7CWuXL2y/4CYfCFv2XQcEIisOfwqEv1pu6A2keJnrhbPD\nn2juBwzF0UZPXtWHImCr3pGLZK09nTRybARs/9/E08HOwunlQiNpWdciwDutlJWo\ncGTzvwk2jQsmOe3dq9Z2M7rjPPYC9Q1pIFLMfJly012UDaorIJuMBwfyW3jhR+Ey\n0mAaWBNiMA346RpbFGpJi+fZLjlo2GH7jQpf8ehq0xCzTqJhuOjpQ4yp1XR3x0Wl\nLh/g+Bn+TN+9Lz0No/j1aqoWvc2ESosI1zzANgS67yFSLM3RT6dLfwnAOdN7hyOB\nsmrA+Xzfn3xc5X6KMS/Of+vIpeNwIvIHoBCHaUkQospGqEXtv+yi+Qik5fdVrqkB\n88Jn/57zyaJR7XqHnIvUR1X2PtfrWyD1wMC/wO4/ykIWtsGhGC/XgggisNsODDml\nhcGiI3vV\n=6rw7\n-----END PGP SIGNATURE-----",
        "payload": "tree 75f71f932ce8c45c47cacf37070b22f6f0dbbc5c\nparent fadafab83379ff10d86ada179c6f9641d19464fe\nauthor MarcoFalke <falke.marco@gmail.com> 1618814735 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1619512601 +0200\n\nstyle: Add { } to multi-line if\n\nCan be reviewed with --word-diff-regex=. --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa09a9eac8d8ab65ce4064c35a9f21349a644982",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa09a9eac8d8ab65ce4064c35a9f21349a644982",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa09a9eac8d8ab65ce4064c35a9f21349a644982/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fadafab83379ff10d86ada179c6f9641d19464fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fadafab83379ff10d86ada179c6f9641d19464fe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fadafab83379ff10d86ada179c6f9641d19464fe"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 30,
      "deletions": 21
    },
    "files": [
      {
        "sha": "6c66c565ad9b7753c7ed1752fbd0a25fba44506b",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 19,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa09a9eac8d8ab65ce4064c35a9f21349a644982/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa09a9eac8d8ab65ce4064c35a9f21349a644982/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa09a9eac8d8ab65ce4064c35a9f21349a644982",
        "patch": "@@ -42,7 +42,7 @@ std::set<CBlockIndex*> setDirtyBlockIndex;\n std::set<int> setDirtyFileInfo;\n // } // namespace\n \n-static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n+static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n \n@@ -71,10 +71,11 @@ void CleanupBlockRevFiles()\n             it->path().filename().string().length() == 12 &&\n             it->path().filename().string().substr(8,4) == \".dat\")\n         {\n-            if (it->path().filename().string().substr(0,3) == \"blk\")\n-                mapBlockFiles[it->path().filename().string().substr(3,5)] = it->path();\n-            else if (it->path().filename().string().substr(0,3) == \"rev\")\n+            if (it->path().filename().string().substr(0, 3) == \"blk\") {\n+                mapBlockFiles[it->path().filename().string().substr(3, 5)] = it->path();\n+            } else if (it->path().filename().string().substr(0, 3) == \"rev\") {\n                 remove(it->path());\n+            }\n         }\n     }\n \n@@ -108,17 +109,19 @@ static bool UndoWriteToDisk(const CBlockUndo& blockundo, FlatFilePos& pos, const\n {\n     // Open history file to append\n     CAutoFile fileout(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n+    if (fileout.IsNull()) {\n         return error(\"%s: OpenUndoFile failed\", __func__);\n+    }\n \n     // Write index header\n     unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());\n     fileout << messageStart << nSize;\n \n     // Write undo data\n     long fileOutPos = ftell(fileout.Get());\n-    if (fileOutPos < 0)\n+    if (fileOutPos < 0) {\n         return error(\"%s: ftell failed\", __func__);\n+    }\n     pos.nPos = (unsigned int)fileOutPos;\n     fileout << blockundo;\n \n@@ -140,8 +143,9 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n \n     // Open history file to read\n     CAutoFile filein(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n+    if (filein.IsNull()) {\n         return error(\"%s: OpenUndoFile failed\", __func__);\n+    }\n \n     // Read block\n     uint256 hashChecksum;\n@@ -150,14 +154,14 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n         verifier << pindex->pprev->GetBlockHash();\n         verifier >> blockundo;\n         filein >> hashChecksum;\n-    }\n-    catch (const std::exception& e) {\n+    } catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     // Verify checksum\n-    if (hashChecksum != verifier.GetHash())\n+    if (hashChecksum != verifier.GetHash()) {\n         return error(\"%s: Checksum mismatch\", __func__);\n+    }\n \n     return true;\n }\n@@ -187,7 +191,7 @@ uint64_t CalculateCurrentUsage()\n     LOCK(cs_LastBlockFile);\n \n     uint64_t retval = 0;\n-    for (const CBlockFileInfo &file : vinfoBlockFile) {\n+    for (const CBlockFileInfo& file : vinfoBlockFile) {\n         retval += file.nSize + file.nUndoSize;\n     }\n     return retval;\n@@ -213,16 +217,18 @@ static FlatFileSeq UndoFileSeq()\n     return FlatFileSeq(gArgs.GetBlocksDirPath(), \"rev\", UNDOFILE_CHUNK_SIZE);\n }\n \n-FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly) {\n+FILE* OpenBlockFile(const FlatFilePos& pos, bool fReadOnly)\n+{\n     return BlockFileSeq().Open(pos, fReadOnly);\n }\n \n /** Open an undo file (rev?????.dat) */\n-static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly) {\n+static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly)\n+{\n     return UndoFileSeq().Open(pos, fReadOnly);\n }\n \n-fs::path GetBlockPosFilename(const FlatFilePos &pos)\n+fs::path GetBlockPosFilename(const FlatFilePos& pos)\n {\n     return BlockFileSeq().FileName(pos);\n }\n@@ -262,10 +268,11 @@ bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight,\n     }\n \n     vinfoBlockFile[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown)\n+    if (fKnown) {\n         vinfoBlockFile[nFile].nSize = std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize);\n-    else\n+    } else {\n         vinfoBlockFile[nFile].nSize += nAddSize;\n+    }\n \n     if (!fKnown) {\n         bool out_of_space;\n@@ -282,7 +289,7 @@ bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight,\n     return true;\n }\n \n-static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize)\n+static bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -332,10 +339,12 @@ bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& st\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull()) {\n         FlatFilePos _pos;\n-        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))\n+        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40)) {\n             return error(\"ConnectBlock(): FindUndoPos failed\");\n-        if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))\n+        }\n+        if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart())) {\n             return AbortNode(state, \"Failed to write undo data\");\n+        }\n         // rev files are written in block height order, whereas blk files are written as blocks come in (often out of order)\n         // we want to flush the rev (undo) file once we've written the last block, which is indicated by the last height\n         // in the block file info as below; note that this does not catch the case where the undo writes are keeping up"
      },
      {
        "sha": "faf99dea818404aaf34f888a6834b80f44992b84",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa09a9eac8d8ab65ce4064c35a9f21349a644982/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa09a9eac8d8ab65ce4064c35a9f21349a644982/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fa09a9eac8d8ab65ce4064c35a9f21349a644982",
        "patch": "@@ -50,9 +50,9 @@ bool IsBlockPruned(const CBlockIndex* pblockindex);\n void CleanupBlockRevFiles();\n \n /** Open a block file (blk?????.dat) */\n-FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n+FILE* OpenBlockFile(const FlatFilePos& pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n-fs::path GetBlockPosFilename(const FlatFilePos &pos);\n+fs::path GetBlockPosFilename(const FlatFilePos& pos);\n \n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);"
      }
    ]
  }
]