[
  {
    "sha": "a1261296e48967b3236053d3435a3f521898df2f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMTI2MTI5NmU0ODk2N2IzMjM2MDUzZDM0MzVhM2Y1MjE4OThkZjJm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:21:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:44:06Z"
      },
      "message": "Add auto-formatter script",
      "tree": {
        "sha": "7fe2bc03486b3099aed0f54c6b71daf8d98210a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7fe2bc03486b3099aed0f54c6b71daf8d98210a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1261296e48967b3236053d3435a3f521898df2f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1261296e48967b3236053d3435a3f521898df2f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a1261296e48967b3236053d3435a3f521898df2f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1261296e48967b3236053d3435a3f521898df2f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2adce1f71600881f69ba44a4d847ade5d7066f7e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2adce1f71600881f69ba44a4d847ade5d7066f7e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2adce1f71600881f69ba44a4d847ade5d7066f7e"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b7cf5854fefc4905b567fa9b64add63521fef80c",
        "filename": "contrib/devtools/auto-format.sh",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1261296e48967b3236053d3435a3f521898df2f/contrib/devtools/auto-format.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1261296e48967b3236053d3435a3f521898df2f/contrib/devtools/auto-format.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/auto-format.sh?ref=a1261296e48967b3236053d3435a3f521898df2f",
        "patch": "@@ -0,0 +1,13 @@\n+#!/bin/bash\n+\n+if [ ! -f src/main.cpp ]; then\n+    echo \"This tool must be run from the project root directory.\" >&2\n+    exit 1\n+fi\n+\n+cd src\n+\n+find . \\( -name bip32_tests.cpp -o -name utilstrencodings.cpp -o -name chainparams.cpp -o -name chainparamsseed.h -o -name tinyformat.h -o -name qt -o -name leveldb -o -name univalue -o -name secp256k1 -o -name json \\) -prune -o -name '*.h' -o -name '*.cpp' -print | while read FILE; do\n+    clang-format-3.5 -style=file -i \"$FILE\"\n+done\n+"
      }
    ]
  },
  {
    "sha": "5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YmEzNzZhOWJjNmU3ZDMyMmIzZjMxOGI4YTg5NDI2NDVkNzJiN2M4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:32:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:44:06Z"
      },
      "message": "Reformat CBloomFilter::CBloomFilter comments",
      "tree": {
        "sha": "9c9e2ffe8183642245a6a118e8eab5c4ff345ba6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c9e2ffe8183642245a6a118e8eab5c4ff345ba6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1261296e48967b3236053d3435a3f521898df2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1261296e48967b3236053d3435a3f521898df2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1261296e48967b3236053d3435a3f521898df2f"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 8,
      "deletions": 9
    },
    "files": [
      {
        "sha": "d439137c7e036135fa4ac654b227e5d783643739",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
        "patch": "@@ -20,23 +20,22 @@\n \n using namespace std;\n \n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n /**\n  * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n  * - nElements * log(fp rate) / ln(2)^2\n  * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n- */\n-vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n-/**\n+\n  * The ideal number of hash functions is filter size * ln(2) / number of elements\n  * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n  * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n  */\n-isFull(false),\n-isEmpty(false),\n-nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n-nTweak(nTweakIn),\n-nFlags(nFlagsIn)\n+CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn)\n+    : vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+      isFull(false),\n+      isEmpty(false),\n+      nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+      nTweak(nTweakIn),\n+      nFlags(nFlagsIn)\n {\n }\n "
      }
    ]
  },
  {
    "sha": "2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDM3MjExYTFhYTE3ZTVjZjM2ZDdlYzlmYWQzMWQyOWU3ZjhhZDQ4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:45:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-27T16:45:42Z"
      },
      "message": "Apply autoformat script",
      "tree": {
        "sha": "59c74023f827cefd24c992d0cb5e09cbd7621f32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/59c74023f827cefd24c992d0cb5e09cbd7621f32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ba376a9bc6e7d322b3f318b8a8942645d72b7c8"
      }
    ],
    "stats": {
      "total": 12020,
      "additions": 5716,
      "deletions": 6304
    },
    "files": [
      {
        "sha": "e4601c92e80839b69791410f5f20c17f7ddee0c8",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 30,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -48,10 +48,10 @@ void CUnsignedAlert::SetNull()\n std::string CUnsignedAlert::ToString() const\n {\n     std::string strSetCancel;\n-    BOOST_FOREACH(int n, setCancel)\n+    BOOST_FOREACH (int n, setCancel)\n         strSetCancel += strprintf(\"%d \", n);\n     std::string strSetSubVer;\n-    BOOST_FOREACH(std::string str, setSubVer)\n+    BOOST_FOREACH (std::string str, setSubVer)\n         strSetSubVer += \"\\\"\" + str + \"\\\" \";\n     return strprintf(\n         \"CAlert(\\n\"\n@@ -132,12 +132,10 @@ bool CAlert::RelayTo(CNode* pnode) const\n     if (pnode->nVersion == 0)\n         return false;\n     // returns true if wasn't already contained in the set\n-    if (pnode->setKnown.insert(GetHash()).second)\n-    {\n+    if (pnode->setKnown.insert(GetHash()).second) {\n         if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n             AppliesToMe() ||\n-            GetAdjustedTime() < nRelayUntil)\n-        {\n+            GetAdjustedTime() < nRelayUntil) {\n             pnode->PushMessage(\"alert\", *this);\n             return true;\n         }\n@@ -157,13 +155,13 @@ bool CAlert::CheckSignature() const\n     return true;\n }\n \n-CAlert CAlert::getAlertByHash(const uint256 &hash)\n+CAlert CAlert::getAlertByHash(const uint256& hash)\n {\n     CAlert retval;\n     {\n         LOCK(cs_mapAlerts);\n         map<uint256, CAlert>::iterator mi = mapAlerts.find(hash);\n-        if(mi != mapAlerts.end())\n+        if (mi != mapAlerts.end())\n             retval = mi->second;\n     }\n     return retval;\n@@ -184,48 +182,39 @@ bool CAlert::ProcessAlert(bool fThread)\n     // send an \"everything is OK, don't panic\" version that\n     // cannot be overridden):\n     int maxInt = std::numeric_limits<int>::max();\n-    if (nID == maxInt)\n-    {\n+    if (nID == maxInt) {\n         if (!(\n                 nExpiration == maxInt &&\n-                nCancel == (maxInt-1) &&\n+                nCancel == (maxInt - 1) &&\n                 nMinVer == 0 &&\n                 nMaxVer == maxInt &&\n                 setSubVer.empty() &&\n                 nPriority == maxInt &&\n-                strStatusBar == \"URGENT: Alert key compromised, upgrade required\"\n-                ))\n+                strStatusBar == \"URGENT: Alert key compromised, upgrade required\"))\n             return false;\n     }\n \n     {\n         LOCK(cs_mapAlerts);\n         // Cancel previous alerts\n-        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n-        {\n+        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();) {\n             const CAlert& alert = (*mi).second;\n-            if (Cancels(alert))\n-            {\n+            if (Cancels(alert)) {\n                 LogPrint(\"alert\", \"cancelling alert %d\\n\", alert.nID);\n                 uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                 mapAlerts.erase(mi++);\n-            }\n-            else if (!alert.IsInEffect())\n-            {\n+            } else if (!alert.IsInEffect()) {\n                 LogPrint(\"alert\", \"expiring alert %d\\n\", alert.nID);\n                 uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                 mapAlerts.erase(mi++);\n-            }\n-            else\n+            } else\n                 mi++;\n         }\n \n         // Check if this alert has been cancelled\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n-        {\n+        BOOST_FOREACH (PAIRTYPE(const uint256, CAlert) & item, mapAlerts) {\n             const CAlert& alert = item.second;\n-            if (alert.Cancels(*this))\n-            {\n+            if (alert.Cancels(*this)) {\n                 LogPrint(\"alert\", \"alert already cancelled by %d\\n\", alert.nID);\n                 return false;\n             }\n@@ -234,8 +223,7 @@ bool CAlert::ProcessAlert(bool fThread)\n         // Add to mapAlerts\n         mapAlerts.insert(make_pair(GetHash(), *this));\n         // Notify UI and -alertnotify if it applies to me\n-        if(AppliesToMe())\n-        {\n+        if (AppliesToMe()) {\n             uiInterface.NotifyAlertChanged(GetHash(), CT_NEW);\n             Notify(strStatusBar, fThread);\n         }\n@@ -249,14 +237,15 @@ void\n CAlert::Notify(const std::string& strMessage, bool fThread)\n {\n     std::string strCmd = GetArg(\"-alertnotify\", \"\");\n-    if (strCmd.empty()) return;\n+    if (strCmd.empty())\n+        return;\n \n     // Alert text should be plain ascii coming from a trusted source, but to\n     // be safe we first strip anything not in safeChars, then add single quotes around\n     // the whole string before passing it to the shell:\n     std::string singleQuote(\"'\");\n     std::string safeStatus = SanitizeString(strMessage);\n-    safeStatus = singleQuote+safeStatus+singleQuote;\n+    safeStatus = singleQuote + safeStatus + singleQuote;\n     boost::replace_all(strCmd, \"%s\", safeStatus);\n \n     if (fThread)"
      },
      {
        "sha": "6a718f6d40e487dc2cc6bbcafb0688ed725415db",
        "filename": "src/amount.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/amount.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/amount.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -10,14 +10,14 @@\n CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nSize)\n {\n     if (nSize > 0)\n-        nSatoshisPerK = nFeePaid*1000/nSize;\n+        nSatoshisPerK = nFeePaid * 1000 / nSize;\n     else\n         nSatoshisPerK = 0;\n }\n \n CAmount CFeeRate::GetFee(size_t nSize) const\n {\n-    CAmount nFee = nSatoshisPerK*nSize / 1000;\n+    CAmount nFee = nSatoshisPerK * nSize / 1000;\n \n     if (nFee == 0 && nSatoshisPerK > 0)\n         nFee = nSatoshisPerK;"
      },
      {
        "sha": "c46e9359f389d58864e7a0c8a9cdc129b5eb785a",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 29,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -28,7 +28,8 @@ std::string HelpMessageCli()\n     strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n     strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n     strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+                                                \"solved instantly. This is intended for regression testing tools and app development.\") +\n+                \"\\n\";\n     strUsage += \"  -rpcconnect=<ip>       \" + strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), \"127.0.0.1\") + \"\\n\";\n     strUsage += \"  -rpcport=<port>        \" + strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), 8332, 18332) + \"\\n\";\n     strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n@@ -53,11 +54,9 @@ std::string HelpMessageCli()\n class CConnectionFailed : public std::runtime_error\n {\n public:\n-\n-    explicit inline CConnectionFailed(const std::string& msg) :\n-        std::runtime_error(msg)\n-    {}\n-\n+    explicit inline CConnectionFailed(const std::string& msg) : std::runtime_error(msg)\n+    {\n+    }\n };\n \n static bool AppInitRPC(int argc, char* argv[])\n@@ -66,13 +65,13 @@ static bool AppInitRPC(int argc, char* argv[])\n     // Parameters\n     //\n     ParseParameters(argc, argv);\n-    if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\")) {\n+    if (argc < 2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\")) {\n         std::string strUsage = _(\"Bitcoin Core RPC client version\") + \" \" + FormatFullVersion() + \"\\n\";\n         if (!mapArgs.count(\"-version\")) {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] <command> [params]  \" + _(\"Send command to Bitcoin Core\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+                        \"  bitcoin-cli [options] <command> [params]  \" + _(\"Send command to Bitcoin Core\") + \"\\n\" +\n+                        \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n+                        \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessageCli();\n         }\n@@ -86,8 +85,8 @@ static bool AppInitRPC(int argc, char* argv[])\n     }\n     try {\n         ReadConfigFile(mapArgs, mapMultiArgs);\n-    } catch(std::exception &e) {\n-        fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+    } catch (std::exception& e) {\n+        fprintf(stderr, \"Error reading configuration file: %s\\n\", e.what());\n         return false;\n     }\n     // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n@@ -104,7 +103,7 @@ Object CallRPC(const string& strMethod, const Array& params)\n         throw runtime_error(strprintf(\n             _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n               \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n-                GetConfigFile().string().c_str()));\n+            GetConfigFile().string().c_str()));\n \n     // Connect to localhost\n     bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n@@ -113,7 +112,7 @@ Object CallRPC(const string& strMethod, const Array& params)\n     context.set_options(ssl::context::no_sslv2);\n     asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n     SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n-    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n+    iostreams::stream<SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n \n     const bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(BaseParams().RPCPort())));\n     if (!fConnected)\n@@ -156,7 +155,7 @@ Object CallRPC(const string& strMethod, const Array& params)\n     return reply;\n }\n \n-int CommandLineRPC(int argc, char *argv[])\n+int CommandLineRPC(int argc, char* argv[])\n {\n     string strPrint;\n     int nRet = 0;\n@@ -184,7 +183,7 @@ int CommandLineRPC(int argc, char *argv[])\n \n                 // Parse reply\n                 const Value& result = find_value(reply, \"result\");\n-                const Value& error  = find_value(reply, \"error\");\n+                const Value& error = find_value(reply, \"error\");\n \n                 if (error.type() != null_type) {\n                     // Error\n@@ -205,23 +204,19 @@ int CommandLineRPC(int argc, char *argv[])\n \n                 // Connection succeeded, no need to retry.\n                 break;\n-            }\n-            catch (const CConnectionFailed& e) {\n+            } catch (const CConnectionFailed& e) {\n                 if (fWait)\n                     MilliSleep(1000);\n                 else\n                     throw;\n             }\n         } while (fWait);\n-    }\n-    catch (boost::thread_interrupted) {\n+    } catch (boost::thread_interrupted) {\n         throw;\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         strPrint = string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n-    }\n-    catch (...) {\n+    } catch (...) {\n         PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n         throw;\n     }\n@@ -237,10 +232,9 @@ int main(int argc, char* argv[])\n     SetupEnvironment();\n \n     try {\n-        if(!AppInitRPC(argc, argv))\n+        if (!AppInitRPC(argc, argv))\n             return EXIT_FAILURE;\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n     } catch (...) {\n@@ -251,8 +245,7 @@ int main(int argc, char* argv[])\n     int ret = EXIT_FAILURE;\n     try {\n         ret = CommandLineRPC(argc, argv);\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"CommandLineRPC()\");\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"CommandLineRPC()\");"
      },
      {
        "sha": "0676088f745b7a7685558d3a80d6451b16a23086",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 37,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -24,7 +24,7 @@ using namespace boost::assign;\n using namespace std;\n \n static bool fCreateBlank;\n-static map<string,UniValue> registers;\n+static map<string, UniValue> registers;\n CClientUIInterface uiInterface;\n \n static bool AppInitRawTx(int argc, char* argv[])\n@@ -42,14 +42,13 @@ static bool AppInitRawTx(int argc, char* argv[])\n \n     fCreateBlank = GetBoolArg(\"-create\", false);\n \n-    if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\"))\n-    {\n+    if (argc < 2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\")) {\n         // First part of help message is specific to this utility\n         std::string strUsage = _(\"Bitcoin Core bitcoin-tx utility version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-            _(\"Usage:\") + \"\\n\" +\n-              \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"\\n\";\n+                               _(\"Usage:\") + \"\\n\" +\n+                               \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n+                               \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n+                               \"\\n\";\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n@@ -129,7 +128,7 @@ static void RegisterLoad(const string& strInput)\n     string key = strInput.substr(0, pos);\n     string filename = strInput.substr(pos + 1, string::npos);\n \n-    FILE *f = fopen(filename.c_str(), \"r\");\n+    FILE* f = fopen(filename.c_str(), \"r\");\n     if (!f) {\n         string strErr = \"Cannot open file \" + filename;\n         throw runtime_error(strErr);\n@@ -163,7 +162,7 @@ static void MutateTxVersion(CMutableTransaction& tx, const string& cmdVal)\n     if (newVersion < 1 || newVersion > CTransaction::CURRENT_VERSION)\n         throw runtime_error(\"Invalid TX version requested\");\n \n-    tx.nVersion = (int) newVersion;\n+    tx.nVersion = (int)newVersion;\n }\n \n static void MutateTxLocktime(CMutableTransaction& tx, const string& cmdVal)\n@@ -172,7 +171,7 @@ static void MutateTxLocktime(CMutableTransaction& tx, const string& cmdVal)\n     if (newLocktime < 0LL || newLocktime > 0xffffffffLL)\n         throw runtime_error(\"Invalid TX locktime requested\");\n \n-    tx.nLockTime = (unsigned int) newLocktime;\n+    tx.nLockTime = (unsigned int)newLocktime;\n }\n \n static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n@@ -283,16 +282,17 @@ static void MutateTxDelOutput(CMutableTransaction& tx, const string& strOutIdx)\n }\n \n static const unsigned int N_SIGHASH_OPTS = 6;\n-static const struct {\n-    const char *flagStr;\n+static const struct\n+{\n+    const char* flagStr;\n     int flags;\n } sighashOptions[N_SIGHASH_OPTS] = {\n-    {\"ALL\", SIGHASH_ALL},\n-    {\"NONE\", SIGHASH_NONE},\n-    {\"SINGLE\", SIGHASH_SINGLE},\n-    {\"ALL|ANYONECANPAY\", SIGHASH_ALL|SIGHASH_ANYONECANPAY},\n-    {\"NONE|ANYONECANPAY\", SIGHASH_NONE|SIGHASH_ANYONECANPAY},\n-    {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE|SIGHASH_ANYONECANPAY},\n+      {\"ALL\", SIGHASH_ALL},\n+      {\"NONE\", SIGHASH_NONE},\n+      {\"SINGLE\", SIGHASH_SINGLE},\n+      {\"ALL|ANYONECANPAY\", SIGHASH_ALL | SIGHASH_ANYONECANPAY},\n+      {\"NONE|ANYONECANPAY\", SIGHASH_NONE | SIGHASH_ANYONECANPAY},\n+      {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE | SIGHASH_ANYONECANPAY},\n };\n \n static bool findSighashFlags(int& flags, const string& flagStr)\n@@ -309,14 +309,14 @@ static bool findSighashFlags(int& flags, const string& flagStr)\n     return false;\n }\n \n-uint256 ParseHashUO(map<string,UniValue>& o, string strKey)\n+uint256 ParseHashUO(map<string, UniValue>& o, string strKey)\n {\n     if (!o.count(strKey))\n         return 0;\n     return ParseHashUV(o[strKey], strKey);\n }\n \n-vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n+vector<unsigned char> ParseHexUO(map<string, UniValue>& o, string strKey)\n {\n     if (!o.count(strKey)) {\n         vector<unsigned char> emptyVec;\n@@ -372,7 +372,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n             if (!prevOut.isObject())\n                 throw runtime_error(\"expected prevtxs internal object\");\n \n-            map<string,UniValue::VType> types = map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n+            map<string, UniValue::VType> types = map_list_of(\"txid\", UniValue::VSTR)(\"vout\", UniValue::VNUM)(\"scriptPubKey\", UniValue::VSTR);\n             if (!prevOut.checkObject(types))\n                 throw runtime_error(\"prevtxs internal object typecheck fail\");\n \n@@ -389,12 +389,12 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n                 CCoinsModifier coins = view.ModifyCoins(txid);\n                 if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n                     string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + coins->vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\"+\n-                        scriptPubKey.ToString();\n+                    err = err + coins->vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\" +\n+                          scriptPubKey.ToString();\n                     throw runtime_error(err);\n                 }\n                 if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n+                    coins->vout.resize(nOut + 1);\n                 coins->vout[nOut].scriptPubKey = scriptPubKey;\n                 coins->vout[nOut].nValue = 0; // we don't know the actual output value\n             }\n@@ -431,7 +431,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n             SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants) {\n+        BOOST_FOREACH (const CTransaction& txv, txVariants) {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, SignatureChecker(mergedTx, i)))\n@@ -446,8 +446,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     tx = mergedTx;\n }\n \n-static void MutateTx(CMutableTransaction& tx, const string& command,\n-                     const string& commandVal)\n+static void MutateTx(CMutableTransaction& tx, const string& command, const string& commandVal)\n {\n     if (command == \"nversion\")\n         MutateTxVersion(tx, commandVal);\n@@ -545,7 +544,7 @@ static int CommandLineRawTx(int argc, char* argv[])\n \n             // param: hex-encoded bitcoin transaction\n             string strHexTx(argv[1]);\n-            if (strHexTx == \"-\")                 // \"-\" implies standard input\n+            if (strHexTx == \"-\") // \"-\" implies standard input\n                 strHexTx = readStdin();\n \n             if (!DecodeHexTx(txDecodeTmp, strHexTx))\n@@ -576,12 +575,10 @@ static int CommandLineRawTx(int argc, char* argv[])\n \n     catch (boost::thread_interrupted) {\n         throw;\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         strPrint = string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n-    }\n-    catch (...) {\n+    } catch (...) {\n         PrintExceptionContinue(NULL, \"CommandLineRawTx()\");\n         throw;\n     }\n@@ -597,10 +594,9 @@ int main(int argc, char* argv[])\n     SetupEnvironment();\n \n     try {\n-        if(!AppInitRawTx(argc, argv))\n+        if (!AppInitRawTx(argc, argv))\n             return EXIT_FAILURE;\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n     } catch (...) {\n@@ -611,8 +607,7 @@ int main(int argc, char* argv[])\n     int ret = EXIT_FAILURE;\n     try {\n         ret = CommandLineRawTx(argc, argv);\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"CommandLineRawTx()\");\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"CommandLineRawTx()\");"
      },
      {
        "sha": "fdbeca0a66aca0a196cba70d118eac055d1214c2",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 32,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -37,13 +37,11 @@ void DetectShutdownThread(boost::thread_group* threadGroup)\n {\n     bool fShutdown = ShutdownRequested();\n     // Tell the main threads to shutdown.\n-    while (!fShutdown)\n-    {\n+    while (!fShutdown) {\n         MilliSleep(200);\n         fShutdown = ShutdownRequested();\n     }\n-    if (threadGroup)\n-    {\n+    if (threadGroup) {\n         threadGroup->interrupt_all();\n         threadGroup->join_all();\n     }\n@@ -67,18 +65,14 @@ bool AppInit(int argc, char* argv[])\n     ParseParameters(argc, argv);\n \n     // Process help and version before taking care about datadir\n-    if (mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\"))\n-    {\n+    if (mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\")) {\n         std::string strUsage = _(\"Bitcoin Core Daemon\") + \" \" + _(\"version\") + \" \" + FormatFullVersion() + \"\\n\";\n \n-        if (mapArgs.count(\"-version\"))\n-        {\n+        if (mapArgs.count(\"-version\")) {\n             strUsage += LicenseInfo();\n-        }\n-        else\n-        {\n+        } else {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\";\n+                        \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n         }\n@@ -87,18 +81,15 @@ bool AppInit(int argc, char* argv[])\n         return false;\n     }\n \n-    try\n-    {\n-        if (!boost::filesystem::is_directory(GetDataDir(false)))\n-        {\n+    try {\n+        if (!boost::filesystem::is_directory(GetDataDir(false))) {\n             fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n             return false;\n         }\n-        try\n-        {\n+        try {\n             ReadConfigFile(mapArgs, mapMultiArgs);\n-        } catch(std::exception &e) {\n-            fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+        } catch (std::exception& e) {\n+            fprintf(stderr, \"Error reading configuration file: %s\\n\", e.what());\n             return false;\n         }\n         // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n@@ -113,21 +104,18 @@ bool AppInit(int argc, char* argv[])\n             if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"bitcoin:\"))\n                 fCommandLine = true;\n \n-        if (fCommandLine)\n-        {\n+        if (fCommandLine) {\n             fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n             exit(1);\n         }\n #ifndef WIN32\n         fDaemon = GetBoolArg(\"-daemon\", false);\n-        if (fDaemon)\n-        {\n+        if (fDaemon) {\n             fprintf(stdout, \"Bitcoin server starting\\n\");\n \n             // Daemonize\n             pid_t pid = fork();\n-            if (pid < 0)\n-            {\n+            if (pid < 0) {\n                 fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n                 return false;\n             }\n@@ -146,15 +134,13 @@ bool AppInit(int argc, char* argv[])\n \n         detectShutdownThread = new boost::thread(boost::bind(&DetectShutdownThread, &threadGroup));\n         fRet = AppInit2(threadGroup);\n-    }\n-    catch (std::exception& e) {\n+    } catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInit()\");\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"AppInit()\");\n     }\n \n-    if (!fRet)\n-    {\n+    if (!fRet) {\n         if (detectShutdownThread)\n             detectShutdownThread->interrupt();\n \n@@ -164,8 +150,7 @@ bool AppInit(int argc, char* argv[])\n         // thread-blocking-waiting-for-another-thread-during-startup case\n     }\n \n-    if (detectShutdownThread)\n-    {\n+    if (detectShutdownThread) {\n         detectShutdownThread->join();\n         delete detectShutdownThread;\n         detectShutdownThread = NULL;"
      },
      {
        "sha": "439e6da9440e4d158181eb342a1c43f3af0106c6",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 22,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -30,7 +30,7 @@ using namespace std;\n  * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n  */\n CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn)\n-    : vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    : vData(min((unsigned int)(-1 / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n       isFull(false),\n       isEmpty(false),\n       nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n@@ -49,8 +49,7 @@ void CBloomFilter::insert(const vector<unsigned char>& vKey)\n {\n     if (isFull)\n         return;\n-    for (unsigned int i = 0; i < nHashFuncs; i++)\n-    {\n+    for (unsigned int i = 0; i < nHashFuncs; i++) {\n         unsigned int nIndex = Hash(i, vKey);\n         // Sets bit nIndex of vData\n         vData[nIndex >> 3] |= (1 << (7 & nIndex));\n@@ -78,8 +77,7 @@ bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n         return true;\n     if (isEmpty)\n         return false;\n-    for (unsigned int i = 0; i < nHashFuncs; i++)\n-    {\n+    for (unsigned int i = 0; i < nHashFuncs; i++) {\n         unsigned int nIndex = Hash(i, vKey);\n         // Checks bit nIndex of vData\n         if (!(vData[nIndex >> 3] & (1 << (7 & nIndex))))\n@@ -104,7 +102,7 @@ bool CBloomFilter::contains(const uint256& hash) const\n \n void CBloomFilter::clear()\n {\n-    vData.assign(vData.size(),0);\n+    vData.assign(vData.size(), 0);\n     isFull = false;\n     isEmpty = true;\n }\n@@ -127,31 +125,27 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n     if (contains(hash))\n         fFound = true;\n \n-    for (unsigned int i = 0; i < tx.vout.size(); i++)\n-    {\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n         const CTxOut& txout = tx.vout[i];\n         // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n         // If this matches, also add the specific output that was matched.\n-        // This means clients don't have to update the filter themselves when a new relevant tx \n+        // This means clients don't have to update the filter themselves when a new relevant tx\n         // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n         CScript::const_iterator pc = txout.scriptPubKey.begin();\n         vector<unsigned char> data;\n-        while (pc < txout.scriptPubKey.end())\n-        {\n+        while (pc < txout.scriptPubKey.end()) {\n             opcodetype opcode;\n             if (!txout.scriptPubKey.GetOp(pc, opcode, data))\n                 break;\n-            if (data.size() != 0 && contains(data))\n-            {\n+            if (data.size() != 0 && contains(data)) {\n                 fFound = true;\n                 if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_ALL)\n                     insert(COutPoint(hash, i));\n-                else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n-                {\n+                else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY) {\n                     txnouttype type;\n                     vector<vector<unsigned char> > vSolutions;\n                     if (Solver(txout.scriptPubKey, type, vSolutions) &&\n-                            (type == TX_PUBKEY || type == TX_MULTISIG))\n+                        (type == TX_PUBKEY || type == TX_MULTISIG))\n                         insert(COutPoint(hash, i));\n                 }\n                 break;\n@@ -162,17 +156,15 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n     if (fFound)\n         return true;\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-    {\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n         // Match if the filter contains an outpoint tx spends\n         if (contains(txin.prevout))\n             return true;\n \n         // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n         CScript::const_iterator pc = txin.scriptSig.begin();\n         vector<unsigned char> data;\n-        while (pc < txin.scriptSig.end())\n-        {\n+        while (pc < txin.scriptSig.end()) {\n             opcodetype opcode;\n             if (!txin.scriptSig.GetOp(pc, opcode, data))\n                 break;\n@@ -188,8 +180,7 @@ void CBloomFilter::UpdateEmptyFull()\n {\n     bool full = true;\n     bool empty = true;\n-    for (unsigned int i = 0; i < vData.size(); i++)\n-    {\n+    for (unsigned int i = 0; i < vData.size(); i++) {\n         full &= vData[i] == 0xff;\n         empty &= vData[i] == 0;\n     }"
      },
      {
        "sha": "d7bb53efa775e61d66928b20d747a4296f63b4bb",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -10,7 +10,8 @@ using namespace std;\n /**\n  * CChain implementation\n  */\n-void CChain::SetTip(CBlockIndex *pindex) {\n+void CChain::SetTip(CBlockIndex* pindex)\n+{\n     if (pindex == NULL) {\n         vChain.clear();\n         return;\n@@ -22,7 +23,8 @@ void CChain::SetTip(CBlockIndex *pindex) {\n     }\n }\n \n-CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n+CBlockLocator CChain::GetLocator(const CBlockIndex* pindex) const\n+{\n     int nStep = 1;\n     std::vector<uint256> vHave;\n     vHave.reserve(32);\n@@ -50,7 +52,8 @@ CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n     return CBlockLocator(vHave);\n }\n \n-const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n+const CBlockIndex* CChain::FindFork(const CBlockIndex* pindex) const\n+{\n     if (pindex->nHeight > Height())\n         pindex = pindex->GetAncestor(Height());\n     while (pindex && !Contains(pindex))"
      },
      {
        "sha": "d96ec059b3673266e5a72f339774418c3d6d8292",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 68,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -12,88 +12,89 @@\n \n #include <boost/foreach.hpp>\n \n-namespace Checkpoints {\n-\n-    /**\n+namespace Checkpoints\n+{\n+/**\n      * How many times we expect transactions after the last checkpoint to\n      * be slower. This number is a compromise, as it can't be accurate for\n      * every system. When reindexing from a fast disk with a slow CPU, it\n      * can be up to 20, while when downloading from a slow network with a\n      * fast multicore CPU, it won't be much higher than 1.\n      */\n-    static const double SIGCHECK_VERIFICATION_FACTOR = 5.0;\n-\n-    bool fEnabled = true;\n-\n-    bool CheckBlock(int nHeight, const uint256& hash)\n-    {\n-        if (!fEnabled)\n-            return true;\n-\n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n-\n-        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n-        if (i == checkpoints.end()) return true;\n-        return hash == i->second;\n+static const double SIGCHECK_VERIFICATION_FACTOR = 5.0;\n+\n+bool fEnabled = true;\n+\n+bool CheckBlock(int nHeight, const uint256& hash)\n+{\n+    if (!fEnabled)\n+        return true;\n+\n+    const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+\n+    MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n+    if (i == checkpoints.end())\n+        return true;\n+    return hash == i->second;\n+}\n+\n+//! Guess how far we are in the verification process at the given block index\n+double GuessVerificationProgress(CBlockIndex* pindex, bool fSigchecks)\n+{\n+    if (pindex == NULL)\n+        return 0.0;\n+\n+    int64_t nNow = time(NULL);\n+\n+    double fSigcheckVerificationFactor = fSigchecks ? SIGCHECK_VERIFICATION_FACTOR : 1.0;\n+    double fWorkBefore = 0.0; // Amount of work done before pindex\n+    double fWorkAfter = 0.0;  // Amount of work left after pindex (estimated)\n+    // Work is defined as: 1.0 per transaction before the last checkpoint, and\n+    // fSigcheckVerificationFactor per transaction after.\n+\n+    const CCheckpointData& data = Params().Checkpoints();\n+\n+    if (pindex->nChainTx <= data.nTransactionsLastCheckpoint) {\n+        double nCheapBefore = pindex->nChainTx;\n+        double nCheapAfter = data.nTransactionsLastCheckpoint - pindex->nChainTx;\n+        double nExpensiveAfter = (nNow - data.nTimeLastCheckpoint) / 86400.0 * data.fTransactionsPerDay;\n+        fWorkBefore = nCheapBefore;\n+        fWorkAfter = nCheapAfter + nExpensiveAfter * fSigcheckVerificationFactor;\n+    } else {\n+        double nCheapBefore = data.nTransactionsLastCheckpoint;\n+        double nExpensiveBefore = pindex->nChainTx - data.nTransactionsLastCheckpoint;\n+        double nExpensiveAfter = (nNow - pindex->GetBlockTime()) / 86400.0 * data.fTransactionsPerDay;\n+        fWorkBefore = nCheapBefore + nExpensiveBefore * fSigcheckVerificationFactor;\n+        fWorkAfter = nExpensiveAfter * fSigcheckVerificationFactor;\n     }\n \n-    //! Guess how far we are in the verification process at the given block index\n-    double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks) {\n-        if (pindex==NULL)\n-            return 0.0;\n-\n-        int64_t nNow = time(NULL);\n-\n-        double fSigcheckVerificationFactor = fSigchecks ? SIGCHECK_VERIFICATION_FACTOR : 1.0;\n-        double fWorkBefore = 0.0; // Amount of work done before pindex\n-        double fWorkAfter = 0.0;  // Amount of work left after pindex (estimated)\n-        // Work is defined as: 1.0 per transaction before the last checkpoint, and\n-        // fSigcheckVerificationFactor per transaction after.\n-\n-        const CCheckpointData &data = Params().Checkpoints();\n-\n-        if (pindex->nChainTx <= data.nTransactionsLastCheckpoint) {\n-            double nCheapBefore = pindex->nChainTx;\n-            double nCheapAfter = data.nTransactionsLastCheckpoint - pindex->nChainTx;\n-            double nExpensiveAfter = (nNow - data.nTimeLastCheckpoint)/86400.0*data.fTransactionsPerDay;\n-            fWorkBefore = nCheapBefore;\n-            fWorkAfter = nCheapAfter + nExpensiveAfter*fSigcheckVerificationFactor;\n-        } else {\n-            double nCheapBefore = data.nTransactionsLastCheckpoint;\n-            double nExpensiveBefore = pindex->nChainTx - data.nTransactionsLastCheckpoint;\n-            double nExpensiveAfter = (nNow - pindex->GetBlockTime())/86400.0*data.fTransactionsPerDay;\n-            fWorkBefore = nCheapBefore + nExpensiveBefore*fSigcheckVerificationFactor;\n-            fWorkAfter = nExpensiveAfter*fSigcheckVerificationFactor;\n-        }\n-\n-        return fWorkBefore / (fWorkBefore + fWorkAfter);\n-    }\n+    return fWorkBefore / (fWorkBefore + fWorkAfter);\n+}\n \n-    int GetTotalBlocksEstimate()\n-    {\n-        if (!fEnabled)\n-            return 0;\n+int GetTotalBlocksEstimate()\n+{\n+    if (!fEnabled)\n+        return 0;\n \n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+    const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n \n-        return checkpoints.rbegin()->first;\n-    }\n+    return checkpoints.rbegin()->first;\n+}\n \n-    CBlockIndex* GetLastCheckpoint()\n-    {\n-        if (!fEnabled)\n-            return NULL;\n+CBlockIndex* GetLastCheckpoint()\n+{\n+    if (!fEnabled)\n+        return NULL;\n \n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+    const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n \n-        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n-        {\n-            const uint256& hash = i.second;\n-            BlockMap::const_iterator t = mapBlockIndex.find(hash);\n-            if (t != mapBlockIndex.end())\n-                return t->second;\n-        }\n-        return NULL;\n+    BOOST_REVERSE_FOREACH (const MapCheckpoints::value_type& i, checkpoints) {\n+        const uint256& hash = i.second;\n+        BlockMap::const_iterator t = mapBlockIndex.find(hash);\n+        if (t != mapBlockIndex.end())\n+            return t->second;\n     }\n+    return NULL;\n+}\n \n } // namespace Checkpoints"
      },
      {
        "sha": "6410e1cd88a1daf98151964a48d78d1509111f73",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -99,11 +99,10 @@ std::string FormatSubVersion(const std::string& name, int nClientVersion, const\n     std::ostringstream ss;\n     ss << \"/\";\n     ss << name << \":\" << FormatVersion(nClientVersion);\n-    if (!comments.empty())\n-    {\n+    if (!comments.empty()) {\n         std::vector<std::string>::const_iterator it(comments.begin());\n         ss << \"(\" << *it;\n-        for(++it; it != comments.end(); ++it)\n+        for (++it; it != comments.end(); ++it)\n             ss << \"; \" << *it;\n         ss << \")\";\n     }"
      },
      {
        "sha": "dcc43afbaaefbab4b888b1cf80e04c6d2fdffcbb",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 34,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,12 +13,13 @@\n  * each bit in the bitmask represents the availability of one output, but the\n  * availabilities of the first two outputs are encoded separately\n  */\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n+void CCoins::CalcMaskSize(unsigned int& nBytes, unsigned int& nNonzeroBytes) const\n+{\n     unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n+    for (unsigned int b = 0; 2 + b * 8 < vout.size(); b++) {\n         bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n+        for (unsigned int i = 0; i < 8 && 2 + b * 8 + i < vout.size(); i++) {\n+            if (!vout[2 + b * 8 + i].IsNull()) {\n                 fZero = false;\n                 continue;\n             }\n@@ -31,7 +32,8 @@ void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) con\n     nBytes += nLastUsedByte;\n }\n \n-bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n+bool CCoins::Spend(const COutPoint& out, CTxInUndo& undo)\n+{\n     if (out.n >= vout.size())\n         return false;\n     if (vout[out.n].IsNull())\n@@ -47,38 +49,40 @@ bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n     return true;\n }\n \n-bool CCoins::Spend(int nPos) {\n+bool CCoins::Spend(int nPos)\n+{\n     CTxInUndo undo;\n     COutPoint out(0, nPos);\n     return Spend(out, undo);\n }\n \n \n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n+bool CCoinsView::GetCoins(const uint256& txid, CCoins& coins) const { return false; }\n+bool CCoinsView::HaveCoins(const uint256& txid) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(0); }\n-bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n-bool CCoinsView::GetStats(CCoinsStats &stats) const { return false; }\n+bool CCoinsView::BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) { return false; }\n+bool CCoinsView::GetStats(CCoinsStats& stats) const { return false; }\n \n \n-CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n+CCoinsViewBacked::CCoinsViewBacked(CCoinsView* viewIn) : base(viewIn) {}\n+bool CCoinsViewBacked::GetCoins(const uint256& txid, CCoins& coins) const { return base->GetCoins(txid, coins); }\n+bool CCoinsViewBacked::HaveCoins(const uint256& txid) const { return base->HaveCoins(txid); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n-void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n-bool CCoinsViewBacked::GetStats(CCoinsStats &stats) const { return base->GetStats(stats); }\n+void CCoinsViewBacked::SetBackend(CCoinsView& viewIn) { base = &viewIn; }\n+bool CCoinsViewBacked::BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n+bool CCoinsViewBacked::GetStats(CCoinsStats& stats) const { return base->GetStats(stats); }\n \n CCoinsKeyHasher::CCoinsKeyHasher() : salt(GetRandHash()) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), hashBlock(0) { }\n+CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), hashBlock(0) {}\n \n CCoinsViewCache::~CCoinsViewCache()\n {\n     assert(!hasModifier);\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n+CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256& txid) const\n+{\n     CCoinsMap::iterator it = cacheCoins.find(txid);\n     if (it != cacheCoins.end())\n         return it;\n@@ -95,7 +99,8 @@ CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewCache::GetCoins(const uint256& txid, CCoins& coins) const\n+{\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     if (it != cacheCoins.end()) {\n         coins = it->second.coins;\n@@ -104,7 +109,8 @@ bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n     return false;\n }\n \n-CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n+CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256& txid)\n+{\n     assert(!hasModifier);\n     hasModifier = true;\n     std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n@@ -123,7 +129,8 @@ CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n     return CCoinsModifier(*this, ret.first);\n }\n \n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n+const CCoins* CCoinsViewCache::AccessCoins(const uint256& txid) const\n+{\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     if (it == cacheCoins.end()) {\n         return NULL;\n@@ -132,7 +139,8 @@ const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n     }\n }\n \n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n+bool CCoinsViewCache::HaveCoins(const uint256& txid) const\n+{\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     // We're using vtx.empty() instead of IsPruned here for performance reasons,\n     // as we only care about the case where a transaction was replaced entirely\n@@ -141,17 +149,20 @@ bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n     return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n }\n \n-uint256 CCoinsViewCache::GetBestBlock() const {\n+uint256 CCoinsViewCache::GetBestBlock() const\n+{\n     if (hashBlock == uint256(0))\n         hashBlock = base->GetBestBlock();\n     return hashBlock;\n }\n \n-void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n+void CCoinsViewCache::SetBestBlock(const uint256& hashBlockIn)\n+{\n     hashBlock = hashBlockIn;\n }\n \n-bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n+bool CCoinsViewCache::BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlockIn)\n+{\n     assert(!hasModifier);\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) { // Ignore non-dirty entries (optimization).\n@@ -187,17 +198,19 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n     return true;\n }\n \n-bool CCoinsViewCache::Flush() {\n+bool CCoinsViewCache::Flush()\n+{\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n     return fOk;\n }\n \n-unsigned int CCoinsViewCache::GetCacheSize() const {\n+unsigned int CCoinsViewCache::GetCacheSize() const\n+{\n     return cacheCoins.size();\n }\n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n+const CTxOut& CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n {\n     const CCoins* coins = AccessCoins(input.prevout.hash);\n     assert(coins && coins->IsAvailable(input.prevout.n));\n@@ -220,7 +233,7 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n+            const COutPoint& prevout = tx.vin[i].prevout;\n             const CCoins* coins = AccessCoins(prevout.hash);\n             if (!coins || !coins->IsAvailable(prevout.n)) {\n                 return false;\n@@ -230,18 +243,18 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n     return true;\n }\n \n-double CCoinsViewCache::GetPriority(const CTransaction &tx, int nHeight) const\n+double CCoinsViewCache::GetPriority(const CTransaction& tx, int nHeight) const\n {\n     if (tx.IsCoinBase())\n         return 0.0;\n     double dResult = 0.0;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-    {\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n         const CCoins* coins = AccessCoins(txin.prevout.hash);\n         assert(coins);\n-        if (!coins->IsAvailable(txin.prevout.n)) continue;\n+        if (!coins->IsAvailable(txin.prevout.n))\n+            continue;\n         if (coins->nHeight < nHeight) {\n-            dResult += coins->vout[txin.prevout.n].nValue * (nHeight-coins->nHeight);\n+            dResult += coins->vout[txin.prevout.n].nValue * (nHeight - coins->nHeight);\n         }\n     }\n     return tx.ComputePriority(dResult);"
      },
      {
        "sha": "1777a04449c19f2e686d1cb18999b48871c553f4",
        "filename": "src/compat/glibcxx_compat.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compat/glibcxx_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compat/glibcxx_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_compat.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -30,7 +30,8 @@ const char* bad_alloc::what() const throw()\n \n namespace __detail\n {\n-struct _List_node_base {\n+struct _List_node_base\n+{\n     void _M_hook(std::__detail::_List_node_base* const __position) throw() __attribute__((used))\n     {\n         _M_next = __position;"
      },
      {
        "sha": "517f0eb4a36369c995ed6534e83c54ce2d472f0b",
        "filename": "src/compat/strnlen.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compat/strnlen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compat/strnlen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/strnlen.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -9,9 +9,9 @@\n #include <cstring>\n \n #if HAVE_DECL_STRNLEN == 0\n-size_t strnlen( const char *start, size_t max_len)\n+size_t strnlen(const char* start, size_t max_len)\n {\n-    const char *end = (const char *)memchr(start, '\\0', max_len);\n+    const char* end = (const char*)memchr(start, '\\0', max_len);\n \n     return end ? (size_t)(end - start) : max_len;\n }"
      },
      {
        "sha": "842ac6543763484adb9d58b0668f9db6b7ecc8e4",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 19,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -9,43 +9,38 @@\n #include \"pubkey.h\"\n #include \"script/standard.h\"\n \n-bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n+bool CScriptCompressor::IsToKeyID(CKeyID& hash) const\n {\n-    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n-                            && script[2] == 20 && script[23] == OP_EQUALVERIFY\n-                            && script[24] == OP_CHECKSIG) {\n+    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160 && script[2] == 20 && script[23] == OP_EQUALVERIFY && script[24] == OP_CHECKSIG) {\n         memcpy(&hash, &script[3], 20);\n         return true;\n     }\n     return false;\n }\n \n-bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n+bool CScriptCompressor::IsToScriptID(CScriptID& hash) const\n {\n-    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n-                            && script[22] == OP_EQUAL) {\n+    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20 && script[22] == OP_EQUAL) {\n         memcpy(&hash, &script[2], 20);\n         return true;\n     }\n     return false;\n }\n \n-bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n+bool CScriptCompressor::IsToPubKey(CPubKey& pubkey) const\n {\n-    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n-                            && (script[1] == 0x02 || script[1] == 0x03)) {\n+    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG && (script[1] == 0x02 || script[1] == 0x03)) {\n         pubkey.Set(&script[1], &script[34]);\n         return true;\n     }\n-    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n-                            && script[1] == 0x04) {\n+    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG && script[1] == 0x04) {\n         pubkey.Set(&script[1], &script[66]);\n         return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n     }\n     return false;\n }\n \n-bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n+bool CScriptCompressor::Compress(std::vector<unsigned char>& out) const\n {\n     CKeyID keyID;\n     if (IsToKeyID(keyID)) {\n@@ -85,9 +80,9 @@ unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n     return 0;\n }\n \n-bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n+bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char>& in)\n {\n-    switch(nSize) {\n+    switch (nSize) {\n     case 0x00:\n         script.resize(25);\n         script[0] = OP_DUP;\n@@ -152,9 +147,9 @@ uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n         int d = (n % 10);\n         assert(d >= 1 && d <= 9);\n         n /= 10;\n-        return 1 + (n*9 + d - 1)*10 + e;\n+        return 1 + (n * 9 + d - 1) * 10 + e;\n     } else {\n-        return 1 + (n - 1)*10 + 9;\n+        return 1 + (n - 1) * 10 + 9;\n     }\n }\n \n@@ -173,9 +168,9 @@ uint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n         int d = (x % 9) + 1;\n         x /= 9;\n         // x = n\n-        n = x*10 + d;\n+        n = x * 10 + d;\n     } else {\n-        n = x+1;\n+        n = x + 1;\n     }\n     while (e) {\n         n *= 10;"
      },
      {
        "sha": "b1c875230322e066d87b073831c149825426bbce",
        "filename": "src/core/block.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 22,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/block.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -57,17 +57,14 @@ uint256 CBlock::BuildMerkleTree(bool* fMutated) const\n         vMerkleTree.push_back(it->GetHash());\n     int j = 0;\n     bool mutated = false;\n-    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-    {\n-        for (int i = 0; i < nSize; i += 2)\n-        {\n-            int i2 = std::min(i+1, nSize-1);\n-            if (i2 == i + 1 && i2 + 1 == nSize && vMerkleTree[j+i] == vMerkleTree[j+i2]) {\n+    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2) {\n+        for (int i = 0; i < nSize; i += 2) {\n+            int i2 = std::min(i + 1, nSize - 1);\n+            if (i2 == i + 1 && i2 + 1 == nSize && vMerkleTree[j + i] == vMerkleTree[j + i2]) {\n                 // Two identical hashes at the end of the list at a particular level.\n                 mutated = true;\n             }\n-            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-                                       BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j + i]), END(vMerkleTree[j + i]), BEGIN(vMerkleTree[j + i2]), END(vMerkleTree[j + i2])));\n         }\n         j += nSize;\n     }\n@@ -83,10 +80,9 @@ std::vector<uint256> CBlock::GetMerkleBranch(int nIndex) const\n         BuildMerkleTree();\n     std::vector<uint256> vMerkleBranch;\n     int j = 0;\n-    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-    {\n-        int i = std::min(nIndex^1, nSize-1);\n-        vMerkleBranch.push_back(vMerkleTree[j+i]);\n+    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2) {\n+        int i = std::min(nIndex ^ 1, nSize - 1);\n+        vMerkleBranch.push_back(vMerkleTree[j + i]);\n         nIndex >>= 1;\n         j += nSize;\n     }\n@@ -97,8 +93,7 @@ uint256 CBlock::CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMer\n {\n     if (nIndex == -1)\n         return 0;\n-    for (std::vector<uint256>::const_iterator it(vMerkleBranch.begin()); it != vMerkleBranch.end(); ++it)\n-    {\n+    for (std::vector<uint256>::const_iterator it(vMerkleBranch.begin()); it != vMerkleBranch.end(); ++it) {\n         if (nIndex & 1)\n             hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));\n         else\n@@ -112,14 +107,15 @@ std::string CBlock::ToString() const\n {\n     std::stringstream s;\n     s << strprintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%u)\\n\",\n-        GetHash().ToString(),\n-        nVersion,\n-        hashPrevBlock.ToString(),\n-        hashMerkleRoot.ToString(),\n-        nTime, nBits, nNonce,\n-        vtx.size());\n-    for (unsigned int i = 0; i < vtx.size(); i++)\n-    {\n+                   GetHash().ToString(),\n+                   nVersion,\n+                   hashPrevBlock.ToString(),\n+                   hashMerkleRoot.ToString(),\n+                   nTime,\n+                   nBits,\n+                   nNonce,\n+                   vtx.size());\n+    for (unsigned int i = 0; i < vtx.size(); i++) {\n         s << \"  \" << vtx[i].ToString() << \"\\n\";\n     }\n     s << \"  vMerkleTree: \";"
      },
      {
        "sha": "81437f90626b6a099a90c866e96200d044ffa51d",
        "filename": "src/core/transaction.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 16,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/transaction.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -11,7 +11,7 @@\n \n std::string COutPoint::ToString() const\n {\n-    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10), n);\n+    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0, 10), n);\n }\n \n CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)\n@@ -36,7 +36,7 @@ std::string CTxIn::ToString() const\n     if (prevout.IsNull())\n         str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n     else\n-        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24));\n+        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0, 24));\n     if (nSequence != std::numeric_limits<unsigned int>::max())\n         str += strprintf(\", nSequence=%u\", nSequence);\n     str += \")\";\n@@ -56,7 +56,7 @@ uint256 CTxOut::GetHash() const\n \n std::string CTxOut::ToString() const\n {\n-    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30));\n+    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0, 30));\n }\n \n CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\n@@ -72,13 +72,15 @@ void CTransaction::UpdateHash() const\n     *const_cast<uint256*>(&hash) = SerializeHash(*this);\n }\n \n-CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { }\n+CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) {}\n \n-CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {\n+CTransaction::CTransaction(const CMutableTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime)\n+{\n     UpdateHash();\n }\n \n-CTransaction& CTransaction::operator=(const CTransaction &tx) {\n+CTransaction& CTransaction::operator=(const CTransaction& tx)\n+{\n     *const_cast<int*>(&nVersion) = tx.nVersion;\n     *const_cast<std::vector<CTxIn>*>(&vin) = tx.vin;\n     *const_cast<std::vector<CTxOut>*>(&vout) = tx.vout;\n@@ -90,8 +92,7 @@ CTransaction& CTransaction::operator=(const CTransaction &tx) {\n CAmount CTransaction::GetValueOut() const\n {\n     CAmount nValueOut = 0;\n-    for (std::vector<CTxOut>::const_iterator it(vout.begin()); it != vout.end(); ++it)\n-    {\n+    for (std::vector<CTxOut>::const_iterator it(vout.begin()); it != vout.end(); ++it) {\n         nValueOut += it->nValue;\n         if (!MoneyRange(it->nValue) || !MoneyRange(nValueOut))\n             throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n@@ -102,7 +103,8 @@ CAmount CTransaction::GetValueOut() const\n double CTransaction::ComputePriority(double dPriorityInputs, unsigned int nTxSize) const\n {\n     nTxSize = CalculateModifiedSize(nTxSize);\n-    if (nTxSize == 0) return 0.0;\n+    if (nTxSize == 0)\n+        return 0.0;\n \n     return dPriorityInputs / nTxSize;\n }\n@@ -116,8 +118,7 @@ unsigned int CTransaction::CalculateModifiedSize(unsigned int nTxSize) const\n     // risk encouraging people to create junk outputs to redeem later.\n     if (nTxSize == 0)\n         nTxSize = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\n-    for (std::vector<CTxIn>::const_iterator it(vin.begin()); it != vin.end(); ++it)\n-    {\n+    for (std::vector<CTxIn>::const_iterator it(vin.begin()); it != vin.end(); ++it) {\n         unsigned int offset = 41U + std::min(110U, (unsigned int)it->scriptSig.size());\n         if (nTxSize > offset)\n             nTxSize -= offset;\n@@ -129,11 +130,11 @@ std::string CTransaction::ToString() const\n {\n     std::string str;\n     str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\\n\",\n-        GetHash().ToString().substr(0,10),\n-        nVersion,\n-        vin.size(),\n-        vout.size(),\n-        nLockTime);\n+                     GetHash().ToString().substr(0, 10),\n+                     nVersion,\n+                     vin.size(),\n+                     vout.size(),\n+                     nLockTime);\n     for (unsigned int i = 0; i < vin.size(); i++)\n         str += \"    \" + vin[i].ToString() + \"\\n\";\n     for (unsigned int i = 0; i < vout.size(); i++)"
      },
      {
        "sha": "3ef3663e93286f21386a712a321bf9573dadb4c9",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 32,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -30,10 +30,8 @@ CScript ParseScript(std::string s)\n \n     static map<string, opcodetype> mapOpNames;\n \n-    if (mapOpNames.empty())\n-    {\n-        for (int op = 0; op <= OP_NOP10; op++)\n-        {\n+    if (mapOpNames.empty()) {\n+        for (int op = 0; op <= OP_NOP10; op++) {\n             // Allow OP_RESERVED to get into mapOpNames\n             if (op < OP_NOP && op != OP_RESERVED)\n                 continue;\n@@ -52,39 +50,27 @@ CScript ParseScript(std::string s)\n     vector<string> words;\n     split(words, s, is_any_of(\" \\t\\n\"), token_compress_on);\n \n-    for (std::vector<std::string>::const_iterator w = words.begin(); w != words.end(); ++w)\n-    {\n-        if (w->empty())\n-        {\n+    for (std::vector<std::string>::const_iterator w = words.begin(); w != words.end(); ++w) {\n+        if (w->empty()) {\n             // Empty string, ignore. (boost::split given '' will return one word)\n-        }\n-        else if (all(*w, is_digit()) ||\n-            (starts_with(*w, \"-\") && all(string(w->begin()+1, w->end()), is_digit())))\n-        {\n+        } else if (all(*w, is_digit()) ||\n+                   (starts_with(*w, \"-\") && all(string(w->begin() + 1, w->end()), is_digit()))) {\n             // Number\n             int64_t n = atoi64(*w);\n             result << n;\n-        }\n-        else if (starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(string(w->begin()+2, w->end())))\n-        {\n+        } else if (starts_with(*w, \"0x\") && (w->begin() + 2 != w->end()) && IsHex(string(w->begin() + 2, w->end()))) {\n             // Raw hex data, inserted NOT pushed onto stack:\n-            std::vector<unsigned char> raw = ParseHex(string(w->begin()+2, w->end()));\n+            std::vector<unsigned char> raw = ParseHex(string(w->begin() + 2, w->end()));\n             result.insert(result.end(), raw.begin(), raw.end());\n-        }\n-        else if (w->size() >= 2 && starts_with(*w, \"'\") && ends_with(*w, \"'\"))\n-        {\n+        } else if (w->size() >= 2 && starts_with(*w, \"'\") && ends_with(*w, \"'\")) {\n             // Single-quoted string, pushed as data. NOTE: this is poor-man's\n             // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n-            std::vector<unsigned char> value(w->begin()+1, w->end()-1);\n+            std::vector<unsigned char> value(w->begin() + 1, w->end() - 1);\n             result << value;\n-        }\n-        else if (mapOpNames.count(*w))\n-        {\n+        } else if (mapOpNames.count(*w)) {\n             // opcode, e.g. OP_ADD or ADD:\n             result << mapOpNames[*w];\n-        }\n-        else\n-        {\n+        } else {\n             throw runtime_error(\"script parse error\");\n         }\n     }\n@@ -101,8 +87,7 @@ bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx)\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ssData >> tx;\n-    }\n-    catch (const std::exception &) {\n+    } catch (const std::exception&) {\n         return false;\n     }\n \n@@ -118,8 +103,7 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     CDataStream ssBlock(blockData, SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ssBlock >> block;\n-    }\n-    catch (const std::exception &) {\n+    } catch (const std::exception&) {\n         return false;\n     }\n \n@@ -132,7 +116,7 @@ uint256 ParseHashUV(const UniValue& v, const string& strName)\n     if (v.isStr())\n         strHex = v.getValStr();\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n \n     uint256 result;\n     result.SetHex(strHex);\n@@ -145,6 +129,6 @@ vector<unsigned char> ParseHexUV(const UniValue& v, const string& strName)\n     if (v.isStr())\n         strHex = v.getValStr();\n     if (!IsHex(strHex))\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     return ParseHex(strHex);\n }"
      },
      {
        "sha": "ca3c13fb9232a558453bcefc91dd084ba60cd7c0",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -62,7 +62,8 @@ string EncodeHexTx(const CTransaction& tx)\n }\n \n void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n-                        UniValue& out, bool fIncludeHex)\n+                        UniValue& out,\n+                        bool fIncludeHex)\n {\n     txnouttype type;\n     vector<CTxDestination> addresses;\n@@ -81,7 +82,7 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+    BOOST_FOREACH (const CTxDestination& addr, addresses)\n         a.push_back(CBitcoinAddress(addr).ToString());\n     out.pushKV(\"addresses\", a);\n }\n@@ -93,7 +94,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));"
      },
      {
        "sha": "6a4e861b3a257f47b7791ac1e674bd77d9f4c592",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 42,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -21,11 +21,9 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n \n     int i = 0;\n     if (nDerivationMethod == 0)\n-        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n-                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0], (unsigned char*)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n \n-    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n-    {\n+    if (i != (int)WALLET_CRYPTO_KEY_SIZE) {\n         OPENSSL_cleanse(chKey, sizeof(chKey));\n         OPENSSL_cleanse(chIV, sizeof(chIV));\n         return false;\n@@ -47,7 +45,7 @@ bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigne\n     return true;\n }\n \n-bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n+bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char>& vchCiphertext)\n {\n     if (!fKeySet)\n         return false;\n@@ -56,19 +54,23 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n     // n + AES_BLOCK_SIZE - 1 bytes\n     int nLen = vchPlaintext.size();\n     int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n-    vchCiphertext = std::vector<unsigned char> (nCLen);\n+    vchCiphertext = std::vector<unsigned char>(nCLen);\n \n     EVP_CIPHER_CTX ctx;\n \n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n+    if (fOk)\n+        fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk)\n+        fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n+    if (fOk)\n+        fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n     EVP_CIPHER_CTX_cleanup(&ctx);\n \n-    if (!fOk) return false;\n+    if (!fOk)\n+        return false;\n \n     vchCiphertext.resize(nCLen + nFLen);\n     return true;\n@@ -90,24 +92,28 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n+    if (fOk)\n+        fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk)\n+        fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n+    if (fOk)\n+        fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n     EVP_CIPHER_CTX_cleanup(&ctx);\n \n-    if (!fOk) return false;\n+    if (!fOk)\n+        return false;\n \n     vchPlaintext.resize(nPLen + nFLen);\n     return true;\n }\n \n \n-bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n+bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial& vchPlaintext, const uint256& nIV, std::vector<unsigned char>& vchCiphertext)\n {\n     CCrypter cKeyCrypter;\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n     memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n-    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+    if (!cKeyCrypter.SetKey(vMasterKey, chIV))\n         return false;\n     return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n }\n@@ -117,7 +123,7 @@ bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned\n     CCrypter cKeyCrypter;\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n     memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n-    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+    if (!cKeyCrypter.SetKey(vMasterKey, chIV))\n         return false;\n     return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n }\n@@ -157,34 +163,29 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n         bool keyPass = false;\n         bool keyFail = false;\n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n-        for (; mi != mapCryptedKeys.end(); ++mi)\n-        {\n-            const CPubKey &vchPubKey = (*mi).second.first;\n-            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+        for (; mi != mapCryptedKeys.end(); ++mi) {\n+            const CPubKey& vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char>& vchCryptedSecret = (*mi).second.second;\n             CKeyingMaterial vchSecret;\n-            if(!DecryptSecret(vMasterKeyIn, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n-            {\n+            if (!DecryptSecret(vMasterKeyIn, vchCryptedSecret, vchPubKey.GetHash(), vchSecret)) {\n                 keyFail = true;\n                 break;\n             }\n-            if (vchSecret.size() != 32)\n-            {\n+            if (vchSecret.size() != 32) {\n                 keyFail = true;\n                 break;\n             }\n             CKey key;\n             key.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n-            if (key.GetPubKey() != vchPubKey)\n-            {\n+            if (key.GetPubKey() != vchPubKey) {\n                 keyFail = true;\n                 break;\n             }\n             keyPass = true;\n             if (fDecryptionThoroughlyChecked)\n                 break;\n         }\n-        if (keyPass && keyFail)\n-        {\n+        if (keyPass && keyFail) {\n             LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\");\n             assert(false);\n         }\n@@ -197,7 +198,7 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n     return true;\n }\n \n-bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n+bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey& pubkey)\n {\n     {\n         LOCK(cs_KeyStore);\n@@ -219,7 +220,7 @@ bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n }\n \n \n-bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+bool CCryptoKeyStore::AddCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret)\n {\n     {\n         LOCK(cs_KeyStore);\n@@ -231,18 +232,17 @@ bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<\n     return true;\n }\n \n-bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n+bool CCryptoKeyStore::GetKey(const CKeyID& address, CKey& keyOut) const\n {\n     {\n         LOCK(cs_KeyStore);\n         if (!IsCrypted())\n             return CBasicKeyStore::GetKey(address, keyOut);\n \n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n-        if (mi != mapCryptedKeys.end())\n-        {\n-            const CPubKey &vchPubKey = (*mi).second.first;\n-            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+        if (mi != mapCryptedKeys.end()) {\n+            const CPubKey& vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char>& vchCryptedSecret = (*mi).second.second;\n             CKeyingMaterial vchSecret;\n             if (!DecryptSecret(vMasterKey, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n                 return false;\n@@ -255,16 +255,15 @@ bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n     return false;\n }\n \n-bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+bool CCryptoKeyStore::GetPubKey(const CKeyID& address, CPubKey& vchPubKeyOut) const\n {\n     {\n         LOCK(cs_KeyStore);\n         if (!IsCrypted())\n             return CKeyStore::GetPubKey(address, vchPubKeyOut);\n \n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n-        if (mi != mapCryptedKeys.end())\n-        {\n+        if (mi != mapCryptedKeys.end()) {\n             vchPubKeyOut = (*mi).second.first;\n             return true;\n         }\n@@ -280,9 +279,8 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n             return false;\n \n         fUseCrypto = true;\n-        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n-        {\n-            const CKey &key = mKey.second;\n+        BOOST_FOREACH (KeyMap::value_type& mKey, mapKeys) {\n+            const CKey& key = mKey.second;\n             CPubKey vchPubKey = key.GetPubKey();\n             CKeyingMaterial vchSecret(key.begin(), key.end());\n             std::vector<unsigned char> vchCryptedSecret;"
      },
      {
        "sha": "55a804d25bb57bdb30c34f0cc3de675af76b00eb",
        "filename": "src/eccryptoverify.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 17,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/eccryptoverify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/eccryptoverify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eccryptoverify.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -5,9 +5,10 @@\n \n #include \"eccryptoverify.h\"\n \n-namespace {\n-\n-int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char *c2, size_t c2len) {\n+namespace\n+{\n+int CompareBigEndian(const unsigned char* c1, size_t c1len, const unsigned char* c2, size_t c2len)\n+{\n     while (c1len > c2len) {\n         if (*c1)\n             return 1;\n@@ -34,32 +35,88 @@ int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char\n \n /** Order of secp256k1's generator minus 1. */\n const unsigned char vchMaxModOrder[32] = {\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n-    0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n-    0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x40\n-};\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFE,\n+    0xBA,\n+    0xAE,\n+    0xDC,\n+    0xE6,\n+    0xAF,\n+    0x48,\n+    0xA0,\n+    0x3B,\n+    0xBF,\n+    0xD2,\n+    0x5E,\n+    0x8C,\n+    0xD0,\n+    0x36,\n+    0x41,\n+    0x40};\n \n /** Half of the order of secp256k1's generator minus 1. */\n const unsigned char vchMaxModHalfOrder[32] = {\n-    0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0x5D,0x57,0x6E,0x73,0x57,0xA4,0x50,0x1D,\n-    0xDF,0xE9,0x2F,0x46,0x68,0x1B,0x20,0xA0\n-};\n+    0x7F,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0xFF,\n+    0x5D,\n+    0x57,\n+    0x6E,\n+    0x73,\n+    0x57,\n+    0xA4,\n+    0x50,\n+    0x1D,\n+    0xDF,\n+    0xE9,\n+    0x2F,\n+    0x46,\n+    0x68,\n+    0x1B,\n+    0x20,\n+    0xA0};\n \n const unsigned char vchZero[1] = {0};\n } // anon namespace\n \n-namespace eccrypto {\n-\n-bool Check(const unsigned char *vch) {\n+namespace eccrypto\n+{\n+bool Check(const unsigned char* vch)\n+{\n     return vch &&\n            CompareBigEndian(vch, 32, vchZero, 0) > 0 &&\n            CompareBigEndian(vch, 32, vchMaxModOrder, 32) <= 0;\n }\n \n-bool CheckSignatureElement(const unsigned char *vch, int len, bool half) {\n+bool CheckSignatureElement(const unsigned char* vch, int len, bool half)\n+{\n     return vch &&\n            CompareBigEndian(vch, len, vchZero, 0) > 0 &&\n            CompareBigEndian(vch, len, half ? vchMaxModHalfOrder : vchMaxModOrder, 32) <= 0;"
      },
      {
        "sha": "3e8d64eb92fc020c1dbeec67ff9c887218f5011f",
        "filename": "src/ecwrapper.cpp",
        "status": "modified",
        "additions": 138,
        "deletions": 65,
        "changes": 203,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -11,70 +11,134 @@\n #include <openssl/ecdsa.h>\n #include <openssl/obj_mac.h>\n \n-namespace {\n-\n+namespace\n+{\n /**\n  * Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n  * recid selects which key is recovered\n  * if check is non-zero, additional checks are performed\n  */\n-int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n+int ECDSA_SIG_recover_key_GFp(EC_KEY* eckey, ECDSA_SIG* ecsig, const unsigned char* msg, int msglen, int recid, int check)\n {\n-    if (!eckey) return 0;\n+    if (!eckey)\n+        return 0;\n \n     int ret = 0;\n-    BN_CTX *ctx = NULL;\n-\n-    BIGNUM *x = NULL;\n-    BIGNUM *e = NULL;\n-    BIGNUM *order = NULL;\n-    BIGNUM *sor = NULL;\n-    BIGNUM *eor = NULL;\n-    BIGNUM *field = NULL;\n-    EC_POINT *R = NULL;\n-    EC_POINT *O = NULL;\n-    EC_POINT *Q = NULL;\n-    BIGNUM *rr = NULL;\n-    BIGNUM *zero = NULL;\n+    BN_CTX* ctx = NULL;\n+\n+    BIGNUM* x = NULL;\n+    BIGNUM* e = NULL;\n+    BIGNUM* order = NULL;\n+    BIGNUM* sor = NULL;\n+    BIGNUM* eor = NULL;\n+    BIGNUM* field = NULL;\n+    EC_POINT* R = NULL;\n+    EC_POINT* O = NULL;\n+    EC_POINT* Q = NULL;\n+    BIGNUM* rr = NULL;\n+    BIGNUM* zero = NULL;\n     int n = 0;\n     int i = recid / 2;\n \n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n+    const EC_GROUP* group = EC_KEY_get0_group(eckey);\n+    if ((ctx = BN_CTX_new()) == NULL) {\n+        ret = -1;\n+        goto err;\n+    }\n     BN_CTX_start(ctx);\n     order = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n+    if (!EC_GROUP_get_order(group, order, ctx)) {\n+        ret = -2;\n+        goto err;\n+    }\n     x = BN_CTX_get(ctx);\n-    if (!BN_copy(x, order)) { ret=-1; goto err; }\n-    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n-    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n+    if (!BN_copy(x, order)) {\n+        ret = -1;\n+        goto err;\n+    }\n+    if (!BN_mul_word(x, i)) {\n+        ret = -1;\n+        goto err;\n+    }\n+    if (!BN_add(x, x, ecsig->r)) {\n+        ret = -1;\n+        goto err;\n+    }\n     field = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n-    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n-    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n-    if (check)\n-    {\n-        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n-        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n-    }\n-    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n+    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) {\n+        ret = -2;\n+        goto err;\n+    }\n+    if (BN_cmp(x, field) >= 0) {\n+        ret = 0;\n+        goto err;\n+    }\n+    if ((R = EC_POINT_new(group)) == NULL) {\n+        ret = -2;\n+        goto err;\n+    }\n+    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) {\n+        ret = 0;\n+        goto err;\n+    }\n+    if (check) {\n+        if ((O = EC_POINT_new(group)) == NULL) {\n+            ret = -2;\n+            goto err;\n+        }\n+        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) {\n+            ret = -2;\n+            goto err;\n+        }\n+        if (!EC_POINT_is_at_infinity(group, O)) {\n+            ret = 0;\n+            goto err;\n+        }\n+    }\n+    if ((Q = EC_POINT_new(group)) == NULL) {\n+        ret = -2;\n+        goto err;\n+    }\n     n = EC_GROUP_get_degree(group);\n     e = BN_CTX_get(ctx);\n-    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n-    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n+    if (!BN_bin2bn(msg, msglen, e)) {\n+        ret = -1;\n+        goto err;\n+    }\n+    if (8 * msglen > n)\n+        BN_rshift(e, e, 8 - (n & 7));\n     zero = BN_CTX_get(ctx);\n-    if (!BN_zero(zero)) { ret=-1; goto err; }\n-    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n+    if (!BN_zero(zero)) {\n+        ret = -1;\n+        goto err;\n+    }\n+    if (!BN_mod_sub(e, zero, e, order, ctx)) {\n+        ret = -1;\n+        goto err;\n+    }\n     rr = BN_CTX_get(ctx);\n-    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n+    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) {\n+        ret = -1;\n+        goto err;\n+    }\n     sor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n+    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) {\n+        ret = -1;\n+        goto err;\n+    }\n     eor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n-    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n-    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n+    if (!BN_mod_mul(eor, e, rr, order, ctx)) {\n+        ret = -1;\n+        goto err;\n+    }\n+    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) {\n+        ret = -2;\n+        goto err;\n+    }\n+    if (!EC_KEY_set_public_key(eckey, Q)) {\n+        ret = -2;\n+        goto err;\n+    }\n \n     ret = 1;\n \n@@ -83,71 +147,80 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch\n         BN_CTX_end(ctx);\n         BN_CTX_free(ctx);\n     }\n-    if (R != NULL) EC_POINT_free(R);\n-    if (O != NULL) EC_POINT_free(O);\n-    if (Q != NULL) EC_POINT_free(Q);\n+    if (R != NULL)\n+        EC_POINT_free(R);\n+    if (O != NULL)\n+        EC_POINT_free(O);\n+    if (Q != NULL)\n+        EC_POINT_free(Q);\n     return ret;\n }\n \n } // anon namespace\n \n-CECKey::CECKey() {\n+CECKey::CECKey()\n+{\n     pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n     assert(pkey != NULL);\n }\n \n-CECKey::~CECKey() {\n+CECKey::~CECKey()\n+{\n     EC_KEY_free(pkey);\n }\n \n-void CECKey::GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n+void CECKey::GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed)\n+{\n     EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n     int nSize = i2o_ECPublicKey(pkey, NULL);\n     assert(nSize);\n     assert(nSize <= 65);\n     pubkey.clear();\n     pubkey.resize(nSize);\n-    unsigned char *pbegin(begin_ptr(pubkey));\n+    unsigned char* pbegin(begin_ptr(pubkey));\n     int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n     assert(nSize == nSize2);\n }\n \n-bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n+bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size)\n+{\n     return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n }\n \n-bool CECKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+bool CECKey::Verify(const uint256& hash, const std::vector<unsigned char>& vchSig)\n+{\n     // -1 = error, 0 = bad sig, 1 = good\n     if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n         return false;\n     return true;\n }\n \n-bool CECKey::Recover(const uint256 &hash, const unsigned char *p64, int rec)\n+bool CECKey::Recover(const uint256& hash, const unsigned char* p64, int rec)\n {\n-    if (rec<0 || rec>=3)\n+    if (rec < 0 || rec >= 3)\n         return false;\n-    ECDSA_SIG *sig = ECDSA_SIG_new();\n-    BN_bin2bn(&p64[0],  32, sig->r);\n+    ECDSA_SIG* sig = ECDSA_SIG_new();\n+    BN_bin2bn(&p64[0], 32, sig->r);\n     BN_bin2bn(&p64[32], 32, sig->s);\n     bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n     ECDSA_SIG_free(sig);\n     return ret;\n }\n \n-bool CECKey::TweakPublic(const unsigned char vchTweak[32]) {\n+bool CECKey::TweakPublic(const unsigned char vchTweak[32])\n+{\n     bool ret = true;\n-    BN_CTX *ctx = BN_CTX_new();\n+    BN_CTX* ctx = BN_CTX_new();\n     BN_CTX_start(ctx);\n-    BIGNUM *bnTweak = BN_CTX_get(ctx);\n-    BIGNUM *bnOrder = BN_CTX_get(ctx);\n-    BIGNUM *bnOne = BN_CTX_get(ctx);\n-    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n+    BIGNUM* bnTweak = BN_CTX_get(ctx);\n+    BIGNUM* bnOrder = BN_CTX_get(ctx);\n+    BIGNUM* bnOne = BN_CTX_get(ctx);\n+    const EC_GROUP* group = EC_KEY_get0_group(pkey);\n     EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n     BN_bin2bn(vchTweak, 32, bnTweak);\n     if (BN_cmp(bnTweak, bnOrder) >= 0)\n         ret = false; // extremely unlikely\n-    EC_POINT *point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n+    EC_POINT* point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n     BN_one(bnOne);\n     EC_POINT_mul(group, point, bnTweak, point, bnOne, ctx);\n     if (EC_POINT_is_at_infinity(group, point))\n@@ -161,8 +234,8 @@ bool CECKey::TweakPublic(const unsigned char vchTweak[32]) {\n \n bool CECKey::SanityCheck()\n {\n-    EC_KEY *pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if(pkey == NULL)\n+    EC_KEY* pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    if (pkey == NULL)\n         return false;\n     EC_KEY_free(pkey);\n "
      },
      {
        "sha": "9b49b43edc3cc857c5fb24326fe926be260a5d5d",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,8 +13,7 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n {\n     // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n     uint32_t h1 = nHashSeed;\n-    if (vDataToHash.size() > 0)\n-    {\n+    if (vDataToHash.size() > 0) {\n         const uint32_t c1 = 0xcc9e2d51;\n         const uint32_t c2 = 0x1b873593;\n \n@@ -73,10 +72,7 @@ void BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, unsigned\n     unsigned char num[4];\n     num[0] = (nChild >> 24) & 0xFF;\n     num[1] = (nChild >> 16) & 0xFF;\n-    num[2] = (nChild >>  8) & 0xFF;\n-    num[3] = (nChild >>  0) & 0xFF;\n-    CHMAC_SHA512(chainCode, 32).Write(&header, 1)\n-                               .Write(data, 32)\n-                               .Write(num, 4)\n-                               .Finalize(output);\n+    num[2] = (nChild >> 8) & 0xFF;\n+    num[3] = (nChild >> 0) & 0xFF;\n+    CHMAC_SHA512(chainCode, 32).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }"
      },
      {
        "sha": "c3c5b11feed49dd0af88d90f4414868a3a79ed4d",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 102,
        "deletions": 127,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -62,13 +62,13 @@ bool fFeeEstimatesInitialized = false;\n \n // Used to pass flags to the Bind() function\n enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n+    BF_NONE = 0,\n+    BF_EXPLICIT = (1U << 0),\n     BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n+    BF_WHITELIST = (1U << 2),\n };\n \n-static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n+static const char* FEE_ESTIMATES_FILENAME = \"fee_estimates.dat\";\n CClientUIInterface uiInterface;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -112,7 +112,7 @@ bool ShutdownRequested()\n     return fRequestShutdown;\n }\n \n-static CCoinsViewDB *pcoinsdbview = NULL;\n+static CCoinsViewDB* pcoinsdbview = NULL;\n \n void Shutdown()\n {\n@@ -137,8 +137,7 @@ void Shutdown()\n     StopNode();\n     UnregisterNodeSignals(GetNodeSignals());\n \n-    if (fFeeEstimatesInitialized)\n-    {\n+    if (fFeeEstimatesInitialized) {\n         boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n         CAutoFile est_fileout(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n         if (!est_fileout.IsNull())\n@@ -188,19 +187,20 @@ void HandleSIGHUP(int)\n     fReopenDebugLog = true;\n }\n \n-bool static InitError(const std::string &str)\n+bool static InitError(const std::string& str)\n {\n     uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR);\n     return false;\n }\n \n-bool static InitWarning(const std::string &str)\n+bool static InitWarning(const std::string& str)\n {\n     uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING);\n     return true;\n }\n \n-bool static Bind(const CService &addr, unsigned int flags) {\n+bool static Bind(const CService& addr, unsigned int flags)\n+{\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n         return false;\n     std::string strError;\n@@ -222,8 +222,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += \"  -checkblocks=<n>       \" + strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), 288) + \"\\n\";\n     strUsage += \"  -checklevel=<n>        \" + strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), 3) + \"\\n\";\n     strUsage += \"  -conf=<file>           \" + strprintf(_(\"Specify configuration file (default: %s)\"), \"bitcoin.conf\") + \"\\n\";\n-    if (mode == HMM_BITCOIND)\n-    {\n+    if (mode == HMM_BITCOIND) {\n #if !defined(WIN32)\n         strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n #endif\n@@ -296,8 +295,7 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n \n     strUsage += \"\\n\" + _(\"Debugging/Testing options:\") + \"\\n\";\n-    if (GetBoolArg(\"-help-debug\", false))\n-    {\n+    if (GetBoolArg(\"-help-debug\", false)) {\n         strUsage += \"  -checkpoints           \" + strprintf(_(\"Only accept block chain matching built-in checkpoints (default: %u)\"), 1) + \"\\n\";\n         strUsage += \"  -dblogsize=<n>         \" + strprintf(_(\"Flush database activity from memory pool to disk log every <n> megabytes (default: %u)\"), 100) + \"\\n\";\n         strUsage += \"  -disablesafemode       \" + strprintf(_(\"Disable safemode, override a real safe mode event (default: %u)\"), 0) + \"\\n\";\n@@ -310,7 +308,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += \"  -debug=<category>      \" + strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \"\\n\";\n     strUsage += \"                         \" + _(\"If <category> is not supplied, output all debugging information.\") + \"\\n\";\n     strUsage += \"                         \" + _(\"<category> can be:\");\n-    strUsage +=                                 \" addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n+    strUsage += \" addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         strUsage += \", qt\";\n     strUsage += \".\\n\";\n@@ -321,15 +319,13 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += \"  -help-debug            \" + _(\"Show all debugging options (usage: --help -help-debug)\") + \"\\n\";\n     strUsage += \"  -logips                \" + strprintf(_(\"Include IP addresses in debug output (default: %u)\"), 0) + \"\\n\";\n     strUsage += \"  -logtimestamps         \" + strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), 1) + \"\\n\";\n-    if (GetBoolArg(\"-help-debug\", false))\n-    {\n+    if (GetBoolArg(\"-help-debug\", false)) {\n         strUsage += \"  -limitfreerelay=<n>    \" + strprintf(_(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:%u)\"), 15) + \"\\n\";\n         strUsage += \"  -maxsigcachesize=<n>   \" + strprintf(_(\"Limit size of signature cache to <n> entries (default: %u)\"), 50000) + \"\\n\";\n     }\n     strUsage += \"  -minrelaytxfee=<amt>   \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"), FormatMoney(::minRelayTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n-    if (GetBoolArg(\"-help-debug\", false))\n-    {\n+    if (GetBoolArg(\"-help-debug\", false)) {\n         strUsage += \"  -printpriority         \" + strprintf(_(\"Log transaction priority and fee per kB when mining blocks (default: %u)\"), 0) + \"\\n\";\n         strUsage += \"  -privdb                \" + strprintf(_(\"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\"), 1) + \"\\n\";\n         strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n@@ -389,12 +385,14 @@ static void BlockNotifyCallback(const uint256& hashNewTip)\n \n struct CImportingNow\n {\n-    CImportingNow() {\n+    CImportingNow()\n+    {\n         assert(fImporting == false);\n         fImporting = true;\n     }\n \n-    ~CImportingNow() {\n+    ~CImportingNow()\n+    {\n         assert(fImporting == true);\n         fImporting = false;\n     }\n@@ -412,7 +410,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n             CDiskBlockPos pos(nFile, 0);\n             if (!boost::filesystem::exists(GetBlockPosFilename(pos, \"blk\")))\n                 break; // No block files left to reindex\n-            FILE *file = OpenBlockFile(pos, true);\n+            FILE* file = OpenBlockFile(pos, true);\n             if (!file)\n                 break; // This error is logged in OpenBlockFile\n             LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n@@ -429,7 +427,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n     // hardcoded $DATADIR/bootstrap.dat\n     filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n     if (filesystem::exists(pathBootstrap)) {\n-        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n+        FILE* file = fopen(pathBootstrap.string().c_str(), \"rb\");\n         if (file) {\n             CImportingNow imp;\n             filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n@@ -442,8 +440,8 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n     }\n \n     // -loadblock=\n-    BOOST_FOREACH(boost::filesystem::path &path, vImportFiles) {\n-        FILE *file = fopen(path.string().c_str(), \"rb\");\n+    BOOST_FOREACH (boost::filesystem::path& path, vImportFiles) {\n+        FILE* file = fopen(path.string().c_str(), \"rb\");\n         if (file) {\n             CImportingNow imp;\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n@@ -465,7 +463,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n  */\n bool InitSanityCheck(void)\n {\n-    if(!ECC_InitSanityCheck()) {\n+    if (!ECC_InitSanityCheck()) {\n         InitError(\"OpenSSL appears to lack support for elliptic curve cryptography. For more \"\n                   \"information, visit https://en.bitcoin.it/wiki/OpenSSL_and_EC_Libraries\");\n         return false;\n@@ -481,7 +479,7 @@ bool InitSanityCheck(void)\n  */\n bool AppInit2(boost::thread_group& threadGroup)\n {\n-    // ********************************************************* Step 1: setup\n+// ********************************************************* Step 1: setup\n #ifdef _MSC_VER\n     // Turn off Microsoft heap dump noise\n     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n@@ -492,23 +490,23 @@ bool AppInit2(boost::thread_group& threadGroup)\n     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n #endif\n #ifdef WIN32\n-    // Enable Data Execution Prevention (DEP)\n-    // Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n-    // A failure is non-critical and needs no further attention!\n+// Enable Data Execution Prevention (DEP)\n+// Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n+// A failure is non-critical and needs no further attention!\n #ifndef PROCESS_DEP_ENABLE\n-    // We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n-    // which is not correct. Can be removed, when GCCs winbase.h is fixed!\n+// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n+// which is not correct. Can be removed, when GCCs winbase.h is fixed!\n #define PROCESS_DEP_ENABLE 0x00000001\n #endif\n-    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n+    typedef BOOL(WINAPI * PSETPROCDEPPOL)(DWORD);\n     PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n-    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n+    if (setProcDEPPol != NULL)\n+        setProcDEPPol(PROCESS_DEP_ENABLE);\n \n     // Initialize Windows Sockets\n     WSADATA wsadata;\n-    int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n-    if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2)\n-    {\n+    int ret = WSAStartup(MAKEWORD(2, 2), &wsadata);\n+    if (ret != NO_ERROR || LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wVersion) != 2) {\n         return InitError(strprintf(\"Error: Winsock library failed to start (WSAStartup returned error %d)\", ret));\n     }\n #endif\n@@ -538,7 +536,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     sa_hup.sa_flags = 0;\n     sigaction(SIGHUP, &sa_hup, NULL);\n \n-#if defined (__SVR4) && defined (__sun)\n+#if defined(__SVR4) && defined(__sun)\n     // ignore SIGPIPE on Solaris\n     signal(SIGPIPE, SIG_IGN);\n #endif\n@@ -657,16 +655,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // BIP16 support.\n     // This can be removed eventually...\n     const char* pszP2SH = \"/P2SH/\";\n-    COINBASE_FLAGS << std::vector<unsigned char>(pszP2SH, pszP2SH+strlen(pszP2SH));\n+    COINBASE_FLAGS << std::vector<unsigned char>(pszP2SH, pszP2SH + strlen(pszP2SH));\n \n     // Fee-per-kilobyte amount considered the same as \"free\"\n     // If you are mining, be careful setting this:\n     // if you set it to zero then\n     // a transaction spammer can cheaply fill blocks using\n     // 1-satoshi-fee transactions. It should be set above the real\n     // cost to you of processing a transaction.\n-    if (mapArgs.count(\"-minrelaytxfee\"))\n-    {\n+    if (mapArgs.count(\"-minrelaytxfee\")) {\n         CAmount n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n             ::minRelayTxFee = CFeeRate(n);\n@@ -675,26 +672,24 @@ bool AppInit2(boost::thread_group& threadGroup)\n     }\n \n #ifdef ENABLE_WALLET\n-    if (mapArgs.count(\"-mintxfee\"))\n-    {\n+    if (mapArgs.count(\"-mintxfee\")) {\n         CAmount n = 0;\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n             CWallet::minTxFee = CFeeRate(n);\n         else\n             return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n     }\n-    if (mapArgs.count(\"-paytxfee\"))\n-    {\n+    if (mapArgs.count(\"-paytxfee\")) {\n         CAmount nFeePerK = 0;\n         if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n         if (nFeePerK > nHighTransactionFeeWarning)\n             InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n         payTxFee = CFeeRate(nFeePerK, 1000);\n-        if (payTxFee < ::minRelayTxFee)\n-        {\n+        if (payTxFee < ::minRelayTxFee) {\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n-                                       mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()));\n+                                       mapArgs[\"-paytxfee\"],\n+                                       ::minRelayTxFee.ToString()));\n         }\n     }\n     nTxConfirmTarget = GetArg(\"-txconfirmtarget\", 1);\n@@ -722,7 +717,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n-    if (file) fclose(file);\n+    if (file)\n+        fclose(file);\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n     if (!lock.try_lock())\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\"), strDataDir));\n@@ -747,7 +743,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {\n-        for (int i=0; i<nScriptCheckThreads-1; i++)\n+        for (int i = 0; i < nScriptCheckThreads - 1; i++)\n             threadGroup.create_thread(&ThreadScriptCheck);\n     }\n \n@@ -756,30 +752,28 @@ bool AppInit2(boost::thread_group& threadGroup)\n      * that the server is there and will be ready later).  Warmup mode will\n      * be disabled when initialisation is finished.\n      */\n-    if (fServer)\n-    {\n+    if (fServer) {\n         uiInterface.InitMessage.connect(SetRPCWarmupStatus);\n         StartRPCThreads();\n     }\n \n     int64_t nStart;\n \n-    // ********************************************************* Step 5: verify wallet database integrity\n+// ********************************************************* Step 5: verify wallet database integrity\n #ifdef ENABLE_WALLET\n     if (!fDisableWallet) {\n         LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n-        if (!bitdb.Open(GetDataDir()))\n-        {\n+        if (!bitdb.Open(GetDataDir())) {\n             // try moving the database env out of the way\n             boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n             boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n             try {\n                 boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n                 LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n-            } catch(boost::filesystem::filesystem_error &error) {\n-                 // failure is ok (well, not really, but it's not worse than what we started with)\n+            } catch (boost::filesystem::filesystem_error& error) {\n+                // failure is ok (well, not really, but it's not worse than what we started with)\n             }\n \n             // try again\n@@ -790,36 +784,34 @@ bool AppInit2(boost::thread_group& threadGroup)\n             }\n         }\n \n-        if (GetBoolArg(\"-salvagewallet\", false))\n-        {\n+        if (GetBoolArg(\"-salvagewallet\", false)) {\n             // Recover readable keypairs:\n             if (!CWalletDB::Recover(bitdb, strWalletFile, true))\n                 return false;\n         }\n \n-        if (filesystem::exists(GetDataDir() / strWalletFile))\n-        {\n+        if (filesystem::exists(GetDataDir() / strWalletFile)) {\n             CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n-            if (r == CDBEnv::RECOVER_OK)\n-            {\n+            if (r == CDBEnv::RECOVER_OK) {\n                 string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                          \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                          \" your balance or transactions are incorrect you should\"\n-                                         \" restore from a backup.\"), strDataDir);\n+                                         \" restore from a backup.\"),\n+                                       strDataDir);\n                 InitWarning(msg);\n             }\n             if (r == CDBEnv::RECOVER_FAIL)\n                 return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n         }\n-    } // (!fDisableWallet)\n+    }  // (!fDisableWallet)\n #endif // ENABLE_WALLET\n     // ********************************************************* Step 6: network initialization\n \n     RegisterNodeSignals(GetNodeSignals());\n \n     if (mapArgs.count(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n+        BOOST_FOREACH (std::string snet, mapMultiArgs[\"-onlynet\"]) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n@@ -833,7 +825,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     }\n \n     if (mapArgs.count(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n+        BOOST_FOREACH (const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n             CSubNet subnet(net);\n             if (!subnet.IsValid())\n                 return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n@@ -876,22 +868,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n     bool fBound = false;\n     if (fListen) {\n         if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\")) {\n-            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n+            BOOST_FOREACH (std::string strBind, mapMultiArgs[\"-bind\"]) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                     return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind));\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n-            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-whitebind\"]) {\n+            BOOST_FOREACH (std::string strBind, mapMultiArgs[\"-whitebind\"]) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, 0, false))\n                     return InitError(strprintf(_(\"Cannot resolve -whitebind address: '%s'\"), strBind));\n                 if (addrBind.GetPort() == 0)\n                     return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n             }\n-        }\n-        else {\n+        } else {\n             struct in_addr inaddr_any;\n             inaddr_any.s_addr = INADDR_ANY;\n             fBound |= Bind(CService(in6addr_any, GetListenPort()), BF_NONE);\n@@ -902,15 +893,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n     }\n \n     if (mapArgs.count(\"-externalip\")) {\n-        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n+        BOOST_FOREACH (string strAddr, mapMultiArgs[\"-externalip\"]) {\n             CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n             if (!addrLocal.IsValid())\n                 return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr));\n             AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n         }\n     }\n \n-    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n+    BOOST_FOREACH (string strDest, mapMultiArgs[\"-seednode\"])\n         AddOneShot(strDest);\n \n     // ********************************************************* Step 7: load block chain\n@@ -919,27 +910,26 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // Upgrading to 0.8; hard-link the old blknnnn.dat files into /blocks/\n     filesystem::path blocksDir = GetDataDir() / \"blocks\";\n-    if (!filesystem::exists(blocksDir))\n-    {\n+    if (!filesystem::exists(blocksDir)) {\n         filesystem::create_directories(blocksDir);\n         bool linked = false;\n         for (unsigned int i = 1; i < 10000; i++) {\n             filesystem::path source = GetDataDir() / strprintf(\"blk%04u.dat\", i);\n-            if (!filesystem::exists(source)) break;\n-            filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i-1);\n+            if (!filesystem::exists(source))\n+                break;\n+            filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i - 1);\n             try {\n                 filesystem::create_hard_link(source, dest);\n                 LogPrintf(\"Hardlinked %s -> %s\\n\", source.string(), dest.string());\n                 linked = true;\n-            } catch (filesystem::filesystem_error & e) {\n+            } catch (filesystem::filesystem_error& e) {\n                 // Note: hardlink creation failing is not a disaster, it just means\n                 // blocks will get re-downloaded from peers.\n                 LogPrintf(\"Error hardlinking blk%04u.dat : %s\\n\", i, e.what());\n                 break;\n             }\n         }\n-        if (linked)\n-        {\n+        if (linked) {\n             fReindex = true;\n         }\n     }\n@@ -1003,26 +993,27 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 }\n \n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n-                if (!CVerifyDB().VerifyDB(pcoinsdbview, GetArg(\"-checklevel\", 3),\n-                              GetArg(\"-checkblocks\", 288))) {\n+                if (!CVerifyDB().VerifyDB(pcoinsdbview, GetArg(\"-checklevel\", 3), GetArg(\"-checkblocks\", 288))) {\n                     strLoadError = _(\"Corrupted block database detected\");\n                     break;\n                 }\n-            } catch(std::exception &e) {\n-                if (fDebug) LogPrintf(\"%s\\n\", e.what());\n+            } catch (std::exception& e) {\n+                if (fDebug)\n+                    LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n             }\n \n             fLoaded = true;\n-        } while(false);\n+        } while (false);\n \n         if (!fLoaded) {\n             // first suggest a reindex\n             if (!fReset) {\n                 bool fRet = uiInterface.ThreadSafeMessageBox(\n                     strLoadError + \".\\n\\n\" + _(\"Do you want to rebuild the block database now?\"),\n-                    \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n+                    \"\",\n+                    CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n                 if (fRet) {\n                     fReindex = true;\n                     fRequestShutdown = false;\n@@ -1039,8 +1030,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // As LoadBlockIndex can take several minutes, it's possible the user\n     // requested to kill the GUI during the last operation. If so, exit.\n     // As the program has not fully started yet, Shutdown() is possibly overkill.\n-    if (fRequestShutdown)\n-    {\n+    if (fRequestShutdown) {\n         LogPrintf(\"Shutdown requested. Exiting.\\n\");\n         return false;\n     }\n@@ -1053,13 +1043,12 @@ bool AppInit2(boost::thread_group& threadGroup)\n         mempool.ReadFeeEstimates(est_filein);\n     fFeeEstimatesInitialized = true;\n \n-    // ********************************************************* Step 8: load wallet\n+// ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n     if (fDisableWallet) {\n         pwalletMain = NULL;\n         LogPrintf(\"Wallet disabled!\\n\");\n     } else {\n-\n         // needed to restore wallet transaction meta data after -zapwallettxes\n         std::vector<CWalletTx> vWtx;\n \n@@ -1083,46 +1072,38 @@ bool AppInit2(boost::thread_group& threadGroup)\n         bool fFirstRun = true;\n         pwalletMain = new CWallet(strWalletFile);\n         DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n-        if (nLoadWalletRet != DB_LOAD_OK)\n-        {\n+        if (nLoadWalletRet != DB_LOAD_OK) {\n             if (nLoadWalletRet == DB_CORRUPT)\n                 strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n-            else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n-            {\n+            else if (nLoadWalletRet == DB_NONCRITICAL_ERROR) {\n                 string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                              \" or address book entries might be missing or incorrect.\"));\n                 InitWarning(msg);\n-            }\n-            else if (nLoadWalletRet == DB_TOO_NEW)\n+            } else if (nLoadWalletRet == DB_TOO_NEW)\n                 strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\") << \"\\n\";\n-            else if (nLoadWalletRet == DB_NEED_REWRITE)\n-            {\n+            else if (nLoadWalletRet == DB_NEED_REWRITE) {\n                 strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") << \"\\n\";\n                 LogPrintf(\"%s\", strErrors.str());\n                 return InitError(strErrors.str());\n-            }\n-            else\n+            } else\n                 strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n         }\n \n-        if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n-        {\n+        if (GetBoolArg(\"-upgradewallet\", fFirstRun)) {\n             int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n             if (nMaxVersion == 0) // the -upgradewallet without argument case\n             {\n                 LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n                 nMaxVersion = CLIENT_VERSION;\n                 pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n-            }\n-            else\n+            } else\n                 LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n             if (nMaxVersion < pwalletMain->GetVersion())\n                 strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n             pwalletMain->SetMaxVersion(nMaxVersion);\n         }\n \n-        if (fFirstRun)\n-        {\n+        if (fFirstRun) {\n             // Create new keyUser and set as default key\n             RandAddSeedPerfmon();\n \n@@ -1141,20 +1122,18 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n         RegisterValidationInterface(pwalletMain);\n \n-        CBlockIndex *pindexRescan = chainActive.Tip();\n+        CBlockIndex* pindexRescan = chainActive.Tip();\n         if (GetBoolArg(\"-rescan\", false))\n             pindexRescan = chainActive.Genesis();\n-        else\n-        {\n+        else {\n             CWalletDB walletdb(strWalletFile);\n             CBlockLocator locator;\n             if (walletdb.ReadBestBlock(locator))\n                 pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n             else\n                 pindexRescan = chainActive.Genesis();\n         }\n-        if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n-        {\n+        if (chainActive.Tip() && chainActive.Tip() != pindexRescan) {\n             uiInterface.InitMessage(_(\"Rescanning...\"));\n             LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n             nStart = GetTimeMillis();\n@@ -1164,14 +1143,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n             nWalletDBUpdated++;\n \n             // Restore wallet transaction metadata after -zapwallettxes=1\n-            if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n-            {\n-                BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n-                {\n+            if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\") {\n+                BOOST_FOREACH (const CWalletTx& wtxOld, vWtx) {\n                     uint256 hash = wtxOld.GetHash();\n                     std::map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n-                    if (mi != pwalletMain->mapWallet.end())\n-                    {\n+                    if (mi != pwalletMain->mapWallet.end()) {\n                         const CWalletTx* copyFrom = &wtxOld;\n                         CWalletTx* copyTo = &mi->second;\n                         copyTo->mapValue = copyFrom->mapValue;\n@@ -1186,8 +1162,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 }\n             }\n         }\n-    } // (!fDisableWallet)\n-#else // ENABLE_WALLET\n+    }  // (!fDisableWallet)\n+#else  // ENABLE_WALLET\n     LogPrintf(\"No wallet compiled in!\\n\");\n #endif // !ENABLE_WALLET\n     // ********************************************************* Step 9: import blocks\n@@ -1201,9 +1177,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n         strErrors << \"Failed to connect best block\";\n \n     std::vector<boost::filesystem::path> vImportFiles;\n-    if (mapArgs.count(\"-loadblock\"))\n-    {\n-        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n+    if (mapArgs.count(\"-loadblock\")) {\n+        BOOST_FOREACH (string strFile, mapMultiArgs[\"-loadblock\"])\n             vImportFiles.push_back(strFile);\n     }\n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n@@ -1219,12 +1194,12 @@ bool AppInit2(boost::thread_group& threadGroup)\n     RandAddSeedPerfmon();\n \n     //// debug print\n-    LogPrintf(\"mapBlockIndex.size() = %u\\n\",   mapBlockIndex.size());\n-    LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n+    LogPrintf(\"mapBlockIndex.size() = %u\\n\", mapBlockIndex.size());\n+    LogPrintf(\"nBestHeight = %d\\n\", chainActive.Height());\n #ifdef ENABLE_WALLET\n-    LogPrintf(\"setKeyPool.size() = %u\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n-    LogPrintf(\"mapWallet.size() = %u\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n-    LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n+    LogPrintf(\"setKeyPool.size() = %u\\n\", pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n+    LogPrintf(\"mapWallet.size() = %u\\n\", pwalletMain ? pwalletMain->mapWallet.size() : 0);\n+    LogPrintf(\"mapAddressBook.size() = %u\\n\", pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n #endif\n \n     StartNode(threadGroup);"
      },
      {
        "sha": "8d5ff304f7d18b8ffdafefc603cb649e8db42443",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 34,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,42 +13,49 @@\n #include \"ecwrapper.h\"\n \n //! anonymous namespace\n-namespace {\n-\n-class CSecp256k1Init {\n+namespace\n+{\n+class CSecp256k1Init\n+{\n public:\n-    CSecp256k1Init() {\n+    CSecp256k1Init()\n+    {\n         secp256k1_start(SECP256K1_START_SIGN);\n     }\n-    ~CSecp256k1Init() {\n+    ~CSecp256k1Init()\n+    {\n         secp256k1_stop();\n     }\n };\n static CSecp256k1Init instance_of_csecp256k1;\n \n } // anon namespace\n \n-bool CKey::Check(const unsigned char *vch) {\n+bool CKey::Check(const unsigned char* vch)\n+{\n     return eccrypto::Check(vch);\n }\n \n-void CKey::MakeNewKey(bool fCompressedIn) {\n+void CKey::MakeNewKey(bool fCompressedIn)\n+{\n     do {\n         GetRandBytes(vch, sizeof(vch));\n     } while (!Check(vch));\n     fValid = true;\n     fCompressed = fCompressedIn;\n }\n \n-bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n+bool CKey::SetPrivKey(const CPrivKey& privkey, bool fCompressedIn)\n+{\n     if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = fCompressedIn;\n     fValid = true;\n     return true;\n }\n \n-CPrivKey CKey::GetPrivKey() const {\n+CPrivKey CKey::GetPrivKey() const\n+{\n     assert(fValid);\n     CPrivKey privkey;\n     int privkeylen, ret;\n@@ -60,7 +67,8 @@ CPrivKey CKey::GetPrivKey() const {\n     return privkey;\n }\n \n-CPubKey CKey::GetPubKey() const {\n+CPubKey CKey::GetPubKey() const\n+{\n     assert(fValid);\n     CPubKey result;\n     int clen = 65;\n@@ -71,7 +79,8 @@ CPubKey CKey::GetPubKey() const {\n     return result;\n }\n \n-bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+bool CKey::Sign(const uint256& hash, std::vector<unsigned char>& vchSig) const\n+{\n     if (!fValid)\n         return false;\n     vchSig.resize(72);\n@@ -81,12 +90,13 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n         nonce.MakeNewKey(true);\n         if (secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(), nonce.begin()))\n             break;\n-    } while(true);\n+    } while (true);\n     vchSig.resize(nSigLen);\n     return true;\n }\n \n-bool CKey::VerifyPubKey(const CPubKey& pubkey) const {\n+bool CKey::VerifyPubKey(const CPubKey& pubkey) const\n+{\n     if (pubkey.IsCompressed() != fCompressed) {\n         return false;\n     }\n@@ -100,7 +110,8 @@ bool CKey::VerifyPubKey(const CPubKey& pubkey) const {\n     return pubkey.Verify(hash, vchSig);\n }\n \n-bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+bool CKey::SignCompact(const uint256& hash, std::vector<unsigned char>& vchSig) const\n+{\n     if (!fValid)\n         return false;\n     vchSig.resize(65);\n@@ -110,13 +121,14 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n         nonce.MakeNewKey(true);\n         if (secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), nonce.begin(), &rec))\n             break;\n-    } while(true);\n+    } while (true);\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n-bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n+bool CKey::Load(CPrivKey& privkey, CPubKey& vchPubKey, bool fSkipCheck = false)\n+{\n     if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n@@ -128,20 +140,21 @@ bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n     return VerifyPubKey(vchPubKey);\n }\n \n-bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const\n+{\n     assert(IsValid());\n     assert(IsCompressed());\n     unsigned char out[64];\n     LockObject(out);\n     if ((nChild >> 31) == 0) {\n         CPubKey pubkey = GetPubKey();\n         assert(pubkey.begin() + 33 == pubkey.end());\n-        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out);\n+        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin() + 1, out);\n     } else {\n         assert(begin() + 32 == end());\n         BIP32Hash(cc, nChild, 0, begin(), out);\n     }\n-    memcpy(ccChild, out+32, 32);\n+    memcpy(ccChild, out + 32, 32);\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n     bool ret = secp256k1_ec_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n     UnlockObject(out);\n@@ -150,16 +163,18 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n     return ret;\n }\n \n-bool CExtKey::Derive(CExtKey &out, unsigned int nChild) const {\n+bool CExtKey::Derive(CExtKey& out, unsigned int nChild) const\n+{\n     out.nDepth = nDepth + 1;\n     CKeyID id = key.GetPubKey().GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);\n     out.nChild = nChild;\n     return key.Derive(out.key, out.vchChainCode, nChild, vchChainCode);\n }\n \n-void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n-    static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n+void CExtKey::SetMaster(const unsigned char* seed, unsigned int nSeedLen)\n+{\n+    static const unsigned char hashkey[] = {'B', 'i', 't', 'c', 'o', 'i', 'n', ' ', 's', 'e', 'e', 'd'};\n     unsigned char out[64];\n     LockObject(out);\n     CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out);\n@@ -171,7 +186,8 @@ void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     memset(vchFingerprint, 0, sizeof(vchFingerprint));\n }\n \n-CExtPubKey CExtKey::Neuter() const {\n+CExtPubKey CExtKey::Neuter() const\n+{\n     CExtPubKey ret;\n     ret.nDepth = nDepth;\n     memcpy(&ret.vchFingerprint[0], &vchFingerprint[0], 4);\n@@ -181,26 +197,31 @@ CExtPubKey CExtKey::Neuter() const {\n     return ret;\n }\n \n-void CExtKey::Encode(unsigned char code[74]) const {\n+void CExtKey::Encode(unsigned char code[74]) const\n+{\n     code[0] = nDepth;\n-    memcpy(code+1, vchFingerprint, 4);\n-    code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n-    code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code + 1, vchFingerprint, 4);\n+    code[5] = (nChild >> 24) & 0xFF;\n+    code[6] = (nChild >> 16) & 0xFF;\n+    code[7] = (nChild >> 8) & 0xFF;\n+    code[8] = (nChild >> 0) & 0xFF;\n+    memcpy(code + 9, vchChainCode, 32);\n     code[41] = 0;\n     assert(key.size() == 32);\n-    memcpy(code+42, key.begin(), 32);\n+    memcpy(code + 42, key.begin(), 32);\n }\n \n-void CExtKey::Decode(const unsigned char code[74]) {\n+void CExtKey::Decode(const unsigned char code[74])\n+{\n     nDepth = code[0];\n-    memcpy(vchFingerprint, code+1, 4);\n+    memcpy(vchFingerprint, code + 1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n-    key.Set(code+42, code+74, true);\n+    memcpy(vchChainCode, code + 9, 32);\n+    key.Set(code + 42, code + 74, true);\n }\n \n-bool ECC_InitSanityCheck() {\n+bool ECC_InitSanityCheck()\n+{\n #if !defined(USE_SECP256K1)\n     if (!CECKey::SanityCheck()) {\n         return false;"
      },
      {
        "sha": "7257ed2543184096fdf90784325a3325cfcd4b51",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,7 +13,7 @@\n \n #include <boost/foreach.hpp>\n \n-bool CKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) const\n+bool CKeyStore::GetPubKey(const CKeyID& address, CPubKey& vchPubKeyOut) const\n {\n     CKey key;\n     if (!GetKey(address, key))\n@@ -22,11 +22,12 @@ bool CKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) const\n     return true;\n }\n \n-bool CKeyStore::AddKey(const CKey &key) {\n+bool CKeyStore::AddKey(const CKey& key)\n+{\n     return AddKeyPubKey(key, key.GetPubKey());\n }\n \n-bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n+bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey& pubkey)\n {\n     LOCK(cs_KeyStore);\n     mapKeys[pubkey.GetID()] = key;\n@@ -49,33 +50,32 @@ bool CBasicKeyStore::HaveCScript(const CScriptID& hash) const\n     return mapScripts.count(hash) > 0;\n }\n \n-bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n+bool CBasicKeyStore::GetCScript(const CScriptID& hash, CScript& redeemScriptOut) const\n {\n     LOCK(cs_KeyStore);\n     ScriptMap::const_iterator mi = mapScripts.find(hash);\n-    if (mi != mapScripts.end())\n-    {\n+    if (mi != mapScripts.end()) {\n         redeemScriptOut = (*mi).second;\n         return true;\n     }\n     return false;\n }\n \n-bool CBasicKeyStore::AddWatchOnly(const CScript &dest)\n+bool CBasicKeyStore::AddWatchOnly(const CScript& dest)\n {\n     LOCK(cs_KeyStore);\n     setWatchOnly.insert(dest);\n     return true;\n }\n \n-bool CBasicKeyStore::RemoveWatchOnly(const CScript &dest)\n+bool CBasicKeyStore::RemoveWatchOnly(const CScript& dest)\n {\n     LOCK(cs_KeyStore);\n     setWatchOnly.erase(dest);\n     return true;\n }\n \n-bool CBasicKeyStore::HaveWatchOnly(const CScript &dest) const\n+bool CBasicKeyStore::HaveWatchOnly(const CScript& dest) const\n {\n     LOCK(cs_KeyStore);\n     return setWatchOnly.count(dest) > 0;"
      },
      {
        "sha": "cee09d38f13983ffeb4d30fa8e1ded815c915b44",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 695,
        "deletions": 864,
        "changes": 1559,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48"
      },
      {
        "sha": "769d51bda6918a4ed791b5a6460d3c924947ed5b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 79,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -60,18 +60,15 @@ class TxPriorityCompare\n     bool byFee;\n \n public:\n-    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+    TxPriorityCompare(bool _byFee) : byFee(_byFee) {}\n \n     bool operator()(const TxPriority& a, const TxPriority& b)\n     {\n-        if (byFee)\n-        {\n+        if (byFee) {\n             if (a.get<1>() == b.get<1>())\n                 return a.get<0>() < b.get<0>();\n             return a.get<1>() < b.get<1>();\n-        }\n-        else\n-        {\n+        } else {\n             if (a.get<0>() == b.get<0>())\n                 return a.get<1>() < b.get<1>();\n             return a.get<0>() < b.get<0>();\n@@ -81,7 +78,7 @@ class TxPriorityCompare\n \n void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n {\n-    pblock->nTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n+    pblock->nTime = std::max(pindexPrev->GetMedianTimePast() + 1, GetAdjustedTime());\n \n     // Updating time can change work required on testnet:\n     if (Params().AllowMinDifficultyBlocks())\n@@ -92,9 +89,9 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n {\n     // Create new block\n     auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n-    if(!pblocktemplate.get())\n+    if (!pblocktemplate.get())\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n \n     // -regtest only: allow overriding block.nVersion with\n     // -blockversion=N to test forking scenarios\n@@ -110,13 +107,13 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n-    pblocktemplate->vTxFees.push_back(-1); // updated at end\n+    pblocktemplate->vTxFees.push_back(-1);   // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n     // Largest block you're willing to create:\n     unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n     // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE - 1000), nBlockMaxSize));\n \n     // How much of the block should be dedicated to high-priority transactions,\n     // included regardless of the fees they pay\n@@ -146,8 +143,8 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n         for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n-             mi != mempool.mapTx.end(); ++mi)\n-        {\n+             mi != mempool.mapTx.end();\n+             ++mi) {\n             const CTransaction& tx = mi->second.GetTx();\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight))\n                 continue;\n@@ -156,27 +153,24 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             double dPriority = 0;\n             CAmount nTotalIn = 0;\n             bool fMissingInputs = false;\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-            {\n+            BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n                 // Read prev transaction\n-                if (!view.HaveCoins(txin.prevout.hash))\n-                {\n+                if (!view.HaveCoins(txin.prevout.hash)) {\n                     // This should never happen; all transactions in the memory\n                     // pool should connect to either transactions in the chain\n                     // or other transactions in the memory pool.\n-                    if (!mempool.mapTx.count(txin.prevout.hash))\n-                    {\n+                    if (!mempool.mapTx.count(txin.prevout.hash)) {\n                         LogPrintf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n+                        if (fDebug)\n+                            assert(\"mempool transaction missing input\" == 0);\n                         fMissingInputs = true;\n                         if (porphan)\n                             vOrphan.pop_back();\n                         break;\n                     }\n \n                     // Has to wait for dependencies\n-                    if (!porphan)\n-                    {\n+                    if (!porphan) {\n                         // Use list for automatic deletion\n                         vOrphan.push_back(COrphan(&tx));\n                         porphan = &vOrphan.back();\n@@ -196,7 +190,8 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n                 dPriority += (double)nValueIn * nConf;\n             }\n-            if (fMissingInputs) continue;\n+            if (fMissingInputs)\n+                continue;\n \n             // Priority is sum(valuein * age) / modified_txsize\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n@@ -205,14 +200,12 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             uint256 hash = tx.GetHash();\n             mempool.ApplyDeltas(hash, dPriority, nTotalIn);\n \n-            CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n+            CFeeRate feeRate(nTotalIn - tx.GetValueOut(), nTxSize);\n \n-            if (porphan)\n-            {\n+            if (porphan) {\n                 porphan->dPriority = dPriority;\n                 porphan->feeRate = feeRate;\n-            }\n-            else\n+            } else\n                 vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n         }\n \n@@ -225,8 +218,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         TxPriorityCompare comparer(fSortedByFee);\n         std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n \n-        while (!vecPriority.empty())\n-        {\n+        while (!vecPriority.empty()) {\n             // Take highest priority transaction off the priority queue:\n             double dPriority = vecPriority.front().get<0>();\n             CFeeRate feeRate = vecPriority.front().get<1>();\n@@ -256,8 +248,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             // Prioritise by fee once past the priority size or we run out of high-priority\n             // transactions:\n             if (!fSortedByFee &&\n-                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority)))\n-            {\n+                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority))) {\n                 fSortedByFee = true;\n                 comparer = TxPriorityCompare(fSortedByFee);\n                 std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n@@ -266,7 +257,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (!view.HaveInputs(tx))\n                 continue;\n \n-            CAmount nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n+            CAmount nTxFees = view.GetValueIn(tx) - tx.GetValueOut();\n \n             nTxSigOps += GetP2SHSigOpCount(tx, view);\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n@@ -291,22 +282,19 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             nBlockSigOps += nTxSigOps;\n             nFees += nTxFees;\n \n-            if (fPrintPriority)\n-            {\n+            if (fPrintPriority) {\n                 LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n-                    dPriority, feeRate.ToString(), tx.GetHash().ToString());\n+                          dPriority,\n+                          feeRate.ToString(),\n+                          tx.GetHash().ToString());\n             }\n \n             // Add transactions that depend on this one to the priority queue\n-            if (mapDependers.count(hash))\n-            {\n-                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n-                {\n-                    if (!porphan->setDependsOn.empty())\n-                    {\n+            if (mapDependers.count(hash)) {\n+                BOOST_FOREACH (COrphan* porphan, mapDependers[hash]) {\n+                    if (!porphan->setDependsOn.empty()) {\n                         porphan->setDependsOn.erase(hash);\n-                        if (porphan->setDependsOn.empty())\n-                        {\n+                        if (porphan->setDependsOn.empty()) {\n                             vecPriority.push_back(TxPriority(porphan->dPriority, porphan->feeRate, porphan->ptx));\n                             std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n                         }\n@@ -326,10 +314,10 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         pblocktemplate->vTxFees[0] = -nFees;\n \n         // Fill in header\n-        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+        pblock->hashPrevBlock = pindexPrev->GetBlockHash();\n         UpdateTime(pblock, pindexPrev);\n-        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock);\n-        pblock->nNonce         = 0;\n+        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock);\n+        pblock->nNonce = 0;\n         pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n \n         CValidationState state;\n@@ -344,13 +332,12 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n {\n     // Update nExtraNonce\n     static uint256 hashPrevBlock;\n-    if (hashPrevBlock != pblock->hashPrevBlock)\n-    {\n+    if (hashPrevBlock != pblock->hashPrevBlock) {\n         nExtraNonce = 0;\n         hashPrevBlock = pblock->hashPrevBlock;\n     }\n     ++nExtraNonce;\n-    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n+    unsigned int nHeight = pindexPrev->nHeight + 1; // Height first in coinbase required for block.version=2\n     CMutableTransaction txCoinbase(pblock->vtx[0]);\n     txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n     assert(txCoinbase.vin[0].scriptSig.size() <= 100);\n@@ -373,7 +360,7 @@ int64_t nHPSTimerStart = 0;\n // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n // zero.\n //\n-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n+bool static ScanHash(const CBlockHeader* pblock, uint32_t& nNonce, uint256* phash)\n {\n     // Write the first 76 bytes of the block header to a double-SHA256 state.\n     CHash256 hasher;\n@@ -441,7 +428,7 @@ bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n     return true;\n }\n \n-void static BitcoinMiner(CWallet *pwallet)\n+void static BitcoinMiner(CWallet* pwallet)\n {\n     LogPrintf(\"BitcoinMiner started\\n\");\n     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n@@ -467,16 +454,14 @@ void static BitcoinMiner(CWallet *pwallet)\n             CBlockIndex* pindexPrev = chainActive.Tip();\n \n             auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n-            if (!pblocktemplate.get())\n-            {\n+            if (!pblocktemplate.get()) {\n                 LogPrintf(\"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n                 return;\n             }\n-            CBlock *pblock = &pblocktemplate->block;\n+            CBlock* pblock = &pblocktemplate->block;\n             IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n \n-            LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n-                ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n+            LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(), ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n \n             //\n             // Search\n@@ -492,10 +477,8 @@ void static BitcoinMiner(CWallet *pwallet)\n                 nOldNonce = nNonce;\n \n                 // Check if something found\n-                if (fFound)\n-                {\n-                    if (hash <= hashTarget)\n-                    {\n+                if (fFound) {\n+                    if (hash <= hashTarget) {\n                         // Found a solution\n                         pblock->nNonce = nNonce;\n                         assert(hash == pblock->GetHash());\n@@ -516,28 +499,23 @@ void static BitcoinMiner(CWallet *pwallet)\n \n                 // Meter hashes/sec\n                 static int64_t nHashCounter;\n-                if (nHPSTimerStart == 0)\n-                {\n+                if (nHPSTimerStart == 0) {\n                     nHPSTimerStart = GetTimeMillis();\n                     nHashCounter = 0;\n-                }\n-                else\n+                } else\n                     nHashCounter += nHashesDone;\n-                if (GetTimeMillis() - nHPSTimerStart > 4000)\n-                {\n+                if (GetTimeMillis() - nHPSTimerStart > 4000) {\n                     static CCriticalSection cs;\n                     {\n                         LOCK(cs);\n-                        if (GetTimeMillis() - nHPSTimerStart > 4000)\n-                        {\n+                        if (GetTimeMillis() - nHPSTimerStart > 4000) {\n                             dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                             nHPSTimerStart = GetTimeMillis();\n                             nHashCounter = 0;\n                             static int64_t nLogTime;\n-                            if (GetTime() - nLogTime > 30 * 60)\n-                            {\n+                            if (GetTime() - nLogTime > 30 * 60) {\n                                 nLogTime = GetTime();\n-                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec / 1000.0);\n                             }\n                         }\n                     }\n@@ -557,16 +535,13 @@ void static BitcoinMiner(CWallet *pwallet)\n \n                 // Update nTime every few seconds\n                 UpdateTime(pblock, pindexPrev);\n-                if (Params().AllowMinDifficultyBlocks())\n-                {\n+                if (Params().AllowMinDifficultyBlocks()) {\n                     // Changing pblock->nTime can change work required on testnet:\n                     hashTarget.SetCompact(pblock->nBits);\n                 }\n             }\n         }\n-    }\n-    catch (boost::thread_interrupted)\n-    {\n+    } catch (boost::thread_interrupted) {\n         LogPrintf(\"BitcoinMiner terminated\\n\");\n         throw;\n     }\n@@ -584,8 +559,7 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)\n             nThreads = boost::thread::hardware_concurrency();\n     }\n \n-    if (minerThreads != NULL)\n-    {\n+    if (minerThreads != NULL) {\n         minerThreads->interrupt_all();\n         delete minerThreads;\n         minerThreads = NULL;"
      },
      {
        "sha": "12106cd4bc8601a671d71bcee02c8322e0d7bd97",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 215,
        "deletions": 348,
        "changes": 563,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -52,15 +52,17 @@\n using namespace boost;\n using namespace std;\n \n-namespace {\n-    const int MAX_OUTBOUND_CONNECTIONS = 8;\n+namespace\n+{\n+const int MAX_OUTBOUND_CONNECTIONS = 8;\n \n-    struct ListenSocket {\n-        SOCKET socket;\n-        bool whitelisted;\n+struct ListenSocket\n+{\n+    SOCKET socket;\n+    bool whitelisted;\n \n-        ListenSocket(SOCKET socket, bool whitelisted) : socket(socket), whitelisted(whitelisted) {}\n-    };\n+    ListenSocket(SOCKET socket, bool whitelisted) : socket(socket), whitelisted(whitelisted) {}\n+};\n }\n \n //\n@@ -99,7 +101,7 @@ CCriticalSection cs_vAddedNodes;\n NodeId nLastNodeId = 0;\n CCriticalSection cs_nLastNodeId;\n \n-static CSemaphore *semOutbound = NULL;\n+static CSemaphore* semOutbound = NULL;\n \n // Signals for message handling\n static CNodeSignals g_signals;\n@@ -117,7 +119,7 @@ unsigned short GetListenPort()\n }\n \n // find 'best' local address for a particular peer\n-bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n+bool GetLocal(CService& addr, const CNetAddr* paddrPeer)\n {\n     if (!fListen)\n         return false;\n@@ -126,12 +128,10 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     int nBestReachability = -1;\n     {\n         LOCK(cs_mapLocalHost);\n-        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n-        {\n+        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++) {\n             int nScore = (*it).second.nScore;\n             int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n-            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n-            {\n+            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore)) {\n                 addr = CService((*it).first, (*it).second.nPort);\n                 nBestReachability = nReachability;\n                 nBestScore = nScore;\n@@ -145,12 +145,11 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n // Otherwise, return the unroutable 0.0.0.0 but filled in with\n // the normal parameters, since the IP may be changed to a useful\n // one by discovery.\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n+CAddress GetLocalAddress(const CNetAddr* paddrPeer)\n {\n-    CAddress ret(CService(\"0.0.0.0\",GetListenPort()),0);\n+    CAddress ret(CService(\"0.0.0.0\", GetListenPort()), 0);\n     CService addr;\n-    if (GetLocal(addr, paddrPeer))\n-    {\n+    if (GetLocal(addr, paddrPeer)) {\n         ret = CAddress(addr);\n     }\n     ret.nServices = nLocalServices;\n@@ -161,44 +160,35 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n bool RecvLine(SOCKET hSocket, string& strLine)\n {\n     strLine = \"\";\n-    while (true)\n-    {\n+    while (true) {\n         char c;\n         int nBytes = recv(hSocket, &c, 1, 0);\n-        if (nBytes > 0)\n-        {\n+        if (nBytes > 0) {\n             if (c == '\\n')\n                 continue;\n             if (c == '\\r')\n                 return true;\n             strLine += c;\n             if (strLine.size() >= 9000)\n                 return true;\n-        }\n-        else if (nBytes <= 0)\n-        {\n+        } else if (nBytes <= 0) {\n             boost::this_thread::interruption_point();\n-            if (nBytes < 0)\n-            {\n+            if (nBytes < 0) {\n                 int nErr = WSAGetLastError();\n                 if (nErr == WSAEMSGSIZE)\n                     continue;\n-                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n-                {\n+                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS) {\n                     MilliSleep(10);\n                     continue;\n                 }\n             }\n             if (!strLine.empty())\n                 return true;\n-            if (nBytes == 0)\n-            {\n+            if (nBytes == 0) {\n                 // socket closed\n                 LogPrint(\"net\", \"socket closed\\n\");\n                 return false;\n-            }\n-            else\n-            {\n+            } else {\n                 // socket error\n                 int nErr = WSAGetLastError();\n                 LogPrint(\"net\", \"recv failed: %s\\n\", NetworkErrorString(nErr));\n@@ -217,28 +207,25 @@ int GetnScore(const CService& addr)\n }\n \n // Is our peer's addrLocal potentially useful as an external IP source?\n-bool IsPeerAddrLocalGood(CNode *pnode)\n+bool IsPeerAddrLocalGood(CNode* pnode)\n {\n     return fDiscover && pnode->addr.IsRoutable() && pnode->addrLocal.IsRoutable() &&\n            !IsLimited(pnode->addrLocal.GetNetwork());\n }\n \n // pushes our own address to a peer\n-void AdvertizeLocal(CNode *pnode)\n+void AdvertizeLocal(CNode* pnode)\n {\n-    if (fListen && pnode->fSuccessfullyConnected)\n-    {\n+    if (fListen && pnode->fSuccessfullyConnected) {\n         CAddress addrLocal = GetLocalAddress(&pnode->addr);\n         // If discovery is enabled, sometimes give our peer the address it\n         // tells us that it sees us as in case it has a better idea of our\n         // address than we do.\n         if (IsPeerAddrLocalGood(pnode) && (!addrLocal.IsRoutable() ||\n-             GetRand((GetnScore(addrLocal) > LOCAL_MANUAL) ? 8:2) == 0))\n-        {\n+                                           GetRand((GetnScore(addrLocal) > LOCAL_MANUAL) ? 8 : 2) == 0)) {\n             addrLocal.SetIP(pnode->addrLocal);\n         }\n-        if (addrLocal.IsRoutable())\n-        {\n+        if (addrLocal.IsRoutable()) {\n             pnode->PushAddress(addrLocal);\n         }\n     }\n@@ -269,7 +256,7 @@ bool AddLocal(const CService& addr, int nScore)\n     {\n         LOCK(cs_mapLocalHost);\n         bool fAlready = mapLocalHost.count(addr) > 0;\n-        LocalServiceInfo &info = mapLocalHost[addr];\n+        LocalServiceInfo& info = mapLocalHost[addr];\n         if (!fAlready || nScore >= info.nScore) {\n             info.nScore = nScore + (fAlready ? 1 : 0);\n             info.nPort = addr.GetPort();\n@@ -280,7 +267,7 @@ bool AddLocal(const CService& addr, int nScore)\n     return true;\n }\n \n-bool AddLocal(const CNetAddr &addr, int nScore)\n+bool AddLocal(const CNetAddr& addr, int nScore)\n {\n     return AddLocal(CService(addr, GetListenPort()), nScore);\n }\n@@ -300,7 +287,7 @@ bool IsLimited(enum Network net)\n     return vfLimited[net];\n }\n \n-bool IsLimited(const CNetAddr &addr)\n+bool IsLimited(const CNetAddr& addr)\n {\n     return IsLimited(addr.GetNetwork());\n }\n@@ -353,7 +340,7 @@ CCriticalSection CNode::cs_totalBytesSent;\n CNode* FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n         if ((CNetAddr)pnode->addr == ip)\n             return (pnode);\n     return NULL;\n@@ -362,7 +349,7 @@ CNode* FindNode(const CNetAddr& ip)\n CNode* FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n         if (pnode->addrName == addrName)\n             return (pnode);\n     return NULL;\n@@ -371,36 +358,32 @@ CNode* FindNode(const std::string& addrName)\n CNode* FindNode(const CService& addr)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n         if ((CService)pnode->addr == addr)\n             return (pnode);\n     return NULL;\n }\n \n-CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n+CNode* ConnectNode(CAddress addrConnect, const char* pszDest)\n {\n     if (pszDest == NULL) {\n         if (IsLocal(addrConnect))\n             return NULL;\n \n         // Look for an existing connection\n         CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n+        if (pnode) {\n             pnode->AddRef();\n             return pnode;\n         }\n     }\n \n     /// debug print\n-    LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n-        pszDest ? pszDest : addrConnect.ToString(),\n-        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n+    LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\", pszDest ? pszDest : addrConnect.ToString(), pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime) / 3600.0);\n \n     // Connect\n     SOCKET hSocket;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort()) : ConnectSocket(addrConnect, hSocket))\n-    {\n+    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort()) : ConnectSocket(addrConnect, hSocket)) {\n         addrman.Attempt(addrConnect);\n \n         // Add node\n@@ -423,8 +406,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n void CNode::CloseSocketDisconnect()\n {\n     fDisconnect = true;\n-    if (hSocket != INVALID_SOCKET)\n-    {\n+    if (hSocket != INVALID_SOCKET) {\n         LogPrint(\"net\", \"disconnecting peer=%d\\n\", id);\n         CloseSocket(hSocket);\n     }\n@@ -441,21 +423,17 @@ void CNode::PushVersion()\n \n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\", 0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n     if (fLogIPs)\n         LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), id);\n     else\n         LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), id);\n-    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n+    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe, nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n }\n \n \n-\n-\n-\n std::map<CNetAddr, int64_t> CNode::setBanned;\n CCriticalSection CNode::cs_setBanned;\n \n@@ -470,8 +448,7 @@ bool CNode::IsBanned(CNetAddr ip)\n     {\n         LOCK(cs_setBanned);\n         std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n-        if (i != setBanned.end())\n-        {\n+        if (i != setBanned.end()) {\n             int64_t t = (*i).second;\n             if (GetTime() < t)\n                 fResult = true;\n@@ -480,8 +457,9 @@ bool CNode::IsBanned(CNetAddr ip)\n     return fResult;\n }\n \n-bool CNode::Ban(const CNetAddr &addr) {\n-    int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n+bool CNode::Ban(const CNetAddr& addr)\n+{\n+    int64_t banTime = GetTime() + GetArg(\"-bantime\", 60 * 60 * 24); // Default 24-hour ban\n     {\n         LOCK(cs_setBanned);\n         if (setBanned[addr] < banTime)\n@@ -494,23 +472,25 @@ bool CNode::Ban(const CNetAddr &addr) {\n std::vector<CSubNet> CNode::vWhitelistedRange;\n CCriticalSection CNode::cs_vWhitelistedRange;\n \n-bool CNode::IsWhitelistedRange(const CNetAddr &addr) {\n+bool CNode::IsWhitelistedRange(const CNetAddr& addr)\n+{\n     LOCK(cs_vWhitelistedRange);\n-    BOOST_FOREACH(const CSubNet& subnet, vWhitelistedRange) {\n+    BOOST_FOREACH (const CSubNet& subnet, vWhitelistedRange) {\n         if (subnet.Match(addr))\n             return true;\n     }\n     return false;\n }\n \n-void CNode::AddWhitelistedRange(const CSubNet &subnet) {\n+void CNode::AddWhitelistedRange(const CSubNet& subnet)\n+{\n     LOCK(cs_vWhitelistedRange);\n     vWhitelistedRange.push_back(subnet);\n }\n \n #undef X\n #define X(name) stats.name = name\n-void CNode::copyStats(CNodeStats &stats)\n+void CNode::copyStats(CNodeStats& stats)\n {\n     stats.nodeid = this->GetId();\n     X(nServices);\n@@ -547,10 +527,9 @@ void CNode::copyStats(CNodeStats &stats)\n #undef X\n \n // requires LOCK(cs_vRecvMsg)\n-bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n+bool CNode::ReceiveMsgBytes(const char* pch, unsigned int nBytes)\n {\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n         if (vRecvMsg.empty() ||\n             vRecvMsg.back().complete())\n@@ -566,7 +545,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n         pch += handled;\n         nBytes -= handled;\n@@ -578,7 +557,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n     return true;\n }\n \n-int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n+int CNetMessage::readHeader(const char* pch, unsigned int nBytes)\n {\n     // copy data to temporary parsing buffer\n     unsigned int nRemaining = 24 - nHdrPos;\n@@ -594,22 +573,21 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n     // deserialize to CMessageHeader\n     try {\n         hdrbuf >> hdr;\n-    }\n-    catch (const std::exception &) {\n+    } catch (const std::exception&) {\n         return -1;\n     }\n \n     // reject messages larger than MAX_SIZE\n     if (hdr.nMessageSize > MAX_SIZE)\n-            return -1;\n+        return -1;\n \n     // switch state to reading message data\n     in_data = true;\n \n     return nCopy;\n }\n \n-int CNetMessage::readData(const char *pch, unsigned int nBytes)\n+int CNetMessage::readData(const char* pch, unsigned int nBytes)\n {\n     unsigned int nRemaining = hdr.nMessageSize - nDataPos;\n     unsigned int nCopy = std::min(nRemaining, nBytes);\n@@ -626,20 +604,13 @@ int CNetMessage::readData(const char *pch, unsigned int nBytes)\n }\n \n \n-\n-\n-\n-\n-\n-\n-\n // requires LOCK(cs_vSend)\n-void SocketSendData(CNode *pnode)\n+void SocketSendData(CNode* pnode)\n {\n     std::deque<CSerializeData>::iterator it = pnode->vSendMsg.begin();\n \n     while (it != pnode->vSendMsg.end()) {\n-        const CSerializeData &data = *it;\n+        const CSerializeData& data = *it;\n         assert(data.size() > pnode->nSendOffset);\n         int nBytes = send(pnode->hSocket, &data[pnode->nSendOffset], data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n         if (nBytes > 0) {\n@@ -659,8 +630,7 @@ void SocketSendData(CNode *pnode)\n             if (nBytes < 0) {\n                 // error\n                 int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                {\n+                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n                     LogPrintf(\"socket send error %s\\n\", NetworkErrorString(nErr));\n                     pnode->CloseSocketDisconnect();\n                 }\n@@ -682,20 +652,17 @@ static list<CNode*> vNodesDisconnected;\n void ThreadSocketHandler()\n {\n     unsigned int nPrevNodeCount = 0;\n-    while (true)\n-    {\n+    while (true) {\n         //\n         // Disconnect nodes\n         //\n         {\n             LOCK(cs_vNodes);\n             // Disconnect unused nodes\n             vector<CNode*> vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n-            {\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy) {\n                 if (pnode->fDisconnect ||\n-                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0 && pnode->ssSend.empty()))\n-                {\n+                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0 && pnode->ssSend.empty())) {\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n@@ -715,34 +682,29 @@ void ThreadSocketHandler()\n         {\n             // Delete disconnected nodes\n             list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n-            {\n+            BOOST_FOREACH (CNode* pnode, vNodesDisconnectedCopy) {\n                 // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0)\n-                {\n+                if (pnode->GetRefCount() <= 0) {\n                     bool fDelete = false;\n                     {\n                         TRY_LOCK(pnode->cs_vSend, lockSend);\n-                        if (lockSend)\n-                        {\n+                        if (lockSend) {\n                             TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n-                            if (lockRecv)\n-                            {\n+                            if (lockRecv) {\n                                 TRY_LOCK(pnode->cs_inventory, lockInv);\n                                 if (lockInv)\n                                     fDelete = true;\n                             }\n                         }\n                     }\n-                    if (fDelete)\n-                    {\n+                    if (fDelete) {\n                         vNodesDisconnected.remove(pnode);\n                         delete pnode;\n                     }\n                 }\n             }\n         }\n-        if(vNodes.size() != nPrevNodeCount) {\n+        if (vNodes.size() != nPrevNodeCount) {\n             nPrevNodeCount = vNodes.size();\n             uiInterface.NotifyNumConnectionsChanged(nPrevNodeCount);\n         }\n@@ -751,7 +713,7 @@ void ThreadSocketHandler()\n         // Find which sockets have data to receive\n         //\n         struct timeval timeout;\n-        timeout.tv_sec  = 0;\n+        timeout.tv_sec = 0;\n         timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n \n         fd_set fdsetRecv;\n@@ -763,16 +725,15 @@ void ThreadSocketHandler()\n         SOCKET hSocketMax = 0;\n         bool have_fds = false;\n \n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket) {\n+        BOOST_FOREACH (const ListenSocket& hListenSocket, vhListenSocket) {\n             FD_SET(hListenSocket.socket, &fdsetRecv);\n             hSocketMax = max(hSocketMax, hListenSocket.socket);\n             have_fds = true;\n         }\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n-            {\n+            BOOST_FOREACH (CNode* pnode, vNodes) {\n                 if (pnode->hSocket == INVALID_SOCKET)\n                     continue;\n                 FD_SET(pnode->hSocket, &fdsetError);\n@@ -803,39 +764,37 @@ void ThreadSocketHandler()\n                 }\n                 {\n                     TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n-                    if (lockRecv && (\n-                        pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||\n-                        pnode->GetTotalRecvSize() <= ReceiveFloodSize()))\n+                    if (lockRecv && (pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||\n+                                     pnode->GetTotalRecvSize() <= ReceiveFloodSize()))\n                         FD_SET(pnode->hSocket, &fdsetRecv);\n                 }\n             }\n         }\n \n         int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+                             &fdsetRecv,\n+                             &fdsetSend,\n+                             &fdsetError,\n+                             &timeout);\n         boost::this_thread::interruption_point();\n \n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            if (have_fds)\n-            {\n+        if (nSelect == SOCKET_ERROR) {\n+            if (have_fds) {\n                 int nErr = WSAGetLastError();\n                 LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n                 for (unsigned int i = 0; i <= hSocketMax; i++)\n                     FD_SET(i, &fdsetRecv);\n             }\n             FD_ZERO(&fdsetSend);\n             FD_ZERO(&fdsetError);\n-            MilliSleep(timeout.tv_usec/1000);\n+            MilliSleep(timeout.tv_usec / 1000);\n         }\n \n         //\n         // Accept new connections\n         //\n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket)\n-        {\n-            if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n-            {\n+        BOOST_FOREACH (const ListenSocket& hListenSocket, vhListenSocket) {\n+            if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv)) {\n                 struct sockaddr_storage sockaddr;\n                 socklen_t len = sizeof(sockaddr);\n                 SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n@@ -849,28 +808,21 @@ void ThreadSocketHandler()\n                 bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);\n                 {\n                     LOCK(cs_vNodes);\n-                    BOOST_FOREACH(CNode* pnode, vNodes)\n+                    BOOST_FOREACH (CNode* pnode, vNodes)\n                         if (pnode->fInbound)\n                             nInbound++;\n                 }\n \n-                if (hSocket == INVALID_SOCKET)\n-                {\n+                if (hSocket == INVALID_SOCKET) {\n                     int nErr = WSAGetLastError();\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-                }\n-                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n-                {\n+                } else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS) {\n                     CloseSocket(hSocket);\n-                }\n-                else if (CNode::IsBanned(addr) && !whitelisted)\n-                {\n+                } else if (CNode::IsBanned(addr) && !whitelisted) {\n                     LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n                     CloseSocket(hSocket);\n-                }\n-                else\n-                {\n+                } else {\n                     CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                     pnode->AddRef();\n                     pnode->fWhitelisted = whitelisted;\n@@ -890,48 +842,39 @@ void ThreadSocketHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n                 pnode->AddRef();\n         }\n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n-        {\n+        BOOST_FOREACH (CNode* pnode, vNodesCopy) {\n             boost::this_thread::interruption_point();\n \n             //\n             // Receive\n             //\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n-            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n-            {\n+            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError)) {\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n-                if (lockRecv)\n-                {\n+                if (lockRecv) {\n                     {\n                         // typical socket buffer is 8K-64K\n                         char pchBuf[0x10000];\n                         int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-                        if (nBytes > 0)\n-                        {\n+                        if (nBytes > 0) {\n                             if (!pnode->ReceiveMsgBytes(pchBuf, nBytes))\n                                 pnode->CloseSocketDisconnect();\n                             pnode->nLastRecv = GetTime();\n                             pnode->nRecvBytes += nBytes;\n                             pnode->RecordBytesRecv(nBytes);\n-                        }\n-                        else if (nBytes == 0)\n-                        {\n+                        } else if (nBytes == 0) {\n                             // socket closed gracefully\n                             if (!pnode->fDisconnect)\n                                 LogPrint(\"net\", \"socket closed\\n\");\n                             pnode->CloseSocketDisconnect();\n-                        }\n-                        else if (nBytes < 0)\n-                        {\n+                        } else if (nBytes < 0) {\n                             // error\n                             int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n+                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n                                 if (!pnode->fDisconnect)\n                                     LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n                                 pnode->CloseSocketDisconnect();\n@@ -946,8 +889,7 @@ void ThreadSocketHandler()\n             //\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n-            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n-            {\n+            if (FD_ISSET(pnode->hSocket, &fdsetSend)) {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n                 if (lockSend)\n                     SocketSendData(pnode);\n@@ -957,53 +899,38 @@ void ThreadSocketHandler()\n             // Inactivity checking\n             //\n             int64_t nTime = GetTime();\n-            if (nTime - pnode->nTimeConnected > 60)\n-            {\n-                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n-                {\n+            if (nTime - pnode->nTimeConnected > 60) {\n+                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0) {\n                     LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n                     pnode->fDisconnect = true;\n-                }\n-                else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n-                {\n+                } else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL) {\n                     LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n                     pnode->fDisconnect = true;\n-                }\n-                else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n-                {\n+                } else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90 * 60)) {\n                     LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n                     pnode->fDisconnect = true;\n-                }\n-                else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n-                {\n+                } else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros()) {\n                     LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n                     pnode->fDisconnect = true;\n                 }\n             }\n         }\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n                 pnode->Release();\n         }\n     }\n }\n \n \n-\n-\n-\n-\n-\n-\n-\n #ifdef USE_UPNP\n void ThreadMapPort()\n {\n     std::string port = strprintf(\"%u\", GetListenPort());\n-    const char * multicastif = 0;\n-    const char * minissdpdpath = 0;\n-    struct UPNPDev * devlist = 0;\n+    const char* multicastif = 0;\n+    const char* minissdpdpath = 0;\n+    struct UPNPDev* devlist = 0;\n     char lanaddr[64];\n \n #ifndef UPNPDISCOVER_SUCCESS\n@@ -1020,21 +947,17 @@ void ThreadMapPort()\n     int r;\n \n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n-    if (r == 1)\n-    {\n+    if (r == 1) {\n         if (fDiscover) {\n             char externalIPAddress[40];\n             r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n-            if(r != UPNPCOMMAND_SUCCESS)\n+            if (r != UPNPCOMMAND_SUCCESS)\n                 LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n-            else\n-            {\n-                if(externalIPAddress[0])\n-                {\n+            else {\n+                if (externalIPAddress[0]) {\n                     LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                     AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n-                }\n-                else\n+                } else\n                     LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n             }\n         }\n@@ -1045,34 +968,37 @@ void ThreadMapPort()\n             while (true) {\n #ifndef UPNPDISCOVER_SUCCESS\n                 /* miniupnpc 1.5 */\n-                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n+                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n #else\n                 /* miniupnpc 1.6 */\n-                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n #endif\n \n-                if(r!=UPNPCOMMAND_SUCCESS)\n+                if (r != UPNPCOMMAND_SUCCESS)\n                     LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-                        port, port, lanaddr, r, strupnperror(r));\n+                              port,\n+                              port,\n+                              lanaddr,\n+                              r,\n+                              strupnperror(r));\n                 else\n-                    LogPrintf(\"UPnP Port Mapping successful.\\n\");;\n+                    LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+                ;\n \n-                MilliSleep(20*60*1000); // Refresh every 20 minutes\n+                MilliSleep(20 * 60 * 1000); // Refresh every 20 minutes\n             }\n-        }\n-        catch (boost::thread_interrupted)\n-        {\n+        } catch (boost::thread_interrupted) {\n             r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n             LogPrintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n-            freeUPNPDevlist(devlist); devlist = 0;\n+            freeUPNPDevlist(devlist);\n+            devlist = 0;\n             FreeUPNPUrls(&urls);\n             throw;\n         }\n     } else {\n         LogPrintf(\"No valid UPnP IGDs found\\n\");\n-        freeUPNPDevlist(devlist); devlist = 0;\n+        freeUPNPDevlist(devlist);\n+        devlist = 0;\n         if (r != 0)\n             FreeUPNPUrls(&urls);\n     }\n@@ -1082,16 +1008,14 @@ void MapPort(bool fUseUPnP)\n {\n     static boost::thread* upnp_thread = NULL;\n \n-    if (fUseUPnP)\n-    {\n+    if (fUseUPnP) {\n         if (upnp_thread) {\n             upnp_thread->interrupt();\n             upnp_thread->join();\n             delete upnp_thread;\n         }\n         upnp_thread = new boost::thread(boost::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadMapPort));\n-    }\n-    else if (upnp_thread) {\n+    } else if (upnp_thread) {\n         upnp_thread->interrupt();\n         upnp_thread->join();\n         delete upnp_thread;\n@@ -1107,10 +1031,6 @@ void MapPort(bool)\n #endif\n \n \n-\n-\n-\n-\n void ThreadDNSAddressSeed()\n {\n     // goal: only query DNS seeds if address need is acute\n@@ -1125,24 +1045,22 @@ void ThreadDNSAddressSeed()\n         }\n     }\n \n-    const vector<CDNSSeedData> &vSeeds = Params().DNSSeeds();\n+    const vector<CDNSSeedData>& vSeeds = Params().DNSSeeds();\n     int found = 0;\n \n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-    BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n+    BOOST_FOREACH (const CDNSSeedData& seed, vSeeds) {\n         if (HaveNameProxy()) {\n             AddOneShot(seed.host);\n         } else {\n             vector<CNetAddr> vIPs;\n             vector<CAddress> vAdd;\n-            if (LookupHost(seed.host.c_str(), vIPs))\n-            {\n-                BOOST_FOREACH(CNetAddr& ip, vIPs)\n-                {\n-                    int nOneDay = 24*3600;\n+            if (LookupHost(seed.host.c_str(), vIPs)) {\n+                BOOST_FOREACH (CNetAddr& ip, vIPs) {\n+                    int nOneDay = 24 * 3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()));\n-                    addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n+                    addr.nTime = GetTime() - 3 * nOneDay - GetRand(4 * nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n@@ -1155,25 +1073,14 @@ void ThreadDNSAddressSeed()\n }\n \n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n void DumpAddresses()\n {\n     int64_t nStart = GetTimeMillis();\n \n     CAddrDB adb;\n     adb.Write(addrman);\n \n-    LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %dms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+    LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %dms\\n\", addrman.size(), GetTimeMillis() - nStart);\n }\n \n void static ProcessOneShot()\n@@ -1197,17 +1104,13 @@ void static ProcessOneShot()\n void ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n-    {\n-        for (int64_t nLoop = 0;; nLoop++)\n-        {\n+    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n+        for (int64_t nLoop = 0;; nLoop++) {\n             ProcessOneShot();\n-            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n-            {\n+            BOOST_FOREACH (string strAddr, mapMultiArgs[\"-connect\"]) {\n                 CAddress addr;\n                 OpenNetworkConnection(addr, NULL, strAddr.c_str());\n-                for (int i = 0; i < 10 && i < nLoop; i++)\n-                {\n+                for (int i = 0; i < 10 && i < nLoop; i++) {\n                     MilliSleep(500);\n                 }\n             }\n@@ -1217,8 +1120,7 @@ void ThreadOpenConnections()\n \n     // Initiate network connections\n     int64_t nStart = GetTime();\n-    while (true)\n-    {\n+    while (true) {\n         ProcessOneShot();\n \n         MilliSleep(500);\n@@ -1247,7 +1149,7 @@ void ThreadOpenConnections()\n         set<vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes) {\n+            BOOST_FOREACH (CNode* pnode, vNodes) {\n                 if (!pnode->fInbound) {\n                     setConnected.insert(pnode->addr.GetGroup());\n                     nOutbound++;\n@@ -1258,10 +1160,9 @@ void ThreadOpenConnections()\n         int64_t nANow = GetAdjustedTime();\n \n         int nTries = 0;\n-        while (true)\n-        {\n+        while (true) {\n             // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n-            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n+            CAddress addr = addrman.Select(10 + min(nOutbound, 8) * 10);\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n@@ -1302,14 +1203,14 @@ void ThreadOpenAddedConnections()\n     }\n \n     if (HaveNameProxy()) {\n-        while(true) {\n+        while (true) {\n             list<string> lAddresses(0);\n             {\n                 LOCK(cs_vAddedNodes);\n-                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n+                BOOST_FOREACH (string& strAddNode, vAddedNodes)\n                     lAddresses.push_back(strAddNode);\n             }\n-            BOOST_FOREACH(string& strAddNode, lAddresses) {\n+            BOOST_FOREACH (string& strAddNode, lAddresses) {\n                 CAddress addr;\n                 CSemaphoreGrant grant(*semOutbound);\n                 OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n@@ -1319,25 +1220,22 @@ void ThreadOpenAddedConnections()\n         }\n     }\n \n-    for (unsigned int i = 0; true; i++)\n-    {\n+    for (unsigned int i = 0; true; i++) {\n         list<string> lAddresses(0);\n         {\n             LOCK(cs_vAddedNodes);\n-            BOOST_FOREACH(string& strAddNode, vAddedNodes)\n+            BOOST_FOREACH (string& strAddNode, vAddedNodes)\n                 lAddresses.push_back(strAddNode);\n         }\n \n         list<vector<CService> > lservAddressesToAdd(0);\n-        BOOST_FOREACH(string& strAddNode, lAddresses)\n-        {\n+        BOOST_FOREACH (string& strAddNode, lAddresses) {\n             vector<CService> vservNode(0);\n-            if(Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n-            {\n+            if (Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0)) {\n                 lservAddressesToAdd.push_back(vservNode);\n                 {\n                     LOCK(cs_setservAddNodeAddresses);\n-                    BOOST_FOREACH(CService& serv, vservNode)\n+                    BOOST_FOREACH (CService& serv, vservNode)\n                         setservAddNodeAddresses.insert(serv);\n                 }\n             }\n@@ -1346,18 +1244,16 @@ void ThreadOpenAddedConnections()\n         // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n+            BOOST_FOREACH (CNode* pnode, vNodes)\n                 for (list<vector<CService> >::iterator it = lservAddressesToAdd.begin(); it != lservAddressesToAdd.end(); it++)\n-                    BOOST_FOREACH(CService& addrNode, *(it))\n-                        if (pnode->addr == addrNode)\n-                        {\n+                    BOOST_FOREACH (CService& addrNode, *(it))\n+                        if (pnode->addr == addrNode) {\n                             it = lservAddressesToAdd.erase(it);\n                             it--;\n                             break;\n                         }\n         }\n-        BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd)\n-        {\n+        BOOST_FOREACH (vector<CService>& vserv, lservAddressesToAdd) {\n             CSemaphoreGrant grant(*semOutbound);\n             OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n             MilliSleep(500);\n@@ -1367,7 +1263,7 @@ void ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot)\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant* grantOutbound, const char* pszDest, bool fOneShot)\n {\n     //\n     // Initiate outbound network connection\n@@ -1399,13 +1295,12 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n void ThreadMessageHandler()\n {\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n-    while (true)\n-    {\n+    while (true) {\n         vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy) {\n                 pnode->AddRef();\n             }\n         }\n@@ -1417,23 +1312,19 @@ void ThreadMessageHandler()\n \n         bool fSleep = true;\n \n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n-        {\n+        BOOST_FOREACH (CNode* pnode, vNodesCopy) {\n             if (pnode->fDisconnect)\n                 continue;\n \n             // Receive messages\n             {\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n-                if (lockRecv)\n-                {\n+                if (lockRecv) {\n                     if (!g_signals.ProcessMessages(pnode))\n                         pnode->CloseSocketDisconnect();\n \n-                    if (pnode->nSendSize < SendBufferSize())\n-                    {\n-                        if (!pnode->vRecvGetData.empty() || (!pnode->vRecvMsg.empty() && pnode->vRecvMsg[0].complete()))\n-                        {\n+                    if (pnode->nSendSize < SendBufferSize()) {\n+                        if (!pnode->vRecvGetData.empty() || (!pnode->vRecvMsg.empty() && pnode->vRecvMsg[0].complete())) {\n                             fSleep = false;\n                         }\n                     }\n@@ -1452,7 +1343,7 @@ void ThreadMessageHandler()\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n                 pnode->Release();\n         }\n \n@@ -1462,28 +1353,22 @@ void ThreadMessageHandler()\n }\n \n \n-\n-\n-\n-\n-bool BindListenPort(const CService &addrBind, string& strError, bool fWhitelisted)\n+bool BindListenPort(const CService& addrBind, string& strError, bool fWhitelisted)\n {\n     strError = \"\";\n     int nOne = 1;\n \n     // Create socket for listening for incoming connections\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n+    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n         strError = strprintf(\"Error: Bind address family for %s not supported\", addrBind.ToString());\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n     SOCKET hListenSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n-    if (hListenSocket == INVALID_SOCKET)\n-    {\n+    if (hListenSocket == INVALID_SOCKET) {\n         strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n@@ -1522,8 +1407,7 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n #endif\n     }\n \n-    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n-    {\n+    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR) {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n             strError = strprintf(_(\"Unable to bind to %s on this computer. Bitcoin Core is probably already running.\"), addrBind.ToString());\n@@ -1536,8 +1420,7 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n-    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n-    {\n+    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR) {\n         strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         CloseSocket(hListenSocket);\n@@ -1560,13 +1443,10 @@ void static Discover(boost::thread_group& threadGroup)\n #ifdef WIN32\n     // Get local host IP\n     char pszHostName[256] = \"\";\n-    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n-    {\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR) {\n         vector<CNetAddr> vaddr;\n-        if (LookupHost(pszHostName, vaddr))\n-        {\n-            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n-            {\n+        if (LookupHost(pszHostName, vaddr)) {\n+            BOOST_FOREACH (const CNetAddr& addr, vaddr) {\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());\n             }\n@@ -1575,23 +1455,22 @@ void static Discover(boost::thread_group& threadGroup)\n #else\n     // Get local host ip\n     struct ifaddrs* myaddrs;\n-    if (getifaddrs(&myaddrs) == 0)\n-    {\n-        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n-        {\n-            if (ifa->ifa_addr == NULL) continue;\n-            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n-            if (ifa->ifa_addr->sa_family == AF_INET)\n-            {\n+    if (getifaddrs(&myaddrs) == 0) {\n+        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n+            if (ifa->ifa_addr == NULL)\n+                continue;\n+            if ((ifa->ifa_flags & IFF_UP) == 0)\n+                continue;\n+            if (strcmp(ifa->ifa_name, \"lo\") == 0)\n+                continue;\n+            if (strcmp(ifa->ifa_name, \"lo0\") == 0)\n+                continue;\n+            if (ifa->ifa_addr->sa_family == AF_INET) {\n                 struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                 CNetAddr addr(s4->sin_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());\n-            }\n-            else if (ifa->ifa_addr->sa_family == AF_INET6)\n-            {\n+            } else if (ifa->ifa_addr->sa_family == AF_INET6) {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 CNetAddr addr(s6->sin6_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n@@ -1614,7 +1493,8 @@ void StartNode(boost::thread_group& threadGroup)\n             LogPrintf(\"Invalid or missing peers.dat; recreating\\n\");\n     }\n     LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+              addrman.size(),\n+              GetTimeMillis() - nStart);\n     fAddressesInitialized = true;\n \n     if (semOutbound == NULL) {\n@@ -1661,11 +1541,10 @@ bool StopNode()\n     LogPrintf(\"StopNode()\\n\");\n     MapPort(false);\n     if (semOutbound)\n-        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n+        for (int i = 0; i < MAX_OUTBOUND_CONNECTIONS; i++)\n             semOutbound->post();\n \n-    if (fAddressesInitialized)\n-    {\n+    if (fAddressesInitialized) {\n         DumpAddresses();\n         fAddressesInitialized = false;\n     }\n@@ -1681,18 +1560,18 @@ class CNetCleanup\n     ~CNetCleanup()\n     {\n         // Close sockets\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n+        BOOST_FOREACH (CNode* pnode, vNodes)\n             if (pnode->hSocket != INVALID_SOCKET)\n                 CloseSocket(pnode->hSocket);\n-        BOOST_FOREACH(ListenSocket& hListenSocket, vhListenSocket)\n+        BOOST_FOREACH (ListenSocket& hListenSocket, vhListenSocket)\n             if (hListenSocket.socket != INVALID_SOCKET)\n                 if (!CloseSocket(hListenSocket.socket))\n                     LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n         // clean up some globals (to help leak detection)\n-        BOOST_FOREACH(CNode *pnode, vNodes)\n+        BOOST_FOREACH (CNode* pnode, vNodes)\n             delete pnode;\n-        BOOST_FOREACH(CNode *pnode, vNodesDisconnected)\n+        BOOST_FOREACH (CNode* pnode, vNodesDisconnected)\n             delete pnode;\n         vNodes.clear();\n         vNodesDisconnected.clear();\n@@ -1707,13 +1586,7 @@ class CNetCleanup\n         WSACleanup();\n #endif\n     }\n-}\n-instance_of_cnetcleanup;\n-\n-\n-\n-\n-\n+} instance_of_cnetcleanup;\n \n \n void RelayTransaction(const CTransaction& tx)\n@@ -1730,8 +1603,7 @@ void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n     {\n         LOCK(cs_mapRelay);\n         // Expire old relay messages\n-        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n-        {\n+        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime()) {\n             mapRelay.erase(vRelayExpiration.front().second);\n             vRelayExpiration.pop_front();\n         }\n@@ -1741,13 +1613,11 @@ void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n         vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n     }\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n-    {\n-        if(!pnode->fRelayTxes)\n+    BOOST_FOREACH (CNode* pnode, vNodes) {\n+        if (!pnode->fRelayTxes)\n             continue;\n         LOCK(pnode->cs_filter);\n-        if (pnode->pfilter)\n-        {\n+        if (pnode->pfilter) {\n             if (pnode->pfilter->IsRelevantAndUpdate(tx))\n                 pnode->PushInventory(inv);\n         } else\n@@ -1781,11 +1651,12 @@ uint64_t CNode::GetTotalBytesSent()\n \n void CNode::Fuzz(int nChance)\n {\n-    if (!fSuccessfullyConnected) return; // Don't fuzz initial handshake\n-    if (GetRand(nChance) != 0) return; // Fuzz 1 of every nChance messages\n+    if (!fSuccessfullyConnected)\n+        return; // Don't fuzz initial handshake\n+    if (GetRand(nChance) != 0)\n+        return; // Fuzz 1 of every nChance messages\n \n-    switch (GetRand(3))\n-    {\n+    switch (GetRand(3)) {\n     case 0:\n         // xor a random byte with a random value:\n         if (!ssSend.empty()) {\n@@ -1797,15 +1668,15 @@ void CNode::Fuzz(int nChance)\n         // delete a random byte:\n         if (!ssSend.empty()) {\n             CDataStream::size_type pos = GetRand(ssSend.size());\n-            ssSend.erase(ssSend.begin()+pos);\n+            ssSend.erase(ssSend.begin() + pos);\n         }\n         break;\n     case 2:\n         // insert a random byte at a random position\n         {\n             CDataStream::size_type pos = GetRand(ssSend.size());\n             char ch = (char)GetRand(256);\n-            ssSend.insert(ssSend.begin()+pos, ch);\n+            ssSend.insert(ssSend.begin() + pos, ch);\n         }\n         break;\n     }\n@@ -1839,16 +1710,15 @@ bool CAddrDB::Write(const CAddrMan& addr)\n \n     // open temp output file, and associate with CAutoFile\n     boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n+    FILE* file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n         return error(\"%s : Failed to open file %s\", __func__, pathTmp.string());\n \n     // Write and commit header, data\n     try {\n         fileout << ssPeers;\n-    }\n-    catch (std::exception &e) {\n+    } catch (std::exception& e) {\n         return error(\"%s : Serialize or I/O error - %s\", __func__, e.what());\n     }\n     FileCommit(fileout.Get());\n@@ -1864,7 +1734,7 @@ bool CAddrDB::Write(const CAddrMan& addr)\n bool CAddrDB::Read(CAddrMan& addr)\n {\n     // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n+    FILE* file = fopen(pathAddr.string().c_str(), \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n         return error(\"%s : Failed to open file %s\", __func__, pathAddr.string());\n@@ -1881,10 +1751,9 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n     // read data and checksum from file\n     try {\n-        filein.read((char *)&vchData[0], dataSize);\n+        filein.read((char*)&vchData[0], dataSize);\n         filein >> hashIn;\n-    }\n-    catch (std::exception &e) {\n+    } catch (std::exception& e) {\n         return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n     }\n     filein.fclose();\n@@ -1907,16 +1776,15 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n-    }\n-    catch (std::exception &e) {\n+    } catch (std::exception& e) {\n         return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     return true;\n }\n \n-unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n-unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n+unsigned int ReceiveFloodSize() { return 1000 * GetArg(\"-maxreceivebuffer\", 5 * 1000); }\n+unsigned int SendBufferSize() { return 1000 * GetArg(\"-maxsendbuffer\", 1 * 1000); }\n \n CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), setAddrKnown(5000)\n {\n@@ -1992,7 +1860,7 @@ void CNode::AskFor(const CInv& inv)\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n-    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n+    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime / 1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;\n@@ -2032,8 +1900,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n     // The -*messagestest options are intentionally not documented in the help message,\n     // since they are only used during development to debug the networking code and are\n     // not intended for end-users.\n-    if (mapArgs.count(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 2)) == 0)\n-    {\n+    if (mapArgs.count(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 2)) == 0) {\n         LogPrint(\"net\", \"dropmessages DROPPING SEND MESSAGE\\n\");\n         AbortMessage();\n         return;\n@@ -2052,7 +1919,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n     uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());\n     unsigned int nChecksum = 0;\n     memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-    assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n+    assert(ssSend.size() >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n     memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n \n     LogPrint(\"net\", \"(%d bytes) peer=%d\\n\", nSize, id);"
      },
      {
        "sha": "1b47119b087b70b00e58459901739b435e229f8c",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 263,
        "deletions": 250,
        "changes": 513,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -43,49 +43,58 @@ static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n bool fNameLookup = false;\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+static const unsigned char pchIPv4[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff};\n \n // Need ample time for negotiation for very slow proxies such as Tor (milliseconds)\n static const int SOCKS5_RECV_TIMEOUT = 20 * 1000;\n \n-enum Network ParseNetwork(std::string net) {\n+enum Network ParseNetwork(std::string net)\n+{\n     boost::to_lower(net);\n-    if (net == \"ipv4\") return NET_IPV4;\n-    if (net == \"ipv6\") return NET_IPV6;\n-    if (net == \"tor\" || net == \"onion\")  return NET_TOR;\n+    if (net == \"ipv4\")\n+        return NET_IPV4;\n+    if (net == \"ipv6\")\n+        return NET_IPV6;\n+    if (net == \"tor\" || net == \"onion\")\n+        return NET_TOR;\n     return NET_UNROUTABLE;\n }\n \n-std::string GetNetworkName(enum Network net) {\n-    switch(net)\n-    {\n-    case NET_IPV4: return \"ipv4\";\n-    case NET_IPV6: return \"ipv6\";\n-    case NET_TOR: return \"onion\";\n-    default: return \"\";\n+std::string GetNetworkName(enum Network net)\n+{\n+    switch (net) {\n+    case NET_IPV4:\n+        return \"ipv4\";\n+    case NET_IPV6:\n+        return \"ipv6\";\n+    case NET_TOR:\n+        return \"onion\";\n+    default:\n+        return \"\";\n     }\n }\n \n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n+void SplitHostPort(std::string in, int& portOut, std::string& hostOut)\n+{\n     size_t colon = in.find_last_of(':');\n     // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n     bool fHaveColon = colon != in.npos;\n-    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n-    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n-    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n+    bool fBracketed = fHaveColon && (in[0] == '[' && in[colon - 1] == ']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n+    bool fMultiColon = fHaveColon && (in.find_last_of(':', colon - 1) != in.npos);\n+    if (fHaveColon && (colon == 0 || fBracketed || !fMultiColon)) {\n         int32_t n;\n         if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n             in = in.substr(0, colon);\n             portOut = n;\n         }\n     }\n-    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n-        hostOut = in.substr(1, in.size()-2);\n+    if (in.size() > 0 && in[0] == '[' && in[in.size() - 1] == ']')\n+        hostOut = in.substr(1, in.size() - 2);\n     else\n         hostOut = in;\n }\n \n-bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool static LookupIntern(const char* pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     vIP.clear();\n \n@@ -130,7 +139,7 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n #endif\n \n-    struct addrinfo *aiRes = NULL;\n+    struct addrinfo* aiRes = NULL;\n #ifdef HAVE_GETADDRINFO_A\n     struct gaicb gcb, *query = &gcb;\n     memset(query, 0, sizeof(struct gaicb));\n@@ -145,7 +154,7 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n         // generating unnecessary checking call during the polling loop,\n         // while it can still response to stop request quick enough.\n         // 2 seconds looks fine in our situation.\n-        struct timespec ts = { 2, 0 };\n+        struct timespec ts = {2, 0};\n         gai_suspend(&query, 1, &ts);\n         boost::this_thread::interruption_point();\n \n@@ -159,17 +168,14 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     if (nErr)\n         return false;\n \n-    struct addrinfo *aiTrav = aiRes;\n-    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n-    {\n-        if (aiTrav->ai_family == AF_INET)\n-        {\n+    struct addrinfo* aiTrav = aiRes;\n+    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions)) {\n+        if (aiTrav->ai_family == AF_INET) {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n             vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n         }\n \n-        if (aiTrav->ai_family == AF_INET6)\n-        {\n+        if (aiTrav->ai_family == AF_INET6) {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n             vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n         }\n@@ -182,20 +188,19 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     return (vIP.size() > 0);\n }\n \n-bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool LookupHost(const char* pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     std::string strHost(pszName);\n     if (strHost.empty())\n         return false;\n-    if (boost::algorithm::starts_with(strHost, \"[\") && boost::algorithm::ends_with(strHost, \"]\"))\n-    {\n+    if (boost::algorithm::starts_with(strHost, \"[\") && boost::algorithm::ends_with(strHost, \"]\")) {\n         strHost = strHost.substr(1, strHost.size() - 2);\n     }\n \n     return LookupIntern(strHost.c_str(), vIP, nMaxSolutions, fAllowLookup);\n }\n \n-bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n+bool Lookup(const char* pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n {\n     if (pszName[0] == 0)\n         return false;\n@@ -213,7 +218,7 @@ bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault,\n     return true;\n }\n \n-bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n+bool Lookup(const char* pszName, CService& addr, int portDefault, bool fAllowLookup)\n {\n     std::vector<CService> vService;\n     bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n@@ -223,7 +228,7 @@ bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLoo\n     return true;\n }\n \n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n+bool LookupNumeric(const char* pszName, CService& addr, int portDefault)\n {\n     return Lookup(pszName, addr, portDefault, false);\n }\n@@ -234,7 +239,7 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n struct timeval static MillisToTimeval(int64_t nTimeout)\n {\n     struct timeval timeout;\n-    timeout.tv_sec  = nTimeout / 1000;\n+    timeout.tv_sec = nTimeout / 1000;\n     timeout.tv_usec = (nTimeout % 1000) * 1000;\n     return timeout;\n }\n@@ -288,108 +293,110 @@ bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSock\n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n-    if (strDest.size() > 255)\n-    {\n+    if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n     }\n     char pszSocks5Init[] = \"\\5\\1\\0\";\n     ssize_t nSize = sizeof(pszSocks5Init) - 1;\n \n     ssize_t ret = send(hSocket, pszSocks5Init, nSize, MSG_NOSIGNAL);\n-    if (ret != nSize)\n-    {\n+    if (ret != nSize) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n-    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n-    {\n+    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to initialize\");\n     }\n     string strSocks5(\"\\5\\1\");\n-    strSocks5 += '\\000'; strSocks5 += '\\003';\n+    strSocks5 += '\\000';\n+    strSocks5 += '\\003';\n     strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n     strSocks5 += strDest;\n     strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n     strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n     ret = send(hSocket, strSocks5.data(), strSocks5.size(), MSG_NOSIGNAL);\n-    if (ret != (ssize_t)strSocks5.size())\n-    {\n+    if (ret != (ssize_t)strSocks5.size()) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n-    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet2[0] != 0x05)\n-    {\n+    if (pchRet2[0] != 0x05) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to accept request\");\n     }\n-    if (pchRet2[1] != 0x00)\n-    {\n+    if (pchRet2[1] != 0x00) {\n         CloseSocket(hSocket);\n-        switch (pchRet2[1])\n-        {\n-            case 0x01: return error(\"Proxy error: general failure\");\n-            case 0x02: return error(\"Proxy error: connection not allowed\");\n-            case 0x03: return error(\"Proxy error: network unreachable\");\n-            case 0x04: return error(\"Proxy error: host unreachable\");\n-            case 0x05: return error(\"Proxy error: connection refused\");\n-            case 0x06: return error(\"Proxy error: TTL expired\");\n-            case 0x07: return error(\"Proxy error: protocol error\");\n-            case 0x08: return error(\"Proxy error: address type not supported\");\n-            default:   return error(\"Proxy error: unknown\");\n+        switch (pchRet2[1]) {\n+        case 0x01:\n+            return error(\"Proxy error: general failure\");\n+        case 0x02:\n+            return error(\"Proxy error: connection not allowed\");\n+        case 0x03:\n+            return error(\"Proxy error: network unreachable\");\n+        case 0x04:\n+            return error(\"Proxy error: host unreachable\");\n+        case 0x05:\n+            return error(\"Proxy error: connection refused\");\n+        case 0x06:\n+            return error(\"Proxy error: TTL expired\");\n+        case 0x07:\n+            return error(\"Proxy error: protocol error\");\n+        case 0x08:\n+            return error(\"Proxy error: address type not supported\");\n+        default:\n+            return error(\"Proxy error: unknown\");\n         }\n     }\n-    if (pchRet2[2] != 0x00)\n-    {\n+    if (pchRet2[2] != 0x00) {\n         CloseSocket(hSocket);\n         return error(\"Error: malformed proxy response\");\n     }\n     char pchRet3[256];\n-    switch (pchRet2[3])\n-    {\n-        case 0x01: ret = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n-        case 0x04: ret = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n-        case 0x03:\n-        {\n-            ret = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n-            if (!ret) {\n-                CloseSocket(hSocket);\n-                return error(\"Error reading from proxy\");\n-            }\n-            int nRecv = pchRet3[0];\n-            ret = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n-            break;\n+    switch (pchRet2[3]) {\n+    case 0x01:\n+        ret = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket);\n+        break;\n+    case 0x04:\n+        ret = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket);\n+        break;\n+    case 0x03: {\n+        ret = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n+        if (!ret) {\n+            CloseSocket(hSocket);\n+            return error(\"Error reading from proxy\");\n         }\n-        default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n+        int nRecv = pchRet3[0];\n+        ret = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n+        break;\n     }\n-    if (!ret)\n-    {\n+    default:\n+        CloseSocket(hSocket);\n+        return error(\"Error: malformed proxy response\");\n+    }\n+    if (!ret) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n     LogPrintf(\"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n \n-bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRet, int nTimeout)\n+bool static ConnectSocketDirectly(const CService& addrConnect, SOCKET& hSocketRet, int nTimeout)\n {\n     hSocketRet = INVALID_SOCKET;\n \n@@ -414,25 +421,21 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n-    if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n-    {\n+    if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR) {\n         int nErr = WSAGetLastError();\n         // WSAEINVAL is here because some legacy version of winsock uses it\n-        if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n-        {\n+        if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL) {\n             struct timeval timeout = MillisToTimeval(nTimeout);\n             fd_set fdset;\n             FD_ZERO(&fdset);\n             FD_SET(hSocket, &fdset);\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n-            if (nRet == 0)\n-            {\n+            if (nRet == 0) {\n                 LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n                 CloseSocket(hSocket);\n                 return false;\n             }\n-            if (nRet == SOCKET_ERROR)\n-            {\n+            if (nRet == SOCKET_ERROR) {\n                 LogPrintf(\"select() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n                 CloseSocket(hSocket);\n                 return false;\n@@ -448,8 +451,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n                 CloseSocket(hSocket);\n                 return false;\n             }\n-            if (nRet != 0)\n-            {\n+            if (nRet != 0) {\n                 LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(), NetworkErrorString(nRet));\n                 CloseSocket(hSocket);\n                 return false;\n@@ -471,7 +473,8 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     return true;\n }\n \n-bool SetProxy(enum Network net, CService addrProxy) {\n+bool SetProxy(enum Network net, CService addrProxy)\n+{\n     assert(net >= 0 && net < NET_MAX);\n     if (!addrProxy.IsValid())\n         return false;\n@@ -480,7 +483,8 @@ bool SetProxy(enum Network net, CService addrProxy) {\n     return true;\n }\n \n-bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n+bool GetProxy(enum Network net, proxyType& proxyInfoOut)\n+{\n     assert(net >= 0 && net < NET_MAX);\n     LOCK(cs_proxyInfos);\n     if (!proxyInfo[net].IsValid())\n@@ -489,28 +493,32 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     return true;\n }\n \n-bool SetNameProxy(CService addrProxy) {\n+bool SetNameProxy(CService addrProxy)\n+{\n     if (!addrProxy.IsValid())\n         return false;\n     LOCK(cs_proxyInfos);\n     nameProxy = addrProxy;\n     return true;\n }\n \n-bool GetNameProxy(CService &nameProxyOut) {\n+bool GetNameProxy(CService& nameProxyOut)\n+{\n     LOCK(cs_proxyInfos);\n-    if(!nameProxy.IsValid())\n+    if (!nameProxy.IsValid())\n         return false;\n     nameProxyOut = nameProxy;\n     return true;\n }\n \n-bool HaveNameProxy() {\n+bool HaveNameProxy()\n+{\n     LOCK(cs_proxyInfos);\n     return nameProxy.IsValid();\n }\n \n-bool IsProxy(const CNetAddr &addr) {\n+bool IsProxy(const CNetAddr& addr)\n+{\n     LOCK(cs_proxyInfos);\n     for (int i = 0; i < NET_MAX; i++) {\n         if (addr == (CNetAddr)proxyInfo[i])\n@@ -519,7 +527,7 @@ bool IsProxy(const CNetAddr &addr) {\n     return false;\n }\n \n-bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n+bool ConnectSocket(const CService& addrDest, SOCKET& hSocketRet, int nTimeout)\n {\n     proxyType proxy;\n     // no proxy needed (none set for target network)\n@@ -539,7 +547,7 @@ bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n     return true;\n }\n \n-bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout)\n+bool ConnectSocketByName(CService& addr, SOCKET& hSocketRet, const char* pszDest, int portDefault, int nTimeout)\n {\n     string strDest;\n     int port = portDefault;\n@@ -581,32 +589,31 @@ void CNetAddr::SetIP(const CNetAddr& ipIn)\n     memcpy(ip, ipIn.ip, sizeof(ip));\n }\n \n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n+void CNetAddr::SetRaw(Network network, const uint8_t* ip_in)\n {\n-    switch(network)\n-    {\n-        case NET_IPV4:\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n+    switch (network) {\n+    case NET_IPV4:\n+        memcpy(ip, pchIPv4, 12);\n+        memcpy(ip + 12, ip_in, 4);\n+        break;\n+    case NET_IPV6:\n+        memcpy(ip, ip_in, 16);\n+        break;\n+    default:\n+        assert(!\"invalid network\");\n     }\n }\n \n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+static const unsigned char pchOnionCat[] = {0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43};\n \n-bool CNetAddr::SetSpecial(const std::string &strName)\n+bool CNetAddr::SetSpecial(const std::string& strName)\n {\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n+    if (strName.size() > 6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n+        if (vchAddr.size() != 16 - sizeof(pchOnionCat))\n             return false;\n         memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n+        for (unsigned int i = 0; i < 16 - sizeof(pchOnionCat); i++)\n             ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n         return true;\n     }\n@@ -628,15 +635,15 @@ CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr)\n     SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n }\n \n-CNetAddr::CNetAddr(const char *pszIp, bool fAllowLookup)\n+CNetAddr::CNetAddr(const char* pszIp, bool fAllowLookup)\n {\n     Init();\n     std::vector<CNetAddr> vIP;\n     if (LookupHost(pszIp, vIP, 1, fAllowLookup))\n         *this = vIP[0];\n }\n \n-CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n+CNetAddr::CNetAddr(const std::string& strIp, bool fAllowLookup)\n {\n     Init();\n     std::vector<CNetAddr> vIP;\n@@ -646,7 +653,7 @@ CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n \n unsigned int CNetAddr::GetByte(int n) const\n {\n-    return ip[15-n];\n+    return ip[15 - n];\n }\n \n bool CNetAddr::IsIPv4() const\n@@ -661,10 +668,9 @@ bool CNetAddr::IsIPv6() const\n \n bool CNetAddr::IsRFC1918() const\n {\n-    return IsIPv4() && (\n-        GetByte(3) == 10 ||\n-        (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+    return IsIPv4() && (GetByte(3) == 10 ||\n+                        (GetByte(3) == 192 && GetByte(2) == 168) ||\n+                        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n }\n \n bool CNetAddr::IsRFC2544() const\n@@ -685,8 +691,8 @@ bool CNetAddr::IsRFC6598() const\n bool CNetAddr::IsRFC5737() const\n {\n     return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n-        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n-        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n+                        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n+                        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n }\n \n bool CNetAddr::IsRFC3849() const\n@@ -701,7 +707,7 @@ bool CNetAddr::IsRFC3964() const\n \n bool CNetAddr::IsRFC6052() const\n {\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+    static const unsigned char pchRFC6052[] = {0, 0x64, 0xFF, 0x9B, 0, 0, 0, 0, 0, 0, 0, 0};\n     return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n }\n \n@@ -712,7 +718,7 @@ bool CNetAddr::IsRFC4380() const\n \n bool CNetAddr::IsRFC4862() const\n {\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+    static const unsigned char pchRFC4862[] = {0xFE, 0x80, 0, 0, 0, 0, 0, 0};\n     return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n }\n \n@@ -723,7 +729,7 @@ bool CNetAddr::IsRFC4193() const\n \n bool CNetAddr::IsRFC6145() const\n {\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+    static const unsigned char pchRFC6145[] = {0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0, 0};\n     return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n }\n \n@@ -740,21 +746,20 @@ bool CNetAddr::IsTor() const\n bool CNetAddr::IsLocal() const\n {\n     // IPv4 loopback\n-   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n-       return true;\n+    if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+        return true;\n \n-   // IPv6 loopback (::1/128)\n-   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-   if (memcmp(ip, pchLocal, 16) == 0)\n-       return true;\n+    // IPv6 loopback (::1/128)\n+    static const unsigned char pchLocal[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};\n+    if (memcmp(ip, pchLocal, 16) == 0)\n+        return true;\n \n-   return false;\n+    return false;\n }\n \n bool CNetAddr::IsMulticast() const\n {\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n+    return (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0) || (GetByte(15) == 0xFF);\n }\n \n bool CNetAddr::IsValid() const\n@@ -765,7 +770,7 @@ bool CNetAddr::IsValid() const\n     // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n     // so if the first length field is garbled, it reads the second batch\n     // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+    if (memcmp(ip, pchIPv4 + 3, sizeof(pchIPv4) - 3) == 0)\n         return false;\n \n     // unspecified IPv6 address (::/128)\n@@ -777,16 +782,15 @@ bool CNetAddr::IsValid() const\n     if (IsRFC3849())\n         return false;\n \n-    if (IsIPv4())\n-    {\n+    if (IsIPv4()) {\n         // INADDR_NONE\n         uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+        if (memcmp(ip + 12, &ipNone, 4) == 0)\n             return false;\n \n         // 0\n         ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+        if (memcmp(ip + 12, &ipNone, 4) == 0)\n             return false;\n     }\n \n@@ -828,10 +832,14 @@ std::string CNetAddr::ToStringIP() const\n         return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n     else\n         return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+                         GetByte(15) << 8 | GetByte(14),\n+                         GetByte(13) << 8 | GetByte(12),\n+                         GetByte(11) << 8 | GetByte(10),\n+                         GetByte(9) << 8 | GetByte(8),\n+                         GetByte(7) << 8 | GetByte(6),\n+                         GetByte(5) << 8 | GetByte(4),\n+                         GetByte(3) << 8 | GetByte(2),\n+                         GetByte(1) << 8 | GetByte(0));\n }\n \n std::string CNetAddr::ToString() const\n@@ -858,7 +866,7 @@ bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n {\n     if (!IsIPv4())\n         return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n+    memcpy(pipv4Addr, ip + 12, 4);\n     return true;\n }\n \n@@ -878,41 +886,34 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     int nBits = 16;\n \n     // all local addresses belong to the same group\n-    if (IsLocal())\n-    {\n+    if (IsLocal()) {\n         nClass = 255;\n         nBits = 0;\n     }\n \n     // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n-    {\n+    if (!IsRoutable()) {\n         nClass = NET_UNROUTABLE;\n         nBits = 0;\n     }\n     // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n     // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n-    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n-    {\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052()) {\n         nClass = NET_IPV4;\n         nStartByte = 12;\n     }\n     // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n-    else if (IsRFC3964())\n-    {\n+    else if (IsRFC3964()) {\n         nClass = NET_IPV4;\n         nStartByte = 2;\n     }\n     // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n-    else if (IsRFC4380())\n-    {\n+    else if (IsRFC4380()) {\n         vchRet.push_back(NET_IPV4);\n         vchRet.push_back(GetByte(3) ^ 0xFF);\n         vchRet.push_back(GetByte(2) ^ 0xFF);\n         return vchRet;\n-    }\n-    else if (IsTor())\n-    {\n+    } else if (IsTor()) {\n         nClass = NET_TOR;\n         nStartByte = 6;\n         nBits = 4;\n@@ -925,8 +926,7 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nBits = 32;\n \n     vchRet.push_back(nClass);\n-    while (nBits >= 8)\n-    {\n+    while (nBits >= 8) {\n         vchRet.push_back(GetByte(15 - nStartByte));\n         nStartByte++;\n         nBits -= 8;\n@@ -948,8 +948,8 @@ uint64_t CNetAddr::GetHash() const\n // private extensions to enum Network, only returned by GetExtNetwork,\n // and only used in GetReachabilityFrom\n static const int NET_UNKNOWN = NET_MAX + 0;\n-static const int NET_TEREDO  = NET_MAX + 1;\n-int static GetExtNetwork(const CNetAddr *addr)\n+static const int NET_TEREDO = NET_MAX + 1;\n+int static GetExtNetwork(const CNetAddr* addr)\n {\n     if (addr == NULL)\n         return NET_UNKNOWN;\n@@ -959,7 +959,7 @@ int static GetExtNetwork(const CNetAddr *addr)\n }\n \n /** Calculates a metric for how reachable (*this) is from a given partner */\n-int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n+int CNetAddr::GetReachabilityFrom(const CNetAddr* paddrPartner) const\n {\n     enum Reachability {\n         REACH_UNREACHABLE,\n@@ -978,41 +978,59 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n     int theirNet = GetExtNetwork(paddrPartner);\n     bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n \n-    switch(theirNet) {\n+    switch (theirNet) {\n     case NET_IPV4:\n-        switch(ourNet) {\n-        default:       return REACH_DEFAULT;\n-        case NET_IPV4: return REACH_IPV4;\n+        switch (ourNet) {\n+        default:\n+            return REACH_DEFAULT;\n+        case NET_IPV4:\n+            return REACH_IPV4;\n         }\n     case NET_IPV6:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_TEREDO: return REACH_TEREDO;\n-        case NET_IPV4:   return REACH_IPV4;\n-        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n+        switch (ourNet) {\n+        default:\n+            return REACH_DEFAULT;\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+        case NET_IPV4:\n+            return REACH_IPV4;\n+        case NET_IPV6:\n+            return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n         }\n     case NET_TOR:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n-        case NET_TOR:    return REACH_PRIVATE;\n+        switch (ourNet) {\n+        default:\n+            return REACH_DEFAULT;\n+        case NET_IPV4:\n+            return REACH_IPV4; // Tor users can connect to IPv4 as well\n+        case NET_TOR:\n+            return REACH_PRIVATE;\n         }\n     case NET_TEREDO:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n+        switch (ourNet) {\n+        default:\n+            return REACH_DEFAULT;\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+        case NET_IPV6:\n+            return REACH_IPV6_WEAK;\n+        case NET_IPV4:\n+            return REACH_IPV4;\n         }\n     case NET_UNKNOWN:\n     case NET_UNROUTABLE:\n     default:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n+        switch (ourNet) {\n+        default:\n+            return REACH_DEFAULT;\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+        case NET_IPV6:\n+            return REACH_IPV6_WEAK;\n+        case NET_IPV4:\n+            return REACH_IPV4;\n+        case NET_TOR:\n+            return REACH_PRIVATE; // either from Tor, or don't care about our address\n         }\n     }\n }\n@@ -1044,12 +1062,12 @@ CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), po\n     assert(addr.sin_family == AF_INET);\n }\n \n-CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n+CService::CService(const struct sockaddr_in6& addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n {\n-   assert(addr.sin6_family == AF_INET6);\n+    assert(addr.sin6_family == AF_INET6);\n }\n \n-bool CService::SetSockAddr(const struct sockaddr *paddr)\n+bool CService::SetSockAddr(const struct sockaddr* paddr)\n {\n     switch (paddr->sa_family) {\n     case AF_INET:\n@@ -1063,31 +1081,31 @@ bool CService::SetSockAddr(const struct sockaddr *paddr)\n     }\n }\n \n-CService::CService(const char *pszIpPort, bool fAllowLookup)\n+CService::CService(const char* pszIpPort, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n     if (Lookup(pszIpPort, ip, 0, fAllowLookup))\n         *this = ip;\n }\n \n-CService::CService(const char *pszIpPort, int portDefault, bool fAllowLookup)\n+CService::CService(const char* pszIpPort, int portDefault, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n     if (Lookup(pszIpPort, ip, portDefault, fAllowLookup))\n         *this = ip;\n }\n \n-CService::CService(const std::string &strIpPort, bool fAllowLookup)\n+CService::CService(const std::string& strIpPort, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n     if (Lookup(strIpPort.c_str(), ip, 0, fAllowLookup))\n         *this = ip;\n }\n \n-CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n+CService::CService(const std::string& strIpPort, int portDefault, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n@@ -1115,13 +1133,13 @@ bool operator<(const CService& a, const CService& b)\n     return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n }\n \n-bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n+bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t* addrlen) const\n {\n     if (IsIPv4()) {\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n             return false;\n         *addrlen = sizeof(struct sockaddr_in);\n-        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n+        struct sockaddr_in* paddrin = (struct sockaddr_in*)paddr;\n         memset(paddrin, 0, *addrlen);\n         if (!GetInAddr(&paddrin->sin_addr))\n             return false;\n@@ -1133,7 +1151,7 @@ bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n             return false;\n         *addrlen = sizeof(struct sockaddr_in6);\n-        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n+        struct sockaddr_in6* paddrin6 = (struct sockaddr_in6*)paddr;\n         memset(paddrin6, 0, *addrlen);\n         if (!GetIn6Addr(&paddrin6->sin6_addr))\n             return false;\n@@ -1146,12 +1164,12 @@ bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n \n std::vector<unsigned char> CService::GetKey() const\n {\n-     std::vector<unsigned char> vKey;\n-     vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n-     vKey[16] = port / 0x100;\n-     vKey[17] = port & 0x0FF;\n-     return vKey;\n+    std::vector<unsigned char> vKey;\n+    vKey.resize(18);\n+    memcpy(&vKey[0], ip, 16);\n+    vKey[16] = port / 0x100;\n+    vKey[17] = port & 0x0FF;\n+    return vKey;\n }\n \n std::string CService::ToStringPort() const\n@@ -1178,13 +1196,12 @@ void CService::SetPort(unsigned short portIn)\n     port = portIn;\n }\n \n-CSubNet::CSubNet():\n-    valid(false)\n+CSubNet::CSubNet() : valid(false)\n {\n     memset(netmask, 0, sizeof(netmask));\n }\n \n-CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n+CSubNet::CSubNet(const std::string& strSubnet, bool fAllowLookup)\n {\n     size_t slash = strSubnet.find_last_of('/');\n     std::vector<CNetAddr> vIP;\n@@ -1194,59 +1211,50 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n     memset(netmask, 255, sizeof(netmask));\n \n     std::string strAddress = strSubnet.substr(0, slash);\n-    if (LookupHost(strAddress.c_str(), vIP, 1, fAllowLookup))\n-    {\n+    if (LookupHost(strAddress.c_str(), vIP, 1, fAllowLookup)) {\n         network = vIP[0];\n-        if (slash != strSubnet.npos)\n-        {\n+        if (slash != strSubnet.npos) {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n             // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n             int noffset = network.IsIPv4() ? (12 * 8) : 0;\n             if (ParseInt32(strNetmask, &n)) // If valid number, assume /24 symtex\n             {\n-                if(n >= 0 && n <= (128 - noffset)) // Only valid if in range of bits of address\n+                if (n >= 0 && n <= (128 - noffset)) // Only valid if in range of bits of address\n                 {\n                     n += noffset;\n                     // Clear bits [n..127]\n                     for (; n < 128; ++n)\n-                        netmask[n>>3] &= ~(1<<(n&7));\n-                }\n-                else\n-                {\n+                        netmask[n >> 3] &= ~(1 << (n & 7));\n+                } else {\n                     valid = false;\n                 }\n-            }\n-            else // If not a valid number, try full netmask syntax\n+            } else // If not a valid number, try full netmask syntax\n             {\n                 if (LookupHost(strNetmask.c_str(), vIP, 1, false)) // Never allow lookup for netmask\n                 {\n                     // Remember: GetByte returns bytes in reversed order\n                     // Copy only the *last* four bytes in case of IPv4, the rest of the mask should stay 1's as\n                     // we don't want pchIPv4 to be part of the mask.\n                     int asize = network.IsIPv4() ? 4 : 16;\n-                    for(int x=0; x<asize; ++x)\n-                        netmask[15-x] = vIP[0].GetByte(x);\n-                }\n-                else\n-                {\n+                    for (int x = 0; x < asize; ++x)\n+                        netmask[15 - x] = vIP[0].GetByte(x);\n+                } else {\n                     valid = false;\n                 }\n             }\n         }\n-    }\n-    else\n-    {\n+    } else {\n         valid = false;\n     }\n }\n \n-bool CSubNet::Match(const CNetAddr &addr) const\n+bool CSubNet::Match(const CNetAddr& addr) const\n {\n     if (!valid || !addr.IsValid())\n         return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.GetByte(x) & netmask[15-x]) != network.GetByte(x))\n+    for (int x = 0; x < 16; ++x)\n+        if ((addr.GetByte(x) & netmask[15 - x]) != network.GetByte(x))\n             return false;\n     return true;\n }\n@@ -1258,10 +1266,14 @@ std::string CSubNet::ToString() const\n         strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n     else\n         strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n-                         netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n-                         netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n-                         netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+                               netmask[0] << 8 | netmask[1],\n+                               netmask[2] << 8 | netmask[3],\n+                               netmask[4] << 8 | netmask[5],\n+                               netmask[6] << 8 | netmask[7],\n+                               netmask[8] << 8 | netmask[9],\n+                               netmask[10] << 8 | netmask[11],\n+                               netmask[12] << 8 | netmask[13],\n+                               netmask[14] << 8 | netmask[15]);\n     return network.ToString() + \"/\" + strNetmask;\n }\n \n@@ -1277,36 +1289,37 @@ bool operator==(const CSubNet& a, const CSubNet& b)\n \n bool operator!=(const CSubNet& a, const CSubNet& b)\n {\n-    return !(a==b);\n+    return !(a == b);\n }\n \n #ifdef WIN32\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n     buf[0] = 0;\n-    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n-            NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-            buf, sizeof(buf), NULL))\n-    {\n+    if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+                       NULL,\n+                       err,\n+                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+                       buf,\n+                       sizeof(buf),\n+                       NULL)) {\n         return strprintf(\"%s (%d)\", buf, err);\n-    }\n-    else\n-    {\n+    } else {\n         return strprintf(\"Unknown error (%d)\", err);\n     }\n }\n #else\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n-    const char *s = buf;\n+    const char* s = buf;\n     buf[0] = 0;\n-    /* Too bad there are two incompatible implementations of the\n+/* Too bad there are two incompatible implementations of the\n      * thread-safe strerror. */\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n-#else /* POSIX variant always returns message in buffer */\n+#else                    /* POSIX variant always returns message in buffer */\n     if (strerror_r(err, buf, sizeof(buf)))\n         buf[0] = 0;\n #endif"
      },
      {
        "sha": "6f9c10bf0d4e057fa39a2d20b518e5b90c4a4188",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 14,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -11,7 +11,7 @@\n #include \"uint256.h\"\n #include \"util.h\"\n \n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader* pblock)\n {\n     unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();\n \n@@ -20,17 +20,14 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n         return nProofOfWorkLimit;\n \n     // Only change once per interval\n-    if ((pindexLast->nHeight+1) % Params().Interval() != 0)\n-    {\n-        if (Params().AllowMinDifficultyBlocks())\n-        {\n+    if ((pindexLast->nHeight + 1) % Params().Interval() != 0) {\n+        if (Params().AllowMinDifficultyBlocks()) {\n             // Special difficulty rule for testnet:\n             // If the new block's timestamp is more than 2* 10 minutes\n             // then allow mining of a min-difficulty block.\n-            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + Params().TargetSpacing()*2)\n+            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + Params().TargetSpacing() * 2)\n                 return nProofOfWorkLimit;\n-            else\n-            {\n+            else {\n                 // Return the last non-special-min-difficulty-rules-block\n                 const CBlockIndex* pindex = pindexLast;\n                 while (pindex->pprev && pindex->nHeight % Params().Interval() != 0 && pindex->nBits == nProofOfWorkLimit)\n@@ -43,17 +40,17 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n \n     // Go back by what we want to be 14 days worth of blocks\n     const CBlockIndex* pindexFirst = pindexLast;\n-    for (int i = 0; pindexFirst && i < Params().Interval()-1; i++)\n+    for (int i = 0; pindexFirst && i < Params().Interval() - 1; i++)\n         pindexFirst = pindexFirst->pprev;\n     assert(pindexFirst);\n \n     // Limit adjustment step\n     int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n     LogPrintf(\"  nActualTimespan = %d  before bounds\\n\", nActualTimespan);\n-    if (nActualTimespan < Params().TargetTimespan()/4)\n-        nActualTimespan = Params().TargetTimespan()/4;\n-    if (nActualTimespan > Params().TargetTimespan()*4)\n-        nActualTimespan = Params().TargetTimespan()*4;\n+    if (nActualTimespan < Params().TargetTimespan() / 4)\n+        nActualTimespan = Params().TargetTimespan() / 4;\n+    if (nActualTimespan > Params().TargetTimespan() * 4)\n+        nActualTimespan = Params().TargetTimespan() * 4;\n \n     // Retarget\n     uint256 bnNew;\n@@ -82,7 +79,7 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n     uint256 bnTarget;\n \n     if (Params().SkipProofOfWorkCheck())\n-       return true;\n+        return true;\n \n     bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n "
      },
      {
        "sha": "921e0a3b59ee3467ce91438e5350eed6dfe8bfbc",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 20,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -10,16 +10,15 @@\n #include \"utilstrencodings.h\"\n \n #ifndef WIN32\n-# include <arpa/inet.h>\n+#include <arpa/inet.h>\n #endif\n \n static const char* ppszTypeName[] =\n-{\n-    \"ERROR\",\n-    \"tx\",\n-    \"block\",\n-    \"filtered block\"\n-};\n+    {\n+     \"ERROR\",\n+     \"tx\",\n+     \"block\",\n+     \"filtered block\"};\n \n CMessageHeader::CMessageHeader()\n {\n@@ -50,22 +49,18 @@ bool CMessageHeader::IsValid() const\n         return false;\n \n     // Check the command string for errors\n-    for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n-    {\n-        if (*p1 == 0)\n-        {\n+    for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++) {\n+        if (*p1 == 0) {\n             // Must be all zeros after the first zero\n             for (; p1 < pchCommand + COMMAND_SIZE; p1++)\n                 if (*p1 != 0)\n                     return false;\n-        }\n-        else if (*p1 < ' ' || *p1 > 0x7E)\n+        } else if (*p1 < ' ' || *p1 > 0x7E)\n             return false;\n     }\n \n     // Message size\n-    if (nMessageSize > MAX_SIZE)\n-    {\n+    if (nMessageSize > MAX_SIZE) {\n         LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n         return false;\n     }\n@@ -74,7 +69,6 @@ bool CMessageHeader::IsValid() const\n }\n \n \n-\n CAddress::CAddress() : CService()\n {\n     Init();\n@@ -108,10 +102,8 @@ CInv::CInv(int typeIn, const uint256& hashIn)\n CInv::CInv(const std::string& strType, const uint256& hashIn)\n {\n     unsigned int i;\n-    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n-    {\n-        if (strType == ppszTypeName[i])\n-        {\n+    for (i = 1; i < ARRAYLEN(ppszTypeName); i++) {\n+        if (strType == ppszTypeName[i]) {\n             type = i;\n             break;\n         }"
      },
      {
        "sha": "dee54fbb85766c759191eb06da6a8615823ece72",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 18,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,7 +13,8 @@\n #include \"ecwrapper.h\"\n #endif\n \n-bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n+bool CPubKey::Verify(const uint256& hash, const std::vector<unsigned char>& vchSig) const\n+{\n     if (!IsValid())\n         return false;\n #ifdef USE_SECP256K1\n@@ -29,7 +30,8 @@ bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchS\n     return true;\n }\n \n-bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+bool CPubKey::RecoverCompact(const uint256& hash, const std::vector<unsigned char>& vchSig)\n+{\n     if (vchSig.size() != 65)\n         return false;\n     int recid = (vchSig[0] - 27) & 3;\n@@ -50,7 +52,8 @@ bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned cha\n     return true;\n }\n \n-bool CPubKey::IsFullyValid() const {\n+bool CPubKey::IsFullyValid() const\n+{\n     if (!IsValid())\n         return false;\n #ifdef USE_SECP256K1\n@@ -64,7 +67,8 @@ bool CPubKey::IsFullyValid() const {\n     return true;\n }\n \n-bool CPubKey::Decompress() {\n+bool CPubKey::Decompress()\n+{\n     if (!IsValid())\n         return false;\n #ifdef USE_SECP256K1\n@@ -83,13 +87,14 @@ bool CPubKey::Decompress() {\n     return true;\n }\n \n-bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const\n+{\n     assert(IsValid());\n     assert((nChild >> 31) == 0);\n     assert(begin() + 33 == end());\n     unsigned char out[64];\n-    BIP32Hash(cc, nChild, *begin(), begin()+1, out);\n-    memcpy(ccChild, out+32, 32);\n+    BIP32Hash(cc, nChild, *begin(), begin() + 1, out);\n+    memcpy(ccChild, out + 32, 32);\n #ifdef USE_SECP256K1\n     pubkeyChild = *this;\n     bool ret = secp256k1_ecdsa_pubkey_tweak_add((unsigned char*)pubkeyChild.begin(), pubkeyChild.size(), out);\n@@ -104,25 +109,30 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned i\n     return ret;\n }\n \n-void CExtPubKey::Encode(unsigned char code[74]) const {\n+void CExtPubKey::Encode(unsigned char code[74]) const\n+{\n     code[0] = nDepth;\n-    memcpy(code+1, vchFingerprint, 4);\n-    code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n-    code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code + 1, vchFingerprint, 4);\n+    code[5] = (nChild >> 24) & 0xFF;\n+    code[6] = (nChild >> 16) & 0xFF;\n+    code[7] = (nChild >> 8) & 0xFF;\n+    code[8] = (nChild >> 0) & 0xFF;\n+    memcpy(code + 9, vchChainCode, 32);\n     assert(pubkey.size() == 33);\n-    memcpy(code+41, pubkey.begin(), 33);\n+    memcpy(code + 41, pubkey.begin(), 33);\n }\n \n-void CExtPubKey::Decode(const unsigned char code[74]) {\n+void CExtPubKey::Decode(const unsigned char code[74])\n+{\n     nDepth = code[0];\n-    memcpy(vchFingerprint, code+1, 4);\n+    memcpy(vchFingerprint, code + 1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n-    pubkey.Set(code+41, code+74);\n+    memcpy(vchChainCode, code + 9, 32);\n+    pubkey.Set(code + 41, code + 74);\n }\n \n-bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const {\n+bool CExtPubKey::Derive(CExtPubKey& out, unsigned int nChild) const\n+{\n     out.nDepth = nDepth + 1;\n     CKeyID id = pubkey.GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);"
      },
      {
        "sha": "2b06f4d2ad73172465c1dc9ccc28e838aa870ac1",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 24,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -23,16 +23,18 @@ enum RetFormat {\n     RF_JSON,\n };\n \n-static const struct {\n+static const struct\n+{\n     enum RetFormat rf;\n-    const char *name;\n+    const char* name;\n } rf_names[] = {\n-    { RF_BINARY, \"binary\" },            // default, if match not found\n-    { RF_HEX, \"hex\" },\n-    { RF_JSON, \"json\" },\n+      {RF_BINARY, \"binary\"}, // default, if match not found\n+      {RF_HEX, \"hex\"},\n+      {RF_JSON, \"json\"},\n };\n \n-class RestErr {\n+class RestErr\n+{\n public:\n     enum HTTPStatusCode status;\n     string message;\n@@ -67,7 +69,7 @@ static bool ParseHashStr(const string& strReq, uint256& v)\n     return true;\n }\n \n-static bool rest_block(AcceptedConnection *conn,\n+static bool rest_block(AcceptedConnection* conn,\n                        string& strReq,\n                        map<string, string>& mapHeaders,\n                        bool fRun)\n@@ -105,7 +107,8 @@ static bool rest_block(AcceptedConnection *conn,\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";;\n+        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n+        ;\n         conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n         return true;\n     }\n@@ -115,14 +118,14 @@ static bool rest_block(AcceptedConnection *conn,\n         string strJSON = write_string(Value(objBlock), false) + \"\\n\";\n         conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n         return true;\n-     }\n+    }\n     }\n \n     // not reached\n-    return true;     // continue to process further HTTP reqs on this cxn\n+    return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_tx(AcceptedConnection *conn,\n+static bool rest_tx(AcceptedConnection* conn,\n                     string& strReq,\n                     map<string, string>& mapHeaders,\n                     bool fRun)\n@@ -153,7 +156,8 @@ static bool rest_tx(AcceptedConnection *conn,\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";;\n+        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n+        ;\n         conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n         return true;\n     }\n@@ -168,39 +172,39 @@ static bool rest_tx(AcceptedConnection *conn,\n     }\n \n     // not reached\n-    return true;     // continue to process further HTTP reqs on this cxn\n+    return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static const struct {\n-    const char *prefix;\n-    bool (*handler)(AcceptedConnection *conn,\n+static const struct\n+{\n+    const char* prefix;\n+    bool (*handler)(AcceptedConnection* conn,\n                     string& strURI,\n                     map<string, string>& mapHeaders,\n                     bool fRun);\n } uri_prefixes[] = {\n-    { \"/rest/tx/\", rest_tx },\n-    { \"/rest/block/\", rest_block },\n+      {\"/rest/tx/\", rest_tx},\n+      {\"/rest/block/\", rest_block},\n };\n \n-bool HTTPReq_REST(AcceptedConnection *conn,\n+bool HTTPReq_REST(AcceptedConnection* conn,\n                   string& strURI,\n                   map<string, string>& mapHeaders,\n                   bool fRun)\n {\n     try {\n         std::string statusmessage;\n-        if(RPCIsInWarmup(&statusmessage))\n-            throw RESTERR(HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \"+statusmessage);\n-        \n+        if (RPCIsInWarmup(&statusmessage))\n+            throw RESTERR(HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\n+\n         for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++) {\n             unsigned int plen = strlen(uri_prefixes[i].prefix);\n             if (strURI.substr(0, plen) == uri_prefixes[i].prefix) {\n                 string strReq = strURI.substr(plen);\n                 return uri_prefixes[i].handler(conn, strReq, mapHeaders, fRun);\n             }\n         }\n-    }\n-    catch (RestErr& re) {\n+    } catch (RestErr& re) {\n         conn->stream() << HTTPReply(re.status, re.message + \"\\r\\n\", false, false, \"text/plain\") << std::flush;\n         return false;\n     }"
      },
      {
        "sha": "9d713ccab30eff009bb8f2f9bf5e07cd0454a01e",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 90,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -22,8 +22,7 @@ double GetDifficulty(const CBlockIndex* blockindex)\n {\n     // Floating point number that is a multiple of the minimum difficulty,\n     // minimum difficulty = 1.0.\n-    if (blockindex == NULL)\n-    {\n+    if (blockindex == NULL) {\n         if (chainActive.Tip() == NULL)\n             return 1.0;\n         else\n@@ -35,13 +34,11 @@ double GetDifficulty(const CBlockIndex* blockindex)\n     double dDiff =\n         (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n \n-    while (nShift < 29)\n-    {\n+    while (nShift < 29) {\n         dDiff *= 256.0;\n         nShift++;\n     }\n-    while (nShift > 29)\n-    {\n+    while (nShift > 29) {\n         dDiff /= 256.0;\n         nShift--;\n     }\n@@ -64,7 +61,7 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n     result.push_back(Pair(\"version\", block.nVersion));\n     result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n     Array txs;\n-    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n+    BOOST_FOREACH (const CTransaction& tx, block.vtx)\n         txs.push_back(tx.GetHash().GetHex());\n     result.push_back(Pair(\"tx\", txs));\n     result.push_back(Pair(\"time\", block.GetBlockTime()));\n@@ -75,7 +72,7 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n \n     if (blockindex->pprev)\n         result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n-    CBlockIndex *pnext = chainActive.Next(blockindex);\n+    CBlockIndex* pnext = chainActive.Next(blockindex);\n     if (pnext)\n         result.push_back(Pair(\"nextblockhash\", pnext->GetBlockHash().GetHex()));\n     return result;\n@@ -90,10 +87,8 @@ Value getblockcount(const Array& params, bool fHelp)\n             \"\\nReturns the number of blocks in the longest block chain.\\n\"\n             \"\\nResult:\\n\"\n             \"n    (numeric) The current block count\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblockcount\", \"\")\n-            + HelpExampleRpc(\"getblockcount\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getblockcount\", \"\") + HelpExampleRpc(\"getblockcount\", \"\"));\n \n     return chainActive.Height();\n }\n@@ -106,10 +101,8 @@ Value getbestblockhash(const Array& params, bool fHelp)\n             \"\\nReturns the hash of the best (tip) block in the longest block chain.\\n\"\n             \"\\nResult\\n\"\n             \"\\\"hex\\\"      (string) the block hash hex encoded\\n\"\n-            \"\\nExamples\\n\"\n-            + HelpExampleCli(\"getbestblockhash\", \"\")\n-            + HelpExampleRpc(\"getbestblockhash\", \"\")\n-        );\n+            \"\\nExamples\\n\" +\n+            HelpExampleCli(\"getbestblockhash\", \"\") + HelpExampleRpc(\"getbestblockhash\", \"\"));\n \n     return chainActive.Tip()->GetBlockHash().GetHex();\n }\n@@ -122,10 +115,8 @@ Value getdifficulty(const Array& params, bool fHelp)\n             \"\\nReturns the proof-of-work difficulty as a multiple of the minimum difficulty.\\n\"\n             \"\\nResult:\\n\"\n             \"n.nnn       (numeric) the proof-of-work difficulty as a multiple of the minimum difficulty.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getdifficulty\", \"\")\n-            + HelpExampleRpc(\"getdifficulty\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getdifficulty\", \"\") + HelpExampleRpc(\"getdifficulty\", \"\"));\n \n     return GetDifficulty();\n }\n@@ -158,21 +149,17 @@ Value getrawmempool(const Array& params, bool fHelp)\n             \"       ... ]\\n\"\n             \"  }, ...\\n\"\n             \"]\\n\"\n-            \"\\nExamples\\n\"\n-            + HelpExampleCli(\"getrawmempool\", \"true\")\n-            + HelpExampleRpc(\"getrawmempool\", \"true\")\n-        );\n+            \"\\nExamples\\n\" +\n+            HelpExampleCli(\"getrawmempool\", \"true\") + HelpExampleRpc(\"getrawmempool\", \"true\"));\n \n     bool fVerbose = false;\n     if (params.size() > 0)\n         fVerbose = params[0].get_bool();\n \n-    if (fVerbose)\n-    {\n+    if (fVerbose) {\n         LOCK(mempool.cs);\n         Object o;\n-        BOOST_FOREACH(const PAIRTYPE(uint256, CTxMemPoolEntry)& entry, mempool.mapTx)\n-        {\n+        BOOST_FOREACH (const PAIRTYPE(uint256, CTxMemPoolEntry) & entry, mempool.mapTx) {\n             const uint256& hash = entry.first;\n             const CTxMemPoolEntry& e = entry.second;\n             Object info;\n@@ -184,8 +171,7 @@ Value getrawmempool(const Array& params, bool fHelp)\n             info.push_back(Pair(\"currentpriority\", e.GetPriority(chainActive.Height())));\n             const CTransaction& tx = e.GetTx();\n             set<string> setDepends;\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-            {\n+            BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n                 if (mempool.exists(txin.prevout.hash))\n                     setDepends.insert(txin.prevout.hash.ToString());\n             }\n@@ -194,14 +180,12 @@ Value getrawmempool(const Array& params, bool fHelp)\n             o.push_back(Pair(hash.ToString(), info));\n         }\n         return o;\n-    }\n-    else\n-    {\n+    } else {\n         vector<uint256> vtxid;\n         mempool.queryHashes(vtxid);\n \n         Array a;\n-        BOOST_FOREACH(const uint256& hash, vtxid)\n+        BOOST_FOREACH (const uint256& hash, vtxid)\n             a.push_back(hash.ToString());\n \n         return a;\n@@ -218,10 +202,8 @@ Value getblockhash(const Array& params, bool fHelp)\n             \"1. index         (numeric, required) The block index\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"hash\\\"         (string) The block hash\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblockhash\", \"1000\")\n-            + HelpExampleRpc(\"getblockhash\", \"1000\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getblockhash\", \"1000\") + HelpExampleRpc(\"getblockhash\", \"1000\"));\n \n     int nHeight = params[0].get_int();\n     if (nHeight < 0 || nHeight > chainActive.Height())\n@@ -262,10 +244,8 @@ Value getblock(const Array& params, bool fHelp)\n             \"}\\n\"\n             \"\\nResult (for verbose=false):\\n\"\n             \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n-            + HelpExampleRpc(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\") + HelpExampleRpc(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\"));\n \n     std::string strHash = params[0].get_str();\n     uint256 hash(strHash);\n@@ -280,11 +260,10 @@ Value getblock(const Array& params, bool fHelp)\n     CBlock block;\n     CBlockIndex* pblockindex = mapBlockIndex[hash];\n \n-    if(!ReadBlockFromDisk(block, pblockindex))\n+    if (!ReadBlockFromDisk(block, pblockindex))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n \n-    if (!fVerbose)\n-    {\n+    if (!fVerbose) {\n         CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION);\n         ssBlock << block;\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end());\n@@ -311,10 +290,8 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n             \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"gettxoutsetinfo\", \"\")\n-            + HelpExampleRpc(\"gettxoutsetinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"gettxoutsetinfo\", \"\") + HelpExampleRpc(\"gettxoutsetinfo\", \"\"));\n \n     Object ret;\n \n@@ -362,13 +339,10 @@ Value gettxout(const Array& params, bool fHelp)\n             \"}\\n\"\n \n             \"\\nExamples:\\n\"\n-            \"\\nGet unspent transactions\\n\"\n-            + HelpExampleCli(\"listunspent\", \"\") +\n-            \"\\nView the details\\n\"\n-            + HelpExampleCli(\"gettxout\", \"\\\"txid\\\" 1\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"gettxout\", \"\\\"txid\\\", 1\")\n-        );\n+            \"\\nGet unspent transactions\\n\" +\n+            HelpExampleCli(\"listunspent\", \"\") +\n+            \"\\nView the details\\n\" + HelpExampleCli(\"gettxout\", \"\\\"txid\\\" 1\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"gettxout\", \"\\\"txid\\\", 1\"));\n \n     Object ret;\n \n@@ -390,11 +364,11 @@ Value gettxout(const Array& params, bool fHelp)\n         if (!pcoinsTip->GetCoins(hash, coins))\n             return Value::null;\n     }\n-    if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n+    if (n < 0 || (unsigned int)n >= coins.vout.size() || coins.vout[n].IsNull())\n         return Value::null;\n \n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n-    CBlockIndex *pindex = it->second;\n+    CBlockIndex* pindex = it->second;\n     ret.push_back(Pair(\"bestblock\", pindex->GetBlockHash().GetHex()));\n     if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n         ret.push_back(Pair(\"confirmations\", 0));\n@@ -421,10 +395,8 @@ Value verifychain(const Array& params, bool fHelp)\n             \"2. numblocks    (numeric, optional, default=288, 0=all) The number of blocks to check.\\n\"\n             \"\\nResult:\\n\"\n             \"true|false       (boolean) Verified or not\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"verifychain\", \"\")\n-            + HelpExampleRpc(\"verifychain\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"verifychain\", \"\") + HelpExampleRpc(\"verifychain\", \"\"));\n \n     int nCheckLevel = GetArg(\"-checklevel\", 3);\n     int nCheckDepth = GetArg(\"-checkblocks\", 288);\n@@ -452,19 +424,17 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n             \"  \\\"verificationprogress\\\": xxxx, (numeric) estimate of verification progress [0..1]\\n\"\n             \"  \\\"chainwork\\\": \\\"xxxx\\\"     (string) total amount of work in active chain, in hexadecimal\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblockchaininfo\", \"\")\n-            + HelpExampleRpc(\"getblockchaininfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getblockchaininfo\", \"\") + HelpExampleRpc(\"getblockchaininfo\", \"\"));\n \n     Object obj;\n-    obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n-    obj.push_back(Pair(\"blocks\",                (int)chainActive.Height()));\n-    obj.push_back(Pair(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1));\n-    obj.push_back(Pair(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex()));\n-    obj.push_back(Pair(\"difficulty\",            (double)GetDifficulty()));\n-    obj.push_back(Pair(\"verificationprogress\",  Checkpoints::GuessVerificationProgress(chainActive.Tip())));\n-    obj.push_back(Pair(\"chainwork\",             chainActive.Tip()->nChainWork.GetHex()));\n+    obj.push_back(Pair(\"chain\", Params().NetworkIDString()));\n+    obj.push_back(Pair(\"blocks\", (int)chainActive.Height()));\n+    obj.push_back(Pair(\"headers\", pindexBestHeader ? pindexBestHeader->nHeight : -1));\n+    obj.push_back(Pair(\"bestblockhash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+    obj.push_back(Pair(\"difficulty\", (double)GetDifficulty()));\n+    obj.push_back(Pair(\"verificationprogress\", Checkpoints::GuessVerificationProgress(chainActive.Tip())));\n+    obj.push_back(Pair(\"chainwork\", chainActive.Tip()->nChainWork.GetHex()));\n     return obj;\n }\n \n@@ -477,7 +447,7 @@ struct CompareBlocksByHeight\n            equal. Use the pointers themselves to make a distinction. */\n \n         if (a->nHeight != b->nHeight)\n-          return (a->nHeight > b->nHeight);\n+            return (a->nHeight > b->nHeight);\n \n         return a < b;\n     }\n@@ -503,28 +473,24 @@ Value getchaintips(const Array& params, bool fHelp)\n             \"    \\\"branchlen\\\": 1          (numeric) length of branch connecting the tip to the main chain\\n\"\n             \"  }\\n\"\n             \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getchaintips\", \"\")\n-            + HelpExampleRpc(\"getchaintips\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getchaintips\", \"\") + HelpExampleRpc(\"getchaintips\", \"\"));\n \n     /* Build up a list of chain tips.  We start with the list of all\n        known blocks, and successively remove blocks that appear as pprev\n        of another block.  */\n     std::set<const CBlockIndex*, CompareBlocksByHeight> setTips;\n-    BOOST_FOREACH(const PAIRTYPE(const uint256, CBlockIndex*)& item, mapBlockIndex)\n+    BOOST_FOREACH (const PAIRTYPE(const uint256, CBlockIndex*)&item, mapBlockIndex)\n         setTips.insert(item.second);\n-    BOOST_FOREACH(const PAIRTYPE(const uint256, CBlockIndex*)& item, mapBlockIndex)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(const uint256, CBlockIndex*)&item, mapBlockIndex) {\n         const CBlockIndex* pprev = item.second->pprev;\n         if (pprev)\n             setTips.erase(pprev);\n     }\n \n     /* Construct the output array.  */\n     Array res;\n-    BOOST_FOREACH(const CBlockIndex* block, setTips)\n-    {\n+    BOOST_FOREACH (const CBlockIndex* block, setTips) {\n         Object obj;\n         obj.push_back(Pair(\"height\", block->nHeight));\n         obj.push_back(Pair(\"hash\", block->phashBlock->GetHex()));\n@@ -549,15 +515,12 @@ Value getmempoolinfo(const Array& params, bool fHelp)\n             \"  \\\"size\\\": xxxxx                (numeric) Current tx count\\n\"\n             \"  \\\"bytes\\\": xxxxx               (numeric) Sum of all tx sizes\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getmempoolinfo\", \"\")\n-            + HelpExampleRpc(\"getmempoolinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getmempoolinfo\", \"\") + HelpExampleRpc(\"getmempoolinfo\", \"\"));\n \n     Object ret;\n-    ret.push_back(Pair(\"size\", (int64_t) mempool.size()));\n-    ret.push_back(Pair(\"bytes\", (int64_t) mempool.GetTotalTxSize()));\n+    ret.push_back(Pair(\"size\", (int64_t)mempool.size()));\n+    ret.push_back(Pair(\"bytes\", (int64_t)mempool.GetTotalTxSize()));\n \n     return ret;\n }\n-"
      },
      {
        "sha": "0f86aad92ea57284de0950bad2511b1fd4e1fab5",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 71,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -18,76 +18,76 @@ using namespace json_spirit;\n class CRPCConvertParam\n {\n public:\n-    std::string methodName;            //! method whose params want conversion\n-    int paramIdx;                      //! 0-based idx of param to convert\n+    std::string methodName; //! method whose params want conversion\n+    int paramIdx;           //! 0-based idx of param to convert\n };\n \n static const CRPCConvertParam vRPCConvertParams[] =\n-{\n-    { \"stop\", 0 },\n-    { \"setmocktime\", 0 },\n-    { \"getaddednodeinfo\", 0 },\n-    { \"setgenerate\", 0 },\n-    { \"setgenerate\", 1 },\n-    { \"getnetworkhashps\", 0 },\n-    { \"getnetworkhashps\", 1 },\n-    { \"sendtoaddress\", 1 },\n-    { \"settxfee\", 0 },\n-    { \"getreceivedbyaddress\", 1 },\n-    { \"getreceivedbyaccount\", 1 },\n-    { \"listreceivedbyaddress\", 0 },\n-    { \"listreceivedbyaddress\", 1 },\n-    { \"listreceivedbyaddress\", 2 },\n-    { \"listreceivedbyaccount\", 0 },\n-    { \"listreceivedbyaccount\", 1 },\n-    { \"listreceivedbyaccount\", 2 },\n-    { \"getbalance\", 1 },\n-    { \"getbalance\", 2 },\n-    { \"getblockhash\", 0 },\n-    { \"move\", 2 },\n-    { \"move\", 3 },\n-    { \"sendfrom\", 2 },\n-    { \"sendfrom\", 3 },\n-    { \"listtransactions\", 1 },\n-    { \"listtransactions\", 2 },\n-    { \"listtransactions\", 3 },\n-    { \"listaccounts\", 0 },\n-    { \"listaccounts\", 1 },\n-    { \"walletpassphrase\", 1 },\n-    { \"getblocktemplate\", 0 },\n-    { \"listsinceblock\", 1 },\n-    { \"listsinceblock\", 2 },\n-    { \"sendmany\", 1 },\n-    { \"sendmany\", 2 },\n-    { \"addmultisigaddress\", 0 },\n-    { \"addmultisigaddress\", 1 },\n-    { \"createmultisig\", 0 },\n-    { \"createmultisig\", 1 },\n-    { \"listunspent\", 0 },\n-    { \"listunspent\", 1 },\n-    { \"listunspent\", 2 },\n-    { \"getblock\", 1 },\n-    { \"gettransaction\", 1 },\n-    { \"getrawtransaction\", 1 },\n-    { \"createrawtransaction\", 0 },\n-    { \"createrawtransaction\", 1 },\n-    { \"signrawtransaction\", 1 },\n-    { \"signrawtransaction\", 2 },\n-    { \"sendrawtransaction\", 1 },\n-    { \"gettxout\", 1 },\n-    { \"gettxout\", 2 },\n-    { \"lockunspent\", 0 },\n-    { \"lockunspent\", 1 },\n-    { \"importprivkey\", 2 },\n-    { \"importaddress\", 2 },\n-    { \"verifychain\", 0 },\n-    { \"verifychain\", 1 },\n-    { \"keypoolrefill\", 0 },\n-    { \"getrawmempool\", 0 },\n-    { \"estimatefee\", 0 },\n-    { \"estimatepriority\", 0 },\n-    { \"prioritisetransaction\", 1 },\n-    { \"prioritisetransaction\", 2 },\n+    {\n+     {\"stop\", 0},\n+     {\"setmocktime\", 0},\n+     {\"getaddednodeinfo\", 0},\n+     {\"setgenerate\", 0},\n+     {\"setgenerate\", 1},\n+     {\"getnetworkhashps\", 0},\n+     {\"getnetworkhashps\", 1},\n+     {\"sendtoaddress\", 1},\n+     {\"settxfee\", 0},\n+     {\"getreceivedbyaddress\", 1},\n+     {\"getreceivedbyaccount\", 1},\n+     {\"listreceivedbyaddress\", 0},\n+     {\"listreceivedbyaddress\", 1},\n+     {\"listreceivedbyaddress\", 2},\n+     {\"listreceivedbyaccount\", 0},\n+     {\"listreceivedbyaccount\", 1},\n+     {\"listreceivedbyaccount\", 2},\n+     {\"getbalance\", 1},\n+     {\"getbalance\", 2},\n+     {\"getblockhash\", 0},\n+     {\"move\", 2},\n+     {\"move\", 3},\n+     {\"sendfrom\", 2},\n+     {\"sendfrom\", 3},\n+     {\"listtransactions\", 1},\n+     {\"listtransactions\", 2},\n+     {\"listtransactions\", 3},\n+     {\"listaccounts\", 0},\n+     {\"listaccounts\", 1},\n+     {\"walletpassphrase\", 1},\n+     {\"getblocktemplate\", 0},\n+     {\"listsinceblock\", 1},\n+     {\"listsinceblock\", 2},\n+     {\"sendmany\", 1},\n+     {\"sendmany\", 2},\n+     {\"addmultisigaddress\", 0},\n+     {\"addmultisigaddress\", 1},\n+     {\"createmultisig\", 0},\n+     {\"createmultisig\", 1},\n+     {\"listunspent\", 0},\n+     {\"listunspent\", 1},\n+     {\"listunspent\", 2},\n+     {\"getblock\", 1},\n+     {\"gettransaction\", 1},\n+     {\"getrawtransaction\", 1},\n+     {\"createrawtransaction\", 0},\n+     {\"createrawtransaction\", 1},\n+     {\"signrawtransaction\", 1},\n+     {\"signrawtransaction\", 2},\n+     {\"sendrawtransaction\", 1},\n+     {\"gettxout\", 1},\n+     {\"gettxout\", 2},\n+     {\"lockunspent\", 0},\n+     {\"lockunspent\", 1},\n+     {\"importprivkey\", 2},\n+     {\"importaddress\", 2},\n+     {\"verifychain\", 0},\n+     {\"verifychain\", 1},\n+     {\"keypoolrefill\", 0},\n+     {\"getrawmempool\", 0},\n+     {\"estimatefee\", 0},\n+     {\"estimatepriority\", 0},\n+     {\"prioritisetransaction\", 1},\n+     {\"prioritisetransaction\", 2},\n };\n \n class CRPCConvertTable\n@@ -98,7 +98,8 @@ class CRPCConvertTable\n public:\n     CRPCConvertTable();\n \n-    bool convert(const std::string& method, int idx) {\n+    bool convert(const std::string& method, int idx)\n+    {\n         return (members.count(std::make_pair(method, idx)) > 0);\n     }\n };\n@@ -117,7 +118,7 @@ CRPCConvertTable::CRPCConvertTable()\n static CRPCConvertTable rpcCvtTable;\n \n /** Convert strings to command-specific RPC representation */\n-Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n+Array RPCConvertValues(const std::string& strMethod, const std::vector<std::string>& strParams)\n {\n     Array params;\n \n@@ -133,11 +134,10 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n         else {\n             Value jVal;\n             if (!read_string(strVal, jVal))\n-                throw runtime_error(string(\"Error parsing JSON:\")+strVal);\n+                throw runtime_error(string(\"Error parsing JSON:\") + strVal);\n             params.push_back(jVal);\n         }\n     }\n \n     return params;\n }\n-"
      },
      {
        "sha": "d7a32a2deb912c4e995c1c4c8d416a8d29677a4d",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 47,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -26,14 +26,16 @@ using namespace std;\n \n void EnsureWalletIsUnlocked();\n \n-std::string static EncodeDumpTime(int64_t nTime) {\n+std::string static EncodeDumpTime(int64_t nTime)\n+{\n     return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n }\n \n-int64_t static DecodeDumpTime(const std::string &str) {\n+int64_t static DecodeDumpTime(const std::string& str)\n+{\n     static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);\n     static const std::locale loc(std::locale::classic(),\n-        new boost::posix_time::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\"));\n+                                 new boost::posix_time::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\"));\n     std::istringstream iss(str);\n     iss.imbue(loc);\n     boost::posix_time::ptime ptime(boost::date_time::not_a_date_time);\n@@ -43,9 +45,10 @@ int64_t static DecodeDumpTime(const std::string &str) {\n     return (ptime - epoch).total_seconds();\n }\n \n-std::string static EncodeDumpString(const std::string &str) {\n+std::string static EncodeDumpString(const std::string& str)\n+{\n     std::stringstream ret;\n-    BOOST_FOREACH(unsigned char c, str) {\n+    BOOST_FOREACH (unsigned char c, str) {\n         if (c <= 32 || c >= 128 || c == '%') {\n             ret << '%' << HexStr(&c, &c + 1);\n         } else {\n@@ -55,13 +58,14 @@ std::string static EncodeDumpString(const std::string &str) {\n     return ret.str();\n }\n \n-std::string DecodeDumpString(const std::string &str) {\n+std::string DecodeDumpString(const std::string& str)\n+{\n     std::stringstream ret;\n     for (unsigned int pos = 0; pos < str.length(); pos++) {\n         unsigned char c = str[pos];\n-        if (c == '%' && pos+2 < str.length()) {\n-            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n-                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n+        if (c == '%' && pos + 2 < str.length()) {\n+            c = (((str[pos + 1] >> 6) * 9 + ((str[pos + 1] - '0') & 15)) << 4) |\n+                ((str[pos + 2] >> 6) * 9 + ((str[pos + 2] - '0') & 15));\n             pos += 2;\n         }\n         ret << c;\n@@ -81,15 +85,11 @@ Value importprivkey(const Array& params, bool fHelp)\n             \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n             \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nDump a private key\\n\"\n-            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") +\n-            \"\\nImport the private key with rescan\\n\"\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n-            \"\\nImport using a label and without rescan\\n\"\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\")\n-        );\n+            \"\\nDump a private key\\n\" +\n+            HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") +\n+            \"\\nImport the private key with rescan\\n\" + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n+            \"\\nImport using a label and without rescan\\n\" + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\" + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\"));\n \n     EnsureWalletIsUnlocked();\n \n@@ -106,10 +106,12 @@ Value importprivkey(const Array& params, bool fHelp)\n     CBitcoinSecret vchSecret;\n     bool fGood = vchSecret.SetString(strSecret);\n \n-    if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+    if (!fGood)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n \n     CKey key = vchSecret.GetKey();\n-    if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+    if (!key.IsValid())\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n \n     CPubKey pubkey = key.GetPubKey();\n     assert(key.VerifyPubKey(pubkey));\n@@ -150,13 +152,10 @@ Value importaddress(const Array& params, bool fHelp)\n             \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n             \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nImport an address with rescan\\n\"\n-            + HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\"\") +\n-            \"\\nImport using a label without rescan\\n\"\n-            + HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\" \\\"testing\\\" false\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"importaddress\", \"\\\"myaddress\\\", \\\"testing\\\", false\")\n-        );\n+            \"\\nImport an address with rescan\\n\" +\n+            HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\"\") +\n+            \"\\nImport using a label without rescan\\n\" + HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\" + HelpExampleRpc(\"importaddress\", \"\\\"myaddress\\\", \\\"testing\\\", false\"));\n \n     CScript script;\n \n@@ -196,8 +195,7 @@ Value importaddress(const Array& params, bool fHelp)\n         if (!pwalletMain->AddWatchOnly(script))\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n \n-        if (fRescan)\n-        {\n+        if (fRescan) {\n             pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n             pwalletMain->ReacceptWalletTransactions();\n         }\n@@ -215,13 +213,10 @@ Value importwallet(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"filename\\\"    (string, required) The wallet file\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nDump the wallet\\n\"\n-            + HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\") +\n-            \"\\nImport the wallet\\n\"\n-            + HelpExampleCli(\"importwallet\", \"\\\"test\\\"\") +\n-            \"\\nImport using the json rpc call\\n\"\n-            + HelpExampleRpc(\"importwallet\", \"\\\"test\\\"\")\n-        );\n+            \"\\nDump the wallet\\n\" +\n+            HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\") +\n+            \"\\nImport the wallet\\n\" + HelpExampleCli(\"importwallet\", \"\\\"test\\\"\") +\n+            \"\\nImport using the json rpc call\\n\" + HelpExampleRpc(\"importwallet\", \"\\\"test\\\"\"));\n \n     EnsureWalletIsUnlocked();\n \n@@ -288,7 +283,7 @@ Value importwallet(const Array& params, bool fHelp)\n     file.close();\n     pwalletMain->ShowProgress(\"\", 100); // hide progress dialog in GUI\n \n-    CBlockIndex *pindex = chainActive.Tip();\n+    CBlockIndex* pindex = chainActive.Tip();\n     while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n@@ -316,11 +311,8 @@ Value dumpprivkey(const Array& params, bool fHelp)\n             \"1. \\\"bitcoinaddress\\\"   (string, required) The bitcoin address for the private key\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"key\\\"                (string) The private key\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\")\n-            + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\"));\n \n     EnsureWalletIsUnlocked();\n \n@@ -346,10 +338,8 @@ Value dumpwallet(const Array& params, bool fHelp)\n             \"\\nDumps all wallet keys in a human-readable format.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"filename\\\"    (string, required) The filename\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\")\n-            + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\") + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\"));\n \n     EnsureWalletIsUnlocked();\n \n@@ -378,7 +368,7 @@ Value dumpwallet(const Array& params, bool fHelp)\n     file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->GetBlockTime()));\n     file << \"\\n\";\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n-        const CKeyID &keyid = it->second;\n+        const CKeyID& keyid = it->second;\n         std::string strTime = EncodeDumpTime(it->first);\n         std::string strAddr = CBitcoinAddress(keyid).ToString();\n         CKey key;"
      },
      {
        "sha": "07a58a57cfdff5541cfcaa26c5a8392d2832d54b",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 113,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -33,8 +33,9 @@ using namespace std;\n  * or from the last difficulty change if 'lookup' is nonpositive.\n  * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n  */\n-Value GetNetworkHashPS(int lookup, int height) {\n-    CBlockIndex *pb = chainActive.Tip();\n+Value GetNetworkHashPS(int lookup, int height)\n+{\n+    CBlockIndex* pb = chainActive.Tip();\n \n     if (height >= 0 && height < chainActive.Height())\n         pb = chainActive[height];\n@@ -50,7 +51,7 @@ Value GetNetworkHashPS(int lookup, int height) {\n     if (lookup > pb->nHeight)\n         lookup = pb->nHeight;\n \n-    CBlockIndex *pb0 = pb;\n+    CBlockIndex* pb0 = pb;\n     int64_t minTime = pb0->GetBlockTime();\n     int64_t maxTime = minTime;\n     for (int i = 0; i < lookup; i++) {\n@@ -83,10 +84,8 @@ Value getnetworkhashps(const Array& params, bool fHelp)\n             \"2. height     (numeric, optional, default=-1) To estimate at the time of the given height.\\n\"\n             \"\\nResult:\\n\"\n             \"x             (numeric) Hashes per second estimated\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getnetworkhashps\", \"\")\n-            + HelpExampleRpc(\"getnetworkhashps\", \"\")\n-       );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getnetworkhashps\", \"\") + HelpExampleRpc(\"getnetworkhashps\", \"\"));\n \n     return GetNetworkHashPS(params.size() > 0 ? params[0].get_int() : 120, params.size() > 1 ? params[1].get_int() : -1);\n }\n@@ -102,10 +101,8 @@ Value getgenerate(const Array& params, bool fHelp)\n             \"It can also be set with the setgenerate call.\\n\"\n             \"\\nResult\\n\"\n             \"true|false      (boolean) If the server is set to generate coins or not\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getgenerate\", \"\")\n-            + HelpExampleRpc(\"getgenerate\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getgenerate\", \"\") + HelpExampleRpc(\"getgenerate\", \"\"));\n \n     return GetBoolArg(\"-gen\", false);\n }\n@@ -126,15 +123,11 @@ Value setgenerate(const Array& params, bool fHelp)\n             \"\\nResult\\n\"\n             \"[ blockhashes ]     (array, -regtest only) hashes of blocks generated\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nSet the generation on with a limit of one processor\\n\"\n-            + HelpExampleCli(\"setgenerate\", \"true 1\") +\n-            \"\\nCheck the setting\\n\"\n-            + HelpExampleCli(\"getgenerate\", \"\") +\n-            \"\\nTurn off generation\\n\"\n-            + HelpExampleCli(\"setgenerate\", \"false\") +\n-            \"\\nUsing json rpc\\n\"\n-            + HelpExampleRpc(\"setgenerate\", \"true, 1\")\n-        );\n+            \"\\nSet the generation on with a limit of one processor\\n\" +\n+            HelpExampleCli(\"setgenerate\", \"true 1\") +\n+            \"\\nCheck the setting\\n\" + HelpExampleCli(\"getgenerate\", \"\") +\n+            \"\\nTurn off generation\\n\" + HelpExampleCli(\"setgenerate\", \"false\") +\n+            \"\\nUsing json rpc\\n\" + HelpExampleRpc(\"setgenerate\", \"true, 1\"));\n \n     if (pwalletMain == NULL)\n         throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found (disabled)\");\n@@ -144,36 +137,33 @@ Value setgenerate(const Array& params, bool fHelp)\n         fGenerate = params[0].get_bool();\n \n     int nGenProcLimit = -1;\n-    if (params.size() > 1)\n-    {\n+    if (params.size() > 1) {\n         nGenProcLimit = params[1].get_int();\n         if (nGenProcLimit == 0)\n             fGenerate = false;\n     }\n \n     // -regtest mode: don't return until nGenProcLimit blocks are generated\n-    if (fGenerate && Params().MineBlocksOnDemand())\n-    {\n+    if (fGenerate && Params().MineBlocksOnDemand()) {\n         int nHeightStart = 0;\n         int nHeightEnd = 0;\n         int nHeight = 0;\n         int nGenerate = (nGenProcLimit > 0 ? nGenProcLimit : 1);\n         CReserveKey reservekey(pwalletMain);\n \n-        {   // Don't keep cs_main locked\n+        { // Don't keep cs_main locked\n             LOCK(cs_main);\n             nHeightStart = chainActive.Height();\n             nHeight = nHeightStart;\n-            nHeightEnd = nHeightStart+nGenerate;\n+            nHeightEnd = nHeightStart + nGenerate;\n         }\n         unsigned int nExtraNonce = 0;\n         Array blockHashes;\n-        while (nHeight < nHeightEnd)\n-        {\n+        while (nHeight < nHeightEnd) {\n             auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n             if (!pblocktemplate.get())\n                 throw JSONRPCError(RPC_INTERNAL_ERROR, \"Wallet keypool empty\");\n-            CBlock *pblock = &pblocktemplate->block;\n+            CBlock* pblock = &pblocktemplate->block;\n             {\n                 LOCK(cs_main);\n                 IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n@@ -190,11 +180,10 @@ Value setgenerate(const Array& params, bool fHelp)\n             blockHashes.push_back(pblock->GetHash().GetHex());\n         }\n         return blockHashes;\n-    }\n-    else // Not -regtest: start generate thread, return immediately\n+    } else // Not -regtest: start generate thread, return immediately\n     {\n         mapArgs[\"-gen\"] = (fGenerate ? \"1\" : \"0\");\n-        mapArgs [\"-genproclimit\"] = itostr(nGenProcLimit);\n+        mapArgs[\"-genproclimit\"] = itostr(nGenProcLimit);\n         GenerateBitcoins(fGenerate, pwalletMain, nGenProcLimit);\n     }\n \n@@ -210,10 +199,8 @@ Value gethashespersec(const Array& params, bool fHelp)\n             \"See the getgenerate and setgenerate calls to turn generation on and off.\\n\"\n             \"\\nResult:\\n\"\n             \"n            (numeric) The recent hashes per second when generation is on (will return 0 if generation is off)\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"gethashespersec\", \"\")\n-            + HelpExampleRpc(\"gethashespersec\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"gethashespersec\", \"\") + HelpExampleRpc(\"gethashespersec\", \"\"));\n \n     if (GetTimeMillis() - nHPSTimerStart > 8000)\n         return (int64_t)0;\n@@ -242,25 +229,23 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"  \\\"testnet\\\": true|false      (boolean) If using testnet or not\\n\"\n             \"  \\\"chain\\\": \\\"xxxx\\\",         (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getmininginfo\", \"\")\n-            + HelpExampleRpc(\"getmininginfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getmininginfo\", \"\") + HelpExampleRpc(\"getmininginfo\", \"\"));\n \n     Object obj;\n-    obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n+    obj.push_back(Pair(\"blocks\", (int)chainActive.Height()));\n     obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n-    obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n-    obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n-    obj.push_back(Pair(\"errors\",           GetWarnings(\"statusbar\")));\n-    obj.push_back(Pair(\"genproclimit\",     (int)GetArg(\"-genproclimit\", -1)));\n-    obj.push_back(Pair(\"networkhashps\",    getnetworkhashps(params, false)));\n-    obj.push_back(Pair(\"pooledtx\",         (uint64_t)mempool.size()));\n-    obj.push_back(Pair(\"testnet\",          Params().TestnetToBeDeprecatedFieldRPC()));\n-    obj.push_back(Pair(\"chain\",            Params().NetworkIDString()));\n+    obj.push_back(Pair(\"currentblocktx\", (uint64_t)nLastBlockTx));\n+    obj.push_back(Pair(\"difficulty\", (double)GetDifficulty()));\n+    obj.push_back(Pair(\"errors\", GetWarnings(\"statusbar\")));\n+    obj.push_back(Pair(\"genproclimit\", (int)GetArg(\"-genproclimit\", -1)));\n+    obj.push_back(Pair(\"networkhashps\", getnetworkhashps(params, false)));\n+    obj.push_back(Pair(\"pooledtx\", (uint64_t)mempool.size()));\n+    obj.push_back(Pair(\"testnet\", Params().TestnetToBeDeprecatedFieldRPC()));\n+    obj.push_back(Pair(\"chain\", Params().NetworkIDString()));\n #ifdef ENABLE_WALLET\n-    obj.push_back(Pair(\"generate\",         getgenerate(params, false)));\n-    obj.push_back(Pair(\"hashespersec\",     gethashespersec(params, false)));\n+    obj.push_back(Pair(\"generate\", getgenerate(params, false)));\n+    obj.push_back(Pair(\"hashespersec\", gethashespersec(params, false)));\n #endif\n     return obj;\n }\n@@ -282,10 +267,8 @@ Value prioritisetransaction(const Array& params, bool fHelp)\n             \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n             \"\\nResult\\n\"\n             \"true              (boolean) Returns true\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 0.0 0.00010000\")\n-            + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 0.0, 0.00010000\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 0.0 0.00010000\") + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 0.0, 0.00010000\"));\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n@@ -308,8 +291,7 @@ static Value BIP22ValidationResult(const CValidationState& state)\n     std::string strRejectReason = state.GetRejectReason();\n     if (state.IsError())\n         throw JSONRPCError(RPC_VERIFY_ERROR, strRejectReason);\n-    if (state.IsInvalid())\n-    {\n+    if (state.IsInvalid()) {\n         if (strRejectReason.empty())\n             return \"rejected\";\n         return strRejectReason;\n@@ -375,29 +357,23 @@ Value getblocktemplate(const Array& params, bool fHelp)\n             \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\n             \"}\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblocktemplate\", \"\")\n-            + HelpExampleRpc(\"getblocktemplate\", \"\")\n-         );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getblocktemplate\", \"\") + HelpExampleRpc(\"getblocktemplate\", \"\"));\n \n     std::string strMode = \"template\";\n     Value lpval = Value::null;\n-    if (params.size() > 0)\n-    {\n+    if (params.size() > 0) {\n         const Object& oparam = params[0].get_obj();\n         const Value& modeval = find_value(oparam, \"mode\");\n         if (modeval.type() == str_type)\n             strMode = modeval.get_str();\n-        else if (modeval.type() == null_type)\n-        {\n+        else if (modeval.type() == null_type) {\n             /* Do nothing */\n-        }\n-        else\n+        } else\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n         lpval = find_value(oparam, \"longpollid\");\n \n-        if (strMode == \"proposal\")\n-        {\n+        if (strMode == \"proposal\") {\n             const Value& dataval = find_value(oparam, \"data\");\n             if (dataval.type() != str_type)\n                 throw JSONRPCError(RPC_TYPE_ERROR, \"Missing data String key for proposal\");\n@@ -409,7 +385,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n             uint256 hash = block.GetHash();\n             BlockMap::iterator mi = mapBlockIndex.find(hash);\n             if (mi != mapBlockIndex.end()) {\n-                CBlockIndex *pindex = mi->second;\n+                CBlockIndex* pindex = mi->second;\n                 if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n                     return \"duplicate\";\n                 if (pindex->nStatus & BLOCK_FAILED_MASK)\n@@ -438,42 +414,36 @@ Value getblocktemplate(const Array& params, bool fHelp)\n \n     static unsigned int nTransactionsUpdatedLast;\n \n-    if (lpval.type() != null_type)\n-    {\n+    if (lpval.type() != null_type) {\n         // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions\n         uint256 hashWatchedChain;\n         boost::system_time checktxtime;\n         unsigned int nTransactionsUpdatedLastLP;\n \n-        if (lpval.type() == str_type)\n-        {\n+        if (lpval.type() == str_type) {\n             // Format: <hashBestChain><nTransactionsUpdatedLast>\n             std::string lpstr = lpval.get_str();\n \n             hashWatchedChain.SetHex(lpstr.substr(0, 64));\n             nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));\n-        }\n-        else\n-        {\n+        } else {\n             // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\n             hashWatchedChain = chainActive.Tip()->GetBlockHash();\n             nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\n         }\n \n-        // Release the wallet and main lock while waiting\n+// Release the wallet and main lock while waiting\n #ifdef ENABLE_WALLET\n-        if(pwalletMain)\n+        if (pwalletMain)\n             LEAVE_CRITICAL_SECTION(pwalletMain->cs_wallet);\n #endif\n         LEAVE_CRITICAL_SECTION(cs_main);\n         {\n             checktxtime = boost::get_system_time() + boost::posix_time::minutes(1);\n \n             boost::unique_lock<boost::mutex> lock(csBestBlock);\n-            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())\n-            {\n-                if (!cvBlockChange.timed_wait(lock, checktxtime))\n-                {\n+            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning()) {\n+                if (!cvBlockChange.timed_wait(lock, checktxtime)) {\n                     // Timeout: Check transactions for update\n                     if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)\n                         break;\n@@ -483,7 +453,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n         }\n         ENTER_CRITICAL_SECTION(cs_main);\n #ifdef ENABLE_WALLET\n-        if(pwalletMain)\n+        if (pwalletMain)\n             ENTER_CRITICAL_SECTION(pwalletMain->cs_wallet);\n #endif\n \n@@ -497,8 +467,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     static int64_t nStart;\n     static CBlockTemplate* pblocktemplate;\n     if (pindexPrev != chainActive.Tip() ||\n-        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n-    {\n+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5)) {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = NULL;\n \n@@ -508,8 +477,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n         nStart = GetTime();\n \n         // Create new block\n-        if(pblocktemplate)\n-        {\n+        if (pblocktemplate) {\n             delete pblocktemplate;\n             pblocktemplate = NULL;\n         }\n@@ -532,8 +500,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     Array transactions;\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (CTransaction& tx, pblock->vtx)\n-    {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {\n         uint256 txHash = tx.GetHash();\n         setTxIndex[txHash] = i++;\n \n@@ -547,8 +514,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n         entry.push_back(Pair(\"hash\", txHash.GetHex()));\n \n         Array deps;\n-        BOOST_FOREACH (const CTxIn &in, tx.vin)\n-        {\n+        BOOST_FOREACH (const CTxIn& in, tx.vin) {\n             if (setTxIndex.count(in.prevout.hash))\n                 deps.push_back(setTxIndex[in.prevout.hash]);\n         }\n@@ -567,8 +533,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n \n     static Array aMutable;\n-    if (aMutable.empty())\n-    {\n+    if (aMutable.empty()) {\n         aMutable.push_back(\"time\");\n         aMutable.push_back(\"transactions\");\n         aMutable.push_back(\"prevblock\");\n@@ -583,14 +548,14 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     result.push_back(Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0].vout[0].nValue));\n     result.push_back(Pair(\"longpollid\", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));\n     result.push_back(Pair(\"target\", hashTarget.GetHex()));\n-    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n+    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast() + 1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n     result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n     result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n-    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n+    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight + 1)));\n \n     return result;\n }\n@@ -602,10 +567,11 @@ class submitblock_StateCatcher : public CValidationInterface\n     bool found;\n     CValidationState state;\n \n-    submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {};\n+    submitblock_StateCatcher(const uint256& hashIn) : hash(hashIn), found(false), state(){};\n \n protected:\n-    virtual void BlockChecked(const CBlock& block, const CValidationState& stateIn) {\n+    virtual void BlockChecked(const CBlock& block, const CValidationState& stateIn)\n+    {\n         if (block.GetHash() != hash)\n             return;\n         found = true;\n@@ -629,10 +595,8 @@ Value submitblock(const Array& params, bool fHelp)\n             \"      \\\"workid\\\" : \\\"id\\\"    (string, optional) if the server provided a workid, it MUST be included with submissions\\n\"\n             \"    }\\n\"\n             \"\\nResult:\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n-            + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\") + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\"));\n \n     CBlock block;\n     if (!DecodeHexBlk(block, params[0].get_str()))\n@@ -641,7 +605,7 @@ Value submitblock(const Array& params, bool fHelp)\n     uint256 hash = block.GetHash();\n     BlockMap::iterator mi = mapBlockIndex.find(hash);\n     if (mi != mapBlockIndex.end()) {\n-        CBlockIndex *pindex = mi->second;\n+        CBlockIndex* pindex = mi->second;\n         if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n             return \"duplicate\";\n         if (pindex->nStatus & BLOCK_FAILED_MASK)\n@@ -654,14 +618,12 @@ Value submitblock(const Array& params, bool fHelp)\n     RegisterValidationInterface(&sc);\n     bool fAccepted = ProcessNewBlock(state, NULL, &block);\n     UnregisterValidationInterface(&sc);\n-    if (mi != mapBlockIndex.end())\n-    {\n+    if (mi != mapBlockIndex.end()) {\n         if (fAccepted && !sc.found)\n             return \"duplicate-inconclusive\";\n         return \"duplicate\";\n     }\n-    if (fAccepted)\n-    {\n+    if (fAccepted) {\n         if (!sc.found)\n             return \"inconclusive\";\n         state = sc.state;\n@@ -684,9 +646,8 @@ Value estimatefee(const Array& params, bool fHelp)\n             \"\\n\"\n             \"-1.0 is returned if not enough transactions and\\n\"\n             \"blocks have been observed to make an estimate.\\n\"\n-            \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimatefee\", \"6\")\n-            );\n+            \"\\nExample:\\n\" +\n+            HelpExampleCli(\"estimatefee\", \"6\"));\n \n     RPCTypeCheck(params, boost::assign::list_of(int_type));\n \n@@ -716,9 +677,8 @@ Value estimatepriority(const Array& params, bool fHelp)\n             \"\\n\"\n             \"-1.0 is returned if not enough transactions and\\n\"\n             \"blocks have been observed to make an estimate.\\n\"\n-            \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimatepriority\", \"6\")\n-            );\n+            \"\\nExample:\\n\" +\n+            HelpExampleCli(\"estimatepriority\", \"6\"));\n \n     RPCTypeCheck(params, boost::assign::list_of(int_type));\n "
      },
      {
        "sha": "cf62bf66e293309aaa8e4ccbf8521b967123f9cd",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 82,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -66,10 +66,8 @@ Value getinfo(const Array& params, bool fHelp)\n             \"  \\\"relayfee\\\": x.xxxx,         (numeric) minimum relay fee for non-free transactions in btc/kb\\n\"\n             \"  \\\"errors\\\": \\\"...\\\"           (string) any error messages\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getinfo\", \"\")\n-            + HelpExampleRpc(\"getinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getinfo\", \"\") + HelpExampleRpc(\"getinfo\", \"\"));\n \n     proxyType proxy;\n     GetProxy(NET_IPV4, proxy);\n@@ -80,26 +78,26 @@ Value getinfo(const Array& params, bool fHelp)\n #ifdef ENABLE_WALLET\n     if (pwalletMain) {\n         obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-        obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n+        obj.push_back(Pair(\"balance\", ValueFromAmount(pwalletMain->GetBalance())));\n     }\n #endif\n-    obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n-    obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n-    obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.ToStringIPPort() : string())));\n-    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n-    obj.push_back(Pair(\"testnet\",       Params().TestnetToBeDeprecatedFieldRPC()));\n+    obj.push_back(Pair(\"blocks\", (int)chainActive.Height()));\n+    obj.push_back(Pair(\"timeoffset\", GetTimeOffset()));\n+    obj.push_back(Pair(\"connections\", (int)vNodes.size()));\n+    obj.push_back(Pair(\"proxy\", (proxy.IsValid() ? proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"difficulty\", (double)GetDifficulty()));\n+    obj.push_back(Pair(\"testnet\", Params().TestnetToBeDeprecatedFieldRPC()));\n #ifdef ENABLE_WALLET\n     if (pwalletMain) {\n         obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n-        obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n+        obj.push_back(Pair(\"keypoolsize\", (int)pwalletMain->GetKeyPoolSize()));\n     }\n     if (pwalletMain && pwalletMain->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n-    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n+    obj.push_back(Pair(\"paytxfee\", ValueFromAmount(payTxFee.GetFeePerK())));\n #endif\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n-    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n+    obj.push_back(Pair(\"relayfee\", ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n+    obj.push_back(Pair(\"errors\", GetWarnings(\"statusbar\")));\n     return obj;\n }\n \n@@ -112,9 +110,10 @@ class DescribeAddressVisitor : public boost::static_visitor<Object>\n public:\n     DescribeAddressVisitor(isminetype mineIn) : mine(mineIn) {}\n \n-    Object operator()(const CNoDestination &dest) const { return Object(); }\n+    Object operator()(const CNoDestination& dest) const { return Object(); }\n \n-    Object operator()(const CKeyID &keyID) const {\n+    Object operator()(const CKeyID& keyID) const\n+    {\n         Object obj;\n         CPubKey vchPubKey;\n         obj.push_back(Pair(\"isscript\", false));\n@@ -126,7 +125,8 @@ class DescribeAddressVisitor : public boost::static_visitor<Object>\n         return obj;\n     }\n \n-    Object operator()(const CScriptID &scriptID) const {\n+    Object operator()(const CScriptID& scriptID) const\n+    {\n         Object obj;\n         obj.push_back(Pair(\"isscript\", true));\n         if (mine != ISMINE_NO) {\n@@ -139,7 +139,7 @@ class DescribeAddressVisitor : public boost::static_visitor<Object>\n             obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n             obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n             Array a;\n-            BOOST_FOREACH(const CTxDestination& addr, addresses)\n+            BOOST_FOREACH (const CTxDestination& addr, addresses)\n                 a.push_back(CBitcoinAddress(addr).ToString());\n             obj.push_back(Pair(\"addresses\", a));\n             if (whichType == TX_MULTISIG)\n@@ -168,26 +168,23 @@ Value validateaddress(const Array& params, bool fHelp)\n             \"  \\\"iscompressed\\\" : true|false,    (boolean) If the address is compressed\\n\"\n             \"  \\\"account\\\" : \\\"account\\\"         (string) The account associated with the address, \\\"\\\" is the default account\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n-            + HelpExampleRpc(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\") + HelpExampleRpc(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\"));\n \n     CBitcoinAddress address(params[0].get_str());\n     bool isValid = address.IsValid();\n \n     Object ret;\n     ret.push_back(Pair(\"isvalid\", isValid));\n-    if (isValid)\n-    {\n+    if (isValid) {\n         CTxDestination dest = address.Get();\n         string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n #ifdef ENABLE_WALLET\n         isminetype mine = pwalletMain ? IsMine(*pwalletMain, dest) : ISMINE_NO;\n         ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n         if (mine != ISMINE_NO) {\n-            ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n+            ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true : false));\n             Object detail = boost::apply_visitor(DescribeAddressVisitor(mine), dest);\n             ret.insert(ret.end(), detail.begin(), detail.end());\n         }\n@@ -212,82 +209,76 @@ CScript _createmultisig_redeemScript(const Array& params)\n     if ((int)keys.size() < nRequired)\n         throw runtime_error(\n             strprintf(\"not enough keys supplied \"\n-                      \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n+                      \"(got %u keys, but need at least %d to redeem)\",\n+                      keys.size(),\n+                      nRequired));\n     std::vector<CPubKey> pubkeys;\n     pubkeys.resize(keys.size());\n-    for (unsigned int i = 0; i < keys.size(); i++)\n-    {\n+    for (unsigned int i = 0; i < keys.size(); i++) {\n         const std::string& ks = keys[i].get_str();\n #ifdef ENABLE_WALLET\n         // Case 1: Bitcoin address and we have full public key:\n         CBitcoinAddress address(ks);\n-        if (pwalletMain && address.IsValid())\n-        {\n+        if (pwalletMain && address.IsValid()) {\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n                 throw runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks));\n+                    strprintf(\"%s does not refer to a key\", ks));\n             CPubKey vchPubKey;\n             if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n                 throw runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks));\n+                    strprintf(\"no full public key for address %s\", ks));\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw runtime_error(\" Invalid public key: \" + ks);\n             pubkeys[i] = vchPubKey;\n         }\n \n         // Case 2: hex public key\n         else\n #endif\n-        if (IsHex(ks))\n-        {\n+            if (IsHex(ks)) {\n             CPubKey vchPubKey(ParseHex(ks));\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw runtime_error(\" Invalid public key: \" + ks);\n             pubkeys[i] = vchPubKey;\n-        }\n-        else\n-        {\n-            throw runtime_error(\" Invalid public key: \"+ks);\n+        } else {\n+            throw runtime_error(\" Invalid public key: \" + ks);\n         }\n     }\n     CScript result = GetScriptForMultisig(nRequired, pubkeys);\n \n     if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n         throw runtime_error(\n-                strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n+            strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n \n     return result;\n }\n \n Value createmultisig(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 2 || params.size() > 2)\n-    {\n+    if (fHelp || params.size() < 2 || params.size() > 2) {\n         string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n-            \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n-            \"It returns a json object with the address and redeemScript.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keys\\\"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys\\n\"\n-            \"     [\\n\"\n-            \"       \\\"key\\\"    (string) bitcoin address or hex-encoded public key\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new multisig address.\\n\"\n-            \"  \\\"redeemScript\\\":\\\"script\\\"       (string) The string value of the hex-encoded redemption script.\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            \"\\nCreate a multisig address from 2 addresses\\n\"\n-            + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n-        ;\n+                     \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n+                     \"It returns a json object with the address and redeemScript.\\n\"\n+\n+                     \"\\nArguments:\\n\"\n+                     \"1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n+                     \"2. \\\"keys\\\"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys\\n\"\n+                     \"     [\\n\"\n+                     \"       \\\"key\\\"    (string) bitcoin address or hex-encoded public key\\n\"\n+                     \"       ,...\\n\"\n+                     \"     ]\\n\"\n+\n+                     \"\\nResult:\\n\"\n+                     \"{\\n\"\n+                     \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new multisig address.\\n\"\n+                     \"  \\\"redeemScript\\\":\\\"script\\\"       (string) The string value of the hex-encoded redemption script.\\n\"\n+                     \"}\\n\"\n+\n+                     \"\\nExamples:\\n\"\n+                     \"\\nCreate a multisig address from 2 addresses\\n\" +\n+                     HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n+                     \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\");\n         throw runtime_error(msg);\n     }\n \n@@ -316,19 +307,15 @@ Value verifymessage(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"true|false   (boolean) If the signature is verified or not.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nUnlock the wallet for 30 seconds\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n-            \"\\nCreate the signature\\n\"\n-            + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"my message\\\"\") +\n-            \"\\nVerify the signature\\n\"\n-            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"signature\\\" \\\"my message\\\"\") +\n-            \"\\nAs json rpc\\n\"\n-            + HelpExampleRpc(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"signature\\\", \\\"my message\\\"\")\n-        );\n-\n-    string strAddress  = params[0].get_str();\n-    string strSign     = params[1].get_str();\n-    string strMessage  = params[2].get_str();\n+            \"\\nUnlock the wallet for 30 seconds\\n\" +\n+            HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n+            \"\\nCreate the signature\\n\" + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"my message\\\"\") +\n+            \"\\nVerify the signature\\n\" + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"signature\\\" \\\"my message\\\"\") +\n+            \"\\nAs json rpc\\n\" + HelpExampleRpc(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"signature\\\", \\\"my message\\\"\"));\n+\n+    string strAddress = params[0].get_str();\n+    string strSign = params[1].get_str();\n+    string strMessage = params[2].get_str();\n \n     CBitcoinAddress addr(strAddress);\n     if (!addr.IsValid())\n@@ -363,8 +350,7 @@ Value setmocktime(const Array& params, bool fHelp)\n             \"\\nSet the local time to given timestamp (-regtest only)\\n\"\n             \"\\nArguments:\\n\"\n             \"1. timestamp  (integer, required) Unix seconds-since-epoch timestamp\\n\"\n-            \"   Pass 0 to go back to using the system time.\"\n-        );\n+            \"   Pass 0 to go back to using the system time.\");\n \n     if (!Params().MineBlocksOnDemand())\n         throw runtime_error(\"setmocktime for regression testing (-regtest mode) only\");"
      },
      {
        "sha": "520dc44bdc204c421cad65cc992a0308470108e6",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 79,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -29,10 +29,8 @@ Value getconnectioncount(const Array& params, bool fHelp)\n             \"\\nReturns the number of connections to other nodes.\\n\"\n             \"\\nbResult:\\n\"\n             \"n          (numeric) The connection count\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getconnectioncount\", \"\")\n-            + HelpExampleRpc(\"getconnectioncount\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getconnectioncount\", \"\") + HelpExampleRpc(\"getconnectioncount\", \"\"));\n \n     LOCK(cs_vNodes);\n     return (int)vNodes.size();\n@@ -46,14 +44,12 @@ Value ping(const Array& params, bool fHelp)\n             \"\\nRequests that a ping be sent to all other nodes, to measure ping time.\\n\"\n             \"Results provided in getpeerinfo, pingtime and pingwait fields are decimal seconds.\\n\"\n             \"Ping command is handled in queue with all other commands, so it measures processing backlog, not just network ping.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"ping\", \"\")\n-            + HelpExampleRpc(\"ping\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"ping\", \"\") + HelpExampleRpc(\"ping\", \"\"));\n \n     // Request that each node send a ping during next message processing pass\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pNode, vNodes) {\n+    BOOST_FOREACH (CNode* pNode, vNodes) {\n         pNode->fPingQueued = true;\n     }\n \n@@ -66,7 +62,7 @@ static void CopyNodeStats(std::vector<CNodeStats>& vstats)\n \n     LOCK(cs_vNodes);\n     vstats.reserve(vNodes.size());\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    BOOST_FOREACH (CNode* pnode, vNodes) {\n         CNodeStats stats;\n         pnode->copyStats(stats);\n         vstats.push_back(stats);\n@@ -107,17 +103,15 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getpeerinfo\", \"\")\n-            + HelpExampleRpc(\"getpeerinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getpeerinfo\", \"\") + HelpExampleRpc(\"getpeerinfo\", \"\"));\n \n     vector<CNodeStats> vstats;\n     CopyNodeStats(vstats);\n \n     Array ret;\n \n-    BOOST_FOREACH(const CNodeStats& stats, vstats) {\n+    BOOST_FOREACH (const CNodeStats& stats, vstats) {\n         Object obj;\n         CNodeStateStats statestats;\n         bool fStateStats = GetNodeStateStats(stats.nodeid, statestats);\n@@ -146,7 +140,7 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             obj.push_back(Pair(\"synced_headers\", statestats.nSyncHeight));\n             obj.push_back(Pair(\"synced_blocks\", statestats.nCommonHeight));\n             Array heights;\n-            BOOST_FOREACH(int height, statestats.vHeightInFlight) {\n+            BOOST_FOREACH (int height, statestats.vHeightInFlight) {\n                 heights.push_back(height);\n             }\n             obj.push_back(Pair(\"inflight\", heights));\n@@ -173,34 +167,28 @@ Value addnode(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n             \"2. \\\"command\\\"  (string, required) 'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"addnode\", \"\\\"192.168.0.6:8333\\\" \\\"onetry\\\"\")\n-            + HelpExampleRpc(\"addnode\", \"\\\"192.168.0.6:8333\\\", \\\"onetry\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"addnode\", \"\\\"192.168.0.6:8333\\\" \\\"onetry\\\"\") + HelpExampleRpc(\"addnode\", \"\\\"192.168.0.6:8333\\\", \\\"onetry\\\"\"));\n \n     string strNode = params[0].get_str();\n \n-    if (strCommand == \"onetry\")\n-    {\n+    if (strCommand == \"onetry\") {\n         CAddress addr;\n         OpenNetworkConnection(addr, NULL, strNode.c_str());\n         return Value::null;\n     }\n \n     LOCK(cs_vAddedNodes);\n     vector<string>::iterator it = vAddedNodes.begin();\n-    for(; it != vAddedNodes.end(); it++)\n+    for (; it != vAddedNodes.end(); it++)\n         if (strNode == *it)\n             break;\n \n-    if (strCommand == \"add\")\n-    {\n+    if (strCommand == \"add\") {\n         if (it != vAddedNodes.end())\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: Node already added\");\n         vAddedNodes.push_back(strNode);\n-    }\n-    else if(strCommand == \"remove\")\n-    {\n+    } else if (strCommand == \"remove\") {\n         if (it == vAddedNodes.end())\n             throw JSONRPCError(RPC_CLIENT_NODE_NOT_ADDED, \"Error: Node has not been added.\");\n         vAddedNodes.erase(it);\n@@ -236,28 +224,21 @@ Value getaddednodeinfo(const Array& params, bool fHelp)\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true\")\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true \\\"192.168.0.201\\\"\")\n-            + HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getaddednodeinfo\", \"true\") + HelpExampleCli(\"getaddednodeinfo\", \"true \\\"192.168.0.201\\\"\") + HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\"));\n \n     bool fDns = params[0].get_bool();\n \n     list<string> laddedNodes(0);\n-    if (params.size() == 1)\n-    {\n+    if (params.size() == 1) {\n         LOCK(cs_vAddedNodes);\n-        BOOST_FOREACH(string& strAddNode, vAddedNodes)\n+        BOOST_FOREACH (string& strAddNode, vAddedNodes)\n             laddedNodes.push_back(strAddNode);\n-    }\n-    else\n-    {\n+    } else {\n         string strNode = params[1].get_str();\n         LOCK(cs_vAddedNodes);\n-        BOOST_FOREACH(string& strAddNode, vAddedNodes)\n-            if (strAddNode == strNode)\n-            {\n+        BOOST_FOREACH (string& strAddNode, vAddedNodes)\n+            if (strAddNode == strNode) {\n                 laddedNodes.push_back(strAddNode);\n                 break;\n             }\n@@ -266,10 +247,8 @@ Value getaddednodeinfo(const Array& params, bool fHelp)\n     }\n \n     Array ret;\n-    if (!fDns)\n-    {\n-        BOOST_FOREACH(string& strAddNode, laddedNodes)\n-        {\n+    if (!fDns) {\n+        BOOST_FOREACH (string& strAddNode, laddedNodes) {\n             Object obj;\n             obj.push_back(Pair(\"addednode\", strAddNode));\n             ret.push_back(obj);\n@@ -278,13 +257,11 @@ Value getaddednodeinfo(const Array& params, bool fHelp)\n     }\n \n     list<pair<string, vector<CService> > > laddedAddreses(0);\n-    BOOST_FOREACH(string& strAddNode, laddedNodes)\n-    {\n+    BOOST_FOREACH (string& strAddNode, laddedNodes) {\n         vector<CService> vservNode(0);\n-        if(Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n+        if (Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n             laddedAddreses.push_back(make_pair(strAddNode, vservNode));\n-        else\n-        {\n+        else {\n             Object obj;\n             obj.push_back(Pair(\"addednode\", strAddNode));\n             obj.push_back(Pair(\"connected\", false));\n@@ -294,21 +271,18 @@ Value getaddednodeinfo(const Array& params, bool fHelp)\n     }\n \n     LOCK(cs_vNodes);\n-    for (list<pair<string, vector<CService> > >::iterator it = laddedAddreses.begin(); it != laddedAddreses.end(); it++)\n-    {\n+    for (list<pair<string, vector<CService> > >::iterator it = laddedAddreses.begin(); it != laddedAddreses.end(); it++) {\n         Object obj;\n         obj.push_back(Pair(\"addednode\", it->first));\n \n         Array addresses;\n         bool fConnected = false;\n-        BOOST_FOREACH(CService& addrNode, it->second)\n-        {\n+        BOOST_FOREACH (CService& addrNode, it->second) {\n             bool fFound = false;\n             Object node;\n             node.push_back(Pair(\"address\", addrNode.ToString()));\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n-                if (pnode->addr == addrNode)\n-                {\n+            BOOST_FOREACH (CNode* pnode, vNodes)\n+                if (pnode->addr == addrNode) {\n                     fFound = true;\n                     fConnected = true;\n                     node.push_back(Pair(\"connected\", pnode->fInbound ? \"inbound\" : \"outbound\"));\n@@ -339,10 +313,8 @@ Value getnettotals(const Array& params, bool fHelp)\n             \"  \\\"totalbytessent\\\": n,   (numeric) Total bytes sent\\n\"\n             \"  \\\"timemillis\\\": t        (numeric) Total cpu time\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getnettotals\", \"\")\n-            + HelpExampleRpc(\"getnettotals\", \"\")\n-       );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getnettotals\", \"\") + HelpExampleRpc(\"getnettotals\", \"\"));\n \n     Object obj;\n     obj.push_back(Pair(\"totalbytesrecv\", CNode::GetTotalBytesRecv()));\n@@ -354,10 +326,9 @@ Value getnettotals(const Array& params, bool fHelp)\n static Array GetNetworksInfo()\n {\n     Array networks;\n-    for(int n=0; n<NET_MAX; ++n)\n-    {\n+    for (int n = 0; n < NET_MAX; ++n) {\n         enum Network network = static_cast<enum Network>(n);\n-        if(network == NET_UNROUTABLE)\n+        if (network == NET_UNROUTABLE)\n             continue;\n         proxyType proxy;\n         Object obj;\n@@ -404,26 +375,23 @@ Value getnetworkinfo(const Array& params, bool fHelp)\n             \"  ,...\\n\"\n             \"  ]\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getnetworkinfo\", \"\")\n-            + HelpExampleRpc(\"getnetworkinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getnetworkinfo\", \"\") + HelpExampleRpc(\"getnetworkinfo\", \"\"));\n \n     Object obj;\n-    obj.push_back(Pair(\"version\",       CLIENT_VERSION));\n+    obj.push_back(Pair(\"version\", CLIENT_VERSION));\n     obj.push_back(Pair(\"subversion\",\n-        FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>())));\n-    obj.push_back(Pair(\"protocolversion\",PROTOCOL_VERSION));\n-    obj.push_back(Pair(\"localservices\",       strprintf(\"%016x\", nLocalServices)));\n-    obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n-    obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"networks\",      GetNetworksInfo()));\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n+                       FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>())));\n+    obj.push_back(Pair(\"protocolversion\", PROTOCOL_VERSION));\n+    obj.push_back(Pair(\"localservices\", strprintf(\"%016x\", nLocalServices)));\n+    obj.push_back(Pair(\"timeoffset\", GetTimeOffset()));\n+    obj.push_back(Pair(\"connections\", (int)vNodes.size()));\n+    obj.push_back(Pair(\"networks\", GetNetworksInfo()));\n+    obj.push_back(Pair(\"relayfee\", ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n     Array localAddresses;\n     {\n         LOCK(cs_mapLocalHost);\n-        BOOST_FOREACH(const PAIRTYPE(CNetAddr, LocalServiceInfo) &item, mapLocalHost)\n-        {\n+        BOOST_FOREACH (const PAIRTYPE(CNetAddr, LocalServiceInfo) & item, mapLocalHost) {\n             Object rec;\n             rec.push_back(Pair(\"address\", item.first.ToString()));\n             rec.push_back(Pair(\"port\", item.second.nPort));"
      },
      {
        "sha": "d95a134af571832e520bd9f19b5650241a4ba3ee",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 60,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -40,7 +40,7 @@ const size_t POST_READ_SIZE = 256 * 1024;\n  * and to be compatible with other JSON-RPC implementations.\n  */\n \n-string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n+string HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)\n {\n     ostringstream s;\n     s << \"POST / HTTP/1.1\\r\\n\"\n@@ -50,7 +50,7 @@ string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeader\n       << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n       << \"Connection: close\\r\\n\"\n       << \"Accept: application/json\\r\\n\";\n-    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n+    BOOST_FOREACH (const PAIRTYPE(string, string) & item, mapRequestHeaders)\n         s << item.first << \": \" << item.second << \"\\r\\n\";\n     s << \"\\r\\n\" << strMsg;\n \n@@ -62,52 +62,59 @@ static string rfc1123Time()\n     return DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", GetTime());\n }\n \n-static const char *httpStatusDescription(int nStatus)\n+static const char* httpStatusDescription(int nStatus)\n {\n     switch (nStatus) {\n-        case HTTP_OK: return \"OK\";\n-        case HTTP_BAD_REQUEST: return \"Bad Request\";\n-        case HTTP_FORBIDDEN: return \"Forbidden\";\n-        case HTTP_NOT_FOUND: return \"Not Found\";\n-        case HTTP_INTERNAL_SERVER_ERROR: return \"Internal Server Error\";\n-        default: return \"\";\n+    case HTTP_OK:\n+        return \"OK\";\n+    case HTTP_BAD_REQUEST:\n+        return \"Bad Request\";\n+    case HTTP_FORBIDDEN:\n+        return \"Forbidden\";\n+    case HTTP_NOT_FOUND:\n+        return \"Not Found\";\n+    case HTTP_INTERNAL_SERVER_ERROR:\n+        return \"Internal Server Error\";\n+    default:\n+        return \"\";\n     }\n }\n \n string HTTPError(int nStatus, bool keepalive, bool headersOnly)\n {\n     if (nStatus == HTTP_UNAUTHORIZED)\n         return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n-            \"Content-Type: text/html\\r\\n\"\n-            \"Content-Length: 296\\r\\n\"\n-            \"\\r\\n\"\n-            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n-            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n-            \"<HTML>\\r\\n\"\n-            \"<HEAD>\\r\\n\"\n-            \"<TITLE>Error</TITLE>\\r\\n\"\n-            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n-            \"</HEAD>\\r\\n\"\n-            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-            \"</HTML>\\r\\n\", rfc1123Time(), FormatFullVersion());\n-\n-    return HTTPReply(nStatus, httpStatusDescription(nStatus), keepalive,\n-                     headersOnly, \"text/plain\");\n+                         \"Date: %s\\r\\n\"\n+                         \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+                         \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n+                         \"Content-Type: text/html\\r\\n\"\n+                         \"Content-Length: 296\\r\\n\"\n+                         \"\\r\\n\"\n+                         \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n+                         \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n+                         \"<HTML>\\r\\n\"\n+                         \"<HEAD>\\r\\n\"\n+                         \"<TITLE>Error</TITLE>\\r\\n\"\n+                         \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n+                         \"</HEAD>\\r\\n\"\n+                         \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n+                         \"</HTML>\\r\\n\",\n+                         rfc1123Time(),\n+                         FormatFullVersion());\n+\n+    return HTTPReply(nStatus, httpStatusDescription(nStatus), keepalive, headersOnly, \"text/plain\");\n }\n \n-string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength, const char *contentType)\n+string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength, const char* contentType)\n {\n     return strprintf(\n-            \"HTTP/1.1 %d %s\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Connection: %s\\r\\n\"\n-            \"Content-Length: %u\\r\\n\"\n-            \"Content-Type: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"\\r\\n\",\n+        \"HTTP/1.1 %d %s\\r\\n\"\n+        \"Date: %s\\r\\n\"\n+        \"Connection: %s\\r\\n\"\n+        \"Content-Length: %u\\r\\n\"\n+        \"Content-Type: %s\\r\\n\"\n+        \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+        \"\\r\\n\",\n         nStatus,\n         httpStatusDescription(nStatus),\n         rfc1123Time(),\n@@ -117,19 +124,16 @@ string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength, const\n         FormatFullVersion());\n }\n \n-string HTTPReply(int nStatus, const string& strMsg, bool keepalive,\n-                 bool headersOnly, const char *contentType)\n+string HTTPReply(int nStatus, const string& strMsg, bool keepalive, bool headersOnly, const char* contentType)\n {\n-    if (headersOnly)\n-    {\n+    if (headersOnly) {\n         return HTTPReplyHeader(nStatus, keepalive, 0, contentType);\n     } else {\n         return HTTPReplyHeader(nStatus, keepalive, strMsg.size(), contentType) + strMsg;\n     }\n }\n \n-bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n-                         string& http_method, string& http_uri)\n+bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int& proto, string& http_method, string& http_uri)\n {\n     string str;\n     getline(stream, str);\n@@ -156,14 +160,14 @@ bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n         strProto = vWords[2];\n \n     proto = 0;\n-    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n+    const char* ver = strstr(strProto.c_str(), \"HTTP/1.\");\n     if (ver != NULL)\n-        proto = atoi(ver+7);\n+        proto = atoi(ver + 7);\n \n     return true;\n }\n \n-int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n+int ReadHTTPStatus(std::basic_istream<char>& stream, int& proto)\n {\n     string str;\n     getline(stream, str);\n@@ -172,28 +176,26 @@ int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n     if (vWords.size() < 2)\n         return HTTP_INTERNAL_SERVER_ERROR;\n     proto = 0;\n-    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n+    const char* ver = strstr(str.c_str(), \"HTTP/1.\");\n     if (ver != NULL)\n-        proto = atoi(ver+7);\n+        proto = atoi(ver + 7);\n     return atoi(vWords[1].c_str());\n }\n \n int ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n {\n     int nLen = 0;\n-    while (true)\n-    {\n+    while (true) {\n         string str;\n         std::getline(stream, str);\n         if (str.empty() || str == \"\\r\")\n             break;\n         string::size_type nColon = str.find(\":\");\n-        if (nColon != string::npos)\n-        {\n+        if (nColon != string::npos) {\n             string strHeader = str.substr(0, nColon);\n             boost::trim(strHeader);\n             boost::to_lower(strHeader);\n-            string strValue = str.substr(nColon+1);\n+            string strValue = str.substr(nColon + 1);\n             boost::trim(strValue);\n             mapHeadersRet[strHeader] = strValue;\n             if (strHeader == \"content-length\")\n@@ -204,9 +206,7 @@ int ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHe\n }\n \n \n-int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n-                    string>& mapHeadersRet, string& strMessageRet,\n-                    int nProto, size_t max_size)\n+int ReadHTTPMessage(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet, string& strMessageRet, int nProto, size_t max_size)\n {\n     mapHeadersRet.clear();\n     strMessageRet = \"\";\n@@ -217,12 +217,10 @@ int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n         return HTTP_INTERNAL_SERVER_ERROR;\n \n     // Read message\n-    if (nLen > 0)\n-    {\n+    if (nLen > 0) {\n         vector<char> vch;\n         size_t ptr = 0;\n-        while (ptr < (size_t)nLen)\n-        {\n+        while (ptr < (size_t)nLen) {\n             size_t bytes_to_read = std::min((size_t)nLen - ptr, POST_READ_SIZE);\n             vch.resize(ptr + bytes_to_read);\n             stream.read(&vch[ptr], bytes_to_read);\n@@ -235,8 +233,7 @@ int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n \n     string sConHdr = mapHeadersRet[\"connection\"];\n \n-    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n-    {\n+    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\")) {\n         if (nProto >= 1)\n             mapHeadersRet[\"connection\"] = \"keep-alive\";\n         else"
      },
      {
        "sha": "9e43c600e686e630e5f929787a954aa7d5a6e79b",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 104,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -49,7 +49,7 @@ void ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeH\n     out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n \n     Array a;\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+    BOOST_FOREACH (const CTxDestination& addr, addresses)\n         a.push_back(CBitcoinAddress(addr).ToString());\n     out.push_back(Pair(\"addresses\", a));\n }\n@@ -60,7 +60,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n     entry.push_back(Pair(\"version\", tx.nVersion));\n     entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n     Array vin;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n         Object in;\n         if (tx.IsCoinBase())\n             in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n@@ -98,8 +98,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n                 entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n                 entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n-            }\n-            else\n+            } else\n                 entry.push_back(Pair(\"confirmations\", 0));\n         }\n     }\n@@ -165,11 +164,8 @@ Value getrawtransaction(const Array& params, bool fHelp)\n             \"  \\\"blocktime\\\" : ttt         (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n             \"}\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\"\")\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" 1\")\n-            + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", 1\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\"\") + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" 1\") + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", 1\"));\n \n     uint256 hash = ParseHashV(params[0], \"parameter 1\");\n \n@@ -226,11 +222,8 @@ Value listunspent(const Array& params, bool fHelp)\n             \"  ,...\\n\"\n             \"]\\n\"\n \n-            \"\\nExamples\\n\"\n-            + HelpExampleCli(\"listunspent\", \"\")\n-            + HelpExampleCli(\"listunspent\", \"6 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n-            + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n-        );\n+            \"\\nExamples\\n\" +\n+            HelpExampleCli(\"listunspent\", \"\") + HelpExampleCli(\"listunspent\", \"6 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\") + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\"));\n \n     RPCTypeCheck(params, list_of(int_type)(int_type)(array_type));\n \n@@ -245,21 +238,21 @@ Value listunspent(const Array& params, bool fHelp)\n     set<CBitcoinAddress> setAddress;\n     if (params.size() > 2) {\n         Array inputs = params[2].get_array();\n-        BOOST_FOREACH(Value& input, inputs) {\n+        BOOST_FOREACH (Value& input, inputs) {\n             CBitcoinAddress address(input.get_str());\n             if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+input.get_str());\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \") + input.get_str());\n             if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+input.get_str());\n-           setAddress.insert(address);\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \") + input.get_str());\n+            setAddress.insert(address);\n         }\n     }\n \n     Array results;\n     vector<COutput> vecOutputs;\n     assert(pwalletMain != NULL);\n     pwalletMain->AvailableCoins(vecOutputs, false);\n-    BOOST_FOREACH(const COutput& out, vecOutputs) {\n+    BOOST_FOREACH (const COutput& out, vecOutputs) {\n         if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n             continue;\n \n@@ -293,8 +286,8 @@ Value listunspent(const Array& params, bool fHelp)\n                     entry.push_back(Pair(\"redeemScript\", HexStr(redeemScript.begin(), redeemScript.end())));\n             }\n         }\n-        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n-        entry.push_back(Pair(\"confirmations\",out.nDepth));\n+        entry.push_back(Pair(\"amount\", ValueFromAmount(nValue)));\n+        entry.push_back(Pair(\"confirmations\", out.nDepth));\n         entry.push_back(Pair(\"spendable\", out.fSpendable));\n         results.push_back(entry);\n     }\n@@ -331,10 +324,8 @@ Value createrawtransaction(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"\\\"transaction\\\"            (string) hex string of the transaction\\n\"\n \n-            \"\\nExamples\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-        );\n+            \"\\nExamples\\n\" +\n+            HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\") + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\"));\n \n     RPCTypeCheck(params, list_of(array_type)(obj_type));\n \n@@ -343,7 +334,7 @@ Value createrawtransaction(const Array& params, bool fHelp)\n \n     CMutableTransaction rawTx;\n \n-    BOOST_FOREACH(const Value& input, inputs) {\n+    BOOST_FOREACH (const Value& input, inputs) {\n         const Object& o = input.get_obj();\n \n         uint256 txid = ParseHashO(o, \"txid\");\n@@ -360,13 +351,13 @@ Value createrawtransaction(const Array& params, bool fHelp)\n     }\n \n     set<CBitcoinAddress> setAddress;\n-    BOOST_FOREACH(const Pair& s, sendTo) {\n+    BOOST_FOREACH (const Pair& s, sendTo) {\n         CBitcoinAddress address(s.name_);\n         if (!address.IsValid())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+s.name_);\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \") + s.name_);\n \n         if (setAddress.count(address))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+s.name_);\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \") + s.name_);\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -425,10 +416,8 @@ Value decoderawtransaction(const Array& params, bool fHelp)\n             \"  ],\\n\"\n             \"}\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\n-            + HelpExampleRpc(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"decoderawtransaction\", \"\\\"hexstring\\\"\") + HelpExampleRpc(\"decoderawtransaction\", \"\\\"hexstring\\\"\"));\n \n     RPCTypeCheck(params, list_of(str_type));\n \n@@ -463,16 +452,14 @@ Value decodescript(const Array& params, bool fHelp)\n             \"  ],\\n\"\n             \"  \\\"p2sh\\\",\\\"address\\\" (string) script address\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"decodescript\", \"\\\"hexstring\\\"\")\n-            + HelpExampleRpc(\"decodescript\", \"\\\"hexstring\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"decodescript\", \"\\\"hexstring\\\"\") + HelpExampleRpc(\"decodescript\", \"\\\"hexstring\\\"\"));\n \n     RPCTypeCheck(params, list_of(str_type));\n \n     Object r;\n     CScript script;\n-    if (params[0].get_str().size() > 0){\n+    if (params[0].get_str().size() > 0) {\n         vector<unsigned char> scriptData(ParseHexV(params[0], \"argument\"));\n         script = CScript(scriptData.begin(), scriptData.end());\n     } else {\n@@ -495,44 +482,43 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             \"The third optional argument (may be null) is an array of base58-encoded private\\n\"\n             \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n #ifdef ENABLE_WALLET\n-            + HelpRequiringPassphrase() + \"\\n\"\n+            +\n+            HelpRequiringPassphrase() + \"\\n\"\n #endif\n \n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"     (string, required) The transaction hex string\\n\"\n-            \"2. \\\"prevtxs\\\"       (string, optional) An json array of previous dependent transaction outputs\\n\"\n-            \"     [               (json array of json objects, or 'null' if none provided)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n-            \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\"    (string, required for P2SH) redeem script\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"    ]\\n\"\n-            \"3. \\\"privatekeys\\\"     (string, optional) A json array of base58-encoded private keys for signing\\n\"\n-            \"    [                  (json array of strings, or 'null' if none provided)\\n\"\n-            \"      \\\"privatekey\\\"   (string) private key in base58-encoding\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"4. \\\"sighashtype\\\"     (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n-            \"       \\\"ALL\\\"\\n\"\n-            \"       \\\"NONE\\\"\\n\"\n-            \"       \\\"SINGLE\\\"\\n\"\n-            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"hex\\\": \\\"value\\\",   (string) The raw transaction with signature(s) (hex-encoded string)\\n\"\n-            \"  \\\"complete\\\": n       (numeric) if transaction has a complete set of signature (0 if not)\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-            + HelpExampleRpc(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-        );\n+                                        \"\\nArguments:\\n\"\n+                                        \"1. \\\"hexstring\\\"     (string, required) The transaction hex string\\n\"\n+                                        \"2. \\\"prevtxs\\\"       (string, optional) An json array of previous dependent transaction outputs\\n\"\n+                                        \"     [               (json array of json objects, or 'null' if none provided)\\n\"\n+                                        \"       {\\n\"\n+                                        \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n+                                        \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n+                                        \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n+                                        \"         \\\"redeemScript\\\": \\\"hex\\\"    (string, required for P2SH) redeem script\\n\"\n+                                        \"       }\\n\"\n+                                        \"       ,...\\n\"\n+                                        \"    ]\\n\"\n+                                        \"3. \\\"privatekeys\\\"     (string, optional) A json array of base58-encoded private keys for signing\\n\"\n+                                        \"    [                  (json array of strings, or 'null' if none provided)\\n\"\n+                                        \"      \\\"privatekey\\\"   (string) private key in base58-encoding\\n\"\n+                                        \"      ,...\\n\"\n+                                        \"    ]\\n\"\n+                                        \"4. \\\"sighashtype\\\"     (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+                                        \"       \\\"ALL\\\"\\n\"\n+                                        \"       \\\"NONE\\\"\\n\"\n+                                        \"       \\\"SINGLE\\\"\\n\"\n+                                        \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+                                        \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+                                        \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+                                        \"\\nResult:\\n\"\n+                                        \"{\\n\"\n+                                        \"  \\\"hex\\\": \\\"value\\\",   (string) The raw transaction with signature(s) (hex-encoded string)\\n\"\n+                                        \"  \\\"complete\\\": n       (numeric) if transaction has a complete set of signature (0 if not)\\n\"\n+                                        \"}\\n\"\n+\n+                                        \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") + HelpExampleRpc(\"signrawtransaction\", \"\\\"myhex\\\"\"));\n \n     RPCTypeCheck(params, list_of(str_type)(array_type)(array_type)(str_type), true);\n \n@@ -544,8 +530,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             CMutableTransaction tx;\n             ssData >> tx;\n             txVariants.push_back(tx);\n-        }\n-        catch (const std::exception &) {\n+        } catch (const std::exception&) {\n             throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n         }\n     }\n@@ -563,11 +548,11 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     CCoinsViewCache view(&viewDummy);\n     {\n         LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewCache& viewChain = *pcoinsTip;\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n-        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n+        BOOST_FOREACH (const CTxIn& txin, mergedTx.vin) {\n             const uint256& prevHash = txin.prevout.hash;\n             CCoins coins;\n             view.AccessCoins(prevHash); // this is certainly allowed to fail\n@@ -581,7 +566,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     if (params.size() > 2 && params[2].type() != null_type) {\n         fGivenKeys = true;\n         Array keys = params[2].get_array();\n-        BOOST_FOREACH(Value k, keys) {\n+        BOOST_FOREACH (Value k, keys) {\n             CBitcoinSecret vchSecret;\n             bool fGood = vchSecret.SetString(k.get_str());\n             if (!fGood)\n@@ -598,7 +583,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     // Add previous txouts given in the RPC call:\n     if (params.size() > 1 && params[1].type() != null_type) {\n         Array prevTxs = params[1].get_array();\n-        BOOST_FOREACH(Value& p, prevTxs) {\n+        BOOST_FOREACH (Value& p, prevTxs) {\n             if (p.type() != obj_type)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n \n@@ -619,20 +604,20 @@ Value signrawtransaction(const Array& params, bool fHelp)\n                 CCoinsModifier coins = view.ModifyCoins(txid);\n                 if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n                     string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + coins->vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\"+\n-                        scriptPubKey.ToString();\n+                    err = err + coins->vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\" +\n+                          scriptPubKey.ToString();\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                 }\n                 if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n+                    coins->vout.resize(nOut + 1);\n                 coins->vout[nOut].scriptPubKey = scriptPubKey;\n                 coins->vout[nOut].nValue = 0; // we don't know the actual output value\n             }\n \n             // if redeemScript given and not using the local wallet (private keys\n             // given), add redeemScript to the tempKeystore so it can be signed:\n             if (fGivenKeys && scriptPubKey.IsPayToScriptHash()) {\n-                RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type)(\"redeemScript\",str_type));\n+                RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type)(\"redeemScript\", str_type));\n                 Value v = find_value(prevOut, \"redeemScript\");\n                 if (!(v == Value::null)) {\n                     vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n@@ -652,14 +637,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     int nHashType = SIGHASH_ALL;\n     if (params.size() > 3 && params[3].type() != null_type) {\n         static map<string, int> mapSigHashValues =\n-            boost::assign::map_list_of\n-            (string(\"ALL\"), int(SIGHASH_ALL))\n-            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n-            (string(\"NONE\"), int(SIGHASH_NONE))\n-            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n-            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n-            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n-            ;\n+            boost::assign::map_list_of(string(\"ALL\"), int(SIGHASH_ALL))(string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL | SIGHASH_ANYONECANPAY))(string(\"NONE\"), int(SIGHASH_NONE))(string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE | SIGHASH_ANYONECANPAY))(string(\"SINGLE\"), int(SIGHASH_SINGLE))(string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE | SIGHASH_ANYONECANPAY));\n         string strHashType = params[3].get_str();\n         if (mapSigHashValues.count(strHashType))\n             nHashType = mapSigHashValues[strHashType];\n@@ -685,7 +663,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CMutableTransaction& txv, txVariants) {\n+        BOOST_FOREACH (const CMutableTransaction& txv, txVariants) {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, SignatureChecker(mergedTx, i)))\n@@ -712,15 +690,11 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"\\\"hex\\\"             (string) The transaction hash in hex\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nCreate a transaction\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n-            \"Sign the transaction, and get back the hex\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n-            \"\\nSend the transaction (signed hex)\\n\"\n-            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\")\n-        );\n+            \"\\nCreate a transaction\\n\" +\n+            HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\" + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nSend the transaction (signed hex)\\n\" + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\"));\n \n     RPCTypeCheck(params, list_of(str_type)(bool_type));\n \n@@ -734,15 +708,15 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     if (params.size() > 1)\n         fOverrideFees = params[1].get_bool();\n \n-    CCoinsViewCache &view = *pcoinsTip;\n+    CCoinsViewCache& view = *pcoinsTip;\n     const CCoins* existingCoins = view.AccessCoins(hashTx);\n     bool fHaveMempool = mempool.exists(hashTx);\n     bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;\n     if (!fHaveMempool && !fHaveChain) {\n         // push to local node and sync with wallets\n         CValidationState state;\n         if (!AcceptToMemoryPool(mempool, state, tx, false, NULL, !fOverrideFees)) {\n-            if(state.IsInvalid())\n+            if (state.IsInvalid())\n                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n             else\n                 throw JSONRPCError(RPC_TRANSACTION_ERROR, state.GetRejectReason());"
      },
      {
        "sha": "9bff3405d313c28db9770f96bdd7f9701836f62b",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 245,
        "deletions": 272,
        "changes": 517,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -43,25 +43,24 @@ static asio::io_service* rpc_io_service = NULL;\n static map<string, boost::shared_ptr<deadline_timer> > deadlineTimers;\n static ssl::context* rpc_ssl_context = NULL;\n static boost::thread_group* rpc_worker_group = NULL;\n-static boost::asio::io_service::work *rpc_dummy_work = NULL;\n+static boost::asio::io_service::work* rpc_dummy_work = NULL;\n static std::vector<CSubNet> rpc_allow_subnets; //!< List of subnets to allow RPC connections from\n-static std::vector< boost::shared_ptr<ip::tcp::acceptor> > rpc_acceptors;\n+static std::vector<boost::shared_ptr<ip::tcp::acceptor> > rpc_acceptors;\n \n void RPCTypeCheck(const Array& params,\n                   const list<Value_type>& typesExpected,\n                   bool fAllowNull)\n {\n     unsigned int i = 0;\n-    BOOST_FOREACH(Value_type t, typesExpected)\n-    {\n+    BOOST_FOREACH (Value_type t, typesExpected) {\n         if (params.size() <= i)\n             break;\n \n         const Value& v = params[i];\n-        if (!((v.type() == t) || (fAllowNull && (v.type() == null_type))))\n-        {\n+        if (!((v.type() == t) || (fAllowNull && (v.type() == null_type)))) {\n             string err = strprintf(\"Expected type %s, got %s\",\n-                                   Value_type_name[t], Value_type_name[v.type()]);\n+                                   Value_type_name[t],\n+                                   Value_type_name[v.type()]);\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n         i++;\n@@ -72,16 +71,16 @@ void RPCTypeCheck(const Object& o,\n                   const map<string, Value_type>& typesExpected,\n                   bool fAllowNull)\n {\n-    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(string, Value_type) & t, typesExpected) {\n         const Value& v = find_value(o, t.first);\n         if (!fAllowNull && v.type() == null_type)\n             throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first));\n \n-        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n-        {\n+        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type)))) {\n             string err = strprintf(\"Expected type %s for %s, got %s\",\n-                                   Value_type_name[t.second], t.first, Value_type_name[v.type()]);\n+                                   Value_type_name[t.second],\n+                                   t.first,\n+                                   Value_type_name[v.type()]);\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n     }\n@@ -114,7 +113,7 @@ uint256 ParseHashV(const Value& v, string strName)\n     if (v.type() == str_type)\n         strHex = v.get_str();\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     uint256 result;\n     result.SetHex(strHex);\n     return result;\n@@ -129,7 +128,7 @@ vector<unsigned char> ParseHexV(const Value& v, string strName)\n     if (v.type() == str_type)\n         strHex = v.get_str();\n     if (!IsHex(strHex))\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     return ParseHex(strHex);\n }\n vector<unsigned char> ParseHexO(const Object& o, string strKey)\n@@ -153,9 +152,8 @@ string CRPCTable::help(string strCommand) const\n         vCommands.push_back(make_pair(mi->second->category + mi->first, mi->second));\n     sort(vCommands.begin(), vCommands.end());\n \n-    BOOST_FOREACH(const PAIRTYPE(string, const CRPCCommand*)& command, vCommands)\n-    {\n-        const CRPCCommand *pcmd = command.second;\n+    BOOST_FOREACH (const PAIRTYPE(string, const CRPCCommand*)&command, vCommands) {\n+        const CRPCCommand* pcmd = command.second;\n         string strMethod = pcmd->name;\n         // We already filter duplicates, but these deprecated screw up the sort order\n         if (strMethod.find(\"label\") != string::npos)\n@@ -167,28 +165,23 @@ string CRPCTable::help(string strCommand) const\n             continue;\n #endif\n \n-        try\n-        {\n+        try {\n             Array params;\n             rpcfn_type pfn = pcmd->actor;\n             if (setDone.insert(pfn).second)\n                 (*pfn)(params, true);\n-        }\n-        catch (std::exception& e)\n-        {\n+        } catch (std::exception& e) {\n             // Help text is returned in an exception\n             string strHelp = string(e.what());\n-            if (strCommand == \"\")\n-            {\n+            if (strCommand == \"\") {\n                 if (strHelp.find('\\n') != string::npos)\n                     strHelp = strHelp.substr(0, strHelp.find('\\n'));\n \n-                if (category != pcmd->category)\n-                {\n+                if (category != pcmd->category) {\n                     if (!category.empty())\n                         strRet += \"\\n\";\n                     category = pcmd->category;\n-                    string firstLetter = category.substr(0,1);\n+                    string firstLetter = category.substr(0, 1);\n                     boost::to_upper(firstLetter);\n                     strRet += \"== \" + firstLetter + category.substr(1) + \" ==\\n\";\n                 }\n@@ -198,7 +191,7 @@ string CRPCTable::help(string strCommand) const\n     }\n     if (strRet == \"\")\n         strRet = strprintf(\"help: unknown command: %s\\n\", strCommand);\n-    strRet = strRet.substr(0,strRet.size()-1);\n+    strRet = strRet.substr(0, strRet.size() - 1);\n     return strRet;\n }\n \n@@ -211,8 +204,7 @@ Value help(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"command\\\"     (string, optional) The command to get help on\\n\"\n             \"\\nResult:\\n\"\n-            \"\\\"text\\\"     (string) The help text\\n\"\n-        );\n+            \"\\\"text\\\"     (string) The help text\\n\");\n \n     string strCommand;\n     if (params.size() > 0)\n@@ -235,128 +227,126 @@ Value stop(const Array& params, bool fHelp)\n }\n \n \n-\n /**\n  * Call Table\n  */\n static const CRPCCommand vRPCCommands[] =\n-{ //  category              name                      actor (function)         okSafeMode threadSafe reqWallet\n-  //  --------------------- ------------------------  -----------------------  ---------- ---------- ---------\n-    /* Overall control/query calls */\n-    { \"control\",            \"getinfo\",                &getinfo,                true,      false,      false }, /* uses wallet if enabled */\n-    { \"control\",            \"help\",                   &help,                   true,      true,       false },\n-    { \"control\",            \"stop\",                   &stop,                   true,      true,       false },\n-    { \"control\",            \"setmocktime\",            &setmocktime,            true,      false,      false },\n-\n-    /* P2P networking */\n-    { \"network\",            \"getnetworkinfo\",         &getnetworkinfo,         true,      false,      false },\n-    { \"network\",            \"addnode\",                &addnode,                true,      true,       false },\n-    { \"network\",            \"getaddednodeinfo\",       &getaddednodeinfo,       true,      true,       false },\n-    { \"network\",            \"getconnectioncount\",     &getconnectioncount,     true,      false,      false },\n-    { \"network\",            \"getnettotals\",           &getnettotals,           true,      true,       false },\n-    { \"network\",            \"getpeerinfo\",            &getpeerinfo,            true,      false,      false },\n-    { \"network\",            \"ping\",                   &ping,                   true,      false,      false },\n-\n-    /* Block chain and UTXO */\n-    { \"blockchain\",         \"getblockchaininfo\",      &getblockchaininfo,      true,      false,      false },\n-    { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,      false,      false },\n-    { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,      false,      false },\n-    { \"blockchain\",         \"getblock\",               &getblock,               true,      false,      false },\n-    { \"blockchain\",         \"getblockhash\",           &getblockhash,           true,      false,      false },\n-    { \"blockchain\",         \"getchaintips\",           &getchaintips,           true,      false,      false },\n-    { \"blockchain\",         \"getdifficulty\",          &getdifficulty,          true,      false,      false },\n-    { \"blockchain\",         \"getmempoolinfo\",         &getmempoolinfo,         true,      true,       false },\n-    { \"blockchain\",         \"getrawmempool\",          &getrawmempool,          true,      false,      false },\n-    { \"blockchain\",         \"gettxout\",               &gettxout,               true,      false,      false },\n-    { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,      false,      false },\n-    { \"blockchain\",         \"verifychain\",            &verifychain,            true,      false,      false },\n-\n-    /* Mining */\n-    { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       true,      false,      false },\n-    { \"mining\",             \"getmininginfo\",          &getmininginfo,          true,      false,      false },\n-    { \"mining\",             \"getnetworkhashps\",       &getnetworkhashps,       true,      false,      false },\n-    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,      false,      false },\n-    { \"mining\",             \"submitblock\",            &submitblock,            true,      true,       false },\n+    { //  category              name                      actor (function)         okSafeMode threadSafe reqWallet\n+      //  --------------------- ------------------------  -----------------------  ---------- ---------- ---------\n+     /* Overall control/query calls */\n+     {\"control\", \"getinfo\", &getinfo, true, false, false}, /* uses wallet if enabled */\n+     {\"control\", \"help\", &help, true, true, false},\n+     {\"control\", \"stop\", &stop, true, true, false},\n+     {\"control\", \"setmocktime\", &setmocktime, true, false, false},\n+\n+     /* P2P networking */\n+     {\"network\", \"getnetworkinfo\", &getnetworkinfo, true, false, false},\n+     {\"network\", \"addnode\", &addnode, true, true, false},\n+     {\"network\", \"getaddednodeinfo\", &getaddednodeinfo, true, true, false},\n+     {\"network\", \"getconnectioncount\", &getconnectioncount, true, false, false},\n+     {\"network\", \"getnettotals\", &getnettotals, true, true, false},\n+     {\"network\", \"getpeerinfo\", &getpeerinfo, true, false, false},\n+     {\"network\", \"ping\", &ping, true, false, false},\n+\n+     /* Block chain and UTXO */\n+     {\"blockchain\", \"getblockchaininfo\", &getblockchaininfo, true, false, false},\n+     {\"blockchain\", \"getbestblockhash\", &getbestblockhash, true, false, false},\n+     {\"blockchain\", \"getblockcount\", &getblockcount, true, false, false},\n+     {\"blockchain\", \"getblock\", &getblock, true, false, false},\n+     {\"blockchain\", \"getblockhash\", &getblockhash, true, false, false},\n+     {\"blockchain\", \"getchaintips\", &getchaintips, true, false, false},\n+     {\"blockchain\", \"getdifficulty\", &getdifficulty, true, false, false},\n+     {\"blockchain\", \"getmempoolinfo\", &getmempoolinfo, true, true, false},\n+     {\"blockchain\", \"getrawmempool\", &getrawmempool, true, false, false},\n+     {\"blockchain\", \"gettxout\", &gettxout, true, false, false},\n+     {\"blockchain\", \"gettxoutsetinfo\", &gettxoutsetinfo, true, false, false},\n+     {\"blockchain\", \"verifychain\", &verifychain, true, false, false},\n+\n+     /* Mining */\n+     {\"mining\", \"getblocktemplate\", &getblocktemplate, true, false, false},\n+     {\"mining\", \"getmininginfo\", &getmininginfo, true, false, false},\n+     {\"mining\", \"getnetworkhashps\", &getnetworkhashps, true, false, false},\n+     {\"mining\", \"prioritisetransaction\", &prioritisetransaction, true, false, false},\n+     {\"mining\", \"submitblock\", &submitblock, true, true, false},\n \n #ifdef ENABLE_WALLET\n-    /* Coin generation */\n-    { \"generating\",         \"getgenerate\",            &getgenerate,            true,      false,      false },\n-    { \"generating\",         \"gethashespersec\",        &gethashespersec,        true,      false,      false },\n-    { \"generating\",         \"setgenerate\",            &setgenerate,            true,      true,       false },\n+     /* Coin generation */\n+     {\"generating\", \"getgenerate\", &getgenerate, true, false, false},\n+     {\"generating\", \"gethashespersec\", &gethashespersec, true, false, false},\n+     {\"generating\", \"setgenerate\", &setgenerate, true, true, false},\n #endif\n \n-    /* Raw transactions */\n-    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   true,      false,      false },\n-    { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   true,      false,      false },\n-    { \"rawtransactions\",    \"decodescript\",           &decodescript,           true,      false,      false },\n-    { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      true,      false,      false },\n-    { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     false,     false,      false },\n-    { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     false,     false,      false }, /* uses wallet if enabled */\n-\n-    /* Utility functions */\n-    { \"util\",               \"createmultisig\",         &createmultisig,         true,      true ,      false },\n-    { \"util\",               \"validateaddress\",        &validateaddress,        true,      false,      false }, /* uses wallet if enabled */\n-    { \"util\",               \"verifymessage\",          &verifymessage,          true,      false,      false },\n-    { \"util\",               \"estimatefee\",            &estimatefee,            true,      true,       false },\n-    { \"util\",               \"estimatepriority\",       &estimatepriority,       true,      true,       false },\n+     /* Raw transactions */\n+     {\"rawtransactions\", \"createrawtransaction\", &createrawtransaction, true, false, false},\n+     {\"rawtransactions\", \"decoderawtransaction\", &decoderawtransaction, true, false, false},\n+     {\"rawtransactions\", \"decodescript\", &decodescript, true, false, false},\n+     {\"rawtransactions\", \"getrawtransaction\", &getrawtransaction, true, false, false},\n+     {\"rawtransactions\", \"sendrawtransaction\", &sendrawtransaction, false, false, false},\n+     {\"rawtransactions\", \"signrawtransaction\", &signrawtransaction, false, false, false}, /* uses wallet if enabled */\n+\n+     /* Utility functions */\n+     {\"util\", \"createmultisig\", &createmultisig, true, true, false},\n+     {\"util\", \"validateaddress\", &validateaddress, true, false, false}, /* uses wallet if enabled */\n+     {\"util\", \"verifymessage\", &verifymessage, true, false, false},\n+     {\"util\", \"estimatefee\", &estimatefee, true, true, false},\n+     {\"util\", \"estimatepriority\", &estimatepriority, true, true, false},\n \n #ifdef ENABLE_WALLET\n-    /* Wallet */\n-    { \"wallet\",             \"addmultisigaddress\",     &addmultisigaddress,     true,      false,      true },\n-    { \"wallet\",             \"backupwallet\",           &backupwallet,           true,      false,      true },\n-    { \"wallet\",             \"dumpprivkey\",            &dumpprivkey,            true,      false,      true },\n-    { \"wallet\",             \"dumpwallet\",             &dumpwallet,             true,      false,      true },\n-    { \"wallet\",             \"encryptwallet\",          &encryptwallet,          true,      false,      true },\n-    { \"wallet\",             \"getaccountaddress\",      &getaccountaddress,      true,      false,      true },\n-    { \"wallet\",             \"getaccount\",             &getaccount,             true,      false,      true },\n-    { \"wallet\",             \"getaddressesbyaccount\",  &getaddressesbyaccount,  true,      false,      true },\n-    { \"wallet\",             \"getbalance\",             &getbalance,             false,     false,      true },\n-    { \"wallet\",             \"getnewaddress\",          &getnewaddress,          true,      false,      true },\n-    { \"wallet\",             \"getrawchangeaddress\",    &getrawchangeaddress,    true,      false,      true },\n-    { \"wallet\",             \"getreceivedbyaccount\",   &getreceivedbyaccount,   false,     false,      true },\n-    { \"wallet\",             \"getreceivedbyaddress\",   &getreceivedbyaddress,   false,     false,      true },\n-    { \"wallet\",             \"gettransaction\",         &gettransaction,         false,     false,      true },\n-    { \"wallet\",             \"getunconfirmedbalance\",  &getunconfirmedbalance,  false,     false,      true },\n-    { \"wallet\",             \"getwalletinfo\",          &getwalletinfo,          false,     false,      true },\n-    { \"wallet\",             \"importprivkey\",          &importprivkey,          true,      false,      true },\n-    { \"wallet\",             \"importwallet\",           &importwallet,           true,      false,      true },\n-    { \"wallet\",             \"importaddress\",          &importaddress,          true,      false,      true },\n-    { \"wallet\",             \"keypoolrefill\",          &keypoolrefill,          true,      false,      true },\n-    { \"wallet\",             \"listaccounts\",           &listaccounts,           false,     false,      true },\n-    { \"wallet\",             \"listaddressgroupings\",   &listaddressgroupings,   false,     false,      true },\n-    { \"wallet\",             \"listlockunspent\",        &listlockunspent,        false,     false,      true },\n-    { \"wallet\",             \"listreceivedbyaccount\",  &listreceivedbyaccount,  false,     false,      true },\n-    { \"wallet\",             \"listreceivedbyaddress\",  &listreceivedbyaddress,  false,     false,      true },\n-    { \"wallet\",             \"listsinceblock\",         &listsinceblock,         false,     false,      true },\n-    { \"wallet\",             \"listtransactions\",       &listtransactions,       false,     false,      true },\n-    { \"wallet\",             \"listunspent\",            &listunspent,            false,     false,      true },\n-    { \"wallet\",             \"lockunspent\",            &lockunspent,            true,      false,      true },\n-    { \"wallet\",             \"move\",                   &movecmd,                false,     false,      true },\n-    { \"wallet\",             \"sendfrom\",               &sendfrom,               false,     false,      true },\n-    { \"wallet\",             \"sendmany\",               &sendmany,               false,     false,      true },\n-    { \"wallet\",             \"sendtoaddress\",          &sendtoaddress,          false,     false,      true },\n-    { \"wallet\",             \"setaccount\",             &setaccount,             true,      false,      true },\n-    { \"wallet\",             \"settxfee\",               &settxfee,               true,      false,      true },\n-    { \"wallet\",             \"signmessage\",            &signmessage,            true,      false,      true },\n-    { \"wallet\",             \"walletlock\",             &walletlock,             true,      false,      true },\n-    { \"wallet\",             \"walletpassphrasechange\", &walletpassphrasechange, true,      false,      true },\n-    { \"wallet\",             \"walletpassphrase\",       &walletpassphrase,       true,      false,      true },\n+     /* Wallet */\n+     {\"wallet\", \"addmultisigaddress\", &addmultisigaddress, true, false, true},\n+     {\"wallet\", \"backupwallet\", &backupwallet, true, false, true},\n+     {\"wallet\", \"dumpprivkey\", &dumpprivkey, true, false, true},\n+     {\"wallet\", \"dumpwallet\", &dumpwallet, true, false, true},\n+     {\"wallet\", \"encryptwallet\", &encryptwallet, true, false, true},\n+     {\"wallet\", \"getaccountaddress\", &getaccountaddress, true, false, true},\n+     {\"wallet\", \"getaccount\", &getaccount, true, false, true},\n+     {\"wallet\", \"getaddressesbyaccount\", &getaddressesbyaccount, true, false, true},\n+     {\"wallet\", \"getbalance\", &getbalance, false, false, true},\n+     {\"wallet\", \"getnewaddress\", &getnewaddress, true, false, true},\n+     {\"wallet\", \"getrawchangeaddress\", &getrawchangeaddress, true, false, true},\n+     {\"wallet\", \"getreceivedbyaccount\", &getreceivedbyaccount, false, false, true},\n+     {\"wallet\", \"getreceivedbyaddress\", &getreceivedbyaddress, false, false, true},\n+     {\"wallet\", \"gettransaction\", &gettransaction, false, false, true},\n+     {\"wallet\", \"getunconfirmedbalance\", &getunconfirmedbalance, false, false, true},\n+     {\"wallet\", \"getwalletinfo\", &getwalletinfo, false, false, true},\n+     {\"wallet\", \"importprivkey\", &importprivkey, true, false, true},\n+     {\"wallet\", \"importwallet\", &importwallet, true, false, true},\n+     {\"wallet\", \"importaddress\", &importaddress, true, false, true},\n+     {\"wallet\", \"keypoolrefill\", &keypoolrefill, true, false, true},\n+     {\"wallet\", \"listaccounts\", &listaccounts, false, false, true},\n+     {\"wallet\", \"listaddressgroupings\", &listaddressgroupings, false, false, true},\n+     {\"wallet\", \"listlockunspent\", &listlockunspent, false, false, true},\n+     {\"wallet\", \"listreceivedbyaccount\", &listreceivedbyaccount, false, false, true},\n+     {\"wallet\", \"listreceivedbyaddress\", &listreceivedbyaddress, false, false, true},\n+     {\"wallet\", \"listsinceblock\", &listsinceblock, false, false, true},\n+     {\"wallet\", \"listtransactions\", &listtransactions, false, false, true},\n+     {\"wallet\", \"listunspent\", &listunspent, false, false, true},\n+     {\"wallet\", \"lockunspent\", &lockunspent, true, false, true},\n+     {\"wallet\", \"move\", &movecmd, false, false, true},\n+     {\"wallet\", \"sendfrom\", &sendfrom, false, false, true},\n+     {\"wallet\", \"sendmany\", &sendmany, false, false, true},\n+     {\"wallet\", \"sendtoaddress\", &sendtoaddress, false, false, true},\n+     {\"wallet\", \"setaccount\", &setaccount, true, false, true},\n+     {\"wallet\", \"settxfee\", &settxfee, true, false, true},\n+     {\"wallet\", \"signmessage\", &signmessage, true, false, true},\n+     {\"wallet\", \"walletlock\", &walletlock, true, false, true},\n+     {\"wallet\", \"walletpassphrasechange\", &walletpassphrasechange, true, false, true},\n+     {\"wallet\", \"walletpassphrase\", &walletpassphrase, true, false, true},\n #endif // ENABLE_WALLET\n };\n \n CRPCTable::CRPCTable()\n {\n     unsigned int vcidx;\n-    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); vcidx++)\n-    {\n-        const CRPCCommand *pcmd;\n+    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); vcidx++) {\n+        const CRPCCommand* pcmd;\n \n         pcmd = &vRPCCommands[vcidx];\n         mapCommands[pcmd->name] = pcmd;\n     }\n }\n \n-const CRPCCommand *CRPCTable::operator[](string name) const\n+const CRPCCommand* CRPCTable::operator[](string name) const\n {\n     map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it == mapCommands.end())\n@@ -368,9 +358,10 @@ const CRPCCommand *CRPCTable::operator[](string name) const\n bool HTTPAuthorized(map<string, string>& mapHeaders)\n {\n     string strAuth = mapHeaders[\"authorization\"];\n-    if (strAuth.substr(0,6) != \"Basic \")\n+    if (strAuth.substr(0, 6) != \"Basic \")\n         return false;\n-    string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64);\n+    string strUserPass64 = strAuth.substr(6);\n+    boost::trim(strUserPass64);\n     string strUserPass = DecodeBase64(strUserPass64);\n     return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n }\n@@ -380,8 +371,10 @@ void ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n     // Send error reply from json-rpc error object\n     int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n     int code = find_value(objError, \"code\").get_int();\n-    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n-    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n+    if (code == RPC_INVALID_REQUEST)\n+        nStatus = HTTP_BAD_REQUEST;\n+    else if (code == RPC_METHOD_NOT_FOUND)\n+        nStatus = HTTP_NOT_FOUND;\n     string strReply = JSONRPCReply(Value::null, objError, id);\n     stream << HTTPReply(nStatus, strReply, false) << std::flush;\n }\n@@ -390,18 +383,13 @@ CNetAddr BoostAsioToCNetAddr(boost::asio::ip::address address)\n {\n     CNetAddr netaddr;\n     // Make sure that IPv4-compatible and IPv4-mapped IPv6 addresses are treated as IPv4 addresses\n-    if (address.is_v6()\n-     && (address.to_v6().is_v4_compatible()\n-      || address.to_v6().is_v4_mapped()))\n+    if (address.is_v6() && (address.to_v6().is_v4_compatible() || address.to_v6().is_v4_mapped()))\n         address = address.to_v6().to_v4();\n \n-    if(address.is_v4())\n-    {\n+    if (address.is_v4()) {\n         boost::asio::ip::address_v4::bytes_type bytes = address.to_v4().to_bytes();\n         netaddr.SetRaw(NET_IPV4, &bytes[0]);\n-    }\n-    else\n-    {\n+    } else {\n         boost::asio::ip::address_v6::bytes_type bytes = address.to_v6().to_bytes();\n         netaddr.SetRaw(NET_IPV6, &bytes[0]);\n     }\n@@ -411,7 +399,7 @@ CNetAddr BoostAsioToCNetAddr(boost::asio::ip::address address)\n bool ClientAllowed(const boost::asio::ip::address& address)\n {\n     CNetAddr netaddr = BoostAsioToCNetAddr(address);\n-    BOOST_FOREACH(const CSubNet &subnet, rpc_allow_subnets)\n+    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n         if (subnet.Match(netaddr))\n             return true;\n     return false;\n@@ -422,12 +410,11 @@ class AcceptedConnectionImpl : public AcceptedConnection\n {\n public:\n     AcceptedConnectionImpl(\n-            asio::io_service& io_service,\n-            ssl::context &context,\n-            bool fUseSSL) :\n-        sslStream(io_service, context),\n-        _d(sslStream, fUseSSL),\n-        _stream(_d)\n+        asio::io_service& io_service,\n+        ssl::context& context,\n+        bool fUseSSL) : sslStream(io_service, context),\n+                        _d(sslStream, fUseSSL),\n+                        _stream(_d)\n     {\n     }\n \n@@ -451,80 +438,77 @@ class AcceptedConnectionImpl : public AcceptedConnection\n \n private:\n     SSLIOStreamDevice<Protocol> _d;\n-    iostreams::stream< SSLIOStreamDevice<Protocol> > _stream;\n+    iostreams::stream<SSLIOStreamDevice<Protocol> > _stream;\n };\n \n-void ServiceConnection(AcceptedConnection *conn);\n+void ServiceConnection(AcceptedConnection* conn);\n \n //! Forward declaration required for RPCListen\n template <typename Protocol, typename SocketAcceptorService>\n-static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n+static void RPCAcceptHandler(boost::shared_ptr<basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                              ssl::context& context,\n                              bool fUseSSL,\n-                             boost::shared_ptr< AcceptedConnection > conn,\n+                             boost::shared_ptr<AcceptedConnection> conn,\n                              const boost::system::error_code& error);\n \n /**\n  * Sets up I/O resources to accept and handle a new connection.\n  */\n template <typename Protocol, typename SocketAcceptorService>\n-static void RPCListen(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n-                   ssl::context& context,\n-                   const bool fUseSSL)\n+static void RPCListen(boost::shared_ptr<basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n+                      ssl::context& context,\n+                      const bool fUseSSL)\n {\n     // Accept connection\n-    boost::shared_ptr< AcceptedConnectionImpl<Protocol> > conn(new AcceptedConnectionImpl<Protocol>(acceptor->get_io_service(), context, fUseSSL));\n+    boost::shared_ptr<AcceptedConnectionImpl<Protocol> > conn(new AcceptedConnectionImpl<Protocol>(acceptor->get_io_service(), context, fUseSSL));\n \n     acceptor->async_accept(\n-            conn->sslStream.lowest_layer(),\n-            conn->peer,\n-            boost::bind(&RPCAcceptHandler<Protocol, SocketAcceptorService>,\n-                acceptor,\n-                boost::ref(context),\n-                fUseSSL,\n-                conn,\n-                _1));\n+        conn->sslStream.lowest_layer(),\n+        conn->peer,\n+        boost::bind(&RPCAcceptHandler<Protocol, SocketAcceptorService>,\n+                    acceptor,\n+                    boost::ref(context),\n+                    fUseSSL,\n+                    conn,\n+                    _1));\n }\n \n \n /**\n  * Accept and handle incoming connection.\n  */\n template <typename Protocol, typename SocketAcceptorService>\n-static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n+static void RPCAcceptHandler(boost::shared_ptr<basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                              ssl::context& context,\n                              const bool fUseSSL,\n-                             boost::shared_ptr< AcceptedConnection > conn,\n+                             boost::shared_ptr<AcceptedConnection> conn,\n                              const boost::system::error_code& error)\n {\n     // Immediately start accepting new connections, except when we're cancelled or our socket is closed.\n     if (error != asio::error::operation_aborted && acceptor->is_open())\n         RPCListen(acceptor, context, fUseSSL);\n \n-    AcceptedConnectionImpl<ip::tcp>* tcp_conn = dynamic_cast< AcceptedConnectionImpl<ip::tcp>* >(conn.get());\n+    AcceptedConnectionImpl<ip::tcp>* tcp_conn = dynamic_cast<AcceptedConnectionImpl<ip::tcp>*>(conn.get());\n \n-    if (error)\n-    {\n+    if (error) {\n         // TODO: Actually handle errors\n         LogPrintf(\"%s: Error: %s\\n\", __func__, error.message());\n     }\n     // Restrict callers by IP.  It is important to\n     // do this before starting client thread, to filter out\n     // certain DoS and misbehaving clients.\n-    else if (tcp_conn && !ClientAllowed(tcp_conn->peer.address()))\n-    {\n+    else if (tcp_conn && !ClientAllowed(tcp_conn->peer.address())) {\n         // Only send a 403 if we're not using SSL to prevent a DoS during the SSL handshake.\n         if (!fUseSSL)\n             conn->stream() << HTTPError(HTTP_FORBIDDEN, false) << std::flush;\n         conn->close();\n-    }\n-    else {\n+    } else {\n         ServiceConnection(conn.get());\n         conn->close();\n     }\n }\n \n-static ip::tcp::endpoint ParseEndpoint(const std::string &strEndpoint, int defaultPort)\n+static ip::tcp::endpoint ParseEndpoint(const std::string& strEndpoint, int defaultPort)\n {\n     std::string addr;\n     int port = defaultPort;\n@@ -536,49 +520,48 @@ void StartRPCThreads()\n {\n     rpc_allow_subnets.clear();\n     rpc_allow_subnets.push_back(CSubNet(\"127.0.0.0/8\")); // always allow IPv4 local subnet\n-    rpc_allow_subnets.push_back(CSubNet(\"::1\")); // always allow IPv6 localhost\n-    if (mapMultiArgs.count(\"-rpcallowip\"))\n-    {\n+    rpc_allow_subnets.push_back(CSubNet(\"::1\"));         // always allow IPv6 localhost\n+    if (mapMultiArgs.count(\"-rpcallowip\")) {\n         const vector<string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n-        BOOST_FOREACH(string strAllow, vAllow)\n-        {\n+        BOOST_FOREACH (string strAllow, vAllow) {\n             CSubNet subnet(strAllow);\n-            if(!subnet.IsValid())\n-            {\n+            if (!subnet.IsValid()) {\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n+                    \"\",\n+                    CClientUIInterface::MSG_ERROR);\n                 StartShutdown();\n                 return;\n             }\n             rpc_allow_subnets.push_back(subnet);\n         }\n     }\n     std::string strAllowed;\n-    BOOST_FOREACH(const CSubNet &subnet, rpc_allow_subnets)\n+    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n         strAllowed += subnet.ToString() + \" \";\n     LogPrint(\"rpc\", \"Allowing RPC connections from: %s\\n\", strAllowed);\n \n     strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n     if (((mapArgs[\"-rpcpassword\"] == \"\") ||\n-         (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"])) && Params().RequireRPCPassword())\n-    {\n+         (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"])) &&\n+        Params().RequireRPCPassword()) {\n         unsigned char rand_pwd[32];\n         GetRandBytes(rand_pwd, 32);\n         uiInterface.ThreadSafeMessageBox(strprintf(\n-            _(\"To use bitcoind, or the -server option to bitcoin-qt, you must set an rpcpassword in the configuration file:\\n\"\n-              \"%s\\n\"\n-              \"It is recommended you use the following random password:\\n\"\n-              \"rpcuser=bitcoinrpc\\n\"\n-              \"rpcpassword=%s\\n\"\n-              \"(you do not need to remember this password)\\n\"\n-              \"The username and password MUST NOT be the same.\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n-              \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n-              \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n-                GetConfigFile().string(),\n-                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32)),\n-                \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::SECURE);\n+                                             _(\"To use bitcoind, or the -server option to bitcoin-qt, you must set an rpcpassword in the configuration file:\\n\"\n+                                               \"%s\\n\"\n+                                               \"It is recommended you use the following random password:\\n\"\n+                                               \"rpcuser=bitcoinrpc\\n\"\n+                                               \"rpcpassword=%s\\n\"\n+                                               \"(you do not need to remember this password)\\n\"\n+                                               \"The username and password MUST NOT be the same.\\n\"\n+                                               \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n+                                               \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n+                                               \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n+                                             GetConfigFile().string(),\n+                                             EncodeBase58(&rand_pwd[0], &rand_pwd[0] + 32)),\n+                                         \"\",\n+                                         CClientUIInterface::MSG_ERROR | CClientUIInterface::SECURE);\n         StartShutdown();\n         return;\n     }\n@@ -589,19 +572,24 @@ void StartRPCThreads()\n \n     const bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n \n-    if (fUseSSL)\n-    {\n+    if (fUseSSL) {\n         rpc_ssl_context->set_options(ssl::context::no_sslv2);\n \n         filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n-        if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n-        if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string());\n+        if (!pathCertFile.is_complete())\n+            pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n+        if (filesystem::exists(pathCertFile))\n+            rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n+        else\n+            LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string());\n \n         filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n-        if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n-        if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string());\n+        if (!pathPKFile.is_complete())\n+            pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n+        if (filesystem::exists(pathPKFile))\n+            rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n+        else\n+            LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string());\n \n         string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\");\n         SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n@@ -614,22 +602,19 @@ void StartRPCThreads()\n     {\n         vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v6::loopback(), defaultPort));\n         vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v4::loopback(), defaultPort));\n-        if (mapArgs.count(\"-rpcbind\"))\n-        {\n+        if (mapArgs.count(\"-rpcbind\")) {\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n         }\n     } else if (mapArgs.count(\"-rpcbind\")) // Specific bind address\n     {\n-        BOOST_FOREACH(const std::string &addr, mapMultiArgs[\"-rpcbind\"])\n-        {\n+        BOOST_FOREACH (const std::string& addr, mapMultiArgs[\"-rpcbind\"]) {\n             try {\n                 vEndpoints.push_back(ParseEndpoint(addr, defaultPort));\n-            }\n-            catch(const boost::system::system_error &)\n-            {\n+            } catch (const boost::system::system_error&) {\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(_(\"Could not parse -rpcbind value %s as network address\"), addr),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n+                    \"\",\n+                    CClientUIInterface::MSG_ERROR);\n                 StartShutdown();\n                 return;\n             }\n@@ -644,8 +629,7 @@ void StartRPCThreads()\n \n     bool fListening = false;\n     std::string strerr;\n-    BOOST_FOREACH(const ip::tcp::endpoint &endpoint, vEndpoints)\n-    {\n+    BOOST_FOREACH (const ip::tcp::endpoint& endpoint, vEndpoints) {\n         asio::ip::address bindAddress = endpoint.address();\n         LogPrintf(\"Binding RPC on address %s port %i (IPv4+IPv6 bind any: %i)\\n\", bindAddress.to_string(), endpoint.port(), bBindAny);\n         boost::system::error_code v6_only_error;\n@@ -657,7 +641,8 @@ void StartRPCThreads()\n \n             // Try making the socket dual IPv6/IPv4 when listening on the IPv6 \"any\" address\n             acceptor->set_option(boost::asio::ip::v6_only(\n-                !bBindAny || bindAddress != asio::ip::address_v6::any()), v6_only_error);\n+                                     !bBindAny || bindAddress != asio::ip::address_v6::any()),\n+                                 v6_only_error);\n \n             acceptor->bind(endpoint);\n             acceptor->listen(socket_base::max_connections);\n@@ -667,11 +652,9 @@ void StartRPCThreads()\n             fListening = true;\n             rpc_acceptors.push_back(acceptor);\n             // If dual IPv6/IPv4 bind successful, skip binding to IPv4 separately\n-            if(bBindAny && bindAddress == asio::ip::address_v6::any() && !v6_only_error)\n+            if (bBindAny && bindAddress == asio::ip::address_v6::any() && !v6_only_error)\n                 break;\n-        }\n-        catch(boost::system::system_error &e)\n-        {\n+        } catch (boost::system::system_error& e) {\n             LogPrintf(\"ERROR: Binding RPC on address %s port %i failed: %s\\n\", bindAddress.to_string(), endpoint.port(), e.what());\n             strerr = strprintf(_(\"An error occurred while setting up the RPC address %s port %u for listening: %s\"), bindAddress.to_string(), endpoint.port(), e.what());\n         }\n@@ -691,8 +674,7 @@ void StartRPCThreads()\n \n void StartDummyRPCThread()\n {\n-    if(rpc_io_service == NULL)\n-    {\n+    if (rpc_io_service == NULL) {\n         rpc_io_service = new asio::io_service();\n         /* Create dummy \"work\" to keep the thread from exiting when no timeouts active,\n          * see http://www.boost.org/doc/libs/1_51_0/doc/html/boost_asio/reference/io_service.html#boost_asio.reference.io_service.stopping_the_io_service_from_running_out_of_work */\n@@ -705,23 +687,22 @@ void StartDummyRPCThread()\n \n void StopRPCThreads()\n {\n-    if (rpc_io_service == NULL) return;\n+    if (rpc_io_service == NULL)\n+        return;\n     // Set this to false first, so that longpolling loops will exit when woken up\n     fRPCRunning = false;\n \n     // First, cancel all timers and acceptors\n     // This is not done automatically by ->stop(), and in some cases the destructor of\n     // asio::io_service can hang if this is skipped.\n     boost::system::error_code ec;\n-    BOOST_FOREACH(const boost::shared_ptr<ip::tcp::acceptor> &acceptor, rpc_acceptors)\n-    {\n+    BOOST_FOREACH (const boost::shared_ptr<ip::tcp::acceptor>& acceptor, rpc_acceptors) {\n         acceptor->cancel(ec);\n         if (ec)\n             LogPrintf(\"%s: Warning: %s when cancelling acceptor\", __func__, ec.message());\n     }\n     rpc_acceptors.clear();\n-    BOOST_FOREACH(const PAIRTYPE(std::string, boost::shared_ptr<deadline_timer>) &timer, deadlineTimers)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(std::string, boost::shared_ptr<deadline_timer>)&timer, deadlineTimers) {\n         timer.second->cancel(ec);\n         if (ec)\n             LogPrintf(\"%s: Warning: %s when cancelling timer\", __func__, ec.message());\n@@ -732,10 +713,14 @@ void StopRPCThreads()\n     cvBlockChange.notify_all();\n     if (rpc_worker_group != NULL)\n         rpc_worker_group->join_all();\n-    delete rpc_dummy_work; rpc_dummy_work = NULL;\n-    delete rpc_worker_group; rpc_worker_group = NULL;\n-    delete rpc_ssl_context; rpc_ssl_context = NULL;\n-    delete rpc_io_service; rpc_io_service = NULL;\n+    delete rpc_dummy_work;\n+    rpc_dummy_work = NULL;\n+    delete rpc_worker_group;\n+    rpc_worker_group = NULL;\n+    delete rpc_ssl_context;\n+    rpc_ssl_context = NULL;\n+    delete rpc_io_service;\n+    rpc_io_service = NULL;\n }\n \n bool IsRPCRunning()\n@@ -756,7 +741,7 @@ void SetRPCWarmupFinished()\n     fRPCInWarmup = false;\n }\n \n-bool RPCIsInWarmup(std::string *outStatus)\n+bool RPCIsInWarmup(std::string* outStatus)\n {\n     LOCK(cs_rpcWarmup);\n     if (outStatus)\n@@ -774,8 +759,7 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n {\n     assert(rpc_io_service != NULL);\n \n-    if (deadlineTimers.count(name) == 0)\n-    {\n+    if (deadlineTimers.count(name) == 0) {\n         deadlineTimers.insert(make_pair(name,\n                                         boost::shared_ptr<deadline_timer>(new deadline_timer(*rpc_io_service))));\n     }\n@@ -835,15 +819,12 @@ static Object JSONRPCExecOne(const Value& req)\n \n         Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n         rpc_result = JSONRPCReplyObj(result, Value::null, jreq.id);\n-    }\n-    catch (Object& objError)\n-    {\n+    } catch (Object& objError) {\n         rpc_result = JSONRPCReplyObj(Value::null, objError, jreq.id);\n-    }\n-    catch (std::exception& e)\n-    {\n+    } catch (std::exception& e) {\n         rpc_result = JSONRPCReplyObj(Value::null,\n-                                     JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n+                                     JSONRPCError(RPC_PARSE_ERROR, e.what()),\n+                                     jreq.id);\n     }\n \n     return rpc_result;\n@@ -858,20 +839,18 @@ static string JSONRPCExecBatch(const Array& vReq)\n     return write_string(Value(ret), false) + \"\\n\";\n }\n \n-static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n+static bool HTTPReq_JSONRPC(AcceptedConnection* conn,\n                             string& strRequest,\n                             map<string, string>& mapHeaders,\n                             bool fRun)\n {\n     // Check authorization\n-    if (mapHeaders.count(\"authorization\") == 0)\n-    {\n+    if (mapHeaders.count(\"authorization\") == 0) {\n         conn->stream() << HTTPError(HTTP_UNAUTHORIZED, false) << std::flush;\n         return false;\n     }\n \n-    if (!HTTPAuthorized(mapHeaders))\n-    {\n+    if (!HTTPAuthorized(mapHeaders)) {\n         LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string());\n         /* Deter brute-forcing\n            If this results in a DoS the user really\n@@ -883,8 +862,7 @@ static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n     }\n \n     JSONRequest jreq;\n-    try\n-    {\n+    try {\n         // Parse request\n         Value valRequest;\n         if (!read_string(strRequest, valRequest))\n@@ -908,32 +886,27 @@ static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n             // Send reply\n             strReply = JSONRPCReply(result, Value::null, jreq.id);\n \n-        // array of requests\n+            // array of requests\n         } else if (valRequest.type() == array_type)\n             strReply = JSONRPCExecBatch(valRequest.get_array());\n         else\n             throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n \n         conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, strReply.size()) << strReply << std::flush;\n-    }\n-    catch (Object& objError)\n-    {\n+    } catch (Object& objError) {\n         ErrorReply(conn->stream(), objError, jreq.id);\n         return false;\n-    }\n-    catch (std::exception& e)\n-    {\n+    } catch (std::exception& e) {\n         ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n         return false;\n     }\n     return true;\n }\n \n-void ServiceConnection(AcceptedConnection *conn)\n+void ServiceConnection(AcceptedConnection* conn)\n {\n     bool fRun = true;\n-    while (fRun && !ShutdownRequested())\n-    {\n+    while (fRun && !ShutdownRequested()) {\n         int nProto = 0;\n         map<string, string> mapHeaders;\n         string strRequest, strMethod, strURI;\n@@ -954,7 +927,7 @@ void ServiceConnection(AcceptedConnection *conn)\n             if (!HTTPReq_JSONRPC(conn, strRequest, mapHeaders, fRun))\n                 break;\n \n-        // Process via HTTP REST API\n+            // Process via HTTP REST API\n         } else if (strURI.substr(0, 6) == \"/rest/\" && GetBoolArg(\"-rest\", false)) {\n             if (!HTTPReq_REST(conn, strURI, mapHeaders, fRun))\n                 break;\n@@ -966,10 +939,10 @@ void ServiceConnection(AcceptedConnection *conn)\n     }\n }\n \n-json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_spirit::Array &params) const\n+json_spirit::Value CRPCTable::execute(const std::string& strMethod, const json_spirit::Array& params) const\n {\n     // Find method\n-    const CRPCCommand *pcmd = tableRPC[strMethod];\n+    const CRPCCommand* pcmd = tableRPC[strMethod];\n     if (!pcmd)\n         throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n #ifdef ENABLE_WALLET\n@@ -983,8 +956,7 @@ json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_s\n         !pcmd->okSafeMode)\n         throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n \n-    try\n-    {\n+    try {\n         // Execute\n         Value result;\n         {\n@@ -998,28 +970,29 @@ json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_s\n                 LOCK2(cs_main, pwalletMain->cs_wallet);\n                 result = pcmd->actor(params, false);\n             }\n-#else // ENABLE_WALLET\n+#else  // ENABLE_WALLET\n             else {\n                 LOCK(cs_main);\n                 result = pcmd->actor(params, false);\n             }\n #endif // !ENABLE_WALLET\n         }\n         return result;\n-    }\n-    catch (std::exception& e)\n-    {\n+    } catch (std::exception& e) {\n         throw JSONRPCError(RPC_MISC_ERROR, e.what());\n     }\n }\n \n-std::string HelpExampleCli(string methodname, string args){\n+std::string HelpExampleCli(string methodname, string args)\n+{\n     return \"> bitcoin-cli \" + methodname + \" \" + args + \"\\n\";\n }\n \n-std::string HelpExampleRpc(string methodname, string args){\n+std::string HelpExampleRpc(string methodname, string args)\n+{\n     return \"> curl --user myusername --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\":\\\"curltest\\\", \"\n-        \"\\\"method\\\": \\\"\" + methodname + \"\\\", \\\"params\\\": [\" + args + \"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\";\n+           \"\\\"method\\\": \\\"\" +\n+           methodname + \"\\\", \\\"params\\\": [\" + args + \"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\";\n }\n \n const CRPCTable tableRPC;"
      },
      {
        "sha": "69b0f421cafffad203bab75d1614c56d6c58b96e",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 277,
        "deletions": 424,
        "changes": 701,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -31,9 +31,7 @@ static CCriticalSection cs_nWalletUnlockTime;\n \n std::string HelpRequiringPassphrase()\n {\n-    return pwalletMain && pwalletMain->IsCrypted()\n-        ? \"\\nRequires wallet passphrase to be set with walletpassphrase call.\"\n-        : \"\";\n+    return pwalletMain && pwalletMain->IsCrypted() ? \"\\nRequires wallet passphrase to be set with walletpassphrase call.\" : \"\";\n }\n \n void EnsureWalletIsUnlocked()\n@@ -48,21 +46,20 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n     entry.push_back(Pair(\"confirmations\", confirms));\n     if (wtx.IsCoinBase())\n         entry.push_back(Pair(\"generated\", true));\n-    if (confirms > 0)\n-    {\n+    if (confirms > 0) {\n         entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n         entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n         entry.push_back(Pair(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime()));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.push_back(Pair(\"txid\", hash.GetHex()));\n     Array conflicts;\n-    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts())\n+    BOOST_FOREACH (const uint256& conflict, wtx.GetConflicts())\n         conflicts.push_back(conflict.GetHex());\n     entry.push_back(Pair(\"walletconflicts\", conflicts));\n     entry.push_back(Pair(\"time\", wtx.GetTxTime()));\n     entry.push_back(Pair(\"timereceived\", (int64_t)wtx.nTimeReceived));\n-    BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n+    BOOST_FOREACH (const PAIRTYPE(string, string) & item, wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n@@ -86,12 +83,8 @@ Value getnewaddress(const Array& params, bool fHelp)\n             \"1. \\\"account\\\"        (string, optional) The account name for the address to be linked to. if not provided, the default account \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getnewaddress\", \"\")\n-            + HelpExampleCli(\"getnewaddress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getnewaddress\", \"\\\"myaccount\\\"\")\n-            + HelpExampleRpc(\"getnewaddress\", \"\\\"myaccount\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getnewaddress\", \"\") + HelpExampleCli(\"getnewaddress\", \"\\\"\\\"\") + HelpExampleCli(\"getnewaddress\", \"\\\"myaccount\\\"\") + HelpExampleRpc(\"getnewaddress\", \"\\\"myaccount\\\"\"));\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount;\n@@ -113,7 +106,7 @@ Value getnewaddress(const Array& params, bool fHelp)\n }\n \n \n-CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n+CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew = false)\n {\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n \n@@ -123,23 +116,20 @@ CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n     bool bKeyUsed = false;\n \n     // Check if the current key has been used\n-    if (account.vchPubKey.IsValid())\n-    {\n+    if (account.vchPubKey.IsValid()) {\n         CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID());\n         for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n              it != pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n-             ++it)\n-        {\n+             ++it) {\n             const CWalletTx& wtx = (*it).second;\n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            BOOST_FOREACH (const CTxOut& txout, wtx.vout)\n                 if (txout.scriptPubKey == scriptPubKey)\n                     bKeyUsed = true;\n         }\n     }\n \n     // Generate a new key\n-    if (!account.vchPubKey.IsValid() || bForceNew || bKeyUsed)\n-    {\n+    if (!account.vchPubKey.IsValid() || bForceNew || bKeyUsed) {\n         if (!pwalletMain->GetKeyFromPool(account.vchPubKey))\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n \n@@ -160,12 +150,8 @@ Value getaccountaddress(const Array& params, bool fHelp)\n             \"1. \\\"account\\\"       (string, required) The account name for the address. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"bitcoinaddress\\\"   (string) The account bitcoin address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccountaddress\", \"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-            + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getaccountaddress\", \"\") + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\") + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\") + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\"));\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount = AccountFromValue(params[0]);\n@@ -187,10 +173,8 @@ Value getrawchangeaddress(const Array& params, bool fHelp)\n             \"This is for use with raw transactions, NOT normal use.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"address\\\"    (string) The address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getrawchangeaddress\", \"\")\n-            + HelpExampleRpc(\"getrawchangeaddress\", \"\")\n-       );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getrawchangeaddress\", \"\") + HelpExampleRpc(\"getrawchangeaddress\", \"\"));\n \n     if (!pwalletMain->IsLocked())\n         pwalletMain->TopUpKeyPool();\n@@ -217,10 +201,8 @@ Value setaccount(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to be associated with an account.\\n\"\n             \"2. \\\"account\\\"         (string, required) The account to assign the address to.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"tabby\\\"\")\n-            + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"tabby\\\"\") + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\"));\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n@@ -232,18 +214,15 @@ Value setaccount(const Array& params, bool fHelp)\n         strAccount = AccountFromValue(params[1]);\n \n     // Only add the account if the address is yours.\n-    if (IsMine(*pwalletMain, address.Get()))\n-    {\n+    if (IsMine(*pwalletMain, address.Get())) {\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n-        if (pwalletMain->mapAddressBook.count(address.Get()))\n-        {\n+        if (pwalletMain->mapAddressBook.count(address.Get())) {\n             string strOldAccount = pwalletMain->mapAddressBook[address.Get()].name;\n             if (address == GetAccountAddress(strOldAccount))\n                 GetAccountAddress(strOldAccount, true);\n         }\n         pwalletMain->SetAddressBook(address.Get(), strAccount, \"receive\");\n-    }\n-    else\n+    } else\n         throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n \n     return Value::null;\n@@ -260,10 +239,8 @@ Value getaccount(const Array& params, bool fHelp)\n             \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address for account lookup.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"accountname\\\"        (string) the account address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n-            + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\") + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\"));\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n@@ -290,17 +267,14 @@ Value getaddressesbyaccount(const Array& params, bool fHelp)\n             \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address associated with the given account\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n-            + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\") + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\"));\n \n     string strAccount = AccountFromValue(params[0]);\n \n     // Find all addresses that have the given account\n     Array ret;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(CBitcoinAddress, CAddressBookData) & item, pwalletMain->mapAddressBook) {\n         const CBitcoinAddress& address = item.first;\n         const string& strName = item.second.name;\n         if (strName == strAccount)\n@@ -314,8 +288,8 @@ Value sendtoaddress(const Array& params, bool fHelp)\n     if (fHelp || params.size() < 2 || params.size() > 4)\n         throw runtime_error(\n             \"sendtoaddress \\\"bitcoinaddress\\\" amount ( \\\"comment\\\" \\\"comment-to\\\" )\\n\"\n-            \"\\nSend an amount to a given address. The amount is a real and is rounded to the nearest 0.00000001\\n\"\n-            + HelpRequiringPassphrase() +\n+            \"\\nSend an amount to a given address. The amount is a real and is rounded to the nearest 0.00000001\\n\" +\n+            HelpRequiringPassphrase() +\n             \"\\nArguments:\\n\"\n             \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to send to.\\n\"\n             \"2. \\\"amount\\\"      (numeric, required) The amount in btc to send. eg 0.1\\n\"\n@@ -326,11 +300,8 @@ Value sendtoaddress(const Array& params, bool fHelp)\n             \"                             transaction, just kept in your wallet.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"transactionid\\\"  (string) The transaction id.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1\")\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1 \\\"donation\\\" \\\"seans outpost\\\"\")\n-            + HelpExampleRpc(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.1, \\\"donation\\\", \\\"seans outpost\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1\") + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1 \\\"donation\\\" \\\"seans outpost\\\"\") + HelpExampleRpc(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.1, \\\"donation\\\", \\\"seans outpost\\\"\"));\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n@@ -344,7 +315,7 @@ Value sendtoaddress(const Array& params, bool fHelp)\n     if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n         wtx.mapValue[\"comment\"] = params[2].get_str();\n     if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[3].get_str();\n+        wtx.mapValue[\"to\"] = params[3].get_str();\n \n     EnsureWalletIsUnlocked();\n \n@@ -375,18 +346,14 @@ Value listaddressgroupings(const Array& params, bool fHelp)\n             \"  ]\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listaddressgroupings\", \"\")\n-            + HelpExampleRpc(\"listaddressgroupings\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"listaddressgroupings\", \"\") + HelpExampleRpc(\"listaddressgroupings\", \"\"));\n \n     Array jsonGroupings;\n     map<CTxDestination, CAmount> balances = pwalletMain->GetAddressBalances();\n-    BOOST_FOREACH(set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n-    {\n+    BOOST_FOREACH (set<CTxDestination> grouping, pwalletMain->GetAddressGroupings()) {\n         Array jsonGrouping;\n-        BOOST_FOREACH(CTxDestination address, grouping)\n-        {\n+        BOOST_FOREACH (CTxDestination address, grouping) {\n             Array addressInfo;\n             addressInfo.push_back(CBitcoinAddress(address).ToString());\n             addressInfo.push_back(ValueFromAmount(balances[address]));\n@@ -407,23 +374,19 @@ Value signmessage(const Array& params, bool fHelp)\n     if (fHelp || params.size() != 2)\n         throw runtime_error(\n             \"signmessage \\\"bitcoinaddress\\\" \\\"message\\\"\\n\"\n-            \"\\nSign a message with the private key of an address\"\n-            + HelpRequiringPassphrase() + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to use for the private key.\\n\"\n-            \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nUnlock the wallet for 30 seconds\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n-            \"\\nCreate the signature\\n\"\n-            + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"my message\\\"\") +\n-            \"\\nVerify the signature\\n\"\n-            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"signature\\\" \\\"my message\\\"\") +\n-            \"\\nAs json rpc\\n\"\n-            + HelpExampleRpc(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"my message\\\"\")\n-        );\n+            \"\\nSign a message with the private key of an address\" +\n+            HelpRequiringPassphrase() + \"\\n\"\n+                                        \"\\nArguments:\\n\"\n+                                        \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to use for the private key.\\n\"\n+                                        \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n+                                        \"\\nResult:\\n\"\n+                                        \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n+                                        \"\\nExamples:\\n\"\n+                                        \"\\nUnlock the wallet for 30 seconds\\n\" +\n+            HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n+            \"\\nCreate the signature\\n\" + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"my message\\\"\") +\n+            \"\\nVerify the signature\\n\" + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"signature\\\" \\\"my message\\\"\") +\n+            \"\\nAs json rpc\\n\" + HelpExampleRpc(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"my message\\\"\"));\n \n     EnsureWalletIsUnlocked();\n \n@@ -465,22 +428,18 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"amount   (numeric) The total amount in btc received at this address.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nThe amount from transactions with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\") +\n-            \"\\nThe amount including unconfirmed transactions, zero confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" 0\") +\n-            \"\\nThe amount with at least 6 confirmation, very safe\\n\"\n-            + HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" 6\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", 6\")\n-       );\n+            \"\\nThe amount from transactions with at least 1 confirmation\\n\" +\n+            HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\") +\n+            \"\\nThe amount including unconfirmed transactions, zero confirmations\\n\" + HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" 0\") +\n+            \"\\nThe amount with at least 6 confirmation, very safe\\n\" + HelpExampleCli(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" 6\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", 6\"));\n \n     // Bitcoin address\n     CBitcoinAddress address = CBitcoinAddress(params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     CScript scriptPubKey = GetScriptForDestination(address.Get());\n-    if (!IsMine(*pwalletMain,scriptPubKey))\n+    if (!IsMine(*pwalletMain, scriptPubKey))\n         return (double)0.0;\n \n     // Minimum confirmations\n@@ -490,19 +449,18 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !IsFinalTx(wtx))\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        BOOST_FOREACH (const CTxOut& txout, wtx.vout)\n             if (txout.scriptPubKey == scriptPubKey)\n                 if (wtx.GetDepthInMainChain() >= nMinDepth)\n                     nAmount += txout.nValue;\n     }\n \n-    return  ValueFromAmount(nAmount);\n+    return ValueFromAmount(nAmount);\n }\n \n \n@@ -518,15 +476,11 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in btc received for this account.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nAmount received by the default account with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"\\\"\") +\n-            \"\\nAmount received at the tabby account including unconfirmed amounts with zero confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 0\") +\n-            \"\\nThe amount with at least 6 confirmation, very safe\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 6\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n-        );\n+            \"\\nAmount received by the default account with at least 1 confirmation\\n\" +\n+            HelpExampleCli(\"getreceivedbyaccount\", \"\\\"\\\"\") +\n+            \"\\nAmount received at the tabby account including unconfirmed amounts with zero confirmations\\n\" + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 0\") +\n+            \"\\nThe amount with at least 6 confirmation, very safe\\n\" + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 6\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\"));\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -539,14 +493,12 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !IsFinalTx(wtx))\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n+        BOOST_FOREACH (const CTxOut& txout, wtx.vout) {\n             CTxDestination address;\n             if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))\n                 if (wtx.GetDepthInMainChain() >= nMinDepth)\n@@ -563,8 +515,7 @@ CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     CAmount nBalance = 0;\n \n     // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n         const CWalletTx& wtx = (*it).second;\n         if (!IsFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n             continue;\n@@ -606,36 +557,30 @@ Value getbalance(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in btc received for this account.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nThe total amount in the server across all accounts\\n\"\n-            + HelpExampleCli(\"getbalance\", \"\") +\n-            \"\\nThe total amount in the server across all accounts, with at least 5 confirmations\\n\"\n-            + HelpExampleCli(\"getbalance\", \"\\\"*\\\" 6\") +\n-            \"\\nThe total amount in the default account with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getbalance\", \"\\\"\\\"\") +\n-            \"\\nThe total amount in the account named tabby with at least 6 confirmations\\n\"\n-            + HelpExampleCli(\"getbalance\", \"\\\"tabby\\\" 6\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getbalance\", \"\\\"tabby\\\", 6\")\n-        );\n+            \"\\nThe total amount in the server across all accounts\\n\" +\n+            HelpExampleCli(\"getbalance\", \"\") +\n+            \"\\nThe total amount in the server across all accounts, with at least 5 confirmations\\n\" + HelpExampleCli(\"getbalance\", \"\\\"*\\\" 6\") +\n+            \"\\nThe total amount in the default account with at least 1 confirmation\\n\" + HelpExampleCli(\"getbalance\", \"\\\"\\\"\") +\n+            \"\\nThe total amount in the account named tabby with at least 6 confirmations\\n\" + HelpExampleCli(\"getbalance\", \"\\\"tabby\\\" 6\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"getbalance\", \"\\\"tabby\\\", 6\"));\n \n     if (params.size() == 0)\n-        return  ValueFromAmount(pwalletMain->GetBalance());\n+        return ValueFromAmount(pwalletMain->GetBalance());\n \n     int nMinDepth = 1;\n     if (params.size() > 1)\n         nMinDepth = params[1].get_int();\n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 2)\n-        if(params[2].get_bool())\n+    if (params.size() > 2)\n+        if (params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     if (params[0].get_str() == \"*\") {\n         // Calculate total balance a different way from GetBalance()\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and getbalance '*' 0 should return the same number\n         CAmount nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n             const CWalletTx& wtx = (*it).second;\n             if (!wtx.IsTrusted() || wtx.GetBlocksToMaturity() > 0)\n                 continue;\n@@ -645,16 +590,15 @@ Value getbalance(const Array& params, bool fHelp)\n             list<COutputEntry> listReceived;\n             list<COutputEntry> listSent;\n             wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n-            if (wtx.GetDepthInMainChain() >= nMinDepth)\n-            {\n-                BOOST_FOREACH(const COutputEntry& r, listReceived)\n+            if (wtx.GetDepthInMainChain() >= nMinDepth) {\n+                BOOST_FOREACH (const COutputEntry& r, listReceived)\n                     nBalance += r.amount;\n             }\n-            BOOST_FOREACH(const COutputEntry& s, listSent)\n+            BOOST_FOREACH (const COutputEntry& s, listSent)\n                 nBalance -= s.amount;\n             nBalance -= allFee;\n         }\n-        return  ValueFromAmount(nBalance);\n+        return ValueFromAmount(nBalance);\n     }\n \n     string strAccount = AccountFromValue(params[0]);\n@@ -664,12 +608,12 @@ Value getbalance(const Array& params, bool fHelp)\n     return ValueFromAmount(nBalance);\n }\n \n-Value getunconfirmedbalance(const Array &params, bool fHelp)\n+Value getunconfirmedbalance(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 0)\n         throw runtime_error(\n-                \"getunconfirmedbalance\\n\"\n-                \"Returns the server's total unconfirmed balance\\n\");\n+            \"getunconfirmedbalance\\n\"\n+            \"Returns the server's total unconfirmed balance\\n\");\n     return ValueFromAmount(pwalletMain->GetUnconfirmedBalance());\n }\n \n@@ -688,13 +632,10 @@ Value movecmd(const Array& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"true|false           (boolean) true if successfull.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nMove 0.01 btc from the default account to the account named tabby\\n\"\n-            + HelpExampleCli(\"move\", \"\\\"\\\" \\\"tabby\\\" 0.01\") +\n-            \"\\nMove 0.01 btc timotei to akiko with a comment and funds have 6 confirmations\\n\"\n-            + HelpExampleCli(\"move\", \"\\\"timotei\\\" \\\"akiko\\\" 0.01 6 \\\"happy birthday!\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"move\", \"\\\"timotei\\\", \\\"akiko\\\", 0.01, 6, \\\"happy birthday!\\\"\")\n-        );\n+            \"\\nMove 0.01 btc from the default account to the account named tabby\\n\" +\n+            HelpExampleCli(\"move\", \"\\\"\\\" \\\"tabby\\\" 0.01\") +\n+            \"\\nMove 0.01 btc timotei to akiko with a comment and funds have 6 confirmations\\n\" + HelpExampleCli(\"move\", \"\\\"timotei\\\" \\\"akiko\\\" 0.01 6 \\\"happy birthday!\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"move\", \"\\\"timotei\\\", \\\"akiko\\\", 0.01, 6, \\\"happy birthday!\\\"\"));\n \n     string strFrom = AccountFromValue(params[0]);\n     string strTo = AccountFromValue(params[1]);\n@@ -745,28 +686,25 @@ Value sendfrom(const Array& params, bool fHelp)\n         throw runtime_error(\n             \"sendfrom \\\"fromaccount\\\" \\\"tobitcoinaddress\\\" amount ( minconf \\\"comment\\\" \\\"comment-to\\\" )\\n\"\n             \"\\nSent an amount from an account to a bitcoin address.\\n\"\n-            \"The amount is a real and is rounded to the nearest 0.00000001.\"\n-            + HelpRequiringPassphrase() + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"fromaccount\\\"       (string, required) The name of the account to send funds from. May be the default account using \\\"\\\".\\n\"\n-            \"2. \\\"tobitcoinaddress\\\"  (string, required) The bitcoin address to send funds to.\\n\"\n-            \"3. amount                (numeric, required) The amount in btc. (transaction fee is added on top).\\n\"\n-            \"4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.\\n\"\n-            \"5. \\\"comment\\\"           (string, optional) A comment used to store what the transaction is for. \\n\"\n-            \"                                     This is not part of the transaction, just kept in your wallet.\\n\"\n-            \"6. \\\"comment-to\\\"        (string, optional) An optional comment to store the name of the person or organization \\n\"\n-            \"                                     to which you're sending the transaction. This is not part of the transaction, \\n\"\n-            \"                                     it is just kept in your wallet.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transactionid\\\"        (string) The transaction id.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nSend 0.01 btc from the default account to the address, must have at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"sendfrom\", \"\\\"\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01\") +\n-            \"\\nSend 0.01 from the tabby account to the given address, funds must have at least 6 confirmations\\n\"\n-            + HelpExampleCli(\"sendfrom\", \"\\\"tabby\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01 6 \\\"donation\\\" \\\"seans outpost\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendfrom\", \"\\\"tabby\\\", \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.01, 6, \\\"donation\\\", \\\"seans outpost\\\"\")\n-        );\n+            \"The amount is a real and is rounded to the nearest 0.00000001.\" +\n+            HelpRequiringPassphrase() + \"\\n\"\n+                                        \"\\nArguments:\\n\"\n+                                        \"1. \\\"fromaccount\\\"       (string, required) The name of the account to send funds from. May be the default account using \\\"\\\".\\n\"\n+                                        \"2. \\\"tobitcoinaddress\\\"  (string, required) The bitcoin address to send funds to.\\n\"\n+                                        \"3. amount                (numeric, required) The amount in btc. (transaction fee is added on top).\\n\"\n+                                        \"4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.\\n\"\n+                                        \"5. \\\"comment\\\"           (string, optional) A comment used to store what the transaction is for. \\n\"\n+                                        \"                                     This is not part of the transaction, just kept in your wallet.\\n\"\n+                                        \"6. \\\"comment-to\\\"        (string, optional) An optional comment to store the name of the person or organization \\n\"\n+                                        \"                                     to which you're sending the transaction. This is not part of the transaction, \\n\"\n+                                        \"                                     it is just kept in your wallet.\\n\"\n+                                        \"\\nResult:\\n\"\n+                                        \"\\\"transactionid\\\"        (string) The transaction id.\\n\"\n+                                        \"\\nExamples:\\n\"\n+                                        \"\\nSend 0.01 btc from the default account to the address, must have at least 1 confirmation\\n\" +\n+            HelpExampleCli(\"sendfrom\", \"\\\"\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01\") +\n+            \"\\nSend 0.01 from the tabby account to the given address, funds must have at least 6 confirmations\\n\" + HelpExampleCli(\"sendfrom\", \"\\\"tabby\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01 6 \\\"donation\\\" \\\"seans outpost\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"sendfrom\", \"\\\"tabby\\\", \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.01, 6, \\\"donation\\\", \\\"seans outpost\\\"\"));\n \n     string strAccount = AccountFromValue(params[0]);\n     CBitcoinAddress address(params[1].get_str());\n@@ -782,7 +720,7 @@ Value sendfrom(const Array& params, bool fHelp)\n     if (params.size() > 4 && params[4].type() != null_type && !params[4].get_str().empty())\n         wtx.mapValue[\"comment\"] = params[4].get_str();\n     if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[5].get_str();\n+        wtx.mapValue[\"to\"] = params[5].get_str();\n \n     EnsureWalletIsUnlocked();\n \n@@ -805,28 +743,25 @@ Value sendmany(const Array& params, bool fHelp)\n     if (fHelp || params.size() < 2 || params.size() > 4)\n         throw runtime_error(\n             \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" )\\n\"\n-            \"\\nSend multiple times. Amounts are double-precision floating point numbers.\"\n-            + HelpRequiringPassphrase() + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"fromaccount\\\"         (string, required) The account to send the funds from, can be \\\"\\\" for the default account\\n\"\n-            \"2. \\\"amounts\\\"             (string, required) A json object with addresses and amounts\\n\"\n-            \"    {\\n\"\n-            \"      \\\"address\\\":amount   (numeric) The bitcoin address is the key, the numeric amount in btc is the value\\n\"\n-            \"      ,...\\n\"\n-            \"    }\\n\"\n-            \"3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\\n\"\n-            \"4. \\\"comment\\\"             (string, optional) A comment\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transactionid\\\"          (string) The transaction id for the send. Only 1 transaction is created regardless of \\n\"\n-            \"                                    the number of addresses.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nSend two amounts to two different addresses:\\n\"\n-            + HelpExampleCli(\"sendmany\", \"\\\"tabby\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\"\") +\n-            \"\\nSend two amounts to two different addresses setting the confirmation and comment:\\n\"\n-            + HelpExampleCli(\"sendmany\", \"\\\"tabby\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 6 \\\"testing\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendmany\", \"\\\"tabby\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\")\n-        );\n+            \"\\nSend multiple times. Amounts are double-precision floating point numbers.\" +\n+            HelpRequiringPassphrase() + \"\\n\"\n+                                        \"\\nArguments:\\n\"\n+                                        \"1. \\\"fromaccount\\\"         (string, required) The account to send the funds from, can be \\\"\\\" for the default account\\n\"\n+                                        \"2. \\\"amounts\\\"             (string, required) A json object with addresses and amounts\\n\"\n+                                        \"    {\\n\"\n+                                        \"      \\\"address\\\":amount   (numeric) The bitcoin address is the key, the numeric amount in btc is the value\\n\"\n+                                        \"      ,...\\n\"\n+                                        \"    }\\n\"\n+                                        \"3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\\n\"\n+                                        \"4. \\\"comment\\\"             (string, optional) A comment\\n\"\n+                                        \"\\nResult:\\n\"\n+                                        \"\\\"transactionid\\\"          (string) The transaction id for the send. Only 1 transaction is created regardless of \\n\"\n+                                        \"                                    the number of addresses.\\n\"\n+                                        \"\\nExamples:\\n\"\n+                                        \"\\nSend two amounts to two different addresses:\\n\" +\n+            HelpExampleCli(\"sendmany\", \"\\\"tabby\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\"\") +\n+            \"\\nSend two amounts to two different addresses setting the confirmation and comment:\\n\" + HelpExampleCli(\"sendmany\", \"\\\"tabby\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 6 \\\"testing\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"sendmany\", \"\\\"tabby\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\"));\n \n     string strAccount = AccountFromValue(params[0]);\n     Object sendTo = params[1].get_obj();\n@@ -843,14 +778,13 @@ Value sendmany(const Array& params, bool fHelp)\n     vector<pair<CScript, CAmount> > vecSend;\n \n     CAmount totalAmount = 0;\n-    BOOST_FOREACH(const Pair& s, sendTo)\n-    {\n+    BOOST_FOREACH (const Pair& s, sendTo) {\n         CBitcoinAddress address(s.name_);\n         if (!address.IsValid())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+s.name_);\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \") + s.name_);\n \n         if (setAddress.count(address))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+s.name_);\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \") + s.name_);\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -885,31 +819,28 @@ extern CScript _createmultisig_redeemScript(const Array& params);\n \n Value addmultisigaddress(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 2 || params.size() > 3)\n-    {\n+    if (fHelp || params.size() < 2 || params.size() > 3) {\n         string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n-            \"\\nAdd a nrequired-to-sign multisignature address to the wallet.\\n\"\n-            \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n-            \"If 'account' is specified, assign address to that account.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. nrequired        (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keysobject\\\"   (string, required) A json array of bitcoin addresses or hex-encoded public keys\\n\"\n-            \"     [\\n\"\n-            \"       \\\"address\\\"  (string) bitcoin address or hex-encoded public key\\n\"\n-            \"       ...,\\n\"\n-            \"     ]\\n\"\n-            \"3. \\\"account\\\"      (string, optional) An account to assign the addresses to.\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"\\\"bitcoinaddress\\\"  (string) A bitcoin address associated with the keys.\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            \"\\nAdd a multisig address from 2 addresses\\n\"\n-            + HelpExampleCli(\"addmultisigaddress\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n-            \"\\nAs json rpc call\\n\"\n-            + HelpExampleRpc(\"addmultisigaddress\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n-        ;\n+                     \"\\nAdd a nrequired-to-sign multisignature address to the wallet.\\n\"\n+                     \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n+                     \"If 'account' is specified, assign address to that account.\\n\"\n+\n+                     \"\\nArguments:\\n\"\n+                     \"1. nrequired        (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n+                     \"2. \\\"keysobject\\\"   (string, required) A json array of bitcoin addresses or hex-encoded public keys\\n\"\n+                     \"     [\\n\"\n+                     \"       \\\"address\\\"  (string) bitcoin address or hex-encoded public key\\n\"\n+                     \"       ...,\\n\"\n+                     \"     ]\\n\"\n+                     \"3. \\\"account\\\"      (string, optional) An account to assign the addresses to.\\n\"\n+\n+                     \"\\nResult:\\n\"\n+                     \"\\\"bitcoinaddress\\\"  (string) A bitcoin address associated with the keys.\\n\"\n+\n+                     \"\\nExamples:\\n\"\n+                     \"\\nAdd a multisig address from 2 addresses\\n\" +\n+                     HelpExampleCli(\"addmultisigaddress\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n+                     \"\\nAs json rpc call\\n\" + HelpExampleRpc(\"addmultisigaddress\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\");\n         throw runtime_error(msg);\n     }\n \n@@ -954,14 +885,13 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         fIncludeEmpty = params[1].get_bool();\n \n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 2)\n-        if(params[2].get_bool())\n+    if (params.size() > 2)\n+        if (params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     // Tally\n     map<CBitcoinAddress, tallyitem> mapTally;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n         const CWalletTx& wtx = (*it).second;\n \n         if (wtx.IsCoinBase() || !IsFinalTx(wtx))\n@@ -971,14 +901,13 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         if (nDepth < nMinDepth)\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n+        BOOST_FOREACH (const CTxOut& txout, wtx.vout) {\n             CTxDestination address;\n             if (!ExtractDestination(txout.scriptPubKey, address))\n                 continue;\n \n             isminefilter mine = IsMine(*pwalletMain, address);\n-            if(!(mine & filter))\n+            if (!(mine & filter))\n                 continue;\n \n             tallyitem& item = mapTally[address];\n@@ -993,8 +922,7 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     // Reply\n     Array ret;\n     map<string, tallyitem> mapAccountTally;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(CBitcoinAddress, CAddressBookData) & item, pwalletMain->mapAddressBook) {\n         const CBitcoinAddress& address = item.first;\n         const string& strAccount = item.second.name;\n         map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n@@ -1004,34 +932,28 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         CAmount nAmount = 0;\n         int nConf = std::numeric_limits<int>::max();\n         bool fIsWatchonly = false;\n-        if (it != mapTally.end())\n-        {\n+        if (it != mapTally.end()) {\n             nAmount = (*it).second.nAmount;\n             nConf = (*it).second.nConf;\n             fIsWatchonly = (*it).second.fIsWatchonly;\n         }\n \n-        if (fByAccounts)\n-        {\n+        if (fByAccounts) {\n             tallyitem& item = mapAccountTally[strAccount];\n             item.nAmount += nAmount;\n             item.nConf = min(item.nConf, nConf);\n             item.fIsWatchonly = fIsWatchonly;\n-        }\n-        else\n-        {\n+        } else {\n             Object obj;\n-            if(fIsWatchonly)\n+            if (fIsWatchonly)\n                 obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"address\",       address.ToString()));\n-            obj.push_back(Pair(\"account\",       strAccount));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+            obj.push_back(Pair(\"address\", address.ToString()));\n+            obj.push_back(Pair(\"account\", strAccount));\n+            obj.push_back(Pair(\"amount\", ValueFromAmount(nAmount)));\n             obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n             Array transactions;\n-            if (it != mapTally.end())\n-            {\n-                BOOST_FOREACH(const uint256& item, (*it).second.txids)\n-                {\n+            if (it != mapTally.end()) {\n+                BOOST_FOREACH (const uint256& item, (*it).second.txids) {\n                     transactions.push_back(item.GetHex());\n                 }\n             }\n@@ -1040,17 +962,15 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         }\n     }\n \n-    if (fByAccounts)\n-    {\n-        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n-        {\n+    if (fByAccounts) {\n+        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it) {\n             CAmount nAmount = (*it).second.nAmount;\n             int nConf = (*it).second.nConf;\n             Object obj;\n-            if((*it).second.fIsWatchonly)\n+            if ((*it).second.fIsWatchonly)\n                 obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"account\",       (*it).first));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+            obj.push_back(Pair(\"account\", (*it).first));\n+            obj.push_back(Pair(\"amount\", ValueFromAmount(nAmount)));\n             obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n             ret.push_back(obj);\n         }\n@@ -1082,11 +1002,8 @@ Value listreceivedbyaddress(const Array& params, bool fHelp)\n             \"  ,...\\n\"\n             \"]\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listreceivedbyaddress\", \"\")\n-            + HelpExampleCli(\"listreceivedbyaddress\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"listreceivedbyaddress\", \"\") + HelpExampleCli(\"listreceivedbyaddress\", \"6 true\") + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\"));\n \n     return ListReceived(params, false);\n }\n@@ -1113,16 +1030,13 @@ Value listreceivedbyaccount(const Array& params, bool fHelp)\n             \"  ,...\\n\"\n             \"]\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"\")\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"listreceivedbyaccount\", \"\") + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\") + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\"));\n \n     return ListReceived(params, true);\n }\n \n-static void MaybePushAddress(Object & entry, const CTxDestination &dest)\n+static void MaybePushAddress(Object& entry, const CTxDestination& dest)\n {\n     CBitcoinAddress addr;\n     if (addr.Set(dest))\n@@ -1142,12 +1056,10 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n-    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n-    {\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n-        {\n+    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount)) {\n+        BOOST_FOREACH (const COutputEntry& s, listSent) {\n             Object entry;\n-            if(involvesWatchonly || (::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n+            if (involvesWatchonly || (::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n                 entry.push_back(Pair(\"involvesWatchonly\", true));\n             entry.push_back(Pair(\"account\", strSentAccount));\n             MaybePushAddress(entry, s.destination);\n@@ -1162,31 +1074,25 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     }\n \n     // Received\n-    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-    {\n-        BOOST_FOREACH(const COutputEntry& r, listReceived)\n-        {\n+    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth) {\n+        BOOST_FOREACH (const COutputEntry& r, listReceived) {\n             string account;\n             if (pwalletMain->mapAddressBook.count(r.destination))\n                 account = pwalletMain->mapAddressBook[r.destination].name;\n-            if (fAllAccounts || (account == strAccount))\n-            {\n+            if (fAllAccounts || (account == strAccount)) {\n                 Object entry;\n-                if(involvesWatchonly || (::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n+                if (involvesWatchonly || (::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n                     entry.push_back(Pair(\"involvesWatchonly\", true));\n                 entry.push_back(Pair(\"account\", account));\n                 MaybePushAddress(entry, r.destination);\n-                if (wtx.IsCoinBase())\n-                {\n+                if (wtx.IsCoinBase()) {\n                     if (wtx.GetDepthInMainChain() < 1)\n                         entry.push_back(Pair(\"category\", \"orphan\"));\n                     else if (wtx.GetBlocksToMaturity() > 0)\n                         entry.push_back(Pair(\"category\", \"immature\"));\n                     else\n                         entry.push_back(Pair(\"category\", \"generate\"));\n-                }\n-                else\n-                {\n+                } else {\n                     entry.push_back(Pair(\"category\", \"receive\"));\n                 }\n                 entry.push_back(Pair(\"amount\", ValueFromAmount(r.amount)));\n@@ -1203,8 +1109,7 @@ void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Ar\n {\n     bool fAllAccounts = (strAccount == string(\"*\"));\n \n-    if (fAllAccounts || acentry.strAccount == strAccount)\n-    {\n+    if (fAllAccounts || acentry.strAccount == strAccount) {\n         Object entry;\n         entry.push_back(Pair(\"account\", acentry.strAccount));\n         entry.push_back(Pair(\"category\", \"move\"));\n@@ -1263,15 +1168,11 @@ Value listtransactions(const Array& params, bool fHelp)\n             \"]\\n\"\n \n             \"\\nExamples:\\n\"\n-            \"\\nList the most recent 10 transactions in the systems\\n\"\n-            + HelpExampleCli(\"listtransactions\", \"\") +\n-            \"\\nList the most recent 10 transactions for the tabby account\\n\"\n-            + HelpExampleCli(\"listtransactions\", \"\\\"tabby\\\"\") +\n-            \"\\nList transactions 100 to 120 from the tabby account\\n\"\n-            + HelpExampleCli(\"listtransactions\", \"\\\"tabby\\\" 20 100\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"listtransactions\", \"\\\"tabby\\\", 20, 100\")\n-        );\n+            \"\\nList the most recent 10 transactions in the systems\\n\" +\n+            HelpExampleCli(\"listtransactions\", \"\") +\n+            \"\\nList the most recent 10 transactions for the tabby account\\n\" + HelpExampleCli(\"listtransactions\", \"\\\"tabby\\\"\") +\n+            \"\\nList transactions 100 to 120 from the tabby account\\n\" + HelpExampleCli(\"listtransactions\", \"\\\"tabby\\\" 20 100\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"listtransactions\", \"\\\"tabby\\\", 20, 100\"));\n \n     string strAccount = \"*\";\n     if (params.size() > 0)\n@@ -1283,8 +1184,8 @@ Value listtransactions(const Array& params, bool fHelp)\n     if (params.size() > 2)\n         nFrom = params[2].get_int();\n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 3)\n-        if(params[3].get_bool())\n+    if (params.size() > 3)\n+        if (params[3].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     if (nCount < 0)\n@@ -1298,16 +1199,16 @@ Value listtransactions(const Array& params, bool fHelp)\n     CWallet::TxItems txOrdered = pwalletMain->OrderedTxItems(acentries, strAccount);\n \n     // iterate backwards until we have nCount items to return:\n-    for (CWallet::TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n-    {\n-        CWalletTx *const pwtx = (*it).second.first;\n+    for (CWallet::TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it) {\n+        CWalletTx* const pwtx = (*it).second.first;\n         if (pwtx != 0)\n             ListTransactions(*pwtx, strAccount, 0, true, ret, filter);\n-        CAccountingEntry *const pacentry = (*it).second.second;\n+        CAccountingEntry* const pacentry = (*it).second.second;\n         if (pacentry != 0)\n             AcentryToJSON(*pacentry, strAccount, ret);\n \n-        if ((int)ret.size() >= (nCount+nFrom)) break;\n+        if ((int)ret.size() >= (nCount + nFrom))\n+            break;\n     }\n     // ret is newest to oldest\n \n@@ -1318,10 +1219,12 @@ Value listtransactions(const Array& params, bool fHelp)\n     Array::iterator first = ret.begin();\n     std::advance(first, nFrom);\n     Array::iterator last = ret.begin();\n-    std::advance(last, nFrom+nCount);\n+    std::advance(last, nFrom + nCount);\n \n-    if (last != ret.end()) ret.erase(last, ret.end());\n-    if (first != ret.begin()) ret.erase(ret.begin(), first);\n+    if (last != ret.end())\n+        ret.erase(last, ret.end());\n+    if (first != ret.begin())\n+        ret.erase(ret.begin(), first);\n \n     std::reverse(ret.begin(), ret.end()); // Return oldest to newest\n \n@@ -1343,32 +1246,27 @@ Value listaccounts(const Array& params, bool fHelp)\n             \"  ...\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nList account balances where there at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"\") +\n-            \"\\nList account balances including zero confirmation transactions\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"0\") +\n-            \"\\nList account balances for 6 or more confirmations\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"6\") +\n-            \"\\nAs json rpc call\\n\"\n-            + HelpExampleRpc(\"listaccounts\", \"6\")\n-        );\n+            \"\\nList account balances where there at least 1 confirmation\\n\" +\n+            HelpExampleCli(\"listaccounts\", \"\") +\n+            \"\\nList account balances including zero confirmation transactions\\n\" + HelpExampleCli(\"listaccounts\", \"0\") +\n+            \"\\nList account balances for 6 or more confirmations\\n\" + HelpExampleCli(\"listaccounts\", \"6\") +\n+            \"\\nAs json rpc call\\n\" + HelpExampleRpc(\"listaccounts\", \"6\"));\n \n     int nMinDepth = 1;\n     if (params.size() > 0)\n         nMinDepth = params[0].get_int();\n     isminefilter includeWatchonly = ISMINE_SPENDABLE;\n-    if(params.size() > 1)\n-        if(params[1].get_bool())\n+    if (params.size() > 1)\n+        if (params[1].get_bool())\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n     map<string, CAmount> mapAccountBalances;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n+    BOOST_FOREACH (const PAIRTYPE(CTxDestination, CAddressBookData) & entry, pwalletMain->mapAddressBook) {\n         if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n     }\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it) {\n         const CWalletTx& wtx = (*it).second;\n         CAmount nFee;\n         string strSentAccount;\n@@ -1379,11 +1277,10 @@ Value listaccounts(const Array& params, bool fHelp)\n             continue;\n         wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);\n         mapAccountBalances[strSentAccount] -= nFee;\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n+        BOOST_FOREACH (const COutputEntry& s, listSent)\n             mapAccountBalances[strSentAccount] -= s.amount;\n-        if (nDepth >= nMinDepth)\n-        {\n-            BOOST_FOREACH(const COutputEntry& r, listReceived)\n+        if (nDepth >= nMinDepth) {\n+            BOOST_FOREACH (const COutputEntry& r, listReceived)\n                 if (pwalletMain->mapAddressBook.count(r.destination))\n                     mapAccountBalances[pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n                 else\n@@ -1393,11 +1290,11 @@ Value listaccounts(const Array& params, bool fHelp)\n \n     list<CAccountingEntry> acentries;\n     CWalletDB(pwalletMain->strWalletFile).ListAccountCreditDebit(\"*\", acentries);\n-    BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n+    BOOST_FOREACH (const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     Object ret;\n-    BOOST_FOREACH(const PAIRTYPE(string, CAmount)& accountBalance, mapAccountBalances) {\n+    BOOST_FOREACH (const PAIRTYPE(string, CAmount) & accountBalance, mapAccountBalances) {\n         ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n     }\n     return ret;\n@@ -1432,21 +1329,17 @@ Value listsinceblock(const Array& params, bool fHelp)\n             \"    \\\"timereceived\\\": xxx,      (numeric) The time received in seconds since epoch (Jan 1 1970 GMT). Available for 'send' and 'receive' category of transactions.\\n\"\n             \"    \\\"comment\\\": \\\"...\\\",       (string) If a comment is associated with the transaction.\\n\"\n             \"    \\\"to\\\": \\\"...\\\",            (string) If a comment to is associated with the transaction.\\n\"\n-             \"  ],\\n\"\n+            \"  ],\\n\"\n             \"  \\\"lastblock\\\": \\\"lastblockhash\\\"     (string) The hash of the last block\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listsinceblock\", \"\")\n-            + HelpExampleCli(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\" 6\")\n-            + HelpExampleRpc(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\", 6\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"listsinceblock\", \"\") + HelpExampleCli(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\" 6\") + HelpExampleRpc(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\", 6\"));\n \n-    CBlockIndex *pindex = NULL;\n+    CBlockIndex* pindex = NULL;\n     int target_confirms = 1;\n     isminefilter filter = ISMINE_SPENDABLE;\n \n-    if (params.size() > 0)\n-    {\n+    if (params.size() > 0) {\n         uint256 blockId = 0;\n \n         blockId.SetHex(params[0].get_str());\n@@ -1455,31 +1348,29 @@ Value listsinceblock(const Array& params, bool fHelp)\n             pindex = it->second;\n     }\n \n-    if (params.size() > 1)\n-    {\n+    if (params.size() > 1) {\n         target_confirms = params[1].get_int();\n \n         if (target_confirms < 1)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n     }\n \n-    if(params.size() > 2)\n-        if(params[2].get_bool())\n+    if (params.size() > 2)\n+        if (params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n \n     Array transactions;\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n-    {\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++) {\n         CWalletTx tx = (*it).second;\n \n         if (depth == -1 || tx.GetDepthInMainChain() < depth)\n             ListTransactions(tx, \"*\", 0, true, transactions, filter);\n     }\n \n-    CBlockIndex *pblockLast = chainActive[chainActive.Height() + 1 - target_confirms];\n+    CBlockIndex* pblockLast = chainActive[chainActive.Height() + 1 - target_confirms];\n     uint256 lastblock = pblockLast ? pblockLast->GetBlockHash() : 0;\n \n     Object ret;\n@@ -1521,18 +1412,15 @@ Value gettransaction(const Array& params, bool fHelp)\n             \"  \\\"hex\\\" : \\\"data\\\"         (string) Raw data for transaction\\n\"\n             \"}\\n\"\n \n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n-            + HelpExampleCli(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\" true\")\n-            + HelpExampleRpc(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\") + HelpExampleCli(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\" true\") + HelpExampleRpc(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\"));\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n \n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 1)\n-        if(params[1].get_bool())\n+    if (params.size() > 1)\n+        if (params[1].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     Object entry;\n@@ -1570,10 +1458,8 @@ Value backupwallet(const Array& params, bool fHelp)\n             \"\\nSafely copies wallet.dat to destination, which can be a directory or a path with filename.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"destination\\\"   (string) The destination directory or file\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"backupwallet\", \"\\\"backup.dat\\\"\")\n-            + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"backupwallet\", \"\\\"backup.dat\\\"\") + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\"));\n \n     string strDest = params[0].get_str();\n     if (!BackupWallet(*pwalletMain, strDest))\n@@ -1588,14 +1474,12 @@ Value keypoolrefill(const Array& params, bool fHelp)\n     if (fHelp || params.size() > 1)\n         throw runtime_error(\n             \"keypoolrefill ( newsize )\\n\"\n-            \"\\nFills the keypool.\"\n-            + HelpRequiringPassphrase() + \"\\n\"\n-            \"\\nArguments\\n\"\n-            \"1. newsize     (numeric, optional, default=100) The new keypool size\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"keypoolrefill\", \"\")\n-            + HelpExampleRpc(\"keypoolrefill\", \"\")\n-        );\n+            \"\\nFills the keypool.\" +\n+            HelpRequiringPassphrase() + \"\\n\"\n+                                        \"\\nArguments\\n\"\n+                                        \"1. newsize     (numeric, optional, default=100) The new keypool size\\n\"\n+                                        \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"keypoolrefill\", \"\") + HelpExampleRpc(\"keypoolrefill\", \"\"));\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n@@ -1636,13 +1520,10 @@ Value walletpassphrase(const Array& params, bool fHelp)\n             \"Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock\\n\"\n             \"time that overrides the old one.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nunlock the wallet for 60 seconds\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 60\") +\n-            \"\\nLock the wallet again (before 60 seconds)\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs json rpc call\\n\"\n-            + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n-        );\n+            \"\\nunlock the wallet for 60 seconds\\n\" +\n+            HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 60\") +\n+            \"\\nLock the wallet again (before 60 seconds)\\n\" + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs json rpc call\\n\" + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\"));\n \n     if (fHelp)\n         return true;\n@@ -1656,12 +1537,10 @@ Value walletpassphrase(const Array& params, bool fHelp)\n     // Alternately, find a way to make params[0] mlock()'d to begin with.\n     strWalletPass = params[0].get_str().c_str();\n \n-    if (strWalletPass.length() > 0)\n-    {\n+    if (strWalletPass.length() > 0) {\n         if (!pwalletMain->Unlock(strWalletPass))\n             throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n-    }\n-    else\n+    } else\n         throw runtime_error(\n             \"walletpassphrase <passphrase> <timeout>\\n\"\n             \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n@@ -1686,10 +1565,8 @@ Value walletpassphrasechange(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"oldpassphrase\\\"      (string) The current passphrase\\n\"\n             \"2. \\\"newpassphrase\\\"      (string) The new passphrase\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"walletpassphrasechange\", \"\\\"old one\\\" \\\"new one\\\"\")\n-            + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"walletpassphrasechange\", \"\\\"old one\\\" \\\"new one\\\"\") + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\"));\n \n     if (fHelp)\n         return true;\n@@ -1727,15 +1604,11 @@ Value walletlock(const Array& params, bool fHelp)\n             \"After calling this method, you will need to call walletpassphrase again\\n\"\n             \"before being able to call any methods which require the wallet to be unlocked.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nSet the passphrase for 2 minutes to perform a transaction\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 120\") +\n-            \"\\nPerform a send (requires passphrase set)\\n\"\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 1.0\") +\n-            \"\\nClear the passphrase since we are done before 2 minutes is up\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs json rpc call\\n\"\n-            + HelpExampleRpc(\"walletlock\", \"\")\n-        );\n+            \"\\nSet the passphrase for 2 minutes to perform a transaction\\n\" +\n+            HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 120\") +\n+            \"\\nPerform a send (requires passphrase set)\\n\" + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 1.0\") +\n+            \"\\nClear the passphrase since we are done before 2 minutes is up\\n\" + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs json rpc call\\n\" + HelpExampleRpc(\"walletlock\", \"\"));\n \n     if (fHelp)\n         return true;\n@@ -1766,17 +1639,12 @@ Value encryptwallet(const Array& params, bool fHelp)\n             \"\\nArguments:\\n\"\n             \"1. \\\"passphrase\\\"    (string) The pass phrase to encrypt the wallet with. It must be at least 1 character, but should be long.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nEncrypt you wallet\\n\"\n-            + HelpExampleCli(\"encryptwallet\", \"\\\"my pass phrase\\\"\") +\n-            \"\\nNow set the passphrase to use the wallet, such as for signing or sending bitcoin\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\"\") +\n-            \"\\nNow we can so something like sign\\n\"\n-            + HelpExampleCli(\"signmessage\", \"\\\"bitcoinaddress\\\" \\\"test message\\\"\") +\n-            \"\\nNow lock the wallet again by removing the passphrase\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\")\n-        );\n+            \"\\nEncrypt you wallet\\n\" +\n+            HelpExampleCli(\"encryptwallet\", \"\\\"my pass phrase\\\"\") +\n+            \"\\nNow set the passphrase to use the wallet, such as for signing or sending bitcoin\\n\" + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\"\") +\n+            \"\\nNow we can so something like sign\\n\" + HelpExampleCli(\"signmessage\", \"\\\"bitcoinaddress\\\" \\\"test message\\\"\") +\n+            \"\\nNow lock the wallet again by removing the passphrase\\n\" + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\"));\n \n     if (fHelp)\n         return true;\n@@ -1830,17 +1698,12 @@ Value lockunspent(const Array& params, bool fHelp)\n             \"true|false    (boolean) Whether the command was successful or not\\n\"\n \n             \"\\nExamples:\\n\"\n-            \"\\nList the unspent transactions\\n\"\n-            + HelpExampleCli(\"listunspent\", \"\") +\n-            \"\\nLock an unspent transaction\\n\"\n-            + HelpExampleCli(\"lockunspent\", \"false \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n-            \"\\nList the locked transactions\\n\"\n-            + HelpExampleCli(\"listlockunspent\", \"\") +\n-            \"\\nUnlock the transaction again\\n\"\n-            + HelpExampleCli(\"lockunspent\", \"true \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"lockunspent\", \"false, \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\")\n-        );\n+            \"\\nList the unspent transactions\\n\" +\n+            HelpExampleCli(\"listunspent\", \"\") +\n+            \"\\nLock an unspent transaction\\n\" + HelpExampleCli(\"lockunspent\", \"false \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n+            \"\\nList the locked transactions\\n\" + HelpExampleCli(\"listlockunspent\", \"\") +\n+            \"\\nUnlock the transaction again\\n\" + HelpExampleCli(\"lockunspent\", \"true \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"lockunspent\", \"false, \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\"));\n \n     if (params.size() == 1)\n         RPCTypeCheck(params, list_of(bool_type));\n@@ -1856,8 +1719,7 @@ Value lockunspent(const Array& params, bool fHelp)\n     }\n \n     Array outputs = params[1].get_array();\n-    BOOST_FOREACH(Value& output, outputs)\n-    {\n+    BOOST_FOREACH (Value& output, outputs) {\n         if (output.type() != obj_type)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected object\");\n         const Object& o = output.get_obj();\n@@ -1899,24 +1761,19 @@ Value listlockunspent(const Array& params, bool fHelp)\n             \"  ,...\\n\"\n             \"]\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nList the unspent transactions\\n\"\n-            + HelpExampleCli(\"listunspent\", \"\") +\n-            \"\\nLock an unspent transaction\\n\"\n-            + HelpExampleCli(\"lockunspent\", \"false \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n-            \"\\nList the locked transactions\\n\"\n-            + HelpExampleCli(\"listlockunspent\", \"\") +\n-            \"\\nUnlock the transaction again\\n\"\n-            + HelpExampleCli(\"lockunspent\", \"true \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"listlockunspent\", \"\")\n-        );\n+            \"\\nList the unspent transactions\\n\" +\n+            HelpExampleCli(\"listunspent\", \"\") +\n+            \"\\nLock an unspent transaction\\n\" + HelpExampleCli(\"lockunspent\", \"false \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n+            \"\\nList the locked transactions\\n\" + HelpExampleCli(\"listlockunspent\", \"\") +\n+            \"\\nUnlock the transaction again\\n\" + HelpExampleCli(\"lockunspent\", \"true \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\") +\n+            \"\\nAs a json rpc call\\n\" + HelpExampleRpc(\"listlockunspent\", \"\"));\n \n     vector<COutPoint> vOutpts;\n     pwalletMain->ListLockedCoins(vOutpts);\n \n     Array ret;\n \n-    BOOST_FOREACH(COutPoint &outpt, vOutpts) {\n+    BOOST_FOREACH (COutPoint& outpt, vOutpts) {\n         Object o;\n \n         o.push_back(Pair(\"txid\", outpt.hash.GetHex()));\n@@ -1937,15 +1794,13 @@ Value settxfee(const Array& params, bool fHelp)\n             \"1. amount         (numeric, required) The transaction fee in BTC/kB rounded to the nearest 0.00000001\\n\"\n             \"\\nResult\\n\"\n             \"true|false        (boolean) Returns true if successful\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"settxfee\", \"0.00001\")\n-            + HelpExampleRpc(\"settxfee\", \"0.00001\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"settxfee\", \"0.00001\") + HelpExampleRpc(\"settxfee\", \"0.00001\"));\n \n     // Amount\n     CAmount nAmount = 0;\n     if (params[0].get_real() != 0.0)\n-        nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n+        nAmount = AmountFromValue(params[0]); // rejects 0.0 amounts\n \n     payTxFee = CFeeRate(nAmount, 1000);\n     return true;\n@@ -1966,17 +1821,15 @@ Value getwalletinfo(const Array& params, bool fHelp)\n             \"  \\\"keypoolsize\\\": xxxx,        (numeric) how many new keys are pre-generated\\n\"\n             \"  \\\"unlocked_until\\\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n             \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getwalletinfo\", \"\")\n-            + HelpExampleRpc(\"getwalletinfo\", \"\")\n-        );\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"getwalletinfo\", \"\") + HelpExampleRpc(\"getwalletinfo\", \"\"));\n \n     Object obj;\n     obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"txcount\",       (int)pwalletMain->mapWallet.size()));\n+    obj.push_back(Pair(\"balance\", ValueFromAmount(pwalletMain->GetBalance())));\n+    obj.push_back(Pair(\"txcount\", (int)pwalletMain->mapWallet.size()));\n     obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n-    obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n+    obj.push_back(Pair(\"keypoolsize\", (int)pwalletMain->GetKeyPoolSize()));\n     if (pwalletMain->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     return obj;"
      },
      {
        "sha": "ac1d9a86b63d6e6823a8145102377b22fdf45e8f",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -9,18 +9,18 @@\n #include \"script/interpreter.h\"\n #include \"version.h\"\n \n-namespace {\n-\n+namespace\n+{\n /** A class that deserializes a single CTransaction one time. */\n class TxInputStream\n {\n public:\n-    TxInputStream(int nTypeIn, int nVersionIn, const unsigned char *txTo, size_t txToLen) :\n-    m_type(nTypeIn),\n-    m_version(nVersionIn),\n-    m_data(txTo),\n-    m_remaining(txToLen)\n-    {}\n+    TxInputStream(int nTypeIn, int nVersionIn, const unsigned char* txTo, size_t txToLen) : m_type(nTypeIn),\n+                                                                                            m_version(nVersionIn),\n+                                                                                            m_data(txTo),\n+                                                                                            m_remaining(txToLen)\n+    {\n+    }\n \n     TxInputStream& read(char* pch, size_t nSize)\n     {\n@@ -39,7 +39,7 @@ class TxInputStream\n         return *this;\n     }\n \n-    template<typename T>\n+    template <typename T>\n     TxInputStream& operator>>(T& obj)\n     {\n         ::Unserialize(*this, obj, m_type, m_version);\n@@ -62,9 +62,7 @@ inline int set_error(bitcoinconsensus_error* ret, bitcoinconsensus_error serror)\n \n } // anon namespace\n \n-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n-                                    const unsigned char *txTo        , unsigned int txToLen,\n-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+int bitcoinconsensus_verify_script(const unsigned char* scriptPubKey, unsigned int scriptPubKeyLen, const unsigned char* txTo, unsigned int txToLen, unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n {\n     try {\n         TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION, txTo, txToLen);\n@@ -75,11 +73,11 @@ int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned i\n         if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION) != txToLen)\n             return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n \n-         // Regardless of the verification result, the tx did not error.\n-         set_error(err, bitcoinconsensus_ERR_OK);\n+        // Regardless of the verification result, the tx did not error.\n+        set_error(err, bitcoinconsensus_ERR_OK);\n \n         return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), flags, SignatureChecker(tx, nIn), NULL);\n-    } catch (std::exception &e) {\n+    } catch (std::exception& e) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }\n }"
      },
      {
        "sha": "0b9cb0465f95b615f52eda8783e71bfc43f6ed7f",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 235,
        "deletions": 261,
        "changes": 496,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -18,8 +18,8 @@ using namespace std;\n \n typedef vector<unsigned char> valtype;\n \n-namespace {\n-\n+namespace\n+{\n inline bool set_success(ScriptError* ret)\n {\n     if (ret)\n@@ -38,12 +38,10 @@ inline bool set_error(ScriptError* ret, const ScriptError serror)\n \n bool CastToBool(const valtype& vch)\n {\n-    for (unsigned int i = 0; i < vch.size(); i++)\n-    {\n-        if (vch[i] != 0)\n-        {\n+    for (unsigned int i = 0; i < vch.size(); i++) {\n+        if (vch[i] != 0) {\n             // Can be negative zero\n-            if (i == vch.size()-1 && vch[i] == 0x80)\n+            if (i == vch.size() - 1 && vch[i] == 0x80)\n                 return false;\n             return true;\n         }\n@@ -55,16 +53,17 @@ bool CastToBool(const valtype& vch)\n  * Script is a stack machine (like Forth) that evaluates a predicate\n  * returning a bool indicating valid or not.  There are no loops.\n  */\n-#define stacktop(i)  (stack.at(stack.size()+(i)))\n-#define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n+#define stacktop(i) (stack.at(stack.size() + (i)))\n+#define altstacktop(i) (altstack.at(altstack.size() + (i)))\n static inline void popstack(vector<valtype>& stack)\n {\n     if (stack.empty())\n         throw runtime_error(\"popstack() : stack empty\");\n     stack.pop_back();\n }\n \n-bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n+bool static IsCompressedOrUncompressedPubKey(const valtype& vchPubKey)\n+{\n     if (vchPubKey.size() < 33) {\n         //  Non-canonical public key: too short\n         return false;\n@@ -80,8 +79,8 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n             return false;\n         }\n     } else {\n-          //  Non-canonical public key: neither compressed nor uncompressed\n-          return false;\n+        //  Non-canonical public key: neither compressed nor uncompressed\n+        return false;\n     }\n     return true;\n }\n@@ -94,8 +93,8 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n  * \n  * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n  */\n-bool static IsDERSignature(const valtype &vchSig) {\n-\n+bool static IsDERSignature(const valtype& vchSig)\n+{\n     if (vchSig.size() < 9) {\n         //  Non-canonical signature: too short\n         return false;\n@@ -108,7 +107,7 @@ bool static IsDERSignature(const valtype &vchSig) {\n         //  Non-canonical signature: wrong type\n         return false;\n     }\n-    if (vchSig[1] != vchSig.size()-3) {\n+    if (vchSig[1] != vchSig.size() - 3) {\n         //  Non-canonical signature: wrong length marker\n         return false;\n     }\n@@ -117,13 +116,13 @@ bool static IsDERSignature(const valtype &vchSig) {\n         //  Non-canonical signature: S length misplaced\n         return false;\n     }\n-    unsigned int nLenS = vchSig[5+nLenR];\n-    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size()) {\n+    unsigned int nLenS = vchSig[5 + nLenR];\n+    if ((unsigned long)(nLenR + nLenS + 7) != vchSig.size()) {\n         //  Non-canonical signature: R+S length mismatch\n         return false;\n     }\n \n-    const unsigned char *R = &vchSig[4];\n+    const unsigned char* R = &vchSig[4];\n     if (R[-2] != 0x02) {\n         //  Non-canonical signature: R value type mismatch\n         return false;\n@@ -141,7 +140,7 @@ bool static IsDERSignature(const valtype &vchSig) {\n         return false;\n     }\n \n-    const unsigned char *S = &vchSig[6+nLenR];\n+    const unsigned char* S = &vchSig[6 + nLenR];\n     if (S[-2] != 0x02) {\n         //  Non-canonical signature: S value type mismatch\n         return false;\n@@ -161,13 +160,14 @@ bool static IsDERSignature(const valtype &vchSig) {\n     return true;\n }\n \n-bool static IsLowDERSignature(const valtype &vchSig, ScriptError* serror) {\n+bool static IsLowDERSignature(const valtype& vchSig, ScriptError* serror)\n+{\n     if (!IsDERSignature(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_SIG_DER);\n     }\n     unsigned int nLenR = vchSig[3];\n-    unsigned int nLenS = vchSig[5+nLenR];\n-    const unsigned char *S = &vchSig[6+nLenR];\n+    unsigned int nLenS = vchSig[5 + nLenR];\n+    const unsigned char* S = &vchSig[6 + nLenR];\n     // If the S value is above the order of the curve divided by two, its\n     // complement modulo the order could have been used instead, which is\n     // one byte shorter when encoded correctly.\n@@ -177,7 +177,8 @@ bool static IsLowDERSignature(const valtype &vchSig, ScriptError* serror) {\n     return true;\n }\n \n-bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n+bool static IsDefinedHashtypeSignature(const valtype& vchSig)\n+{\n     if (vchSig.size() == 0) {\n         return false;\n     }\n@@ -188,7 +189,8 @@ bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n     return true;\n }\n \n-bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n+bool static CheckSignatureEncoding(const valtype& vchSig, unsigned int flags, ScriptError* serror)\n+{\n     if ((flags & (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 && !IsDERSignature(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_SIG_DER);\n     } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig, serror)) {\n@@ -200,14 +202,16 @@ bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags, Sc\n     return true;\n }\n \n-bool static CheckPubKeyEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n+bool static CheckPubKeyEncoding(const valtype& vchSig, unsigned int flags, ScriptError* serror)\n+{\n     if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     return true;\n }\n \n-bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n+bool static CheckMinimalPush(const valtype& data, opcodetype opcode)\n+{\n     if (data.size() == 0) {\n         // Could have used OP_0.\n         return opcode == OP_0;\n@@ -253,10 +257,8 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n \n-    try\n-    {\n-        while (pc < pend)\n-        {\n+    try {\n+        while (pc < pend) {\n             bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n \n             //\n@@ -294,8 +296,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 }\n                 stack.push_back(vchPushValue);\n             } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n-            switch (opcode)\n-            {\n+                switch (opcode) {\n                 //\n                 // Push value\n                 //\n@@ -315,38 +316,40 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_13:\n                 case OP_14:\n                 case OP_15:\n-                case OP_16:\n-                {\n+                case OP_16: {\n                     // ( -- value)\n                     CScriptNum bn((int)opcode - (int)(OP_1 - 1));\n                     stack.push_back(bn.getvch());\n                     // The result of these opcodes should always be the minimal way to push the data\n                     // they push, so no need for a CheckMinimalPush here.\n-                }\n-                break;\n+                } break;\n \n \n                 //\n                 // Control\n                 //\n                 case OP_NOP:\n-                break;\n-\n-                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n-                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n-                {\n+                    break;\n+\n+                case OP_NOP1:\n+                case OP_NOP2:\n+                case OP_NOP3:\n+                case OP_NOP4:\n+                case OP_NOP5:\n+                case OP_NOP6:\n+                case OP_NOP7:\n+                case OP_NOP8:\n+                case OP_NOP9:\n+                case OP_NOP10: {\n                     if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n                         return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n-                }\n-                break;\n+                } break;\n \n                 case OP_IF:\n-                case OP_NOTIF:\n-                {\n+                case OP_NOTIF: {\n                     // <expression> if [statements] [else [statements]] endif\n                     bool fValue = false;\n-                    if (fExec)\n-                    {\n+                    if (fExec) {\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n@@ -356,27 +359,21 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         popstack(stack);\n                     }\n                     vfExec.push_back(fValue);\n-                }\n-                break;\n+                } break;\n \n-                case OP_ELSE:\n-                {\n+                case OP_ELSE: {\n                     if (vfExec.empty())\n                         return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                     vfExec.back() = !vfExec.back();\n-                }\n-                break;\n+                } break;\n \n-                case OP_ENDIF:\n-                {\n+                case OP_ENDIF: {\n                     if (vfExec.empty())\n                         return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                     vfExec.pop_back();\n-                }\n-                break;\n+                } break;\n \n-                case OP_VERIFY:\n-                {\n+                case OP_VERIFY: {\n                     // (true -- ) or\n                     // (false -- false) and return\n                     if (stack.size() < 1)\n@@ -386,61 +383,49 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         popstack(stack);\n                     else\n                         return set_error(serror, SCRIPT_ERR_VERIFY);\n-                }\n-                break;\n+                } break;\n \n-                case OP_RETURN:\n-                {\n+                case OP_RETURN: {\n                     return set_error(serror, SCRIPT_ERR_OP_RETURN);\n-                }\n-                break;\n+                } break;\n \n \n                 //\n                 // Stack ops\n                 //\n-                case OP_TOALTSTACK:\n-                {\n+                case OP_TOALTSTACK: {\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     altstack.push_back(stacktop(-1));\n                     popstack(stack);\n-                }\n-                break;\n+                } break;\n \n-                case OP_FROMALTSTACK:\n-                {\n+                case OP_FROMALTSTACK: {\n                     if (altstack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_ALTSTACK_OPERATION);\n                     stack.push_back(altstacktop(-1));\n                     popstack(altstack);\n-                }\n-                break;\n+                } break;\n \n-                case OP_2DROP:\n-                {\n+                case OP_2DROP: {\n                     // (x1 x2 -- )\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     popstack(stack);\n                     popstack(stack);\n-                }\n-                break;\n+                } break;\n \n-                case OP_2DUP:\n-                {\n+                case OP_2DUP: {\n                     // (x1 x2 -- x1 x2 x1 x2)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-2);\n                     valtype vch2 = stacktop(-1);\n                     stack.push_back(vch1);\n                     stack.push_back(vch2);\n-                }\n-                break;\n+                } break;\n \n-                case OP_3DUP:\n-                {\n+                case OP_3DUP: {\n                     // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                     if (stack.size() < 3)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n@@ -450,104 +435,84 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     stack.push_back(vch1);\n                     stack.push_back(vch2);\n                     stack.push_back(vch3);\n-                }\n-                break;\n+                } break;\n \n-                case OP_2OVER:\n-                {\n+                case OP_2OVER: {\n                     // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                     if (stack.size() < 4)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-4);\n                     valtype vch2 = stacktop(-3);\n                     stack.push_back(vch1);\n                     stack.push_back(vch2);\n-                }\n-                break;\n+                } break;\n \n-                case OP_2ROT:\n-                {\n+                case OP_2ROT: {\n                     // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                     if (stack.size() < 6)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-6);\n                     valtype vch2 = stacktop(-5);\n-                    stack.erase(stack.end()-6, stack.end()-4);\n+                    stack.erase(stack.end() - 6, stack.end() - 4);\n                     stack.push_back(vch1);\n                     stack.push_back(vch2);\n-                }\n-                break;\n+                } break;\n \n-                case OP_2SWAP:\n-                {\n+                case OP_2SWAP: {\n                     // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                     if (stack.size() < 4)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-4), stacktop(-2));\n                     swap(stacktop(-3), stacktop(-1));\n-                }\n-                break;\n+                } break;\n \n-                case OP_IFDUP:\n-                {\n+                case OP_IFDUP: {\n                     // (x - 0 | x x)\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n                     if (CastToBool(vch))\n                         stack.push_back(vch);\n-                }\n-                break;\n+                } break;\n \n-                case OP_DEPTH:\n-                {\n+                case OP_DEPTH: {\n                     // -- stacksize\n                     CScriptNum bn(stack.size());\n                     stack.push_back(bn.getvch());\n-                }\n-                break;\n+                } break;\n \n-                case OP_DROP:\n-                {\n+                case OP_DROP: {\n                     // (x -- )\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     popstack(stack);\n-                }\n-                break;\n+                } break;\n \n-                case OP_DUP:\n-                {\n+                case OP_DUP: {\n                     // (x -- x x)\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n                     stack.push_back(vch);\n-                }\n-                break;\n+                } break;\n \n-                case OP_NIP:\n-                {\n+                case OP_NIP: {\n                     // (x1 x2 -- x2)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     stack.erase(stack.end() - 2);\n-                }\n-                break;\n+                } break;\n \n-                case OP_OVER:\n-                {\n+                case OP_OVER: {\n                     // (x1 x2 -- x1 x2 x1)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-2);\n                     stack.push_back(vch);\n-                }\n-                break;\n+                } break;\n \n                 case OP_PICK:\n-                case OP_ROLL:\n-                {\n+                case OP_ROLL: {\n                     // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                     // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                     if (stack.size() < 2)\n@@ -556,86 +521,76 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     popstack(stack);\n                     if (n < 0 || n >= (int)stack.size())\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n-                    valtype vch = stacktop(-n-1);\n+                    valtype vch = stacktop(-n - 1);\n                     if (opcode == OP_ROLL)\n-                        stack.erase(stack.end()-n-1);\n+                        stack.erase(stack.end() - n - 1);\n                     stack.push_back(vch);\n-                }\n-                break;\n+                } break;\n \n-                case OP_ROT:\n-                {\n+                case OP_ROT: {\n                     // (x1 x2 x3 -- x2 x3 x1)\n                     //  x2 x1 x3  after first swap\n                     //  x2 x3 x1  after second swap\n                     if (stack.size() < 3)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-3), stacktop(-2));\n                     swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n+                } break;\n \n-                case OP_SWAP:\n-                {\n+                case OP_SWAP: {\n                     // (x1 x2 -- x2 x1)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n+                } break;\n \n-                case OP_TUCK:\n-                {\n+                case OP_TUCK: {\n                     // (x1 x2 -- x2 x1 x2)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n-                    stack.insert(stack.end()-2, vch);\n-                }\n-                break;\n+                    stack.insert(stack.end() - 2, vch);\n+                } break;\n \n \n-                case OP_SIZE:\n-                {\n+                case OP_SIZE: {\n                     // (in -- in size)\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn(stacktop(-1).size());\n                     stack.push_back(bn.getvch());\n-                }\n-                break;\n+                } break;\n \n \n                 //\n                 // Bitwise logic\n                 //\n                 case OP_EQUAL:\n                 case OP_EQUALVERIFY:\n-                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n-                {\n-                    // (x1 x2 - bool)\n-                    if (stack.size() < 2)\n-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    bool fEqual = (vch1 == vch2);\n-                    // OP_NOTEQUAL is disabled because it would be too easy to say\n-                    // something like n != 1 and have some wiseguy pass in 1 with extra\n-                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n-                    //if (opcode == OP_NOTEQUAL)\n-                    //    fEqual = !fEqual;\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fEqual ? vchTrue : vchFalse);\n-                    if (opcode == OP_EQUALVERIFY)\n+                    //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                     {\n-                        if (fEqual)\n-                            popstack(stack);\n-                        else\n-                            return set_error(serror, SCRIPT_ERR_EQUALVERIFY);\n+                        // (x1 x2 - bool)\n+                        if (stack.size() < 2)\n+                            return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                        valtype& vch1 = stacktop(-2);\n+                        valtype& vch2 = stacktop(-1);\n+                        bool fEqual = (vch1 == vch2);\n+                        // OP_NOTEQUAL is disabled because it would be too easy to say\n+                        // something like n != 1 and have some wiseguy pass in 1 with extra\n+                        // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n+                        //if (opcode == OP_NOTEQUAL)\n+                        //    fEqual = !fEqual;\n+                        popstack(stack);\n+                        popstack(stack);\n+                        stack.push_back(fEqual ? vchTrue : vchFalse);\n+                        if (opcode == OP_EQUALVERIFY) {\n+                            if (fEqual)\n+                                popstack(stack);\n+                            else\n+                                return set_error(serror, SCRIPT_ERR_EQUALVERIFY);\n+                        }\n                     }\n-                }\n-                break;\n+                    break;\n \n \n                 //\n@@ -646,26 +601,38 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_NEGATE:\n                 case OP_ABS:\n                 case OP_NOT:\n-                case OP_0NOTEQUAL:\n-                {\n+                case OP_0NOTEQUAL: {\n                     // (in -- out)\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn(stacktop(-1), fRequireMinimal);\n-                    switch (opcode)\n-                    {\n-                    case OP_1ADD:       bn += bnOne; break;\n-                    case OP_1SUB:       bn -= bnOne; break;\n-                    case OP_NEGATE:     bn = -bn; break;\n-                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n-                    case OP_NOT:        bn = (bn == bnZero); break;\n-                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n-                    default:            assert(!\"invalid opcode\"); break;\n+                    switch (opcode) {\n+                    case OP_1ADD:\n+                        bn += bnOne;\n+                        break;\n+                    case OP_1SUB:\n+                        bn -= bnOne;\n+                        break;\n+                    case OP_NEGATE:\n+                        bn = -bn;\n+                        break;\n+                    case OP_ABS:\n+                        if (bn < bnZero)\n+                            bn = -bn;\n+                        break;\n+                    case OP_NOT:\n+                        bn = (bn == bnZero);\n+                        break;\n+                    case OP_0NOTEQUAL:\n+                        bn = (bn != bnZero);\n+                        break;\n+                    default:\n+                        assert(!\"invalid opcode\");\n+                        break;\n                     }\n                     popstack(stack);\n                     stack.push_back(bn.getvch());\n-                }\n-                break;\n+                } break;\n \n                 case OP_ADD:\n                 case OP_SUB:\n@@ -679,16 +646,14 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_LESSTHANOREQUAL:\n                 case OP_GREATERTHANOREQUAL:\n                 case OP_MIN:\n-                case OP_MAX:\n-                {\n+                case OP_MAX: {\n                     // (x1 x2 -- out)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn1(stacktop(-2), fRequireMinimal);\n                     CScriptNum bn2(stacktop(-1), fRequireMinimal);\n                     CScriptNum bn(0);\n-                    switch (opcode)\n-                    {\n+                    switch (opcode) {\n                     case OP_ADD:\n                         bn = bn1 + bn2;\n                         break;\n@@ -697,35 +662,56 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         bn = bn1 - bn2;\n                         break;\n \n-                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n-                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n-                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n-                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n-                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n-                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n-                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n-                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n-                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n-                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n-                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n-                    default:                     assert(!\"invalid opcode\"); break;\n+                    case OP_BOOLAND:\n+                        bn = (bn1 != bnZero && bn2 != bnZero);\n+                        break;\n+                    case OP_BOOLOR:\n+                        bn = (bn1 != bnZero || bn2 != bnZero);\n+                        break;\n+                    case OP_NUMEQUAL:\n+                        bn = (bn1 == bn2);\n+                        break;\n+                    case OP_NUMEQUALVERIFY:\n+                        bn = (bn1 == bn2);\n+                        break;\n+                    case OP_NUMNOTEQUAL:\n+                        bn = (bn1 != bn2);\n+                        break;\n+                    case OP_LESSTHAN:\n+                        bn = (bn1 < bn2);\n+                        break;\n+                    case OP_GREATERTHAN:\n+                        bn = (bn1 > bn2);\n+                        break;\n+                    case OP_LESSTHANOREQUAL:\n+                        bn = (bn1 <= bn2);\n+                        break;\n+                    case OP_GREATERTHANOREQUAL:\n+                        bn = (bn1 >= bn2);\n+                        break;\n+                    case OP_MIN:\n+                        bn = (bn1 < bn2 ? bn1 : bn2);\n+                        break;\n+                    case OP_MAX:\n+                        bn = (bn1 > bn2 ? bn1 : bn2);\n+                        break;\n+                    default:\n+                        assert(!\"invalid opcode\");\n+                        break;\n                     }\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(bn.getvch());\n \n-                    if (opcode == OP_NUMEQUALVERIFY)\n-                    {\n+                    if (opcode == OP_NUMEQUALVERIFY) {\n                         if (CastToBool(stacktop(-1)))\n                             popstack(stack);\n                         else\n                             return set_error(serror, SCRIPT_ERR_NUMEQUALVERIFY);\n                     }\n-                }\n-                break;\n+                } break;\n \n-                case OP_WITHIN:\n-                {\n+                case OP_WITHIN: {\n                     // (x min max -- out)\n                     if (stack.size() < 3)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n@@ -737,8 +723,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(fValue ? vchTrue : vchFalse);\n-                }\n-                break;\n+                } break;\n \n \n                 //\n@@ -748,8 +733,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_SHA1:\n                 case OP_SHA256:\n                 case OP_HASH160:\n-                case OP_HASH256:\n-                {\n+                case OP_HASH256: {\n                     // (in -- hash)\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n@@ -767,24 +751,20 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         CHash256().Write(begin_ptr(vch), vch.size()).Finalize(begin_ptr(vchHash));\n                     popstack(stack);\n                     stack.push_back(vchHash);\n-                }\n-                break;                                   \n+                } break;\n \n-                case OP_CODESEPARATOR:\n-                {\n+                case OP_CODESEPARATOR: {\n                     // Hash starts after the code separator\n                     pbegincodehash = pc;\n-                }\n-                break;\n+                } break;\n \n                 case OP_CHECKSIG:\n-                case OP_CHECKSIGVERIFY:\n-                {\n+                case OP_CHECKSIGVERIFY: {\n                     // (sig pubkey -- bool)\n                     if (stack.size() < 2)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n-                    valtype& vchSig    = stacktop(-2);\n+                    valtype& vchSig = stacktop(-2);\n                     valtype& vchPubKey = stacktop(-1);\n \n                     // Subset of script starting at the most recent codeseparator\n@@ -802,19 +782,16 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n-                    if (opcode == OP_CHECKSIGVERIFY)\n-                    {\n+                    if (opcode == OP_CHECKSIGVERIFY) {\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n                             return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);\n                     }\n-                }\n-                break;\n+                } break;\n \n                 case OP_CHECKMULTISIG:\n-                case OP_CHECKMULTISIGVERIFY:\n-                {\n+                case OP_CHECKMULTISIGVERIFY: {\n                     // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n \n                     int i = 1;\n@@ -844,16 +821,14 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signatures, since there's no way for a signature to sign itself\n-                    for (int k = 0; k < nSigsCount; k++)\n-                    {\n-                        valtype& vchSig = stacktop(-isig-k);\n+                    for (int k = 0; k < nSigsCount; k++) {\n+                        valtype& vchSig = stacktop(-isig - k);\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n                     bool fSuccess = true;\n-                    while (fSuccess && nSigsCount > 0)\n-                    {\n-                        valtype& vchSig    = stacktop(-isig);\n+                    while (fSuccess && nSigsCount > 0) {\n+                        valtype& vchSig = stacktop(-isig);\n                         valtype& vchPubKey = stacktop(-ikey);\n \n                         // Note how this makes the exact order of pubkey/signature evaluation\n@@ -899,27 +874,23 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n \n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n \n-                    if (opcode == OP_CHECKMULTISIGVERIFY)\n-                    {\n+                    if (opcode == OP_CHECKMULTISIGVERIFY) {\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n                             return set_error(serror, SCRIPT_ERR_CHECKMULTISIGVERIFY);\n                     }\n-                }\n-                break;\n+                } break;\n \n                 default:\n                     return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n-            }\n+                }\n \n             // Size limits\n             if (stack.size() + altstack.size() > 1000)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n         }\n-    }\n-    catch (...)\n-    {\n+    } catch (...) {\n         return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     }\n \n@@ -929,31 +900,32 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     return set_success(serror);\n }\n \n-namespace {\n-\n+namespace\n+{\n /**\n  * Wrapper that serializes like CTransaction, but with the modifications\n  *  required for the signature hash done in-place\n  */\n-class CTransactionSignatureSerializer {\n+class CTransactionSignatureSerializer\n+{\n private:\n-    const CTransaction &txTo;  //! reference to the spending transaction (the one being serialized)\n-    const CScript &scriptCode; //! output script being consumed\n+    const CTransaction& txTo;  //! reference to the spending transaction (the one being serialized)\n+    const CScript& scriptCode; //! output script being consumed\n     const unsigned int nIn;    //! input index of txTo being signed\n     const bool fAnyoneCanPay;  //! whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n     const bool fHashSingle;    //! whether the hashtype is SIGHASH_SINGLE\n     const bool fHashNone;      //! whether the hashtype is SIGHASH_NONE\n \n public:\n-    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n-        txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n-        fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n-        fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n-        fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n+    CTransactionSignatureSerializer(const CTransaction& txToIn, const CScript& scriptCodeIn, unsigned int nInIn, int nHashTypeIn) : txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n+                                                                                                                                    fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n+                                                                                                                                    fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n+                                                                                                                                    fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n \n     /** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */\n-    template<typename S>\n-    void SerializeScriptCode(S &s, int nType, int nVersion) const {\n+    template <typename S>\n+    void SerializeScriptCode(S& s, int nType, int nVersion) const\n+    {\n         CScript::const_iterator it = scriptCode.begin();\n         CScript::const_iterator itBegin = it;\n         opcodetype opcode;\n@@ -966,17 +938,18 @@ class CTransactionSignatureSerializer {\n         it = itBegin;\n         while (scriptCode.GetOp(it, opcode)) {\n             if (opcode == OP_CODESEPARATOR) {\n-                s.write((char*)&itBegin[0], it-itBegin-1);\n+                s.write((char*)&itBegin[0], it - itBegin - 1);\n                 itBegin = it;\n             }\n         }\n         if (itBegin != scriptCode.end())\n-            s.write((char*)&itBegin[0], it-itBegin);\n+            s.write((char*)&itBegin[0], it - itBegin);\n     }\n \n     /** Serialize an input of txTo */\n-    template<typename S>\n-    void SerializeInput(S &s, unsigned int nInput, int nType, int nVersion) const {\n+    template <typename S>\n+    void SerializeInput(S& s, unsigned int nInput, int nType, int nVersion) const\n+    {\n         // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized\n         if (fAnyoneCanPay)\n             nInput = nIn;\n@@ -997,8 +970,9 @@ class CTransactionSignatureSerializer {\n     }\n \n     /** Serialize an output of txTo */\n-    template<typename S>\n-    void SerializeOutput(S &s, unsigned int nOutput, int nType, int nVersion) const {\n+    template <typename S>\n+    void SerializeOutput(S& s, unsigned int nOutput, int nType, int nVersion) const\n+    {\n         if (fHashSingle && nOutput != nIn)\n             // Do not lock-in the txout payee at other indices as txin\n             ::Serialize(s, CTxOut(), nType, nVersion);\n@@ -1007,20 +981,21 @@ class CTransactionSignatureSerializer {\n     }\n \n     /** Serialize txTo */\n-    template<typename S>\n-    void Serialize(S &s, int nType, int nVersion) const {\n+    template <typename S>\n+    void Serialize(S& s, int nType, int nVersion) const\n+    {\n         // Serialize nVersion\n         ::Serialize(s, txTo.nVersion, nType, nVersion);\n         // Serialize vin\n         unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();\n         ::WriteCompactSize(s, nInputs);\n         for (unsigned int nInput = 0; nInput < nInputs; nInput++)\n-             SerializeInput(s, nInput, nType, nVersion);\n+            SerializeInput(s, nInput, nType, nVersion);\n         // Serialize vout\n-        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());\n+        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn + 1 : txTo.vout.size());\n         ::WriteCompactSize(s, nOutputs);\n         for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)\n-             SerializeOutput(s, nOutput, nType, nVersion);\n+            SerializeOutput(s, nOutput, nType, nVersion);\n         // Serialize nLockTime\n         ::Serialize(s, txTo.nLockTime, nType, nVersion);\n     }\n@@ -1102,8 +1077,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n         return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n     // Additional validation for spend-to-script-hash transactions:\n-    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n-    {\n+    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash()) {\n         // scriptSig must be literals-only or validation fails\n         if (!scriptSig.IsPushOnly())\n             return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);"
      },
      {
        "sha": "25e61e99c433a41056a8eecfdf0edef196b9a0ea",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 233,
        "deletions": 127,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -8,7 +8,8 @@\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n \n-namespace {\n+namespace\n+{\n inline std::string ValueString(const std::vector<unsigned char>& vch)\n {\n     if (vch.size() <= 4)\n@@ -22,136 +23,247 @@ using namespace std;\n \n const char* GetOpName(opcodetype opcode)\n {\n-    switch (opcode)\n-    {\n+    switch (opcode) {\n     // push value\n-    case OP_0                      : return \"0\";\n-    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n-    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n-    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n-    case OP_1NEGATE                : return \"-1\";\n-    case OP_RESERVED               : return \"OP_RESERVED\";\n-    case OP_1                      : return \"1\";\n-    case OP_2                      : return \"2\";\n-    case OP_3                      : return \"3\";\n-    case OP_4                      : return \"4\";\n-    case OP_5                      : return \"5\";\n-    case OP_6                      : return \"6\";\n-    case OP_7                      : return \"7\";\n-    case OP_8                      : return \"8\";\n-    case OP_9                      : return \"9\";\n-    case OP_10                     : return \"10\";\n-    case OP_11                     : return \"11\";\n-    case OP_12                     : return \"12\";\n-    case OP_13                     : return \"13\";\n-    case OP_14                     : return \"14\";\n-    case OP_15                     : return \"15\";\n-    case OP_16                     : return \"16\";\n+    case OP_0:\n+        return \"0\";\n+    case OP_PUSHDATA1:\n+        return \"OP_PUSHDATA1\";\n+    case OP_PUSHDATA2:\n+        return \"OP_PUSHDATA2\";\n+    case OP_PUSHDATA4:\n+        return \"OP_PUSHDATA4\";\n+    case OP_1NEGATE:\n+        return \"-1\";\n+    case OP_RESERVED:\n+        return \"OP_RESERVED\";\n+    case OP_1:\n+        return \"1\";\n+    case OP_2:\n+        return \"2\";\n+    case OP_3:\n+        return \"3\";\n+    case OP_4:\n+        return \"4\";\n+    case OP_5:\n+        return \"5\";\n+    case OP_6:\n+        return \"6\";\n+    case OP_7:\n+        return \"7\";\n+    case OP_8:\n+        return \"8\";\n+    case OP_9:\n+        return \"9\";\n+    case OP_10:\n+        return \"10\";\n+    case OP_11:\n+        return \"11\";\n+    case OP_12:\n+        return \"12\";\n+    case OP_13:\n+        return \"13\";\n+    case OP_14:\n+        return \"14\";\n+    case OP_15:\n+        return \"15\";\n+    case OP_16:\n+        return \"16\";\n \n     // control\n-    case OP_NOP                    : return \"OP_NOP\";\n-    case OP_VER                    : return \"OP_VER\";\n-    case OP_IF                     : return \"OP_IF\";\n-    case OP_NOTIF                  : return \"OP_NOTIF\";\n-    case OP_VERIF                  : return \"OP_VERIF\";\n-    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n-    case OP_ELSE                   : return \"OP_ELSE\";\n-    case OP_ENDIF                  : return \"OP_ENDIF\";\n-    case OP_VERIFY                 : return \"OP_VERIFY\";\n-    case OP_RETURN                 : return \"OP_RETURN\";\n+    case OP_NOP:\n+        return \"OP_NOP\";\n+    case OP_VER:\n+        return \"OP_VER\";\n+    case OP_IF:\n+        return \"OP_IF\";\n+    case OP_NOTIF:\n+        return \"OP_NOTIF\";\n+    case OP_VERIF:\n+        return \"OP_VERIF\";\n+    case OP_VERNOTIF:\n+        return \"OP_VERNOTIF\";\n+    case OP_ELSE:\n+        return \"OP_ELSE\";\n+    case OP_ENDIF:\n+        return \"OP_ENDIF\";\n+    case OP_VERIFY:\n+        return \"OP_VERIFY\";\n+    case OP_RETURN:\n+        return \"OP_RETURN\";\n \n     // stack ops\n-    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n-    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n-    case OP_2DROP                  : return \"OP_2DROP\";\n-    case OP_2DUP                   : return \"OP_2DUP\";\n-    case OP_3DUP                   : return \"OP_3DUP\";\n-    case OP_2OVER                  : return \"OP_2OVER\";\n-    case OP_2ROT                   : return \"OP_2ROT\";\n-    case OP_2SWAP                  : return \"OP_2SWAP\";\n-    case OP_IFDUP                  : return \"OP_IFDUP\";\n-    case OP_DEPTH                  : return \"OP_DEPTH\";\n-    case OP_DROP                   : return \"OP_DROP\";\n-    case OP_DUP                    : return \"OP_DUP\";\n-    case OP_NIP                    : return \"OP_NIP\";\n-    case OP_OVER                   : return \"OP_OVER\";\n-    case OP_PICK                   : return \"OP_PICK\";\n-    case OP_ROLL                   : return \"OP_ROLL\";\n-    case OP_ROT                    : return \"OP_ROT\";\n-    case OP_SWAP                   : return \"OP_SWAP\";\n-    case OP_TUCK                   : return \"OP_TUCK\";\n+    case OP_TOALTSTACK:\n+        return \"OP_TOALTSTACK\";\n+    case OP_FROMALTSTACK:\n+        return \"OP_FROMALTSTACK\";\n+    case OP_2DROP:\n+        return \"OP_2DROP\";\n+    case OP_2DUP:\n+        return \"OP_2DUP\";\n+    case OP_3DUP:\n+        return \"OP_3DUP\";\n+    case OP_2OVER:\n+        return \"OP_2OVER\";\n+    case OP_2ROT:\n+        return \"OP_2ROT\";\n+    case OP_2SWAP:\n+        return \"OP_2SWAP\";\n+    case OP_IFDUP:\n+        return \"OP_IFDUP\";\n+    case OP_DEPTH:\n+        return \"OP_DEPTH\";\n+    case OP_DROP:\n+        return \"OP_DROP\";\n+    case OP_DUP:\n+        return \"OP_DUP\";\n+    case OP_NIP:\n+        return \"OP_NIP\";\n+    case OP_OVER:\n+        return \"OP_OVER\";\n+    case OP_PICK:\n+        return \"OP_PICK\";\n+    case OP_ROLL:\n+        return \"OP_ROLL\";\n+    case OP_ROT:\n+        return \"OP_ROT\";\n+    case OP_SWAP:\n+        return \"OP_SWAP\";\n+    case OP_TUCK:\n+        return \"OP_TUCK\";\n \n     // splice ops\n-    case OP_CAT                    : return \"OP_CAT\";\n-    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n-    case OP_LEFT                   : return \"OP_LEFT\";\n-    case OP_RIGHT                  : return \"OP_RIGHT\";\n-    case OP_SIZE                   : return \"OP_SIZE\";\n+    case OP_CAT:\n+        return \"OP_CAT\";\n+    case OP_SUBSTR:\n+        return \"OP_SUBSTR\";\n+    case OP_LEFT:\n+        return \"OP_LEFT\";\n+    case OP_RIGHT:\n+        return \"OP_RIGHT\";\n+    case OP_SIZE:\n+        return \"OP_SIZE\";\n \n     // bit logic\n-    case OP_INVERT                 : return \"OP_INVERT\";\n-    case OP_AND                    : return \"OP_AND\";\n-    case OP_OR                     : return \"OP_OR\";\n-    case OP_XOR                    : return \"OP_XOR\";\n-    case OP_EQUAL                  : return \"OP_EQUAL\";\n-    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n-    case OP_RESERVED1              : return \"OP_RESERVED1\";\n-    case OP_RESERVED2              : return \"OP_RESERVED2\";\n+    case OP_INVERT:\n+        return \"OP_INVERT\";\n+    case OP_AND:\n+        return \"OP_AND\";\n+    case OP_OR:\n+        return \"OP_OR\";\n+    case OP_XOR:\n+        return \"OP_XOR\";\n+    case OP_EQUAL:\n+        return \"OP_EQUAL\";\n+    case OP_EQUALVERIFY:\n+        return \"OP_EQUALVERIFY\";\n+    case OP_RESERVED1:\n+        return \"OP_RESERVED1\";\n+    case OP_RESERVED2:\n+        return \"OP_RESERVED2\";\n \n     // numeric\n-    case OP_1ADD                   : return \"OP_1ADD\";\n-    case OP_1SUB                   : return \"OP_1SUB\";\n-    case OP_2MUL                   : return \"OP_2MUL\";\n-    case OP_2DIV                   : return \"OP_2DIV\";\n-    case OP_NEGATE                 : return \"OP_NEGATE\";\n-    case OP_ABS                    : return \"OP_ABS\";\n-    case OP_NOT                    : return \"OP_NOT\";\n-    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n-    case OP_ADD                    : return \"OP_ADD\";\n-    case OP_SUB                    : return \"OP_SUB\";\n-    case OP_MUL                    : return \"OP_MUL\";\n-    case OP_DIV                    : return \"OP_DIV\";\n-    case OP_MOD                    : return \"OP_MOD\";\n-    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n-    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n-    case OP_BOOLAND                : return \"OP_BOOLAND\";\n-    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n-    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n-    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n-    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n-    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n-    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n-    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n-    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n-    case OP_MIN                    : return \"OP_MIN\";\n-    case OP_MAX                    : return \"OP_MAX\";\n-    case OP_WITHIN                 : return \"OP_WITHIN\";\n+    case OP_1ADD:\n+        return \"OP_1ADD\";\n+    case OP_1SUB:\n+        return \"OP_1SUB\";\n+    case OP_2MUL:\n+        return \"OP_2MUL\";\n+    case OP_2DIV:\n+        return \"OP_2DIV\";\n+    case OP_NEGATE:\n+        return \"OP_NEGATE\";\n+    case OP_ABS:\n+        return \"OP_ABS\";\n+    case OP_NOT:\n+        return \"OP_NOT\";\n+    case OP_0NOTEQUAL:\n+        return \"OP_0NOTEQUAL\";\n+    case OP_ADD:\n+        return \"OP_ADD\";\n+    case OP_SUB:\n+        return \"OP_SUB\";\n+    case OP_MUL:\n+        return \"OP_MUL\";\n+    case OP_DIV:\n+        return \"OP_DIV\";\n+    case OP_MOD:\n+        return \"OP_MOD\";\n+    case OP_LSHIFT:\n+        return \"OP_LSHIFT\";\n+    case OP_RSHIFT:\n+        return \"OP_RSHIFT\";\n+    case OP_BOOLAND:\n+        return \"OP_BOOLAND\";\n+    case OP_BOOLOR:\n+        return \"OP_BOOLOR\";\n+    case OP_NUMEQUAL:\n+        return \"OP_NUMEQUAL\";\n+    case OP_NUMEQUALVERIFY:\n+        return \"OP_NUMEQUALVERIFY\";\n+    case OP_NUMNOTEQUAL:\n+        return \"OP_NUMNOTEQUAL\";\n+    case OP_LESSTHAN:\n+        return \"OP_LESSTHAN\";\n+    case OP_GREATERTHAN:\n+        return \"OP_GREATERTHAN\";\n+    case OP_LESSTHANOREQUAL:\n+        return \"OP_LESSTHANOREQUAL\";\n+    case OP_GREATERTHANOREQUAL:\n+        return \"OP_GREATERTHANOREQUAL\";\n+    case OP_MIN:\n+        return \"OP_MIN\";\n+    case OP_MAX:\n+        return \"OP_MAX\";\n+    case OP_WITHIN:\n+        return \"OP_WITHIN\";\n \n     // crypto\n-    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n-    case OP_SHA1                   : return \"OP_SHA1\";\n-    case OP_SHA256                 : return \"OP_SHA256\";\n-    case OP_HASH160                : return \"OP_HASH160\";\n-    case OP_HASH256                : return \"OP_HASH256\";\n-    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n-    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n-    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n-    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n-    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n+    case OP_RIPEMD160:\n+        return \"OP_RIPEMD160\";\n+    case OP_SHA1:\n+        return \"OP_SHA1\";\n+    case OP_SHA256:\n+        return \"OP_SHA256\";\n+    case OP_HASH160:\n+        return \"OP_HASH160\";\n+    case OP_HASH256:\n+        return \"OP_HASH256\";\n+    case OP_CODESEPARATOR:\n+        return \"OP_CODESEPARATOR\";\n+    case OP_CHECKSIG:\n+        return \"OP_CHECKSIG\";\n+    case OP_CHECKSIGVERIFY:\n+        return \"OP_CHECKSIGVERIFY\";\n+    case OP_CHECKMULTISIG:\n+        return \"OP_CHECKMULTISIG\";\n+    case OP_CHECKMULTISIGVERIFY:\n+        return \"OP_CHECKMULTISIGVERIFY\";\n \n     // expanson\n-    case OP_NOP1                   : return \"OP_NOP1\";\n-    case OP_NOP2                   : return \"OP_NOP2\";\n-    case OP_NOP3                   : return \"OP_NOP3\";\n-    case OP_NOP4                   : return \"OP_NOP4\";\n-    case OP_NOP5                   : return \"OP_NOP5\";\n-    case OP_NOP6                   : return \"OP_NOP6\";\n-    case OP_NOP7                   : return \"OP_NOP7\";\n-    case OP_NOP8                   : return \"OP_NOP8\";\n-    case OP_NOP9                   : return \"OP_NOP9\";\n-    case OP_NOP10                  : return \"OP_NOP10\";\n+    case OP_NOP1:\n+        return \"OP_NOP1\";\n+    case OP_NOP2:\n+        return \"OP_NOP2\";\n+    case OP_NOP3:\n+        return \"OP_NOP3\";\n+    case OP_NOP4:\n+        return \"OP_NOP4\";\n+    case OP_NOP5:\n+        return \"OP_NOP5\";\n+    case OP_NOP6:\n+        return \"OP_NOP6\";\n+    case OP_NOP7:\n+        return \"OP_NOP7\";\n+    case OP_NOP8:\n+        return \"OP_NOP8\";\n+    case OP_NOP9:\n+        return \"OP_NOP9\";\n+    case OP_NOP10:\n+        return \"OP_NOP10\";\n \n-    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n+    case OP_INVALIDOPCODE:\n+        return \"OP_INVALIDOPCODE\";\n \n     // Note:\n     //  The template matching params OP_SMALLDATA/etc are defined in opcodetype enum\n@@ -168,15 +280,13 @@ unsigned int CScript::GetSigOpCount(bool fAccurate) const\n     unsigned int n = 0;\n     const_iterator pc = begin();\n     opcodetype lastOpcode = OP_INVALIDOPCODE;\n-    while (pc < end())\n-    {\n+    while (pc < end()) {\n         opcodetype opcode;\n         if (!GetOp(pc, opcode))\n             break;\n         if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n             n++;\n-        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-        {\n+        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY) {\n             if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n                 n += DecodeOP_N(lastOpcode);\n             else\n@@ -197,8 +307,7 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     // pushes onto the stack:\n     const_iterator pc = scriptSig.begin();\n     vector<unsigned char> data;\n-    while (pc < scriptSig.end())\n-    {\n+    while (pc < scriptSig.end()) {\n         opcodetype opcode;\n         if (!scriptSig.GetOp(pc, opcode, data))\n             return 0;\n@@ -223,8 +332,7 @@ bool CScript::IsPayToScriptHash() const\n bool CScript::IsPushOnly() const\n {\n     const_iterator pc = begin();\n-    while (pc < end())\n-    {\n+    while (pc < end()) {\n         opcodetype opcode;\n         if (!GetOp(pc, opcode))\n             return false;\n@@ -244,12 +352,10 @@ std::string CScript::ToString() const\n     opcodetype opcode;\n     std::vector<unsigned char> vch;\n     const_iterator pc = begin();\n-    while (pc < end())\n-    {\n+    while (pc < end()) {\n         if (!str.empty())\n             str += \" \";\n-        if (!GetOp(pc, opcode, vch))\n-        {\n+        if (!GetOp(pc, opcode, vch)) {\n             str += \"[error]\";\n             return str;\n         }"
      },
      {
        "sha": "d297e733d7de63420298ec6d78d39a225914575e",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 59,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -7,65 +7,65 @@\n \n const char* ScriptErrorString(const ScriptError serror)\n {\n-    switch (serror)\n-    {\n-        case SCRIPT_ERR_OK:\n-            return \"No error\";\n-        case SCRIPT_ERR_EVAL_FALSE:\n-            return \"Script evaluated without error but finished with a false/empty top stack element\";\n-        case SCRIPT_ERR_VERIFY:\n-            return \"Script failed an OP_VERIFY operation\";\n-        case SCRIPT_ERR_EQUALVERIFY:\n-            return \"Script failed an OP_EQUALVERIFY operation\";\n-        case SCRIPT_ERR_CHECKMULTISIGVERIFY:\n-            return \"Script failed an OP_CHECKMULTISIGVERIFY operation\";\n-        case SCRIPT_ERR_CHECKSIGVERIFY:\n-            return \"Script failed an OP_CHECKSIGVERIFY operation\";\n-        case SCRIPT_ERR_NUMEQUALVERIFY:\n-            return \"Script failed an OP_NUMEQUALVERIFY operation\";\n-        case SCRIPT_ERR_SCRIPT_SIZE:\n-            return \"Script is too big\";\n-        case SCRIPT_ERR_PUSH_SIZE:\n-            return \"Push value size limit exceeded\";\n-        case SCRIPT_ERR_OP_COUNT:\n-            return \"Operation limit exceeded\";\n-        case SCRIPT_ERR_STACK_SIZE:\n-            return \"Stack size limit exceeded\";\n-        case SCRIPT_ERR_SIG_COUNT:\n-            return \"Signature count negative or greater than pubkey count\";\n-        case SCRIPT_ERR_PUBKEY_COUNT:\n-            return \"Pubkey count negative or limit exceeded\";\n-        case SCRIPT_ERR_BAD_OPCODE:\n-            return \"Opcode missing or not understood\";\n-        case SCRIPT_ERR_DISABLED_OPCODE:\n-            return \"Attempted to use a disabled opcode\";\n-        case SCRIPT_ERR_INVALID_STACK_OPERATION:\n-            return \"Operation not valid with the current stack size\";\n-        case SCRIPT_ERR_INVALID_ALTSTACK_OPERATION:\n-            return \"Operation not valid with the current altstack size\";\n-        case SCRIPT_ERR_OP_RETURN:\n-            return \"OP_RETURN was encountered\";\n-        case SCRIPT_ERR_UNBALANCED_CONDITIONAL:\n-            return \"Invalid OP_IF construction\";\n-        case SCRIPT_ERR_SIG_HASHTYPE:\n-            return \"Signature hash type missing or not understood\";\n-        case SCRIPT_ERR_SIG_DER:\n-            return \"Non-canonical DER signature\";\n-        case SCRIPT_ERR_MINIMALDATA:\n-            return \"Data push larger than necessary\";\n-        case SCRIPT_ERR_SIG_PUSHONLY:\n-            return \"Only non-push operators allowed in signatures\";\n-        case SCRIPT_ERR_SIG_HIGH_S:\n-            return \"Non-canonical signature: S value is unnecessarily high\";\n-        case SCRIPT_ERR_SIG_NULLDUMMY:\n-            return \"Dummy CHECKMULTISIG argument must be zero\";\n-        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS:\n-            return \"NOPx reserved for soft-fork upgrades\";\n-        case SCRIPT_ERR_PUBKEYTYPE:\n-            return \"Public key is neither compressed or uncompressed\";\n-        case SCRIPT_ERR_UNKNOWN_ERROR:\n-        case SCRIPT_ERR_ERROR_COUNT:\n-        default: break;\n+    switch (serror) {\n+    case SCRIPT_ERR_OK:\n+        return \"No error\";\n+    case SCRIPT_ERR_EVAL_FALSE:\n+        return \"Script evaluated without error but finished with a false/empty top stack element\";\n+    case SCRIPT_ERR_VERIFY:\n+        return \"Script failed an OP_VERIFY operation\";\n+    case SCRIPT_ERR_EQUALVERIFY:\n+        return \"Script failed an OP_EQUALVERIFY operation\";\n+    case SCRIPT_ERR_CHECKMULTISIGVERIFY:\n+        return \"Script failed an OP_CHECKMULTISIGVERIFY operation\";\n+    case SCRIPT_ERR_CHECKSIGVERIFY:\n+        return \"Script failed an OP_CHECKSIGVERIFY operation\";\n+    case SCRIPT_ERR_NUMEQUALVERIFY:\n+        return \"Script failed an OP_NUMEQUALVERIFY operation\";\n+    case SCRIPT_ERR_SCRIPT_SIZE:\n+        return \"Script is too big\";\n+    case SCRIPT_ERR_PUSH_SIZE:\n+        return \"Push value size limit exceeded\";\n+    case SCRIPT_ERR_OP_COUNT:\n+        return \"Operation limit exceeded\";\n+    case SCRIPT_ERR_STACK_SIZE:\n+        return \"Stack size limit exceeded\";\n+    case SCRIPT_ERR_SIG_COUNT:\n+        return \"Signature count negative or greater than pubkey count\";\n+    case SCRIPT_ERR_PUBKEY_COUNT:\n+        return \"Pubkey count negative or limit exceeded\";\n+    case SCRIPT_ERR_BAD_OPCODE:\n+        return \"Opcode missing or not understood\";\n+    case SCRIPT_ERR_DISABLED_OPCODE:\n+        return \"Attempted to use a disabled opcode\";\n+    case SCRIPT_ERR_INVALID_STACK_OPERATION:\n+        return \"Operation not valid with the current stack size\";\n+    case SCRIPT_ERR_INVALID_ALTSTACK_OPERATION:\n+        return \"Operation not valid with the current altstack size\";\n+    case SCRIPT_ERR_OP_RETURN:\n+        return \"OP_RETURN was encountered\";\n+    case SCRIPT_ERR_UNBALANCED_CONDITIONAL:\n+        return \"Invalid OP_IF construction\";\n+    case SCRIPT_ERR_SIG_HASHTYPE:\n+        return \"Signature hash type missing or not understood\";\n+    case SCRIPT_ERR_SIG_DER:\n+        return \"Non-canonical DER signature\";\n+    case SCRIPT_ERR_MINIMALDATA:\n+        return \"Data push larger than necessary\";\n+    case SCRIPT_ERR_SIG_PUSHONLY:\n+        return \"Only non-push operators allowed in signatures\";\n+    case SCRIPT_ERR_SIG_HIGH_S:\n+        return \"Non-canonical signature: S value is unnecessarily high\";\n+    case SCRIPT_ERR_SIG_NULLDUMMY:\n+        return \"Dummy CHECKMULTISIG argument must be zero\";\n+    case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS:\n+        return \"NOPx reserved for soft-fork upgrades\";\n+    case SCRIPT_ERR_PUBKEYTYPE:\n+        return \"Public key is neither compressed or uncompressed\";\n+    case SCRIPT_ERR_UNKNOWN_ERROR:\n+    case SCRIPT_ERR_ERROR_COUNT:\n+    default:\n+        break;\n     }\n     return \"unknown error\";\n }"
      },
      {
        "sha": "26478672f20ff7c26f48c78285a7d819b55cdc8a",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,8 +13,8 @@\n #include <boost/thread.hpp>\n #include <boost/tuple/tuple_comparison.hpp>\n \n-namespace {\n-\n+namespace\n+{\n /**\n  * Valid signature cache, to avoid doing expensive ECDSA signature checking\n  * twice for every transaction (once when accepted into memory pool, and\n@@ -23,14 +23,14 @@ namespace {\n class CSignatureCache\n {\n private:\n-     //! sigdata_type is (signature hash, signature, public key):\n+    //! sigdata_type is (signature hash, signature, public key):\n     typedef boost::tuple<uint256, std::vector<unsigned char>, CPubKey> sigdata_type;\n-    std::set< sigdata_type> setValid;\n+    std::set<sigdata_type> setValid;\n     boost::shared_mutex cs_sigcache;\n \n public:\n     bool\n-    Get(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n+    Get(const uint256& hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n     {\n         boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n \n@@ -41,19 +41,19 @@ class CSignatureCache\n         return false;\n     }\n \n-    void Set(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n+    void Set(const uint256& hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n     {\n         // DoS prevention: limit cache size to less than 10MB\n         // (~200 bytes per cache entry times 50,000 entries)\n         // Since there are a maximum of 20,000 signature operations per block\n         // 50,000 is a reasonable default.\n         int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n-        if (nMaxCacheSize <= 0) return;\n+        if (nMaxCacheSize <= 0)\n+            return;\n \n         boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n \n-        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n-        {\n+        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize) {\n             // Evict a random entry. Random because that helps\n             // foil would-be DoS attackers who might try to pre-generate\n             // and re-use a set of valid signatures just-slightly-greater\n@@ -71,7 +71,6 @@ class CSignatureCache\n         setValid.insert(k);\n     }\n };\n-\n }\n \n bool CachingSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const"
      },
      {
        "sha": "1cfb0e6eaa91503a17bbcd94d753c9e60545809d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 45,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -36,14 +36,13 @@ bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint2\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n-    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n-    {\n+    for (unsigned int i = 1; i < multisigdata.size() - 1 && nSigned < nRequired; i++) {\n         const valtype& pubkey = multisigdata[i];\n         CKeyID keyID = CPubKey(pubkey).GetID();\n         if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n             ++nSigned;\n     }\n-    return nSigned==nRequired;\n+    return nSigned == nRequired;\n }\n \n /**\n@@ -52,8 +51,7 @@ bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint2\n  * unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n  * Returns false if scriptPubKey could not be completely satisfied.\n  */\n-bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n-                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n+bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet, txnouttype& whichTypeRet)\n {\n     scriptSigRet.clear();\n \n@@ -62,8 +60,7 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n         return false;\n \n     CKeyID keyID;\n-    switch (whichTypeRet)\n-    {\n+    switch (whichTypeRet) {\n     case TX_NONSTANDARD:\n     case TX_NULL_DATA:\n         return false;\n@@ -74,8 +71,7 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n         keyID = CKeyID(uint160(vSolutions[0]));\n         if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n             return false;\n-        else\n-        {\n+        else {\n             CPubKey vch;\n             keystore.GetPubKey(keyID, vch);\n             scriptSigRet << ToByteVector(vch);\n@@ -91,7 +87,7 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n     return false;\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -104,8 +100,7 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutabl\n     if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n         return false;\n \n-    if (whichType == TX_SCRIPTHASH)\n-    {\n+    if (whichType == TX_SCRIPTHASH) {\n         // Solver returns the subscript that need to be evaluated;\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n@@ -119,14 +114,15 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutabl\n             Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n         // Append serialized subscript whether or not it is completely signed:\n         txin.scriptSig << static_cast<valtype>(subscript);\n-        if (!fSolved) return false;\n+        if (!fSolved)\n+            return false;\n     }\n \n     // Test solution\n     return VerifyScript(txin.scriptSig, fromPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, SignatureChecker(txTo, nIn));\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -139,56 +135,48 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutab\n static CScript PushAll(const vector<valtype>& values)\n {\n     CScript result;\n-    BOOST_FOREACH(const valtype& v, values)\n+    BOOST_FOREACH (const valtype& v, values)\n         result << v;\n     return result;\n }\n \n-static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                               const vector<valtype>& vSolutions,\n-                               const vector<valtype>& sigs1, const vector<valtype>& sigs2)\n+static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const vector<valtype>& vSolutions, const vector<valtype>& sigs1, const vector<valtype>& sigs2)\n {\n     // Combine all the signatures we've got:\n     set<valtype> allsigs;\n-    BOOST_FOREACH(const valtype& v, sigs1)\n-    {\n+    BOOST_FOREACH (const valtype& v, sigs1) {\n         if (!v.empty())\n             allsigs.insert(v);\n     }\n-    BOOST_FOREACH(const valtype& v, sigs2)\n-    {\n+    BOOST_FOREACH (const valtype& v, sigs2) {\n         if (!v.empty())\n             allsigs.insert(v);\n     }\n \n     // Build a map of pubkey -> signature by matching sigs to pubkeys:\n     assert(vSolutions.size() > 1);\n     unsigned int nSigsRequired = vSolutions.front()[0];\n-    unsigned int nPubKeys = vSolutions.size()-2;\n+    unsigned int nPubKeys = vSolutions.size() - 2;\n     map<valtype, valtype> sigs;\n-    BOOST_FOREACH(const valtype& sig, allsigs)\n-    {\n-        for (unsigned int i = 0; i < nPubKeys; i++)\n-        {\n-            const valtype& pubkey = vSolutions[i+1];\n+    BOOST_FOREACH (const valtype& sig, allsigs) {\n+        for (unsigned int i = 0; i < nPubKeys; i++) {\n+            const valtype& pubkey = vSolutions[i + 1];\n             if (sigs.count(pubkey))\n                 continue; // Already got a sig for this pubkey\n \n-            if (SignatureChecker(txTo, nIn).CheckSig(sig, pubkey, scriptPubKey))\n-            {\n+            if (SignatureChecker(txTo, nIn).CheckSig(sig, pubkey, scriptPubKey)) {\n                 sigs[pubkey] = sig;\n                 break;\n             }\n         }\n     }\n     // Now build a merged CScript:\n     unsigned int nSigsHave = 0;\n-    CScript result; result << OP_0; // pop-one-too-many workaround\n-    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n-    {\n-        if (sigs.count(vSolutions[i+1]))\n-        {\n-            result << sigs[vSolutions[i+1]];\n+    CScript result;\n+    result << OP_0; // pop-one-too-many workaround\n+    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++) {\n+        if (sigs.count(vSolutions[i + 1])) {\n+            result << sigs[vSolutions[i + 1]];\n             ++nSigsHave;\n         }\n     }\n@@ -199,12 +187,9 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const CTransaction&\n     return result;\n }\n \n-static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                                 const txnouttype txType, const vector<valtype>& vSolutions,\n-                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n+static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const txnouttype txType, const vector<valtype>& vSolutions, vector<valtype>& sigs1, vector<valtype>& sigs2)\n {\n-    switch (txType)\n-    {\n+    switch (txType) {\n     case TX_NONSTANDARD:\n     case TX_NULL_DATA:\n         // Don't know anything about this, assume bigger one is correct:\n@@ -222,8 +207,7 @@ static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction\n             return PushAll(sigs2);\n         else if (sigs2.empty() || sigs2.back().empty())\n             return PushAll(sigs1);\n-        else\n-        {\n+        else {\n             // Recur to combine:\n             valtype spk = sigs1.back();\n             CScript pubKey2(spk.begin(), spk.end());\n@@ -244,8 +228,7 @@ static CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction\n     return CScript();\n }\n \n-CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                          const CScript& scriptSig1, const CScript& scriptSig2)\n+CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2)\n {\n     txnouttype txType;\n     vector<vector<unsigned char> > vSolutions;"
      },
      {
        "sha": "9a6401312c43daa1571ecdc908763a9630910f15",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 71,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -22,14 +22,19 @@ CScriptID::CScriptID(const CScript& in) : uint160(in.size() ? Hash160(in.begin()\n \n const char* GetTxnOutputType(txnouttype t)\n {\n-    switch (t)\n-    {\n-    case TX_NONSTANDARD: return \"nonstandard\";\n-    case TX_PUBKEY: return \"pubkey\";\n-    case TX_PUBKEYHASH: return \"pubkeyhash\";\n-    case TX_SCRIPTHASH: return \"scripthash\";\n-    case TX_MULTISIG: return \"multisig\";\n-    case TX_NULL_DATA: return \"nulldata\";\n+    switch (t) {\n+    case TX_NONSTANDARD:\n+        return \"nonstandard\";\n+    case TX_PUBKEY:\n+        return \"pubkey\";\n+    case TX_PUBKEYHASH:\n+        return \"pubkeyhash\";\n+    case TX_SCRIPTHASH:\n+        return \"scripthash\";\n+    case TX_MULTISIG:\n+        return \"multisig\";\n+    case TX_NULL_DATA:\n+        return \"nulldata\";\n     }\n     return NULL;\n }\n@@ -41,8 +46,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n {\n     // Templates\n     static multimap<txnouttype, CScript> mTemplates;\n-    if (mTemplates.empty())\n-    {\n+    if (mTemplates.empty()) {\n         // Standard tx, sender provides pubkey, receiver adds signature\n         mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n \n@@ -60,18 +64,16 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n \n     // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n     // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n-    if (scriptPubKey.IsPayToScriptHash())\n-    {\n+    if (scriptPubKey.IsPayToScriptHash()) {\n         typeRet = TX_SCRIPTHASH;\n-        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n+        vector<unsigned char> hashBytes(scriptPubKey.begin() + 2, scriptPubKey.begin() + 22);\n         vSolutionsRet.push_back(hashBytes);\n         return true;\n     }\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n-    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(txnouttype, CScript) & tplate, mTemplates) {\n         const CScript& script2 = tplate.second;\n         vSolutionsRet.clear();\n \n@@ -81,18 +83,15 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n         // Compare\n         CScript::const_iterator pc1 = script1.begin();\n         CScript::const_iterator pc2 = script2.begin();\n-        while (true)\n-        {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n+        while (true) {\n+            if (pc1 == script1.end() && pc2 == script2.end()) {\n                 // Found a match\n                 typeRet = tplate.first;\n-                if (typeRet == TX_MULTISIG)\n-                {\n+                if (typeRet == TX_MULTISIG) {\n                     // Additional checks for TX_MULTISIG:\n                     unsigned char m = vSolutionsRet.front()[0];\n                     unsigned char n = vSolutionsRet.back()[0];\n-                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n+                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size() - 2 != n)\n                         return false;\n                 }\n                 return true;\n@@ -103,10 +102,8 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n                 break;\n \n             // Template matching opcodes:\n-            if (opcode2 == OP_PUBKEYS)\n-            {\n-                while (vch1.size() >= 33 && vch1.size() <= 65)\n-                {\n+            if (opcode2 == OP_PUBKEYS) {\n+                while (vch1.size() >= 33 && vch1.size() <= 65) {\n                     vSolutionsRet.push_back(vch1);\n                     if (!script1.GetOp(pc1, opcode1, vch1))\n                         break;\n@@ -117,37 +114,26 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n                 // to other if/else statements\n             }\n \n-            if (opcode2 == OP_PUBKEY)\n-            {\n+            if (opcode2 == OP_PUBKEY) {\n                 if (vch1.size() < 33 || vch1.size() > 65)\n                     break;\n                 vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n+            } else if (opcode2 == OP_PUBKEYHASH) {\n                 if (vch1.size() != sizeof(uint160))\n                     break;\n                 vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_SMALLINTEGER)\n-            {   // Single-byte small integer pushed onto vSolutions\n+            } else if (opcode2 == OP_SMALLINTEGER) { // Single-byte small integer pushed onto vSolutions\n                 if (opcode1 == OP_0 ||\n-                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n-                {\n+                    (opcode1 >= OP_1 && opcode1 <= OP_16)) {\n                     char n = (char)CScript::DecodeOP_N(opcode1);\n                     vSolutionsRet.push_back(valtype(1, n));\n-                }\n-                else\n+                } else\n                     break;\n-            }\n-            else if (opcode2 == OP_SMALLDATA)\n-            {\n+            } else if (opcode2 == OP_SMALLDATA) {\n                 // small pushdata, <= nMaxDatacarrierBytes\n                 if (vch1.size() > nMaxDatacarrierBytes)\n                     break;\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n+            } else if (opcode1 != opcode2 || vch1 != vch2) {\n                 // Others must match exactly\n                 break;\n             }\n@@ -161,8 +147,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n \n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n {\n-    switch (t)\n-    {\n+    switch (t) {\n     case TX_NONSTANDARD:\n     case TX_NULL_DATA:\n         return -1;\n@@ -186,8 +171,7 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n-    if (whichType == TX_MULTISIG)\n-    {\n+    if (whichType == TX_MULTISIG) {\n         unsigned char m = vSolutions.front()[0];\n         unsigned char n = vSolutions.back()[0];\n         // Support up to x-of-3 multisig txns as standard\n@@ -207,22 +191,17 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n-    if (whichType == TX_PUBKEY)\n-    {\n+    if (whichType == TX_PUBKEY) {\n         CPubKey pubKey(vSolutions[0]);\n         if (!pubKey.IsValid())\n             return false;\n \n         addressRet = pubKey.GetID();\n         return true;\n-    }\n-    else if (whichType == TX_PUBKEYHASH)\n-    {\n+    } else if (whichType == TX_PUBKEYHASH) {\n         addressRet = CKeyID(uint160(vSolutions[0]));\n         return true;\n-    }\n-    else if (whichType == TX_SCRIPTHASH)\n-    {\n+    } else if (whichType == TX_SCRIPTHASH) {\n         addressRet = CScriptID(uint160(vSolutions[0]));\n         return true;\n     }\n@@ -237,16 +216,14 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vecto\n     vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, typeRet, vSolutions))\n         return false;\n-    if (typeRet == TX_NULL_DATA){\n+    if (typeRet == TX_NULL_DATA) {\n         // This is data, not addresses\n         return false;\n     }\n \n-    if (typeRet == TX_MULTISIG)\n-    {\n+    if (typeRet == TX_MULTISIG) {\n         nRequiredRet = vSolutions.front()[0];\n-        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n-        {\n+        for (unsigned int i = 1; i < vSolutions.size() - 1; i++) {\n             CPubKey pubKey(vSolutions[i]);\n             if (!pubKey.IsValid())\n                 continue;\n@@ -257,13 +234,11 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vecto\n \n         if (addressRet.empty())\n             return false;\n-    }\n-    else\n-    {\n+    } else {\n         nRequiredRet = 1;\n         CTxDestination address;\n         if (!ExtractDestination(scriptPubKey, address))\n-           return false;\n+            return false;\n         addressRet.push_back(address);\n     }\n \n@@ -275,22 +250,26 @@ namespace\n class CScriptVisitor : public boost::static_visitor<bool>\n {\n private:\n-    CScript *script;\n+    CScript* script;\n+\n public:\n-    CScriptVisitor(CScript *scriptin) { script = scriptin; }\n+    CScriptVisitor(CScript* scriptin) { script = scriptin; }\n \n-    bool operator()(const CNoDestination &dest) const {\n+    bool operator()(const CNoDestination& dest) const\n+    {\n         script->clear();\n         return false;\n     }\n \n-    bool operator()(const CKeyID &keyID) const {\n+    bool operator()(const CKeyID& keyID) const\n+    {\n         script->clear();\n         *script << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;\n         return true;\n     }\n \n-    bool operator()(const CScriptID &scriptID) const {\n+    bool operator()(const CScriptID& scriptID) const\n+    {\n         script->clear();\n         *script << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;\n         return true;\n@@ -311,7 +290,7 @@ CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys)\n     CScript script;\n \n     script << CScript::EncodeOP_N(nRequired);\n-    BOOST_FOREACH(const CPubKey& key, keys)\n+    BOOST_FOREACH (const CPubKey& key, keys)\n         script << ToByteVector(key);\n     script << CScript::EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n     return script;"
      },
      {
        "sha": "956e35832edf3584bb54999c8ce41f342055b43a",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -32,7 +32,8 @@ void PrintLockContention(const char* pszName, const char* pszFile, int nLine)\n // Complain if any thread tries to lock in a different order.\n //\n \n-struct CLockLocation {\n+struct CLockLocation\n+{\n     CLockLocation(const char* pszName, const char* pszFile, int nLine)\n     {\n         mutexName = pszName;"
      },
      {
        "sha": "3889bf72c716996488d1294c1d909a45a4832993",
        "filename": "src/test/Checkpoints_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/Checkpoints_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/Checkpoints_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/Checkpoints_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -23,16 +23,16 @@ BOOST_AUTO_TEST_CASE(sanity)\n     BOOST_CHECK(Checkpoints::CheckBlock(11111, p11111));\n     BOOST_CHECK(Checkpoints::CheckBlock(134444, p134444));\n \n-    \n+\n     // Wrong hashes at checkpoints should fail:\n     BOOST_CHECK(!Checkpoints::CheckBlock(11111, p134444));\n     BOOST_CHECK(!Checkpoints::CheckBlock(134444, p11111));\n \n     // ... but any hash not at a checkpoint should succeed:\n-    BOOST_CHECK(Checkpoints::CheckBlock(11111+1, p134444));\n-    BOOST_CHECK(Checkpoints::CheckBlock(134444+1, p11111));\n+    BOOST_CHECK(Checkpoints::CheckBlock(11111 + 1, p134444));\n+    BOOST_CHECK(Checkpoints::CheckBlock(134444 + 1, p11111));\n \n     BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate() >= 134444);\n-}    \n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c2bb81d4b63815699f2e06628705482d6c6c2b70",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 18,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -7,7 +7,6 @@\n //\n \n \n-\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"net.h\"\n@@ -27,7 +26,8 @@\n extern bool AddOrphanTx(const CTransaction& tx, NodeId peer);\n extern void EraseOrphansFor(NodeId peer);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n-struct COrphanTx {\n+struct COrphanTx\n+{\n     CTransaction tx;\n     NodeId fromPeer;\n };\n@@ -52,7 +52,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     SendMessages(&dummyNode1, false);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n-    BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n+    BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001 | 0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002));\n     CNode dummyNode2(INVALID_SOCKET, addr2, \"\", true);\n@@ -99,10 +99,10 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     SendMessages(&dummyNode, false);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n-    SetMockTime(nStartTime+60*60);\n+    SetMockTime(nStartTime + 60 * 60);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n-    SetMockTime(nStartTime+60*60*24+1);\n+    SetMockTime(nStartTime + 60 * 60 * 24 + 1);\n     BOOST_CHECK(!CNode::IsBanned(addr));\n }\n \n@@ -123,49 +123,45 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     keystore.AddKey(key);\n \n     // 50 orphan transactions:\n-    for (int i = 0; i < 50; i++)\n-    {\n+    for (int i = 0; i < 50; i++) {\n         CMutableTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n         tx.vin[0].prevout.hash = GetRandHash();\n         tx.vin[0].scriptSig << OP_1;\n         tx.vout.resize(1);\n-        tx.vout[0].nValue = 1*CENT;\n+        tx.vout[0].nValue = 1 * CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n \n         AddOrphanTx(tx, i);\n     }\n \n     // ... and 50 that depend on other orphans:\n-    for (int i = 0; i < 50; i++)\n-    {\n+    for (int i = 0; i < 50; i++) {\n         CTransaction txPrev = RandomOrphan();\n \n         CMutableTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n         tx.vin[0].prevout.hash = txPrev.GetHash();\n         tx.vout.resize(1);\n-        tx.vout[0].nValue = 1*CENT;\n+        tx.vout[0].nValue = 1 * CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n         SignSignature(keystore, txPrev, tx, 0);\n \n         AddOrphanTx(tx, i);\n     }\n \n     // This really-big orphan should be ignored:\n-    for (int i = 0; i < 10; i++)\n-    {\n+    for (int i = 0; i < 10; i++) {\n         CTransaction txPrev = RandomOrphan();\n \n         CMutableTransaction tx;\n         tx.vout.resize(1);\n-        tx.vout[0].nValue = 1*CENT;\n+        tx.vout[0].nValue = 1 * CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n         tx.vin.resize(500);\n-        for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        {\n+        for (unsigned int j = 0; j < tx.vin.size(); j++) {\n             tx.vin[j].prevout.n = j;\n             tx.vin[j].prevout.hash = txPrev.GetHash();\n         }\n@@ -179,8 +175,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     }\n \n     // Test EraseOrphansFor:\n-    for (NodeId i = 0; i < 3; i++)\n-    {\n+    for (NodeId i = 0; i < 3; i++) {\n         size_t sizeBefore = mapOrphanTransactions.size();\n         EraseOrphansFor(i);\n         BOOST_CHECK(mapOrphanTransactions.size() < sizeBefore);"
      },
      {
        "sha": "951f32edb45e7111ea330fdde47fadea5467dec8",
        "filename": "src/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/accounting_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -22,8 +22,7 @@ GetResults(CWalletDB& walletdb, std::map<CAmount, CAccountingEntry>& results)\n     results.clear();\n     BOOST_CHECK(walletdb.ReorderTransactions(pwalletMain) == DB_LOAD_OK);\n     walletdb.ListAccountCreditDebit(\"\", aes);\n-    BOOST_FOREACH(CAccountingEntry& ae, aes)\n-    {\n+    BOOST_FOREACH (CAccountingEntry& ae, aes) {\n         results[ae.nOrderPos] = ae;\n     }\n }\n@@ -85,7 +84,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     wtx.mapValue[\"comment\"] = \"y\";\n     {\n         CMutableTransaction tx(wtx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        --tx.nLockTime; // Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n     pwalletMain->AddToWallet(wtx);\n@@ -95,7 +94,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     wtx.mapValue[\"comment\"] = \"x\";\n     {\n         CMutableTransaction tx(wtx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        --tx.nLockTime; // Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n     pwalletMain->AddToWallet(wtx);"
      },
      {
        "sha": "4d66723892b8775385a80b0943b62dd644e694f2",
        "filename": "src/test/alert_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 8,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/alert_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/alert_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/alert_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -85,24 +85,23 @@ struct ReadAlerts\n         std::vector<unsigned char> vch(alert_tests::alertTests, alert_tests::alertTests + sizeof(alert_tests::alertTests));\n         CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n         try {\n-            while (!stream.eof())\n-            {\n+            while (!stream.eof()) {\n                 CAlert alert;\n                 stream >> alert;\n                 alerts.push_back(alert);\n             }\n+        } catch (std::exception) {\n         }\n-        catch (std::exception) { }\n     }\n-    ~ReadAlerts() { }\n+    ~ReadAlerts() {}\n \n     static std::vector<std::string> read_lines(boost::filesystem::path filepath)\n     {\n         std::vector<std::string> result;\n \n         std::ifstream f(filepath.string().c_str());\n         std::string line;\n-        while (std::getline(f,line))\n+        while (std::getline(f, line))\n             result.push_back(line);\n \n         return result;\n@@ -118,8 +117,7 @@ BOOST_AUTO_TEST_CASE(AlertApplies)\n {\n     SetMockTime(11);\n \n-    BOOST_FOREACH(const CAlert& alert, alerts)\n-    {\n+    BOOST_FOREACH (const CAlert& alert, alerts) {\n         BOOST_CHECK(alert.CheckSignature());\n     }\n \n@@ -163,7 +161,7 @@ BOOST_AUTO_TEST_CASE(AlertNotify)\n \n     mapArgs[\"-alertnotify\"] = std::string(\"echo %s >> \") + temp.string();\n \n-    BOOST_FOREACH(CAlert alert, alerts)\n+    BOOST_FOREACH (CAlert alert, alerts)\n         alert.ProcessAlert(false);\n \n     std::vector<std::string> r = read_lines(temp);"
      },
      {
        "sha": "67c1d78d0828e673da2b32f563446c2ff354bb27",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 36,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -11,18 +11,18 @@\n BOOST_AUTO_TEST_SUITE(allocator_tests)\n \n // Dummy memory page locker for platform independent tests\n-static const void *last_lock_addr, *last_unlock_addr;\n+static const void* last_lock_addr, *last_unlock_addr;\n static size_t last_lock_len, last_unlock_len;\n class TestLocker\n {\n public:\n-    bool Lock(const void *addr, size_t len)\n+    bool Lock(const void* addr, size_t len)\n     {\n         last_lock_addr = addr;\n         last_lock_len = len;\n         return true;\n     }\n-    bool Unlock(const void *addr, size_t len)\n+    bool Unlock(const void* addr, size_t len)\n     {\n         last_unlock_addr = addr;\n         last_unlock_len = len;\n@@ -40,80 +40,73 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n \n     /* Try large number of small objects */\n     addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n+    for (int i = 0; i < 1000; ++i) {\n         lpm.LockRange(reinterpret_cast<void*>(addr), 33);\n         addr += 33;\n     }\n     /* Try small number of page-sized objects, straddling two pages */\n-    addr = test_page_size*100 + 53;\n-    for(int i=0; i<100; ++i)\n-    {\n+    addr = test_page_size * 100 + 53;\n+    for (int i = 0; i < 100; ++i) {\n         lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n     /* Try small number of page-sized objects aligned to exactly one page */\n-    addr = test_page_size*300;\n-    for(int i=0; i<100; ++i)\n-    {\n+    addr = test_page_size * 300;\n+    for (int i = 0; i < 100; ++i) {\n         lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n     /* one very large object, straddling pages */\n-    lpm.LockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n+    lpm.LockRange(reinterpret_cast<void*>(test_page_size * 600 + 1), test_page_size * 500);\n+    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size * (600 + 500)));\n     /* one very large object, page aligned */\n-    lpm.LockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n+    lpm.LockRange(reinterpret_cast<void*>(test_page_size * 1200), test_page_size * 500 - 1);\n+    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size * (1200 + 500 - 1)));\n \n-    BOOST_CHECK(lpm.GetLockedPageCount() == (\n-        (1000*33+test_page_size-1)/test_page_size + // small objects\n-        101 + 100 +  // page-sized objects\n-        501 + 500)); // large objects\n-    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n-    BOOST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n+    BOOST_CHECK(lpm.GetLockedPageCount() == ((1000 * 33 + test_page_size - 1) / test_page_size + // small objects\n+                                             101 +\n+                                             100 + // page-sized objects\n+                                             501 +\n+                                             500));           // large objects\n+    BOOST_CHECK((last_lock_len & (test_page_size - 1)) == 0); // always lock entire pages\n+    BOOST_CHECK(last_unlock_len == 0);                        // nothing unlocked yet\n \n     /* And unlock again */\n     addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n+    for (int i = 0; i < 1000; ++i) {\n         lpm.UnlockRange(reinterpret_cast<void*>(addr), 33);\n         addr += 33;\n     }\n-    addr = test_page_size*100 + 53;\n-    for(int i=0; i<100; ++i)\n-    {\n+    addr = test_page_size * 100 + 53;\n+    for (int i = 0; i < 100; ++i) {\n         lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n-    addr = test_page_size*300;\n-    for(int i=0; i<100; ++i)\n-    {\n+    addr = test_page_size * 300;\n+    for (int i = 0; i < 100; ++i) {\n         lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n-    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n-    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n+    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size * 600 + 1), test_page_size * 500);\n+    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size * 1200), test_page_size * 500 - 1);\n \n     /* Check that everything is released */\n     BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n \n     /* A few and unlocks of size zero (should have no effect) */\n     addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n+    for (int i = 0; i < 1000; ++i) {\n         lpm.LockRange(reinterpret_cast<void*>(addr), 0);\n         addr += 1;\n     }\n     BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n     addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n+    for (int i = 0; i < 1000; ++i) {\n         lpm.UnlockRange(reinterpret_cast<void*>(addr), 0);\n         addr += 1;\n     }\n     BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n-    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n+    BOOST_CHECK((last_unlock_len & (test_page_size - 1)) == 0); // always unlock entire pages\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "06250388fbd55a1d1619168088cc2cea15b9ae3b",
        "filename": "src/test/base32_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base32_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -10,10 +10,9 @@ BOOST_AUTO_TEST_SUITE(base32_tests)\n \n BOOST_AUTO_TEST_CASE(base32_testvectors)\n {\n-    static const std::string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n-    static const std::string vstrOut[] = {\"\",\"my======\",\"mzxq====\",\"mzxw6===\",\"mzxw6yq=\",\"mzxw6ytb\",\"mzxw6ytboi======\"};\n-    for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n-    {\n+    static const std::string vstrIn[] = {\"\", \"f\", \"fo\", \"foo\", \"foob\", \"fooba\", \"foobar\"};\n+    static const std::string vstrOut[] = {\"\", \"my======\", \"mzxq====\", \"mzxw6===\", \"mzxw6yq=\", \"mzxw6ytb\", \"mzxw6ytboi======\"};\n+    for (unsigned int i = 0; i < sizeof(vstrIn) / sizeof(vstrIn[0]); i++) {\n         std::string strEnc = EncodeBase32(vstrIn[i]);\n         BOOST_CHECK(strEnc == vstrOut[i]);\n         std::string strDec = DecodeBase32(vstrOut[i]);"
      },
      {
        "sha": "8032c53648dd6f8f3005666dfa2608f15368b4f2",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 46,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -29,8 +29,7 @@ BOOST_AUTO_TEST_SUITE(base58_tests)\n BOOST_AUTO_TEST_CASE(base58_EncodeBase58)\n {\n     Array tests = read_json(std::string(json_tests::base58_encode_decode, json_tests::base58_encode_decode + sizeof(json_tests::base58_encode_decode)));\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 2) // Allow for extra stuff (useful for comments)\n@@ -41,8 +40,8 @@ BOOST_AUTO_TEST_CASE(base58_EncodeBase58)\n         std::vector<unsigned char> sourcedata = ParseHex(test[0].get_str());\n         std::string base58string = test[1].get_str();\n         BOOST_CHECK_MESSAGE(\n-                    EncodeBase58(begin_ptr(sourcedata), end_ptr(sourcedata)) == base58string,\n-                    strTest);\n+            EncodeBase58(begin_ptr(sourcedata), end_ptr(sourcedata)) == base58string,\n+            strTest);\n     }\n }\n \n@@ -52,8 +51,7 @@ BOOST_AUTO_TEST_CASE(base58_DecodeBase58)\n     Array tests = read_json(std::string(json_tests::base58_encode_decode, json_tests::base58_encode_decode + sizeof(json_tests::base58_encode_decode)));\n     std::vector<unsigned char> result;\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 2) // Allow for extra stuff (useful for comments)\n@@ -71,7 +69,7 @@ BOOST_AUTO_TEST_CASE(base58_DecodeBase58)\n \n     // check that DecodeBase58 skips whitespace, but still fails with unexpected non-whitespace at the end.\n     BOOST_CHECK(!DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t a\", result));\n-    BOOST_CHECK( DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t \", result));\n+    BOOST_CHECK(DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t \", result));\n     std::vector<unsigned char> expected = ParseHex(\"971a55\");\n     BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n }\n@@ -81,17 +79,18 @@ class TestAddrTypeVisitor : public boost::static_visitor<bool>\n {\n private:\n     std::string exp_addrType;\n+\n public:\n-    TestAddrTypeVisitor(const std::string &exp_addrType) : exp_addrType(exp_addrType) { }\n-    bool operator()(const CKeyID &id) const\n+    TestAddrTypeVisitor(const std::string& exp_addrType) : exp_addrType(exp_addrType) {}\n+    bool operator()(const CKeyID& id) const\n     {\n         return (exp_addrType == \"pubkey\");\n     }\n-    bool operator()(const CScriptID &id) const\n+    bool operator()(const CScriptID& id) const\n     {\n         return (exp_addrType == \"script\");\n     }\n-    bool operator()(const CNoDestination &no) const\n+    bool operator()(const CNoDestination& no) const\n     {\n         return (exp_addrType == \"none\");\n     }\n@@ -102,19 +101,20 @@ class TestPayloadVisitor : public boost::static_visitor<bool>\n {\n private:\n     std::vector<unsigned char> exp_payload;\n+\n public:\n-    TestPayloadVisitor(std::vector<unsigned char> &exp_payload) : exp_payload(exp_payload) { }\n-    bool operator()(const CKeyID &id) const\n+    TestPayloadVisitor(std::vector<unsigned char>& exp_payload) : exp_payload(exp_payload) {}\n+    bool operator()(const CKeyID& id) const\n     {\n         uint160 exp_key(exp_payload);\n         return exp_key == id;\n     }\n-    bool operator()(const CScriptID &id) const\n+    bool operator()(const CScriptID& id) const\n     {\n         uint160 exp_key(exp_payload);\n         return exp_key == id;\n     }\n-    bool operator()(const CNoDestination &no) const\n+    bool operator()(const CNoDestination& no) const\n     {\n         return exp_payload.size() == 0;\n     }\n@@ -128,8 +128,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n     CBitcoinSecret secret;\n     CBitcoinAddress addr;\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 3) // Allow for extra stuff (useful for comments)\n@@ -139,19 +138,18 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n         }\n         std::string exp_base58string = test[0].get_str();\n         std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n-        const Object &metadata = test[2].get_obj();\n+        const Object& metadata = test[2].get_obj();\n         bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n         bool isTestnet = find_value(metadata, \"isTestnet\").get_bool();\n         if (isTestnet)\n             SelectParams(CBaseChainParams::TESTNET);\n         else\n             SelectParams(CBaseChainParams::MAIN);\n-        if(isPrivkey)\n-        {\n+        if (isPrivkey) {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n             // Must be valid private key\n             // Note: CBitcoinSecret::SetString tests isValid, whereas CBitcoinAddress does not!\n-            BOOST_CHECK_MESSAGE(secret.SetString(exp_base58string), \"!SetString:\"+ strTest);\n+            BOOST_CHECK_MESSAGE(secret.SetString(exp_base58string), \"!SetString:\" + strTest);\n             BOOST_CHECK_MESSAGE(secret.IsValid(), \"!IsValid:\" + strTest);\n             CKey privkey = secret.GetKey();\n             BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n@@ -160,9 +158,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n             // Private key must be invalid public key\n             addr.SetString(exp_base58string);\n             BOOST_CHECK_MESSAGE(!addr.IsValid(), \"IsValid privkey as pubkey:\" + strTest);\n-        }\n-        else\n-        {\n+        } else {\n             std::string exp_addrType = find_value(metadata, \"addrType\").get_str(); // \"script\" or \"pubkey\"\n             // Must be valid public key\n             BOOST_CHECK_MESSAGE(addr.SetString(exp_base58string), \"SetString:\" + strTest);\n@@ -184,8 +180,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n {\n     Array tests = read_json(std::string(json_tests::base58_keys_valid, json_tests::base58_keys_valid + sizeof(json_tests::base58_keys_valid)));\n     std::vector<unsigned char> result;\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 3) // Allow for extra stuff (useful for comments)\n@@ -195,41 +190,31 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n         }\n         std::string exp_base58string = test[0].get_str();\n         std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n-        const Object &metadata = test[2].get_obj();\n+        const Object& metadata = test[2].get_obj();\n         bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n         bool isTestnet = find_value(metadata, \"isTestnet\").get_bool();\n         if (isTestnet)\n             SelectParams(CBaseChainParams::TESTNET);\n         else\n             SelectParams(CBaseChainParams::MAIN);\n-        if(isPrivkey)\n-        {\n+        if (isPrivkey) {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n             CKey key;\n             key.Set(exp_payload.begin(), exp_payload.end(), isCompressed);\n             assert(key.IsValid());\n             CBitcoinSecret secret;\n             secret.SetKey(key);\n             BOOST_CHECK_MESSAGE(secret.ToString() == exp_base58string, \"result mismatch: \" + strTest);\n-        }\n-        else\n-        {\n+        } else {\n             std::string exp_addrType = find_value(metadata, \"addrType\").get_str();\n             CTxDestination dest;\n-            if(exp_addrType == \"pubkey\")\n-            {\n+            if (exp_addrType == \"pubkey\") {\n                 dest = CKeyID(uint160(exp_payload));\n-            }\n-            else if(exp_addrType == \"script\")\n-            {\n+            } else if (exp_addrType == \"script\") {\n                 dest = CScriptID(uint160(exp_payload));\n-            }\n-            else if(exp_addrType == \"none\")\n-            {\n+            } else if (exp_addrType == \"none\") {\n                 dest = CNoDestination();\n-            }\n-            else\n-            {\n+            } else {\n                 BOOST_ERROR(\"Bad addrtype: \" << strTest);\n                 continue;\n             }\n@@ -255,8 +240,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_invalid)\n     CBitcoinSecret secret;\n     CBitcoinAddress addr;\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 1) // Allow for extra stuff (useful for comments)\n@@ -276,4 +260,3 @@ BOOST_AUTO_TEST_CASE(base58_keys_invalid)\n \n \n BOOST_AUTO_TEST_SUITE_END()\n-"
      },
      {
        "sha": "b972a2288c7e877b6155e3a05354fa8898f03883",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -10,10 +10,9 @@ BOOST_AUTO_TEST_SUITE(base64_tests)\n \n BOOST_AUTO_TEST_CASE(base64_testvectors)\n {\n-    static const std::string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n-    static const std::string vstrOut[] = {\"\",\"Zg==\",\"Zm8=\",\"Zm9v\",\"Zm9vYg==\",\"Zm9vYmE=\",\"Zm9vYmFy\"};\n-    for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n-    {\n+    static const std::string vstrIn[] = {\"\", \"f\", \"fo\", \"foo\", \"foob\", \"fooba\", \"foobar\"};\n+    static const std::string vstrOut[] = {\"\", \"Zg==\", \"Zm8=\", \"Zm9v\", \"Zm9vYg==\", \"Zm9vYmE=\", \"Zm9vYmFy\"};\n+    for (unsigned int i = 0; i < sizeof(vstrIn) / sizeof(vstrIn[0]); i++) {\n         std::string strEnc = EncodeBase64(vstrIn[i]);\n         BOOST_CHECK(strEnc == vstrOut[i]);\n         std::string strDec = DecodeBase64(strEnc);"
      },
      {
        "sha": "01b15dd673f239d12607b3367d716306631ae970",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -27,7 +27,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n     CBloomFilter filter(3, 0.01, 0, BLOOM_UPDATE_ALL);\n \n     filter.insert(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\"));\n-    BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n+    BOOST_CHECK_MESSAGE(filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n     // One bit different in first byte\n     BOOST_CHECK_MESSAGE(!filter.contains(ParseHex(\"19108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter contains something it shouldn't!\");\n \n@@ -48,9 +48,9 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n \n     BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n \n-    BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n+    BOOST_CHECK_MESSAGE(filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n     filter.clear();\n-    BOOST_CHECK_MESSAGE( !filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter should be empty!\");\n+    BOOST_CHECK_MESSAGE(!filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter should be empty!\");\n }\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n@@ -59,7 +59,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n     CBloomFilter filter(3, 0.01, 2147483649UL, BLOOM_UPDATE_ALL);\n \n     filter.insert(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\"));\n-    BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n+    BOOST_CHECK_MESSAGE(filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n     // One bit different in first byte\n     BOOST_CHECK_MESSAGE(!filter.contains(ParseHex(\"19108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter contains something it shouldn't!\");\n \n@@ -117,7 +117,7 @@ BOOST_AUTO_TEST_CASE(bloom_match)\n \n     // and one which spends it (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n     unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n-    vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n+    vector<unsigned char> vch(ch, ch + sizeof(ch) - 1);\n     CDataStream spendStream(vch, SER_DISK, CLIENT_VERSION);\n     CTransaction spendingTx;\n     spendStream >> spendingTx;"
      },
      {
        "sha": "faed43848bf6ab7c7d2ff1ee9aaad2ceac7543b8",
        "filename": "src/test/checkblock_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/checkblock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/checkblock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkblock_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -7,7 +7,6 @@\n //\n \n \n-\n #include \"clientversion.h\"\n #include \"main.h\"\n #include \"utiltime.h\"\n@@ -26,18 +25,19 @@ bool read_block(const std::string& filename, CBlock& block)\n     namespace fs = boost::filesystem;\n     fs::path testFile = fs::current_path() / \"data\" / filename;\n #ifdef TEST_DATA_DIR\n-    if (!fs::exists(testFile))\n-    {\n+    if (!fs::exists(testFile)) {\n         testFile = fs::path(BOOST_PP_STRINGIZE(TEST_DATA_DIR)) / filename;\n     }\n #endif\n     FILE* fp = fopen(testFile.string().c_str(), \"rb\");\n-    if (!fp) return false;\n+    if (!fp)\n+        return false;\n \n     fseek(fp, 8, SEEK_SET); // skip msgheader/size\n \n     CAutoFile filein(fp, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull()) return false;\n+    if (filein.IsNull())\n+        return false;\n \n     filein >> block;\n \n@@ -54,8 +54,7 @@ BOOST_AUTO_TEST_CASE(May15)\n     SetMockTime(tMay15); // Test as if it was right at May 15\n \n     CBlock forkingBlock;\n-    if (read_block(\"Mar12Fork.dat\", forkingBlock))\n-    {\n+    if (read_block(\"Mar12Fork.dat\", forkingBlock)) {\n         CValidationState state;\n \n         // After May 15'th, big blocks are OK:"
      },
      {
        "sha": "b2587f98a3d44e8183e6509a03cddf1c7c2f1d44",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -43,7 +43,7 @@ class CCoinsViewTest : public CCoinsView\n \n     bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock)\n     {\n-        for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n+        for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n             map_[it->first] = it->second.coins;\n             if (it->second.coins.IsPruned() && insecure_rand() % 3 == 0) {\n                 // Randomly delete empty entries on write.\n@@ -88,8 +88,8 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     std::map<uint256, CCoins> result;\n \n     // The cache stack.\n-    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n-    std::vector<CCoinsViewCache*> stack; // A stack of CCoinsViewCaches on top.\n+    CCoinsViewTest base;                         // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCache*> stack;         // A stack of CCoinsViewCaches on top.\n     stack.push_back(new CCoinsViewCache(&base)); // Start with one cache.\n \n     // Use a limited set of random transaction ids, so we do test overwriting entries."
      },
      {
        "sha": "8a43d462642c387f903cc99f6dd7644e8380bc38",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -23,27 +23,30 @@\n \n BOOST_AUTO_TEST_SUITE(compress_tests)\n \n-bool static TestEncode(uint64_t in) {\n+bool static TestEncode(uint64_t in)\n+{\n     return in == CTxOutCompressor::DecompressAmount(CTxOutCompressor::CompressAmount(in));\n }\n \n-bool static TestDecode(uint64_t in) {\n+bool static TestDecode(uint64_t in)\n+{\n     return in == CTxOutCompressor::CompressAmount(CTxOutCompressor::DecompressAmount(in));\n }\n \n-bool static TestPair(uint64_t dec, uint64_t enc) {\n+bool static TestPair(uint64_t dec, uint64_t enc)\n+{\n     return CTxOutCompressor::CompressAmount(dec) == enc &&\n            CTxOutCompressor::DecompressAmount(enc) == dec;\n }\n \n BOOST_AUTO_TEST_CASE(compress_amounts)\n {\n-    BOOST_CHECK(TestPair(            0,       0x0));\n-    BOOST_CHECK(TestPair(            1,       0x1));\n-    BOOST_CHECK(TestPair(         CENT,       0x7));\n-    BOOST_CHECK(TestPair(         COIN,       0x9));\n-    BOOST_CHECK(TestPair(      50*COIN,      0x32));\n-    BOOST_CHECK(TestPair(21000000*COIN, 0x1406f40));\n+    BOOST_CHECK(TestPair(0, 0x0));\n+    BOOST_CHECK(TestPair(1, 0x1));\n+    BOOST_CHECK(TestPair(CENT, 0x7));\n+    BOOST_CHECK(TestPair(COIN, 0x9));\n+    BOOST_CHECK(TestPair(50 * COIN, 0x32));\n+    BOOST_CHECK(TestPair(21000000 * COIN, 0x1406f40));\n \n     for (uint64_t i = 1; i <= NUM_MULTIPLES_UNIT; i++)\n         BOOST_CHECK(TestEncode(i));"
      },
      {
        "sha": "e8feda90f2f55e0a8342005b152938aa1b81394d",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 15,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -14,8 +14,9 @@\n \n BOOST_AUTO_TEST_SUITE(crypto_tests)\n \n-template<typename Hasher, typename In, typename Out>\n-void TestVector(const Hasher &h, const In &in, const Out &out) {\n+template <typename Hasher, typename In, typename Out>\n+void TestVector(const Hasher& h, const In& in, const Out& out)\n+{\n     Out hash;\n     BOOST_CHECK(out.size() == h.OUTPUT_SIZE);\n     hash.resize(out.size());\n@@ -24,7 +25,7 @@ void TestVector(const Hasher &h, const In &in, const Out &out) {\n         Hasher(h).Write((unsigned char*)&in[0], in.size()).Finalize(&hash[0]);\n         BOOST_CHECK(hash == out);\n     }\n-    for (int i=0; i<32; i++) {\n+    for (int i = 0; i < 32; i++) {\n         // Test that writing the string broken up in random pieces works.\n         Hasher hasher(h);\n         size_t pos = 0;\n@@ -43,19 +44,21 @@ void TestVector(const Hasher &h, const In &in, const Out &out) {\n     }\n }\n \n-void TestSHA1(const std::string &in, const std::string &hexout) { TestVector(CSHA1(), in, ParseHex(hexout));}\n-void TestSHA256(const std::string &in, const std::string &hexout) { TestVector(CSHA256(), in, ParseHex(hexout));}\n-void TestSHA512(const std::string &in, const std::string &hexout) { TestVector(CSHA512(), in, ParseHex(hexout));}\n-void TestRIPEMD160(const std::string &in, const std::string &hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout));}\n+void TestSHA1(const std::string& in, const std::string& hexout) { TestVector(CSHA1(), in, ParseHex(hexout)); }\n+void TestSHA256(const std::string& in, const std::string& hexout) { TestVector(CSHA256(), in, ParseHex(hexout)); }\n+void TestSHA512(const std::string& in, const std::string& hexout) { TestVector(CSHA512(), in, ParseHex(hexout)); }\n+void TestRIPEMD160(const std::string& in, const std::string& hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout)); }\n \n-void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n+void TestHMACSHA512(const std::string& hexkey, const std::string& hexin, const std::string& hexout)\n+{\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     TestVector(CHMAC_SHA512(&key[0], key.size()), ParseHex(hexin), ParseHex(hexout));\n }\n \n-std::string LongTestString(void) {\n+std::string LongTestString(void)\n+{\n     std::string ret;\n-    for (int i=0; i<200000; i++) {\n+    for (int i = 0; i < 200000; i++) {\n         ret += (unsigned char)(i);\n         ret += (unsigned char)(i >> 4);\n         ret += (unsigned char)(i >> 8);\n@@ -67,7 +70,8 @@ std::string LongTestString(void) {\n \n const std::string test1 = LongTestString();\n \n-BOOST_AUTO_TEST_CASE(ripemd160_testvectors) {\n+BOOST_AUTO_TEST_CASE(ripemd160_testvectors)\n+{\n     TestRIPEMD160(\"\", \"9c1185a5c5e9fc54612808977ee8f548b2258d31\");\n     TestRIPEMD160(\"abc\", \"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc\");\n     TestRIPEMD160(\"message digest\", \"5d0689ef49d2fae572b881b123a85ffa21595f36\");\n@@ -83,7 +87,8 @@ BOOST_AUTO_TEST_CASE(ripemd160_testvectors) {\n     TestRIPEMD160(test1, \"464243587bd146ea835cdf57bdae582f25ec45f1\");\n }\n \n-BOOST_AUTO_TEST_CASE(sha1_testvectors) {\n+BOOST_AUTO_TEST_CASE(sha1_testvectors)\n+{\n     TestSHA1(\"\", \"da39a3ee5e6b4b0d3255bfef95601890afd80709\");\n     TestSHA1(\"abc\", \"a9993e364706816aba3e25717850c26c9cd0d89d\");\n     TestSHA1(\"message digest\", \"c12252ceda8be8994d5fa0290a47231c1d16aae3\");\n@@ -99,7 +104,8 @@ BOOST_AUTO_TEST_CASE(sha1_testvectors) {\n     TestSHA1(test1, \"b7755760681cbfd971451668f32af5774f4656b5\");\n }\n \n-BOOST_AUTO_TEST_CASE(sha256_testvectors) {\n+BOOST_AUTO_TEST_CASE(sha256_testvectors)\n+{\n     TestSHA256(\"\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\");\n     TestSHA256(\"abc\", \"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\");\n     TestSHA256(\"message digest\",\n@@ -121,7 +127,8 @@ BOOST_AUTO_TEST_CASE(sha256_testvectors) {\n     TestSHA256(test1, \"a316d55510b49662420f49d145d42fb83f31ef8dc016aa4e32df049991a91e26\");\n }\n \n-BOOST_AUTO_TEST_CASE(sha512_testvectors) {\n+BOOST_AUTO_TEST_CASE(sha512_testvectors)\n+{\n     TestSHA512(\"\",\n                \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\"\n                \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\");\n@@ -158,7 +165,8 @@ BOOST_AUTO_TEST_CASE(sha512_testvectors) {\n                \"37de8c3ef5459d76a52cedc02dc499a3c9ed9dedbfb3281afd9653b8a112fafc\");\n }\n \n-BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors) {\n+BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors)\n+{\n     // test cases 1, 2, 3, 4, 6 and 7 of RFC 4231\n     TestHMACSHA512(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n                    \"4869205468657265\","
      },
      {
        "sha": "0517112af221f21b622c21a2da3212824756a14a",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -17,14 +17,14 @@ static void ResetArgs(const std::string& strArg)\n {\n     std::vector<std::string> vecArg;\n     if (strArg.size())\n-      boost::split(vecArg, strArg, boost::is_space(), boost::token_compress_on);\n+        boost::split(vecArg, strArg, boost::is_space(), boost::token_compress_on);\n \n     // Insert dummy executable name:\n     vecArg.insert(vecArg.begin(), \"testbitcoin\");\n \n     // Convert to char*:\n     std::vector<const char*> vecChar;\n-    BOOST_FOREACH(std::string& s, vecArg)\n+    BOOST_FOREACH (std::string& s, vecArg)\n         vecChar.push_back(s.c_str());\n \n     ParseParameters(vecChar.size(), &vecChar[0]);\n@@ -59,15 +59,15 @@ BOOST_AUTO_TEST_CASE(boolarg)\n     BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n \n-    ResetArgs(\"-foo -nofoo\");  // -foo should win\n+    ResetArgs(\"-foo -nofoo\"); // -foo should win\n     BOOST_CHECK(GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(GetBoolArg(\"-foo\", true));\n \n-    ResetArgs(\"-foo=1 -nofoo=1\");  // -foo should win\n+    ResetArgs(\"-foo=1 -nofoo=1\"); // -foo should win\n     BOOST_CHECK(GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(GetBoolArg(\"-foo\", true));\n \n-    ResetArgs(\"-foo=0 -nofoo=0\");  // -foo should win\n+    ResetArgs(\"-foo=0 -nofoo=0\"); // -foo should win\n     BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n \n@@ -79,7 +79,6 @@ BOOST_AUTO_TEST_CASE(boolarg)\n     ResetArgs(\"--nofoo=1\");\n     BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n-\n }\n \n BOOST_AUTO_TEST_CASE(stringarg)\n@@ -103,7 +102,6 @@ BOOST_AUTO_TEST_CASE(stringarg)\n     ResetArgs(\"-foo=eleven\");\n     BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"eleven\");\n     BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"eleven\");\n-\n }\n \n BOOST_AUTO_TEST_CASE(intarg)"
      },
      {
        "sha": "879315f11047e9e7e61356e38f0e8e8d7b98ceff",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -15,7 +15,6 @@ BOOST_AUTO_TEST_SUITE(hash_tests)\n \n BOOST_AUTO_TEST_CASE(murmurhash3)\n {\n-\n #define T(expected, seed, data) BOOST_CHECK_EQUAL(MurmurHash3(seed, ParseHex(data)), expected)\n \n     // Test MurmurHash3 with various inputs. Of course this is retested in the"
      },
      {
        "sha": "cad145211e195454198f1d8819e9797d31291272",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 36,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -16,12 +16,12 @@\n \n using namespace std;\n \n-static const string strSecret1     (\"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\");\n-static const string strSecret2     (\"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\");\n-static const string strSecret1C    (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n-static const string strSecret2C    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n-static const CBitcoinAddress addr1 (\"1QFqqMUD55ZV3PJEJZtaKCsQmjLT6JkjvJ\");\n-static const CBitcoinAddress addr2 (\"1F5y5E5FMc5YzdJtB9hLaUe43GDxEKXENJ\");\n+static const string strSecret1(\"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\");\n+static const string strSecret2(\"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\");\n+static const string strSecret1C(\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n+static const string strSecret2C(\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n+static const CBitcoinAddress addr1(\"1QFqqMUD55ZV3PJEJZtaKCsQmjLT6JkjvJ\");\n+static const CBitcoinAddress addr2(\"1F5y5E5FMc5YzdJtB9hLaUe43GDxEKXENJ\");\n static const CBitcoinAddress addr1C(\"1NoJrossxPBKfCHuJXT4HadJrXRE9Fxiqs\");\n static const CBitcoinAddress addr2C(\"1CRj2HyM1CXWzHAXLQtiGLyggNT9WQqsDs\");\n \n@@ -40,8 +40,7 @@ void dumpKeyInfo(uint256 privkey)\n     memcpy(&sec[0], &secret[0], 32);\n     printf(\"  * secret (hex): %s\\n\", HexStr(sec).c_str());\n \n-    for (int nCompressed=0; nCompressed<2; nCompressed++)\n-    {\n+    for (int nCompressed = 0; nCompressed < 2; nCompressed++) {\n         bool fCompressed = nCompressed == 1;\n         printf(\"  * %s:\\n\", fCompressed ? \"compressed\" : \"uncompressed\");\n         CBitcoinSecret bsecret;\n@@ -62,23 +61,23 @@ BOOST_AUTO_TEST_SUITE(key_tests)\n BOOST_AUTO_TEST_CASE(key_test1)\n {\n     CBitcoinSecret bsecret1, bsecret2, bsecret1C, bsecret2C, baddress1;\n-    BOOST_CHECK( bsecret1.SetString (strSecret1));\n-    BOOST_CHECK( bsecret2.SetString (strSecret2));\n-    BOOST_CHECK( bsecret1C.SetString(strSecret1C));\n-    BOOST_CHECK( bsecret2C.SetString(strSecret2C));\n+    BOOST_CHECK(bsecret1.SetString(strSecret1));\n+    BOOST_CHECK(bsecret2.SetString(strSecret2));\n+    BOOST_CHECK(bsecret1C.SetString(strSecret1C));\n+    BOOST_CHECK(bsecret2C.SetString(strSecret2C));\n     BOOST_CHECK(!baddress1.SetString(strAddressBad));\n \n-    CKey key1  = bsecret1.GetKey();\n+    CKey key1 = bsecret1.GetKey();\n     BOOST_CHECK(key1.IsCompressed() == false);\n-    CKey key2  = bsecret2.GetKey();\n+    CKey key2 = bsecret2.GetKey();\n     BOOST_CHECK(key2.IsCompressed() == false);\n     CKey key1C = bsecret1C.GetKey();\n     BOOST_CHECK(key1C.IsCompressed() == true);\n     CKey key2C = bsecret2C.GetKey();\n     BOOST_CHECK(key2C.IsCompressed() == true);\n \n-    CPubKey pubkey1  = key1. GetPubKey();\n-    CPubKey pubkey2  = key2. GetPubKey();\n+    CPubKey pubkey1 = key1.GetPubKey();\n+    CPubKey pubkey2 = key2.GetPubKey();\n     CPubKey pubkey1C = key1C.GetPubKey();\n     CPubKey pubkey2C = key2C.GetPubKey();\n \n@@ -102,63 +101,62 @@ BOOST_AUTO_TEST_CASE(key_test1)\n     BOOST_CHECK(!key2C.VerifyPubKey(pubkey2));\n     BOOST_CHECK(key2C.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(addr1.Get()  == CTxDestination(pubkey1.GetID()));\n-    BOOST_CHECK(addr2.Get()  == CTxDestination(pubkey2.GetID()));\n+    BOOST_CHECK(addr1.Get() == CTxDestination(pubkey1.GetID()));\n+    BOOST_CHECK(addr2.Get() == CTxDestination(pubkey2.GetID()));\n     BOOST_CHECK(addr1C.Get() == CTxDestination(pubkey1C.GetID()));\n     BOOST_CHECK(addr2C.Get() == CTxDestination(pubkey2C.GetID()));\n \n-    for (int n=0; n<16; n++)\n-    {\n+    for (int n = 0; n < 16; n++) {\n         string strMsg = strprintf(\"Very secret message %i: 11\", n);\n         uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n \n         // normal signatures\n \n         vector<unsigned char> sign1, sign2, sign1C, sign2C;\n \n-        BOOST_CHECK(key1.Sign (hashMsg, sign1));\n-        BOOST_CHECK(key2.Sign (hashMsg, sign2));\n+        BOOST_CHECK(key1.Sign(hashMsg, sign1));\n+        BOOST_CHECK(key2.Sign(hashMsg, sign2));\n         BOOST_CHECK(key1C.Sign(hashMsg, sign1C));\n         BOOST_CHECK(key2C.Sign(hashMsg, sign2C));\n \n-        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1));\n+        BOOST_CHECK(pubkey1.Verify(hashMsg, sign1));\n         BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2));\n-        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1C));\n+        BOOST_CHECK(pubkey1.Verify(hashMsg, sign1C));\n         BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2C));\n \n         BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1));\n-        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2));\n+        BOOST_CHECK(pubkey2.Verify(hashMsg, sign2));\n         BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2C));\n+        BOOST_CHECK(pubkey2.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1));\n+        BOOST_CHECK(pubkey1C.Verify(hashMsg, sign1));\n         BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2));\n-        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1C));\n+        BOOST_CHECK(pubkey1C.Verify(hashMsg, sign1C));\n         BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2C));\n \n         BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1));\n-        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2));\n+        BOOST_CHECK(pubkey2C.Verify(hashMsg, sign2));\n         BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2C));\n+        BOOST_CHECK(pubkey2C.Verify(hashMsg, sign2C));\n \n         // compact signatures (with key recovery)\n \n         vector<unsigned char> csign1, csign2, csign1C, csign2C;\n \n-        BOOST_CHECK(key1.SignCompact (hashMsg, csign1));\n-        BOOST_CHECK(key2.SignCompact (hashMsg, csign2));\n+        BOOST_CHECK(key1.SignCompact(hashMsg, csign1));\n+        BOOST_CHECK(key2.SignCompact(hashMsg, csign2));\n         BOOST_CHECK(key1C.SignCompact(hashMsg, csign1C));\n         BOOST_CHECK(key2C.SignCompact(hashMsg, csign2C));\n \n         CPubKey rkey1, rkey2, rkey1C, rkey2C;\n \n-        BOOST_CHECK(rkey1.RecoverCompact (hashMsg, csign1));\n-        BOOST_CHECK(rkey2.RecoverCompact (hashMsg, csign2));\n+        BOOST_CHECK(rkey1.RecoverCompact(hashMsg, csign1));\n+        BOOST_CHECK(rkey2.RecoverCompact(hashMsg, csign2));\n         BOOST_CHECK(rkey1C.RecoverCompact(hashMsg, csign1C));\n         BOOST_CHECK(rkey2C.RecoverCompact(hashMsg, csign2C));\n \n-        BOOST_CHECK(rkey1  == pubkey1);\n-        BOOST_CHECK(rkey2  == pubkey2);\n+        BOOST_CHECK(rkey1 == pubkey1);\n+        BOOST_CHECK(rkey2 == pubkey2);\n         BOOST_CHECK(rkey1C == pubkey1C);\n         BOOST_CHECK(rkey2C == pubkey2C);\n     }"
      },
      {
        "sha": "04b45b53ef1548827de5d5186323343d652ae037",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 125,
        "deletions": 46,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -12,47 +12,129 @@\n \n BOOST_AUTO_TEST_SUITE(miner_tests)\n \n-static\n-struct {\n+static struct\n+{\n     unsigned char extranonce;\n     unsigned int nonce;\n } blockinfo[] = {\n-    {4, 0xa4a3e223}, {2, 0x15c32f9e}, {1, 0x0375b547}, {1, 0x7004a8a5},\n-    {2, 0xce440296}, {2, 0x52cfe198}, {1, 0x77a72cd0}, {2, 0xbb5d6f84},\n-    {2, 0x83f30c2c}, {1, 0x48a73d5b}, {1, 0xef7dcd01}, {2, 0x6809c6c4},\n-    {2, 0x0883ab3c}, {1, 0x087bbbe2}, {2, 0x2104a814}, {2, 0xdffb6daa},\n-    {1, 0xee8a0a08}, {2, 0xba4237c1}, {1, 0xa70349dc}, {1, 0x344722bb},\n-    {3, 0xd6294733}, {2, 0xec9f5c94}, {2, 0xca2fbc28}, {1, 0x6ba4f406},\n-    {2, 0x015d4532}, {1, 0x6e119b7c}, {2, 0x43e8f314}, {2, 0x27962f38},\n-    {2, 0xb571b51b}, {2, 0xb36bee23}, {2, 0xd17924a8}, {2, 0x6bc212d9},\n-    {1, 0x630d4948}, {2, 0x9a4c4ebb}, {2, 0x554be537}, {1, 0xd63ddfc7},\n-    {2, 0xa10acc11}, {1, 0x759a8363}, {2, 0xfb73090d}, {1, 0xe82c6a34},\n-    {1, 0xe33e92d7}, {3, 0x658ef5cb}, {2, 0xba32ff22}, {5, 0x0227a10c},\n-    {1, 0xa9a70155}, {5, 0xd096d809}, {1, 0x37176174}, {1, 0x830b8d0f},\n-    {1, 0xc6e3910e}, {2, 0x823f3ca8}, {1, 0x99850849}, {1, 0x7521fb81},\n-    {1, 0xaacaabab}, {1, 0xd645a2eb}, {5, 0x7aea1781}, {5, 0x9d6e4b78},\n-    {1, 0x4ce90fd8}, {1, 0xabdc832d}, {6, 0x4a34f32a}, {2, 0xf2524c1c},\n-    {2, 0x1bbeb08a}, {1, 0xad47f480}, {1, 0x9f026aeb}, {1, 0x15a95049},\n-    {2, 0xd1cb95b2}, {2, 0xf84bbda5}, {1, 0x0fa62cd1}, {1, 0xe05f9169},\n-    {1, 0x78d194a9}, {5, 0x3e38147b}, {5, 0x737ba0d4}, {1, 0x63378e10},\n-    {1, 0x6d5f91cf}, {2, 0x88612eb8}, {2, 0xe9639484}, {1, 0xb7fabc9d},\n-    {2, 0x19b01592}, {1, 0x5a90dd31}, {2, 0x5bd7e028}, {2, 0x94d00323},\n-    {1, 0xa9b9c01a}, {1, 0x3a40de61}, {1, 0x56e7eec7}, {5, 0x859f7ef6},\n-    {1, 0xfd8e5630}, {1, 0x2b0c9f7f}, {1, 0xba700e26}, {1, 0x7170a408},\n-    {1, 0x70de86a8}, {1, 0x74d64cd5}, {1, 0x49e738a1}, {2, 0x6910b602},\n-    {0, 0x643c565f}, {1, 0x54264b3f}, {2, 0x97ea6396}, {2, 0x55174459},\n-    {2, 0x03e8779a}, {1, 0x98f34d8f}, {1, 0xc07b2b07}, {1, 0xdfe29668},\n-    {1, 0x3141c7c1}, {1, 0xb3b595f4}, {1, 0x735abf08}, {5, 0x623bfbce},\n-    {2, 0xd351e722}, {1, 0xf4ca48c9}, {1, 0x5b19c670}, {1, 0xa164bf0e},\n-    {2, 0xbbbeb305}, {2, 0xfe1c810a},\n+      {4, 0xa4a3e223},\n+      {2, 0x15c32f9e},\n+      {1, 0x0375b547},\n+      {1, 0x7004a8a5},\n+      {2, 0xce440296},\n+      {2, 0x52cfe198},\n+      {1, 0x77a72cd0},\n+      {2, 0xbb5d6f84},\n+      {2, 0x83f30c2c},\n+      {1, 0x48a73d5b},\n+      {1, 0xef7dcd01},\n+      {2, 0x6809c6c4},\n+      {2, 0x0883ab3c},\n+      {1, 0x087bbbe2},\n+      {2, 0x2104a814},\n+      {2, 0xdffb6daa},\n+      {1, 0xee8a0a08},\n+      {2, 0xba4237c1},\n+      {1, 0xa70349dc},\n+      {1, 0x344722bb},\n+      {3, 0xd6294733},\n+      {2, 0xec9f5c94},\n+      {2, 0xca2fbc28},\n+      {1, 0x6ba4f406},\n+      {2, 0x015d4532},\n+      {1, 0x6e119b7c},\n+      {2, 0x43e8f314},\n+      {2, 0x27962f38},\n+      {2, 0xb571b51b},\n+      {2, 0xb36bee23},\n+      {2, 0xd17924a8},\n+      {2, 0x6bc212d9},\n+      {1, 0x630d4948},\n+      {2, 0x9a4c4ebb},\n+      {2, 0x554be537},\n+      {1, 0xd63ddfc7},\n+      {2, 0xa10acc11},\n+      {1, 0x759a8363},\n+      {2, 0xfb73090d},\n+      {1, 0xe82c6a34},\n+      {1, 0xe33e92d7},\n+      {3, 0x658ef5cb},\n+      {2, 0xba32ff22},\n+      {5, 0x0227a10c},\n+      {1, 0xa9a70155},\n+      {5, 0xd096d809},\n+      {1, 0x37176174},\n+      {1, 0x830b8d0f},\n+      {1, 0xc6e3910e},\n+      {2, 0x823f3ca8},\n+      {1, 0x99850849},\n+      {1, 0x7521fb81},\n+      {1, 0xaacaabab},\n+      {1, 0xd645a2eb},\n+      {5, 0x7aea1781},\n+      {5, 0x9d6e4b78},\n+      {1, 0x4ce90fd8},\n+      {1, 0xabdc832d},\n+      {6, 0x4a34f32a},\n+      {2, 0xf2524c1c},\n+      {2, 0x1bbeb08a},\n+      {1, 0xad47f480},\n+      {1, 0x9f026aeb},\n+      {1, 0x15a95049},\n+      {2, 0xd1cb95b2},\n+      {2, 0xf84bbda5},\n+      {1, 0x0fa62cd1},\n+      {1, 0xe05f9169},\n+      {1, 0x78d194a9},\n+      {5, 0x3e38147b},\n+      {5, 0x737ba0d4},\n+      {1, 0x63378e10},\n+      {1, 0x6d5f91cf},\n+      {2, 0x88612eb8},\n+      {2, 0xe9639484},\n+      {1, 0xb7fabc9d},\n+      {2, 0x19b01592},\n+      {1, 0x5a90dd31},\n+      {2, 0x5bd7e028},\n+      {2, 0x94d00323},\n+      {1, 0xa9b9c01a},\n+      {1, 0x3a40de61},\n+      {1, 0x56e7eec7},\n+      {5, 0x859f7ef6},\n+      {1, 0xfd8e5630},\n+      {1, 0x2b0c9f7f},\n+      {1, 0xba700e26},\n+      {1, 0x7170a408},\n+      {1, 0x70de86a8},\n+      {1, 0x74d64cd5},\n+      {1, 0x49e738a1},\n+      {2, 0x6910b602},\n+      {0, 0x643c565f},\n+      {1, 0x54264b3f},\n+      {2, 0x97ea6396},\n+      {2, 0x55174459},\n+      {2, 0x03e8779a},\n+      {1, 0x98f34d8f},\n+      {1, 0xc07b2b07},\n+      {1, 0xdfe29668},\n+      {1, 0x3141c7c1},\n+      {1, 0xb3b595f4},\n+      {1, 0x735abf08},\n+      {5, 0x623bfbce},\n+      {2, 0xd351e722},\n+      {1, 0xf4ca48c9},\n+      {1, 0x5b19c670},\n+      {1, 0xa164bf0e},\n+      {2, 0xbbbeb305},\n+      {2, 0xfe1c810a},\n };\n \n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n-    CBlockTemplate *pblocktemplate;\n-    CMutableTransaction tx,tx2;\n+    CBlockTemplate* pblocktemplate;\n+    CMutableTransaction tx, tx2;\n     CScript script;\n     uint256 hash;\n \n@@ -64,12 +146,11 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n-    std::vector<CTransaction*>txFirst;\n-    for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n-    {\n-        CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n+    std::vector<CTransaction*> txFirst;\n+    for (unsigned int i = 0; i < sizeof(blockinfo) / sizeof(*blockinfo); ++i) {\n+        CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n         pblock->nVersion = 1;\n-        pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n+        pblock->nTime = chainActive.Tip()->GetMedianTimePast() + 1;\n         CMutableTransaction txCoinbase(pblock->vtx[0]);\n         txCoinbase.vin[0].scriptSig = CScript();\n         txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n@@ -99,8 +180,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].prevout.n = 0;\n     tx.vout.resize(1);\n     tx.vout[0].nValue = 5000000000LL;\n-    for (unsigned int i = 0; i < 1001; ++i)\n-    {\n+    for (unsigned int i = 0; i < 1001; ++i) {\n         tx.vout[0].nValue -= 1000000;\n         hash = tx.GetHash();\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n@@ -119,8 +199,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].scriptSig << OP_1;\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vout[0].nValue = 5000000000LL;\n-    for (unsigned int i = 0; i < 128; ++i)\n-    {\n+    for (unsigned int i = 0; i < 128; ++i) {\n         tx.vout[0].nValue -= 10000000;\n         hash = tx.GetHash();\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n@@ -209,15 +288,15 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     chainActive.Tip()->nHeight = nHeight;\n \n     // non-final txs in mempool\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast()+1);\n+    SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n     // height locked\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vin[0].nSequence = 0;\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx.nLockTime = chainActive.Tip()->nHeight+1;\n+    tx.nLockTime = chainActive.Tip()->nHeight + 1;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n     BOOST_CHECK(!IsFinalTx(tx, chainActive.Tip()->nHeight + 1));\n@@ -231,7 +310,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx2.vout.resize(1);\n     tx2.vout[0].nValue = 4900000000LL;\n     tx2.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx2.nLockTime = chainActive.Tip()->GetMedianTimePast()+1;\n+    tx2.nLockTime = chainActive.Tip()->GetMedianTimePast() + 1;\n     hash = tx2.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx2, 11, GetTime(), 111.0, 11));\n     BOOST_CHECK(!IsFinalTx(tx2));\n@@ -244,7 +323,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // However if we advance height and time by one, both will.\n     chainActive.Tip()->nHeight++;\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast()+2);\n+    SetMockTime(chainActive.Tip()->GetMedianTimePast() + 2);\n \n     BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 1));\n     BOOST_CHECK(IsFinalTx(tx2));\n@@ -257,7 +336,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     SetMockTime(0);\n     mempool.clear();\n \n-    BOOST_FOREACH(CTransaction *tx, txFirst)\n+    BOOST_FOREACH (CTransaction* tx, txFirst)\n         delete tx;\n \n     Checkpoints::fEnabled = true;"
      },
      {
        "sha": "cbf06f5b19c44340509694b68aa4d38939400e33",
        "filename": "src/test/mruset_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 16,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/mruset_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/mruset_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mruset_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -39,24 +39,19 @@ BOOST_AUTO_TEST_SUITE(mruset_tests)\n // Test that an mruset behaves like a set, as long as no more than MAX_SIZE elements are in it\n BOOST_AUTO_TEST_CASE(mruset_like_set)\n {\n-\n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n-    {\n+    for (int nTest = 0; nTest < NUM_TESTS; nTest++) {\n         mrutester tester;\n         while (tester.size() < MAX_SIZE)\n             tester.insert(GetRandInt(2 * MAX_SIZE));\n     }\n-\n }\n \n // Test that an mruset's size never exceeds its max_size\n BOOST_AUTO_TEST_CASE(mruset_limited_size)\n {\n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n-    {\n+    for (int nTest = 0; nTest < NUM_TESTS; nTest++) {\n         mruset<int> mru(MAX_SIZE);\n-        for (int nAction=0; nAction<3*MAX_SIZE; nAction++)\n-        {\n+        for (int nAction = 0; nAction < 3 * MAX_SIZE; nAction++) {\n             int n = GetRandInt(2 * MAX_SIZE);\n             mru.insert(n);\n             BOOST_CHECK(mru.size() <= MAX_SIZE);\n@@ -68,13 +63,12 @@ BOOST_AUTO_TEST_CASE(mruset_limited_size)\n int static permute(int n)\n {\n     // hexadecimals of pi; verified to be linearly independent\n-    static const int table[16] = {0x243F, 0x6A88, 0x85A3, 0x08D3, 0x1319, 0x8A2E, 0x0370, 0x7344,\n-                                  0xA409, 0x3822, 0x299F, 0x31D0, 0x082E, 0xFA98, 0xEC4E, 0x6C89};\n+    static const int table[16] = {0x243F, 0x6A88, 0x85A3, 0x08D3, 0x1319, 0x8A2E, 0x0370, 0x7344, 0xA409, 0x3822, 0x299F, 0x31D0, 0x082E, 0xFA98, 0xEC4E, 0x6C89};\n \n     int ret = 0;\n-    for (int bit=0; bit<16; bit++)\n-         if (n & (1<<bit))\n-             ret ^= table[bit];\n+    for (int bit = 0; bit < 16; bit++)\n+        if (n & (1 << bit))\n+            ret ^= table[bit];\n \n     return ret;\n }\n@@ -83,12 +77,11 @@ int static permute(int n)\n BOOST_AUTO_TEST_CASE(mruset_window)\n {\n     mruset<int> mru(MAX_SIZE);\n-    for (int n=0; n<10*MAX_SIZE; n++)\n-    {\n+    for (int n = 0; n < 10 * MAX_SIZE; n++) {\n         mru.insert(permute(n));\n \n         set<int> tester;\n-        for (int m=max(0,n-MAX_SIZE+1); m<=n; m++)\n+        for (int m = max(0, n - MAX_SIZE + 1); m <= n; m++)\n             tester.insert(permute(m));\n \n         BOOST_CHECK(mru == tester);"
      },
      {
        "sha": "df2251a10e7f108f8e51dcc1a3a0ee0fae145d2f",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 35,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -33,8 +33,7 @@ sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction,\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround\n-    BOOST_FOREACH(const CKey &key, keys)\n-    {\n+    BOOST_FOREACH (const CKey& key, keys) {\n         vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -61,15 +60,14 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     CScript escrow;\n     escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n \n-    CMutableTransaction txFrom;  // Funding transaction\n+    CMutableTransaction txFrom; // Funding transaction\n     txFrom.vout.resize(3);\n     txFrom.vout[0].scriptPubKey = a_and_b;\n     txFrom.vout[1].scriptPubKey = a_or_b;\n     txFrom.vout[2].scriptPubKey = escrow;\n \n     CMutableTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n         txTo[i].vin[0].prevout.n = i;\n@@ -82,39 +80,34 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n \n     // Test a AND b:\n     keys.clear();\n-    keys += key[0],key[1]; // magic operator+= from boost.assign\n+    keys += key[0], key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n     BOOST_CHECK(VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.clear();\n-        keys += key[1],key[i];\n+        keys += key[1], key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n     // Test a OR b:\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n-        if (i == 0 || i == 1)\n-        {\n+        if (i == 0 || i == 1) {\n             BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-        }\n-        else\n-        {\n+        } else {\n             BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n         }\n@@ -130,18 +123,14 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n \n \n     for (int i = 0; i < 4; i++)\n-        for (int j = 0; j < 4; j++)\n-        {\n+        for (int j = 0; j < 4; j++) {\n             keys.clear();\n-            keys += key[i],key[j];\n+            keys += key[i], key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n-            if (i < j && i < 3 && j < 3)\n-            {\n+            if (i < j && i < 3 && j < 3) {\n                 BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0), &err), strprintf(\"escrow 1: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-            }\n-            else\n-            {\n+            } else {\n                 BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0), &err), strprintf(\"escrow 2: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n             }\n@@ -161,7 +150,7 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n     BOOST_CHECK(::IsStandard(a_and_b, whichType));\n \n     CScript a_or_b;\n-    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n+    a_or_b << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n     BOOST_CHECK(::IsStandard(a_or_b, whichType));\n \n     CScript escrow;\n@@ -199,8 +188,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     CBasicKeyStore keystore, emptykeystore, partialkeystore;\n     CKey key[3];\n     CTxDestination keyaddr[3];\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n         keyaddr[i] = key[i].GetPubKey().GetID();\n@@ -286,8 +274,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n     CBasicKeyStore keystore;\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n     }\n@@ -296,29 +283,27 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n \n     CScript a_or_b;\n-    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n+    a_or_b << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n \n     CScript escrow;\n     escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n \n-    CMutableTransaction txFrom;  // Funding transaction\n+    CMutableTransaction txFrom; // Funding transaction\n     txFrom.vout.resize(3);\n     txFrom.vout[0].scriptPubKey = a_and_b;\n     txFrom.vout[1].scriptPubKey = a_or_b;\n     txFrom.vout[2].scriptPubKey = escrow;\n \n     CMutableTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n         txTo[i].vin[0].prevout.n = i;\n         txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n         txTo[i].vout[0].nValue = 1;\n     }\n \n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n     }\n }"
      },
      {
        "sha": "52e9cb43977c581c55cd4fe2fe9ada5c2473d412",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -14,10 +14,10 @@ BOOST_AUTO_TEST_SUITE(netbase_tests)\n \n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n-    BOOST_CHECK(CNetAddr(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n+    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetNetwork() == NET_UNROUTABLE);\n+    BOOST_CHECK(CNetAddr(\"::1\").GetNetwork() == NET_UNROUTABLE);\n+    BOOST_CHECK(CNetAddr(\"8.8.8.8\").GetNetwork() == NET_IPV4);\n+    BOOST_CHECK(CNetAddr(\"2001::8888\").GetNetwork() == NET_IPV6);\n     BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n }\n "
      },
      {
        "sha": "ce568b4f1a082163251dfdc9364293b19651e952",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -16,10 +16,11 @@ class CPartialMerkleTreeTester : public CPartialMerkleTree\n {\n public:\n     // flip one bit in one of the hashes - this should break the authentication\n-    void Damage() {\n+    void Damage()\n+    {\n         unsigned int n = rand() % vHash.size();\n         int bit = rand() % 256;\n-        uint256 &hash = vHash[n];\n+        uint256& hash = vHash[n];\n         hash ^= ((uint256)1 << bit);\n     }\n };\n@@ -35,7 +36,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n \n         // build a block with some dummy transactions\n         CBlock block;\n-        for (unsigned int j=0; j<nTx; j++) {\n+        for (unsigned int j = 0; j < nTx; j++) {\n             CMutableTransaction tx;\n             tx.nLockTime = rand(); // actual transaction data doesn't matter; just make the nLockTime's unique\n             block.vtx.push_back(CTransaction(tx));\n@@ -44,11 +45,11 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n         // calculate actual merkle root and height\n         uint256 merkleRoot1 = block.BuildMerkleTree();\n         std::vector<uint256> vTxid(nTx, 0);\n-        for (unsigned int j=0; j<nTx; j++)\n+        for (unsigned int j = 0; j < nTx; j++)\n             vTxid[j] = block.vtx[j].GetHash();\n         int nHeight = 1, nTx_ = nTx;\n         while (nTx_ > 1) {\n-            nTx_ = (nTx_+1)/2;\n+            nTx_ = (nTx_ + 1) / 2;\n             nHeight++;\n         }\n \n@@ -57,8 +58,8 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             // build random subset of txid's\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n-            for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (rand() & ((1 << (att/2)) - 1)) == 0;\n+            for (unsigned int j = 0; j < nTx; j++) {\n+                bool fInclude = (rand() & ((1 << (att / 2)) - 1)) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n@@ -72,8 +73,8 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             ss << pmt1;\n \n             // verify CPartialMerkleTree's size guarantees\n-            unsigned int n = std::min<unsigned int>(nTx, 1 + vMatchTxid1.size()*nHeight);\n-            BOOST_CHECK(ss.size() <= 10 + (258*n+7)/8);\n+            unsigned int n = std::min<unsigned int>(nTx, 1 + vMatchTxid1.size() * nHeight);\n+            BOOST_CHECK(ss.size() <= 10 + (258 * n + 7) / 8);\n \n             // deserialize into a tester copy\n             CPartialMerkleTreeTester pmt2;\n@@ -91,7 +92,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             BOOST_CHECK(vMatchTxid1 == vMatchTxid2);\n \n             // check that random bit flips break the authentication\n-            for (int j=0; j<4; j++) {\n+            for (int j = 0; j < 4; j++) {\n                 CPartialMerkleTreeTester pmt3(pmt2);\n                 pmt3.Damage();\n                 std::vector<uint256> vMatchTxid3;"
      },
      {
        "sha": "559a54d5945d99888b0561b935a857839b174d1e",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -15,13 +15,15 @@ using namespace std;\n using namespace json_spirit;\n \n Array\n-createArgs(int nRequired, const char* address1=NULL, const char* address2=NULL)\n+createArgs(int nRequired, const char* address1 = NULL, const char* address2 = NULL)\n {\n     Array result;\n     result.push_back(nRequired);\n     Array addresses;\n-    if (address1) addresses.push_back(address1);\n-    if (address2) addresses.push_back(address2);\n+    if (address1)\n+        addresses.push_back(address1);\n+    if (address2)\n+        addresses.push_back(address2);\n     result.push_back(addresses);\n     return result;\n }\n@@ -38,9 +40,7 @@ Value CallRPC(string args)\n     try {\n         Value result = (*method)(params, false);\n         return result;\n-    }\n-    catch (Object& objError)\n-    {\n+    } catch (Object& objError) {\n         throw runtime_error(find_value(objError, \"message\").get_str());\n     }\n }\n@@ -69,42 +69,42 @@ BOOST_AUTO_TEST_CASE(rpc_rawparams)\n     BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction null\"), runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction DEADBEEF\"), runtime_error);\n     string rawtx = \"0100000001a15d57094aa7a21a28cb20b59aab8fc7d1149a3bdbcddba9c622e4f5f6a99ece010000006c493046022100f93bb0e7d8db7bd46e40132d1f8242026e045f03a0efe71bbb8e3f475e970d790221009337cd7f1f929f00cc6ff01f03729b069a7c21b59b1736ddfee5db5946c5da8c0121033b9b137ee87d5a812d6f506efdd37f0affa7ffc310711c06c7f3e097c9447c52ffffffff0100e1f505000000001976a9140389035a9225b3839e2bbf32d826a1e222031fd888ac00000000\";\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"decoderawtransaction \") + rawtx));\n     BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"version\").get_int(), 1);\n     BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"locktime\").get_int(), 0);\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx+\" extra\"), runtime_error);\n+    BOOST_CHECK_THROW(r = CallRPC(string(\"decoderawtransaction \") + rawtx + \" extra\"), runtime_error);\n \n     BOOST_CHECK_THROW(CallRPC(\"signrawtransaction\"), runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"signrawtransaction null\"), runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"signrawtransaction ff00\"), runtime_error);\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" [] [] NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null badenum\"), runtime_error);\n+    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \") + rawtx));\n+    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \") + rawtx + \" null null NONE|ANYONECANPAY\"));\n+    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \") + rawtx + \" [] [] NONE|ANYONECANPAY\"));\n+    BOOST_CHECK_THROW(CallRPC(string(\"signrawtransaction \") + rawtx + \" null null badenum\"), runtime_error);\n \n     // Only check failure cases for sendrawtransaction, there's no network to send to...\n     BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction\"), runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction null\"), runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction DEADBEEF\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(string(\"sendrawtransaction \")+rawtx+\" extra\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(string(\"sendrawtransaction \") + rawtx + \" extra\"), runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(rpc_rawsign)\n {\n     Value r;\n     // input is a 1-of-2 multisig (so is output):\n     string prevout =\n-      \"[{\\\"txid\\\":\\\"b4cc287e58f87cdae59417329f710f3ecd75a4ee1d2872b7248f50977c8493f3\\\",\"\n-      \"\\\"vout\\\":1,\\\"scriptPubKey\\\":\\\"a914b10c9df5f7edf436c697f02f1efdba4cf399615187\\\",\"\n-      \"\\\"redeemScript\\\":\\\"512103debedc17b3df2badbcdd86d5feb4562b86fe182e5998abd8bcd4f122c6155b1b21027e940bb73ab8732bfdf7f9216ecefca5b94d6df834e77e108f68e66f126044c052ae\\\"}]\";\n-    r = CallRPC(string(\"createrawtransaction \")+prevout+\" \"+\n-      \"{\\\"3HqAe9LtNBjnsfM4CyYaWTnvCaUYT7v4oZ\\\":11}\");\n+        \"[{\\\"txid\\\":\\\"b4cc287e58f87cdae59417329f710f3ecd75a4ee1d2872b7248f50977c8493f3\\\",\"\n+        \"\\\"vout\\\":1,\\\"scriptPubKey\\\":\\\"a914b10c9df5f7edf436c697f02f1efdba4cf399615187\\\",\"\n+        \"\\\"redeemScript\\\":\\\"512103debedc17b3df2badbcdd86d5feb4562b86fe182e5998abd8bcd4f122c6155b1b21027e940bb73ab8732bfdf7f9216ecefca5b94d6df834e77e108f68e66f126044c052ae\\\"}]\";\n+    r = CallRPC(string(\"createrawtransaction \") + prevout + \" \" +\n+                \"{\\\"3HqAe9LtNBjnsfM4CyYaWTnvCaUYT7v4oZ\\\":11}\");\n     string notsigned = r.get_str();\n     string privkey1 = \"\\\"KzsXybp9jX64P5ekX1KUxRQ79Jht9uzW7LorgwE65i5rWACL6LQe\\\"\";\n     string privkey2 = \"\\\"Kyhdf5LuKTRx4ge69ybABsiUAWjVRK4XGxAKk2FQLp2HjGMy87Z4\\\"\";\n-    r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[]\");\n+    r = CallRPC(string(\"signrawtransaction \") + notsigned + \" \" + prevout + \" \" + \"[]\");\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == false);\n-    r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[\"+privkey1+\",\"+privkey2+\"]\");\n+    r = CallRPC(string(\"signrawtransaction \") + notsigned + \" \" + prevout + \" \" + \"[\" + privkey1 + \",\" + privkey2 + \"]\");\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == true);\n }\n \n@@ -120,7 +120,7 @@ BOOST_AUTO_TEST_CASE(rpc_format_monetary_values)\n     BOOST_CHECK_EQUAL(write_string(ValueFromAmount(2099999999999999LL), false), \"20999999.99999999\");\n }\n \n-static Value ValueFromString(const std::string &str)\n+static Value ValueFromString(const std::string& str)\n {\n     Value value;\n     BOOST_CHECK(read_string(str, value));\n@@ -147,7 +147,7 @@ BOOST_AUTO_TEST_CASE(rpc_boostasiotocnetaddr)\n     // Check IPv6 addresses\n     BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"::1\")).ToString(), \"::1\");\n     BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"123:4567:89ab:cdef:123:4567:89ab:cdef\")).ToString(),\n-                                         \"123:4567:89ab:cdef:123:4567:89ab:cdef\");\n+                      \"123:4567:89ab:cdef:123:4567:89ab:cdef\");\n     // v4 compatible must be interpreted as IPv4\n     BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"::0:127.0.0.1\")).ToString(), \"127.0.0.1\");\n     // v4 mapped must be interpreted as IPv4"
      },
      {
        "sha": "e89a905e1a809ba1c94335351a853e3411bae2e2",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 51,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -59,8 +59,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n     CBasicKeyStore keystore;\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n     }\n@@ -73,27 +72,24 @@ BOOST_AUTO_TEST_CASE(sign)\n     standardScripts[2] << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n     standardScripts[3] = GetScriptForDestination(key[2].GetPubKey().GetID());\n     CScript evalScripts[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         keystore.AddCScript(standardScripts[i]);\n         evalScripts[i] = GetScriptForDestination(CScriptID(standardScripts[i]));\n     }\n \n-    CMutableTransaction txFrom;  // Funding transaction:\n+    CMutableTransaction txFrom; // Funding transaction:\n     string reason;\n     txFrom.vout.resize(8);\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         txFrom.vout[i].scriptPubKey = evalScripts[i];\n         txFrom.vout[i].nValue = COIN;\n-        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n-        txFrom.vout[i+4].nValue = COIN;\n+        txFrom.vout[i + 4].scriptPubKey = standardScripts[i];\n+        txFrom.vout[i + 4].nValue = COIN;\n     }\n     BOOST_CHECK(IsStandardTx(txFrom, reason));\n \n     CMutableTransaction txTo[8]; // Spending transactions\n-    for (int i = 0; i < 8; i++)\n-    {\n+    for (int i = 0; i < 8; i++) {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n         txTo[i].vin[0].prevout.n = i;\n@@ -103,15 +99,13 @@ BOOST_AUTO_TEST_CASE(sign)\n         BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n #endif\n     }\n-    for (int i = 0; i < 8; i++)\n-    {\n+    for (int i = 0; i < 8; i++) {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n     for (int i = 0; i < 8; i++)\n-        for (int j = 0; j < 8; j++)\n-        {\n+        for (int j = 0; j < 8; j++) {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n             bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false)();\n@@ -157,51 +151,46 @@ BOOST_AUTO_TEST_CASE(set)\n     CBasicKeyStore keystore;\n     CKey key[4];\n     std::vector<CPubKey> keys;\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n         keys.push_back(key[i].GetPubKey());\n     }\n \n     CScript inner[4];\n     inner[0] = GetScriptForDestination(key[0].GetPubKey().GetID());\n-    inner[1] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n-    inner[2] = GetScriptForMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n-    inner[3] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+3));\n+    inner[1] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin() + 2));\n+    inner[2] = GetScriptForMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin() + 2));\n+    inner[3] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin() + 3));\n \n     CScript outer[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         outer[i] = GetScriptForDestination(CScriptID(inner[i]));\n         keystore.AddCScript(inner[i]);\n     }\n \n-    CMutableTransaction txFrom;  // Funding transaction:\n+    CMutableTransaction txFrom; // Funding transaction:\n     string reason;\n     txFrom.vout.resize(4);\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         txFrom.vout[i].scriptPubKey = outer[i];\n         txFrom.vout[i].nValue = CENT;\n     }\n     BOOST_CHECK(IsStandardTx(txFrom, reason));\n \n     CMutableTransaction txTo[4]; // Spending transactions\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n         txTo[i].vin[0].prevout.n = i;\n         txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1*CENT;\n+        txTo[i].vout[0].nValue = 1 * CENT;\n         txTo[i].vout[0].scriptPubKey = inner[i];\n #ifdef ENABLE_WALLET\n         BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n #endif\n     }\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n         BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n     }\n@@ -216,25 +205,28 @@ BOOST_AUTO_TEST_CASE(is)\n     BOOST_CHECK(p2sh.IsPayToScriptHash());\n \n     // Not considered pay-to-script-hash if using one of the OP_PUSHDATA opcodes:\n-    static const unsigned char direct[] =    { OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\n-    static const unsigned char pushdata1[] = { OP_HASH160, OP_PUSHDATA1, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\n-    static const unsigned char pushdata2[] = { OP_HASH160, OP_PUSHDATA2, 20,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\n-    static const unsigned char pushdata4[] = { OP_HASH160, OP_PUSHDATA4, 20,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\n+    static const unsigned char direct[] = {OP_HASH160, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, OP_EQUAL};\n+    BOOST_CHECK(CScript(direct, direct + sizeof(direct)).IsPayToScriptHash());\n+    static const unsigned char pushdata1[] = {OP_HASH160, OP_PUSHDATA1, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, OP_EQUAL};\n+    BOOST_CHECK(!CScript(pushdata1, pushdata1 + sizeof(pushdata1)).IsPayToScriptHash());\n+    static const unsigned char pushdata2[] = {OP_HASH160, OP_PUSHDATA2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, OP_EQUAL};\n+    BOOST_CHECK(!CScript(pushdata2, pushdata2 + sizeof(pushdata2)).IsPayToScriptHash());\n+    static const unsigned char pushdata4[] = {OP_HASH160, OP_PUSHDATA4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, OP_EQUAL};\n+    BOOST_CHECK(!CScript(pushdata4, pushdata4 + sizeof(pushdata4)).IsPayToScriptHash());\n \n     CScript not_p2sh;\n     BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n-    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << ToByteVector(dummy) << OP_EQUAL;\n+    not_p2sh.clear();\n+    not_p2sh << OP_HASH160 << ToByteVector(dummy) << ToByteVector(dummy) << OP_EQUAL;\n     BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n-    not_p2sh.clear(); not_p2sh << OP_NOP << ToByteVector(dummy) << OP_EQUAL;\n+    not_p2sh.clear();\n+    not_p2sh << OP_NOP << ToByteVector(dummy) << OP_EQUAL;\n     BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n-    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << OP_CHECKSIG;\n+    not_p2sh.clear();\n+    not_p2sh << OP_HASH160 << ToByteVector(dummy) << OP_CHECKSIG;\n     BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n }\n \n@@ -266,8 +258,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CBasicKeyStore keystore;\n     CKey key[6];\n     vector<CPubKey> keys;\n-    for (int i = 0; i < 6; i++)\n-    {\n+    for (int i = 0; i < 6; i++) {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n     }\n@@ -301,20 +292,23 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[3].nValue = 4000;\n \n     // vout[4] is max sigops:\n-    CScript fifteenSigops; fifteenSigops << OP_1;\n+    CScript fifteenSigops;\n+    fifteenSigops << OP_1;\n     for (unsigned i = 0; i < MAX_P2SH_SIGOPS; i++)\n-        fifteenSigops << ToByteVector(key[i%3].GetPubKey());\n+        fifteenSigops << ToByteVector(key[i % 3].GetPubKey());\n     fifteenSigops << OP_15 << OP_CHECKMULTISIG;\n     keystore.AddCScript(fifteenSigops);\n     txFrom.vout[4].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\n     txFrom.vout[4].nValue = 5000;\n \n     // vout[5/6] are non-standard because they exceed MAX_P2SH_SIGOPS\n-    CScript sixteenSigops; sixteenSigops << OP_16 << OP_CHECKMULTISIG;\n+    CScript sixteenSigops;\n+    sixteenSigops << OP_16 << OP_CHECKMULTISIG;\n     keystore.AddCScript(sixteenSigops);\n     txFrom.vout[5].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\n     txFrom.vout[5].nValue = 5000;\n-    CScript twentySigops; twentySigops << OP_CHECKMULTISIG;\n+    CScript twentySigops;\n+    twentySigops << OP_CHECKMULTISIG;\n     keystore.AddCScript(twentySigops);\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n@@ -326,8 +320,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txTo.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\n \n     txTo.vin.resize(5);\n-    for (int i = 0; i < 5; i++)\n-    {\n+    for (int i = 0; i < 5; i++) {\n         txTo.vin[i].prevout.n = i;\n         txTo.vin[i].prevout.hash = txFrom.GetHash();\n     }\n@@ -345,8 +338,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n \n     // Make sure adding crap to the scriptSigs makes them non-standard:\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         CScript t = txTo.vin[i].scriptSig;\n         txTo.vin[i].scriptSig = (CScript() << 11) + t;\n         BOOST_CHECK(!::AreInputsStandard(txTo, coins));"
      },
      {
        "sha": "749ecb946ea1fdf764df346d7595de9d1d19fe8b",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 248,
        "deletions": 144,
        "changes": 392,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -52,8 +52,7 @@ read_json(const std::string& jsondata)\n {\n     Value v;\n \n-    if (!read_string(jsondata, v) || v.type() != array_type)\n-    {\n+    if (!read_string(jsondata, v) || v.type() != array_type) {\n         BOOST_ERROR(\"Parse error.\");\n         return Array();\n     }\n@@ -105,11 +104,12 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, bo\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n-    BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(begin_ptr(scriptPubKey), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect,message);\n+    BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(begin_ptr(scriptPubKey), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n #endif\n }\n \n-void static NegateSignatureS(std::vector<unsigned char>& vchSig) {\n+void static NegateSignatureS(std::vector<unsigned char>& vchSig)\n+{\n     // Parse the signature.\n     std::vector<unsigned char> r, s;\n     r = std::vector<unsigned char>(vchSig.begin() + 4, vchSig.begin() + 4 + vchSig[3]);\n@@ -119,11 +119,38 @@ void static NegateSignatureS(std::vector<unsigned char>& vchSig) {\n     // Really ugly to implement mod-n negation here, but it would be feature creep to expose such functionality from libsecp256k1.\n     static const unsigned char order[33] = {\n         0x00,\n-        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n-        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n-        0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n-        0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n-    };\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFF,\n+        0xFE,\n+        0xBA,\n+        0xAE,\n+        0xDC,\n+        0xE6,\n+        0xAF,\n+        0x48,\n+        0xA0,\n+        0x3B,\n+        0xBF,\n+        0xD2,\n+        0x5E,\n+        0x8C,\n+        0xD0,\n+        0x36,\n+        0x41,\n+        0x41};\n     while (s.size() < 33) {\n         s.insert(s.begin(), 0x00);\n     }\n@@ -153,9 +180,9 @@ void static NegateSignatureS(std::vector<unsigned char>& vchSig) {\n \n namespace\n {\n-const unsigned char vchKey0[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-const unsigned char vchKey1[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0};\n-const unsigned char vchKey2[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0};\n+const unsigned char vchKey0[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};\n+const unsigned char vchKey1[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};\n+const unsigned char vchKey2[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};\n \n struct KeyData\n {\n@@ -166,7 +193,6 @@ struct KeyData\n \n     KeyData()\n     {\n-\n         key0.Set(vchKey0, vchKey0 + 32, false);\n         key0C.Set(vchKey0, vchKey0 + 32, true);\n         pubkey0 = key0.GetPubKey();\n@@ -208,9 +234,9 @@ class TestBuilder\n \n     void DoPush(const std::vector<unsigned char>& data)\n     {\n-         DoPush();\n-         push = data;\n-         havePush = true;\n+        DoPush();\n+        push = data;\n+        havePush = true;\n     }\n \n public:\n@@ -333,161 +359,234 @@ BOOST_AUTO_TEST_CASE(script_build)\n     std::vector<TestBuilder> bad;\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                               \"P2PK\", 0\n-                              ).PushSig(keys.key0));\n+                               \"P2PK\",\n+                               0).PushSig(keys.key0));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                              \"P2PK, bad sig\", 0\n-                             ).PushSig(keys.key0).DamagePush(10));\n+                              \"P2PK, bad sig\",\n+                              0).PushSig(keys.key0)\n+                      .DamagePush(10));\n \n     good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                               \"P2PKH\", 0\n-                              ).PushSig(keys.key1).Push(keys.pubkey1C));\n+                               \"P2PKH\",\n+                               0).PushSig(keys.key1)\n+                       .Push(keys.pubkey1C));\n     bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey2C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                              \"P2PKH, bad pubkey\", 0\n-                             ).PushSig(keys.key2).Push(keys.pubkey2C).DamagePush(5));\n+                              \"P2PKH, bad pubkey\",\n+                              0).PushSig(keys.key2)\n+                      .Push(keys.pubkey2C)\n+                      .DamagePush(5));\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                               \"P2PK anyonecanpay\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY));\n+                               \"P2PK anyonecanpay\",\n+                               0).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                              \"P2PK anyonecanpay marked with normal hashtype\", 0\n-                             ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY).EditPush(70, \"81\", \"01\"));\n+                              \"P2PK anyonecanpay marked with normal hashtype\",\n+                              0).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY)\n+                      .EditPush(70, \"81\", \"01\"));\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                               \"P2SH(P2PK)\", SCRIPT_VERIFY_P2SH, true\n-                              ).PushSig(keys.key0).PushRedeem());\n+                               \"P2SH(P2PK)\",\n+                               SCRIPT_VERIFY_P2SH,\n+                               true).PushSig(keys.key0)\n+                       .PushRedeem());\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK), bad redeemscript\", SCRIPT_VERIFY_P2SH, true\n-                             ).PushSig(keys.key0).PushRedeem().DamagePush(10));\n+                              \"P2SH(P2PK), bad redeemscript\",\n+                              SCRIPT_VERIFY_P2SH,\n+                              true).PushSig(keys.key0)\n+                      .PushRedeem()\n+                      .DamagePush(10));\n \n     good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                               \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\", 0, true\n-                              ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n+                               \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\",\n+                               0,\n+                               true).PushSig(keys.key0)\n+                       .DamagePush(10)\n+                       .PushRedeem());\n     bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                              \"P2SH(P2PKH), bad sig\", SCRIPT_VERIFY_P2SH, true\n-                             ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n+                              \"P2SH(P2PKH), bad sig\",\n+                              SCRIPT_VERIFY_P2SH,\n+                              true).PushSig(keys.key0)\n+                      .DamagePush(10)\n+                      .PushRedeem());\n \n     good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"3-of-3\", 0\n-                              ).Num(0).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+                               \"3-of-3\",\n+                               0).Num(0)\n+                       .PushSig(keys.key0)\n+                       .PushSig(keys.key1)\n+                       .PushSig(keys.key2));\n     bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"3-of-3, 2 sigs\", 0\n-                             ).Num(0).PushSig(keys.key0).PushSig(keys.key1).Num(0));\n+                              \"3-of-3, 2 sigs\",\n+                              0).Num(0)\n+                      .PushSig(keys.key0)\n+                      .PushSig(keys.key1)\n+                      .Num(0));\n \n     good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"P2SH(2-of-3)\", SCRIPT_VERIFY_P2SH, true\n-                              ).Num(0).PushSig(keys.key1).PushSig(keys.key2).PushRedeem());\n+                               \"P2SH(2-of-3)\",\n+                               SCRIPT_VERIFY_P2SH,\n+                               true).Num(0)\n+                       .PushSig(keys.key1)\n+                       .PushSig(keys.key2)\n+                       .PushRedeem());\n     bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"P2SH(2-of-3), 1 sig\", SCRIPT_VERIFY_P2SH, true\n-                             ).Num(0).PushSig(keys.key1).Num(0).PushRedeem());\n+                              \"P2SH(2-of-3), 1 sig\",\n+                              SCRIPT_VERIFY_P2SH,\n+                              true).Num(0)\n+                      .PushSig(keys.key1)\n+                      .Num(0)\n+                      .PushRedeem());\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too much R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+                               \"P2PK with too much R padding but no DERSIG\",\n+                               0).PushSig(keys.key1, SIGHASH_ALL, 31, 32)\n+                       .EditPush(1, \"43021F\", \"44022000\"));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+                              \"P2PK with too much R padding\",\n+                              SCRIPT_VERIFY_DERSIG).PushSig(keys.key1, SIGHASH_ALL, 31, 32)\n+                      .EditPush(1, \"43021F\", \"44022000\"));\n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too much S padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n+                               \"P2PK with too much S padding but no DERSIG\",\n+                               0).PushSig(keys.key1, SIGHASH_ALL)\n+                       .EditPush(1, \"44\", \"45\")\n+                       .EditPush(37, \"20\", \"2100\"));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too much S padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n+                              \"P2PK with too much S padding\",\n+                              SCRIPT_VERIFY_DERSIG).PushSig(keys.key1, SIGHASH_ALL)\n+                      .EditPush(1, \"44\", \"45\")\n+                      .EditPush(37, \"20\", \"2100\"));\n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too little R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n+                               \"P2PK with too little R padding but no DERSIG\",\n+                               0).PushSig(keys.key1, SIGHASH_ALL, 33, 32)\n+                       .EditPush(1, \"45022100\", \"440220\"));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too little R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n+                              \"P2PK with too little R padding\",\n+                              SCRIPT_VERIFY_DERSIG).PushSig(keys.key1, SIGHASH_ALL, 33, 32)\n+                      .EditPush(1, \"45022100\", \"440220\"));\n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with bad sig with too much R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n+                               \"P2PK NOT with bad sig with too much R padding but no DERSIG\",\n+                               0).PushSig(keys.key2, SIGHASH_ALL, 31, 32)\n+                       .EditPush(1, \"43021F\", \"44022000\")\n+                       .DamagePush(10));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with bad sig with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n+                              \"P2PK NOT with bad sig with too much R padding\",\n+                              SCRIPT_VERIFY_DERSIG).PushSig(keys.key2, SIGHASH_ALL, 31, 32)\n+                      .EditPush(1, \"43021F\", \"44022000\")\n+                      .DamagePush(10));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with too much R padding but no DERSIG\", 0\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+                              \"P2PK NOT with too much R padding but no DERSIG\",\n+                              0).PushSig(keys.key2, SIGHASH_ALL, 31, 32)\n+                      .EditPush(1, \"43021F\", \"44022000\"));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+                              \"P2PK NOT with too much R padding\",\n+                              SCRIPT_VERIFY_DERSIG).PushSig(keys.key2, SIGHASH_ALL, 31, 32)\n+                      .EditPush(1, \"43021F\", \"44022000\"));\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                               \"P2PK with high S but no LOW_S\", 0\n-                              ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n+                               \"P2PK with high S but no LOW_S\",\n+                               0).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2PK with high S\", SCRIPT_VERIFY_LOW_S\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n+                              \"P2PK with high S\",\n+                              SCRIPT_VERIFY_LOW_S).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n-                               \"P2PK with hybrid pubkey but no STRICTENC\", 0\n-                              ).PushSig(keys.key0, SIGHASH_ALL));\n+                               \"P2PK with hybrid pubkey but no STRICTENC\",\n+                               0).PushSig(keys.key0, SIGHASH_ALL));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n-                              \"P2PK with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key0, SIGHASH_ALL));\n+                              \"P2PK with hybrid pubkey\",\n+                              SCRIPT_VERIFY_STRICTENC).PushSig(keys.key0, SIGHASH_ALL));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with hybrid pubkey but no STRICTENC\", 0\n-                             ).PushSig(keys.key0, SIGHASH_ALL));\n+                              \"P2PK NOT with hybrid pubkey but no STRICTENC\",\n+                              0).PushSig(keys.key0, SIGHASH_ALL));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key0, SIGHASH_ALL));\n+                              \"P2PK NOT with hybrid pubkey\",\n+                              SCRIPT_VERIFY_STRICTENC).PushSig(keys.key0, SIGHASH_ALL));\n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\", 0\n-                              ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n+                               \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\",\n+                               0).PushSig(keys.key0, SIGHASH_ALL)\n+                       .DamagePush(10));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with invalid hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n+                              \"P2PK NOT with invalid hybrid pubkey\",\n+                              SCRIPT_VERIFY_STRICTENC).PushSig(keys.key0, SIGHASH_ALL)\n+                      .DamagePush(10));\n     good.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey0H) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"1-of-2 with the second 1 hybrid pubkey and no STRICTENC\", 0\n-                              ).Num(0).PushSig(keys.key1, SIGHASH_ALL));\n+                               \"1-of-2 with the second 1 hybrid pubkey and no STRICTENC\",\n+                               0).Num(0)\n+                       .PushSig(keys.key1, SIGHASH_ALL));\n     good.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey0H) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"1-of-2 with the second 1 hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                              ).Num(0).PushSig(keys.key1, SIGHASH_ALL));\n+                               \"1-of-2 with the second 1 hybrid pubkey\",\n+                               SCRIPT_VERIFY_STRICTENC).Num(0)\n+                       .PushSig(keys.key1, SIGHASH_ALL));\n     bad.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0H) << OP_2 << OP_CHECKMULTISIG,\n-                              \"1-of-2 with the first 1 hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                             ).Num(0).PushSig(keys.key1, SIGHASH_ALL));\n+                              \"1-of-2 with the first 1 hybrid pubkey\",\n+                              SCRIPT_VERIFY_STRICTENC).Num(0)\n+                      .PushSig(keys.key1, SIGHASH_ALL));\n \n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                               \"P2PK with undefined hashtype but no STRICTENC\", 0\n-                              ).PushSig(keys.key1, 5));\n+                               \"P2PK with undefined hashtype but no STRICTENC\",\n+                               0).PushSig(keys.key1, 5));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                              \"P2PK with undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key1, 5));\n+                              \"P2PK with undefined hashtype\",\n+                              SCRIPT_VERIFY_STRICTENC).PushSig(keys.key1, 5));\n     good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\", 0\n-                              ).PushSig(keys.key1, 5).DamagePush(10));\n+                               \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\",\n+                               0).PushSig(keys.key1, 5)\n+                       .DamagePush(10));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with invalid sig and undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key1, 5).DamagePush(10));\n+                              \"P2PK NOT with invalid sig and undefined hashtype\",\n+                              SCRIPT_VERIFY_STRICTENC).PushSig(keys.key1, 5)\n+                      .DamagePush(10));\n \n     good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"3-of-3 with nonzero dummy but no NULLDUMMY\", 0\n-                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+                               \"3-of-3 with nonzero dummy but no NULLDUMMY\",\n+                               0).Num(1)\n+                       .PushSig(keys.key0)\n+                       .PushSig(keys.key1)\n+                       .PushSig(keys.key2));\n     bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"3-of-3 with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n-                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+                              \"3-of-3 with nonzero dummy\",\n+                              SCRIPT_VERIFY_NULLDUMMY).Num(1)\n+                      .PushSig(keys.key0)\n+                      .PushSig(keys.key1)\n+                      .PushSig(keys.key2));\n     good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n-                               \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\", 0\n-                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n+                               \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\",\n+                               0).Num(1)\n+                       .PushSig(keys.key0)\n+                       .PushSig(keys.key1)\n+                       .PushSig(keys.key2)\n+                       .DamagePush(10));\n     bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n-                              \"3-of-3 NOT with invalid sig with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n-                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n+                              \"3-of-3 NOT with invalid sig with nonzero dummy\",\n+                              SCRIPT_VERIFY_NULLDUMMY).Num(1)\n+                      .PushSig(keys.key0)\n+                      .PushSig(keys.key1)\n+                      .PushSig(keys.key2)\n+                      .DamagePush(10));\n \n     good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\", 0\n-                              ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n+                               \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\",\n+                               0).Num(0)\n+                       .PushSig(keys.key1)\n+                       .Add(CScript() << OP_DUP));\n     bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                              \"2-of-2 with two identical keys and sigs pushed using OP_DUP\", SCRIPT_VERIFY_SIGPUSHONLY\n-                             ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n+                              \"2-of-2 with two identical keys and sigs pushed using OP_DUP\",\n+                              SCRIPT_VERIFY_SIGPUSHONLY).Num(0)\n+                      .PushSig(keys.key1)\n+                      .Add(CScript() << OP_DUP));\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK) with non-push scriptSig but no SIGPUSHONLY\", 0\n-                             ).PushSig(keys.key2).PushRedeem());\n+                              \"P2SH(P2PK) with non-push scriptSig but no SIGPUSHONLY\",\n+                              0).PushSig(keys.key2)\n+                      .PushRedeem());\n     bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK) with non-push scriptSig\", SCRIPT_VERIFY_SIGPUSHONLY\n-                             ).PushSig(keys.key2).PushRedeem());\n+                              \"P2SH(P2PK) with non-push scriptSig\",\n+                              SCRIPT_VERIFY_SIGPUSHONLY).PushSig(keys.key2)\n+                      .PushRedeem());\n     good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"2-of-2 with two identical keys and sigs pushed\", SCRIPT_VERIFY_SIGPUSHONLY\n-                              ).Num(0).PushSig(keys.key1).PushSig(keys.key1));\n+                               \"2-of-2 with two identical keys and sigs pushed\",\n+                               SCRIPT_VERIFY_SIGPUSHONLY).Num(0)\n+                       .PushSig(keys.key1)\n+                       .PushSig(keys.key1));\n \n \n     std::map<std::string, Array> tests_good;\n@@ -497,13 +596,13 @@ BOOST_AUTO_TEST_CASE(script_build)\n         Array json_good = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n         Array json_bad = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n \n-        BOOST_FOREACH(Value& tv, json_good) {\n+        BOOST_FOREACH (Value& tv, json_good) {\n             Array test = tv.get_array();\n             if (test.size() >= 4) {\n                 tests_good[test[3].get_str()] = test;\n             }\n         }\n-        BOOST_FOREACH(Value& tv, json_bad) {\n+        BOOST_FOREACH (Value& tv, json_bad) {\n             Array test = tv.get_array();\n             if (test.size() >= 4) {\n                 tests_bad[test[3].get_str()] = test;\n@@ -514,7 +613,7 @@ BOOST_AUTO_TEST_CASE(script_build)\n     std::string strGood;\n     std::string strBad;\n \n-    BOOST_FOREACH(TestBuilder& test, good) {\n+    BOOST_FOREACH (TestBuilder& test, good) {\n         test.Test(true);\n         if (tests_good.count(test.GetComment()) == 0) {\n #ifndef UPDATE_JSON_TESTS\n@@ -526,7 +625,7 @@ BOOST_AUTO_TEST_CASE(script_build)\n             strGood += write_string(Value(tests_good[test.GetComment()]), true) + \",\\n\";\n         }\n     }\n-    BOOST_FOREACH(TestBuilder& test, bad) {\n+    BOOST_FOREACH (TestBuilder& test, bad) {\n         test.Test(false);\n         if (tests_bad.count(test.GetComment()) == 0) {\n #ifndef UPDATE_JSON_TESTS\n@@ -558,8 +657,7 @@ BOOST_AUTO_TEST_CASE(script_valid)\n     // scripts.\n     Array tests = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         string strTest = write_string(tv, false);\n         if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n@@ -584,8 +682,7 @@ BOOST_AUTO_TEST_CASE(script_invalid)\n     // Scripts that should evaluate as invalid\n     Array tests = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         string strTest = write_string(tv, false);\n         if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n@@ -609,10 +706,10 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n {\n     // Check that PUSHDATA1, PUSHDATA2, and PUSHDATA4 create the same value on\n     // the stack as the 1-75 opcodes do.\n-    static const unsigned char direct[] = { 1, 0x5a };\n-    static const unsigned char pushdata1[] = { OP_PUSHDATA1, 1, 0x5a };\n-    static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n-    static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n+    static const unsigned char direct[] = {1, 0x5a};\n+    static const unsigned char pushdata1[] = {OP_PUSHDATA1, 1, 0x5a};\n+    static const unsigned char pushdata2[] = {OP_PUSHDATA2, 1, 0, 0x5a};\n+    static const unsigned char pushdata4[] = {OP_PUSHDATA4, 1, 0, 0, 0, 0x5a};\n \n     ScriptError err;\n     vector<vector<unsigned char> > directStack;\n@@ -650,8 +747,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     // and vice-versa)\n     //\n     result << OP_0;\n-    BOOST_FOREACH(const CKey &key, keys)\n-    {\n+    BOOST_FOREACH (const CKey& key, keys) {\n         vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -660,7 +756,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     return result;\n }\n CScript\n-sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n+sign_multisig(CScript scriptPubKey, const CKey& key, CTransaction transaction)\n {\n     std::vector<CKey> keys;\n     keys.push_back(key);\n@@ -713,49 +809,57 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), txFrom23);\n \n     std::vector<CKey> keys;\n-    keys.push_back(key1); keys.push_back(key2);\n+    keys.push_back(key1);\n+    keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key1); keys.push_back(key3);\n+    keys.push_back(key1);\n+    keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key2); keys.push_back(key3);\n+    keys.push_back(key2);\n+    keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n+    keys.push_back(key2);\n+    keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n+    keys.push_back(key2);\n+    keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n+    keys.push_back(key3);\n+    keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n+    keys.push_back(key4);\n+    keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n-    keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n+    keys.push_back(key1);\n+    keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n@@ -764,18 +868,17 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n     BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n-}    \n+}\n \n BOOST_AUTO_TEST_CASE(script_combineSigs)\n {\n     // Test the CombineSignatures function\n     CBasicKeyStore keystore;\n     vector<CKey> keys;\n     vector<CPubKey> pubkeys;\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         CKey key;\n-        key.MakeNewKey(i%2 == 1);\n+        key.MakeNewKey(i % 2 == 1);\n         keys.push_back(key);\n         pubkeys.push_back(key.GetPubKey());\n         keystore.AddKey(key);\n@@ -803,7 +906,8 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n \n     // P2SH, single-signature case:\n-    CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n+    CScript pkSingle;\n+    pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n     SignSignature(keystore, txFrom, txTo, 0);\n@@ -878,15 +982,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n BOOST_AUTO_TEST_CASE(script_standard_push)\n {\n     ScriptError err;\n-    for (int i=0; i<67000; i++) {\n+    for (int i = 0; i < 67000; i++) {\n         CScript script;\n         script << i;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n         BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n \n-    for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n+    for (unsigned int i = 0; i <= MAX_SCRIPT_ELEMENT_SIZE; i++) {\n         std::vector<unsigned char> data(i, '\\111');\n         CScript script;\n         script << data;\n@@ -903,8 +1007,8 @@ BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n     // because P2SH evaluation uses it, although this specific behavior should\n     // not be consensus critical as the P2SH evaluation would fail first due to\n     // the invalid push. Still, it doesn't hurt to test it explicitly.\n-    static const unsigned char direct[] = { 1 };\n-    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n+    static const unsigned char direct[] = {1};\n+    BOOST_CHECK(!CScript(direct, direct + sizeof(direct)).IsPushOnly());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4c2b3da8e5bfc5f818c26d66f91370e866cf1d20",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 44,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -9,9 +9,9 @@\n #include <stdint.h>\n BOOST_AUTO_TEST_SUITE(scriptnum_tests)\n \n-static const int64_t values[] = \\\n-{ 0, 1, CHAR_MIN, CHAR_MAX, UCHAR_MAX, SHRT_MIN, USHRT_MAX, INT_MIN, INT_MAX, UINT_MAX, LONG_MIN, LONG_MAX };\n-static const int64_t offsets[] = { 1, 0x79, 0x80, 0x81, 0xFF, 0x7FFF, 0x8000, 0xFFFF, 0x10000};\n+static const int64_t values[] =\n+    {0, 1, CHAR_MIN, CHAR_MAX, UCHAR_MAX, SHRT_MIN, USHRT_MAX, INT_MIN, INT_MAX, UINT_MAX, LONG_MIN, LONG_MAX};\n+static const int64_t offsets[] = {1, 0x79, 0x80, 0x81, 0xFF, 0x7FFF, 0x8000, 0xFFFF, 0x10000};\n \n static bool verify(const CBigNum& bignum, const CScriptNum& scriptnum)\n {\n@@ -58,8 +58,7 @@ static void CheckAdd(const int64_t& num1, const int64_t& num2)\n     // int64_t overflow is undefined.\n     bool invalid = (((num2 > 0) && (num1 > (std::numeric_limits<int64_t>::max() - num2))) ||\n                     ((num2 < 0) && (num1 < (std::numeric_limits<int64_t>::min() - num2))));\n-    if (!invalid)\n-    {\n+    if (!invalid) {\n         BOOST_CHECK(verify(bignum1 + bignum2, scriptnum1 + scriptnum2));\n         BOOST_CHECK(verify(bignum1 + bignum2, scriptnum1 + num2));\n         BOOST_CHECK(verify(bignum1 + bignum2, scriptnum2 + num1));\n@@ -87,16 +86,14 @@ static void CheckSubtract(const int64_t& num1, const int64_t& num2)\n     // int64_t overflow is undefined.\n     invalid = ((num2 > 0 && num1 < std::numeric_limits<int64_t>::min() + num2) ||\n                (num2 < 0 && num1 > std::numeric_limits<int64_t>::max() + num2));\n-    if (!invalid)\n-    {\n+    if (!invalid) {\n         BOOST_CHECK(verify(bignum1 - bignum2, scriptnum1 - scriptnum2));\n         BOOST_CHECK(verify(bignum1 - bignum2, scriptnum1 - num2));\n     }\n \n     invalid = ((num1 > 0 && num2 < std::numeric_limits<int64_t>::min() + num1) ||\n                (num1 < 0 && num2 > std::numeric_limits<int64_t>::max() + num1));\n-    if (!invalid)\n-    {\n+    if (!invalid) {\n         BOOST_CHECK(verify(bignum2 - bignum1, scriptnum2 - scriptnum1));\n         BOOST_CHECK(verify(bignum2 - bignum1, scriptnum2 - num1));\n     }\n@@ -110,32 +107,32 @@ static void CheckCompare(const int64_t& num1, const int64_t& num2)\n     const CScriptNum scriptnum2(num2);\n \n     BOOST_CHECK((bignum1 == bignum1) == (scriptnum1 == scriptnum1));\n-    BOOST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != scriptnum1));\n-    BOOST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < scriptnum1));\n-    BOOST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > scriptnum1));\n-    BOOST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= scriptnum1));\n-    BOOST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= scriptnum1));\n+    BOOST_CHECK((bignum1 != bignum1) == (scriptnum1 != scriptnum1));\n+    BOOST_CHECK((bignum1 < bignum1) == (scriptnum1 < scriptnum1));\n+    BOOST_CHECK((bignum1 > bignum1) == (scriptnum1 > scriptnum1));\n+    BOOST_CHECK((bignum1 >= bignum1) == (scriptnum1 >= scriptnum1));\n+    BOOST_CHECK((bignum1 <= bignum1) == (scriptnum1 <= scriptnum1));\n \n     BOOST_CHECK((bignum1 == bignum1) == (scriptnum1 == num1));\n-    BOOST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != num1));\n-    BOOST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < num1));\n-    BOOST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > num1));\n-    BOOST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= num1));\n-    BOOST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= num1));\n-\n-    BOOST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == scriptnum2));\n-    BOOST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != scriptnum2));\n-    BOOST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < scriptnum2));\n-    BOOST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > scriptnum2));\n-    BOOST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= scriptnum2));\n-    BOOST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= scriptnum2));\n-\n-    BOOST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == num2));\n-    BOOST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != num2));\n-    BOOST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < num2));\n-    BOOST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > num2));\n-    BOOST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= num2));\n-    BOOST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= num2));\n+    BOOST_CHECK((bignum1 != bignum1) == (scriptnum1 != num1));\n+    BOOST_CHECK((bignum1 < bignum1) == (scriptnum1 < num1));\n+    BOOST_CHECK((bignum1 > bignum1) == (scriptnum1 > num1));\n+    BOOST_CHECK((bignum1 >= bignum1) == (scriptnum1 >= num1));\n+    BOOST_CHECK((bignum1 <= bignum1) == (scriptnum1 <= num1));\n+\n+    BOOST_CHECK((bignum1 == bignum2) == (scriptnum1 == scriptnum2));\n+    BOOST_CHECK((bignum1 != bignum2) == (scriptnum1 != scriptnum2));\n+    BOOST_CHECK((bignum1 < bignum2) == (scriptnum1 < scriptnum2));\n+    BOOST_CHECK((bignum1 > bignum2) == (scriptnum1 > scriptnum2));\n+    BOOST_CHECK((bignum1 >= bignum2) == (scriptnum1 >= scriptnum2));\n+    BOOST_CHECK((bignum1 <= bignum2) == (scriptnum1 <= scriptnum2));\n+\n+    BOOST_CHECK((bignum1 == bignum2) == (scriptnum1 == num2));\n+    BOOST_CHECK((bignum1 != bignum2) == (scriptnum1 != num2));\n+    BOOST_CHECK((bignum1 < bignum2) == (scriptnum1 < num2));\n+    BOOST_CHECK((bignum1 > bignum2) == (scriptnum1 > num2));\n+    BOOST_CHECK((bignum1 >= bignum2) == (scriptnum1 >= num2));\n+    BOOST_CHECK((bignum1 <= bignum2) == (scriptnum1 <= num2));\n }\n \n static void RunCreate(const int64_t& num)\n@@ -144,9 +141,8 @@ static void RunCreate(const int64_t& num)\n     CScriptNum scriptnum(num);\n     if (scriptnum.getvch().size() <= CScriptNum::nMaxNumSize)\n         CheckCreateVch(num);\n-    else\n-    {\n-        BOOST_CHECK_THROW (CheckCreateVch(num), scriptnum_error);\n+    else {\n+        BOOST_CHECK_THROW(CheckCreateVch(num), scriptnum_error);\n     }\n }\n \n@@ -160,10 +156,8 @@ static void RunOperators(const int64_t& num1, const int64_t& num2)\n \n BOOST_AUTO_TEST_CASE(creation)\n {\n-    for(size_t i = 0; i < sizeof(values) / sizeof(values[0]); ++i)\n-    {\n-        for(size_t j = 0; j < sizeof(offsets) / sizeof(offsets[0]); ++j)\n-        {\n+    for (size_t i = 0; i < sizeof(values) / sizeof(values[0]); ++i) {\n+        for (size_t j = 0; j < sizeof(offsets) / sizeof(offsets[0]); ++j) {\n             RunCreate(values[i]);\n             RunCreate(values[i] + offsets[j]);\n             RunCreate(values[i] - offsets[j]);\n@@ -173,10 +167,8 @@ BOOST_AUTO_TEST_CASE(creation)\n \n BOOST_AUTO_TEST_CASE(operators)\n {\n-    for(size_t i = 0; i < sizeof(values) / sizeof(values[0]); ++i)\n-    {\n-        for(size_t j = 0; j < sizeof(offsets) / sizeof(offsets[0]); ++j)\n-        {\n+    for (size_t i = 0; i < sizeof(values) / sizeof(values[0]); ++i) {\n+        for (size_t j = 0; j < sizeof(offsets) / sizeof(offsets[0]); ++j) {\n             RunOperators(values[i], values[i]);\n             RunOperators(values[i], -values[i]);\n             RunOperators(values[i], values[j]);"
      },
      {
        "sha": "d5a3c8651a311dda2d36568dbebec6499a78eafb",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 13,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -25,7 +25,7 @@ BOOST_AUTO_TEST_CASE(varints)\n         BOOST_CHECK(size == ss.size());\n     }\n \n-    for (uint64_t i = 0;  i < 100000000000ULL; i += 999999937) {\n+    for (uint64_t i = 0; i < 100000000000ULL; i += 999999937) {\n         ss << VARINT(i);\n         size += ::GetSerializeSize(VARINT(i), 0, 0);\n         BOOST_CHECK(size == ss.size());\n@@ -38,7 +38,7 @@ BOOST_AUTO_TEST_CASE(varints)\n         BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n     }\n \n-    for (uint64_t i = 0;  i < 100000000000ULL; i += 999999937) {\n+    for (uint64_t i = 0; i < 100000000000ULL; i += 999999937) {\n         uint64_t j = -1;\n         ss >> VARINT(j);\n         BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n@@ -50,15 +50,13 @@ BOOST_AUTO_TEST_CASE(compactsize)\n     CDataStream ss(SER_DISK, 0);\n     vector<char>::size_type i, j;\n \n-    for (i = 1; i <= MAX_SIZE; i *= 2)\n-    {\n-        WriteCompactSize(ss, i-1);\n+    for (i = 1; i <= MAX_SIZE; i *= 2) {\n+        WriteCompactSize(ss, i - 1);\n         WriteCompactSize(ss, i);\n     }\n-    for (i = 1; i <= MAX_SIZE; i *= 2)\n-    {\n+    for (i = 1; i <= MAX_SIZE; i *= 2) {\n         j = ReadCompactSize(ss);\n-        BOOST_CHECK_MESSAGE((i-1) == j, \"decoded:\" << j << \" expected:\" << (i-1));\n+        BOOST_CHECK_MESSAGE((i - 1) == j, \"decoded:\" << j << \" expected:\" << (i - 1));\n         j = ReadCompactSize(ss);\n         BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n     }\n@@ -70,8 +68,8 @@ static bool isCanonicalException(const std::ios_base::failure& ex)\n \n     // The string returned by what() can be different for different platforms.\n     // Instead of directly comparing the ex.what() with an expected string,\n-    // create an instance of exception to see if ex.what() matches \n-    // the expected explanatory string returned by the exception instance. \n+    // create an instance of exception to see if ex.what() matches\n+    // the expected explanatory string returned by the exception instance.\n     return strcmp(expectedException.what(), ex.what()) == 0;\n }\n \n@@ -135,7 +133,7 @@ BOOST_AUTO_TEST_CASE(insert_delete)\n     BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n     BOOST_CHECK_EQUAL(ss[5], c);\n \n-    ss.insert(ss.begin()+2, c);\n+    ss.insert(ss.begin() + 2, c);\n     BOOST_CHECK_EQUAL(ss.size(), 7);\n     BOOST_CHECK_EQUAL(ss[2], c);\n \n@@ -144,11 +142,11 @@ BOOST_AUTO_TEST_CASE(insert_delete)\n     BOOST_CHECK_EQUAL(ss.size(), 6);\n     BOOST_CHECK_EQUAL(ss[0], 0);\n \n-    ss.erase(ss.begin()+ss.size()-1);\n+    ss.erase(ss.begin() + ss.size() - 1);\n     BOOST_CHECK_EQUAL(ss.size(), 5);\n     BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n \n-    ss.erase(ss.begin()+1);\n+    ss.erase(ss.begin() + 1);\n     BOOST_CHECK_EQUAL(ss.size(), 4);\n     BOOST_CHECK_EQUAL(ss[0], 0);\n     BOOST_CHECK_EQUAL(ss[1], 1);"
      },
      {
        "sha": "3a5ef06ed85725a5abc5e7969a89edb438bae02e",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 52,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -24,8 +24,7 @@ extern Array read_json(const std::string& jsondata);\n // Old script.cpp SignatureHash function\n uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n-    if (nIn >= txTo.vin.size())\n-    {\n+    if (nIn >= txTo.vin.size()) {\n         printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n         return 1;\n     }\n@@ -41,26 +40,22 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     txTmp.vin[nIn].scriptSig = scriptCode;\n \n     // Blank out some of the outputs\n-    if ((nHashType & 0x1f) == SIGHASH_NONE)\n-    {\n+    if ((nHashType & 0x1f) == SIGHASH_NONE) {\n         // Wildcard payee\n         txTmp.vout.clear();\n \n         // Let the others update at will\n         for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n             if (i != nIn)\n                 txTmp.vin[i].nSequence = 0;\n-    }\n-    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n-    {\n+    } else if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n         // Only lock-in the txout payee at same index as txin\n         unsigned int nOut = nIn;\n-        if (nOut >= txTmp.vout.size())\n-        {\n+        if (nOut >= txTmp.vout.size()) {\n             printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n             return 1;\n         }\n-        txTmp.vout.resize(nOut+1);\n+        txTmp.vout.resize(nOut + 1);\n         for (unsigned int i = 0; i < nOut; i++)\n             txTmp.vout[i].SetNull();\n \n@@ -71,8 +66,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     }\n \n     // Blank out other inputs completely, not recommended for open transactions\n-    if (nHashType & SIGHASH_ANYONECANPAY)\n-    {\n+    if (nHashType & SIGHASH_ANYONECANPAY) {\n         txTmp.vin[0] = txTmp.vin[nIn];\n         txTmp.vin.resize(1);\n     }\n@@ -83,15 +77,17 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     return ss.GetHash();\n }\n \n-void static RandomScript(CScript &script) {\n+void static RandomScript(CScript& script)\n+{\n     static const opcodetype oplist[] = {OP_FALSE, OP_1, OP_2, OP_3, OP_CHECKSIG, OP_IF, OP_VERIF, OP_RETURN, OP_CODESEPARATOR};\n     script = CScript();\n     int ops = (insecure_rand() % 10);\n-    for (int i=0; i<ops; i++)\n-        script << oplist[insecure_rand() % (sizeof(oplist)/sizeof(oplist[0]))];\n+    for (int i = 0; i < ops; i++)\n+        script << oplist[insecure_rand() % (sizeof(oplist) / sizeof(oplist[0]))];\n }\n \n-void static RandomTransaction(CMutableTransaction &tx, bool fSingle) {\n+void static RandomTransaction(CMutableTransaction& tx, bool fSingle)\n+{\n     tx.nVersion = insecure_rand();\n     tx.vin.clear();\n     tx.vout.clear();\n@@ -100,15 +96,15 @@ void static RandomTransaction(CMutableTransaction &tx, bool fSingle) {\n     int outs = fSingle ? ins : (insecure_rand() % 4) + 1;\n     for (int in = 0; in < ins; in++) {\n         tx.vin.push_back(CTxIn());\n-        CTxIn &txin = tx.vin.back();\n+        CTxIn& txin = tx.vin.back();\n         txin.prevout.hash = GetRandHash();\n         txin.prevout.n = insecure_rand() % 4;\n         RandomScript(txin.scriptSig);\n         txin.nSequence = (insecure_rand() % 2) ? insecure_rand() : (unsigned int)-1;\n     }\n     for (int out = 0; out < outs; out++) {\n         tx.vout.push_back(CTxOut());\n-        CTxOut &txout = tx.vout.back();\n+        CTxOut& txout = tx.vout.back();\n         txout.nValue = insecure_rand() % 100000000;\n         RandomScript(txout.scriptPubKey);\n     }\n@@ -120,16 +116,16 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n {\n     seed_insecure_rand(false);\n \n-    #if defined(PRINT_SIGHASH_JSON)\n+#if defined(PRINT_SIGHASH_JSON)\n     std::cout << \"[\\n\";\n     std::cout << \"\\t[\\\"raw_transaction, script, input_index, hashType, signature_hash (result)\\\"],\\n\";\n-    #endif\n+#endif\n     int nRandomTests = 50000;\n \n-    #if defined(PRINT_SIGHASH_JSON)\n+#if defined(PRINT_SIGHASH_JSON)\n     nRandomTests = 500;\n-    #endif\n-    for (int i=0; i<nRandomTests; i++) {\n+#endif\n+    for (int i = 0; i < nRandomTests; i++) {\n         int nHashType = insecure_rand();\n         CMutableTransaction txTo;\n         RandomTransaction(txTo, (nHashType & 0x1f) == SIGHASH_SINGLE);\n@@ -140,43 +136,43 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n         sh = SignatureHash(scriptCode, txTo, nIn, nHashType);\n-        #if defined(PRINT_SIGHASH_JSON)\n+#if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n \n-        std::cout << \"\\t[\\\"\" ;\n+        std::cout << \"\\t[\\\"\";\n         std::cout << HexStr(ss.begin(), ss.end()) << \"\\\", \\\"\";\n         std::cout << HexStr(scriptCode) << \"\\\", \";\n         std::cout << nIn << \", \";\n         std::cout << nHashType << \", \\\"\";\n         std::cout << sho.GetHex() << \"\\\"]\";\n-        if (i+1 != nRandomTests) {\n-          std::cout << \",\";\n+        if (i + 1 != nRandomTests) {\n+            std::cout << \",\";\n         }\n         std::cout << \"\\n\";\n-        #endif\n+#endif\n         BOOST_CHECK(sh == sho);\n     }\n-    #if defined(PRINT_SIGHASH_JSON)\n+#if defined(PRINT_SIGHASH_JSON)\n     std::cout << \"]\\n\";\n-    #endif\n+#endif\n }\n \n // Goal: check that SignatureHash generates correct hash\n BOOST_AUTO_TEST_CASE(sighash_from_data)\n {\n     Array tests = read_json(std::string(json_tests::sighash, json_tests::sighash + sizeof(json_tests::sighash)));\n \n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         std::string strTest = write_string(tv, false);\n         if (test.size() < 1) // Allow for extra stuff (useful for comments)\n         {\n             BOOST_ERROR(\"Bad test: \" << strTest);\n             continue;\n         }\n-        if (test.size() == 1) continue; // comment\n+        if (test.size() == 1)\n+            continue; // comment\n \n         std::string raw_tx, raw_script, sigHashHex;\n         int nIn, nHashType;\n@@ -185,26 +181,26 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n         CScript scriptCode = CScript();\n \n         try {\n-          // deserialize test data\n-          raw_tx = test[0].get_str();\n-          raw_script = test[1].get_str();\n-          nIn = test[2].get_int();\n-          nHashType = test[3].get_int();\n-          sigHashHex = test[4].get_str();\n-\n-          uint256 sh;\n-          CDataStream stream(ParseHex(raw_tx), SER_NETWORK, PROTOCOL_VERSION);\n-          stream >> tx;\n-\n-          CValidationState state;\n-          BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n-          BOOST_CHECK(state.IsValid());\n-\n-          std::vector<unsigned char> raw = ParseHex(raw_script);\n-          scriptCode.insert(scriptCode.end(), raw.begin(), raw.end());\n+            // deserialize test data\n+            raw_tx = test[0].get_str();\n+            raw_script = test[1].get_str();\n+            nIn = test[2].get_int();\n+            nHashType = test[3].get_int();\n+            sigHashHex = test[4].get_str();\n+\n+            uint256 sh;\n+            CDataStream stream(ParseHex(raw_tx), SER_NETWORK, PROTOCOL_VERSION);\n+            stream >> tx;\n+\n+            CValidationState state;\n+            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n+            BOOST_CHECK(state.IsValid());\n+\n+            std::vector<unsigned char> raw = ParseHex(raw_script);\n+            scriptCode.insert(scriptCode.end(), raw.begin(), raw.end());\n         } catch (...) {\n-          BOOST_ERROR(\"Bad test, couldn't deserialize data: \" << strTest);\n-          continue;\n+            BOOST_ERROR(\"Bad test, couldn't deserialize data: \" << strTest);\n+            continue;\n         }\n \n         sh = SignatureHash(scriptCode, tx, nIn, nHashType);"
      },
      {
        "sha": "f9dfd0a4ad1eedb79eebade9e7c27ecdcc12b4a0",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -45,8 +45,7 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n     BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3U);\n \n     std::vector<CPubKey> keys;\n-    for (int i = 0; i < 3; i++)\n-    {\n+    for (int i = 0; i < 3; i++) {\n         CKey k;\n         k.MakeNewKey(true);\n         keys.push_back(k.GetPubKey());"
      },
      {
        "sha": "8b59cb6cc1ba3d364e4a00635b83fb27c6842ae5",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -18,13 +18,13 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n {\n     std::vector<CBlockIndex> vIndex(SKIPLIST_LENGTH);\n \n-    for (int i=0; i<SKIPLIST_LENGTH; i++) {\n+    for (int i = 0; i < SKIPLIST_LENGTH; i++) {\n         vIndex[i].nHeight = i;\n         vIndex[i].pprev = (i == 0) ? NULL : &vIndex[i - 1];\n         vIndex[i].BuildSkip();\n     }\n \n-    for (int i=0; i<SKIPLIST_LENGTH; i++) {\n+    for (int i = 0; i < SKIPLIST_LENGTH; i++) {\n         if (i > 0) {\n             BOOST_CHECK(vIndex[i].pskip == &vIndex[vIndex[i].pskip->nHeight]);\n             BOOST_CHECK(vIndex[i].pskip->nHeight < i);\n@@ -33,7 +33,7 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n         }\n     }\n \n-    for (int i=0; i < 1000; i++) {\n+    for (int i = 0; i < 1000; i++) {\n         int from = insecure_rand() % (SKIPLIST_LENGTH - 1);\n         int to = insecure_rand() % (from + 1);\n \n@@ -48,7 +48,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n     // Build a main chain 100000 blocks long.\n     std::vector<uint256> vHashMain(100000);\n     std::vector<CBlockIndex> vBlocksMain(100000);\n-    for (unsigned int i=0; i<vBlocksMain.size(); i++) {\n+    for (unsigned int i = 0; i < vBlocksMain.size(); i++) {\n         vHashMain[i] = i; // Set the hash equal to the height, so we can quickly check the distances.\n         vBlocksMain[i].nHeight = i;\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : NULL;\n@@ -61,7 +61,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n     // Build a branch that splits off at block 49999, 50000 blocks long.\n     std::vector<uint256> vHashSide(50000);\n     std::vector<CBlockIndex> vBlocksSide(50000);\n-    for (unsigned int i=0; i<vBlocksSide.size(); i++) {\n+    for (unsigned int i = 0; i < vBlocksSide.size(); i++) {\n         vHashSide[i] = i + 50000 + (uint256(1) << 128); // Add 1<<128 to the hashes, so GetLow64() still returns the height.\n         vBlocksSide[i].nHeight = i + 50000;\n         vBlocksSide[i].pprev = i ? &vBlocksSide[i - 1] : &vBlocksMain[49999];\n@@ -76,7 +76,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n     chain.SetTip(&vBlocksMain.back());\n \n     // Test 100 random starting points for locators.\n-    for (int n=0; n<100; n++) {\n+    for (int n = 0; n < 100; n++) {\n         int r = insecure_rand() % 150000;\n         CBlockIndex* tip = (r < 100000) ? &vBlocksMain[r] : &vBlocksSide[r - 100000];\n         CBlockLocator locator = chain.GetLocator(tip);"
      },
      {
        "sha": "438cfbf23c2bea3aa4338e21e1aef2d70cfd0af8",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -24,12 +24,14 @@ CWallet* pwalletMain;\n extern bool fPrintToConsole;\n extern void noui_connect();\n \n-struct TestingSetup {\n-    CCoinsViewDB *pcoinsdbview;\n+struct TestingSetup\n+{\n+    CCoinsViewDB* pcoinsdbview;\n     boost::filesystem::path pathTemp;\n     boost::thread_group threadGroup;\n \n-    TestingSetup() {\n+    TestingSetup()\n+    {\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         SelectParams(CBaseChainParams::UNITTEST);\n         noui_connect();\n@@ -50,7 +52,7 @@ struct TestingSetup {\n         RegisterValidationInterface(pwalletMain);\n #endif\n         nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n+        for (int i = 0; i < nScriptCheckThreads - 1; i++)\n             threadGroup.create_thread(&ThreadScriptCheck);\n         RegisterNodeSignals(GetNodeSignals());\n     }\n@@ -77,15 +79,15 @@ BOOST_GLOBAL_FIXTURE(TestingSetup);\n \n void Shutdown(void* parg)\n {\n-  exit(0);\n+    exit(0);\n }\n \n void StartShutdown()\n {\n-  exit(0);\n+    exit(0);\n }\n \n bool ShutdownRequested()\n {\n-  return false;\n+    return false;\n }"
      },
      {
        "sha": "98003a38cefd091654170586001d588e78812215",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 62,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -29,16 +29,7 @@ using namespace boost::algorithm;\n // In script_tests.cpp\n extern Array read_json(const std::string& jsondata);\n \n-static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n-    (string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n-    (string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n-    (string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n-    (string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n-    (string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n-    (string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n-    (string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n-    (string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n-    (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n+static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of(string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)(string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)(string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)(string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)(string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)(string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)(string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)(string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)(string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n \n unsigned int ParseScriptFlags(string strFlags)\n {\n@@ -49,8 +40,7 @@ unsigned int ParseScriptFlags(string strFlags)\n     vector<string> words;\n     split(words, strFlags, is_any_of(\",\"));\n \n-    BOOST_FOREACH(string word, words)\n-    {\n+    BOOST_FOREACH (string word, words) {\n         if (!mapFlagNames.count(word))\n             BOOST_ERROR(\"Bad test: unknown verification flag '\" << word << \"'\");\n         flags |= mapFlagNames[word];\n@@ -89,39 +79,32 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n     Array tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n \n     ScriptError err;\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         string strTest = write_string(tv, false);\n-        if (test[0].type() == array_type)\n-        {\n-            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type)\n-            {\n+        if (test[0].type() == array_type) {\n+            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type) {\n                 BOOST_ERROR(\"Bad test: \" << strTest);\n                 continue;\n             }\n \n             map<COutPoint, CScript> mapprevOutScriptPubKeys;\n             Array inputs = test[0].get_array();\n             bool fValid = true;\n-            BOOST_FOREACH(Value& input, inputs)\n-            {\n-                if (input.type() != array_type)\n-                {\n+            BOOST_FOREACH (Value& input, inputs) {\n+                if (input.type() != array_type) {\n                     fValid = false;\n                     break;\n                 }\n                 Array vinput = input.get_array();\n-                if (vinput.size() != 3)\n-                {\n+                if (vinput.size() != 3) {\n                     fValid = false;\n                     break;\n                 }\n \n                 mapprevOutScriptPubKeys[COutPoint(uint256(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n             }\n-            if (!fValid)\n-            {\n+            if (!fValid) {\n                 BOOST_ERROR(\"Bad test: \" << strTest);\n                 continue;\n             }\n@@ -135,17 +118,14 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n             BOOST_CHECK(state.IsValid());\n \n-            for (unsigned int i = 0; i < tx.vin.size(); i++)\n-            {\n-                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n-                {\n+            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout)) {\n                     BOOST_ERROR(\"Bad test: \" << strTest);\n                     break;\n                 }\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n-                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 verify_flags, SignatureChecker(tx, i), &err),\n+                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], verify_flags, SignatureChecker(tx, i), &err),\n                                     strTest);\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n@@ -165,39 +145,32 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n     Array tests = read_json(std::string(json_tests::tx_invalid, json_tests::tx_invalid + sizeof(json_tests::tx_invalid)));\n \n     ScriptError err;\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n+    BOOST_FOREACH (Value& tv, tests) {\n         Array test = tv.get_array();\n         string strTest = write_string(tv, false);\n-        if (test[0].type() == array_type)\n-        {\n-            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type)\n-            {\n+        if (test[0].type() == array_type) {\n+            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type) {\n                 BOOST_ERROR(\"Bad test: \" << strTest);\n                 continue;\n             }\n \n             map<COutPoint, CScript> mapprevOutScriptPubKeys;\n             Array inputs = test[0].get_array();\n             bool fValid = true;\n-            BOOST_FOREACH(Value& input, inputs)\n-            {\n-                if (input.type() != array_type)\n-                {\n+            BOOST_FOREACH (Value& input, inputs) {\n+                if (input.type() != array_type) {\n                     fValid = false;\n                     break;\n                 }\n                 Array vinput = input.get_array();\n-                if (vinput.size() != 3)\n-                {\n+                if (vinput.size() != 3) {\n                     fValid = false;\n                     break;\n                 }\n \n                 mapprevOutScriptPubKeys[COutPoint(uint256(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n             }\n-            if (!fValid)\n-            {\n+            if (!fValid) {\n                 BOOST_ERROR(\"Bad test: \" << strTest);\n                 continue;\n             }\n@@ -210,17 +183,14 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             CValidationState state;\n             fValid = CheckTransaction(tx, state) && state.IsValid();\n \n-            for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n-            {\n-                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n-                {\n+            for (unsigned int i = 0; i < tx.vin.size() && fValid; i++) {\n+                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout)) {\n                     BOOST_ERROR(\"Bad test: \" << strTest);\n                     break;\n                 }\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n-                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      verify_flags, SignatureChecker(tx, i), &err);\n+                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], verify_flags, SignatureChecker(tx, i), &err);\n             }\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n             BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n@@ -232,7 +202,7 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n {\n     // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n     unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n-    vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n+    vector<unsigned char> vch(ch, ch + sizeof(ch) - 1);\n     CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n     CMutableTransaction tx;\n     stream >> tx;\n@@ -258,24 +228,23 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n \n     // Add some keys to the keystore:\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n+    for (int i = 0; i < 4; i++) {\n         key[i].MakeNewKey(i % 2);\n         keystoreRet.AddKey(key[i]);\n     }\n \n     // Create some dummy input transactions\n     dummyTransactions[0].vout.resize(2);\n-    dummyTransactions[0].vout[0].nValue = 11*CENT;\n+    dummyTransactions[0].vout[0].nValue = 11 * CENT;\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n-    dummyTransactions[0].vout[1].nValue = 50*CENT;\n+    dummyTransactions[0].vout[1].nValue = 50 * CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n     coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n-    dummyTransactions[1].vout[0].nValue = 21*CENT;\n+    dummyTransactions[1].vout[0].nValue = 21 * CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n-    dummyTransactions[1].vout[1].nValue = 22*CENT;\n+    dummyTransactions[1].vout[1].nValue = 22 * CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n     coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n \n@@ -301,11 +270,11 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vin[2].prevout.n = 1;\n     t1.vin[2].scriptSig << std::vector<unsigned char>(65, 0) << std::vector<unsigned char>(33, 4);\n     t1.vout.resize(2);\n-    t1.vout[0].nValue = 90*CENT;\n+    t1.vout[0].nValue = 90 * CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n     BOOST_CHECK(AreInputsStandard(t1, coins));\n-    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n+    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50 + 21 + 22) * CENT);\n \n     // Adding extra junk to the scriptSig should make it non-standard:\n     t1.vin[0].scriptSig << OP_11;\n@@ -330,7 +299,7 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     t.vin[0].prevout.n = 1;\n     t.vin[0].scriptSig << std::vector<unsigned char>(65, 0);\n     t.vout.resize(1);\n-    t.vout[0].nValue = 90*CENT;\n+    t.vout[0].nValue = 90 * CENT;\n     CKey key;\n     key.MakeNewKey(true);\n     t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());"
      },
      {
        "sha": "f6245768cb005038d44c57c57f7aa79fd35a4fa2",
        "filename": "src/test/uint256_tests.cpp",
        "status": "modified",
        "additions": 436,
        "deletions": 359,
        "changes": 795,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint256_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -13,476 +13,536 @@\n #include \"version.h\"\n \n BOOST_AUTO_TEST_SUITE(uint256_tests)\n- \n-const unsigned char R1Array[] = \n+\n+const unsigned char R1Array[] =\n     \"\\x9c\\x52\\x4a\\xdb\\xcf\\x56\\x11\\x12\\x2b\\x29\\x12\\x5e\\x5d\\x35\\xd2\\xd2\"\n     \"\\x22\\x81\\xaa\\xb5\\x33\\xf0\\x08\\x32\\xd5\\x56\\xb1\\xf9\\xea\\xe5\\x1d\\x7d\";\n const char R1ArrayHex[] = \"7D1DE5EAF9B156D53208F033B5AA8122D2d2355d5e12292b121156cfdb4a529c\";\n const double R1Ldouble = 0.4887374590559308955; // R1L equals roughly R1Ldouble * 2^256\n-const double R1Sdouble = 0.7096329412477836074; \n-const uint256 R1L = uint256(std::vector<unsigned char>(R1Array,R1Array+32));\n-const uint160 R1S = uint160(std::vector<unsigned char>(R1Array,R1Array+20));\n+const double R1Sdouble = 0.7096329412477836074;\n+const uint256 R1L = uint256(std::vector<unsigned char>(R1Array, R1Array + 32));\n+const uint160 R1S = uint160(std::vector<unsigned char>(R1Array, R1Array + 20));\n const uint64_t R1LLow64 = 0x121156cfdb4a529cULL;\n \n-const unsigned char R2Array[] = \n+const unsigned char R2Array[] =\n     \"\\x70\\x32\\x1d\\x7c\\x47\\xa5\\x6b\\x40\\x26\\x7e\\x0a\\xc3\\xa6\\x9c\\xb6\\xbf\"\n     \"\\x13\\x30\\x47\\xa3\\x19\\x2d\\xda\\x71\\x49\\x13\\x72\\xf0\\xb4\\xca\\x81\\xd7\";\n-const uint256 R2L = uint256(std::vector<unsigned char>(R2Array,R2Array+32));\n-const uint160 R2S = uint160(std::vector<unsigned char>(R2Array,R2Array+20));\n+const uint256 R2L = uint256(std::vector<unsigned char>(R2Array, R2Array + 32));\n+const uint160 R2S = uint160(std::vector<unsigned char>(R2Array, R2Array + 20));\n \n const char R1LplusR2L[] = \"549FB09FEA236A1EA3E31D4D58F1B1369288D204211CA751527CFC175767850C\";\n \n-const unsigned char ZeroArray[] = \n+const unsigned char ZeroArray[] =\n     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n-const uint256 ZeroL = uint256(std::vector<unsigned char>(ZeroArray,ZeroArray+32));\n-const uint160 ZeroS = uint160(std::vector<unsigned char>(ZeroArray,ZeroArray+20));\n-                             \n-const unsigned char OneArray[] = \n+const uint256 ZeroL = uint256(std::vector<unsigned char>(ZeroArray, ZeroArray + 32));\n+const uint160 ZeroS = uint160(std::vector<unsigned char>(ZeroArray, ZeroArray + 20));\n+\n+const unsigned char OneArray[] =\n     \"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n-const uint256 OneL = uint256(std::vector<unsigned char>(OneArray,OneArray+32));\n-const uint160 OneS = uint160(std::vector<unsigned char>(OneArray,OneArray+20));\n+const uint256 OneL = uint256(std::vector<unsigned char>(OneArray, OneArray + 32));\n+const uint160 OneS = uint160(std::vector<unsigned char>(OneArray, OneArray + 20));\n \n-const unsigned char MaxArray[] = \n+const unsigned char MaxArray[] =\n     \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n     \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\";\n-const uint256 MaxL = uint256(std::vector<unsigned char>(MaxArray,MaxArray+32));\n-const uint160 MaxS = uint160(std::vector<unsigned char>(MaxArray,MaxArray+20));\n+const uint256 MaxL = uint256(std::vector<unsigned char>(MaxArray, MaxArray + 32));\n+const uint160 MaxS = uint160(std::vector<unsigned char>(MaxArray, MaxArray + 20));\n \n const uint256 HalfL = (OneL << 255);\n const uint160 HalfS = (OneS << 159);\n std::string ArrayToString(const unsigned char A[], unsigned int width)\n {\n     std::stringstream Stream;\n     Stream << std::hex;\n-    for (unsigned int i = 0; i < width; ++i) \n-    {\n-        Stream<<std::setw(2)<<std::setfill('0')<<(unsigned int)A[width-i-1];\n-    }       \n+    for (unsigned int i = 0; i < width; ++i) {\n+        Stream << std::setw(2) << std::setfill('0') << (unsigned int)A[width - i - 1];\n+    }\n     return Stream.str();\n }\n \n-BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n+BOOST_AUTO_TEST_CASE(basics) // constructors, equality, inequality\n {\n-    BOOST_CHECK(1 == 0+1);\n+    BOOST_CHECK(1 == 0 + 1);\n     // constructor uint256(vector<char>):\n-    BOOST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n-    BOOST_CHECK(R1S.ToString() == ArrayToString(R1Array,20));\n-    BOOST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n-    BOOST_CHECK(R2S.ToString() == ArrayToString(R2Array,20));\n-    BOOST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n-    BOOST_CHECK(ZeroS.ToString() == ArrayToString(ZeroArray,20));\n-    BOOST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n-    BOOST_CHECK(OneS.ToString() == ArrayToString(OneArray,20));\n-    BOOST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n-    BOOST_CHECK(MaxS.ToString() == ArrayToString(MaxArray,20));\n-    BOOST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n-    BOOST_CHECK(OneS.ToString() != ArrayToString(ZeroArray,20));\n+    BOOST_CHECK(R1L.ToString() == ArrayToString(R1Array, 32));\n+    BOOST_CHECK(R1S.ToString() == ArrayToString(R1Array, 20));\n+    BOOST_CHECK(R2L.ToString() == ArrayToString(R2Array, 32));\n+    BOOST_CHECK(R2S.ToString() == ArrayToString(R2Array, 20));\n+    BOOST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray, 32));\n+    BOOST_CHECK(ZeroS.ToString() == ArrayToString(ZeroArray, 20));\n+    BOOST_CHECK(OneL.ToString() == ArrayToString(OneArray, 32));\n+    BOOST_CHECK(OneS.ToString() == ArrayToString(OneArray, 20));\n+    BOOST_CHECK(MaxL.ToString() == ArrayToString(MaxArray, 32));\n+    BOOST_CHECK(MaxS.ToString() == ArrayToString(MaxArray, 20));\n+    BOOST_CHECK(OneL.ToString() != ArrayToString(ZeroArray, 32));\n+    BOOST_CHECK(OneS.ToString() != ArrayToString(ZeroArray, 20));\n \n     // == and !=\n     BOOST_CHECK(R1L != R2L && R1S != R2S);\n     BOOST_CHECK(ZeroL != OneL && ZeroS != OneS);\n     BOOST_CHECK(OneL != ZeroL && OneS != ZeroS);\n     BOOST_CHECK(MaxL != ZeroL && MaxS != ZeroS);\n     BOOST_CHECK(~MaxL == ZeroL && ~MaxS == ZeroS);\n-    BOOST_CHECK( ((R1L ^ R2L) ^ R1L) == R2L);\n-    BOOST_CHECK( ((R1S ^ R2S) ^ R1S) == R2S);\n-    \n+    BOOST_CHECK(((R1L ^ R2L) ^ R1L) == R2L);\n+    BOOST_CHECK(((R1S ^ R2S) ^ R1S) == R2S);\n+\n     uint64_t Tmp64 = 0xc4dab720d9c7acaaULL;\n-    for (unsigned int i = 0; i < 256; ++i) \n-    {\n-        BOOST_CHECK(ZeroL != (OneL << i)); \n-        BOOST_CHECK((OneL << i) != ZeroL); \n+    for (unsigned int i = 0; i < 256; ++i) {\n+        BOOST_CHECK(ZeroL != (OneL << i));\n+        BOOST_CHECK((OneL << i) != ZeroL);\n         BOOST_CHECK(R1L != (R1L ^ (OneL << i)));\n-        BOOST_CHECK(((uint256(Tmp64) ^ (OneL << i) ) != Tmp64 ));\n+        BOOST_CHECK(((uint256(Tmp64) ^ (OneL << i)) != Tmp64));\n     }\n-    BOOST_CHECK(ZeroL == (OneL << 256)); \n+    BOOST_CHECK(ZeroL == (OneL << 256));\n \n-    for (unsigned int i = 0; i < 160; ++i) \n-    {\n-        BOOST_CHECK(ZeroS != (OneS << i)); \n-        BOOST_CHECK((OneS << i) != ZeroS); \n+    for (unsigned int i = 0; i < 160; ++i) {\n+        BOOST_CHECK(ZeroS != (OneS << i));\n+        BOOST_CHECK((OneS << i) != ZeroS);\n         BOOST_CHECK(R1S != (R1S ^ (OneS << i)));\n-        BOOST_CHECK(((uint160(Tmp64) ^ (OneS << i) ) != Tmp64 ));\n+        BOOST_CHECK(((uint160(Tmp64) ^ (OneS << i)) != Tmp64));\n     }\n-    BOOST_CHECK(ZeroS == (OneS << 256)); \n+    BOOST_CHECK(ZeroS == (OneS << 256));\n \n     // String Constructor and Copy Constructor\n-    BOOST_CHECK(uint256(\"0x\"+R1L.ToString()) == R1L);\n-    BOOST_CHECK(uint256(\"0x\"+R2L.ToString()) == R2L);\n-    BOOST_CHECK(uint256(\"0x\"+ZeroL.ToString()) == ZeroL);\n-    BOOST_CHECK(uint256(\"0x\"+OneL.ToString()) == OneL);\n-    BOOST_CHECK(uint256(\"0x\"+MaxL.ToString()) == MaxL);\n+    BOOST_CHECK(uint256(\"0x\" + R1L.ToString()) == R1L);\n+    BOOST_CHECK(uint256(\"0x\" + R2L.ToString()) == R2L);\n+    BOOST_CHECK(uint256(\"0x\" + ZeroL.ToString()) == ZeroL);\n+    BOOST_CHECK(uint256(\"0x\" + OneL.ToString()) == OneL);\n+    BOOST_CHECK(uint256(\"0x\" + MaxL.ToString()) == MaxL);\n     BOOST_CHECK(uint256(R1L.ToString()) == R1L);\n-    BOOST_CHECK(uint256(\"   0x\"+R1L.ToString()+\"   \") == R1L);\n+    BOOST_CHECK(uint256(\"   0x\" + R1L.ToString() + \"   \") == R1L);\n     BOOST_CHECK(uint256(\"\") == ZeroL);\n     BOOST_CHECK(R1L == uint256(R1ArrayHex));\n     BOOST_CHECK(uint256(R1L) == R1L);\n-    BOOST_CHECK((uint256(R1L^R2L)^R2L) == R1L);\n+    BOOST_CHECK((uint256(R1L ^ R2L) ^ R2L) == R1L);\n     BOOST_CHECK(uint256(ZeroL) == ZeroL);\n     BOOST_CHECK(uint256(OneL) == OneL);\n \n-    BOOST_CHECK(uint160(\"0x\"+R1S.ToString()) == R1S);\n-    BOOST_CHECK(uint160(\"0x\"+R2S.ToString()) == R2S);\n-    BOOST_CHECK(uint160(\"0x\"+ZeroS.ToString()) == ZeroS);\n-    BOOST_CHECK(uint160(\"0x\"+OneS.ToString()) == OneS);\n-    BOOST_CHECK(uint160(\"0x\"+MaxS.ToString()) == MaxS);\n+    BOOST_CHECK(uint160(\"0x\" + R1S.ToString()) == R1S);\n+    BOOST_CHECK(uint160(\"0x\" + R2S.ToString()) == R2S);\n+    BOOST_CHECK(uint160(\"0x\" + ZeroS.ToString()) == ZeroS);\n+    BOOST_CHECK(uint160(\"0x\" + OneS.ToString()) == OneS);\n+    BOOST_CHECK(uint160(\"0x\" + MaxS.ToString()) == MaxS);\n     BOOST_CHECK(uint160(R1S.ToString()) == R1S);\n-    BOOST_CHECK(uint160(\"   0x\"+R1S.ToString()+\"   \") == R1S); \n+    BOOST_CHECK(uint160(\"   0x\" + R1S.ToString() + \"   \") == R1S);\n     BOOST_CHECK(uint160(\"\") == ZeroS);\n     BOOST_CHECK(R1S == uint160(R1ArrayHex));\n \n     BOOST_CHECK(uint160(R1S) == R1S);\n-    BOOST_CHECK((uint160(R1S^R2S)^R2S) == R1S);\n+    BOOST_CHECK((uint160(R1S ^ R2S) ^ R2S) == R1S);\n     BOOST_CHECK(uint160(ZeroS) == ZeroS);\n     BOOST_CHECK(uint160(OneS) == OneS);\n \n     // uint64_t constructor\n-    BOOST_CHECK( (R1L & uint256(\"0xffffffffffffffff\")) == uint256(R1LLow64));\n+    BOOST_CHECK((R1L & uint256(\"0xffffffffffffffff\")) == uint256(R1LLow64));\n     BOOST_CHECK(ZeroL == uint256(0));\n     BOOST_CHECK(OneL == uint256(1));\n     BOOST_CHECK(uint256(\"0xffffffffffffffff\") = uint256(0xffffffffffffffffULL));\n-    BOOST_CHECK( (R1S & uint160(\"0xffffffffffffffff\")) == uint160(R1LLow64));\n+    BOOST_CHECK((R1S & uint160(\"0xffffffffffffffff\")) == uint160(R1LLow64));\n     BOOST_CHECK(ZeroS == uint160(0));\n     BOOST_CHECK(OneS == uint160(1));\n     BOOST_CHECK(uint160(\"0xffffffffffffffff\") = uint160(0xffffffffffffffffULL));\n \n     // Assignment (from base_uint)\n-    uint256 tmpL = ~ZeroL; BOOST_CHECK(tmpL == ~ZeroL);\n-    tmpL = ~OneL; BOOST_CHECK(tmpL == ~OneL);\n-    tmpL = ~R1L; BOOST_CHECK(tmpL == ~R1L);\n-    tmpL = ~R2L; BOOST_CHECK(tmpL == ~R2L);\n-    tmpL = ~MaxL; BOOST_CHECK(tmpL == ~MaxL);\n-    uint160 tmpS = ~ZeroS; BOOST_CHECK(tmpS == ~ZeroS);\n-    tmpS = ~OneS; BOOST_CHECK(tmpS == ~OneS);\n-    tmpS = ~R1S; BOOST_CHECK(tmpS == ~R1S);\n-    tmpS = ~R2S; BOOST_CHECK(tmpS == ~R2S);\n-    tmpS = ~MaxS; BOOST_CHECK(tmpS == ~MaxS);\n+    uint256 tmpL = ~ZeroL;\n+    BOOST_CHECK(tmpL == ~ZeroL);\n+    tmpL = ~OneL;\n+    BOOST_CHECK(tmpL == ~OneL);\n+    tmpL = ~R1L;\n+    BOOST_CHECK(tmpL == ~R1L);\n+    tmpL = ~R2L;\n+    BOOST_CHECK(tmpL == ~R2L);\n+    tmpL = ~MaxL;\n+    BOOST_CHECK(tmpL == ~MaxL);\n+    uint160 tmpS = ~ZeroS;\n+    BOOST_CHECK(tmpS == ~ZeroS);\n+    tmpS = ~OneS;\n+    BOOST_CHECK(tmpS == ~OneS);\n+    tmpS = ~R1S;\n+    BOOST_CHECK(tmpS == ~R1S);\n+    tmpS = ~R2S;\n+    BOOST_CHECK(tmpS == ~R2S);\n+    tmpS = ~MaxS;\n+    BOOST_CHECK(tmpS == ~MaxS);\n \n     // Wrong length must throw exception.\n-    BOOST_CHECK_THROW(uint256(std::vector<unsigned char>(OneArray,OneArray+31)), uint_error);\n-    BOOST_CHECK_THROW(uint256(std::vector<unsigned char>(OneArray,OneArray+20)), uint_error);\n-    BOOST_CHECK_THROW(uint160(std::vector<unsigned char>(OneArray,OneArray+32)), uint_error);\n-    BOOST_CHECK_THROW(uint160(std::vector<unsigned char>(OneArray,OneArray+19)), uint_error);\n+    BOOST_CHECK_THROW(uint256(std::vector<unsigned char>(OneArray, OneArray + 31)), uint_error);\n+    BOOST_CHECK_THROW(uint256(std::vector<unsigned char>(OneArray, OneArray + 20)), uint_error);\n+    BOOST_CHECK_THROW(uint160(std::vector<unsigned char>(OneArray, OneArray + 32)), uint_error);\n+    BOOST_CHECK_THROW(uint160(std::vector<unsigned char>(OneArray, OneArray + 19)), uint_error);\n }\n \n-void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift) \n+void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n {\n-    for (unsigned int T=0; T < arrayLength; ++T) \n-    {\n-        unsigned int F = (T+bitsToShift/8);\n-        if (F < arrayLength) \n-            to[T]  = from[F] >> (bitsToShift%8);\n+    for (unsigned int T = 0; T < arrayLength; ++T) {\n+        unsigned int F = (T + bitsToShift / 8);\n+        if (F < arrayLength)\n+            to[T] = from[F] >> (bitsToShift % 8);\n         else\n             to[T] = 0;\n-        if (F + 1 < arrayLength) \n-            to[T] |= from[(F+1)] << (8-bitsToShift%8);\n+        if (F + 1 < arrayLength)\n+            to[T] |= from[(F + 1)] << (8 - bitsToShift % 8);\n     }\n }\n \n-void shiftArrayLeft(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift) \n+void shiftArrayLeft(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n {\n-    for (unsigned int T=0; T < arrayLength; ++T) \n-    {\n-        if (T >= bitsToShift/8) \n-        {\n-            unsigned int F = T-bitsToShift/8;\n-            to[T]  = from[F] << (bitsToShift%8);\n-            if (T >= bitsToShift/8+1)\n-                to[T] |= from[F-1] >> (8-bitsToShift%8);\n-        }\n-        else {\n+    for (unsigned int T = 0; T < arrayLength; ++T) {\n+        if (T >= bitsToShift / 8) {\n+            unsigned int F = T - bitsToShift / 8;\n+            to[T] = from[F] << (bitsToShift % 8);\n+            if (T >= bitsToShift / 8 + 1)\n+                to[T] |= from[F - 1] >> (8 - bitsToShift % 8);\n+        } else {\n             to[T] = 0;\n         }\n     }\n }\n \n-BOOST_AUTO_TEST_CASE( shifts ) { // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n+BOOST_AUTO_TEST_CASE(shifts)\n+{ // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n     unsigned char TmpArray[32];\n     uint256 TmpL;\n-    for (unsigned int i = 0; i < 256; ++i)\n-    {\n+    for (unsigned int i = 0; i < 256; ++i) {\n         shiftArrayLeft(TmpArray, OneArray, 32, i);\n-        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (OneL << i));\n-        TmpL = OneL; TmpL <<= i;\n+        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (OneL << i));\n+        TmpL = OneL;\n+        TmpL <<= i;\n         BOOST_CHECK(TmpL == (OneL << i));\n-        BOOST_CHECK((HalfL >> (255-i)) == (OneL << i));\n-        TmpL = HalfL; TmpL >>= (255-i);\n+        BOOST_CHECK((HalfL >> (255 - i)) == (OneL << i));\n+        TmpL = HalfL;\n+        TmpL >>= (255 - i);\n         BOOST_CHECK(TmpL == (OneL << i));\n-                    \n+\n         shiftArrayLeft(TmpArray, R1Array, 32, i);\n-        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L << i));\n-        TmpL = R1L; TmpL <<= i;\n+        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (R1L << i));\n+        TmpL = R1L;\n+        TmpL <<= i;\n         BOOST_CHECK(TmpL == (R1L << i));\n \n         shiftArrayRight(TmpArray, R1Array, 32, i);\n-        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L >> i)); \n-        TmpL = R1L; TmpL >>= i;\n+        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (R1L >> i));\n+        TmpL = R1L;\n+        TmpL >>= i;\n         BOOST_CHECK(TmpL == (R1L >> i));\n \n         shiftArrayLeft(TmpArray, MaxArray, 32, i);\n-        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL << i));\n-        TmpL = MaxL; TmpL <<= i;\n+        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (MaxL << i));\n+        TmpL = MaxL;\n+        TmpL <<= i;\n         BOOST_CHECK(TmpL == (MaxL << i));\n \n         shiftArrayRight(TmpArray, MaxArray, 32, i);\n-        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL >> i));\n-        TmpL = MaxL; TmpL >>= i;\n+        BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (MaxL >> i));\n+        TmpL = MaxL;\n+        TmpL >>= i;\n         BOOST_CHECK(TmpL == (MaxL >> i));\n     }\n     uint256 c1L = uint256(0x0123456789abcdefULL);\n     uint256 c2L = c1L << 128;\n     for (unsigned int i = 0; i < 128; ++i) {\n-        BOOST_CHECK((c1L << i) == (c2L >> (128-i)));\n+        BOOST_CHECK((c1L << i) == (c2L >> (128 - i)));\n     }\n     for (unsigned int i = 128; i < 256; ++i) {\n-        BOOST_CHECK((c1L << i) == (c2L << (i-128)));\n+        BOOST_CHECK((c1L << i) == (c2L << (i - 128)));\n     }\n \n     uint160 TmpS;\n-    for (unsigned int i = 0; i < 160; ++i)\n-    {\n+    for (unsigned int i = 0; i < 160; ++i) {\n         shiftArrayLeft(TmpArray, OneArray, 20, i);\n-        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (OneS << i));\n-        TmpS = OneS; TmpS <<= i;\n+        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (OneS << i));\n+        TmpS = OneS;\n+        TmpS <<= i;\n         BOOST_CHECK(TmpS == (OneS << i));\n-        BOOST_CHECK((HalfS >> (159-i)) == (OneS << i));\n-        TmpS = HalfS; TmpS >>= (159-i);\n+        BOOST_CHECK((HalfS >> (159 - i)) == (OneS << i));\n+        TmpS = HalfS;\n+        TmpS >>= (159 - i);\n         BOOST_CHECK(TmpS == (OneS << i));\n-                    \n+\n         shiftArrayLeft(TmpArray, R1Array, 20, i);\n-        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (R1S << i));\n-        TmpS = R1S; TmpS <<= i;\n+        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (R1S << i));\n+        TmpS = R1S;\n+        TmpS <<= i;\n         BOOST_CHECK(TmpS == (R1S << i));\n \n         shiftArrayRight(TmpArray, R1Array, 20, i);\n-        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (R1S >> i)); \n-        TmpS = R1S; TmpS >>= i;\n+        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (R1S >> i));\n+        TmpS = R1S;\n+        TmpS >>= i;\n         BOOST_CHECK(TmpS == (R1S >> i));\n \n         shiftArrayLeft(TmpArray, MaxArray, 20, i);\n-        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (MaxS << i));\n-        TmpS = MaxS; TmpS <<= i;\n+        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (MaxS << i));\n+        TmpS = MaxS;\n+        TmpS <<= i;\n         BOOST_CHECK(TmpS == (MaxS << i));\n \n         shiftArrayRight(TmpArray, MaxArray, 20, i);\n-        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (MaxS >> i));\n-        TmpS = MaxS; TmpS >>= i;\n+        BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (MaxS >> i));\n+        TmpS = MaxS;\n+        TmpS >>= i;\n         BOOST_CHECK(TmpS == (MaxS >> i));\n     }\n     uint160 c1S = uint160(0x0123456789abcdefULL);\n     uint160 c2S = c1S << 80;\n     for (unsigned int i = 0; i < 80; ++i) {\n-        BOOST_CHECK((c1S << i) == (c2S >> (80-i)));\n+        BOOST_CHECK((c1S << i) == (c2S >> (80 - i)));\n     }\n     for (unsigned int i = 80; i < 160; ++i) {\n-        BOOST_CHECK((c1S << i) == (c2S << (i-80)));\n+        BOOST_CHECK((c1S << i) == (c2S << (i - 80)));\n     }\n }\n \n-BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n+BOOST_AUTO_TEST_CASE(unaryOperators) // !    ~    -\n {\n-    BOOST_CHECK(!ZeroL);  BOOST_CHECK(!ZeroS);\n-    BOOST_CHECK(!(!OneL));BOOST_CHECK(!(!OneS));\n-    for (unsigned int i = 0; i < 256; ++i) \n-        BOOST_CHECK(!(!(OneL<<i)));\n-    for (unsigned int i = 0; i < 160; ++i) \n-        BOOST_CHECK(!(!(OneS<<i)));\n-    BOOST_CHECK(!(!R1L));BOOST_CHECK(!(!R1S));\n-    BOOST_CHECK(!(!R2S));BOOST_CHECK(!(!R2S)); \n-    BOOST_CHECK(!(!MaxL));BOOST_CHECK(!(!MaxS));\n-\n-    BOOST_CHECK(~ZeroL == MaxL); BOOST_CHECK(~ZeroS == MaxS);\n+    BOOST_CHECK(!ZeroL);\n+    BOOST_CHECK(!ZeroS);\n+    BOOST_CHECK(!(!OneL));\n+    BOOST_CHECK(!(!OneS));\n+    for (unsigned int i = 0; i < 256; ++i)\n+        BOOST_CHECK(!(!(OneL << i)));\n+    for (unsigned int i = 0; i < 160; ++i)\n+        BOOST_CHECK(!(!(OneS << i)));\n+    BOOST_CHECK(!(!R1L));\n+    BOOST_CHECK(!(!R1S));\n+    BOOST_CHECK(!(!R2S));\n+    BOOST_CHECK(!(!R2S));\n+    BOOST_CHECK(!(!MaxL));\n+    BOOST_CHECK(!(!MaxS));\n+\n+    BOOST_CHECK(~ZeroL == MaxL);\n+    BOOST_CHECK(~ZeroS == MaxS);\n \n     unsigned char TmpArray[32];\n-    for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = ~R1Array[i]; } \n-    BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (~R1L));\n-    BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (~R1S));\n-\n-    BOOST_CHECK(-ZeroL == ZeroL); BOOST_CHECK(-ZeroS == ZeroS);\n-    BOOST_CHECK(-R1L == (~R1L)+1);\n-    BOOST_CHECK(-R1S == (~R1S)+1);\n-    for (unsigned int i = 0; i < 256; ++i) \n-        BOOST_CHECK(-(OneL<<i) == (MaxL << i));\n-    for (unsigned int i = 0; i < 160; ++i) \n-        BOOST_CHECK(-(OneS<<i) == (MaxS << i));\n+    for (unsigned int i = 0; i < 32; ++i) {\n+        TmpArray[i] = ~R1Array[i];\n+    }\n+    BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (~R1L));\n+    BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (~R1S));\n+\n+    BOOST_CHECK(-ZeroL == ZeroL);\n+    BOOST_CHECK(-ZeroS == ZeroS);\n+    BOOST_CHECK(-R1L == (~R1L) + 1);\n+    BOOST_CHECK(-R1S == (~R1S) + 1);\n+    for (unsigned int i = 0; i < 256; ++i)\n+        BOOST_CHECK(-(OneL << i) == (MaxL << i));\n+    for (unsigned int i = 0; i < 160; ++i)\n+        BOOST_CHECK(-(OneS << i) == (MaxS << i));\n }\n \n \n // Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n // element of Aarray and Barray, and then converting the result into a uint256.\n-#define CHECKBITWISEOPERATOR(_A_,_B_,_OP_)                              \\\n-    for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n-    BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L)); \\\n-    for (unsigned int i = 0; i < 20; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n-    BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray,TmpArray+20)) == (_A_##S _OP_ _B_##S));\n-\n-#define CHECKASSIGNMENTOPERATOR(_A_,_B_,_OP_)                           \\\n-    TmpL = _A_##L; TmpL _OP_##= _B_##L; BOOST_CHECK(TmpL == (_A_##L _OP_ _B_##L)); \\\n-    TmpS = _A_##S; TmpS _OP_##= _B_##S; BOOST_CHECK(TmpS == (_A_##S _OP_ _B_##S));\n-\n-BOOST_AUTO_TEST_CASE( bitwiseOperators ) \n+#define CHECKBITWISEOPERATOR(_A_, _B_, _OP_)                                                           \\\n+    for (unsigned int i = 0; i < 32; ++i) {                                                            \\\n+        TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i];                                                \\\n+    }                                                                                                  \\\n+    BOOST_CHECK(uint256(std::vector<unsigned char>(TmpArray, TmpArray + 32)) == (_A_##L _OP_ _B_##L)); \\\n+    for (unsigned int i = 0; i < 20; ++i) {                                                            \\\n+        TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i];                                                \\\n+    }                                                                                                  \\\n+    BOOST_CHECK(uint160(std::vector<unsigned char>(TmpArray, TmpArray + 20)) == (_A_##S _OP_ _B_##S));\n+\n+#define CHECKASSIGNMENTOPERATOR(_A_, _B_, _OP_) \\\n+    TmpL = _A_##L;                              \\\n+    TmpL _OP_## = _B_##L;                       \\\n+    BOOST_CHECK(TmpL == (_A_##L _OP_ _B_##L));  \\\n+    TmpS = _A_##S;                              \\\n+    TmpS _OP_## = _B_##S;                       \\\n+    BOOST_CHECK(TmpS == (_A_##S _OP_ _B_##S));\n+\n+BOOST_AUTO_TEST_CASE(bitwiseOperators)\n {\n     unsigned char TmpArray[32];\n-    \n-    CHECKBITWISEOPERATOR(R1,R2,|)\n-    CHECKBITWISEOPERATOR(R1,R2,^)\n-    CHECKBITWISEOPERATOR(R1,R2,&)\n-    CHECKBITWISEOPERATOR(R1,Zero,|)\n-    CHECKBITWISEOPERATOR(R1,Zero,^)\n-    CHECKBITWISEOPERATOR(R1,Zero,&)\n-    CHECKBITWISEOPERATOR(R1,Max,|)\n-    CHECKBITWISEOPERATOR(R1,Max,^)\n-    CHECKBITWISEOPERATOR(R1,Max,&)\n-    CHECKBITWISEOPERATOR(Zero,R1,|)\n-    CHECKBITWISEOPERATOR(Zero,R1,^)\n-    CHECKBITWISEOPERATOR(Zero,R1,&)\n-    CHECKBITWISEOPERATOR(Max,R1,|)\n-    CHECKBITWISEOPERATOR(Max,R1,^)\n-    CHECKBITWISEOPERATOR(Max,R1,&)\n+\n+    CHECKBITWISEOPERATOR(R1, R2, | )\n+    CHECKBITWISEOPERATOR(R1, R2, ^)\n+    CHECKBITWISEOPERATOR(R1, R2, &)\n+    CHECKBITWISEOPERATOR(R1, Zero, | )\n+    CHECKBITWISEOPERATOR(R1, Zero, ^)\n+    CHECKBITWISEOPERATOR(R1, Zero, &)\n+    CHECKBITWISEOPERATOR(R1, Max, | )\n+    CHECKBITWISEOPERATOR(R1, Max, ^)\n+    CHECKBITWISEOPERATOR(R1, Max, &)\n+    CHECKBITWISEOPERATOR(Zero, R1, | )\n+    CHECKBITWISEOPERATOR(Zero, R1, ^)\n+    CHECKBITWISEOPERATOR(Zero, R1, &)\n+    CHECKBITWISEOPERATOR(Max, R1, | )\n+    CHECKBITWISEOPERATOR(Max, R1, ^)\n+    CHECKBITWISEOPERATOR(Max, R1, &)\n \n     uint256 TmpL;\n     uint160 TmpS;\n-    CHECKASSIGNMENTOPERATOR(R1,R2,|)\n-    CHECKASSIGNMENTOPERATOR(R1,R2,^)\n-    CHECKASSIGNMENTOPERATOR(R1,R2,&)\n-    CHECKASSIGNMENTOPERATOR(R1,Zero,|)\n-    CHECKASSIGNMENTOPERATOR(R1,Zero,^)\n-    CHECKASSIGNMENTOPERATOR(R1,Zero,&)\n-    CHECKASSIGNMENTOPERATOR(R1,Max,|)\n-    CHECKASSIGNMENTOPERATOR(R1,Max,^)\n-    CHECKASSIGNMENTOPERATOR(R1,Max,&)\n-    CHECKASSIGNMENTOPERATOR(Zero,R1,|)\n-    CHECKASSIGNMENTOPERATOR(Zero,R1,^)\n-    CHECKASSIGNMENTOPERATOR(Zero,R1,&)\n-    CHECKASSIGNMENTOPERATOR(Max,R1,|)\n-    CHECKASSIGNMENTOPERATOR(Max,R1,^)\n-    CHECKASSIGNMENTOPERATOR(Max,R1,&)\n-\n-    uint64_t Tmp64 = 0xe1db685c9a0b47a2ULL; \n-    TmpL = R1L; TmpL |= Tmp64;  BOOST_CHECK(TmpL == (R1L | uint256(Tmp64)));\n-    TmpS = R1S; TmpS |= Tmp64;  BOOST_CHECK(TmpS == (R1S | uint160(Tmp64)));\n-    TmpL = R1L; TmpL |= 0; BOOST_CHECK(TmpL == R1L);\n-    TmpS = R1S; TmpS |= 0; BOOST_CHECK(TmpS == R1S);\n-    TmpL ^= 0; BOOST_CHECK(TmpL == R1L);\n-    TmpS ^= 0; BOOST_CHECK(TmpS == R1S);\n-    TmpL ^= Tmp64;  BOOST_CHECK(TmpL == (R1L ^ uint256(Tmp64)));\n-    TmpS ^= Tmp64;  BOOST_CHECK(TmpS == (R1S ^ uint160(Tmp64)));\n+    CHECKASSIGNMENTOPERATOR(R1, R2, | )\n+    CHECKASSIGNMENTOPERATOR(R1, R2, ^)\n+    CHECKASSIGNMENTOPERATOR(R1, R2, &)\n+    CHECKASSIGNMENTOPERATOR(R1, Zero, | )\n+    CHECKASSIGNMENTOPERATOR(R1, Zero, ^)\n+    CHECKASSIGNMENTOPERATOR(R1, Zero, &)\n+    CHECKASSIGNMENTOPERATOR(R1, Max, | )\n+    CHECKASSIGNMENTOPERATOR(R1, Max, ^)\n+    CHECKASSIGNMENTOPERATOR(R1, Max, &)\n+    CHECKASSIGNMENTOPERATOR(Zero, R1, | )\n+    CHECKASSIGNMENTOPERATOR(Zero, R1, ^)\n+    CHECKASSIGNMENTOPERATOR(Zero, R1, &)\n+    CHECKASSIGNMENTOPERATOR(Max, R1, | )\n+    CHECKASSIGNMENTOPERATOR(Max, R1, ^)\n+    CHECKASSIGNMENTOPERATOR(Max, R1, &)\n+\n+    uint64_t Tmp64 = 0xe1db685c9a0b47a2ULL;\n+    TmpL = R1L;\n+    TmpL |= Tmp64;\n+    BOOST_CHECK(TmpL == (R1L | uint256(Tmp64)));\n+    TmpS = R1S;\n+    TmpS |= Tmp64;\n+    BOOST_CHECK(TmpS == (R1S | uint160(Tmp64)));\n+    TmpL = R1L;\n+    TmpL |= 0;\n+    BOOST_CHECK(TmpL == R1L);\n+    TmpS = R1S;\n+    TmpS |= 0;\n+    BOOST_CHECK(TmpS == R1S);\n+    TmpL ^= 0;\n+    BOOST_CHECK(TmpL == R1L);\n+    TmpS ^= 0;\n+    BOOST_CHECK(TmpS == R1S);\n+    TmpL ^= Tmp64;\n+    BOOST_CHECK(TmpL == (R1L ^ uint256(Tmp64)));\n+    TmpS ^= Tmp64;\n+    BOOST_CHECK(TmpS == (R1S ^ uint160(Tmp64)));\n }\n \n-BOOST_AUTO_TEST_CASE( comparison ) // <= >= < >\n+BOOST_AUTO_TEST_CASE(comparison) // <= >= < >\n {\n     uint256 TmpL;\n     for (unsigned int i = 0; i < 256; ++i) {\n-        TmpL= OneL<< i;\n-        BOOST_CHECK( TmpL >= ZeroL && TmpL > ZeroL && ZeroL < TmpL && ZeroL <= TmpL);\n-        BOOST_CHECK( TmpL >= 0 && TmpL > 0 && 0 < TmpL && 0 <= TmpL);\n+        TmpL = OneL << i;\n+        BOOST_CHECK(TmpL >= ZeroL && TmpL > ZeroL && ZeroL < TmpL && ZeroL <= TmpL);\n+        BOOST_CHECK(TmpL >= 0 && TmpL > 0 && 0 < TmpL && 0 <= TmpL);\n         TmpL |= R1L;\n-        BOOST_CHECK( TmpL >= R1L ); BOOST_CHECK( (TmpL == R1L) != (TmpL > R1L)); BOOST_CHECK( (TmpL == R1L) || !( TmpL <= R1L));\n-        BOOST_CHECK( R1L <= TmpL ); BOOST_CHECK( (R1L == TmpL) != (R1L < TmpL)); BOOST_CHECK( (TmpL == R1L) || !( R1L >= TmpL));\n-        BOOST_CHECK(! (TmpL < R1L)); BOOST_CHECK(! (R1L > TmpL));\n+        BOOST_CHECK(TmpL >= R1L);\n+        BOOST_CHECK((TmpL == R1L) != (TmpL > R1L));\n+        BOOST_CHECK((TmpL == R1L) || !(TmpL <= R1L));\n+        BOOST_CHECK(R1L <= TmpL);\n+        BOOST_CHECK((R1L == TmpL) != (R1L < TmpL));\n+        BOOST_CHECK((TmpL == R1L) || !(R1L >= TmpL));\n+        BOOST_CHECK(!(TmpL < R1L));\n+        BOOST_CHECK(!(R1L > TmpL));\n     }\n     uint160 TmpS;\n     for (unsigned int i = 0; i < 160; ++i) {\n-        TmpS= OneS<< i;\n-        BOOST_CHECK( TmpS >= ZeroS && TmpS > ZeroS && ZeroS < TmpS && ZeroS <= TmpS);\n-        BOOST_CHECK( TmpS >= 0 && TmpS > 0 && 0 < TmpS && 0 <= TmpS);\n+        TmpS = OneS << i;\n+        BOOST_CHECK(TmpS >= ZeroS && TmpS > ZeroS && ZeroS < TmpS && ZeroS <= TmpS);\n+        BOOST_CHECK(TmpS >= 0 && TmpS > 0 && 0 < TmpS && 0 <= TmpS);\n         TmpS |= R1S;\n-        BOOST_CHECK( TmpS >= R1S ); BOOST_CHECK( (TmpS == R1S) != (TmpS > R1S)); BOOST_CHECK( (TmpS == R1S) || !( TmpS <= R1S));\n-        BOOST_CHECK( R1S <= TmpS ); BOOST_CHECK( (R1S == TmpS) != (R1S < TmpS)); BOOST_CHECK( (TmpS == R1S) || !( R1S >= TmpS));\n-        BOOST_CHECK(! (TmpS < R1S)); BOOST_CHECK(! (R1S > TmpS));\n+        BOOST_CHECK(TmpS >= R1S);\n+        BOOST_CHECK((TmpS == R1S) != (TmpS > R1S));\n+        BOOST_CHECK((TmpS == R1S) || !(TmpS <= R1S));\n+        BOOST_CHECK(R1S <= TmpS);\n+        BOOST_CHECK((R1S == TmpS) != (R1S < TmpS));\n+        BOOST_CHECK((TmpS == R1S) || !(R1S >= TmpS));\n+        BOOST_CHECK(!(TmpS < R1S));\n+        BOOST_CHECK(!(R1S > TmpS));\n     }\n }\n \n-BOOST_AUTO_TEST_CASE( plusMinus ) \n+BOOST_AUTO_TEST_CASE(plusMinus)\n {\n     uint256 TmpL = 0;\n-    BOOST_CHECK(R1L+R2L == uint256(R1LplusR2L));\n+    BOOST_CHECK(R1L + R2L == uint256(R1LplusR2L));\n     TmpL += R1L;\n     BOOST_CHECK(TmpL == R1L);\n     TmpL += R2L;\n     BOOST_CHECK(TmpL == R1L + R2L);\n-    BOOST_CHECK(OneL+MaxL == ZeroL);\n-    BOOST_CHECK(MaxL+OneL == ZeroL);\n+    BOOST_CHECK(OneL + MaxL == ZeroL);\n+    BOOST_CHECK(MaxL + OneL == ZeroL);\n     for (unsigned int i = 1; i < 256; ++i) {\n-        BOOST_CHECK( (MaxL >> i) + OneL == (HalfL >> (i-1)) );\n-        BOOST_CHECK( OneL + (MaxL >> i) == (HalfL >> (i-1)) );\n-        TmpL = (MaxL>>i); TmpL += OneL;\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)) );\n-        TmpL = (MaxL>>i); TmpL += 1;\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)) );\n-        TmpL = (MaxL>>i); \n-        BOOST_CHECK( TmpL++ == (MaxL>>i) );\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)));\n+        BOOST_CHECK((MaxL >> i) + OneL == (HalfL >> (i - 1)));\n+        BOOST_CHECK(OneL + (MaxL >> i) == (HalfL >> (i - 1)));\n+        TmpL = (MaxL >> i);\n+        TmpL += OneL;\n+        BOOST_CHECK(TmpL == (HalfL >> (i - 1)));\n+        TmpL = (MaxL >> i);\n+        TmpL += 1;\n+        BOOST_CHECK(TmpL == (HalfL >> (i - 1)));\n+        TmpL = (MaxL >> i);\n+        BOOST_CHECK(TmpL++ == (MaxL >> i));\n+        BOOST_CHECK(TmpL == (HalfL >> (i - 1)));\n     }\n     BOOST_CHECK(uint256(0xbedc77e27940a7ULL) + 0xee8d836fce66fbULL == uint256(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n-    TmpL = uint256(0xbedc77e27940a7ULL); TmpL += 0xee8d836fce66fbULL;\n-    BOOST_CHECK(TmpL == uint256(0xbedc77e27940a7ULL+0xee8d836fce66fbULL));\n-    TmpL -= 0xee8d836fce66fbULL;  BOOST_CHECK(TmpL == 0xbedc77e27940a7ULL);\n+    TmpL = uint256(0xbedc77e27940a7ULL);\n+    TmpL += 0xee8d836fce66fbULL;\n+    BOOST_CHECK(TmpL == uint256(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n+    TmpL -= 0xee8d836fce66fbULL;\n+    BOOST_CHECK(TmpL == 0xbedc77e27940a7ULL);\n     TmpL = R1L;\n-    BOOST_CHECK(++TmpL == R1L+1);\n+    BOOST_CHECK(++TmpL == R1L + 1);\n \n-    BOOST_CHECK(R1L -(-R2L) == R1L+R2L);\n-    BOOST_CHECK(R1L -(-OneL) == R1L+OneL);\n-    BOOST_CHECK(R1L - OneL == R1L+(-OneL));\n+    BOOST_CHECK(R1L - (-R2L) == R1L + R2L);\n+    BOOST_CHECK(R1L - (-OneL) == R1L + OneL);\n+    BOOST_CHECK(R1L - OneL == R1L + (-OneL));\n     for (unsigned int i = 1; i < 256; ++i) {\n-        BOOST_CHECK((MaxL>>i) - (-OneL)  == (HalfL >> (i-1)));\n-        BOOST_CHECK((HalfL >> (i-1)) - OneL == (MaxL>>i));\n-        TmpL = (HalfL >> (i-1));\n-        BOOST_CHECK(TmpL-- == (HalfL >> (i-1)));\n+        BOOST_CHECK((MaxL >> i) - (-OneL) == (HalfL >> (i - 1)));\n+        BOOST_CHECK((HalfL >> (i - 1)) - OneL == (MaxL >> i));\n+        TmpL = (HalfL >> (i - 1));\n+        BOOST_CHECK(TmpL-- == (HalfL >> (i - 1)));\n         BOOST_CHECK(TmpL == (MaxL >> i));\n-        TmpL = (HalfL >> (i-1));\n+        TmpL = (HalfL >> (i - 1));\n         BOOST_CHECK(--TmpL == (MaxL >> i));\n     }\n     TmpL = R1L;\n-    BOOST_CHECK(--TmpL == R1L-1);\n+    BOOST_CHECK(--TmpL == R1L - 1);\n \n     // 160-bit; copy-pasted\n     uint160 TmpS = 0;\n-    BOOST_CHECK(R1S+R2S == uint160(R1LplusR2L));\n+    BOOST_CHECK(R1S + R2S == uint160(R1LplusR2L));\n     TmpS += R1S;\n     BOOST_CHECK(TmpS == R1S);\n     TmpS += R2S;\n     BOOST_CHECK(TmpS == R1S + R2S);\n-    BOOST_CHECK(OneS+MaxS == ZeroS);\n-    BOOST_CHECK(MaxS+OneS == ZeroS);\n+    BOOST_CHECK(OneS + MaxS == ZeroS);\n+    BOOST_CHECK(MaxS + OneS == ZeroS);\n     for (unsigned int i = 1; i < 160; ++i) {\n-        BOOST_CHECK( (MaxS >> i) + OneS == (HalfS >> (i-1)) );\n-        BOOST_CHECK( OneS + (MaxS >> i) == (HalfS >> (i-1)) );\n-        TmpS = (MaxS>>i); TmpS += OneS;\n-        BOOST_CHECK( TmpS == (HalfS >> (i-1)) );\n-        TmpS = (MaxS>>i); TmpS += 1;\n-        BOOST_CHECK( TmpS == (HalfS >> (i-1)) );\n-        TmpS = (MaxS>>i); \n-        BOOST_CHECK( TmpS++ == (MaxS>>i) );\n-        BOOST_CHECK( TmpS == (HalfS >> (i-1)));\n+        BOOST_CHECK((MaxS >> i) + OneS == (HalfS >> (i - 1)));\n+        BOOST_CHECK(OneS + (MaxS >> i) == (HalfS >> (i - 1)));\n+        TmpS = (MaxS >> i);\n+        TmpS += OneS;\n+        BOOST_CHECK(TmpS == (HalfS >> (i - 1)));\n+        TmpS = (MaxS >> i);\n+        TmpS += 1;\n+        BOOST_CHECK(TmpS == (HalfS >> (i - 1)));\n+        TmpS = (MaxS >> i);\n+        BOOST_CHECK(TmpS++ == (MaxS >> i));\n+        BOOST_CHECK(TmpS == (HalfS >> (i - 1)));\n     }\n     BOOST_CHECK(uint160(0xbedc77e27940a7ULL) + 0xee8d836fce66fbULL == uint160(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n-    TmpS = uint160(0xbedc77e27940a7ULL); TmpS += 0xee8d836fce66fbULL;\n-    BOOST_CHECK(TmpS == uint160(0xbedc77e27940a7ULL+0xee8d836fce66fbULL));\n-    TmpS -= 0xee8d836fce66fbULL;  BOOST_CHECK(TmpS == 0xbedc77e27940a7ULL);\n+    TmpS = uint160(0xbedc77e27940a7ULL);\n+    TmpS += 0xee8d836fce66fbULL;\n+    BOOST_CHECK(TmpS == uint160(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n+    TmpS -= 0xee8d836fce66fbULL;\n+    BOOST_CHECK(TmpS == 0xbedc77e27940a7ULL);\n     TmpS = R1S;\n-    BOOST_CHECK(++TmpS == R1S+1);\n+    BOOST_CHECK(++TmpS == R1S + 1);\n \n-    BOOST_CHECK(R1S -(-R2S) == R1S+R2S);\n-    BOOST_CHECK(R1S -(-OneS) == R1S+OneS);\n-    BOOST_CHECK(R1S - OneS == R1S+(-OneS));\n+    BOOST_CHECK(R1S - (-R2S) == R1S + R2S);\n+    BOOST_CHECK(R1S - (-OneS) == R1S + OneS);\n+    BOOST_CHECK(R1S - OneS == R1S + (-OneS));\n     for (unsigned int i = 1; i < 160; ++i) {\n-        BOOST_CHECK((MaxS>>i) - (-OneS)  == (HalfS >> (i-1)));\n-        BOOST_CHECK((HalfS >> (i-1)) - OneS == (MaxS>>i));\n-        TmpS = (HalfS >> (i-1));\n-        BOOST_CHECK(TmpS-- == (HalfS >> (i-1)));\n+        BOOST_CHECK((MaxS >> i) - (-OneS) == (HalfS >> (i - 1)));\n+        BOOST_CHECK((HalfS >> (i - 1)) - OneS == (MaxS >> i));\n+        TmpS = (HalfS >> (i - 1));\n+        BOOST_CHECK(TmpS-- == (HalfS >> (i - 1)));\n         BOOST_CHECK(TmpS == (MaxS >> i));\n-        TmpS = (HalfS >> (i-1));\n+        TmpS = (HalfS >> (i - 1));\n         BOOST_CHECK(--TmpS == (MaxS >> i));\n     }\n     TmpS = R1S;\n-    BOOST_CHECK(--TmpS == R1S-1);\n-\n+    BOOST_CHECK(--TmpS == R1S - 1);\n }\n \n-BOOST_AUTO_TEST_CASE( multiply )\n+BOOST_AUTO_TEST_CASE(multiply)\n {\n     BOOST_CHECK((R1L * R1L).ToString() == \"62a38c0486f01e45879d7910a7761bf30d5237e9873f9bff3642a732c4d84f10\");\n     BOOST_CHECK((R1L * R2L).ToString() == \"de37805e9986996cfba76ff6ba51c008df851987d9dd323f0e5de07760529c40\");\n@@ -519,7 +579,7 @@ BOOST_AUTO_TEST_CASE( multiply )\n     BOOST_CHECK((R2S * 0xFFFFFFFFUL).ToString() == \"1c6f6c930353e17f7d6127213bb18d2883e2cd90\");\n }\n \n-BOOST_AUTO_TEST_CASE( divide )\n+BOOST_AUTO_TEST_CASE(divide)\n {\n     uint256 D1L(\"AD7133AC1977FA2B7\");\n     uint256 D2L(\"ECD751716\");\n@@ -553,29 +613,32 @@ BOOST_AUTO_TEST_CASE( divide )\n }\n \n \n-bool almostEqual(double d1, double d2) \n+bool almostEqual(double d1, double d2)\n {\n-    return fabs(d1-d2) <= 4*fabs(d1)*std::numeric_limits<double>::epsilon();\n+    return fabs(d1 - d2) <= 4 * fabs(d1) * std::numeric_limits<double>::epsilon();\n }\n \n-BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex begin() end() size() GetLow64 GetSerializeSize, Serialize, Unserialize\n+BOOST_AUTO_TEST_CASE(methods) // GetHex SetHex begin() end() size() GetLow64 GetSerializeSize, Serialize, Unserialize\n {\n     BOOST_CHECK(R1L.GetHex() == R1L.ToString());\n     BOOST_CHECK(R2L.GetHex() == R2L.ToString());\n     BOOST_CHECK(OneL.GetHex() == OneL.ToString());\n     BOOST_CHECK(MaxL.GetHex() == MaxL.ToString());\n     uint256 TmpL(R1L);\n     BOOST_CHECK(TmpL == R1L);\n-    TmpL.SetHex(R2L.ToString());   BOOST_CHECK(TmpL == R2L);\n-    TmpL.SetHex(ZeroL.ToString()); BOOST_CHECK(TmpL == 0);\n-    TmpL.SetHex(HalfL.ToString()); BOOST_CHECK(TmpL == HalfL);\n+    TmpL.SetHex(R2L.ToString());\n+    BOOST_CHECK(TmpL == R2L);\n+    TmpL.SetHex(ZeroL.ToString());\n+    BOOST_CHECK(TmpL == 0);\n+    TmpL.SetHex(HalfL.ToString());\n+    BOOST_CHECK(TmpL == HalfL);\n \n     TmpL.SetHex(R1L.ToString());\n-    BOOST_CHECK(memcmp(R1L.begin(), R1Array, 32)==0);\n-    BOOST_CHECK(memcmp(TmpL.begin(), R1Array, 32)==0);\n-    BOOST_CHECK(memcmp(R2L.begin(), R2Array, 32)==0);\n-    BOOST_CHECK(memcmp(ZeroL.begin(), ZeroArray, 32)==0);\n-    BOOST_CHECK(memcmp(OneL.begin(), OneArray, 32)==0);\n+    BOOST_CHECK(memcmp(R1L.begin(), R1Array, 32) == 0);\n+    BOOST_CHECK(memcmp(TmpL.begin(), R1Array, 32) == 0);\n+    BOOST_CHECK(memcmp(R2L.begin(), R2Array, 32) == 0);\n+    BOOST_CHECK(memcmp(ZeroL.begin(), ZeroArray, 32) == 0);\n+    BOOST_CHECK(memcmp(OneL.begin(), OneArray, 32) == 0);\n     BOOST_CHECK(R1L.size() == 32);\n     BOOST_CHECK(R2L.size() == 32);\n     BOOST_CHECK(ZeroL.size() == 32);\n@@ -585,26 +648,26 @@ BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex begin() end() size() GetLow64 G\n     BOOST_CHECK(OneL.begin() + 32 == OneL.end());\n     BOOST_CHECK(MaxL.begin() + 32 == MaxL.end());\n     BOOST_CHECK(TmpL.begin() + 32 == TmpL.end());\n-    BOOST_CHECK(R1L.GetLow64()  == R1LLow64);\n-    BOOST_CHECK(HalfL.GetLow64() ==0x0000000000000000ULL);\n-    BOOST_CHECK(OneL.GetLow64() ==0x0000000000000001ULL);\n-    BOOST_CHECK(R1L.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n-    BOOST_CHECK(ZeroL.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n+    BOOST_CHECK(R1L.GetLow64() == R1LLow64);\n+    BOOST_CHECK(HalfL.GetLow64() == 0x0000000000000000ULL);\n+    BOOST_CHECK(OneL.GetLow64() == 0x0000000000000001ULL);\n+    BOOST_CHECK(R1L.GetSerializeSize(0, PROTOCOL_VERSION) == 32);\n+    BOOST_CHECK(ZeroL.GetSerializeSize(0, PROTOCOL_VERSION) == 32);\n \n     std::stringstream ss;\n-    R1L.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(R1Array,R1Array+32));\n-    TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n+    R1L.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(R1Array, R1Array + 32));\n+    TmpL.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(R1L == TmpL);\n     ss.str(\"\");\n-    ZeroL.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+32));\n-    TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n+    ZeroL.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(ZeroArray, ZeroArray + 32));\n+    TmpL.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(ZeroL == TmpL);\n     ss.str(\"\");\n-    MaxL.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(MaxArray,MaxArray+32));\n-    TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n+    MaxL.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(MaxArray, MaxArray + 32));\n+    TmpL.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(MaxL == TmpL);\n     ss.str(\"\");\n \n@@ -614,16 +677,19 @@ BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex begin() end() size() GetLow64 G\n     BOOST_CHECK(MaxS.GetHex() == MaxS.ToString());\n     uint160 TmpS(R1S);\n     BOOST_CHECK(TmpS == R1S);\n-    TmpS.SetHex(R2S.ToString());   BOOST_CHECK(TmpS == R2S);\n-    TmpS.SetHex(ZeroS.ToString()); BOOST_CHECK(TmpS == 0);\n-    TmpS.SetHex(HalfS.ToString()); BOOST_CHECK(TmpS == HalfS);\n+    TmpS.SetHex(R2S.ToString());\n+    BOOST_CHECK(TmpS == R2S);\n+    TmpS.SetHex(ZeroS.ToString());\n+    BOOST_CHECK(TmpS == 0);\n+    TmpS.SetHex(HalfS.ToString());\n+    BOOST_CHECK(TmpS == HalfS);\n \n     TmpS.SetHex(R1S.ToString());\n-    BOOST_CHECK(memcmp(R1S.begin(), R1Array, 20)==0);\n-    BOOST_CHECK(memcmp(TmpS.begin(), R1Array, 20)==0);\n-    BOOST_CHECK(memcmp(R2S.begin(), R2Array, 20)==0);\n-    BOOST_CHECK(memcmp(ZeroS.begin(), ZeroArray, 20)==0);\n-    BOOST_CHECK(memcmp(OneS.begin(), OneArray, 20)==0);\n+    BOOST_CHECK(memcmp(R1S.begin(), R1Array, 20) == 0);\n+    BOOST_CHECK(memcmp(TmpS.begin(), R1Array, 20) == 0);\n+    BOOST_CHECK(memcmp(R2S.begin(), R2Array, 20) == 0);\n+    BOOST_CHECK(memcmp(ZeroS.begin(), ZeroArray, 20) == 0);\n+    BOOST_CHECK(memcmp(OneS.begin(), OneArray, 20) == 0);\n     BOOST_CHECK(R1S.size() == 20);\n     BOOST_CHECK(R2S.size() == 20);\n     BOOST_CHECK(ZeroS.size() == 20);\n@@ -633,45 +699,45 @@ BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex begin() end() size() GetLow64 G\n     BOOST_CHECK(OneS.begin() + 20 == OneS.end());\n     BOOST_CHECK(MaxS.begin() + 20 == MaxS.end());\n     BOOST_CHECK(TmpS.begin() + 20 == TmpS.end());\n-    BOOST_CHECK(R1S.GetLow64()  == R1LLow64);\n-    BOOST_CHECK(HalfS.GetLow64() ==0x0000000000000000ULL); \n-    BOOST_CHECK(OneS.GetLow64() ==0x0000000000000001ULL);\n-    BOOST_CHECK(R1S.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n-    BOOST_CHECK(ZeroS.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n-\n-    R1S.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(R1Array,R1Array+20));\n-    TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n+    BOOST_CHECK(R1S.GetLow64() == R1LLow64);\n+    BOOST_CHECK(HalfS.GetLow64() == 0x0000000000000000ULL);\n+    BOOST_CHECK(OneS.GetLow64() == 0x0000000000000001ULL);\n+    BOOST_CHECK(R1S.GetSerializeSize(0, PROTOCOL_VERSION) == 20);\n+    BOOST_CHECK(ZeroS.GetSerializeSize(0, PROTOCOL_VERSION) == 20);\n+\n+    R1S.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(R1Array, R1Array + 20));\n+    TmpS.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(R1S == TmpS);\n     ss.str(\"\");\n-    ZeroS.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+20));\n-    TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n+    ZeroS.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(ZeroArray, ZeroArray + 20));\n+    TmpS.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(ZeroS == TmpS);\n     ss.str(\"\");\n-    MaxS.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(MaxArray,MaxArray+20));\n-    TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n+    MaxS.Serialize(ss, 0, PROTOCOL_VERSION);\n+    BOOST_CHECK(ss.str() == std::string(MaxArray, MaxArray + 20));\n+    TmpS.Unserialize(ss, 0, PROTOCOL_VERSION);\n     BOOST_CHECK(MaxS == TmpS);\n     ss.str(\"\");\n-    \n-    for (unsigned int i = 0; i < 255; ++i) \n-    {\n-        BOOST_CHECK((OneL << i).getdouble() == ldexp(1.0,i));\n-        if (i < 160) BOOST_CHECK((OneS << i).getdouble() == ldexp(1.0,i));\n+\n+    for (unsigned int i = 0; i < 255; ++i) {\n+        BOOST_CHECK((OneL << i).getdouble() == ldexp(1.0, i));\n+        if (i < 160)\n+            BOOST_CHECK((OneS << i).getdouble() == ldexp(1.0, i));\n     }\n     BOOST_CHECK(ZeroL.getdouble() == 0.0);\n     BOOST_CHECK(ZeroS.getdouble() == 0.0);\n-    for (int i = 256; i > 53; --i) \n-        BOOST_CHECK(almostEqual((R1L>>(256-i)).getdouble(), ldexp(R1Ldouble,i)));\n-    for (int i = 160; i > 53; --i) \n-        BOOST_CHECK(almostEqual((R1S>>(160-i)).getdouble(), ldexp(R1Sdouble,i)));\n-    uint64_t R1L64part = (R1L>>192).GetLow64();\n-    uint64_t R1S64part = (R1S>>96).GetLow64();\n+    for (int i = 256; i > 53; --i)\n+        BOOST_CHECK(almostEqual((R1L >> (256 - i)).getdouble(), ldexp(R1Ldouble, i)));\n+    for (int i = 160; i > 53; --i)\n+        BOOST_CHECK(almostEqual((R1S >> (160 - i)).getdouble(), ldexp(R1Sdouble, i)));\n+    uint64_t R1L64part = (R1L >> 192).GetLow64();\n+    uint64_t R1S64part = (R1S >> 96).GetLow64();\n     for (int i = 53; i > 0; --i) // doubles can store all integers in {0,...,2^54-1} exactly\n     {\n-        BOOST_CHECK((R1L>>(256-i)).getdouble() == (double)(R1L64part >> (64-i)));\n-        BOOST_CHECK((R1S>>(160-i)).getdouble() == (double)(R1S64part >> (64-i)));\n+        BOOST_CHECK((R1L >> (256 - i)).getdouble() == (double)(R1L64part >> (64 - i)));\n+        BOOST_CHECK((R1S >> (160 - i)).getdouble() == (double)(R1S64part >> (64 - i)));\n     }\n }\n \n@@ -804,34 +870,45 @@ BOOST_AUTO_TEST_CASE(bignum_SetCompact)\n }\n \n \n-BOOST_AUTO_TEST_CASE( getmaxcoverage ) // some more tests just to get 100% coverage\n+BOOST_AUTO_TEST_CASE(getmaxcoverage) // some more tests just to get 100% coverage\n {\n     // ~R1L give a base_uint<256>\n-    BOOST_CHECK((~~R1L >> 10) == (R1L >> 10)); BOOST_CHECK((~~R1S >> 10) == (R1S >> 10));\n-    BOOST_CHECK((~~R1L << 10) == (R1L << 10)); BOOST_CHECK((~~R1S << 10) == (R1S << 10));\n-    BOOST_CHECK(!(~~R1L < R1L)); BOOST_CHECK(!(~~R1S < R1S)); \n-    BOOST_CHECK(~~R1L <= R1L); BOOST_CHECK(~~R1S <= R1S); \n-    BOOST_CHECK(!(~~R1L > R1L)); BOOST_CHECK(!(~~R1S > R1S)); \n-    BOOST_CHECK(~~R1L >= R1L); BOOST_CHECK(~~R1S >= R1S); \n-    BOOST_CHECK(!(R1L < ~~R1L)); BOOST_CHECK(!(R1S < ~~R1S)); \n-    BOOST_CHECK(R1L <= ~~R1L); BOOST_CHECK(R1S <= ~~R1S); \n-    BOOST_CHECK(!(R1L > ~~R1L)); BOOST_CHECK(!(R1S > ~~R1S)); \n-    BOOST_CHECK(R1L >= ~~R1L); BOOST_CHECK(R1S >= ~~R1S); \n-    \n+    BOOST_CHECK((~~R1L >> 10) == (R1L >> 10));\n+    BOOST_CHECK((~~R1S >> 10) == (R1S >> 10));\n+    BOOST_CHECK((~~R1L << 10) == (R1L << 10));\n+    BOOST_CHECK((~~R1S << 10) == (R1S << 10));\n+    BOOST_CHECK(!(~~R1L < R1L));\n+    BOOST_CHECK(!(~~R1S < R1S));\n+    BOOST_CHECK(~~R1L <= R1L);\n+    BOOST_CHECK(~~R1S <= R1S);\n+    BOOST_CHECK(!(~~R1L > R1L));\n+    BOOST_CHECK(!(~~R1S > R1S));\n+    BOOST_CHECK(~~R1L >= R1L);\n+    BOOST_CHECK(~~R1S >= R1S);\n+    BOOST_CHECK(!(R1L < ~~R1L));\n+    BOOST_CHECK(!(R1S < ~~R1S));\n+    BOOST_CHECK(R1L <= ~~R1L);\n+    BOOST_CHECK(R1S <= ~~R1S);\n+    BOOST_CHECK(!(R1L > ~~R1L));\n+    BOOST_CHECK(!(R1S > ~~R1S));\n+    BOOST_CHECK(R1L >= ~~R1L);\n+    BOOST_CHECK(R1S >= ~~R1S);\n+\n     BOOST_CHECK(~~R1L + R2L == R1L + ~~R2L);\n     BOOST_CHECK(~~R1S + R2S == R1S + ~~R2S);\n     BOOST_CHECK(~~R1L - R2L == R1L - ~~R2L);\n     BOOST_CHECK(~~R1S - R2S == R1S - ~~R2S);\n-    BOOST_CHECK(~R1L != R1L); BOOST_CHECK(R1L != ~R1L); \n-    BOOST_CHECK(~R1S != R1S); BOOST_CHECK(R1S != ~R1S); \n+    BOOST_CHECK(~R1L != R1L);\n+    BOOST_CHECK(R1L != ~R1L);\n+    BOOST_CHECK(~R1S != R1S);\n+    BOOST_CHECK(R1S != ~R1S);\n     unsigned char TmpArray[32];\n-    CHECKBITWISEOPERATOR(~R1,R2,|)\n-    CHECKBITWISEOPERATOR(~R1,R2,^)\n-    CHECKBITWISEOPERATOR(~R1,R2,&)\n-    CHECKBITWISEOPERATOR(R1,~R2,|)\n-    CHECKBITWISEOPERATOR(R1,~R2,^)\n-    CHECKBITWISEOPERATOR(R1,~R2,&)\n+    CHECKBITWISEOPERATOR(~R1, R2, | )\n+    CHECKBITWISEOPERATOR(~R1, R2, ^)\n+    CHECKBITWISEOPERATOR(~R1, R2, &)\n+    CHECKBITWISEOPERATOR(R1, ~R2, | )\n+    CHECKBITWISEOPERATOR(R1, ~R2, ^)\n+    CHECKBITWISEOPERATOR(R1, ~R2, &)\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n-"
      },
      {
        "sha": "b32103bd9e53fdf0bd2e434bd206af798bda34b7",
        "filename": "src/test/univalue_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/univalue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/univalue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/univalue_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -56,7 +56,7 @@ BOOST_AUTO_TEST_CASE(univalue_constructor)\n     BOOST_CHECK(v8.isStr());\n     BOOST_CHECK_EQUAL(v8.getValStr(), \"yawn\");\n \n-    const char *vcs = \"zappa\";\n+    const char* vcs = \"zappa\";\n     UniValue v9(vcs);\n     BOOST_CHECK(v9.isStr());\n     BOOST_CHECK_EQUAL(v9.getValStr(), \"zappa\");\n@@ -131,7 +131,7 @@ BOOST_AUTO_TEST_CASE(univalue_array)\n     string vStr(\"zippy\");\n     BOOST_CHECK(arr.push_back(vStr));\n \n-    const char *s = \"pippy\";\n+    const char* s = \"pippy\";\n     BOOST_CHECK(arr.push_back(s));\n \n     vector<UniValue> vec;\n@@ -174,20 +174,20 @@ BOOST_AUTO_TEST_CASE(univalue_object)\n     BOOST_CHECK(obj.pushKV(strKey, strVal));\n \n     strKey = \"last\";\n-    const char *cVal = \"Smith\";\n+    const char* cVal = \"Smith\";\n     BOOST_CHECK(obj.pushKV(strKey, cVal));\n \n     strKey = \"distance\";\n-    BOOST_CHECK(obj.pushKV(strKey, (int64_t) 25));\n+    BOOST_CHECK(obj.pushKV(strKey, (int64_t)25));\n \n     strKey = \"time\";\n-    BOOST_CHECK(obj.pushKV(strKey, (uint64_t) 3600));\n+    BOOST_CHECK(obj.pushKV(strKey, (uint64_t)3600));\n \n     strKey = \"calories\";\n-    BOOST_CHECK(obj.pushKV(strKey, (int) 12));\n+    BOOST_CHECK(obj.pushKV(strKey, (int)12));\n \n     strKey = \"temperature\";\n-    BOOST_CHECK(obj.pushKV(strKey, (double) 90.012));\n+    BOOST_CHECK(obj.pushKV(strKey, (double)90.012));\n \n     UniValue obj2(UniValue::VOBJ);\n     BOOST_CHECK(obj2.pushKV(\"cat1\", 9000));\n@@ -242,8 +242,8 @@ BOOST_AUTO_TEST_CASE(univalue_object)\n     BOOST_CHECK_EQUAL(obj.count(), 0);\n }\n \n-static const char *json1 =\n-\"[1.1,{\\\"key1\\\":\\\"str\\\",\\\"key2\\\":800,\\\"key3\\\":{\\\"name\\\":\\\"martian\\\"}}]\";\n+static const char* json1 =\n+    \"[1.1,{\\\"key1\\\":\\\"str\\\",\\\"key2\\\":800,\\\"key3\\\":{\\\"name\\\":\\\"martian\\\"}}]\";\n \n BOOST_AUTO_TEST_CASE(univalue_readwrite)\n {\n@@ -272,4 +272,3 @@ BOOST_AUTO_TEST_CASE(univalue_readwrite)\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n-"
      },
      {
        "sha": "dffdb2d23e43b9428f3cf7183045863688556bac",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 75,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -29,24 +29,83 @@ BOOST_AUTO_TEST_CASE(util_criticalsection)\n         break;\n \n         BOOST_ERROR(\"break was swallowed!\");\n-    } while(0);\n+    } while (0);\n \n     do {\n         TRY_LOCK(cs, lockTest);\n         if (lockTest)\n             break;\n \n         BOOST_ERROR(\"break was swallowed!\");\n-    } while(0);\n+    } while (0);\n }\n \n static const unsigned char ParseHex_expected[65] = {\n-    0x04, 0x67, 0x8a, 0xfd, 0xb0, 0xfe, 0x55, 0x48, 0x27, 0x19, 0x67, 0xf1, 0xa6, 0x71, 0x30, 0xb7,\n-    0x10, 0x5c, 0xd6, 0xa8, 0x28, 0xe0, 0x39, 0x09, 0xa6, 0x79, 0x62, 0xe0, 0xea, 0x1f, 0x61, 0xde,\n-    0xb6, 0x49, 0xf6, 0xbc, 0x3f, 0x4c, 0xef, 0x38, 0xc4, 0xf3, 0x55, 0x04, 0xe5, 0x1e, 0xc1, 0x12,\n-    0xde, 0x5c, 0x38, 0x4d, 0xf7, 0xba, 0x0b, 0x8d, 0x57, 0x8a, 0x4c, 0x70, 0x2b, 0x6b, 0xf1, 0x1d,\n-    0x5f\n-};\n+    0x04,\n+    0x67,\n+    0x8a,\n+    0xfd,\n+    0xb0,\n+    0xfe,\n+    0x55,\n+    0x48,\n+    0x27,\n+    0x19,\n+    0x67,\n+    0xf1,\n+    0xa6,\n+    0x71,\n+    0x30,\n+    0xb7,\n+    0x10,\n+    0x5c,\n+    0xd6,\n+    0xa8,\n+    0x28,\n+    0xe0,\n+    0x39,\n+    0x09,\n+    0xa6,\n+    0x79,\n+    0x62,\n+    0xe0,\n+    0xea,\n+    0x1f,\n+    0x61,\n+    0xde,\n+    0xb6,\n+    0x49,\n+    0xf6,\n+    0xbc,\n+    0x3f,\n+    0x4c,\n+    0xef,\n+    0x38,\n+    0xc4,\n+    0xf3,\n+    0x55,\n+    0x04,\n+    0xe5,\n+    0x1e,\n+    0xc1,\n+    0x12,\n+    0xde,\n+    0x5c,\n+    0x38,\n+    0x4d,\n+    0xf7,\n+    0xba,\n+    0x0b,\n+    0x8d,\n+    0x57,\n+    0x8a,\n+    0x4c,\n+    0x70,\n+    0x2b,\n+    0x6b,\n+    0xf1,\n+    0x1d,\n+    0x5f};\n BOOST_AUTO_TEST_CASE(util_ParseHex)\n {\n     std::vector<unsigned char> result;\n@@ -97,7 +156,7 @@ BOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n \n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n {\n-    const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n+    const char* argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n \n     ParseParameters(0, (char**)argv_test);\n     BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n@@ -110,10 +169,8 @@ BOOST_AUTO_TEST_CASE(util_ParseParameters)\n     // -a, -b and -ccc end up in map, -d ignored because it is after\n     // a non-option argument (non-GNU option parsing)\n     BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n-    BOOST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\")\n-                && !mapArgs.count(\"f\") && !mapArgs.count(\"-d\"));\n-    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\")\n-                && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n+    BOOST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\") && !mapArgs.count(\"f\") && !mapArgs.count(\"-d\"));\n+    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\") && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n \n     BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n     BOOST_CHECK(mapMultiArgs[\"-ccc\"].size() == 2);\n@@ -146,28 +203,28 @@ BOOST_AUTO_TEST_CASE(util_GetArg)\n BOOST_AUTO_TEST_CASE(util_FormatMoney)\n {\n     BOOST_CHECK_EQUAL(FormatMoney(0, false), \"0.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789, false), \"12345.6789\");\n+    BOOST_CHECK_EQUAL(FormatMoney((COIN / 10000) * 123456789, false), \"12345.6789\");\n     BOOST_CHECK_EQUAL(FormatMoney(COIN, true), \"+1.00\");\n     BOOST_CHECK_EQUAL(FormatMoney(-COIN, false), \"-1.00\");\n     BOOST_CHECK_EQUAL(FormatMoney(-COIN, true), \"-1.00\");\n \n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000000, false), \"100000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000000, false), \"10000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000000, false), \"1000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000, false), \"100000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000, false), \"10000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000, false), \"1000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100, false), \"100.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10, false), \"10.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 100000000, false), \"100000000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 10000000, false), \"10000000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 1000000, false), \"1000000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 100000, false), \"100000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 10000, false), \"10000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 1000, false), \"1000.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 100, false), \"100.00\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN * 10, false), \"10.00\");\n     BOOST_CHECK_EQUAL(FormatMoney(COIN, false), \"1.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10, false), \"0.10\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100, false), \"0.01\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000, false), \"0.001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000, false), \"0.0001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000, false), \"0.00001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000000, false), \"0.000001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000000, false), \"0.0000001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000000, false), \"0.00000001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 10, false), \"0.10\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 100, false), \"0.01\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 1000, false), \"0.001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 10000, false), \"0.0001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 100000, false), \"0.00001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 1000000, false), \"0.000001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 10000000, false), \"0.0000001\");\n+    BOOST_CHECK_EQUAL(FormatMoney(COIN / 100000000, false), \"0.00000001\");\n }\n \n BOOST_AUTO_TEST_CASE(util_ParseMoney)\n@@ -177,42 +234,42 @@ BOOST_AUTO_TEST_CASE(util_ParseMoney)\n     BOOST_CHECK_EQUAL(ret, 0);\n \n     BOOST_CHECK(ParseMoney(\"12345.6789\", ret));\n-    BOOST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n+    BOOST_CHECK_EQUAL(ret, (COIN / 10000) * 123456789);\n \n     BOOST_CHECK(ParseMoney(\"100000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 100000000);\n     BOOST_CHECK(ParseMoney(\"10000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 10000000);\n     BOOST_CHECK(ParseMoney(\"1000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 1000000);\n     BOOST_CHECK(ParseMoney(\"100000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 100000);\n     BOOST_CHECK(ParseMoney(\"10000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 10000);\n     BOOST_CHECK(ParseMoney(\"1000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000);\n+    BOOST_CHECK_EQUAL(ret, COIN * 1000);\n     BOOST_CHECK(ParseMoney(\"100.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100);\n+    BOOST_CHECK_EQUAL(ret, COIN * 100);\n     BOOST_CHECK(ParseMoney(\"10.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10);\n+    BOOST_CHECK_EQUAL(ret, COIN * 10);\n     BOOST_CHECK(ParseMoney(\"1.00\", ret));\n     BOOST_CHECK_EQUAL(ret, COIN);\n     BOOST_CHECK(ParseMoney(\"0.1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10);\n+    BOOST_CHECK_EQUAL(ret, COIN / 10);\n     BOOST_CHECK(ParseMoney(\"0.01\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100);\n+    BOOST_CHECK_EQUAL(ret, COIN / 100);\n     BOOST_CHECK(ParseMoney(\"0.001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 1000);\n     BOOST_CHECK(ParseMoney(\"0.0001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 10000);\n     BOOST_CHECK(ParseMoney(\"0.00001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 100000);\n     BOOST_CHECK(ParseMoney(\"0.000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 1000000);\n     BOOST_CHECK(ParseMoney(\"0.0000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 10000000);\n     BOOST_CHECK(ParseMoney(\"0.00000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n+    BOOST_CHECK_EQUAL(ret, COIN / 100000000);\n \n     // Attempted 63 bit overflow should fail\n     BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n@@ -236,30 +293,29 @@ BOOST_AUTO_TEST_CASE(util_IsHex)\n BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n {\n     int i;\n-    int count=0;\n+    int count = 0;\n \n     seed_insecure_rand(true);\n \n-    for (int mod=2;mod<11;mod++)\n-    {\n+    for (int mod = 2; mod < 11; mod++) {\n         int mask = 1;\n         // Really rough binomal confidence approximation.\n-        int err = 30*10000./mod*sqrt((1./mod*(1-1./mod))/10000.);\n+        int err = 30 * 10000. / mod * sqrt((1. / mod * (1 - 1. / mod)) / 10000.);\n         //mask is 2^ceil(log2(mod))-1\n-        while(mask<mod-1)mask=(mask<<1)+1;\n+        while (mask < mod - 1)\n+            mask = (mask << 1) + 1;\n \n         count = 0;\n         //How often does it get a zero from the uniform range [0,mod)?\n-        for (i=0;i<10000;i++)\n-        {\n+        for (i = 0; i < 10000; i++) {\n             uint32_t rval;\n-            do{\n-                rval=insecure_rand()&mask;\n-            }while(rval>=(uint32_t)mod);\n-            count += rval==0;\n+            do {\n+                rval = insecure_rand() & mask;\n+            } while (rval >= (uint32_t)mod);\n+            count += rval == 0;\n         }\n-        BOOST_CHECK(count<=10000/mod+err);\n-        BOOST_CHECK(count>=10000/mod-err);\n+        BOOST_CHECK(count <= 10000 / mod + err);\n+        BOOST_CHECK(count >= 10000 / mod - err);\n     }\n }\n \n@@ -280,23 +336,23 @@ BOOST_AUTO_TEST_CASE(util_TimingResistantEqual)\n #define E \"check_postfix\"\n BOOST_AUTO_TEST_CASE(strprintf_numbers)\n {\n-    int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n+    int64_t s64t = -9223372036854775807LL;   /* signed 64 bit test value */\n     uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B\" -9223372036854775807 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B\" 18446744073709551615 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B\" ffffffffffffffff \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B \" -9223372036854775807 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B \" 18446744073709551615 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B \" ffffffffffffffff \" E);\n \n-    size_t st = 12345678; /* unsigned size_t test value */\n+    size_t st = 12345678;    /* unsigned size_t test value */\n     ssize_t sst = -12345678; /* signed size_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B\" -12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B\" 12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B\" bc614e \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B \" -12345678 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B \" 12345678 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B \" bc614e \" E);\n \n-    ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n+    ptrdiff_t pt = 87654321;   /* positive ptrdiff_t test value */\n     ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B\" -87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B\" 87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B\" 5397fb1 \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B \" -87654321 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B \" 87654321 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B \" 5397fb1 \" E);\n }\n #undef B\n #undef E\n@@ -349,8 +405,8 @@ BOOST_AUTO_TEST_CASE(test_FormatSubVersion)\n     std::vector<std::string> comments2;\n     comments2.push_back(std::string(\"comment1\"));\n     comments2.push_back(std::string(\"comment2\"));\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, std::vector<std::string>()),std::string(\"/Test:0.9.99/\"));\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments),std::string(\"/Test:0.9.99(comment1)/\"));\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments2),std::string(\"/Test:0.9.99(comment1; comment2)/\"));\n+    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, std::vector<std::string>()), std::string(\"/Test:0.9.99/\"));\n+    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments), std::string(\"/Test:0.9.99(comment1)/\"));\n+    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments2), std::string(\"/Test:0.9.99(comment1; comment2)/\"));\n }\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "aca5614efff43c6fe29241df3b28dcb48b3f19bd",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 77,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -21,28 +21,27 @@\n \n using namespace std;\n \n-typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+typedef set<pair<const CWalletTx*, unsigned int> > CoinSet;\n \n BOOST_AUTO_TEST_SUITE(wallet_tests)\n \n static CWallet wallet;\n static vector<COutput> vCoins;\n \n-static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+static void add_coin(const CAmount& nValue, int nAge = 6 * 24, bool fIsFromMe = false, int nInput = 0)\n {\n     static int nextLockTime = 0;\n     CMutableTransaction tx;\n-    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n-    tx.vout.resize(nInput+1);\n+    tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n+    tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n     if (fIsFromMe) {\n         // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n         // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n         tx.vin.resize(1);\n     }\n     CWalletTx* wtx = new CWalletTx(&wallet, tx);\n-    if (fIsFromMe)\n-    {\n+    if (fIsFromMe) {\n         wtx->fDebitCached = true;\n         wtx->nDebitCached = 1;\n     }\n@@ -52,7 +51,7 @@ static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = fa\n \n static void empty_wallet(void)\n {\n-    BOOST_FOREACH(COutput output, vCoins)\n+    BOOST_FOREACH (COutput output, vCoins)\n         delete output.tx;\n     vCoins.clear();\n }\n@@ -71,34 +70,33 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n     LOCK(wallet.cs_wallet);\n \n     // test multiple times to allow for differences in the shuffle order\n-    for (int i = 0; i < RUN_TESTS; i++)\n-    {\n+    for (int i = 0; i < RUN_TESTS; i++) {\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n \n-        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+        add_coin(1 * CENT, 4); // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n-        add_coin(2*CENT);           // add a mature 2 cent coin\n+        add_coin(2 * CENT); // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n \n         // we can make 3 cents of new  coins\n-        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n-        add_coin(5*CENT);           // add a mature 5 cent coin,\n-        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n-        add_coin(20*CENT);          // and a mature 20 cent coin\n+        add_coin(5 * CENT);           // add a mature 5 cent coin,\n+        add_coin(10 * CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20 * CENT);          // and a mature 20 cent coin\n \n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n@@ -107,108 +105,108 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n         BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_GT(nValueRet, 34 * CENT);      // but should get more than 34 cents\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U); // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n         empty_wallet();\n \n-        add_coin( 6*CENT);\n-        add_coin( 7*CENT);\n-        add_coin( 8*CENT);\n-        add_coin(20*CENT);\n-        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+        add_coin(6 * CENT);\n+        add_coin(7 * CENT);\n+        add_coin(8 * CENT);\n+        add_coin(20 * CENT);\n+        add_coin(30 * CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+        add_coin(5 * CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n-        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+        add_coin(18 * CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);   // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // check that the smallest bigger coin is used\n-        add_coin( 1*COIN);\n-        add_coin( 2*COIN);\n-        add_coin( 3*COIN);\n-        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n+        add_coin(1 * COIN);\n+        add_coin(2 * COIN);\n+        add_coin(3 * COIN);\n+        add_coin(4 * COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN); // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN); // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         // empty the wallet and start again, now with fractions of a cent, to test sub-cent change avoidance\n         empty_wallet();\n-        add_coin(0.1*CENT);\n-        add_coin(0.2*CENT);\n-        add_coin(0.3*CENT);\n-        add_coin(0.4*CENT);\n-        add_coin(0.5*CENT);\n+        add_coin(0.1 * CENT);\n+        add_coin(0.2 * CENT);\n+        add_coin(0.3 * CENT);\n+        add_coin(0.4 * CENT);\n+        add_coin(0.5 * CENT);\n \n         // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 = 1.5 cents\n         // we'll get sub-cent change whatever happens, so can expect 1.0 exactly\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         // but if we add a bigger coin, making it possible to avoid sub-cent change, things change:\n-        add_coin(1111*CENT);\n+        add_coin(1111 * CENT);\n \n         // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // if we add more sub-cent coins:\n-        add_coin(0.6*CENT);\n-        add_coin(0.7*CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.7 * CENT);\n \n         // and try again to make 1.0 cents, we can still make 1.0 cents\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -217,9 +215,9 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         for (int i = 0; i < 20; i++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U);  // in ten coins\n \n         // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n         // we need to try finding an exact subset anyway\n@@ -230,7 +228,7 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(0.6 * CENT);\n         add_coin(0.7 * CENT);\n         add_coin(1111 * CENT);\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -240,8 +238,8 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(0.6 * CENT);\n         add_coin(0.8 * CENT);\n         add_coin(1111 * CENT);\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);   // we should get the exact amount\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);    // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n         // test avoiding sub-cent change\n@@ -251,13 +249,13 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(1 * COIN);\n \n         // trying to make 1.0001 from these three coins\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(1.0001 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1.0105 * COIN);   // we should get all coins\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(1.0001 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.0105 * COIN); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 0.999, we should take the bigger of the two small coins to avoid sub-cent change\n-        BOOST_CHECK( wallet.SelectCoinsMinConf(0.999 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1.01 * COIN);   // we should get 1 + 0.01\n+        BOOST_CHECK(wallet.SelectCoinsMinConf(0.999 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.01 * COIN); // we should get 1 + 0.01\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // test randomness\n@@ -268,16 +266,15 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n \n             // picking 50 from 100 coins doesn't depend on the shuffle,\n             // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n             BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n             BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n \n             int fails = 0;\n-            for (int i = 0; i < RANDOM_REPEATS; i++)\n-            {\n+            for (int i = 0; i < RANDOM_REPEATS; i++) {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n                 BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n@@ -287,15 +284,18 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n             // add 75 cents in small change.  not enough to make 90 cents,\n             // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n             // one of which should be picked at random\n-            add_coin( 5*CENT); add_coin(10*CENT); add_coin(15*CENT); add_coin(20*CENT); add_coin(25*CENT);\n+            add_coin(5 * CENT);\n+            add_coin(10 * CENT);\n+            add_coin(15 * CENT);\n+            add_coin(20 * CENT);\n+            add_coin(25 * CENT);\n \n             fails = 0;\n-            for (int i = 0; i < RANDOM_REPEATS; i++)\n-            {\n+            for (int i = 0; i < RANDOM_REPEATS; i++) {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90 * CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }"
      },
      {
        "sha": "a08ee20f1847c407606dfa194abca839d6614932",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -51,9 +51,9 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n         return;\n \n     // Add data\n-    static CMedianFilter<int64_t> vTimeOffsets(200,0);\n+    static CMedianFilter<int64_t> vTimeOffsets(200, 0);\n     vTimeOffsets.input(nOffsetSample);\n-    LogPrintf(\"Added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    LogPrintf(\"Added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample / 60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -72,30 +72,24 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n     // So we should hold off on fixing this and clean it up as part of\n     // a timing cleanup that strengthens it in a number of other ways.\n     //\n-    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n+    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1) {\n         int64_t nMedian = vTimeOffsets.median();\n         std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n         // Only let other nodes change our time by so much\n-        if (abs64(nMedian) < 70 * 60)\n-        {\n+        if (abs64(nMedian) < 70 * 60) {\n             nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n+        } else {\n             nTimeOffset = 0;\n \n             static bool fDone;\n-            if (!fDone)\n-            {\n+            if (!fDone) {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n-                BOOST_FOREACH(int64_t nOffset, vSorted)\n+                BOOST_FOREACH (int64_t nOffset, vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n-                if (!fMatch)\n-                {\n+                if (!fMatch) {\n                     fDone = true;\n                     string strMessage = _(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin Core will not work properly.\");\n                     strMiscWarning = strMessage;\n@@ -105,10 +99,10 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n             }\n         }\n         if (fDebug) {\n-            BOOST_FOREACH(int64_t n, vSorted)\n+            BOOST_FOREACH (int64_t n, vSorted)\n                 LogPrintf(\"%+d  \", n);\n             LogPrintf(\"|  \");\n         }\n-        LogPrintf(\"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+        LogPrintf(\"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset / 60);\n     }\n }"
      },
      {
        "sha": "e6cc2182fdd5ad25f4d3715713b305fb7d8110fd",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 40,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -14,36 +14,43 @@\n \n using namespace std;\n \n-void static BatchWriteCoins(CLevelDBBatch &batch, const uint256 &hash, const CCoins &coins) {\n+void static BatchWriteCoins(CLevelDBBatch& batch, const uint256& hash, const CCoins& coins)\n+{\n     if (coins.IsPruned())\n         batch.Erase(make_pair('c', hash));\n     else\n         batch.Write(make_pair('c', hash), coins);\n }\n \n-void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n+void static BatchWriteHashBestChain(CLevelDBBatch& batch, const uint256& hash)\n+{\n     batch.Write('B', hash);\n }\n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe) {\n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe)\n+{\n }\n \n-bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewDB::GetCoins(const uint256& txid, CCoins& coins) const\n+{\n     return db.Read(make_pair('c', txid), coins);\n }\n \n-bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n+bool CCoinsViewDB::HaveCoins(const uint256& txid) const\n+{\n     return db.Exists(make_pair('c', txid));\n }\n \n-uint256 CCoinsViewDB::GetBestBlock() const {\n+uint256 CCoinsViewDB::GetBestBlock() const\n+{\n     uint256 hashBestChain;\n     if (!db.Read('B', hashBestChain))\n         return uint256(0);\n     return hashBestChain;\n }\n \n-bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n+bool CCoinsViewDB::BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock)\n+{\n     CLevelDBBatch batch;\n     size_t count = 0;\n     size_t changed = 0;\n@@ -63,43 +70,51 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CLevelDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CLevelDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe)\n+{\n }\n \n bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n {\n     return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n }\n \n-bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo& info)\n+{\n     return Write(make_pair('f', nFile), info);\n }\n \n-bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n     return Read(make_pair('f', nFile), info);\n }\n \n-bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n+bool CBlockTreeDB::WriteLastBlockFile(int nFile)\n+{\n     return Write('l', nFile);\n }\n \n-bool CBlockTreeDB::WriteReindexing(bool fReindexing) {\n+bool CBlockTreeDB::WriteReindexing(bool fReindexing)\n+{\n     if (fReindexing)\n         return Write('R', '1');\n     else\n         return Erase('R');\n }\n \n-bool CBlockTreeDB::ReadReindexing(bool &fReindexing) {\n+bool CBlockTreeDB::ReadReindexing(bool& fReindexing)\n+{\n     fReindexing = Exists('R');\n     return true;\n }\n \n-bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n+bool CBlockTreeDB::ReadLastBlockFile(int& nFile)\n+{\n     return Read('l', nFile);\n }\n \n-bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n+bool CCoinsViewDB::GetStats(CCoinsStats& stats) const\n+{\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n@@ -114,12 +129,12 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n         boost::this_thread::interruption_point();\n         try {\n             leveldb::Slice slKey = pcursor->key();\n-            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            CDataStream ssKey(slKey.data(), slKey.data() + slKey.size(), SER_DISK, CLIENT_VERSION);\n             char chType;\n             ssKey >> chType;\n             if (chType == 'c') {\n                 leveldb::Slice slValue = pcursor->value();\n-                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                CDataStream ssValue(slValue.data(), slValue.data() + slValue.size(), SER_DISK, CLIENT_VERSION);\n                 CCoins coins;\n                 ssValue >> coins;\n                 uint256 txhash;\n@@ -129,11 +144,11 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n                 ss << (coins.fCoinBase ? 'c' : 'n');\n                 ss << VARINT(coins.nHeight);\n                 stats.nTransactions++;\n-                for (unsigned int i=0; i<coins.vout.size(); i++) {\n-                    const CTxOut &out = coins.vout[i];\n+                for (unsigned int i = 0; i < coins.vout.size(); i++) {\n+                    const CTxOut& out = coins.vout[i];\n                     if (!out.IsNull()) {\n                         stats.nTransactionOutputs++;\n-                        ss << VARINT(i+1);\n+                        ss << VARINT(i + 1);\n                         ss << out;\n                         nTotalAmount += out.nValue;\n                     }\n@@ -142,7 +157,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n                 ss << VARINT(0);\n             }\n             pcursor->Next();\n-        } catch (std::exception &e) {\n+        } catch (std::exception& e) {\n             return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n         }\n     }\n@@ -152,22 +167,26 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n     return true;\n }\n \n-bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n+bool CBlockTreeDB::ReadTxIndex(const uint256& txid, CDiskTxPos& pos)\n+{\n     return Read(make_pair('t', txid), pos);\n }\n \n-bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n+bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >& vect)\n+{\n     CLevelDBBatch batch;\n-    for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+    for (std::vector<std::pair<uint256, CDiskTxPos> >::const_iterator it = vect.begin(); it != vect.end(); it++)\n         batch.Write(make_pair('t', it->first), it->second);\n     return WriteBatch(batch);\n }\n \n-bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n+bool CBlockTreeDB::WriteFlag(const std::string& name, bool fValue)\n+{\n     return Write(std::make_pair('F', name), fValue ? '1' : '0');\n }\n \n-bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n+bool CBlockTreeDB::ReadFlag(const std::string& name, bool& fValue)\n+{\n     char ch;\n     if (!Read(std::make_pair('F', name), ch))\n         return false;\n@@ -188,29 +207,29 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n         boost::this_thread::interruption_point();\n         try {\n             leveldb::Slice slKey = pcursor->key();\n-            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            CDataStream ssKey(slKey.data(), slKey.data() + slKey.size(), SER_DISK, CLIENT_VERSION);\n             char chType;\n             ssKey >> chType;\n             if (chType == 'b') {\n                 leveldb::Slice slValue = pcursor->value();\n-                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                CDataStream ssValue(slValue.data(), slValue.data() + slValue.size(), SER_DISK, CLIENT_VERSION);\n                 CDiskBlockIndex diskindex;\n                 ssValue >> diskindex;\n \n                 // Construct block index object\n                 CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-                pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-                pindexNew->nHeight        = diskindex.nHeight;\n-                pindexNew->nFile          = diskindex.nFile;\n-                pindexNew->nDataPos       = diskindex.nDataPos;\n-                pindexNew->nUndoPos       = diskindex.nUndoPos;\n-                pindexNew->nVersion       = diskindex.nVersion;\n+                pindexNew->pprev = InsertBlockIndex(diskindex.hashPrev);\n+                pindexNew->nHeight = diskindex.nHeight;\n+                pindexNew->nFile = diskindex.nFile;\n+                pindexNew->nDataPos = diskindex.nDataPos;\n+                pindexNew->nUndoPos = diskindex.nUndoPos;\n+                pindexNew->nVersion = diskindex.nVersion;\n                 pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-                pindexNew->nTime          = diskindex.nTime;\n-                pindexNew->nBits          = diskindex.nBits;\n-                pindexNew->nNonce         = diskindex.nNonce;\n-                pindexNew->nStatus        = diskindex.nStatus;\n-                pindexNew->nTx            = diskindex.nTx;\n+                pindexNew->nTime = diskindex.nTime;\n+                pindexNew->nBits = diskindex.nBits;\n+                pindexNew->nNonce = diskindex.nNonce;\n+                pindexNew->nStatus = diskindex.nStatus;\n+                pindexNew->nTx = diskindex.nTx;\n \n                 if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits))\n                     return error(\"LoadBlockIndex() : CheckProofOfWork failed: %s\", pindexNew->ToString());\n@@ -219,7 +238,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n             } else {\n                 break; // if shutdown requested or finished loading block index\n             }\n-        } catch (std::exception &e) {\n+        } catch (std::exception& e) {\n             return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n         }\n     }"
      },
      {
        "sha": "4921d8ba0c42a0cd5ef3a1d7ddabae62df0077fc",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 100,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -15,16 +15,12 @@\n \n using namespace std;\n \n-CTxMemPoolEntry::CTxMemPoolEntry():\n-    nFee(0), nTxSize(0), nModSize(0), nTime(0), dPriority(0.0)\n+CTxMemPoolEntry::CTxMemPoolEntry() : nFee(0), nTxSize(0), nModSize(0), nTime(0), dPriority(0.0)\n {\n     nHeight = MEMPOOL_HEIGHT;\n }\n \n-CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n-                                 int64_t _nTime, double _dPriority,\n-                                 unsigned int _nHeight):\n-    tx(_tx), nFee(_nFee), nTime(_nTime), dPriority(_dPriority), nHeight(_nHeight)\n+CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee, int64_t _nTime, double _dPriority, unsigned int _nHeight) : tx(_tx), nFee(_nFee), nTime(_nTime), dPriority(_dPriority), nHeight(_nHeight)\n {\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n \n@@ -39,8 +35,8 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n double\n CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n {\n-    CAmount nValueIn = tx.GetValueOut()+nFee;\n-    double deltaPriority = ((double)(currentHeight-nHeight)*nValueIn)/nModSize;\n+    CAmount nValueIn = tx.GetValueOut() + nFee;\n+    double deltaPriority = ((double)(currentHeight - nHeight) * nValueIn) / nModSize;\n     double dResult = dPriority + deltaPriority;\n     return dResult;\n }\n@@ -54,34 +50,37 @@ class CBlockAverage\n     boost::circular_buffer<CFeeRate> feeSamples;\n     boost::circular_buffer<double> prioritySamples;\n \n-    template<typename T> std::vector<T> buf2vec(boost::circular_buffer<T> buf) const\n+    template <typename T>\n+    std::vector<T> buf2vec(boost::circular_buffer<T> buf) const\n     {\n         std::vector<T> vec(buf.begin(), buf.end());\n         return vec;\n     }\n \n public:\n-    CBlockAverage() : feeSamples(100), prioritySamples(100) { }\n+    CBlockAverage() : feeSamples(100), prioritySamples(100) {}\n \n-    void RecordFee(const CFeeRate& feeRate) {\n+    void RecordFee(const CFeeRate& feeRate)\n+    {\n         feeSamples.push_back(feeRate);\n     }\n \n-    void RecordPriority(double priority) {\n+    void RecordPriority(double priority)\n+    {\n         prioritySamples.push_back(priority);\n     }\n \n     size_t FeeSamples() const { return feeSamples.size(); }\n     size_t GetFeeSamples(std::vector<CFeeRate>& insertInto) const\n     {\n-        BOOST_FOREACH(const CFeeRate& f, feeSamples)\n+        BOOST_FOREACH (const CFeeRate& f, feeSamples)\n             insertInto.push_back(f);\n         return feeSamples.size();\n     }\n     size_t PrioritySamples() const { return prioritySamples.size(); }\n     size_t GetPrioritySamples(std::vector<double>& insertInto) const\n     {\n-        BOOST_FOREACH(double d, prioritySamples)\n+        BOOST_FOREACH (double d, prioritySamples)\n             insertInto.push_back(d);\n         return prioritySamples.size();\n     }\n@@ -92,8 +91,7 @@ class CBlockAverage\n      */\n     bool AreSane(const std::vector<CFeeRate>& vecFee, const CFeeRate& minRelayFee)\n     {\n-        BOOST_FOREACH(CFeeRate fee, vecFee)\n-        {\n+        BOOST_FOREACH (CFeeRate fee, vecFee) {\n             if (fee < CFeeRate(0))\n                 return false;\n             if (fee.GetFeePerK() > minRelayFee.GetFeePerK() * 10000)\n@@ -103,8 +101,7 @@ class CBlockAverage\n     }\n     bool AreSane(const std::vector<double> vecPriority)\n     {\n-        BOOST_FOREACH(double priority, vecPriority)\n-        {\n+        BOOST_FOREACH (double priority, vecPriority) {\n             if (priority < 0)\n                 return false;\n         }\n@@ -119,7 +116,8 @@ class CBlockAverage\n         fileout << vecPriority;\n     }\n \n-    void Read(CAutoFile& filein, const CFeeRate& minRelayFee) {\n+    void Read(CAutoFile& filein, const CFeeRate& minRelayFee)\n+    {\n         std::vector<CFeeRate> vecFee;\n         filein >> vecFee;\n         if (AreSane(vecFee, minRelayFee))\n@@ -133,8 +131,7 @@ class CBlockAverage\n         else\n             throw runtime_error(\"Corrupt priority value in estimates file.\");\n         if (feeSamples.size() + prioritySamples.size() > 0)\n-            LogPrint(\"estimatefee\", \"Read %d fee samples and %d priority samples\\n\",\n-                     feeSamples.size(), prioritySamples.size());\n+            LogPrint(\"estimatefee\", \"Read %d fee samples and %d priority samples\\n\", feeSamples.size(), prioritySamples.size());\n     }\n };\n \n@@ -158,31 +155,25 @@ class CMinerPolicyEstimator\n     void seenTxConfirm(const CFeeRate& feeRate, const CFeeRate& minRelayFee, double dPriority, int nBlocksAgo)\n     {\n         // Last entry records \"everything else\".\n-        int nBlocksTruncated = min(nBlocksAgo, (int) history.size() - 1);\n+        int nBlocksTruncated = min(nBlocksAgo, (int)history.size() - 1);\n         assert(nBlocksTruncated >= 0);\n \n         // We need to guess why the transaction was included in a block-- either\n         // because it is high-priority or because it has sufficient fees.\n         bool sufficientFee = (feeRate > minRelayFee);\n         bool sufficientPriority = AllowFree(dPriority);\n         const char* assignedTo = \"unassigned\";\n-        if (sufficientFee && !sufficientPriority)\n-        {\n+        if (sufficientFee && !sufficientPriority) {\n             history[nBlocksTruncated].RecordFee(feeRate);\n             assignedTo = \"fee\";\n-        }\n-        else if (sufficientPriority && !sufficientFee)\n-        {\n+        } else if (sufficientPriority && !sufficientFee) {\n             history[nBlocksTruncated].RecordPriority(dPriority);\n             assignedTo = \"priority\";\n-        }\n-        else\n-        {\n+        } else {\n             // Neither or both fee and priority sufficient to get confirmed:\n             // don't know why they got confirmed.\n         }\n-        LogPrint(\"estimatefee\", \"Seen TX confirm: %s : %s fee/%g priority, took %d blocks\\n\",\n-                 assignedTo, feeRate.ToString(), dPriority, nBlocksAgo);\n+        LogPrint(\"estimatefee\", \"Seen TX confirm: %s : %s fee/%g priority, took %d blocks\\n\", assignedTo, feeRate.ToString(), dPriority, nBlocksAgo);\n     }\n \n public:\n@@ -193,8 +184,7 @@ class CMinerPolicyEstimator\n \n     void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight, const CFeeRate minRelayFee)\n     {\n-        if (nBlockHeight <= nBestSeenHeight)\n-        {\n+        if (nBlockHeight <= nBestSeenHeight) {\n             // Ignore side chains and re-orgs; assuming they are random\n             // they don't affect the estimate.\n             // And if an attacker can re-org the chain at will, then\n@@ -208,31 +198,27 @@ class CMinerPolicyEstimator\n         // to confirm.\n         std::vector<std::vector<const CTxMemPoolEntry*> > entriesByConfirmations;\n         entriesByConfirmations.resize(history.size());\n-        BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)\n-        {\n+        BOOST_FOREACH (const CTxMemPoolEntry& entry, entries) {\n             // How many blocks did it take for miners to include this transaction?\n             int delta = nBlockHeight - entry.GetHeight();\n-            if (delta <= 0)\n-            {\n+            if (delta <= 0) {\n                 // Re-org made us lose height, this should only happen if we happen\n                 // to re-org on a difficulty transition point: very rare!\n                 continue;\n             }\n-            if ((delta-1) >= (int)history.size())\n+            if ((delta - 1) >= (int)history.size())\n                 delta = history.size(); // Last bucket is catch-all\n-            entriesByConfirmations.at(delta-1).push_back(&entry);\n+            entriesByConfirmations.at(delta - 1).push_back(&entry);\n         }\n-        for (size_t i = 0; i < entriesByConfirmations.size(); i++)\n-        {\n-            std::vector<const CTxMemPoolEntry*> &e = entriesByConfirmations.at(i);\n+        for (size_t i = 0; i < entriesByConfirmations.size(); i++) {\n+            std::vector<const CTxMemPoolEntry*>& e = entriesByConfirmations.at(i);\n             // Insert at most 10 random entries per bucket, otherwise a single block\n             // can dominate an estimate:\n             if (e.size() > 10) {\n                 std::random_shuffle(e.begin(), e.end());\n                 e.resize(10);\n             }\n-            BOOST_FOREACH(const CTxMemPoolEntry* entry, e)\n-            {\n+            BOOST_FOREACH (const CTxMemPoolEntry* entry, e) {\n                 // Fees are stored and reported as BTC-per-kb:\n                 CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n                 double dPriority = entry->GetPriority(entry->GetHeight()); // Want priority when it went IN\n@@ -247,10 +233,7 @@ class CMinerPolicyEstimator\n \n         for (size_t i = 0; i < history.size(); i++) {\n             if (history[i].FeeSamples() + history[i].PrioritySamples() > 0)\n-                LogPrint(\"estimatefee\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%s, prio=%g\\n\", \n-                         i,\n-                         history[i].FeeSamples(), history[i].PrioritySamples(),\n-                         estimateFee(i+1).ToString(), estimatePriority(i+1));\n+                LogPrint(\"estimatefee\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%s, prio=%g\\n\", i, history[i].FeeSamples(), history[i].PrioritySamples(), estimateFee(i + 1).ToString(), estimatePriority(i + 1));\n         }\n     }\n \n@@ -264,15 +247,12 @@ class CMinerPolicyEstimator\n         if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n             return CFeeRate(0);\n \n-        if (sortedFeeSamples.size() == 0)\n-        {\n+        if (sortedFeeSamples.size() == 0) {\n             for (size_t i = 0; i < history.size(); i++)\n                 history.at(i).GetFeeSamples(sortedFeeSamples);\n-            std::sort(sortedFeeSamples.begin(), sortedFeeSamples.end(),\n-                      std::greater<CFeeRate>());\n+            std::sort(sortedFeeSamples.begin(), sortedFeeSamples.end(), std::greater<CFeeRate>());\n         }\n-        if (sortedFeeSamples.size() < 11)\n-        {\n+        if (sortedFeeSamples.size() < 11) {\n             // Eleven is Gavin's Favorite Number\n             // ... but we also take a maximum of 10 samples per block so eleven means\n             // we're getting samples from at least two different blocks\n@@ -289,7 +269,7 @@ class CMinerPolicyEstimator\n         size_t nPrevSize = 0;\n         for (int i = 0; i < nBlocksToConfirm; i++)\n             nPrevSize += history.at(i).FeeSamples();\n-        size_t index = min(nPrevSize + nBucketSize/2, sortedFeeSamples.size()-1);\n+        size_t index = min(nPrevSize + nBucketSize / 2, sortedFeeSamples.size() - 1);\n         return sortedFeeSamples[index];\n     }\n     double estimatePriority(int nBlocksToConfirm)\n@@ -299,12 +279,10 @@ class CMinerPolicyEstimator\n         if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n             return -1;\n \n-        if (sortedPrioritySamples.size() == 0)\n-        {\n+        if (sortedPrioritySamples.size() == 0) {\n             for (size_t i = 0; i < history.size(); i++)\n                 history.at(i).GetPrioritySamples(sortedPrioritySamples);\n-            std::sort(sortedPrioritySamples.begin(), sortedPrioritySamples.end(),\n-                      std::greater<double>());\n+            std::sort(sortedPrioritySamples.begin(), sortedPrioritySamples.end(), std::greater<double>());\n         }\n         if (sortedPrioritySamples.size() < 11)\n             return -1.0;\n@@ -319,16 +297,15 @@ class CMinerPolicyEstimator\n         size_t nPrevSize = 0;\n         for (int i = 0; i < nBlocksToConfirm; i++)\n             nPrevSize += history.at(i).PrioritySamples();\n-        size_t index = min(nPrevSize + nBucketSize/2, sortedPrioritySamples.size()-1);\n+        size_t index = min(nPrevSize + nBucketSize / 2, sortedPrioritySamples.size() - 1);\n         return sortedPrioritySamples[index];\n     }\n \n     void Write(CAutoFile& fileout) const\n     {\n         fileout << nBestSeenHeight;\n         fileout << history.size();\n-        BOOST_FOREACH(const CBlockAverage& entry, history)\n-        {\n+        BOOST_FOREACH (const CBlockAverage& entry, history) {\n             entry.Write(fileout);\n         }\n     }\n@@ -343,9 +320,8 @@ class CMinerPolicyEstimator\n             throw runtime_error(\"Corrupt estimates file. Must have between 1 and 10k entries.\");\n \n         std::vector<CBlockAverage> fileHistory;\n-        \n-        for (size_t i = 0; i < numEntries; i++)\n-        {\n+\n+        for (size_t i = 0; i < numEntries; i++) {\n             CBlockAverage entry;\n             entry.Read(filein, minRelayFee);\n             fileHistory.push_back(entry);\n@@ -360,9 +336,8 @@ class CMinerPolicyEstimator\n };\n \n \n-CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n-    nTransactionsUpdated(0),\n-    minRelayFee(_minRelayFee)\n+CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) : nTransactionsUpdated(0),\n+                                                       minRelayFee(_minRelayFee)\n {\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n@@ -382,7 +357,7 @@ CTxMemPool::~CTxMemPool()\n     delete minerPolicyEstimator;\n }\n \n-void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+void CTxMemPool::pruneSpent(const uint256& hashTx, CCoins& coins)\n {\n     LOCK(cs);\n \n@@ -408,7 +383,7 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n }\n \n \n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry& entry)\n {\n     // Add to memory pool without checking anything.\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n@@ -426,7 +401,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry)\n }\n \n \n-void CTxMemPool::remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive)\n+void CTxMemPool::remove(const CTransaction& tx, std::list<CTransaction>& removed, bool fRecursive)\n {\n     // Remove transaction from memory pool\n     {\n@@ -440,10 +415,9 @@ void CTxMemPool::remove(const CTransaction &tx, std::list<CTransaction>& removed\n                 remove(*it->second.ptx, removed, true);\n             }\n         }\n-        if (mapTx.count(hash))\n-        {\n+        if (mapTx.count(hash)) {\n             removed.push_front(tx);\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+            BOOST_FOREACH (const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n \n             totalTxSize -= mapTx[hash].GetTxSize();\n@@ -453,17 +427,16 @@ void CTxMemPool::remove(const CTransaction &tx, std::list<CTransaction>& removed\n     }\n }\n \n-void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed)\n+void CTxMemPool::removeConflicts(const CTransaction& tx, std::list<CTransaction>& removed)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n     list<CTransaction> result;\n     LOCK(cs);\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n         std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n-            const CTransaction &txConflict = *it->second.ptx;\n-            if (txConflict != tx)\n-            {\n+            const CTransaction& txConflict = *it->second.ptx;\n+            if (txConflict != tx) {\n                 remove(txConflict, removed, true);\n             }\n         }\n@@ -473,20 +446,17 @@ void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>\n /**\n  * Called when a block is connected. Removes from mempool and updates the miner fee estimator.\n  */\n-void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight,\n-                                std::list<CTransaction>& conflicts)\n+void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight, std::list<CTransaction>& conflicts)\n {\n     LOCK(cs);\n     std::vector<CTxMemPoolEntry> entries;\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-    {\n+    BOOST_FOREACH (const CTransaction& tx, vtx) {\n         uint256 hash = tx.GetHash();\n         if (mapTx.count(hash))\n             entries.push_back(mapTx[hash]);\n     }\n     minerPolicyEstimator->seenBlock(entries, nBlockHeight, minRelayFee);\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-    {\n+    BOOST_FOREACH (const CTransaction& tx, vtx) {\n         std::list<CTransaction> dummy;\n         remove(tx, dummy, false);\n         removeConflicts(tx, conflicts);\n@@ -504,7 +474,7 @@ void CTxMemPool::clear()\n     ++nTransactionsUpdated;\n }\n \n-void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n+void CTxMemPool::check(const CCoinsViewCache* pcoins) const\n {\n     if (!fSanityCheck)\n         return;\n@@ -518,7 +488,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         unsigned int i = 0;\n         checkTotal += it->second.GetTxSize();\n         const CTransaction& tx = it->second.GetTx();\n-        BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+        BOOST_FOREACH (const CTxIn& txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n@@ -563,7 +533,8 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n {\n     LOCK(cs);\n     map<uint256, CTxMemPoolEntry>::const_iterator i = mapTx.find(hash);\n-    if (i == mapTx.end()) return false;\n+    if (i == mapTx.end())\n+        return false;\n     result = i->second.GetTx();\n     return true;\n }\n@@ -584,11 +555,10 @@ CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n {\n     try {\n         LOCK(cs);\n-        fileout << 99900; // version required to read: 0.9.99 or later\n+        fileout << 99900;          // version required to read: 0.9.99 or later\n         fileout << CLIENT_VERSION; // version that wrote the file\n         minerPolicyEstimator->Write(fileout);\n-    }\n-    catch (const std::exception &) {\n+    } catch (const std::exception&) {\n         LogPrintf(\"CTxMemPool::WriteFeeEstimates() : unable to write policy estimator data (non-fatal)\");\n         return false;\n     }\n@@ -606,8 +576,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n \n         LOCK(cs);\n         minerPolicyEstimator->Read(filein, minRelayFee);\n-    }\n-    catch (const std::exception &) {\n+    } catch (const std::exception&) {\n         LogPrintf(\"CTxMemPool::ReadFeeEstimates() : unable to read policy estimator data (non-fatal)\");\n         return false;\n     }\n@@ -618,20 +587,20 @@ void CTxMemPool::PrioritiseTransaction(const uint256 hash, const string strHash,\n {\n     {\n         LOCK(cs);\n-        std::pair<double, CAmount> &deltas = mapDeltas[hash];\n+        std::pair<double, CAmount>& deltas = mapDeltas[hash];\n         deltas.first += dPriorityDelta;\n         deltas.second += nFeeDelta;\n     }\n     LogPrintf(\"PrioritiseTransaction: %s priority += %f, fee += %d\\n\", strHash, dPriorityDelta, FormatMoney(nFeeDelta));\n }\n \n-void CTxMemPool::ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta)\n+void CTxMemPool::ApplyDeltas(const uint256 hash, double& dPriorityDelta, CAmount& nFeeDelta)\n {\n     LOCK(cs);\n     std::map<uint256, std::pair<double, CAmount> >::iterator pos = mapDeltas.find(hash);\n     if (pos == mapDeltas.end())\n         return;\n-    const std::pair<double, CAmount> &deltas = pos->second;\n+    const std::pair<double, CAmount>& deltas = pos->second;\n     dPriorityDelta += deltas.first;\n     nFeeDelta += deltas.second;\n }\n@@ -643,9 +612,10 @@ void CTxMemPool::ClearPrioritisation(const uint256 hash)\n }\n \n \n-CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView *baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n+CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) {}\n \n-bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewMemPool::GetCoins(const uint256& txid, CCoins& coins) const\n+{\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n@@ -657,6 +627,7 @@ bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) const {\n     return (base->GetCoins(txid, coins) && !coins.IsPruned());\n }\n \n-bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n+bool CCoinsViewMemPool::HaveCoins(const uint256& txid) const\n+{\n     return mempool.exists(txid) || base->HaveCoins(txid);\n }"
      },
      {
        "sha": "aaf1722d2fbcb1a9f8bf925ab85c73bcebab8cc6",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 82,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -38,10 +38,10 @@\n #else\n \n #ifdef _MSC_VER\n-#pragma warning(disable:4786)\n-#pragma warning(disable:4804)\n-#pragma warning(disable:4805)\n-#pragma warning(disable:4717)\n+#pragma warning(disable : 4786)\n+#pragma warning(disable : 4804)\n+#pragma warning(disable : 4805)\n+#pragma warning(disable : 4717)\n #endif\n \n #ifdef _WIN32_WINNT\n@@ -83,11 +83,12 @@\n // /usr/include/boost/program_options/detail/config_file.hpp:163:17: error: call to function 'to_internal' that is neither visible in the template definition nor found by argument-dependent lookup\n // See also: http://stackoverflow.com/questions/10020179/compilation-fail-in-boost-librairies-program-options\n //           http://clang.debian.net/status.php?version=3.0&key=CANNOT_FIND_FUNCTION\n-namespace boost {\n-\n-    namespace program_options {\n-        std::string to_internal(const std::string&);\n-    }\n+namespace boost\n+{\n+namespace program_options\n+{\n+std::string to_internal(const std::string&);\n+}\n \n } // namespace boost\n \n@@ -146,8 +147,7 @@ class CInit\n             delete ppmutexOpenSSL[i];\n         OPENSSL_free(ppmutexOpenSSL);\n     }\n-}\n-instance_of_cinit;\n+} instance_of_cinit;\n \n /**\n  * LogPrintf() has been broken a couple of times now\n@@ -175,15 +175,15 @@ static void DebugPrintInit()\n \n     boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n     fileout = fopen(pathDebug.string().c_str(), \"a\");\n-    if (fileout) setbuf(fileout, NULL); // unbuffered\n+    if (fileout)\n+        setbuf(fileout, NULL); // unbuffered\n \n     mutexDebugLog = new boost::mutex();\n }\n \n bool LogAcceptCategory(const char* category)\n {\n-    if (category != NULL)\n-    {\n+    if (category != NULL) {\n         if (!fDebug)\n             return false;\n \n@@ -192,8 +192,7 @@ bool LogAcceptCategory(const char* category)\n         // where mapMultiArgs might be deleted before another\n         // global destructor calls LogPrint()\n         static boost::thread_specific_ptr<set<string> > ptrCategory;\n-        if (ptrCategory.get() == NULL)\n-        {\n+        if (ptrCategory.get() == NULL) {\n             const vector<string>& categories = mapMultiArgs[\"-debug\"];\n             ptrCategory.reset(new set<string>(categories.begin(), categories.end()));\n             // thread_specific_ptr automatically deletes the set when the thread ends.\n@@ -208,17 +207,14 @@ bool LogAcceptCategory(const char* category)\n     return true;\n }\n \n-int LogPrintStr(const std::string &str)\n+int LogPrintStr(const std::string& str)\n {\n     int ret = 0; // Returns total number of characters written\n-    if (fPrintToConsole)\n-    {\n+    if (fPrintToConsole) {\n         // print to console\n         ret = fwrite(str.data(), 1, str.size(), stdout);\n         fflush(stdout);\n-    }\n-    else if (fPrintToDebugLog && AreBaseParamsConfigured())\n-    {\n+    } else if (fPrintToDebugLog && AreBaseParamsConfigured()) {\n         static bool fStartedNewLine = true;\n         boost::call_once(&DebugPrintInit, debugPrintInitFlag);\n \n@@ -231,14 +227,14 @@ int LogPrintStr(const std::string &str)\n         if (fReopenDebugLog) {\n             fReopenDebugLog = false;\n             boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n-            if (freopen(pathDebug.string().c_str(),\"a\",fileout) != NULL)\n+            if (freopen(pathDebug.string().c_str(), \"a\", fileout) != NULL)\n                 setbuf(fileout, NULL); // unbuffered\n         }\n \n         // Debug print useful for profiling\n         if (fLogTimestamps && fStartedNewLine)\n             ret += fprintf(fileout, \"%s \", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()).c_str());\n-        if (!str.empty() && str[str.size()-1] == '\\n')\n+        if (!str.empty() && str[str.size() - 1] == '\\n')\n             fStartedNewLine = true;\n         else\n             fStartedNewLine = false;\n@@ -252,12 +248,10 @@ int LogPrintStr(const std::string &str)\n static void InterpretNegativeSetting(string name, map<string, string>& mapSettingsRet)\n {\n     // interpret -nofoo as -foo=0 (and -nofoo=0 as -foo=1) as long as -foo not set\n-    if (name.find(\"-no\") == 0)\n-    {\n+    if (name.find(\"-no\") == 0) {\n         std::string positive(\"-\");\n-        positive.append(name.begin()+3, name.end());\n-        if (mapSettingsRet.count(positive) == 0)\n-        {\n+        positive.append(name.begin() + 3, name.end());\n+        if (mapSettingsRet.count(positive) == 0) {\n             bool value = !GetBoolArg(name, false);\n             mapSettingsRet[positive] = (value ? \"1\" : \"0\");\n         }\n@@ -269,14 +263,12 @@ void ParseParameters(int argc, const char* const argv[])\n     mapArgs.clear();\n     mapMultiArgs.clear();\n \n-    for (int i = 1; i < argc; i++)\n-    {\n+    for (int i = 1; i < argc; i++) {\n         std::string str(argv[i]);\n         std::string strValue;\n         size_t is_index = str.find('=');\n-        if (is_index != std::string::npos)\n-        {\n-            strValue = str.substr(is_index+1);\n+        if (is_index != std::string::npos) {\n+            strValue = str.substr(is_index + 1);\n             str = str.substr(0, is_index);\n         }\n #ifdef WIN32\n@@ -298,8 +290,7 @@ void ParseParameters(int argc, const char* const argv[])\n     }\n \n     // New 0.6 features:\n-    BOOST_FOREACH(const PAIRTYPE(string,string)& entry, mapArgs)\n-    {\n+    BOOST_FOREACH (const PAIRTYPE(string, string) & entry, mapArgs) {\n         // interpret -nofoo as -foo=0 (and -nofoo=0 as -foo=1) as long as -foo not set\n         InterpretNegativeSetting(entry.first, mapArgs);\n     }\n@@ -321,8 +312,7 @@ int64_t GetArg(const std::string& strArg, int64_t nDefault)\n \n bool GetBoolArg(const std::string& strArg, bool fDefault)\n {\n-    if (mapArgs.count(strArg))\n-    {\n+    if (mapArgs.count(strArg)) {\n         if (mapArgs[strArg].empty())\n             return true;\n         return (atoi(mapArgs[strArg]) != 0);\n@@ -373,10 +363,10 @@ void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n boost::filesystem::path GetDefaultDataDir()\n {\n     namespace fs = boost::filesystem;\n-    // Windows < Vista: C:\\Documents and Settings\\Username\\Application Data\\Bitcoin\n-    // Windows >= Vista: C:\\Users\\Username\\AppData\\Roaming\\Bitcoin\n-    // Mac: ~/Library/Application Support/Bitcoin\n-    // Unix: ~/.bitcoin\n+// Windows < Vista: C:\\Documents and Settings\\Username\\Application Data\\Bitcoin\n+// Windows >= Vista: C:\\Users\\Username\\AppData\\Roaming\\Bitcoin\n+// Mac: ~/Library/Application Support/Bitcoin\n+// Unix: ~/.bitcoin\n #ifdef WIN32\n     // Windows\n     return GetSpecialFolderPath(CSIDL_APPDATA) / \"Bitcoin\";\n@@ -403,13 +393,13 @@ static boost::filesystem::path pathCached;\n static boost::filesystem::path pathCachedNetSpecific;\n static CCriticalSection csPathCached;\n \n-const boost::filesystem::path &GetDataDir(bool fNetSpecific)\n+const boost::filesystem::path& GetDataDir(bool fNetSpecific)\n {\n     namespace fs = boost::filesystem;\n \n     LOCK(csPathCached);\n \n-    fs::path &path = fNetSpecific ? pathCachedNetSpecific : pathCached;\n+    fs::path& path = fNetSpecific ? pathCachedNetSpecific : pathCached;\n \n     // This can be called during exceptions by LogPrintf(), so we cache the\n     // value so we don't have to do memory allocations after that.\n@@ -458,12 +448,10 @@ void ReadConfigFile(map<string, string>& mapSettingsRet,\n     set<string> setOptions;\n     setOptions.insert(\"*\");\n \n-    for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n-    {\n+    for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it) {\n         // Don't overwrite existing settings so command line settings override bitcoin.conf\n         string strKey = string(\"-\") + it->string_key;\n-        if (mapSettingsRet.count(strKey) == 0)\n-        {\n+        if (mapSettingsRet.count(strKey) == 0) {\n             mapSettingsRet[strKey] = it->value[0];\n             // interpret nofoo=1 as foo=0 (and nofoo=0 as foo=1) as long as foo not set)\n             InterpretNegativeSetting(strKey, mapSettingsRet);\n@@ -478,15 +466,15 @@ void ReadConfigFile(map<string, string>& mapSettingsRet,\n boost::filesystem::path GetPidFile()\n {\n     boost::filesystem::path pathPidFile(GetArg(\"-pid\", \"bitcoind.pid\"));\n-    if (!pathPidFile.is_complete()) pathPidFile = GetDataDir() / pathPidFile;\n+    if (!pathPidFile.is_complete())\n+        pathPidFile = GetDataDir() / pathPidFile;\n     return pathPidFile;\n }\n \n-void CreatePidFile(const boost::filesystem::path &path, pid_t pid)\n+void CreatePidFile(const boost::filesystem::path& path, pid_t pid)\n {\n     FILE* file = fopen(path.string().c_str(), \"w\");\n-    if (file)\n-    {\n+    if (file) {\n         fprintf(file, \"%d\\n\", pid);\n         fclose(file);\n     }\n@@ -496,8 +484,7 @@ void CreatePidFile(const boost::filesystem::path &path, pid_t pid)\n bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest)\n {\n #ifdef WIN32\n-    return MoveFileExA(src.string().c_str(), dest.string().c_str(),\n-                       MOVEFILE_REPLACE_EXISTING) != 0;\n+    return MoveFileExA(src.string().c_str(), dest.string().c_str(), MOVEFILE_REPLACE_EXISTING) != 0;\n #else\n     int rc = std::rename(src.string().c_str(), dest.string().c_str());\n     return (rc == 0);\n@@ -511,8 +498,7 @@ bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest)\n  */\n bool TryCreateDirectory(const boost::filesystem::path& p)\n {\n-    try\n-    {\n+    try {\n         return boost::filesystem::create_directory(p);\n     } catch (boost::filesystem::filesystem_error) {\n         if (!boost::filesystem::exists(p) || !boost::filesystem::is_directory(p))\n@@ -523,24 +509,25 @@ bool TryCreateDirectory(const boost::filesystem::path& p)\n     return false;\n }\n \n-void FileCommit(FILE *fileout)\n+void FileCommit(FILE* fileout)\n {\n     fflush(fileout); // harmless if redundantly called\n #ifdef WIN32\n     HANDLE hFile = (HANDLE)_get_osfhandle(_fileno(fileout));\n     FlushFileBuffers(hFile);\n #else\n-    #if defined(__linux__) || defined(__NetBSD__)\n+#if defined(__linux__) || defined(__NetBSD__)\n     fdatasync(fileno(fileout));\n-    #elif defined(__APPLE__) && defined(F_FULLFSYNC)\n+#elif defined(__APPLE__) && defined(F_FULLFSYNC)\n     fcntl(fileno(fileout), F_FULLFSYNC, 0);\n-    #else\n+#else\n     fsync(fileno(fileout));\n-    #endif\n+#endif\n #endif\n }\n \n-bool TruncateFile(FILE *file, unsigned int length) {\n+bool TruncateFile(FILE* file, unsigned int length)\n+{\n #if defined(WIN32)\n     return _chsize(_fileno(file), length) == 0;\n #else\n@@ -552,7 +539,8 @@ bool TruncateFile(FILE *file, unsigned int length) {\n  * this function tries to raise the file descriptor limit to the requested number.\n  * It returns the actual file descriptor limit (which may be more or less than nMinFD)\n  */\n-int RaiseFileDescriptorLimit(int nMinFD) {\n+int RaiseFileDescriptorLimit(int nMinFD)\n+{\n #if defined(WIN32)\n     return 2048;\n #else\n@@ -575,7 +563,8 @@ int RaiseFileDescriptorLimit(int nMinFD) {\n  * this function tries to make a particular range of a file allocated (corresponding to disk space)\n  * it is advisory, and the range specified in the arguments will never contain live data\n  */\n-void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length) {\n+void AllocateFileRange(FILE* file, unsigned int offset, unsigned int length)\n+{\n #if defined(WIN32)\n     // Windows-specific version\n     HANDLE hFile = (HANDLE)_get_osfhandle(_fileno(file));\n@@ -622,22 +611,19 @@ void ShrinkDebugFile()\n     // Scroll debug.log if it's getting too big\n     boost::filesystem::path pathLog = GetDataDir() / \"debug.log\";\n     FILE* file = fopen(pathLog.string().c_str(), \"r\");\n-    if (file && boost::filesystem::file_size(pathLog) > 10 * 1000000)\n-    {\n+    if (file && boost::filesystem::file_size(pathLog) > 10 * 1000000) {\n         // Restart the file with some of the end\n-        std::vector <char> vch(200000,0);\n+        std::vector<char> vch(200000, 0);\n         fseek(file, -((long)vch.size()), SEEK_END);\n         int nBytes = fread(begin_ptr(vch), 1, vch.size(), file);\n         fclose(file);\n \n         file = fopen(pathLog.string().c_str(), \"w\");\n-        if (file)\n-        {\n+        if (file) {\n             fwrite(begin_ptr(vch), 1, nBytes, file);\n             fclose(file);\n         }\n-    }\n-    else if (file != NULL)\n+    } else if (file != NULL)\n         fclose(file);\n }\n \n@@ -648,8 +634,7 @@ boost::filesystem::path GetSpecialFolderPath(int nFolder, bool fCreate)\n \n     char pszPath[MAX_PATH] = \"\";\n \n-    if(SHGetSpecialFolderPathA(NULL, pszPath, nFolder, fCreate))\n-    {\n+    if (SHGetSpecialFolderPathA(NULL, pszPath, nFolder, fCreate)) {\n         return fs::path(pszPath);\n     }\n \n@@ -658,7 +643,8 @@ boost::filesystem::path GetSpecialFolderPath(int nFolder, bool fCreate)\n }\n #endif\n \n-boost::filesystem::path GetTempPath() {\n+boost::filesystem::path GetTempPath()\n+{\n #if BOOST_FILESYSTEM_VERSION == 3\n     return boost::filesystem::temp_directory_path();\n #else\n@@ -714,15 +700,13 @@ void RenameThread(const char* name)\n void SetupEnvironment()\n {\n #ifndef WIN32\n-    try\n-    {\n+    try {\n #if BOOST_FILESYSTEM_VERSION == 3\n-            boost::filesystem::path::codecvt(); // Raises runtime error if current locale is invalid\n-#else // boost filesystem v2\n-            std::locale();                      // Raises runtime error if current locale is invalid\n+        boost::filesystem::path::codecvt(); // Raises runtime error if current locale is invalid\n+#else                                       // boost filesystem v2\n+        std::locale(); // Raises runtime error if current locale is invalid\n #endif\n-    } catch(std::runtime_error &e)\n-    {\n+    } catch (std::runtime_error& e) {\n         setenv(\"LC_ALL\", \"C\", 1); // Force C locale\n     }\n #endif\n@@ -735,7 +719,7 @@ void SetThreadPriority(int nPriority)\n #else // WIN32\n #ifdef PRIO_THREAD\n     setpriority(PRIO_THREAD, 0, nPriority);\n-#else // PRIO_THREAD\n+#else  // PRIO_THREAD\n     setpriority(PRIO_PROCESS, 0, nPriority);\n #endif // PRIO_THREAD\n #endif // WIN32"
      },
      {
        "sha": "b19789271af5363454e28aa371d780c836ec410c",
        "filename": "src/utilmoneystr.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/utilmoneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/utilmoneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -16,16 +16,16 @@ string FormatMoney(const CAmount& n, bool fPlus)\n     // Note: not using straight sprintf here because we do NOT want\n     // localized number formatting.\n     int64_t n_abs = (n > 0 ? n : -n);\n-    int64_t quotient = n_abs/COIN;\n-    int64_t remainder = n_abs%COIN;\n+    int64_t quotient = n_abs / COIN;\n+    int64_t remainder = n_abs % COIN;\n     string str = strprintf(\"%d.%08d\", quotient, remainder);\n \n     // Right-trim excess zeros before the decimal point:\n     int nTrim = 0;\n-    for (int i = str.size()-1; (str[i] == '0' && isdigit(str[i-2])); --i)\n+    for (int i = str.size() - 1; (str[i] == '0' && isdigit(str[i - 2])); --i)\n         ++nTrim;\n     if (nTrim)\n-        str.erase(str.size()-nTrim, nTrim);\n+        str.erase(str.size() - nTrim, nTrim);\n \n     if (n < 0)\n         str.insert((unsigned int)0, 1, '-');\n@@ -47,14 +47,11 @@ bool ParseMoney(const char* pszIn, CAmount& nRet)\n     const char* p = pszIn;\n     while (isspace(*p))\n         p++;\n-    for (; *p; p++)\n-    {\n-        if (*p == '.')\n-        {\n+    for (; *p; p++) {\n+        if (*p == '.') {\n             p++;\n-            int64_t nMult = CENT*10;\n-            while (isdigit(*p) && (nMult > 0))\n-            {\n+            int64_t nMult = CENT * 10;\n+            while (isdigit(*p) && (nMult > 0)) {\n                 nUnits += nMult * (*p++ - '0');\n                 nMult /= 10;\n             }\n@@ -74,7 +71,7 @@ bool ParseMoney(const char* pszIn, CAmount& nRet)\n     if (nUnits < 0 || nUnits > COIN)\n         return false;\n     int64_t nWhole = atoi64(strWhole);\n-    CAmount nValue = nWhole*COIN + nUnits;\n+    CAmount nValue = nWhole * COIN + nUnits;\n \n     nRet = nValue;\n     return true;"
      },
      {
        "sha": "680646357767d64d292383597dbba5b6636a8aaf",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48",
        "patch": "@@ -14,11 +14,12 @@\n \n using namespace std;\n \n-static int64_t nMockTime = 0;  //! For unit testing\n+static int64_t nMockTime = 0; //! For unit testing\n \n int64_t GetTime()\n {\n-    if (nMockTime) return nMockTime;\n+    if (nMockTime)\n+        return nMockTime;\n \n     return time(NULL);\n }\n@@ -31,18 +32,17 @@ void SetMockTime(int64_t nMockTimeIn)\n int64_t GetTimeMillis()\n {\n     return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n-            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n+            boost::posix_time::ptime(boost::gregorian::date(1970, 1, 1))).total_milliseconds();\n }\n \n int64_t GetTimeMicros()\n {\n     return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n-            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_microseconds();\n+            boost::posix_time::ptime(boost::gregorian::date(1970, 1, 1))).total_microseconds();\n }\n \n void MilliSleep(int64_t n)\n {\n-\n /**\n  * Boost's sleep_for was uninterruptable when backed by nanosleep from 1.50\n  * until fixed in 1.52. Use the deprecated sleep method for the broken case."
      },
      {
        "sha": "1dc767c03a0e67c10bb954aca1050209379452b8",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48"
      },
      {
        "sha": "24043935c00efb405d3fc9af2964211418457261",
        "filename": "src/wallet_ismine.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 11,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/wallet_ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/wallet_ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet_ismine.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48"
      },
      {
        "sha": "0ac9834d673515b562044bf8ecef7a9553cedd08",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 196,
        "changes": 307,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=2037211a1aa17e5cf36d7ec9fad31d29e7f8ad48"
      }
    ]
  }
]