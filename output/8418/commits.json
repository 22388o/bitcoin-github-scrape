[
  {
    "sha": "56c87e92110f05d7452f1e85bf755246ffc77206",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NmM4N2U5MjExMGYwNWQ3NDUyZjFlODViZjc1NTI0NmZmYzc3MjA2",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-25T21:22:37Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-29T13:41:58Z"
      },
      "message": "Allow changing BIP9 parameters on regtest",
      "tree": {
        "sha": "8428199ed927d530d034610071f7551940e5b366",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8428199ed927d530d034610071f7551940e5b366"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56c87e92110f05d7452f1e85bf755246ffc77206",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c87e92110f05d7452f1e85bf755246ffc77206",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56c87e92110f05d7452f1e85bf755246ffc77206",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c87e92110f05d7452f1e85bf755246ffc77206/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a2d4027271750139f4df51619aa2cfbe49f6665",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a2d4027271750139f4df51619aa2cfbe49f6665",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a2d4027271750139f4df51619aa2cfbe49f6665"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 52,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d6032440e3bb2a37694b4c25a612b3e22e5b33df",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56c87e92110f05d7452f1e85bf755246ffc77206/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56c87e92110f05d7452f1e85bf755246ffc77206/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=56c87e92110f05d7452f1e85bf755246ffc77206",
        "patch": "@@ -303,6 +303,12 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n         base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n     }\n+\n+    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+    {\n+        consensus.vDeployments[d].nStartTime = nStartTime;\n+        consensus.vDeployments[d].nTimeout = nTimeout;\n+    }\n };\n static CRegTestParams regTestParams;\n \n@@ -330,4 +336,9 @@ void SelectParams(const std::string& network)\n     SelectBaseParams(network);\n     pCurrentParams = &Params(network);\n }\n+\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+}\n  "
      },
      {
        "sha": "0c3820b7c6e725ff5e468606c3b985185fb41754",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56c87e92110f05d7452f1e85bf755246ffc77206/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56c87e92110f05d7452f1e85bf755246ffc77206/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=56c87e92110f05d7452f1e85bf755246ffc77206",
        "patch": "@@ -112,4 +112,9 @@ CChainParams& Params(const std::string& chain);\n  */\n void SelectParams(const std::string& chain);\n \n+/**\n+ * Allows modifying the BIP9 regtest parameters.\n+ */\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+\n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "5dc3ac023ccf837f9cc206c7dcc3c7941477dfec",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56c87e92110f05d7452f1e85bf755246ffc77206/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56c87e92110f05d7452f1e85bf755246ffc77206/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=56c87e92110f05d7452f1e85bf755246ffc77206",
        "patch": "@@ -410,6 +410,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified bip9 deployment (regtest-only)\");\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n@@ -975,6 +976,41 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n+    if (!mapMultiArgs[\"-bip9params\"].empty()) {\n+        // Allow overriding bip9 parameters for testing\n+        if (!Params().MineBlocksOnDemand()) {\n+            return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n+        }\n+        const vector<string>& deployments = mapMultiArgs[\"-bip9params\"];\n+        for (auto i : deployments) {\n+            std::vector<std::string> vDeploymentParams;\n+            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            if (vDeploymentParams.size() != 3) {\n+                return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n+            }\n+            int64_t nStartTime, nTimeout;\n+            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n+                return InitError(strprintf(\"Invalid nStartTime (%s)\", vDeploymentParams[1]));\n+            }\n+            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {\n+                return InitError(strprintf(\"Invalid nTimeout (%s)\", vDeploymentParams[2]));\n+            }\n+            bool found = false;\n+            for (int i=0; i<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++i)\n+            {\n+                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[i].name) == 0) {\n+                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(i), nStartTime, nTimeout);\n+                    found = true;\n+                    LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                return InitError(strprintf(\"Invalid deployment (%s)\", vDeploymentParams[0]));\n+            }\n+        }\n+    }\n+\n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n     // Initialize elliptic curve code"
      }
    ]
  },
  {
    "sha": "9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Yzg1OTNkMmI0ZTI1ZWY2MjgxNzJjZWFkYmVkZjBlZjA3OGQwMWVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-27T14:06:17Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-29T13:41:58Z"
      },
      "message": "Implement SipHash in Python",
      "tree": {
        "sha": "915efaddaaebf93a751932dcd58948f8772dc9a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/915efaddaaebf93a751932dcd58948f8772dc9a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8593d2b4e25ef628172ceadbedf0ef078d01ef/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56c87e92110f05d7452f1e85bf755246ffc77206",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c87e92110f05d7452f1e85bf755246ffc77206",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56c87e92110f05d7452f1e85bf755246ffc77206"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 68,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c0574bd931758cca0b1583da0269bec96b5d8bf",
        "filename": "qa/rpc-tests/test_framework/siphash.py",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c8593d2b4e25ef628172ceadbedf0ef078d01ef/qa/rpc-tests/test_framework/siphash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c8593d2b4e25ef628172ceadbedf0ef078d01ef/qa/rpc-tests/test_framework/siphash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/siphash.py?ref=9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
        "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# siphash.py - Specialized SipHash-2-4 implementations\n+#\n+# This implements SipHash-2-4 for 256-bit integers.\n+\n+def rotl64(n, b):\n+    return n >> (64 - b) | (n & ((1 << (64 - b)) - 1)) << b\n+\n+def siphash_round(v0, v1, v2, v3):\n+    v0 = (v0 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 13)\n+    v1 ^= v0\n+    v0 = rotl64(v0, 32)\n+    v2 = (v2 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 16)\n+    v3 ^= v2\n+    v0 = (v0 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 21)\n+    v3 ^= v0\n+    v2 = (v2 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 17)\n+    v1 ^= v2\n+    v2 = rotl64(v2, 32)\n+    return (v0, v1, v2, v3)\n+\n+def siphash256(k0, k1, h):\n+    n0 = h & ((1 << 64) - 1)\n+    n1 = (h >> 64) & ((1 << 64) - 1)\n+    n2 = (h >> 128) & ((1 << 64) - 1)\n+    n3 = (h >> 192) & ((1 << 64) - 1)\n+    v0 = 0x736f6d6570736575 ^ k0\n+    v1 = 0x646f72616e646f6d ^ k1\n+    v2 = 0x6c7967656e657261 ^ k0\n+    v3 = 0x7465646279746573 ^ k1 ^ n0\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n0\n+    v3 ^= n1\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n1\n+    v3 ^= n2\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n2\n+    v3 ^= n3\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n3\n+    v3 ^= 0x2000000000000000\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= 0x2000000000000000\n+    v2 ^= 0xFF\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    return v0 ^ v1 ^ v2 ^ v3"
      },
      {
        "sha": "fa9624f13daf5508d21571c50d2540f5580ba8e3",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c8593d2b4e25ef628172ceadbedf0ef078d01ef/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c8593d2b4e25ef628172ceadbedf0ef078d01ef/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
        "patch": "@@ -122,6 +122,10 @@ BOOST_AUTO_TEST_CASE(siphash)\n         hasher3.Write(uint64_t(x)|(uint64_t(x+1)<<8)|(uint64_t(x+2)<<16)|(uint64_t(x+3)<<24)|\n                      (uint64_t(x+4)<<32)|(uint64_t(x+5)<<40)|(uint64_t(x+6)<<48)|(uint64_t(x+7)<<56));\n     }\n+\n+    CHashWriter ss(SER_DISK, CLIENT_VERSION);\n+    ss << CTransaction();\n+    BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "a8689fdf8e10300b73750161a73a23467ecd1efe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODY4OWZkZjhlMTAzMDBiNzM3NTAxNjFhNzNhMjM0NjdlY2QxZWZl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-06-18T01:17:25Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-29T13:41:58Z"
      },
      "message": "Tests: refactor compact size serialization in mininode",
      "tree": {
        "sha": "9a9ae4ae065efc2d67d76563aab9c03130736c67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a9ae4ae065efc2d67d76563aab9c03130736c67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8689fdf8e10300b73750161a73a23467ecd1efe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8689fdf8e10300b73750161a73a23467ecd1efe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8689fdf8e10300b73750161a73a23467ecd1efe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8689fdf8e10300b73750161a73a23467ecd1efe/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c8593d2b4e25ef628172ceadbedf0ef078d01ef"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 25,
      "deletions": 72
    },
    "files": [
      {
        "sha": "67aaab698e9521a3ed3de13b0892fbcd2779b7cc",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 25,
        "deletions": 72,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8689fdf8e10300b73750161a73a23467ecd1efe/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8689fdf8e10300b73750161a73a23467ecd1efe/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=a8689fdf8e10300b73750161a73a23467ecd1efe",
        "patch": "@@ -74,25 +74,34 @@ def ripemd160(s):\n def hash256(s):\n     return sha256(sha256(s))\n \n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n \n-def deser_string(f):\n+def deser_compact_size(f):\n     nit = struct.unpack(\"<B\", f.read(1))[0]\n     if nit == 253:\n         nit = struct.unpack(\"<H\", f.read(2))[0]\n     elif nit == 254:\n         nit = struct.unpack(\"<I\", f.read(4))[0]\n     elif nit == 255:\n         nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return nit\n+\n+def deser_string(f):\n+    nit = deser_compact_size(f)\n     return f.read(nit)\n \n def ser_string(s):\n-    if len(s) < 253:\n-        return struct.pack(\"B\", len(s)) + s\n-    elif len(s) < 0x10000:\n-        return struct.pack(\"<BH\", 253, len(s)) + s\n-    elif len(s) < 0x100000000:\n-        return struct.pack(\"<BI\", 254, len(s)) + s\n-    return struct.pack(\"<BQ\", 255, len(s)) + s\n+    return ser_compact_size(len(s)) + s\n \n def deser_uint256(f):\n     r = 0\n@@ -125,13 +134,7 @@ def uint256_from_compact(c):\n \n \n def deser_vector(f, c):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = c()\n@@ -144,15 +147,7 @@ def deser_vector(f, c):\n # entries in the vector (we use this for serializing the vector of transactions\n # for a witness block).\n def ser_vector(l, ser_function_name=None):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         if ser_function_name:\n             r += getattr(i, ser_function_name)()\n@@ -162,13 +157,7 @@ def ser_vector(l, ser_function_name=None):\n \n \n def deser_uint256_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_uint256(f)\n@@ -177,28 +166,14 @@ def deser_uint256_vector(f):\n \n \n def ser_uint256_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += ser_uint256(i)\n     return r\n \n \n def deser_string_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_string(f)\n@@ -207,28 +182,14 @@ def deser_string_vector(f):\n \n \n def ser_string_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for sv in l:\n         r += ser_string(sv)\n     return r\n \n \n def deser_int_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = struct.unpack(\"<i\", f.read(4))[0]\n@@ -237,15 +198,7 @@ def deser_int_vector(f):\n \n \n def ser_int_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += struct.pack(\"<i\", i)\n     return r"
      }
    ]
  },
  {
    "sha": "9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YTIyYTZjMDg5MTI1NmYwMmY0OTA2YzFjMTNmYjIyYTk3MjJlYzdj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-12T20:04:38Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-29T13:41:58Z"
      },
      "message": "Add support for compactblocks to mininode",
      "tree": {
        "sha": "b55cc5af02df8b90815828001dcc7e6d759bd470",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b55cc5af02df8b90815828001dcc7e6d759bd470"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a22a6c0891256f02f4906c1c13fb22a9722ec7c/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8689fdf8e10300b73750161a73a23467ecd1efe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8689fdf8e10300b73750161a73a23467ecd1efe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8689fdf8e10300b73750161a73a23467ecd1efe"
      }
    ],
    "stats": {
      "total": 276,
      "additions": 272,
      "deletions": 4
    },
    "files": [
      {
        "sha": "caffab35351df437f8828baa60284f0b3ac79cac",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 272,
        "deletions": 4,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a22a6c0891256f02f4906c1c13fb22a9722ec7c/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a22a6c0891256f02f4906c1c13fb22a9722ec7c/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
        "patch": "@@ -36,9 +36,10 @@\n from threading import Thread\n import logging\n import copy\n+from test_framework.siphash import siphash256\n \n BIP0031_VERSION = 60000\n-MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n \n MAX_INV_SZ = 50000\n@@ -52,7 +53,7 @@\n NODE_WITNESS = (1 << 3)\n \n # Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to workaround an issue with closing an asyncore socket when \n+# ourselves (to workaround an issue with closing an asyncore socket when\n # using select)\n mininode_socket_map = dict()\n \n@@ -247,7 +248,8 @@ class CInv(object):\n         1: \"TX\",\n         2: \"Block\",\n         1|MSG_WITNESS_FLAG: \"WitnessTx\",\n-        2|MSG_WITNESS_FLAG : \"WitnessBlock\"\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n+        4: \"CompactBlock\"\n     }\n \n     def __init__(self, t=0, h=0):\n@@ -734,6 +736,187 @@ def __repr__(self):\n             % (len(self.vchMsg), len(self.vchSig))\n \n \n+class PrefilledTransaction(object):\n+    def __init__(self, index=0, tx = None):\n+        self.index = index\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.index = deser_compact_size(f)\n+        self.tx = CTransaction()\n+        self.tx.deserialize(f)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_compact_size(self.index)\n+        if with_witness:\n+            r += self.tx.serialize_with_witness()\n+        else:\n+            r += self.tx.serialize_without_witness()\n+        return r\n+\n+    def __repr__(self):\n+        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n+\n+# This is what we send on the wire, in a cmpctblock message.\n+class P2PHeaderAndShortIDs(object):\n+    def __init__(self):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids_length = 0\n+        self.shortids = []\n+        self.prefilled_txn_length = 0\n+        self.prefilled_txn = []\n+\n+    def deserialize(self, f):\n+        self.header.deserialize(f)\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.shortids_length = deser_compact_size(f)\n+        for i in range(self.shortids_length):\n+            # shortids are defined to be 6 bytes in the spec, so append\n+            # two zero bytes and read it in as an 8-byte number\n+            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n+        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n+        self.prefilled_txn_length = len(self.prefilled_txn)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += self.header.serialize()\n+        r += struct.pack(\"<Q\", self.nonce)\n+        r += ser_compact_size(self.shortids_length)\n+        for x in self.shortids:\n+            # We only want the first 6 bytes\n+            r += struct.pack(\"<Q\", x)[0:6]\n+        r += ser_vector(self.prefilled_txn)\n+        return r\n+\n+    def __repr__(self):\n+        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n+\n+\n+# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n+def calculate_shortid(k0, k1, tx_hash):\n+    expected_shortid = siphash256(k0, k1, tx_hash)\n+    expected_shortid &= 0x0000ffffffffffff\n+    return expected_shortid\n+\n+# This version gets rid of the array lengths, and reinterprets the differential\n+# encoding into indices that can be used for lookup.\n+class HeaderAndShortIDs(object):\n+    def __init__(self, p2pheaders_and_shortids = None):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids = []\n+        self.prefilled_txn = []\n+\n+        if p2pheaders_and_shortids != None:\n+            self.header = p2pheaders_and_shortids.header\n+            self.nonce = p2pheaders_and_shortids.nonce\n+            self.shortids = p2pheaders_and_shortids.shortids\n+            last_index = -1\n+            for x in p2pheaders_and_shortids.prefilled_txn:\n+                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n+                last_index = self.prefilled_txn[-1].index\n+\n+    def to_p2p(self):\n+        ret = P2PHeaderAndShortIDs()\n+        ret.header = self.header\n+        ret.nonce = self.nonce\n+        ret.shortids_length = len(self.shortids)\n+        ret.shortids = self.shortids\n+        ret.prefilled_txn_length = len(self.prefilled_txn)\n+        ret.prefilled_txn = []\n+        last_index = -1\n+        for x in self.prefilled_txn:\n+            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n+            last_index = x.index\n+        return ret\n+\n+    def get_siphash_keys(self):\n+        header_nonce = self.header.serialize()\n+        header_nonce += struct.pack(\"<Q\", self.nonce)\n+        hash_header_nonce_as_str = sha256(header_nonce)\n+        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n+        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n+        return [ key0, key1 ]\n+\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0]):\n+        self.header = CBlockHeader(block)\n+        self.nonce = nonce\n+        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n+        self.shortids = []\n+        [k0, k1] = self.get_siphash_keys()\n+        for i in range(len(block.vtx)):\n+            if i not in prefill_list:\n+                self.shortids.append(calculate_shortid(k0, k1, block.vtx[i].sha256))\n+\n+    def __repr__(self):\n+        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n+\n+\n+class BlockTransactionsRequest(object):\n+\n+    def __init__(self, blockhash=0, indexes = None):\n+        self.blockhash = blockhash\n+        self.indexes = indexes if indexes != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        indexes_length = deser_compact_size(f)\n+        for i in range(indexes_length):\n+            self.indexes.append(deser_compact_size(f))\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        r += ser_compact_size(len(self.indexes))\n+        for x in self.indexes:\n+            r += ser_compact_size(x)\n+        return r\n+\n+    # helper to set the differentially encoded indexes from absolute ones\n+    def from_absolute(self, absolute_indexes):\n+        self.indexes = []\n+        last_index = -1\n+        for x in absolute_indexes:\n+            self.indexes.append(x-last_index-1)\n+            last_index = x\n+\n+    def to_absolute(self):\n+        absolute_indexes = []\n+        last_index = -1\n+        for x in self.indexes:\n+            absolute_indexes.append(x+last_index+1)\n+            last_index = absolute_indexes[-1]\n+        return absolute_indexes\n+\n+    def __repr__(self):\n+        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n+\n+\n+class BlockTransactions(object):\n+\n+    def __init__(self, blockhash=0, transactions = None):\n+        self.blockhash = blockhash\n+        self.transactions = transactions if transactions != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        self.transactions = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        if with_witness:\n+            r += ser_vector(self.transactions, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.transactions)\n+        return r\n+\n+    def __repr__(self):\n+        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n+\n+\n # Objects that correspond to messages on the wire\n class msg_version(object):\n     command = b\"version\"\n@@ -1168,6 +1351,79 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_feefilter(feerate=%08x)\" % self.feerate\n \n+class msg_sendcmpct(object):\n+    command = b\"sendcmpct\"\n+\n+    def __init__(self):\n+        self.announce = False\n+        self.version = 1\n+\n+    def deserialize(self, f):\n+        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.announce)\n+        r += struct.pack(\"<Q\", self.version)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n+\n+class msg_cmpctblock(object):\n+    command = b\"cmpctblock\"\n+\n+    def __init__(self, header_and_shortids = None):\n+        self.header_and_shortids = header_and_shortids\n+\n+    def deserialize(self, f):\n+        self.header_and_shortids = P2PHeaderAndShortIDs()\n+        self.header_and_shortids.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.header_and_shortids.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n+\n+class msg_getblocktxn(object):\n+    command = b\"getblocktxn\"\n+\n+    def __init__(self):\n+        self.block_txn_request = None\n+\n+    def deserialize(self, f):\n+        self.block_txn_request = BlockTransactionsRequest()\n+        self.block_txn_request.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_txn_request.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n+\n+class msg_blocktxn(object):\n+    command = b\"blocktxn\"\n+\n+    def __init__(self):\n+        self.block_transactions = BlockTransactions()\n+\n+    def deserialize(self, f):\n+        self.block_transactions.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n+\n # This is what a callback should look like for NodeConn\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n@@ -1248,6 +1504,10 @@ def on_mempool(self, conn): pass\n     def on_pong(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n     def on_sendheaders(self, conn, message): pass\n+    def on_sendcmpct(self, conn, message): pass\n+    def on_cmpctblock(self, conn, message): pass\n+    def on_getblocktxn(self, conn, message): pass\n+    def on_blocktxn(self, conn, message): pass\n \n # More useful callbacks and functions for NodeConnCB's which have a single NodeConn\n class SingleNodeConnCB(NodeConnCB):\n@@ -1264,6 +1524,10 @@ def add_connection(self, conn):\n     def send_message(self, message):\n         self.connection.send_message(message)\n \n+    def send_and_ping(self, message):\n+        self.send_message(message)\n+        self.sync_with_ping()\n+\n     def on_pong(self, conn, message):\n         self.last_pong = message\n \n@@ -1297,7 +1561,11 @@ class NodeConn(asyncore.dispatcher):\n         b\"reject\": msg_reject,\n         b\"mempool\": msg_mempool,\n         b\"feefilter\": msg_feefilter,\n-        b\"sendheaders\": msg_sendheaders\n+        b\"sendheaders\": msg_sendheaders,\n+        b\"sendcmpct\": msg_sendcmpct,\n+        b\"cmpctblock\": msg_cmpctblock,\n+        b\"getblocktxn\": msg_getblocktxn,\n+        b\"blocktxn\": msg_blocktxn\n     }\n     MAGIC_BYTES = {\n         \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet"
      }
    ]
  },
  {
    "sha": "45c7ddd109465e03551f5b39c2e650c243b4a078",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NWM3ZGRkMTA5NDY1ZTAzNTUxZjViMzljMmU2NTBjMjQzYjRhMDc4",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-12T20:05:02Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-29T13:41:58Z"
      },
      "message": "Add p2p test for BIP 152 (compact blocks)",
      "tree": {
        "sha": "51cf1b8f1b78e2a846a771f6a1f80ffad21687e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51cf1b8f1b78e2a846a771f6a1f80ffad21687e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45c7ddd109465e03551f5b39c2e650c243b4a078",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45c7ddd109465e03551f5b39c2e650c243b4a078",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/45c7ddd109465e03551f5b39c2e650c243b4a078",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45c7ddd109465e03551f5b39c2e650c243b4a078/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a22a6c0891256f02f4906c1c13fb22a9722ec7c"
      }
    ],
    "stats": {
      "total": 609,
      "additions": 609,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c4b11bc51b1e336b68e2db0176b09aa5d86ea45f",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45c7ddd109465e03551f5b39c2e650c243b4a078/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45c7ddd109465e03551f5b39c2e650c243b4a078/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=45c7ddd109465e03551f5b39c2e650c243b4a078",
        "patch": "@@ -141,6 +141,7 @@\n     'segwit.py',\n     'importprunedfunds.py',\n     'signmessages.py',\n+    'p2p-compactblocks.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "7fe7ecc16c6e19ae3fb4e9ece144f28fcee60740",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "added",
        "additions": 608,
        "deletions": 0,
        "changes": 608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45c7ddd109465e03551f5b39c2e650c243b4a078/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45c7ddd109465e03551f5b39c2e650c243b4a078/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=45c7ddd109465e03551f5b39c2e650c243b4a078",
        "patch": "@@ -0,0 +1,608 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.siphash import siphash256\n+from test_framework.script import CScript, OP_TRUE\n+\n+'''\n+CompactBlocksTest -- test compact blocks (BIP 152)\n+'''\n+\n+\n+# TestNode: A peer we use to send messages to bitcoind, and store responses.\n+class TestNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_sendcmpct = None\n+        self.last_headers = None\n+        self.last_inv = None\n+        self.last_cmpctblock = None\n+        self.block_announced = False\n+        self.last_getdata = None\n+        self.last_getblocktxn = None\n+        self.last_block = None\n+        self.last_blocktxn = None\n+\n+    def on_sendcmpct(self, conn, message):\n+        self.last_sendcmpct = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message\n+\n+    def on_cmpctblock(self, conn, message):\n+        self.last_cmpctblock = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_getblocktxn(self, conn, message):\n+        self.last_getblocktxn = message\n+\n+    def on_blocktxn(self, conn, message):\n+        self.last_blocktxn = message\n+\n+    # Requires caller to hold mininode_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+            self.last_cmpctblock = None\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n+        self.send_message(headers_message)\n+\n+\n+class CompactBlocksTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.utxos = []\n+\n+    def setup_network(self):\n+        self.nodes = []\n+\n+        # Turn off segwit in this test, as compact blocks don't currently work\n+        # with segwit.  (After BIP 152 is updated to support segwit, we can\n+        # test behavior with and without segwit enabled by adding a second node\n+        # to the test.)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"]])\n+\n+    def build_block_on_tip(self):\n+        height = self.nodes[0].getblockcount()\n+        tip = self.nodes[0].getbestblockhash()\n+        mtp = self.nodes[0].getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.solve()\n+        return block\n+\n+    # Create 10 more anyone-can-spend utxo's for testing.\n+    def make_utxos(self):\n+        block = self.build_block_on_tip()\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n+        self.nodes[0].generate(100)\n+\n+        total_value = block.vtx[0].vout[0].nValue\n+        out_value = total_value // 10\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(block.vtx[0].sha256, 0), b''))\n+        for i in range(10):\n+            tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n+        tx.rehash()\n+\n+        block2 = self.build_block_on_tip()\n+        block2.vtx.append(tx)\n+        block2.hashMerkleRoot = block2.calc_merkle_root()\n+        block2.solve()\n+        self.test_node.send_and_ping(msg_block(block2))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block2.sha256)\n+        self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n+        return\n+\n+    # Test \"sendcmpct\":\n+    # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n+    #   sendcmpct is sent.\n+    # - If sendcmpct is sent with version > 0, the message is ignored.\n+    # - If sendcmpct is sent with boolean 0, then block announcements are not\n+    #   made with compact blocks.\n+    # - If sendcmpct is then sent with boolean 1, then new block announcements\n+    #   are made with compact blocks.\n+    def test_sendcmpct(self):\n+        print(\"Testing SENDCMPCT p2p message... \")\n+\n+        # Make sure we get a version 0 SENDCMPCT message from our peer\n+        def received_sendcmpct():\n+            return (self.test_node.last_sendcmpct is not None)\n+        got_message = wait_until(received_sendcmpct, timeout=30)\n+        assert(got_message)\n+        assert_equal(self.test_node.last_sendcmpct.version, 1)\n+\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+\n+        def check_announcement_of_new_block(node, peer, predicate):\n+            self.test_node.clear_block_announcement()\n+            node.generate(1)\n+            got_message = wait_until(peer.received_block_announcement, timeout=30)\n+            assert(got_message)\n+            with mininode_lock:\n+                assert(predicate)\n+\n+        # We shouldn't get any block announcements via cmpctblock yet.\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Try one more time, this time after requesting headers.\n+        self.test_node.clear_block_announcement()\n+        self.test_node.get_headers(locator=[tip], hashstop=0)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_inv is not None)\n+\n+        # Now try a SENDCMPCT message with too-high version\n+        sendcmpct = msg_sendcmpct()\n+        sendcmpct.version = 2\n+        self.test_node.send_message(sendcmpct)\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Now try a SENDCMPCT message with valid version, but announce=False\n+        self.test_node.send_message(msg_sendcmpct())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Finally, try a SENDCMPCT message with announce=True\n+        sendcmpct.version = 1\n+        sendcmpct.announce = True\n+        self.test_node.send_message(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time, after turning on sendheaders\n+        self.test_node.send_message(msg_sendheaders())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Now turn off announcements\n+        sendcmpct.announce = False\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_headers is not None)\n+\n+    # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n+    def test_invalid_cmpctblock_message(self):\n+        print(\"Testing invalid index in cmpctblock message...\")\n+        self.nodes[0].generate(101)\n+        block = self.build_block_on_tip()\n+\n+        cmpct_block = P2PHeaderAndShortIDs()\n+        cmpct_block.header = CBlockHeader(block)\n+        cmpct_block.prefilled_txn_length = 1\n+        # This index will be too high\n+        prefilled_txn = PrefilledTransaction(1, block.vtx[0])\n+        cmpct_block.prefilled_txn = [prefilled_txn]\n+        self.test_node.send_and_ping(msg_cmpctblock(cmpct_block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.hashPrevBlock)\n+\n+    # Compare the generated shortids to what we expect based on BIP 152, given\n+    # bitcoind's choice of nonce.\n+    def test_compactblock_construction(self):\n+        print(\"Testing compactblock headers and shortIDs are correct...\")\n+\n+        # Generate a bunch of transactions.\n+        self.nodes[0].generate(101)\n+        num_transactions = 25\n+        address = self.nodes[0].getnewaddress()\n+        for i in range(num_transactions):\n+            self.nodes[0].sendtoaddress(address, 0.1)\n+\n+        # Now mine a block, and look at the resulting compact block.\n+        self.test_node.clear_block_announcement()\n+        block_hash = int(self.nodes[0].generate(1)[0], 16)\n+\n+        # Store the raw block in our internal format.\n+        block = FromHex(CBlock(), self.nodes[0].getblock(\"%02x\" % block_hash, False))\n+        [tx.calc_sha256() for tx in block.vtx]\n+        block.rehash()\n+\n+        # Don't care which type of announcement came back for this test; just\n+        # request the compact block if we didn't get one yet.\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        with mininode_lock:\n+            if self.test_node.last_cmpctblock is None:\n+                self.test_node.clear_block_announcement()\n+                inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n+                self.test_node.send_message(msg_getdata([inv]))\n+\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        # Now we should have the compactblock\n+        header_and_shortids = None\n+        with mininode_lock:\n+            assert(self.test_node.last_cmpctblock is not None)\n+            # Convert the on-the-wire representation to absolute indexes\n+            header_and_shortids = HeaderAndShortIDs(self.test_node.last_cmpctblock.header_and_shortids)\n+\n+        # Check that we got the right block!\n+        header_and_shortids.header.calc_sha256()\n+        assert_equal(header_and_shortids.header.sha256, block_hash)\n+\n+        # Make sure the prefilled_txn appears to have included the coinbase\n+        assert(len(header_and_shortids.prefilled_txn) >= 1)\n+        assert_equal(header_and_shortids.prefilled_txn[0].index, 0)\n+\n+        # Check that all prefilled_txn entries match what's in the block.\n+        for entry in header_and_shortids.prefilled_txn:\n+            entry.tx.calc_sha256()\n+            assert_equal(entry.tx.sha256, block.vtx[entry.index].sha256)\n+\n+        # Check that the cmpctblock message announced all the transactions.\n+        assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n+\n+        # And now check that all the shortids are as expected as well.\n+        # Determine the siphash keys to use.\n+        [k0, k1] = header_and_shortids.get_siphash_keys()\n+\n+        index = 0\n+        while index < len(block.vtx):\n+            if (len(header_and_shortids.prefilled_txn) > 0 and\n+                    header_and_shortids.prefilled_txn[0].index == index):\n+                # Already checked prefilled transactions above\n+                header_and_shortids.prefilled_txn.pop(0)\n+            else:\n+                shortid = calculate_shortid(k0, k1, block.vtx[index].sha256)\n+                assert_equal(shortid, header_and_shortids.shortids[0])\n+                header_and_shortids.shortids.pop(0)\n+            index += 1\n+\n+    # Test that bitcoind requests compact blocks when we announce new blocks\n+    # via header or inv, and that responding to getblocktxn causes the block\n+    # to be successfully reconstructed.\n+    def test_compactblock_requests(self):\n+        print(\"Testing compactblock requests... \")\n+\n+        # Try announcing a block with an inv or header, expect a compactblock\n+        # request\n+        for announce in [\"inv\", \"header\"]:\n+            block = self.build_block_on_tip()\n+            with mininode_lock:\n+                self.test_node.last_getdata = None\n+\n+            if announce == \"inv\":\n+                self.test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n+            else:\n+                self.test_node.send_header_for_blocks([block])\n+            success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=30)\n+            assert(success)\n+            assert_equal(len(self.test_node.last_getdata.inv), 1)\n+            assert_equal(self.test_node.last_getdata.inv[0].type, 4)\n+            assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+            # Send back a compactblock message that omits the coinbase\n+            comp_block = HeaderAndShortIDs()\n+            comp_block.header = CBlockHeader(block)\n+            comp_block.nonce = 0\n+            comp_block.shortids = [1]  # this is useless, and wrong\n+            self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+            # Expect a getblocktxn message.\n+            with mininode_lock:\n+                assert(self.test_node.last_getblocktxn is not None)\n+                absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert_equal(absolute_indexes, [0])  # should be a coinbase request\n+\n+            # Send the coinbase, and verify that the tip advances.\n+            msg = msg_blocktxn()\n+            msg.block_transactions.blockhash = block.sha256\n+            msg.block_transactions.transactions = [block.vtx[0]]\n+            self.test_node.send_and_ping(msg)\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Create a chain of transactions from given utxo, and add to a new block.\n+    def build_block_with_transactions(self, utxo, num_transactions):\n+        block = self.build_block_on_tip()\n+\n+        for i in range(num_transactions):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(utxo[0], utxo[1]), b''))\n+            tx.vout.append(CTxOut(utxo[2] - 1000, CScript([OP_TRUE])))\n+            tx.rehash()\n+            utxo = [tx.sha256, 0, tx.vout[0].nValue]\n+            block.vtx.append(tx)\n+\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.solve()\n+        return block\n+\n+    # Test that we only receive getblocktxn requests for transactions that the\n+    # node needs, and that responding to them causes the block to be\n+    # reconstructed.\n+    def test_getblocktxn_requests(self):\n+        print(\"Testing getblocktxn requests...\")\n+\n+        # First try announcing compactblocks that won't reconstruct, and verify\n+        # that we receive getblocktxn messages back.\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [1, 2, 3, 4, 5])\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        # Now try interspersing the prefilled transactions\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [2, 3, 4])\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now try giving one transaction ahead of time.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        self.test_node.send_and_ping(msg_tx(block.vtx[1]))\n+        assert(block.vtx[1].hash in self.nodes[0].getrawmempool())\n+\n+        # Prefill 4 out of the 6 transactions, and verify that only the one\n+        # that was not in the mempool is requested.\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [5])\n+\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now provide all transactions to the node before the block is\n+        # announced and verify reconstruction happens immediately.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        for tx in block.vtx[1:]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:]:\n+            assert(tx.hash in mempool)\n+\n+        # Clear out last request.\n+        with mininode_lock:\n+            self.test_node.last_getblocktxn = None\n+\n+        # Send compact block\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            # Shouldn't have gotten a request for any transaction\n+            assert(self.test_node.last_getblocktxn is None)\n+        # Tip should have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n+    # permanently failed.\n+    def test_incorrect_blocktxn_response(self):\n+        print(\"Testing handling of incorrect blocktxn responses...\")\n+\n+        if (len(self.utxos) == 0):\n+            self.make_utxos()\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        # Relay the first 5 transactions from the block in advance\n+        for tx in block.vtx[1:6]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:6]:\n+            assert(tx.hash in mempool)\n+\n+        # Send compact block\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        absolute_indexes = []\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n+\n+        # Now give an incorrect response.\n+        # Note that it's possible for bitcoind to be smart enough to know we're\n+        # lying, since it could check to see if the shortid matches what we're\n+        # sending, and eg disconnect us for misbehavior.  If that behavior\n+        # change were made, we could just modify this test by having a\n+        # different peer provide the block further down, so that we're still\n+        # verifying that the block isn't marked bad permanently. This is good\n+        # enough for now.\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n+        self.test_node.send_and_ping(msg)\n+\n+        # Tip should not have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+\n+        # We should receive a getdata request\n+        success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=10)\n+        assert(success)\n+        assert_equal(len(self.test_node.last_getdata.inv), 1)\n+        assert_equal(self.test_node.last_getdata.inv[0].type, 2)\n+        assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+        # Deliver the block\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    def test_getblocktxn_handler(self):\n+        print(\"Testing getblocktxn handler...\")\n+\n+        # bitcoind won't respond for blocks whose height is more than 15 blocks\n+        # deep.\n+        MAX_GETBLOCKTXN_DEPTH = 15\n+        chain_height = self.nodes[0].getblockcount()\n+        current_height = chain_height\n+        while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n+            block_hash = self.nodes[0].getblockhash(current_height)\n+            block = FromHex(CBlock(), self.nodes[0].getblock(block_hash, False))\n+\n+            msg = msg_getblocktxn()\n+            msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n+            num_to_request = random.randint(1, len(block.vtx))\n+            msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n+            self.test_node.send_message(msg)\n+            success = wait_until(lambda: self.test_node.last_blocktxn is not None, timeout=10)\n+            assert(success)\n+\n+            [tx.calc_sha256() for tx in block.vtx]\n+            with mininode_lock:\n+                assert_equal(self.test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                all_indices = msg.block_txn_request.to_absolute()\n+                for index in all_indices:\n+                    tx = self.test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx.calc_sha256()\n+                    assert_equal(tx.sha256, block.vtx[index].sha256)\n+                self.test_node.last_blocktxn = None\n+            current_height -= 1\n+\n+        # Next request should be ignored, as we're past the allowed depth.\n+        block_hash = self.nodes[0].getblockhash(current_height)\n+        msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert_equal(self.test_node.last_blocktxn, None)\n+\n+    def test_compactblocks_not_at_tip(self):\n+        print(\"Testing compactblock requests/announcements not at chain tip...\")\n+\n+        # Test that requesting old compactblocks doesn't work.\n+        MAX_CMPCTBLOCK_DEPTH = 11\n+        new_blocks = []\n+        for i in range(MAX_CMPCTBLOCK_DEPTH):\n+            self.test_node.clear_block_announcement()\n+            new_blocks.append(self.nodes[0].generate(1)[0])\n+            wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_cmpctblock is not None, timeout=30)\n+        assert(success)\n+\n+        self.test_node.clear_block_announcement()\n+        self.nodes[0].generate(1)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_block is not None, timeout=30)\n+        assert(success)\n+        with mininode_lock:\n+            self.test_node.last_block.block.calc_sha256()\n+            assert_equal(self.test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+\n+        # Generate an old compactblock, and verify that it's not accepted.\n+        cur_height = self.nodes[0].getblockcount()\n+        hashPrevBlock = int(self.nodes[0].getblockhash(cur_height-5), 16)\n+        block = self.build_block_on_tip()\n+        block.hashPrevBlock = hashPrevBlock\n+        block.solve()\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+\n+        tips = self.nodes[0].getchaintips()\n+        found = False\n+        for x in tips:\n+            if x[\"hash\"] == block.hash:\n+                assert_equal(x[\"status\"], \"headers-only\")\n+                found = True\n+                break\n+        assert(found)\n+\n+        # Requesting this block via getblocktxn should silently fail\n+        # (to avoid fingerprinting attacks).\n+        msg = msg_getblocktxn()\n+        msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n+        with mininode_lock:\n+            self.test_node.last_blocktxn = None\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert(self.test_node.last_blocktxn is None)\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        self.test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n+        self.test_node.add_connection(connections[0])\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        self.test_node.wait_for_verack()\n+\n+        # We will need UTXOs to construct transactions in later tests.\n+        self.make_utxos()\n+\n+        self.test_sendcmpct()\n+        self.test_compactblock_construction()\n+        self.test_compactblock_requests()\n+        self.test_getblocktxn_requests()\n+        self.test_getblocktxn_handler()\n+        self.test_compactblocks_not_at_tip()\n+        self.test_incorrect_blocktxn_response()\n+        self.test_invalid_cmpctblock_message()\n+\n+\n+if __name__ == '__main__':\n+    CompactBlocksTest().main()"
      }
    ]
  }
]