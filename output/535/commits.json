[
  {
    "sha": "6ccff2cbdebca38e4913b679784a4865edfbb12a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Y2NmZjJjYmRlYmNhMzhlNDkxM2I2Nzk3ODRhNDg2NWVkZmJiMTJh",
    "commit": {
      "author": {
        "name": "Nils Schneider",
        "email": "nils.schneider@gmail.com",
        "date": "2011-09-27T18:16:07Z"
      },
      "committer": {
        "name": "Nils Schneider",
        "email": "nils.schneider@gmail.com",
        "date": "2011-09-30T18:00:22Z"
      },
      "message": "remove cryptopp dependency, add simple unittest for SHA256Transform()",
      "tree": {
        "sha": "e13e71eb80ffa412810edcae47eea4f2b86e5b2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e13e71eb80ffa412810edcae47eea4f2b86e5b2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ccff2cbdebca38e4913b679784a4865edfbb12a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ccff2cbdebca38e4913b679784a4865edfbb12a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6ccff2cbdebca38e4913b679784a4865edfbb12a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ccff2cbdebca38e4913b679784a4865edfbb12a/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4769e44a326f61bdf47fa39346e1293b97e31c4"
      }
    ],
    "stats": {
      "total": 6144,
      "additions": 87,
      "deletions": 6057
    },
    "files": [
      {
        "sha": "9b2a193acc79e600a9cb2b871fcc64a040e08f3c",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 15,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -1,6 +1,6 @@\n TEMPLATE = app\n TARGET =\n-INCLUDEPATH += src src/json src/cryptopp src/qt\n+INCLUDEPATH += src src/json src/qt\n DEFINES += QT_GUI\n CONFIG += no_include_pwd\n \n@@ -45,7 +45,7 @@ QMAKE_LFLAGS += -fstack-protector\n QMAKE_CXXFLAGS_WARN_ON = -fdiagnostics-show-option -Wall -Wno-invalid-offsetof -Wno-unused-variable -Wno-unused-parameter -Wno-sign-compare -Wno-char-subscripts  -Wno-unused-value -Wno-sequence-point -Wno-parentheses -Wno-unknown-pragmas -Wno-switch\n \n # Input\n-DEPENDPATH += src/qt src src/cryptopp src json/include\n+DEPENDPATH += src/qt src src json/include\n HEADERS += src/qt/bitcoingui.h \\\n     src/qt/transactiontablemodel.h \\\n     src/qt/addresstablemodel.h \\\n@@ -60,17 +60,6 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/util.h \\\n     src/uint256.h \\\n     src/serialize.h \\\n-    src/cryptopp/stdcpp.h \\\n-    src/cryptopp/smartptr.h \\\n-    src/cryptopp/simple.h \\\n-    src/cryptopp/sha.h \\\n-    src/cryptopp/secblock.h \\\n-    src/cryptopp/pch.h \\\n-    src/cryptopp/misc.h \\\n-    src/cryptopp/iterhash.h \\\n-    src/cryptopp/cryptlib.h \\\n-    src/cryptopp/cpu.h \\\n-    src/cryptopp/config.h \\\n     src/strlcpy.h \\\n     src/main.h \\\n     src/net.h \\\n@@ -126,8 +115,6 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/aboutdialog.cpp \\\n     src/qt/editaddressdialog.cpp \\\n     src/qt/bitcoinaddressvalidator.cpp \\\n-    src/cryptopp/sha.cpp \\\n-    src/cryptopp/cpu.cpp \\\n     src/util.cpp \\\n     src/script.cpp \\\n     src/main.cpp \\"
      },
      {
        "sha": "3ceaebd77058ee5b943a6cfe32bb4b6b259c479b",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -4,7 +4,6 @@\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"headers.h\"\n-#include \"cryptopp/sha.h\"\n #include \"db.h\"\n #include \"net.h\"\n #include \"init.h\"\n@@ -1628,7 +1627,7 @@ Value getwork(const Array& params, bool fHelp)\n \n         // Byte reverse\n         for (int i = 0; i < 128/4; i++)\n-            ((unsigned int*)pdata)[i] = CryptoPP::ByteReverse(((unsigned int*)pdata)[i]);\n+            ((unsigned int*)pdata)[i] = ByteReverse(((unsigned int*)pdata)[i]);\n \n         // Get saved block\n         if (!mapNewBlock.count(pdata->hashMerkleRoot))"
      },
      {
        "sha": "fc3f0546930351f42e7fafdecf432055bf7802c4",
        "filename": "src/cryptopp/License.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 67,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/License.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/License.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/License.txt?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,67 +0,0 @@\n-Compilation Copyright (c) 1995-2009 by Wei Dai.  All rights reserved.\n-This copyright applies only to this software distribution package \n-as a compilation, and does not imply a copyright on any particular \n-file in the package.\n-\n-The following files are copyrighted by their respective original authors,\n-and their use is subject to additional licenses included in these files.\n-\n-mars.cpp - Copyright 1998 Brian Gladman.\n-\n-All other files in this compilation are placed in the public domain by\n-Wei Dai and other contributors.\n-\n-I would like to thank the following authors for placing their works into\n-the public domain:\n-\n-Joan Daemen - 3way.cpp\n-Leonard Janke - cast.cpp, seal.cpp\n-Steve Reid - cast.cpp\n-Phil Karn - des.cpp\n-Andrew M. Kuchling - md2.cpp, md4.cpp\n-Colin Plumb - md5.cpp\n-Seal Woods - rc6.cpp\n-Chris Morgan - rijndael.cpp\n-Paulo Baretto - rijndael.cpp, skipjack.cpp, square.cpp\n-Richard De Moliner - safer.cpp\n-Matthew Skala - twofish.cpp\n-Kevin Springle - camellia.cpp, shacal2.cpp, ttmac.cpp, whrlpool.cpp, ripemd.cpp\n-\n-Permission to use, copy, modify, and distribute this compilation for\n-any purpose, including commercial applications, is hereby granted\n-without fee, subject to the following restrictions:\n-\n-1. Any copy or modification of this compilation in any form, except\n-in object code form as part of an application software, must include\n-the above copyright notice and this license.\n-\n-2. Users of this software agree that any modification or extension\n-they provide to Wei Dai will be considered public domain and not\n-copyrighted unless it includes an explicit copyright notice.\n-\n-3. Wei Dai makes no warranty or representation that the operation of the\n-software in this compilation will be error-free, and Wei Dai is under no\n-obligation to provide any services, by way of maintenance, update, or\n-otherwise.  THE SOFTWARE AND ANY DOCUMENTATION ARE PROVIDED \"AS IS\"\n-WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, BUT NOT LIMITED TO,\n-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n-PURPOSE. IN NO EVENT WILL WEI DAI OR ANY OTHER CONTRIBUTOR BE LIABLE FOR\n-DIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES, EVEN IF\n-ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n-\n-4. Users will not use Wei Dai or any other contributor's name in any \n-publicity or advertising, without prior written consent in each case.\n-\n-5. Export of this software from the United States may require a\n-specific license from the United States Government.  It is the\n-responsibility of any person or organization contemplating export\n-to obtain such a license before exporting.\n-\n-6. Certain parts of this software may be protected by patents.  It\n-is the users' responsibility to obtain the appropriate\n-licenses before using those parts.\n-\n-If this compilation is used in object code form in an application\n-software, acknowledgement of the author is not required but would be\n-appreciated. The contribution of any useful modifications or extensions\n-to Wei Dai is not required but would also be appreciated."
      },
      {
        "sha": "861c036c6802b3ba213801d4992e8b92c8ea4879",
        "filename": "src/cryptopp/Readme.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 429,
        "changes": 429,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/Readme.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/Readme.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/Readme.txt?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,429 +0,0 @@\n-Crypto++: a C++ Class Library of Cryptographic Schemes\n-Version 5.6.0 (3/15/2009)\n-\n-Crypto++ Library is a free C++ class library of cryptographic schemes.\n-Currently the library contains the following algorithms:\n-\n-                   algorithm type  name\n-\n- authenticated encryption schemes  GCM, CCM, EAX\n- \n-        high speed stream ciphers  Panama, Sosemanuk, Salsa20, XSalsa20\n-\n-           AES and AES candidates  AES (Rijndael), RC6, MARS, Twofish, Serpent,\n-                                   CAST-256\n-\n-                                   IDEA, Triple-DES (DES-EDE2 and DES-EDE3),\n-              other block ciphers  Camellia, SEED, RC5, Blowfish, TEA, XTEA,\n-                                   Skipjack, SHACAL-2\n-\n-  block cipher modes of operation  ECB, CBC, CBC ciphertext stealing (CTS),\n-                                   CFB, OFB, counter mode (CTR)\n-\n-     message authentication codes  VMAC, HMAC, CMAC, CBC-MAC, DMAC, \n-                                   Two-Track-MAC\n-\n-                                   SHA-1, SHA-2 (SHA-224, SHA-256, SHA-384, and\n-                   hash functions  SHA-512), Tiger, WHIRLPOOL, RIPEMD-128,\n-                                   RIPEMD-256, RIPEMD-160, RIPEMD-320\n-\n-                                   RSA, DSA, ElGamal, Nyberg-Rueppel (NR),\n-          public-key cryptography  Rabin, Rabin-Williams (RW), LUC, LUCELG,\n-                                   DLIES (variants of DHAES), ESIGN\n-\n-   padding schemes for public-key  PKCS#1 v2.0, OAEP, PSS, PSSR, IEEE P1363\n-                          systems  EMSA2 and EMSA5\n-\n-                                   Diffie-Hellman (DH), Unified Diffie-Hellman\n-            key agreement schemes  (DH2), Menezes-Qu-Vanstone (MQV), LUCDIF,\n-                                   XTR-DH\n-\n-      elliptic curve cryptography  ECDSA, ECNR, ECIES, ECDH, ECMQV\n-\n-          insecure or obsolescent  MD2, MD4, MD5, Panama Hash, DES, ARC4, SEAL\n-algorithms retained for backwards  3.0, WAKE, WAKE-OFB, DESX (DES-XEX3), RC2,\n-     compatibility and historical  SAFER, 3-WAY, GOST, SHARK, CAST-128, Square\n-                            value\n-\n-Other features include:\n-\n-  * pseudo random number generators (PRNG): ANSI X9.17 appendix C, RandomPool\n-  * password based key derivation functions: PBKDF1 and PBKDF2 from PKCS #5,\n-    PBKDF from PKCS #12 appendix B\n-  * Shamir's secret sharing scheme and Rabin's information dispersal algorithm\n-    (IDA)\n-  * fast multi-precision integer (bignum) and polynomial operations\n-  * finite field arithmetics, including GF(p) and GF(2^n)\n-  * prime number generation and verification\n-  * useful non-cryptographic algorithms\n-      + DEFLATE (RFC 1951) compression/decompression with gzip (RFC 1952) and\n-        zlib (RFC 1950) format support\n-      + hex, base-32, and base-64 coding/decoding\n-      + 32-bit CRC and Adler32 checksum\n-  * class wrappers for these operating system features (optional):\n-      + high resolution timers on Windows, Unix, and Mac OS\n-      + Berkeley and Windows style sockets\n-      + Windows named pipes\n-      + /dev/random, /dev/urandom, /dev/srandom\n-      + Microsoft's CryptGenRandom on Windows\n-  * A high level interface for most of the above, using a filter/pipeline\n-    metaphor\n-  * benchmarks and validation testing\n-  * x86, x86-64 (x64), MMX, and SSE2 assembly code for the most commonly used\n-    algorithms, with run-time CPU feature detection and code selection\n-  * some versions are available in FIPS 140-2 validated form\n-\n-You are welcome to use it for any purpose without paying me, but see\n-License.txt for the fine print.\n-\n-The following compilers are supported for this release. Please visit\n-http://www.cryptopp.com the most up to date build instructions and porting notes.\n-\n-  * MSVC 6.0 - 2008\n-  * GCC 3.3 - 4.3\n-  * C++Builder 2009\n-  * Intel C++ Compiler 9 - 11\n-  * Sun Studio 12 (CC 5.9)\n-\n-*** Important Usage Notes ***\n-\n-1. If a constructor for A takes a pointer to an object B (except primitive\n-types such as int and char), then A owns B and will delete B at A's\n-destruction.  If a constructor for A takes a reference to an object B,\n-then the caller retains ownership of B and should not destroy it until\n-A no longer needs it. \n-\n-2. Crypto++ is thread safe at the class level. This means you can use\n-Crypto++ safely in a multithreaded application, but you must provide\n-synchronization when multiple threads access a common Crypto++ object.\n-\n-*** MSVC-Specific Information ***\n-\n-On Windows, Crypto++ can be compiled into 3 forms: a static library\n-including all algorithms, a DLL with only FIPS Approved algorithms, and\n-a static library with only algorithms not in the DLL.\n-(FIPS Approved means Approved according to the FIPS 140-2 standard.)\n-The DLL may be used by itself, or it may be used together with the second\n-form of the static library. MSVC project files are included to build\n-all three forms, and sample applications using each of the three forms\n-are also included.\n-\n-To compile Crypto++ with MSVC, open the \"cryptest.dsw\" (for MSVC 6 and MSVC .NET \n-2003) or \"cryptest.sln\" (for MSVC .NET 2005) workspace file and build one or \n-more of the following projects:\n-\n-cryptdll - This builds the DLL. Please note that if you wish to use Crypto++\n-  as a FIPS validated module, you must use a pre-built DLL that has undergone\n-  the FIPS validation process instead of building your own.\n-dlltest - This builds a sample application that only uses the DLL.\n-cryptest Non-DLL-Import Configuration - This builds the full static library\n-  along with a full test driver.\n-cryptest DLL-Import Configuration - This builds a static library containing\n-  only algorithms not in the DLL, along with a full test driver that uses\n-  both the DLL and the static library.\n-\n-To use the Crypto++ DLL in your application, #include \"dll.h\" before including\n-any other Crypto++ header files, and place the DLL in the same directory as\n-your .exe file. dll.h includes the line #pragma comment(lib, \"cryptopp\")\n-so you don't have to explicitly list the import library in your project\n-settings. To use a static library form of Crypto++, specify it as\n-an additional library to link with in your project settings.\n-In either case you should check the compiler options to\n-make sure that the library and your application are using the same C++\n-run-time libraries and calling conventions.\n-\n-*** DLL Memory Management ***\n-\n-Because it's possible for the Crypto++ DLL to delete objects allocated \n-by the calling application, they must use the same C++ memory heap. Three \n-methods are provided to achieve this.\n-1.  The calling application can tell Crypto++ what heap to use. This method \n-    is required when the calling application uses a non-standard heap.\n-2.  Crypto++ can tell the calling application what heap to use. This method \n-    is required when the calling application uses a statically linked C++ Run \n-    Time Library. (Method 1 does not work in this case because the Crypto++ DLL \n-    is initialized before the calling application's heap is initialized.)\n-3.  Crypto++ can automatically use the heap provided by the calling application's \n-    dynamically linked C++ Run Time Library. The calling application must\n-    make sure that the dynamically linked C++ Run Time Library is initialized\n-    before Crypto++ is loaded. (At this time it is not clear if it is possible\n-    to control the order in which DLLs are initialized on Windows 9x machines,\n-    so it might be best to avoid using this method.)\n-\n-When Crypto++ attaches to a new process, it searches all modules loaded \n-into the process space for exported functions \"GetNewAndDeleteForCryptoPP\" \n-and \"SetNewAndDeleteFromCryptoPP\". If one of these functions is found, \n-Crypto++ uses methods 1 or 2, respectively, by calling the function. \n-Otherwise, method 3 is used. \n-\n-*** GCC-Specific Information ***\n-\n-A makefile is included for you to compile Crypto++ with GCC. Make sure\n-you are using GNU Make and GNU ld. The make process will produce two files,\n-libcryptopp.a and cryptest.exe. Run \"cryptest.exe v\" for the validation\n-suite.\n-\n-*** Documentation and Support ***\n-\n-Crypto++ is documented through inline comments in header files, which are\n-processed through Doxygen to produce an HTML reference manual. You can find\n-a link to the manual from http://www.cryptopp.com. Also at that site is\n-the Crypto++ FAQ, which you should browse through before attempting to \n-use this library, because it will likely answer many of questions that\n-may come up.\n-\n-If you run into any problems, please try the Crypto++ mailing list.\n-The subscription information and the list archive are available on\n-http://www.cryptopp.com. You can also email me directly by visiting\n-http://www.weidai.com, but you will probably get a faster response through\n-the mailing list.\n-\n-*** History ***\n-\n-1.0 - First public release.  Withdrawn at the request of RSA DSI.\n-    - included Blowfish, BBS, DES, DH, Diamond, DSA, ElGamal, IDEA,\n-      MD5, RC4, RC5, RSA, SHA, WAKE, secret sharing, DEFLATE compression\n-    - had a serious bug in the RSA key generation code.\n-\n-1.1 - Removed RSA, RC4, RC5\n-    - Disabled calls to RSAREF's non-public functions\n-    - Minor bugs fixed\n-\n-2.0 - a completely new, faster multiprecision integer class\n-    - added MD5-MAC, HAVAL, 3-WAY, TEA, SAFER, LUC, Rabin, BlumGoldwasser,\n-      elliptic curve algorithms\n-    - added the Lucas strong probable primality test\n-    - ElGamal encryption and signature schemes modified to avoid weaknesses\n-    - Diamond changed to Diamond2 because of key schedule weakness\n-    - fixed bug in WAKE key setup\n-    - SHS class renamed to SHA\n-    - lots of miscellaneous optimizations\n-\n-2.1 - added Tiger, HMAC, GOST, RIPE-MD160, LUCELG, LUCDIF, XOR-MAC,\n-      OAEP, PSSR, SHARK\n-    - added precomputation to DH, ElGamal, DSA, and elliptic curve algorithms\n-    - added back RC5 and a new RSA\n-    - optimizations in elliptic curves over GF(p)\n-    - changed Rabin to use OAEP and PSSR\n-    - changed many classes to allow copy constructors to work correctly\n-    - improved exception generation and handling\n-\n-2.2 - added SEAL, CAST-128, Square\n-    - fixed bug in HAVAL (padding problem)\n-    - fixed bug in triple-DES (decryption order was reversed)\n-    - fixed bug in RC5 (couldn't handle key length not a multiple of 4)\n-    - changed HMAC to conform to RFC-2104 (which is not compatible\n-      with the original HMAC)\n-    - changed secret sharing and information dispersal to use GF(2^32)\n-      instead of GF(65521)\n-    - removed zero knowledge prover/verifier for graph isomorphism\n-    - removed several utility classes in favor of the C++ standard library\n-\n-2.3 - ported to EGCS\n-    - fixed incomplete workaround of min/max conflict in MSVC\n-\n-3.0 - placed all names into the \"CryptoPP\" namespace\n-    - added MD2, RC2, RC6, MARS, RW, DH2, MQV, ECDHC, CBC-CTS\n-    - added abstract base classes PK_SimpleKeyAgreementDomain and\n-      PK_AuthenticatedKeyAgreementDomain\n-    - changed DH and LUCDIF to implement the PK_SimpleKeyAgreementDomain\n-      interface and to perform domain parameter and key validation\n-    - changed interfaces of PK_Signer and PK_Verifier to sign and verify\n-      messages instead of message digests\n-    - changed OAEP to conform to PKCS#1 v2.0\n-    - changed benchmark code to produce HTML tables as output\n-    - changed PSSR to track IEEE P1363a\n-    - renamed ElGamalSignature to NR and changed it to track IEEE P1363\n-    - renamed ECKEP to ECMQVC and changed it to track IEEE P1363\n-    - renamed several other classes for clarity\n-    - removed support for calling RSAREF\n-    - removed option to compile old SHA (SHA-0)\n-    - removed option not to throw exceptions\n-\n-3.1 - added ARC4, Rijndael, Twofish, Serpent, CBC-MAC, DMAC\n-    - added interface for querying supported key lengths of symmetric ciphers\n-      and MACs\n-    - added sample code for RSA signature and verification\n-    - changed CBC-CTS to be compatible with RFC 2040\n-    - updated SEAL to version 3.0 of the cipher specification\n-    - optimized multiprecision squaring and elliptic curves over GF(p)\n-    - fixed bug in MARS key setup\n-    - fixed bug with attaching objects to Deflator\n-\n-3.2 - added DES-XEX3, ECDSA, DefaultEncryptorWithMAC\n-    - renamed DES-EDE to DES-EDE2 and TripleDES to DES-EDE3\n-    - optimized ARC4\n-    - generalized DSA to allow keys longer than 1024 bits\n-    - fixed bugs in GF2N and ModularArithmetic that can cause calculation errors\n-    - fixed crashing bug in Inflator when given invalid inputs\n-    - fixed endian bug in Serpent\n-    - fixed padding bug in Tiger\n-\n-4.0 - added Skipjack, CAST-256, Panama, SHA-2 (SHA-256, SHA-384, and SHA-512),\n-      and XTR-DH\n-    - added a faster variant of Rabin's Information Dispersal Algorithm (IDA)\n-    - added class wrappers for these operating system features:\n-      - high resolution timers on Windows, Unix, and MacOS\n-      - Berkeley and Windows style sockets\n-      - Windows named pipes\n-      - /dev/random and /dev/urandom on Linux and FreeBSD\n-      - Microsoft's CryptGenRandom on Windows\n-    - added support for SEC 1 elliptic curve key format and compressed points\n-    - added support for X.509 public key format (subjectPublicKeyInfo) for\n-      RSA, DSA, and elliptic curve schemes\n-    - added support for DER and OpenPGP signature format for DSA\n-    - added support for ZLIB compressed data format (RFC 1950)\n-    - changed elliptic curve encryption to use ECIES (as defined in SEC 1)\n-    - changed MARS key schedule to reflect the latest specification\n-    - changed BufferedTransformation interface to support multiple channels\n-      and messages\n-    - changed CAST and SHA-1 implementations to use public domain source code\n-    - fixed bug in StringSource\n-    - optmized multi-precision integer code for better performance\n-\n-4.1 - added more support for the recommended elliptic curve parameters in SEC 2\n-    - added Panama MAC, MARC4\n-    - added IV stealing feature to CTS mode\n-    - added support for PKCS #8 private key format for RSA, DSA, and elliptic\n-      curve schemes\n-    - changed Deflate, MD5, Rijndael, and Twofish to use public domain code\n-    - fixed a bug with flushing compressed streams\n-    - fixed a bug with decompressing stored blocks\n-    - fixed a bug with EC point decompression using non-trinomial basis\n-    - fixed a bug in NetworkSource::GeneralPump()\n-    - fixed a performance issue with EC over GF(p) decryption\n-    - fixed syntax to allow GCC to compile without -fpermissive\n-    - relaxed some restrictions in the license\n-\n-4.2 - added support for longer HMAC keys\n-    - added MD4 (which is not secure so use for compatibility purposes only)\n-    - added compatibility fixes/workarounds for STLport 4.5, GCC 3.0.2,\n-      and MSVC 7.0\n-    - changed MD2 to use public domain code\n-    - fixed a bug with decompressing multiple messages with the same object\n-    - fixed a bug in CBC-MAC with MACing multiple messages with the same object\n-    - fixed a bug in RC5 and RC6 with zero-length keys\n-    - fixed a bug in Adler32 where incorrect checksum may be generated\n-\n-5.0 - added ESIGN, DLIES, WAKE-OFB, PBKDF1 and PBKDF2 from PKCS #5\n-    - added key validation for encryption and signature public/private keys\n-    - renamed StreamCipher interface to SymmetricCipher, which is now implemented\n-      by both stream ciphers and block cipher modes including ECB and CBC\n-    - added keying interfaces to support resetting of keys and IVs without\n-      having to destroy and recreate objects\n-    - changed filter interface to support non-blocking input/output\n-    - changed SocketSource and SocketSink to use overlapped I/O on Microsoft Windows\n-    - grouped related classes inside structs to help templates, for example\n-      AESEncryption and AESDecryption are now AES::Encryption and AES::Decryption\n-    - where possible, typedefs have been added to improve backwards \n-      compatibility when the CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY macro is defined\n-    - changed Serpent, HAVAL and IDEA to use public domain code\n-    - implemented SSE2 optimizations for Integer operations\n-    - fixed a bug in HMAC::TruncatedFinal()\n-    - fixed SKIPJACK byte ordering following NIST clarification dated 5/9/02\n-\n-5.01 - added known answer test for X9.17 RNG in FIPS 140 power-up self test\n-     - submitted to NIST/CSE, but not publicly released\n-\n-5.02 - changed EDC test to MAC integrity check using HMAC/SHA1\n-     - improved performance of integrity check\n-     - added blinding to defend against RSA timing attack\n-\n-5.03 - created DLL version of Crypto++ for FIPS 140-2 validation\n-     - fixed vulnerabilities in GetNextIV for CTR and OFB modes\n-\n-5.0.4 - Removed DES, SHA-256, SHA-384, SHA-512 from DLL\n-\n-5.1 - added PSS padding and changed PSSR to track IEEE P1363a draft standard\n-    - added blinding for RSA and Rabin to defend against timing attacks\n-      on decryption operations\n-    - changed signing and decryption APIs to support the above\n-    - changed WaitObjectContainer to allow waiting for more than 64\n-      objects at a time on Win32 platforms\n-    - fixed a bug in CBC and ECB modes with processing non-aligned data\n-    - fixed standard conformance bugs in DLIES (DHAES mode) and RW/EMSA2\n-      signature scheme (these fixes are not backwards compatible)\n-    - fixed a number of compiler warnings, minor bugs, and portability problems\n-    - removed Sapphire\n-\n-5.2 - merged in changes for 5.01 - 5.0.4\n-    - added support for using encoding parameters and key derivation parameters\n-      with public key encryption (implemented by OAEP and DL/ECIES)\n-    - added Camellia, SHACAL-2, Two-Track-MAC, Whirlpool, RIPEMD-320,\n-      RIPEMD-128, RIPEMD-256, Base-32 coding, FIPS variant of CFB mode\n-    - added ThreadUserTimer for timing thread CPU usage\n-    - added option for password-based key derivation functions\n-      to iterate until a mimimum elapsed thread CPU time is reached\n-    - added option (on by default) for DEFLATE compression to detect\n-      uncompressible files and process them more quickly\n-    - improved compatibility and performance on 64-bit platforms,\n-      including Alpha, IA-64, x86-64, PPC64, Sparc64, and MIPS64\n-    - fixed ONE_AND_ZEROS_PADDING to use 0x80 instead 0x01 as padding.\n-    - fixed encoding/decoding of PKCS #8 privateKeyInfo to properly\n-      handle optional attributes\n-\n-5.2.1 - fixed bug in the \"dlltest\" DLL testing program\n-      - fixed compiling with STLport using VC .NET\n-      - fixed compiling with -fPIC using GCC\n-      - fixed compiling with -msse2 on systems without memalign()\n-      - fixed inability to instantiate PanamaMAC\n-      - fixed problems with inline documentation\n-\n-5.2.2 - added SHA-224\n-      - put SHA-256, SHA-384, SHA-512, RSASSA-PSS into DLL\n-      \n-5.2.3 - fixed issues with FIPS algorithm test vectors\n-      - put RSASSA-ISO into DLL\n-\n-5.3 - ported to MSVC 2005 with support for x86-64\n-    - added defense against AES timing attacks, and more AES test vectors\n-    - changed StaticAlgorithmName() of Rijndael to \"AES\", CTR to \"CTR\"\n-\n-5.4 - added Salsa20\n-    - updated Whirlpool to version 3.0\n-    - ported to GCC 4.1, Sun C++ 5.8, and Borland C++Builder 2006\n-\n-5.5 - added VMAC and Sosemanuk (with x86-64 and SSE2 assembly)\n-    - improved speed of integer arithmetic, AES, SHA-512, Tiger, Salsa20,\n-      Whirlpool, and PANAMA cipher using assembly (x86-64, MMX, SSE2)\n-    - optimized Camellia and added defense against timing attacks\n-    - updated benchmarks code to show cycles per byte and to time key/IV setup\n-    - started using OpenMP for increased multi-core speed\n-    - enabled GCC optimization flags by default in GNUmakefile\n-    - added blinding and computational error checking for RW signing\n-    - changed RandomPool, X917RNG, GetNextIV, DSA/NR/ECDSA/ECNR to reduce\n-      the risk of reusing random numbers and IVs after virtual machine state\n-      rollback\n-    - changed default FIPS mode RNG from AutoSeededX917RNG<DES_EDE3> to\n-      AutoSeededX917RNG<AES>\n-    - fixed PANAMA cipher interface to accept 256-bit key and 256-bit IV\n-    - moved MD2, MD4, MD5, PanamaHash, ARC4, WAKE_CFB into the namespace \"Weak\"\n-    - removed HAVAL, MD5-MAC, XMAC\n-\n-5.5.1 - fixed VMAC validation failure on 32-bit big-endian machines\n-\n-5.5.2 - ported x64 assembly language code for AES, Salsa20, Sosemanuk, and Panama\n-        to MSVC 2005 (using MASM since MSVC doesn't support inline assembly on x64)\n-      - fixed Salsa20 initialization crash on non-SSE2 machines\n-      - fixed Whirlpool crash on Pentium 2 machines\n-      - fixed possible branch prediction analysis (BPA) vulnerability in\n-        MontgomeryReduce(), which may affect security of RSA, RW, LUC\n-      - fixed link error with MSVC 2003 when using \"debug DLL\" form of runtime library\n-      - fixed crash in SSE2_Add on P4 machines when compiled with \n-        MSVC 6.0 SP5 with Processor Pack\n-      - ported to MSVC 2008, GCC 4.2, Sun CC 5.9, Intel C++ Compiler 10.0, \n-        and Borland C++Builder 2007\n-\n-5.6 - added AuthenticatedSymmetricCipher interface class and Filter wrappers\n-    - added CCM, GCM (with SSE2 assembly), EAX, CMAC, XSalsa20, and SEED\n-    - added support for variable length IVs\n-    - improved AES and SHA-256 speed on x86 and x64\n-    - fixed incorrect VMAC computation on message lengths \n-      that are >64 mod 128 (x86 assembly version is not affected)\n-    - fixed compiler error in vmac.cpp on x86 with GCC -fPIC\n-    - fixed run-time validation error on x86-64 with GCC 4.3.2 -O2\n-    - fixed HashFilter bug when putMessage=true\n-    - removed WORD64_AVAILABLE; compiler support for 64-bit int is now required\n-    - ported to GCC 4.3, C++Builder 2009, Sun CC 5.10, Intel C++ Compiler 11\n-\n-Written by Wei Dai"
      },
      {
        "sha": "0737027f41f37e3946c8eff124dac70ca11c818d",
        "filename": "src/cryptopp/config.h",
        "status": "removed",
        "additions": 0,
        "deletions": 462,
        "changes": 462,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/config.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,462 +0,0 @@\n-#ifndef CRYPTOPP_CONFIG_H\n-#define CRYPTOPP_CONFIG_H\n-\n-//// Bitcoin: disable SSE2 on 32-bit\n-#if !defined(_M_X64) && !defined(__x86_64__)\n-#define CRYPTOPP_DISABLE_SSE2  1\n-#endif\n-//////////// end of Bitcoin changes\n-\n-\n-// ***************** Important Settings ********************\n-\n-// define this if running on a big-endian CPU\n-#if !defined(IS_LITTLE_ENDIAN) && (defined(__BIG_ENDIAN__) || defined(__sparc) || defined(__sparc__) || defined(__hppa__) || defined(__mips__) || (defined(__MWERKS__) && !defined(__INTEL__)))\n-#\tdefine IS_BIG_ENDIAN\n-#endif\n-\n-// define this if running on a little-endian CPU\n-// big endian will be assumed if IS_LITTLE_ENDIAN is not defined\n-#ifndef IS_BIG_ENDIAN\n-#\tdefine IS_LITTLE_ENDIAN\n-#endif\n-\n-// define this if you want to disable all OS-dependent features,\n-// such as sockets and OS-provided random number generators\n-// #define NO_OS_DEPENDENCE\n-\n-// Define this to use features provided by Microsoft's CryptoAPI.\n-// Currently the only feature used is random number generation.\n-// This macro will be ignored if NO_OS_DEPENDENCE is defined.\n-#define USE_MS_CRYPTOAPI\n-\n-// Define this to 1 to enforce the requirement in FIPS 186-2 Change Notice 1 that only 1024 bit moduli be used\n-#ifndef DSA_1024_BIT_MODULUS_ONLY\n-#\tdefine DSA_1024_BIT_MODULUS_ONLY 1\n-#endif\n-\n-// ***************** Less Important Settings ***************\n-\n-// define this to retain (as much as possible) old deprecated function and class names\n-// #define CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\n-#define GZIP_OS_CODE 0\n-\n-// Try this if your CPU has 256K internal cache or a slow multiply instruction\n-// and you want a (possibly) faster IDEA implementation using log tables\n-// #define IDEA_LARGECACHE\n-\n-// Define this if, for the linear congruential RNG, you want to use\n-// the original constants as specified in S.K. Park and K.W. Miller's\n-// CACM paper.\n-// #define LCRNG_ORIGINAL_NUMBERS\n-\n-// choose which style of sockets to wrap (mostly useful for cygwin which has both)\n-#define PREFER_BERKELEY_STYLE_SOCKETS\n-// #define PREFER_WINDOWS_STYLE_SOCKETS\n-\n-// set the name of Rijndael cipher, was \"Rijndael\" before version 5.3\n-#define CRYPTOPP_RIJNDAEL_NAME \"AES\"\n-\n-// ***************** Important Settings Again ********************\n-// But the defaults should be ok.\n-\n-// namespace support is now required\n-#ifdef NO_NAMESPACE\n-#\terror namespace support is now required\n-#endif\n-\n-// Define this to workaround a Microsoft CryptoAPI bug where\n-// each call to CryptAcquireContext causes a 100 KB memory leak.\n-// Defining this will cause Crypto++ to make only one call to CryptAcquireContext.\n-#define WORKAROUND_MS_BUG_Q258000\n-\n-#ifdef CRYPTOPP_DOXYGEN_PROCESSING\n-// Avoid putting \"CryptoPP::\" in front of everything in Doxygen output\n-#\tdefine CryptoPP\n-#\tdefine NAMESPACE_BEGIN(x)\n-#\tdefine NAMESPACE_END\n-// Get Doxygen to generate better documentation for these typedefs\n-#\tdefine DOCUMENTED_TYPEDEF(x, y) class y : public x {};\n-#else\n-#\tdefine NAMESPACE_BEGIN(x) namespace x {\n-#\tdefine NAMESPACE_END }\n-#\tdefine DOCUMENTED_TYPEDEF(x, y) typedef x y;\n-#endif\n-#define ANONYMOUS_NAMESPACE_BEGIN namespace {\n-#define USING_NAMESPACE(x) using namespace x;\n-#define DOCUMENTED_NAMESPACE_BEGIN(x) namespace x {\n-#define DOCUMENTED_NAMESPACE_END }\n-\n-// What is the type of the third parameter to bind?\n-// For Unix, the new standard is ::socklen_t (typically unsigned int), and the old standard is int.\n-// Unfortunately there is no way to tell whether or not socklen_t is defined.\n-// To work around this, TYPE_OF_SOCKLEN_T is a macro so that you can change it from the makefile.\n-#ifndef TYPE_OF_SOCKLEN_T\n-#\tif defined(_WIN32) || defined(__CYGWIN__)\n-#\t\tdefine TYPE_OF_SOCKLEN_T int\n-#\telse\n-#\t\tdefine TYPE_OF_SOCKLEN_T ::socklen_t\n-#\tendif\n-#endif\n-\n-#if defined(__CYGWIN__) && defined(PREFER_WINDOWS_STYLE_SOCKETS)\n-#\tdefine __USE_W32_SOCKETS\n-#endif\n-\n-typedef unsigned char byte;\t\t// put in global namespace to avoid ambiguity with other byte typedefs\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-typedef unsigned short word16;\n-typedef unsigned int word32;\n-\n-#if defined(_MSC_VER) || defined(__BORLANDC__)\n-\ttypedef unsigned __int64 word64;\n-\t#define W64LIT(x) x##ui64\n-#else\n-\ttypedef unsigned long long word64;\n-\t#define W64LIT(x) x##ULL\n-#endif\n-\n-// define large word type, used for file offsets and such\n-typedef word64 lword;\n-const lword LWORD_MAX = W64LIT(0xffffffffffffffff);\n-\n-#ifdef __GNUC__\n-\t#define CRYPTOPP_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n-#endif\n-\n-// define hword, word, and dword. these are used for multiprecision integer arithmetic\n-// Intel compiler won't have _umul128 until version 10.0. See http://softwarecommunity.intel.com/isn/Community/en-US/forums/thread/30231625.aspx\n-#if (defined(_MSC_VER) && (!defined(__INTEL_COMPILER) || __INTEL_COMPILER >= 1000) && (defined(_M_X64) || defined(_M_IA64))) || (defined(__DECCXX) && defined(__alpha__)) || (defined(__INTEL_COMPILER) && defined(__x86_64__)) || (defined(__SUNPRO_CC) && defined(__x86_64__))\n-\ttypedef word32 hword;\n-\ttypedef word64 word;\n-#else\n-\t#define CRYPTOPP_NATIVE_DWORD_AVAILABLE\n-\t#if defined(__alpha__) || defined(__ia64__) || defined(_ARCH_PPC64) || defined(__x86_64__) || defined(__mips64) || defined(__sparc64__)\n-\t\t#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !(CRYPTOPP_GCC_VERSION == 40001 && defined(__APPLE__)) && CRYPTOPP_GCC_VERSION >= 30400\n-\t\t\t// GCC 4.0.1 on MacOS X is missing __umodti3 and __udivti3\n-\t\t\t// mode(TI) division broken on amd64 with GCC earlier than GCC 3.4\n-\t\t\ttypedef word32 hword;\n-\t\t\ttypedef word64 word;\n-\t\t\ttypedef __uint128_t dword;\n-\t\t\ttypedef __uint128_t word128;\n-\t\t\t#define CRYPTOPP_WORD128_AVAILABLE\n-\t\t#else\n-\t\t\t// if we're here, it means we're on a 64-bit CPU but we don't have a way to obtain 128-bit multiplication results\n-\t\t\ttypedef word16 hword;\n-\t\t\ttypedef word32 word;\n-\t\t\ttypedef word64 dword;\n-\t\t#endif\n-\t#else\n-\t\t// being here means the native register size is probably 32 bits or less\n-\t\t#define CRYPTOPP_BOOL_SLOW_WORD64 1\n-\t\ttypedef word16 hword;\n-\t\ttypedef word32 word;\n-\t\ttypedef word64 dword;\n-\t#endif\n-#endif\n-#ifndef CRYPTOPP_BOOL_SLOW_WORD64\n-\t#define CRYPTOPP_BOOL_SLOW_WORD64 0\n-#endif\n-\n-const unsigned int WORD_SIZE = sizeof(word);\n-const unsigned int WORD_BITS = WORD_SIZE * 8;\n-\n-NAMESPACE_END\n-\n-#ifndef CRYPTOPP_L1_CACHE_LINE_SIZE\n-\t// This should be a lower bound on the L1 cache line size. It's used for defense against timing attacks.\n-\t#if defined(_M_X64) || defined(__x86_64__)\n-\t\t#define CRYPTOPP_L1_CACHE_LINE_SIZE 64\n-\t#else\n-\t\t// L1 cache line size is 32 on Pentium III and earlier\n-\t\t#define CRYPTOPP_L1_CACHE_LINE_SIZE 32\n-\t#endif\n-#endif\n-\n-#if defined(_MSC_VER)\n-\t#if _MSC_VER == 1200\n-\t\t#include <malloc.h>\n-\t#endif\n-\t#if _MSC_VER > 1200 || defined(_mm_free)\n-\t\t#define CRYPTOPP_MSVC6PP_OR_LATER\t\t// VC 6 processor pack or later\n-\t#else\n-\t\t#define CRYPTOPP_MSVC6_NO_PP\t\t\t// VC 6 without processor pack\n-\t#endif\n-#endif\n-\n-#ifndef CRYPTOPP_ALIGN_DATA\n-\t#if defined(CRYPTOPP_MSVC6PP_OR_LATER)\n-\t\t#define CRYPTOPP_ALIGN_DATA(x) __declspec(align(x))\n-\t#elif defined(__GNUC__)\n-\t\t#define CRYPTOPP_ALIGN_DATA(x) __attribute__((aligned(x)))\n-\t#else\n-\t\t#define CRYPTOPP_ALIGN_DATA(x)\n-\t#endif\n-#endif\n-\n-#ifndef CRYPTOPP_SECTION_ALIGN16\n-\t#if defined(__GNUC__) && !defined(__APPLE__)\n-\t\t// the alignment attribute doesn't seem to work without this section attribute when -fdata-sections is turned on\n-\t\t#define CRYPTOPP_SECTION_ALIGN16 __attribute__((section (\"CryptoPP_Align16\")))\n-\t#else\n-\t\t#define CRYPTOPP_SECTION_ALIGN16\n-\t#endif\n-#endif\n-\n-#if defined(_MSC_VER) || defined(__fastcall)\n-\t#define CRYPTOPP_FASTCALL __fastcall\n-#else\n-\t#define CRYPTOPP_FASTCALL\n-#endif\n-\n-// VC60 workaround: it doesn't allow typename in some places\n-#if defined(_MSC_VER) && (_MSC_VER < 1300)\n-#define CPP_TYPENAME\n-#else\n-#define CPP_TYPENAME typename\n-#endif\n-\n-// VC60 workaround: can't cast unsigned __int64 to float or double\n-#if defined(_MSC_VER) && !defined(CRYPTOPP_MSVC6PP_OR_LATER)\n-#define CRYPTOPP_VC6_INT64 (__int64)\n-#else\n-#define CRYPTOPP_VC6_INT64\n-#endif\n-\n-#ifdef _MSC_VER\n-#define CRYPTOPP_NO_VTABLE __declspec(novtable)\n-#else\n-#define CRYPTOPP_NO_VTABLE\n-#endif\n-\n-#ifdef _MSC_VER\n-\t// 4231: nonstandard extension used : 'extern' before template explicit instantiation\n-\t// 4250: dominance\n-\t// 4251: member needs to have dll-interface\n-\t// 4275: base needs to have dll-interface\n-\t// 4660: explicitly instantiating a class that's already implicitly instantiated\n-\t// 4661: no suitable definition provided for explicit template instantiation request\n-\t// 4786: identifer was truncated in debug information\n-\t// 4355: 'this' : used in base member initializer list\n-\t// 4910: '__declspec(dllexport)' and 'extern' are incompatible on an explicit instantiation\n-#\tpragma warning(disable: 4231 4250 4251 4275 4660 4661 4786 4355 4910)\n-#endif\n-\n-#ifdef __BORLANDC__\n-// 8037: non-const function called for const object. needed to work around BCB2006 bug\n-#\tpragma warn -8037\n-#endif\n-\n-#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__MWERKS__) || defined(_STLPORT_VERSION)\n-#define CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION\n-#endif\n-\n-#ifndef CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION\n-#define CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE\n-#endif\n-\n-#ifdef CRYPTOPP_DISABLE_X86ASM\t\t// for backwards compatibility: this macro had both meanings\n-#define CRYPTOPP_DISABLE_ASM\n-#define CRYPTOPP_DISABLE_SSE2\n-#endif\n-\n-#if !defined(CRYPTOPP_DISABLE_ASM) && ((defined(_MSC_VER) && defined(_M_IX86)) || (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))))\n-\t#define CRYPTOPP_X86_ASM_AVAILABLE\n-\n-\t#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || CRYPTOPP_GCC_VERSION >= 30300)\n-\t\t#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1\n-\t#else\n-\t\t#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 0\n-\t#endif\n-\n-\t// SSSE3 was actually introduced in GNU as 2.17, which was released 6/23/2006, but we can't tell what version of binutils is installed.\n-\t// GCC 4.1.2 was released on 2/13/2007, so we'll use that as a proxy for the binutils version.\n-\t#if !defined(CRYPTOPP_DISABLE_SSSE3) && (_MSC_VER >= 1400 || CRYPTOPP_GCC_VERSION >= 40102)\n-\t\t#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 1\n-\t#else\n-\t\t#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 0\n-\t#endif\n-#endif\n-\n-#if !defined(CRYPTOPP_DISABLE_ASM) && defined(_MSC_VER) && defined(_M_X64)\n-\t#define CRYPTOPP_X64_MASM_AVAILABLE\n-#endif\n-\n-#if !defined(CRYPTOPP_DISABLE_ASM) && defined(__GNUC__) && defined(__x86_64__)\n-\t#define CRYPTOPP_X64_ASM_AVAILABLE\n-#endif\n-\n-#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || defined(__SSE2__))\n-\t#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 1\n-#else\n-\t#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 0\n-#endif\n-\n-#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n-\t#define CRYPTOPP_BOOL_ALIGN16_ENABLED 1\n-#else\n-\t#define CRYPTOPP_BOOL_ALIGN16_ENABLED 0\n-#endif\n-\n-// how to allocate 16-byte aligned memory (for SSE2)\n-#if defined(CRYPTOPP_MSVC6PP_OR_LATER)\n-\t#define CRYPTOPP_MM_MALLOC_AVAILABLE\n-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)\n-\t#define CRYPTOPP_MALLOC_ALIGNMENT_IS_16\n-#elif defined(__linux__) || defined(__sun__) || defined(__CYGWIN__)\n-\t#define CRYPTOPP_MEMALIGN_AVAILABLE\n-#else\n-\t#define CRYPTOPP_NO_ALIGNED_ALLOC\n-#endif\n-\n-// how to disable inlining\n-#if defined(_MSC_VER) && _MSC_VER >= 1300\n-#\tdefine CRYPTOPP_NOINLINE_DOTDOTDOT\n-#\tdefine CRYPTOPP_NOINLINE __declspec(noinline)\n-#elif defined(__GNUC__)\n-#\tdefine CRYPTOPP_NOINLINE_DOTDOTDOT\n-#\tdefine CRYPTOPP_NOINLINE __attribute__((noinline))\n-#else\n-#\tdefine CRYPTOPP_NOINLINE_DOTDOTDOT ...\n-#\tdefine CRYPTOPP_NOINLINE \n-#endif\n-\n-// how to declare class constants\n-#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__INTEL_COMPILER)\n-#\tdefine CRYPTOPP_CONSTANT(x) enum {x};\n-#else\n-#\tdefine CRYPTOPP_CONSTANT(x) static const int x;\n-#endif\n-\n-#if defined(_M_X64) || defined(__x86_64__)\n-\t#define CRYPTOPP_BOOL_X64 1\n-#else\n-\t#define CRYPTOPP_BOOL_X64 0\n-#endif\n-\n-// see http://predef.sourceforge.net/prearch.html\n-#if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(_X86_) || defined(__I86__) || defined(__INTEL__)\n-\t#define CRYPTOPP_BOOL_X86 1\n-#else\n-\t#define CRYPTOPP_BOOL_X86 0\n-#endif\n-\n-#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86 || defined(__powerpc__)\n-\t#define CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-#endif\n-\n-#define CRYPTOPP_VERSION 560\n-\n-// ***************** determine availability of OS features ********************\n-\n-#ifndef NO_OS_DEPENDENCE\n-\n-#if defined(_WIN32) || defined(__CYGWIN__)\n-#define CRYPTOPP_WIN32_AVAILABLE\n-#endif\n-\n-#if defined(__unix__) || defined(__MACH__) || defined(__NetBSD__) || defined(__sun)\n-#define CRYPTOPP_UNIX_AVAILABLE\n-#endif\n-\n-#if defined(CRYPTOPP_WIN32_AVAILABLE) || defined(CRYPTOPP_UNIX_AVAILABLE)\n-#\tdefine HIGHRES_TIMER_AVAILABLE\n-#endif\n-\n-#ifdef CRYPTOPP_UNIX_AVAILABLE\n-#\tdefine HAS_BERKELEY_STYLE_SOCKETS\n-#endif\n-\n-#ifdef CRYPTOPP_WIN32_AVAILABLE\n-#\tdefine HAS_WINDOWS_STYLE_SOCKETS\n-#endif\n-\n-#if defined(HIGHRES_TIMER_AVAILABLE) && (defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(HAS_WINDOWS_STYLE_SOCKETS))\n-#\tdefine SOCKETS_AVAILABLE\n-#endif\n-\n-#if defined(HAS_WINDOWS_STYLE_SOCKETS) && (!defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(PREFER_WINDOWS_STYLE_SOCKETS))\n-#\tdefine USE_WINDOWS_STYLE_SOCKETS\n-#else\n-#\tdefine USE_BERKELEY_STYLE_SOCKETS\n-#endif\n-\n-#if defined(HIGHRES_TIMER_AVAILABLE) && defined(CRYPTOPP_WIN32_AVAILABLE) && !defined(USE_BERKELEY_STYLE_SOCKETS)\n-#\tdefine WINDOWS_PIPES_AVAILABLE\n-#endif\n-\n-#if defined(CRYPTOPP_WIN32_AVAILABLE) && defined(USE_MS_CRYPTOAPI)\n-#\tdefine NONBLOCKING_RNG_AVAILABLE\n-#\tdefine OS_RNG_AVAILABLE\n-#endif\n-\n-#if defined(CRYPTOPP_UNIX_AVAILABLE) || defined(CRYPTOPP_DOXYGEN_PROCESSING)\n-#\tdefine NONBLOCKING_RNG_AVAILABLE\n-#\tdefine BLOCKING_RNG_AVAILABLE\n-#\tdefine OS_RNG_AVAILABLE\n-#\tdefine HAS_PTHREADS\n-#\tdefine THREADS_AVAILABLE\n-#endif\n-\n-#ifdef CRYPTOPP_WIN32_AVAILABLE\n-#\tdefine HAS_WINTHREADS\n-#\tdefine THREADS_AVAILABLE\n-#endif\n-\n-#endif\t// NO_OS_DEPENDENCE\n-\n-// ***************** DLL related ********************\n-\n-#ifdef CRYPTOPP_WIN32_AVAILABLE\n-\n-#ifdef CRYPTOPP_EXPORTS\n-#define CRYPTOPP_IS_DLL\n-#define CRYPTOPP_DLL __declspec(dllexport)\n-#elif defined(CRYPTOPP_IMPORTS)\n-#define CRYPTOPP_IS_DLL\n-#define CRYPTOPP_DLL __declspec(dllimport)\n-#else\n-#define CRYPTOPP_DLL\n-#endif\n-\n-#define CRYPTOPP_API __cdecl\n-\n-#else\t// CRYPTOPP_WIN32_AVAILABLE\n-\n-#define CRYPTOPP_DLL\n-#define CRYPTOPP_API\n-\n-#endif\t// CRYPTOPP_WIN32_AVAILABLE\n-\n-#if defined(__MWERKS__)\n-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern class CRYPTOPP_DLL\n-#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)\n-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL\n-#else\n-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern template class CRYPTOPP_DLL\n-#endif\n-\n-#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_IMPORTS)\n-#define CRYPTOPP_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL\n-#else\n-#define CRYPTOPP_DLL_TEMPLATE_CLASS CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS\n-#endif\n-\n-#if defined(__MWERKS__)\n-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern class\n-#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)\n-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS template class\n-#else\n-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern template class\n-#endif\n-\n-#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_EXPORTS)\n-#define CRYPTOPP_STATIC_TEMPLATE_CLASS template class\n-#else\n-#define CRYPTOPP_STATIC_TEMPLATE_CLASS CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS\n-#endif\n-\n-#endif"
      },
      {
        "sha": "8789dc3176c73febbf63404df5227b3f3521ae5a",
        "filename": "src/cryptopp/cpu.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 199,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cpu.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cpu.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/cpu.cpp?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,199 +0,0 @@\n-// cpu.cpp - written and placed in the public domain by Wei Dai\n-\n-#include \"pch.h\"\n-\n-#ifndef CRYPTOPP_IMPORTS\n-\n-#include \"cpu.h\"\n-#include \"misc.h\"\n-#include <algorithm>\n-\n-#ifdef __GNUC__\n-#include <signal.h>\n-#include <setjmp.h>\n-#endif\n-\n-#ifdef CRYPTOPP_MSVC6PP_OR_LATER\n-#include <emmintrin.h>\n-#endif\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-#ifdef CRYPTOPP_X86_ASM_AVAILABLE\n-\n-#ifndef _MSC_VER\n-typedef void (*SigHandler)(int);\n-\n-static jmp_buf s_jmpNoCPUID;\n-static void SigIllHandlerCPUID(int)\n-{\n-\tlongjmp(s_jmpNoCPUID, 1);\n-}\n-#endif\n-\n-bool CpuId(word32 input, word32 *output)\n-{\n-#ifdef _MSC_VER\n-    __try\n-\t{\n-\t\t__asm\n-\t\t{\n-\t\t\tmov eax, input\n-\t\t\tcpuid\n-\t\t\tmov edi, output\n-\t\t\tmov [edi], eax\n-\t\t\tmov [edi+4], ebx\n-\t\t\tmov [edi+8], ecx\n-\t\t\tmov [edi+12], edx\n-\t\t}\n-\t}\n-    __except (1)\n-\t{\n-\t\treturn false;\n-    }\n-\treturn true;\n-#else\n-\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);\n-\tif (oldHandler == SIG_ERR)\n-\t\treturn false;\n-\n-\tbool result = true;\n-\tif (setjmp(s_jmpNoCPUID))\n-\t\tresult = false;\n-\telse\n-\t{\n-\t\t__asm__\n-\t\t(\n-\t\t\t// save ebx in case -fPIC is being used\n-#if CRYPTOPP_BOOL_X86\n-\t\t\t\"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx\"\n-#else\n-\t\t\t\"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx\"\n-#endif\n-\t\t\t: \"=a\" (output[0]), \"=D\" (output[1]), \"=c\" (output[2]), \"=d\" (output[3])\n-\t\t\t: \"a\" (input)\n-\t\t);\n-\t}\n-\n-\tsignal(SIGILL, oldHandler);\n-\treturn result;\n-#endif\n-}\n-\n-#if !CRYPTOPP_BOOL_X64 && !defined(_MSC_VER) && defined(__GNUC__)\n-static jmp_buf s_jmpNoSSE2;\n-static void SigIllHandlerSSE2(int)\n-{\n-\tlongjmp(s_jmpNoSSE2, 1);\n-}\n-#endif\n-\n-#elif _MSC_VER >= 1400 && CRYPTOPP_BOOL_X64\n-\n-bool CpuId(word32 input, word32 *output)\n-{\n-\t__cpuid((int *)output, input);\n-\treturn true;\n-}\n-\n-#endif\n-\n-#ifdef CRYPTOPP_CPUID_AVAILABLE\n-\n-static bool TrySSE2()\n-{\n-#if CRYPTOPP_BOOL_X64\n-\treturn true;\n-#elif defined(_MSC_VER)\n-    __try\n-\t{\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-        AS2(por xmm0, xmm0)        // executing SSE2 instruction\n-#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n-\t\t__mm128i x = _mm_setzero_si128();\n-\t\treturn _mm_cvtsi128_si32(x) == 0;\n-#endif\n-\t}\n-    __except (1)\n-\t{\n-\t\treturn false;\n-    }\n-\treturn true;\n-#elif defined(__GNUC__)\n-\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);\n-\tif (oldHandler == SIG_ERR)\n-\t\treturn false;\n-\n-\tbool result = true;\n-\tif (setjmp(s_jmpNoSSE2))\n-\t\tresult = false;\n-\telse\n-\t{\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\t\t__asm __volatile (\"por %xmm0, %xmm0\");\n-#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n-\t\t__mm128i x = _mm_setzero_si128();\n-\t\tresult = _mm_cvtsi128_si32(x) == 0;\n-#endif\n-\t}\n-\n-\tsignal(SIGILL, oldHandler);\n-\treturn result;\n-#else\n-\treturn false;\n-#endif\n-}\n-\n-bool g_x86DetectionDone = false;\n-bool g_hasISSE = false, g_hasSSE2 = false, g_hasSSSE3 = false, g_hasMMX = false, g_isP4 = false;\n-word32 g_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;\n-\n-void DetectX86Features()\n-{\n-\tword32 cpuid[4], cpuid1[4];\n-\tif (!CpuId(0, cpuid))\n-\t\treturn;\n-\tif (!CpuId(1, cpuid1))\n-\t\treturn;\n-\n-\tg_hasMMX = (cpuid1[3] & (1 << 23)) != 0;\n-\tif ((cpuid1[3] & (1 << 26)) != 0)\n-\t\tg_hasSSE2 = TrySSE2();\n-\tg_hasSSSE3 = g_hasSSE2 && (cpuid1[2] & (1<<9));\n-\n-\tif ((cpuid1[3] & (1 << 25)) != 0)\n-\t\tg_hasISSE = true;\n-\telse\n-\t{\n-\t\tword32 cpuid2[4];\n-\t\tCpuId(0x080000000, cpuid2);\n-\t\tif (cpuid2[0] >= 0x080000001)\n-\t\t{\n-\t\t\tCpuId(0x080000001, cpuid2);\n-\t\t\tg_hasISSE = (cpuid2[3] & (1 << 22)) != 0;\n-\t\t}\n-\t}\n-\n-\tstd::swap(cpuid[2], cpuid[3]);\n-\tif (memcmp(cpuid+1, \"GenuineIntel\", 12) == 0)\n-\t{\n-\t\tg_isP4 = ((cpuid1[0] >> 8) & 0xf) == 0xf;\n-\t\tg_cacheLineSize = 8 * GETBYTE(cpuid1[1], 1);\n-\t}\n-\telse if (memcmp(cpuid+1, \"AuthenticAMD\", 12) == 0)\n-\t{\n-\t\tCpuId(0x80000005, cpuid);\n-\t\tg_cacheLineSize = GETBYTE(cpuid[2], 0);\n-\t}\n-\n-\tif (!g_cacheLineSize)\n-\t\tg_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;\n-\n-\tg_x86DetectionDone = true;\n-}\n-\n-#endif\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "7f01dad852616aa0b3576f64c59a6a5dff5c8719",
        "filename": "src/cryptopp/cpu.h",
        "status": "removed",
        "additions": 0,
        "deletions": 263,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cpu.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cpu.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/cpu.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,263 +0,0 @@\n-#ifndef CRYPTOPP_CPU_H\n-#define CRYPTOPP_CPU_H\n-\n-#ifdef CRYPTOPP_GENERATE_X64_MASM\n-\n-#define CRYPTOPP_X86_ASM_AVAILABLE\n-#define CRYPTOPP_BOOL_X64 1\n-#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1\n-#define NAMESPACE_END\n-\n-#else\n-\n-#include \"config.h\"\n-\n-#ifdef CRYPTOPP_MSVC6PP_OR_LATER\n-\t#include <emmintrin.h>\n-#endif\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || (_MSC_VER >= 1400 && CRYPTOPP_BOOL_X64)\n-\n-#define CRYPTOPP_CPUID_AVAILABLE\n-\n-// these should not be used directly\n-extern CRYPTOPP_DLL bool g_x86DetectionDone;\n-extern CRYPTOPP_DLL bool g_hasSSE2;\n-extern CRYPTOPP_DLL bool g_hasISSE;\n-extern CRYPTOPP_DLL bool g_hasMMX;\n-extern CRYPTOPP_DLL bool g_hasSSSE3;\n-extern CRYPTOPP_DLL bool g_isP4;\n-extern CRYPTOPP_DLL word32 g_cacheLineSize;\n-CRYPTOPP_DLL void CRYPTOPP_API DetectX86Features();\n-\n-CRYPTOPP_DLL bool CRYPTOPP_API CpuId(word32 input, word32 *output);\n-\n-#if CRYPTOPP_BOOL_X64\n-inline bool HasSSE2()\t{return true;}\n-inline bool HasISSE()\t{return true;}\n-inline bool HasMMX()\t{return true;}\n-#else\n-\n-inline bool HasSSE2()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_hasSSE2;\n-}\n-\n-inline bool HasISSE()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_hasISSE;\n-}\n-\n-inline bool HasMMX()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_hasMMX;\n-}\n-\n-#endif\n-\n-inline bool HasSSSE3()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_hasSSSE3;\n-}\n-\n-inline bool IsP4()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_isP4;\n-}\n-\n-inline int GetCacheLineSize()\n-{\n-\tif (!g_x86DetectionDone)\n-\t\tDetectX86Features();\n-\treturn g_cacheLineSize;\n-}\n-\n-#else\n-\n-inline int GetCacheLineSize()\n-{\n-\treturn CRYPTOPP_L1_CACHE_LINE_SIZE;\n-}\n-\n-inline bool HasSSSE3()\t{return false;}\n-inline bool IsP4()\t\t{return false;}\n-\n-// assume MMX and SSE2 if intrinsics are enabled\n-#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_X64\n-inline bool HasSSE2()\t{return true;}\n-inline bool HasISSE()\t{return true;}\n-inline bool HasMMX()\t{return true;}\n-#else\n-inline bool HasSSE2()\t{return false;}\n-inline bool HasISSE()\t{return false;}\n-inline bool HasMMX()\t{return false;}\n-#endif\n-\n-#endif\t\t// #ifdef CRYPTOPP_X86_ASM_AVAILABLE || _MSC_VER >= 1400\n-\n-#endif\n-\n-#ifdef CRYPTOPP_GENERATE_X64_MASM\n-\t#define AS1(x) x*newline*\n-\t#define AS2(x, y) x, y*newline*\n-\t#define AS3(x, y, z) x, y, z*newline*\n-\t#define ASS(x, y, a, b, c, d) x, y, a*64+b*16+c*4+d*newline*\n-\t#define ASL(x) label##x:*newline*\n-\t#define ASJ(x, y, z) x label##y*newline*\n-\t#define ASC(x, y) x label##y*newline*\n-\t#define AS_HEX(y) 0##y##h\n-#elif defined(__GNUC__)\n-\t// define these in two steps to allow arguments to be expanded\n-\t#define GNU_AS1(x) #x \";\"\n-\t#define GNU_AS2(x, y) #x \", \" #y \";\"\n-\t#define GNU_AS3(x, y, z) #x \", \" #y \", \" #z \";\"\n-\t#define GNU_ASL(x) \"\\n\" #x \":\"\n-\t#define GNU_ASJ(x, y, z) #x \" \" #y #z \";\"\n-\t#define AS1(x) GNU_AS1(x)\n-\t#define AS2(x, y) GNU_AS2(x, y)\n-\t#define AS3(x, y, z) GNU_AS3(x, y, z)\n-\t#define ASS(x, y, a, b, c, d) #x \", \" #y \", \" #a \"*64+\" #b \"*16+\" #c \"*4+\" #d \";\"\n-\t#define ASL(x) GNU_ASL(x)\n-\t#define ASJ(x, y, z) GNU_ASJ(x, y, z)\n-\t#define ASC(x, y) #x \" \" #y \";\"\n-\t#define CRYPTOPP_NAKED\n-\t#define AS_HEX(y) 0x##y\n-#else\n-\t#define AS1(x) __asm {x}\n-\t#define AS2(x, y) __asm {x, y}\n-\t#define AS3(x, y, z) __asm {x, y, z}\n-\t#define ASS(x, y, a, b, c, d) __asm {x, y, _MM_SHUFFLE(a, b, c, d)}\n-\t#define ASL(x) __asm {label##x:}\n-\t#define ASJ(x, y, z) __asm {x label##y}\n-\t#define ASC(x, y) __asm {x label##y}\n-\t#define CRYPTOPP_NAKED __declspec(naked)\n-\t#define AS_HEX(y) 0x##y\n-#endif\n-\n-#define IF0(y)\n-#define IF1(y) y\n-\n-#ifdef CRYPTOPP_GENERATE_X64_MASM\n-#define ASM_MOD(x, y) ((x) MOD (y))\n-#define XMMWORD_PTR XMMWORD PTR\n-#else\n-// GNU assembler doesn't seem to have mod operator\n-#define ASM_MOD(x, y) ((x)-((x)/(y))*(y))\n-// GAS 2.15 doesn't support XMMWORD PTR. it seems necessary only for MASM\n-#define XMMWORD_PTR\n-#endif\n-\n-#if CRYPTOPP_BOOL_X86\n-\t#define AS_REG_1 ecx\n-\t#define AS_REG_2 edx\n-\t#define AS_REG_3 esi\n-\t#define AS_REG_4 edi\n-\t#define AS_REG_5 eax\n-\t#define AS_REG_6 ebx\n-\t#define AS_REG_7 ebp\n-\t#define AS_REG_1d ecx\n-\t#define AS_REG_2d edx\n-\t#define AS_REG_3d esi\n-\t#define AS_REG_4d edi\n-\t#define AS_REG_5d eax\n-\t#define AS_REG_6d ebx\n-\t#define AS_REG_7d ebp\n-\t#define WORD_SZ 4\n-\t#define WORD_REG(x)\te##x\n-\t#define WORD_PTR DWORD PTR\n-\t#define AS_PUSH_IF86(x) AS1(push e##x)\n-\t#define AS_POP_IF86(x) AS1(pop e##x)\n-\t#define AS_JCXZ jecxz\n-#elif CRYPTOPP_BOOL_X64\n-\t#ifdef CRYPTOPP_GENERATE_X64_MASM\n-\t\t#define AS_REG_1 rcx\n-\t\t#define AS_REG_2 rdx\n-\t\t#define AS_REG_3 r8\n-\t\t#define AS_REG_4 r9\n-\t\t#define AS_REG_5 rax\n-\t\t#define AS_REG_6 r10\n-\t\t#define AS_REG_7 r11\n-\t\t#define AS_REG_1d ecx\n-\t\t#define AS_REG_2d edx\n-\t\t#define AS_REG_3d r8d\n-\t\t#define AS_REG_4d r9d\n-\t\t#define AS_REG_5d eax\n-\t\t#define AS_REG_6d r10d\n-\t\t#define AS_REG_7d r11d\n-\t#else\n-\t\t#define AS_REG_1 rdi\n-\t\t#define AS_REG_2 rsi\n-\t\t#define AS_REG_3 rdx\n-\t\t#define AS_REG_4 rcx\n-\t\t#define AS_REG_5 r8\n-\t\t#define AS_REG_6 r9\n-\t\t#define AS_REG_7 r10\n-\t\t#define AS_REG_1d edi\n-\t\t#define AS_REG_2d esi\n-\t\t#define AS_REG_3d edx\n-\t\t#define AS_REG_4d ecx\n-\t\t#define AS_REG_5d r8d\n-\t\t#define AS_REG_6d r9d\n-\t\t#define AS_REG_7d r10d\n-\t#endif\n-\t#define WORD_SZ 8\n-\t#define WORD_REG(x)\tr##x\n-\t#define WORD_PTR QWORD PTR\n-\t#define AS_PUSH_IF86(x)\n-\t#define AS_POP_IF86(x)\n-\t#define AS_JCXZ jrcxz\n-#endif\n-\n-// helper macro for stream cipher output\n-#define AS_XMM_OUTPUT4(labelPrefix, inputPtr, outputPtr, x0, x1, x2, x3, t, p0, p1, p2, p3, increment)\\\n-\tAS2(\ttest\tinputPtr, inputPtr)\\\n-\tASC(\tjz,\t\tlabelPrefix##3)\\\n-\tAS2(\ttest\tinputPtr, 15)\\\n-\tASC(\tjnz,\tlabelPrefix##7)\\\n-\tAS2(\tpxor\txmm##x0, [inputPtr+p0*16])\\\n-\tAS2(\tpxor\txmm##x1, [inputPtr+p1*16])\\\n-\tAS2(\tpxor\txmm##x2, [inputPtr+p2*16])\\\n-\tAS2(\tpxor\txmm##x3, [inputPtr+p3*16])\\\n-\tAS2(\tadd\t\tinputPtr, increment*16)\\\n-\tASC(\tjmp,\tlabelPrefix##3)\\\n-\tASL(labelPrefix##7)\\\n-\tAS2(\tmovdqu\txmm##t, [inputPtr+p0*16])\\\n-\tAS2(\tpxor\txmm##x0, xmm##t)\\\n-\tAS2(\tmovdqu\txmm##t, [inputPtr+p1*16])\\\n-\tAS2(\tpxor\txmm##x1, xmm##t)\\\n-\tAS2(\tmovdqu\txmm##t, [inputPtr+p2*16])\\\n-\tAS2(\tpxor\txmm##x2, xmm##t)\\\n-\tAS2(\tmovdqu\txmm##t, [inputPtr+p3*16])\\\n-\tAS2(\tpxor\txmm##x3, xmm##t)\\\n-\tAS2(\tadd\t\tinputPtr, increment*16)\\\n-\tASL(labelPrefix##3)\\\n-\tAS2(\ttest\toutputPtr, 15)\\\n-\tASC(\tjnz,\tlabelPrefix##8)\\\n-\tAS2(\tmovdqa\t[outputPtr+p0*16], xmm##x0)\\\n-\tAS2(\tmovdqa\t[outputPtr+p1*16], xmm##x1)\\\n-\tAS2(\tmovdqa\t[outputPtr+p2*16], xmm##x2)\\\n-\tAS2(\tmovdqa\t[outputPtr+p3*16], xmm##x3)\\\n-\tASC(\tjmp,\tlabelPrefix##9)\\\n-\tASL(labelPrefix##8)\\\n-\tAS2(\tmovdqu\t[outputPtr+p0*16], xmm##x0)\\\n-\tAS2(\tmovdqu\t[outputPtr+p1*16], xmm##x1)\\\n-\tAS2(\tmovdqu\t[outputPtr+p2*16], xmm##x2)\\\n-\tAS2(\tmovdqu\t[outputPtr+p3*16], xmm##x3)\\\n-\tASL(labelPrefix##9)\\\n-\tAS2(\tadd\t\toutputPtr, increment*16)\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "15cd6dad67e0eecd1201ea186b0c3c5a0dc78856",
        "filename": "src/cryptopp/cryptlib.h",
        "status": "removed",
        "additions": 0,
        "deletions": 1668,
        "changes": 1668,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cryptlib.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/cryptlib.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/cryptlib.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,1668 +0,0 @@\n-// cryptlib.h - written and placed in the public domain by Wei Dai\n-/*! \\file\n- \tThis file contains the declarations for the abstract base\n-\tclasses that provide a uniform interface to this library.\n-*/\n-\n-/*!\t\\mainpage Crypto++ Library 5.6.0 API Reference\n-<dl>\n-<dt>Abstract Base Classes<dd>\n-\tcryptlib.h\n-<dt>Authenticated Encryption<dd>\n-\tAuthenticatedSymmetricCipherDocumentation\n-<dt>Symmetric Ciphers<dd>\n-\tSymmetricCipherDocumentation\n-<dt>Hash Functions<dd>\n-\tSHA1, SHA224, SHA256, SHA384, SHA512, Tiger, Whirlpool, RIPEMD160, RIPEMD320, RIPEMD128, RIPEMD256, Weak1::MD2, Weak1::MD4, Weak1::MD5\n-<dt>Non-Cryptographic Checksums<dd>\n-\tCRC32, Adler32\n-<dt>Message Authentication Codes<dd>\n-\tVMAC, HMAC, CBC_MAC, CMAC, DMAC, TTMAC, GCM (GMAC)\n-<dt>Random Number Generators<dd>\n-\tNullRNG(), LC_RNG, RandomPool, BlockingRng, NonblockingRng, AutoSeededRandomPool, AutoSeededX917RNG, DefaultAutoSeededRNG\n-<dt>Password-based Cryptography<dd>\n-\tPasswordBasedKeyDerivationFunction\n-<dt>Public Key Cryptosystems<dd>\n-\tDLIES, ECIES, LUCES, RSAES, RabinES, LUC_IES\n-<dt>Public Key Signature Schemes<dd>\n-\tDSA, GDSA, ECDSA, NR, ECNR, LUCSS, RSASS, RSASS_ISO, RabinSS, RWSS, ESIGN\n-<dt>Key Agreement<dd>\n-\t#DH, DH2, #MQV, ECDH, ECMQV, XTR_DH\n-<dt>Algebraic Structures<dd>\n-\tInteger, PolynomialMod2, PolynomialOver, RingOfPolynomialsOver,\n-\tModularArithmetic, MontgomeryRepresentation, GFP2_ONB,\n-\tGF2NP, GF256, GF2_32, EC2N, ECP\n-<dt>Secret Sharing and Information Dispersal<dd>\n-\tSecretSharing, SecretRecovery, InformationDispersal, InformationRecovery\n-<dt>Compression<dd>\n-\tDeflator, Inflator, Gzip, Gunzip, ZlibCompressor, ZlibDecompressor\n-<dt>Input Source Classes<dd>\n-\tStringSource, ArraySource, FileSource, SocketSource, WindowsPipeSource, RandomNumberSource\n-<dt>Output Sink Classes<dd>\n-\tStringSinkTemplate, ArraySink, FileSink, SocketSink, WindowsPipeSink, RandomNumberSink\n-<dt>Filter Wrappers<dd>\n-\tStreamTransformationFilter, HashFilter, HashVerificationFilter, SignerFilter, SignatureVerificationFilter\n-<dt>Binary to Text Encoders and Decoders<dd>\n-\tHexEncoder, HexDecoder, Base64Encoder, Base64Decoder, Base32Encoder, Base32Decoder\n-<dt>Wrappers for OS features<dd>\n-\tTimer, Socket, WindowsHandle, ThreadLocalStorage, ThreadUserTimer\n-<dt>FIPS 140 related<dd>\n-\tfips140.h\n-</dl>\n-\n-In the FIPS 140-2 validated DLL version of Crypto++, only the following implementation class are available.\n-<dl>\n-<dt>Block Ciphers<dd>\n-\tAES, DES_EDE2, DES_EDE3, SKIPJACK\n-<dt>Cipher Modes (replace template parameter BC with one of the block ciphers above)<dd>\n-\tECB_Mode\\<BC\\>, CTR_Mode\\<BC\\>, CBC_Mode\\<BC\\>, CFB_FIPS_Mode\\<BC\\>, OFB_Mode\\<BC\\>\n-<dt>Hash Functions<dd>\n-\tSHA1, SHA224, SHA256, SHA384, SHA512\n-<dt>Public Key Signature Schemes (replace template parameter H with one of the hash functions above)<dd>\n-\tRSASS\\<PKCS1v15, H\\>, RSASS\\<PSS, H\\>, RSASS_ISO\\<H\\>, RWSS\\<P1363_EMSA2, H\\>, DSA, ECDSA\\<ECP, H\\>, ECDSA\\<EC2N, H\\>\n-<dt>Message Authentication Codes (replace template parameter H with one of the hash functions above)<dd>\n-\tHMAC\\<H\\>, CBC_MAC\\<DES_EDE2\\>, CBC_MAC\\<DES_EDE3\\>\n-<dt>Random Number Generators<dd>\n-\tDefaultAutoSeededRNG (AutoSeededX917RNG\\<AES\\>)\n-<dt>Key Agreement<dd>\n-\t#DH\n-<dt>Public Key Cryptosystems<dd>\n-\tRSAES\\<OAEP\\<SHA1\\> \\>\n-</dl>\n-\n-<p>This reference manual is a work in progress. Some classes are still lacking detailed descriptions.\n-<p>Click <a href=\"CryptoPPRef.zip\">here</a> to download a zip archive containing this manual.\n-<p>Thanks to Ryan Phillips for providing the Doxygen configuration file\n-and getting me started with this manual.\n-*/\n-\n-#ifndef CRYPTOPP_CRYPTLIB_H\n-#define CRYPTOPP_CRYPTLIB_H\n-\n-#include \"config.h\"\n-#include \"stdcpp.h\"\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-// forward declarations\n-class Integer;\n-class RandomNumberGenerator;\n-class BufferedTransformation;\n-\n-//! used to specify a direction for a cipher to operate in (encrypt or decrypt)\n-enum CipherDir {ENCRYPTION, DECRYPTION};\n-\n-//! used to represent infinite time\n-const unsigned long INFINITE_TIME = ULONG_MAX;\n-\n-// VC60 workaround: using enums as template parameters causes problems\n-template <typename ENUM_TYPE, int VALUE>\n-struct EnumToType\n-{\n-\tstatic ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}\n-};\n-\n-enum ByteOrder {LITTLE_ENDIAN_ORDER = 0, BIG_ENDIAN_ORDER = 1};\n-typedef EnumToType<ByteOrder, LITTLE_ENDIAN_ORDER> LittleEndian;\n-typedef EnumToType<ByteOrder, BIG_ENDIAN_ORDER> BigEndian;\n-\n-//! base class for all exceptions thrown by Crypto++\n-class CRYPTOPP_DLL Exception : public std::exception\n-{\n-public:\n-\t//! error types\n-\tenum ErrorType {\n-\t\t//! a method is not implemented\n-\t\tNOT_IMPLEMENTED,\n-\t\t//! invalid function argument\n-\t\tINVALID_ARGUMENT,\n-\t\t//! BufferedTransformation received a Flush(true) signal but can't flush buffers\n-\t\tCANNOT_FLUSH,\n-\t\t//! data integerity check (such as CRC or MAC) failed\n-\t\tDATA_INTEGRITY_CHECK_FAILED,\n-\t\t//! received input data that doesn't conform to expected format\n-\t\tINVALID_DATA_FORMAT,\n-\t\t//! error reading from input device or writing to output device\n-\t\tIO_ERROR,\n-\t\t//! some error not belong to any of the above categories\n-\t\tOTHER_ERROR\n-\t};\n-\n-\texplicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}\n-\tvirtual ~Exception() throw() {}\n-\tconst char *what() const throw() {return (m_what.c_str());}\n-\tconst std::string &GetWhat() const {return m_what;}\n-\tvoid SetWhat(const std::string &s) {m_what = s;}\n-\tErrorType GetErrorType() const {return m_errorType;}\n-\tvoid SetErrorType(ErrorType errorType) {m_errorType = errorType;}\n-\n-private:\n-\tErrorType m_errorType;\n-\tstd::string m_what;\n-};\n-\n-//! exception thrown when an invalid argument is detected\n-class CRYPTOPP_DLL InvalidArgument : public Exception\n-{\n-public:\n-\texplicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}\n-};\n-\n-//! exception thrown when input data is received that doesn't conform to expected format\n-class CRYPTOPP_DLL InvalidDataFormat : public Exception\n-{\n-public:\n-\texplicit InvalidDataFormat(const std::string &s) : Exception(INVALID_DATA_FORMAT, s) {}\n-};\n-\n-//! exception thrown by decryption filters when trying to decrypt an invalid ciphertext\n-class CRYPTOPP_DLL InvalidCiphertext : public InvalidDataFormat\n-{\n-public:\n-\texplicit InvalidCiphertext(const std::string &s) : InvalidDataFormat(s) {}\n-};\n-\n-//! exception thrown by a class if a non-implemented method is called\n-class CRYPTOPP_DLL NotImplemented : public Exception\n-{\n-public:\n-\texplicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}\n-};\n-\n-//! exception thrown by a class when Flush(true) is called but it can't completely flush its buffers\n-class CRYPTOPP_DLL CannotFlush : public Exception\n-{\n-public:\n-\texplicit CannotFlush(const std::string &s) : Exception(CANNOT_FLUSH, s) {}\n-};\n-\n-//! error reported by the operating system\n-class CRYPTOPP_DLL OS_Error : public Exception\n-{\n-public:\n-\tOS_Error(ErrorType errorType, const std::string &s, const std::string& operation, int errorCode)\n-\t\t: Exception(errorType, s), m_operation(operation), m_errorCode(errorCode) {}\n-\t~OS_Error() throw() {}\n-\n-\t// the operating system API that reported the error\n-\tconst std::string & GetOperation() const {return m_operation;}\n-\t// the error code return by the operating system\n-\tint GetErrorCode() const {return m_errorCode;}\n-\n-protected:\n-\tstd::string m_operation;\n-\tint m_errorCode;\n-};\n-\n-//! used to return decoding results\n-struct CRYPTOPP_DLL DecodingResult\n-{\n-\texplicit DecodingResult() : isValidCoding(false), messageLength(0) {}\n-\texplicit DecodingResult(size_t len) : isValidCoding(true), messageLength(len) {}\n-\n-\tbool operator==(const DecodingResult &rhs) const {return isValidCoding == rhs.isValidCoding && messageLength == rhs.messageLength;}\n-\tbool operator!=(const DecodingResult &rhs) const {return !operator==(rhs);}\n-\n-\tbool isValidCoding;\n-\tsize_t messageLength;\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\toperator size_t() const {return isValidCoding ? messageLength : 0;}\n-#endif\n-};\n-\n-//! interface for retrieving values given their names\n-/*! \\note This class is used to safely pass a variable number of arbitrarily typed arguments to functions\n-\tand to read values from keys and crypto parameters.\n-\t\\note To obtain an object that implements NameValuePairs for the purpose of parameter\n-\tpassing, use the MakeParameters() function.\n-\t\\note To get a value from NameValuePairs, you need to know the name and the type of the value. \n-\tCall GetValueNames() on a NameValuePairs object to obtain a list of value names that it supports.\n-\tThen look at the Name namespace documentation to see what the type of each value is, or\n-\talternatively, call GetIntValue() with the value name, and if the type is not int, a\n-\tValueTypeMismatch exception will be thrown and you can get the actual type from the exception object.\n-*/\n-class CRYPTOPP_NO_VTABLE NameValuePairs\n-{\n-public:\n-\tvirtual ~NameValuePairs() {}\n-\n-\t//! exception thrown when trying to retrieve a value using a different type than expected\n-\tclass CRYPTOPP_DLL ValueTypeMismatch : public InvalidArgument\n-\t{\n-\tpublic:\n-\t\tValueTypeMismatch(const std::string &name, const std::type_info &stored, const std::type_info &retrieving)\n-\t\t\t: InvalidArgument(\"NameValuePairs: type mismatch for '\" + name + \"', stored '\" + stored.name() + \"', trying to retrieve '\" + retrieving.name() + \"'\")\n-\t\t\t, m_stored(stored), m_retrieving(retrieving) {}\n-\n-\t\tconst std::type_info & GetStoredTypeInfo() const {return m_stored;}\n-\t\tconst std::type_info & GetRetrievingTypeInfo() const {return m_retrieving;}\n-\n-\tprivate:\n-\t\tconst std::type_info &m_stored;\n-\t\tconst std::type_info &m_retrieving;\n-\t};\n-\n-\t//! get a copy of this object or a subobject of it\n-\ttemplate <class T>\n-\tbool GetThisObject(T &object) const\n-\t{\n-\t\treturn GetValue((std::string(\"ThisObject:\")+typeid(T).name()).c_str(), object);\n-\t}\n-\n-\t//! get a pointer to this object, as a pointer to T\n-\ttemplate <class T>\n-\tbool GetThisPointer(T *&p) const\n-\t{\n-\t\treturn GetValue((std::string(\"ThisPointer:\")+typeid(T).name()).c_str(), p);\n-\t}\n-\n-\t//! get a named value, returns true if the name exists\n-\ttemplate <class T>\n-\tbool GetValue(const char *name, T &value) const\n-\t{\n-\t\treturn GetVoidValue(name, typeid(T), &value);\n-\t}\n-\n-\t//! get a named value, returns the default if the name doesn't exist\n-\ttemplate <class T>\n-\tT GetValueWithDefault(const char *name, T defaultValue) const\n-\t{\n-\t\tGetValue(name, defaultValue);\n-\t\treturn defaultValue;\n-\t}\n-\n-\t//! get a list of value names that can be retrieved\n-\tCRYPTOPP_DLL std::string GetValueNames() const\n-\t\t{std::string result; GetValue(\"ValueNames\", result); return result;}\n-\n-\t//! get a named value with type int\n-\t/*! used to ensure we don't accidentally try to get an unsigned int\n-\t\tor some other type when we mean int (which is the most common case) */\n-\tCRYPTOPP_DLL bool GetIntValue(const char *name, int &value) const\n-\t\t{return GetValue(name, value);}\n-\n-\t//! get a named value with type int, with default\n-\tCRYPTOPP_DLL int GetIntValueWithDefault(const char *name, int defaultValue) const\n-\t\t{return GetValueWithDefault(name, defaultValue);}\n-\n-\t//! used by derived classes to check for type mismatch\n-\tCRYPTOPP_DLL static void CRYPTOPP_API ThrowIfTypeMismatch(const char *name, const std::type_info &stored, const std::type_info &retrieving)\n-\t\t{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}\n-\n-\ttemplate <class T>\n-\tvoid GetRequiredParameter(const char *className, const char *name, T &value) const\n-\t{\n-\t\tif (!GetValue(name, value))\n-\t\t\tthrow InvalidArgument(std::string(className) + \": missing required parameter '\" + name + \"'\");\n-\t}\n-\n-\tCRYPTOPP_DLL void GetRequiredIntParameter(const char *className, const char *name, int &value) const\n-\t{\n-\t\tif (!GetIntValue(name, value))\n-\t\t\tthrow InvalidArgument(std::string(className) + \": missing required parameter '\" + name + \"'\");\n-\t}\n-\n-\t//! to be implemented by derived classes, users should use one of the above functions instead\n-\tCRYPTOPP_DLL virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const =0;\n-};\n-\n-//! namespace containing value name definitions\n-/*!\tvalue names, types and semantics:\n-\n-\tThisObject:ClassName (ClassName, copy of this object or a subobject)\n-\tThisPointer:ClassName (const ClassName *, pointer to this object or a subobject)\n-*/\n-DOCUMENTED_NAMESPACE_BEGIN(Name)\n-// more names defined in argnames.h\n-DOCUMENTED_NAMESPACE_END\n-\n-//! empty set of name-value pairs\n-class CRYPTOPP_DLL NullNameValuePairs : public NameValuePairs\n-{\n-public:\n-\tbool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const {return false;}\n-};\n-\n-//! _\n-extern CRYPTOPP_DLL const NullNameValuePairs g_nullNameValuePairs;\n-\n-// ********************************************************\n-\n-//! interface for cloning objects, this is not implemented by most classes yet\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Clonable\n-{\n-public:\n-\tvirtual ~Clonable() {}\n-\t//! this is not implemented by most classes yet\n-\tvirtual Clonable* Clone() const {throw NotImplemented(\"Clone() is not implemented yet.\");}\t// TODO: make this =0\n-};\n-\n-//! interface for all crypto algorithms\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Algorithm : public Clonable\n-{\n-public:\n-\t/*! When FIPS 140-2 compliance is enabled and checkSelfTestStatus == true,\n-\t\tthis constructor throws SelfTestFailure if the self test hasn't been run or fails. */\n-\tAlgorithm(bool checkSelfTestStatus = true);\n-\t//! returns name of this algorithm, not universally implemented yet\n-\tvirtual std::string AlgorithmName() const {return \"unknown\";}\n-};\n-\n-//! keying interface for crypto algorithms that take byte strings as keys\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyingInterface\n-{\n-public:\n-\tvirtual ~SimpleKeyingInterface() {}\n-\n-\t//! returns smallest valid key length in bytes */\n-\tvirtual size_t MinKeyLength() const =0;\n-\t//! returns largest valid key length in bytes */\n-\tvirtual size_t MaxKeyLength() const =0;\n-\t//! returns default (recommended) key length in bytes */\n-\tvirtual size_t DefaultKeyLength() const =0;\n-\n-\t//! returns the smallest valid key length in bytes that is >= min(n, GetMaxKeyLength())\n-\tvirtual size_t GetValidKeyLength(size_t n) const =0;\n-\n-\t//! returns whether n is a valid key length\n-\tvirtual bool IsValidKeyLength(size_t n) const\n-\t\t{return n == GetValidKeyLength(n);}\n-\n-\t//! set or reset the key of this object\n-\t/*! \\param params is used to specify Rounds, BlockSize, etc. */\n-\tvirtual void SetKey(const byte *key, size_t length, const NameValuePairs &params = g_nullNameValuePairs);\n-\n-\t//! calls SetKey() with an NameValuePairs object that just specifies \"Rounds\"\n-\tvoid SetKeyWithRounds(const byte *key, size_t length, int rounds);\n-\n-\t//! calls SetKey() with an NameValuePairs object that just specifies \"IV\"\n-\tvoid SetKeyWithIV(const byte *key, size_t length, const byte *iv, size_t ivLength);\n-\n-\t//! calls SetKey() with an NameValuePairs object that just specifies \"IV\"\n-\tvoid SetKeyWithIV(const byte *key, size_t length, const byte *iv)\n-\t\t{SetKeyWithIV(key, length, iv, IVSize());}\n-\n-\tenum IV_Requirement {UNIQUE_IV = 0, RANDOM_IV, UNPREDICTABLE_RANDOM_IV, INTERNALLY_GENERATED_IV, NOT_RESYNCHRONIZABLE};\n-\t//! returns the minimal requirement for secure IVs\n-\tvirtual IV_Requirement IVRequirement() const =0;\n-\n-\t//! returns whether this object can be resynchronized (i.e. supports initialization vectors)\n-\t/*! If this function returns true, and no IV is passed to SetKey() and CanUseStructuredIVs()==true, an IV of all 0's will be assumed. */\n-\tbool IsResynchronizable() const {return IVRequirement() < NOT_RESYNCHRONIZABLE;}\n-\t//! returns whether this object can use random IVs (in addition to ones returned by GetNextIV)\n-\tbool CanUseRandomIVs() const {return IVRequirement() <= UNPREDICTABLE_RANDOM_IV;}\n-\t//! returns whether this object can use random but possibly predictable IVs (in addition to ones returned by GetNextIV)\n-\tbool CanUsePredictableIVs() const {return IVRequirement() <= RANDOM_IV;}\n-\t//! returns whether this object can use structured IVs, for example a counter (in addition to ones returned by GetNextIV)\n-\tbool CanUseStructuredIVs() const {return IVRequirement() <= UNIQUE_IV;}\n-\n-\tvirtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + \": this object doesn't support resynchronization\");}\n-\t//! returns default length of IVs accepted by this object\n-\tunsigned int DefaultIVLength() const {return IVSize();}\n-\t//! returns minimal length of IVs accepted by this object\n-\tvirtual unsigned int MinIVLength() const {return IVSize();}\n-\t//! returns maximal length of IVs accepted by this object\n-\tvirtual unsigned int MaxIVLength() const {return IVSize();}\n-\t//! resynchronize with an IV. ivLength=-1 means use IVSize()\n-\tvirtual void Resynchronize(const byte *iv, int ivLength=-1) {throw NotImplemented(GetAlgorithm().AlgorithmName() + \": this object doesn't support resynchronization\");}\n-\t//! get a secure IV for the next message\n-\t/*! This method should be called after you finish encrypting one message and are ready to start the next one.\n-\t\tAfter calling it, you must call SetKey() or Resynchronize() before using this object again. \n-\t\tThis method is not implemented on decryption objects. */\n-\tvirtual void GetNextIV(RandomNumberGenerator &rng, byte *IV);\n-\n-protected:\n-\tvirtual const Algorithm & GetAlgorithm() const =0;\n-\tvirtual void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params) =0;\n-\n-\tvoid ThrowIfInvalidKeyLength(size_t length);\n-\tvoid ThrowIfResynchronizable();\t\t\t// to be called when no IV is passed\n-\tvoid ThrowIfInvalidIV(const byte *iv);\t// check for NULL IV if it can't be used\n-\tsize_t ThrowIfInvalidIVLength(int size);\n-\tconst byte * GetIVAndThrowIfInvalid(const NameValuePairs &params, size_t &size);\n-\tinline void AssertValidKeyLength(size_t length) const\n-\t\t{assert(IsValidKeyLength(length));}\n-};\n-\n-//! interface for the data processing part of block ciphers\n-\n-/*! Classes derived from BlockTransformation are block ciphers\n-\tin ECB mode (for example the DES::Encryption class), which are stateless.\n-\tThese classes should not be used directly, but only in combination with\n-\ta mode class (see CipherModeDocumentation in modes.h).\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockTransformation : public Algorithm\n-{\n-public:\n-\t//! encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock\n-\tvirtual void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const =0;\n-\n-\t//! encrypt or decrypt one block\n-\t/*! \\pre size of inBlock and outBlock == BlockSize() */\n-\tvoid ProcessBlock(const byte *inBlock, byte *outBlock) const\n-\t\t{ProcessAndXorBlock(inBlock, NULL, outBlock);}\n-\n-\t//! encrypt or decrypt one block in place\n-\tvoid ProcessBlock(byte *inoutBlock) const\n-\t\t{ProcessAndXorBlock(inoutBlock, NULL, inoutBlock);}\n-\n-\t//! block size of the cipher in bytes\n-\tvirtual unsigned int BlockSize() const =0;\n-\n-\t//! returns how inputs and outputs should be aligned for optimal performance\n-\tvirtual unsigned int OptimalDataAlignment() const;\n-\n-\t//! returns true if this is a permutation (i.e. there is an inverse transformation)\n-\tvirtual bool IsPermutation() const {return true;}\n-\n-\t//! returns true if this is an encryption object\n-\tvirtual bool IsForwardTransformation() const =0;\n-\n-\t//! return number of blocks that can be processed in parallel, for bit-slicing implementations\n-\tvirtual unsigned int OptimalNumberOfParallelBlocks() const {return 1;}\n-\n-\tenum {BT_InBlockIsCounter=1, BT_DontIncrementInOutPointers=2, BT_XorInput=4, BT_ReverseDirection=8} FlagsForAdvancedProcessBlocks;\n-\n-\t//! encrypt and xor blocks according to flags (see FlagsForAdvancedProcessBlocks)\n-\t/*! /note If BT_InBlockIsCounter is set, last byte of inBlocks may be modified. */\n-\tvirtual size_t AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const;\n-\n-\tinline CipherDir GetCipherDirection() const {return IsForwardTransformation() ? ENCRYPTION : DECRYPTION;}\n-};\n-\n-//! interface for the data processing part of stream ciphers\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE StreamTransformation : public Algorithm\n-{\n-public:\n-\t//! return a reference to this object, \n-\t/*! This function is useful for passing a temporary StreamTransformation object to a \n-\t\tfunction that takes a non-const reference. */\n-\tStreamTransformation& Ref() {return *this;}\n-\n-\t//! returns block size, if input must be processed in blocks, otherwise 1\n-\tvirtual unsigned int MandatoryBlockSize() const {return 1;}\n-\n-\t//! returns the input block size that is most efficient for this cipher\n-\t/*! \\note optimal input length is n * OptimalBlockSize() - GetOptimalBlockSizeUsed() for any n > 0 */\n-\tvirtual unsigned int OptimalBlockSize() const {return MandatoryBlockSize();}\n-\t//! returns how much of the current block is used up\n-\tvirtual unsigned int GetOptimalBlockSizeUsed() const {return 0;}\n-\n-\t//! returns how input should be aligned for optimal performance\n-\tvirtual unsigned int OptimalDataAlignment() const;\n-\n-\t//! encrypt or decrypt an array of bytes of specified length\n-\t/*! \\note either inString == outString, or they don't overlap */\n-\tvirtual void ProcessData(byte *outString, const byte *inString, size_t length) =0;\n-\n-\t//! for ciphers where the last block of data is special, encrypt or decrypt the last block of data\n-\t/*! For now the only use of this function is for CBC-CTS mode. */\n-\tvirtual void ProcessLastBlock(byte *outString, const byte *inString, size_t length);\n-\t//! returns the minimum size of the last block, 0 indicating the last block is not special\n-\tvirtual unsigned int MinLastBlockSize() const {return 0;}\n-\n-\t//! same as ProcessData(inoutString, inoutString, length)\n-\tinline void ProcessString(byte *inoutString, size_t length)\n-\t\t{ProcessData(inoutString, inoutString, length);}\n-\t//! same as ProcessData(outString, inString, length)\n-\tinline void ProcessString(byte *outString, const byte *inString, size_t length)\n-\t\t{ProcessData(outString, inString, length);}\n-\t//! implemented as {ProcessData(&input, &input, 1); return input;}\n-\tinline byte ProcessByte(byte input)\n-\t\t{ProcessData(&input, &input, 1); return input;}\n-\n-\t//! returns whether this cipher supports random access\n-\tvirtual bool IsRandomAccess() const =0;\n-\t//! for random access ciphers, seek to an absolute position\n-\tvirtual void Seek(lword n)\n-\t{\n-\t\tassert(!IsRandomAccess());\n-\t\tthrow NotImplemented(\"StreamTransformation: this object doesn't support random access\");\n-\t}\n-\n-\t//! returns whether this transformation is self-inverting (e.g. xor with a keystream)\n-\tvirtual bool IsSelfInverting() const =0;\n-\t//! returns whether this is an encryption object\n-\tvirtual bool IsForwardTransformation() const =0;\n-};\n-\n-//! interface for hash functions and data processing part of MACs\n-\n-/*! HashTransformation objects are stateful.  They are created in an initial state,\n-\tchange state as Update() is called, and return to the initial\n-\tstate when Final() is called.  This interface allows a large message to\n-\tbe hashed in pieces by calling Update() on each piece followed by\n-\tcalling Final().\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE HashTransformation : public Algorithm\n-{\n-public:\n-\t//! return a reference to this object, \n-\t/*! This function is useful for passing a temporary HashTransformation object to a \n-\t\tfunction that takes a non-const reference. */\n-\tHashTransformation& Ref() {return *this;}\n-\n-\t//! process more input\n-\tvirtual void Update(const byte *input, size_t length) =0;\n-\n-\t//! request space to write input into\n-\tvirtual byte * CreateUpdateSpace(size_t &size) {size=0; return NULL;}\n-\n-\t//! compute hash for current message, then restart for a new message\n-\t/*!\t\\pre size of digest == DigestSize(). */\n-\tvirtual void Final(byte *digest)\n-\t\t{TruncatedFinal(digest, DigestSize());}\n-\n-\t//! discard the current state, and restart with a new message\n-\tvirtual void Restart()\n-\t\t{TruncatedFinal(NULL, 0);}\n-\n-\t//! size of the hash/digest/MAC returned by Final()\n-\tvirtual unsigned int DigestSize() const =0;\n-\n-\t//! same as DigestSize()\n-\tunsigned int TagSize() const {return DigestSize();}\n-\n-\n-\t//! block size of underlying compression function, or 0 if not block based\n-\tvirtual unsigned int BlockSize() const {return 0;}\n-\n-\t//! input to Update() should have length a multiple of this for optimal speed\n-\tvirtual unsigned int OptimalBlockSize() const {return 1;}\n-\n-\t//! returns how input should be aligned for optimal performance\n-\tvirtual unsigned int OptimalDataAlignment() const;\n-\n-\t//! use this if your input is in one piece and you don't want to call Update() and Final() separately\n-\tvirtual void CalculateDigest(byte *digest, const byte *input, size_t length)\n-\t\t{Update(input, length); Final(digest);}\n-\n-\t//! verify that digest is a valid digest for the current message, then reinitialize the object\n-\t/*! Default implementation is to call Final() and do a bitwise comparison\n-\t\tbetween its output and digest. */\n-\tvirtual bool Verify(const byte *digest)\n-\t\t{return TruncatedVerify(digest, DigestSize());}\n-\n-\t//! use this if your input is in one piece and you don't want to call Update() and Verify() separately\n-\tvirtual bool VerifyDigest(const byte *digest, const byte *input, size_t length)\n-\t\t{Update(input, length); return Verify(digest);}\n-\n-\t//! truncated version of Final()\n-\tvirtual void TruncatedFinal(byte *digest, size_t digestSize) =0;\n-\n-\t//! truncated version of CalculateDigest()\n-\tvirtual void CalculateTruncatedDigest(byte *digest, size_t digestSize, const byte *input, size_t length)\n-\t\t{Update(input, length); TruncatedFinal(digest, digestSize);}\n-\n-\t//! truncated version of Verify()\n-\tvirtual bool TruncatedVerify(const byte *digest, size_t digestLength);\n-\n-\t//! truncated version of VerifyDigest()\n-\tvirtual bool VerifyTruncatedDigest(const byte *digest, size_t digestLength, const byte *input, size_t length)\n-\t\t{Update(input, length); return TruncatedVerify(digest, digestLength);}\n-\n-protected:\n-\tvoid ThrowIfInvalidTruncatedSize(size_t size) const;\n-};\n-\n-typedef HashTransformation HashFunction;\n-\n-//! interface for one direction (encryption or decryption) of a block cipher\n-/*! \\note These objects usually should not be used directly. See BlockTransformation for more details. */\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockCipher : public SimpleKeyingInterface, public BlockTransformation\n-{\n-protected:\n-\tconst Algorithm & GetAlgorithm() const {return *this;}\n-};\n-\n-//! interface for one direction (encryption or decryption) of a stream cipher or cipher mode\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SymmetricCipher : public SimpleKeyingInterface, public StreamTransformation\n-{\n-protected:\n-\tconst Algorithm & GetAlgorithm() const {return *this;}\n-};\n-\n-//! interface for message authentication codes\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE MessageAuthenticationCode : public SimpleKeyingInterface, public HashTransformation\n-{\n-protected:\n-\tconst Algorithm & GetAlgorithm() const {return *this;}\n-};\n-\n-//! interface for for one direction (encryption or decryption) of a stream cipher or block cipher mode with authentication\n-/*! The StreamTransformation part of this interface is used to encrypt/decrypt the data, and the MessageAuthenticationCode part of this\n-\tinterface is used to input additional authenticated data (AAD, which is MAC'ed but not encrypted), and to generate/verify the MAC. */\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedSymmetricCipher : public MessageAuthenticationCode, public StreamTransformation\n-{\n-public:\n-\t//! this indicates that a member function was called in the wrong state, for example trying to encrypt a message before having set the key or IV\n-\tclass BadState : public Exception\n-\t{\n-\tpublic:\n-\t\texplicit BadState(const std::string &name, const char *message) : Exception(OTHER_ERROR, name + \": \" + message) {}\n-\t\texplicit BadState(const std::string &name, const char *function, const char *state) : Exception(OTHER_ERROR, name + \": \" + function + \" was called before \" + state) {}\n-\t};\n-\n-\t//! the maximum length of AAD that can be input before the encrypted data\n-\tvirtual lword MaxHeaderLength() const =0;\n-\t//! the maximum length of encrypted data\n-\tvirtual lword MaxMessageLength() const =0;\n-\t//! the maximum length of AAD that can be input after the encrypted data\n-\tvirtual lword MaxFooterLength() const {return 0;}\n-\t//! if this function returns true, SpecifyDataLengths() must be called before attempting to input data\n-\t/*! This is the case for some schemes, such as CCM. */\n-\tvirtual bool NeedsPrespecifiedDataLengths() const {return false;}\n-\t//! this function only needs to be called if NeedsPrespecifiedDataLengths() returns true\n-\tvoid SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength=0);\n-\t//! encrypt and generate MAC in one call. will truncate MAC if macSize < TagSize()\n-\tvirtual void EncryptAndAuthenticate(byte *ciphertext, byte *mac, size_t macSize, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *message, size_t messageLength);\n-\t//! decrypt and verify MAC in one call, returning true iff MAC is valid. will assume MAC is truncated if macLength < TagSize()\n-\tvirtual bool DecryptAndVerify(byte *message, const byte *mac, size_t macLength, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *ciphertext, size_t ciphertextLength);\n-\n-\t// redeclare this to avoid compiler ambiguity errors\n-\tvirtual std::string AlgorithmName() const =0;\n-\n-protected:\n-\tconst Algorithm & GetAlgorithm() const {return *static_cast<const MessageAuthenticationCode *>(this);}\n-\tvirtual void UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength) {}\n-};\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-typedef SymmetricCipher StreamCipher;\n-#endif\n-\n-//! interface for random number generators\n-/*! All return values are uniformly distributed over the range specified.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE RandomNumberGenerator : public Algorithm\n-{\n-public:\n-\t//! update RNG state with additional unpredictable values\n-\tvirtual void IncorporateEntropy(const byte *input, size_t length) {throw NotImplemented(\"RandomNumberGenerator: IncorporateEntropy not implemented\");}\n-\n-\t//! returns true if IncorporateEntropy is implemented\n-\tvirtual bool CanIncorporateEntropy() const {return false;}\n-\n-\t//! generate new random byte and return it\n-\tvirtual byte GenerateByte();\n-\n-\t//! generate new random bit and return it\n-\t/*! Default implementation is to call GenerateByte() and return its lowest bit. */\n-\tvirtual unsigned int GenerateBit();\n-\n-\t//! generate a random 32 bit word in the range min to max, inclusive\n-\tvirtual word32 GenerateWord32(word32 a=0, word32 b=0xffffffffL);\n-\n-\t//! generate random array of bytes\n-\tvirtual void GenerateBlock(byte *output, size_t size);\n-\n-\t//! generate and discard n bytes\n-\tvirtual void DiscardBytes(size_t n);\n-\n-\t//! generate random bytes as input to a BufferedTransformation\n-\tvirtual void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length);\n-\n-\t//! randomly shuffle the specified array, resulting permutation is uniformly distributed\n-\ttemplate <class IT> void Shuffle(IT begin, IT end)\n-\t{\n-\t\tfor (; begin != end; ++begin)\n-\t\t\tstd::iter_swap(begin, begin + GenerateWord32(0, end-begin-1));\n-\t}\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\tbyte GetByte() {return GenerateByte();}\n-\tunsigned int GetBit() {return GenerateBit();}\n-\tword32 GetLong(word32 a=0, word32 b=0xffffffffL) {return GenerateWord32(a, b);}\n-\tword16 GetShort(word16 a=0, word16 b=0xffff) {return (word16)GenerateWord32(a, b);}\n-\tvoid GetBlock(byte *output, size_t size) {GenerateBlock(output, size);}\n-#endif\n-};\n-\n-//! returns a reference that can be passed to functions that ask for a RNG but doesn't actually use it\n-CRYPTOPP_DLL RandomNumberGenerator & CRYPTOPP_API NullRNG();\n-\n-class WaitObjectContainer;\n-class CallStack;\n-\n-//! interface for objects that you can wait for\n-\n-class CRYPTOPP_NO_VTABLE Waitable\n-{\n-public:\n-\tvirtual ~Waitable() {}\n-\n-\t//! maximum number of wait objects that this object can return\n-\tvirtual unsigned int GetMaxWaitObjectCount() const =0;\n-\t//! put wait objects into container\n-\t/*! \\param callStack is used for tracing no wait loops, example:\n-\t             something.GetWaitObjects(c, CallStack(\"my func after X\", 0));\n-\t\t\t   - or in an outer GetWaitObjects() method that itself takes a callStack parameter:\n-\t\t\t     innerThing.GetWaitObjects(c, CallStack(\"MyClass::GetWaitObjects at X\", &callStack)); */\n-\tvirtual void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack) =0;\n-\t//! wait on this object\n-\t/*! same as creating an empty container, calling GetWaitObjects(), and calling Wait() on the container */\n-\tbool Wait(unsigned long milliseconds, CallStack const& callStack);\n-};\n-\n-//! the default channel for BufferedTransformation, equal to the empty string\n-extern CRYPTOPP_DLL const std::string DEFAULT_CHANNEL;\n-\n-//! channel for additional authenticated data, equal to \"AAD\"\n-extern CRYPTOPP_DLL const std::string AAD_CHANNEL;\n-\n-//! interface for buffered transformations\n-\n-/*! BufferedTransformation is a generalization of BlockTransformation,\n-\tStreamTransformation, and HashTransformation.\n-\n-\tA buffered transformation is an object that takes a stream of bytes\n-\tas input (this may be done in stages), does some computation on them, and\n-\tthen places the result into an internal buffer for later retrieval.  Any\n-\tpartial result already in the output buffer is not modified by further\n-\tinput.\n-\n-\tIf a method takes a \"blocking\" parameter, and you\n-\tpass \"false\" for it, the method will return before all input has been processed if\n-\tthe input cannot be processed without waiting (for network buffers to become available, for example).\n-\tIn this case the method will return true\n-\tor a non-zero integer value. When this happens you must continue to call the method with the same\n-\tparameters until it returns false or zero, before calling any other method on it or\n-\tattached BufferedTransformation. The integer return value in this case is approximately\n-\tthe number of bytes left to be processed, and can be used to implement a progress bar.\n-\n-\tFor functions that take a \"propagation\" parameter, propagation != 0 means pass on the signal to attached\n-\tBufferedTransformation objects, with propagation decremented at each step until it reaches 0.\n-\t-1 means unlimited propagation.\n-\n-\t\\nosubgrouping\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BufferedTransformation : public Algorithm, public Waitable\n-{\n-public:\n-\t// placed up here for CW8\n-\tstatic const std::string &NULL_CHANNEL;\t// same as DEFAULT_CHANNEL, for backwards compatibility\n-\n-\tBufferedTransformation() : Algorithm(false) {}\n-\n-\t//! return a reference to this object\n-\t/*! This function is useful for passing a temporary BufferedTransformation object to a \n-\t\tfunction that takes a non-const reference. */\n-\tBufferedTransformation& Ref() {return *this;}\n-\n-\t//!\t\\name INPUT\n-\t//@{\n-\t\t//! input a byte for processing\n-\t\tsize_t Put(byte inByte, bool blocking=true)\n-\t\t\t{return Put(&inByte, 1, blocking);}\n-\t\t//! input multiple bytes\n-\t\tsize_t Put(const byte *inString, size_t length, bool blocking=true)\n-\t\t\t{return Put2(inString, length, 0, blocking);}\n-\n-\t\t//! input a 16-bit word\n-\t\tsize_t PutWord16(word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);\n-\t\t//! input a 32-bit word\n-\t\tsize_t PutWord32(word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);\n-\n-\t\t//! request space which can be written into by the caller, and then used as input to Put()\n-\t\t/*! \\param size is requested size (as a hint) for input, and size of the returned space for output */\n-\t\t/*! \\note The purpose of this method is to help avoid doing extra memory allocations. */\n-\t\tvirtual byte * CreatePutSpace(size_t &size) {size=0; return NULL;}\n-\n-\t\tvirtual bool CanModifyInput() const {return false;}\n-\n-\t\t//! input multiple bytes that may be modified by callee\n-\t\tsize_t PutModifiable(byte *inString, size_t length, bool blocking=true)\n-\t\t\t{return PutModifiable2(inString, length, 0, blocking);}\n-\n-\t\tbool MessageEnd(int propagation=-1, bool blocking=true)\n-\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}\n-\t\tsize_t PutMessageEnd(const byte *inString, size_t length, int propagation=-1, bool blocking=true)\n-\t\t\t{return Put2(inString, length, propagation < 0 ? -1 : propagation+1, blocking);}\n-\n-\t\t//! input multiple bytes for blocking or non-blocking processing\n-\t\t/*! \\param messageEnd means how many filters to signal MessageEnd to, including this one */\n-\t\tvirtual size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking) =0;\n-\t\t//! input multiple bytes that may be modified by callee for blocking or non-blocking processing\n-\t\t/*! \\param messageEnd means how many filters to signal MessageEnd to, including this one */\n-\t\tvirtual size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)\n-\t\t\t{return Put2(inString, length, messageEnd, blocking);}\n-\n-\t\t//! thrown by objects that have not implemented nonblocking input processing\n-\t\tstruct BlockingInputOnly : public NotImplemented\n-\t\t\t{BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}};\n-\t//@}\n-\n-\t//!\t\\name WAITING\n-\t//@{\n-\t\tunsigned int GetMaxWaitObjectCount() const;\n-\t\tvoid GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack);\n-\t//@}\n-\n-\t//!\t\\name SIGNALS\n-\t//@{\n-\t\tvirtual void IsolatedInitialize(const NameValuePairs &parameters) {throw NotImplemented(\"BufferedTransformation: this object can't be reinitialized\");}\n-\t\tvirtual bool IsolatedFlush(bool hardFlush, bool blocking) =0;\n-\t\tvirtual bool IsolatedMessageSeriesEnd(bool blocking) {return false;}\n-\n-\t\t//! initialize or reinitialize this object\n-\t\tvirtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);\n-\t\t//! flush buffered input and/or output\n-\t\t/*! \\param hardFlush is used to indicate whether all data should be flushed\n-\t\t\t\\note Hard flushes must be used with care. It means try to process and output everything, even if\n-\t\t\tthere may not be enough data to complete the action. For example, hard flushing a HexDecoder would\n-\t\t\tcause an error if you do it after inputing an odd number of hex encoded characters.\n-\t\t\tFor some types of filters, for example ZlibDecompressor, hard flushes can only\n-\t\t\tbe done at \"synchronization points\". These synchronization points are positions in the data\n-\t\t\tstream that are created by hard flushes on the corresponding reverse filters, in this\n-\t\t\texample ZlibCompressor. This is useful when zlib compressed data is moved across a\n-\t\t\tnetwork in packets and compression state is preserved across packets, as in the ssh2 protocol.\n-\t\t*/\n-\t\tvirtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);\n-\t\t//! mark end of a series of messages\n-\t\t/*! There should be a MessageEnd immediately before MessageSeriesEnd. */\n-\t\tvirtual bool MessageSeriesEnd(int propagation=-1, bool blocking=true);\n-\n-\t\t//! set propagation of automatically generated and transferred signals\n-\t\t/*! propagation == 0 means do not automaticly generate signals */\n-\t\tvirtual void SetAutoSignalPropagation(int propagation) {}\n-\n-\t\t//!\n-\t\tvirtual int GetAutoSignalPropagation() const {return 0;}\n-public:\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\t\tvoid Close() {MessageEnd();}\n-#endif\n-\t//@}\n-\n-\t//!\t\\name RETRIEVAL OF ONE MESSAGE\n-\t//@{\n-\t\t//! returns number of bytes that is currently ready for retrieval\n-\t\t/*! All retrieval functions return the actual number of bytes\n-\t\t\tretrieved, which is the lesser of the request number and\n-\t\t\tMaxRetrievable(). */\n-\t\tvirtual lword MaxRetrievable() const;\n-\n-\t\t//! returns whether any bytes are currently ready for retrieval\n-\t\tvirtual bool AnyRetrievable() const;\n-\n-\t\t//! try to retrieve a single byte\n-\t\tvirtual size_t Get(byte &outByte);\n-\t\t//! try to retrieve multiple bytes\n-\t\tvirtual size_t Get(byte *outString, size_t getMax);\n-\n-\t\t//! peek at the next byte without removing it from the output buffer\n-\t\tvirtual size_t Peek(byte &outByte) const;\n-\t\t//! peek at multiple bytes without removing them from the output buffer\n-\t\tvirtual size_t Peek(byte *outString, size_t peekMax) const;\n-\n-\t\t//! try to retrieve a 16-bit word\n-\t\tsize_t GetWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER);\n-\t\t//! try to retrieve a 32-bit word\n-\t\tsize_t GetWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER);\n-\n-\t\t//! try to peek at a 16-bit word\n-\t\tsize_t PeekWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;\n-\t\t//! try to peek at a 32-bit word\n-\t\tsize_t PeekWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;\n-\n-\t\t//! move transferMax bytes of the buffered output to target as input\n-\t\tlword TransferTo(BufferedTransformation &target, lword transferMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL)\n-\t\t\t{TransferTo2(target, transferMax, channel); return transferMax;}\n-\n-\t\t//! discard skipMax bytes from the output buffer\n-\t\tvirtual lword Skip(lword skipMax=LWORD_MAX);\n-\n-\t\t//! copy copyMax bytes of the buffered output to target as input\n-\t\tlword CopyTo(BufferedTransformation &target, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const\n-\t\t\t{return CopyRangeTo(target, 0, copyMax, channel);}\n-\n-\t\t//! copy copyMax bytes of the buffered output, starting at position (relative to current position), to target as input\n-\t\tlword CopyRangeTo(BufferedTransformation &target, lword position, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const\n-\t\t\t{lword i = position; CopyRangeTo2(target, i, i+copyMax, channel); return i-position;}\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\t\tunsigned long MaxRetrieveable() const {return MaxRetrievable();}\n-#endif\n-\t//@}\n-\n-\t//!\t\\name RETRIEVAL OF MULTIPLE MESSAGES\n-\t//@{\n-\t\t//!\n-\t\tvirtual lword TotalBytesRetrievable() const;\n-\t\t//! number of times MessageEnd() has been received minus messages retrieved or skipped\n-\t\tvirtual unsigned int NumberOfMessages() const;\n-\t\t//! returns true if NumberOfMessages() > 0\n-\t\tvirtual bool AnyMessages() const;\n-\t\t//! start retrieving the next message\n-\t\t/*!\n-\t\t\tReturns false if no more messages exist or this message \n-\t\t\tis not completely retrieved.\n-\t\t*/\n-\t\tvirtual bool GetNextMessage();\n-\t\t//! skip count number of messages\n-\t\tvirtual unsigned int SkipMessages(unsigned int count=UINT_MAX);\n-\t\t//!\n-\t\tunsigned int TransferMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)\n-\t\t\t{TransferMessagesTo2(target, count, channel); return count;}\n-\t\t//!\n-\t\tunsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const;\n-\n-\t\t//!\n-\t\tvirtual void SkipAll();\n-\t\t//!\n-\t\tvoid TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n-\t\t\t{TransferAllTo2(target, channel);}\n-\t\t//!\n-\t\tvoid CopyAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL) const;\n-\n-\t\tvirtual bool GetNextMessageSeries() {return false;}\n-\t\tvirtual unsigned int NumberOfMessagesInThisSeries() const {return NumberOfMessages();}\n-\t\tvirtual unsigned int NumberOfMessageSeries() const {return 0;}\n-\t//@}\n-\n-\t//!\t\\name NON-BLOCKING TRANSFER OF OUTPUT\n-\t//@{\n-\t\t//! upon return, byteCount contains number of bytes that have finished being transfered, and returns the number of bytes left in the current transfer block\n-\t\tvirtual size_t TransferTo2(BufferedTransformation &target, lword &byteCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) =0;\n-\t\t//! upon return, begin contains the start position of data yet to be finished copying, and returns the number of bytes left in the current transfer block\n-\t\tvirtual size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const =0;\n-\t\t//! upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block\n-\t\tsize_t TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);\n-\t\t//! returns the number of bytes left in the current transfer block\n-\t\tsize_t TransferAllTo2(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);\n-\t//@}\n-\n-\t//!\t\\name CHANNELS\n-\t//@{\n-\t\tstruct NoChannelSupport : public NotImplemented\n-\t\t\t{NoChannelSupport(const std::string &name) : NotImplemented(name + \": this object doesn't support multiple channels\") {}};\n-\t\tstruct InvalidChannelName : public InvalidArgument\n-\t\t\t{InvalidChannelName(const std::string &name, const std::string &channel) : InvalidArgument(name + \": unexpected channel name \\\"\" + channel + \"\\\"\") {}};\n-\n-\t\tsize_t ChannelPut(const std::string &channel, byte inByte, bool blocking=true)\n-\t\t\t{return ChannelPut(channel, &inByte, 1, blocking);}\n-\t\tsize_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n-\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}\n-\n-\t\tsize_t ChannelPutModifiable(const std::string &channel, byte *inString, size_t length, bool blocking=true)\n-\t\t\t{return ChannelPutModifiable2(channel, inString, length, 0, blocking);}\n-\n-\t\tsize_t ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);\n-\t\tsize_t ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);\n-\n-\t\tbool ChannelMessageEnd(const std::string &channel, int propagation=-1, bool blocking=true)\n-\t\t\t{return !!ChannelPut2(channel, NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}\n-\t\tsize_t ChannelPutMessageEnd(const std::string &channel, const byte *inString, size_t length, int propagation=-1, bool blocking=true)\n-\t\t\t{return ChannelPut2(channel, inString, length, propagation < 0 ? -1 : propagation+1, blocking);}\n-\n-\t\tvirtual byte * ChannelCreatePutSpace(const std::string &channel, size_t &size);\n-\n-\t\tvirtual size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);\n-\t\tvirtual size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking);\n-\n-\t\tvirtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true);\n-\t\tvirtual bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);\n-\n-\t\tvirtual void SetRetrievalChannel(const std::string &channel);\n-\t//@}\n-\n-\t//!\t\\name ATTACHMENT\n-\t/*! Some BufferedTransformation objects (e.g. Filter objects)\n-\t\tallow other BufferedTransformation objects to be attached. When\n-\t\tthis is done, the first object instead of buffering its output,\n-\t\tsents that output to the attached object as input. The entire\n-\t\tattachment chain is deleted when the anchor object is destructed.\n-\t*/\n-\t//@{\n-\t\t//! returns whether this object allows attachment\n-\t\tvirtual bool Attachable() {return false;}\n-\t\t//! returns the object immediately attached to this object or NULL for no attachment\n-\t\tvirtual BufferedTransformation *AttachedTransformation() {assert(!Attachable()); return 0;}\n-\t\t//!\n-\t\tvirtual const BufferedTransformation *AttachedTransformation() const\n-\t\t\t{return const_cast<BufferedTransformation *>(this)->AttachedTransformation();}\n-\t\t//! delete the current attachment chain and replace it with newAttachment\n-\t\tvirtual void Detach(BufferedTransformation *newAttachment = 0)\n-\t\t\t{assert(!Attachable()); throw NotImplemented(\"BufferedTransformation: this object is not attachable\");}\n-\t\t//! add newAttachment to the end of attachment chain\n-\t\tvirtual void Attach(BufferedTransformation *newAttachment);\n-\t//@}\n-\n-protected:\n-\tstatic int DecrementPropagation(int propagation)\n-\t\t{return propagation != 0 ? propagation - 1 : 0;}\n-\n-private:\n-\tbyte m_buf[4];\t// for ChannelPutWord16 and ChannelPutWord32, to ensure buffer isn't deallocated before non-blocking operation completes\n-};\n-\n-//! returns a reference to a BufferedTransformation object that discards all input\n-BufferedTransformation & TheBitBucket();\n-\n-//! interface for crypto material, such as public and private keys, and crypto parameters\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoMaterial : public NameValuePairs\n-{\n-public:\n-\t//! exception thrown when invalid crypto material is detected\n-\tclass CRYPTOPP_DLL InvalidMaterial : public InvalidDataFormat\n-\t{\n-\tpublic:\n-\t\texplicit InvalidMaterial(const std::string &s) : InvalidDataFormat(s) {}\n-\t};\n-\n-\t//! assign values from source to this object\n-\t/*! \\note This function can be used to create a public key from a private key. */\n-\tvirtual void AssignFrom(const NameValuePairs &source) =0;\n-\n-\t//! check this object for errors\n-\t/*! \\param level denotes the level of thoroughness:\n-\t\t0 - using this object won't cause a crash or exception (rng is ignored)\n-\t\t1 - this object will probably function (encrypt, sign, etc.) correctly (but may not check for weak keys and such)\n-\t\t2 - make sure this object will function correctly, and do reasonable security checks\n-\t\t3 - do checks that may take a long time\n-\t\t\\return true if the tests pass */\n-\tvirtual bool Validate(RandomNumberGenerator &rng, unsigned int level) const =0;\n-\n-\t//! throws InvalidMaterial if this object fails Validate() test\n-\tvirtual void ThrowIfInvalid(RandomNumberGenerator &rng, unsigned int level) const\n-\t\t{if (!Validate(rng, level)) throw InvalidMaterial(\"CryptoMaterial: this object contains invalid values\");}\n-\n-//\tvirtual std::vector<std::string> GetSupportedFormats(bool includeSaveOnly=false, bool includeLoadOnly=false);\n-\n-\t//! save key into a BufferedTransformation\n-\tvirtual void Save(BufferedTransformation &bt) const\n-\t\t{throw NotImplemented(\"CryptoMaterial: this object does not support saving\");}\n-\n-\t//! load key from a BufferedTransformation\n-\t/*! \\throws KeyingErr if decode fails\n-\t\t\\note Generally does not check that the key is valid.\n-\t\t\tCall ValidateKey() or ThrowIfInvalidKey() to check that. */\n-\tvirtual void Load(BufferedTransformation &bt)\n-\t\t{throw NotImplemented(\"CryptoMaterial: this object does not support loading\");}\n-\n-\t//! \\return whether this object supports precomputation\n-\tvirtual bool SupportsPrecomputation() const {return false;}\n-\t//! do precomputation\n-\t/*! The exact semantics of Precompute() is varies, but\n-\t\ttypically it means calculate a table of n objects\n-\t\tthat can be used later to speed up computation. */\n-\tvirtual void Precompute(unsigned int n)\n-\t\t{assert(!SupportsPrecomputation()); throw NotImplemented(\"CryptoMaterial: this object does not support precomputation\");}\n-\t//! retrieve previously saved precomputation\n-\tvirtual void LoadPrecomputation(BufferedTransformation &storedPrecomputation)\n-\t\t{assert(!SupportsPrecomputation()); throw NotImplemented(\"CryptoMaterial: this object does not support precomputation\");}\n-\t//! save precomputation for later use\n-\tvirtual void SavePrecomputation(BufferedTransformation &storedPrecomputation) const\n-\t\t{assert(!SupportsPrecomputation()); throw NotImplemented(\"CryptoMaterial: this object does not support precomputation\");}\n-\n-\t// for internal library use\n-\tvoid DoQuickSanityCheck() const\t{ThrowIfInvalid(NullRNG(), 0);}\n-\n-#if (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)\n-\t// Sun Studio 11/CC 5.8 workaround: it generates incorrect code when casting to an empty virtual base class\n-\tchar m_sunCCworkaround;\n-#endif\n-};\n-\n-//! interface for generatable crypto material, such as private keys and crypto parameters\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE GeneratableCryptoMaterial : virtual public CryptoMaterial\n-{\n-public:\n-\t//! generate a random key or crypto parameters\n-\t/*! \\throws KeyingErr if algorithm parameters are invalid, or if a key can't be generated\n-\t\t(e.g., if this is a public key object) */\n-\tvirtual void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)\n-\t\t{throw NotImplemented(\"GeneratableCryptoMaterial: this object does not support key/parameter generation\");}\n-\n-\t//! calls the above function with a NameValuePairs object that just specifies \"KeySize\"\n-\tvoid GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize);\n-};\n-\n-//! interface for public keys\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKey : virtual public CryptoMaterial\n-{\n-};\n-\n-//! interface for private keys\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKey : public GeneratableCryptoMaterial\n-{\n-};\n-\n-//! interface for crypto prameters\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoParameters : public GeneratableCryptoMaterial\n-{\n-};\n-\n-//! interface for asymmetric algorithms\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AsymmetricAlgorithm : public Algorithm\n-{\n-public:\n-\t//! returns a reference to the crypto material used by this object\n-\tvirtual CryptoMaterial & AccessMaterial() =0;\n-\t//! returns a const reference to the crypto material used by this object\n-\tvirtual const CryptoMaterial & GetMaterial() const =0;\n-\n-\t//! for backwards compatibility, calls AccessMaterial().Load(bt)\n-\tvoid BERDecode(BufferedTransformation &bt)\n-\t\t{AccessMaterial().Load(bt);}\n-\t//! for backwards compatibility, calls GetMaterial().Save(bt)\n-\tvoid DEREncode(BufferedTransformation &bt) const\n-\t\t{GetMaterial().Save(bt);}\n-};\n-\n-//! interface for asymmetric algorithms using public keys\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKeyAlgorithm : public AsymmetricAlgorithm\n-{\n-public:\n-\t// VC60 workaround: no co-variant return type\n-\tCryptoMaterial & AccessMaterial() {return AccessPublicKey();}\n-\tconst CryptoMaterial & GetMaterial() const {return GetPublicKey();}\n-\n-\tvirtual PublicKey & AccessPublicKey() =0;\n-\tvirtual const PublicKey & GetPublicKey() const {return const_cast<PublicKeyAlgorithm *>(this)->AccessPublicKey();}\n-};\n-\n-//! interface for asymmetric algorithms using private keys\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKeyAlgorithm : public AsymmetricAlgorithm\n-{\n-public:\n-\tCryptoMaterial & AccessMaterial() {return AccessPrivateKey();}\n-\tconst CryptoMaterial & GetMaterial() const {return GetPrivateKey();}\n-\n-\tvirtual PrivateKey & AccessPrivateKey() =0;\n-\tvirtual const PrivateKey & GetPrivateKey() const {return const_cast<PrivateKeyAlgorithm *>(this)->AccessPrivateKey();}\n-};\n-\n-//! interface for key agreement algorithms\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE KeyAgreementAlgorithm : public AsymmetricAlgorithm\n-{\n-public:\n-\tCryptoMaterial & AccessMaterial() {return AccessCryptoParameters();}\n-\tconst CryptoMaterial & GetMaterial() const {return GetCryptoParameters();}\n-\n-\tvirtual CryptoParameters & AccessCryptoParameters() =0;\n-\tvirtual const CryptoParameters & GetCryptoParameters() const {return const_cast<KeyAgreementAlgorithm *>(this)->AccessCryptoParameters();}\n-};\n-\n-//! interface for public-key encryptors and decryptors\n-\n-/*! This class provides an interface common to encryptors and decryptors\n-\tfor querying their plaintext and ciphertext lengths.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_CryptoSystem\n-{\n-public:\n-\tvirtual ~PK_CryptoSystem() {}\n-\n-\t//! maximum length of plaintext for a given ciphertext length\n-\t/*! \\note This function returns 0 if ciphertextLength is not valid (too long or too short). */\n-\tvirtual size_t MaxPlaintextLength(size_t ciphertextLength) const =0;\n-\n-\t//! calculate length of ciphertext given length of plaintext\n-\t/*! \\note This function returns 0 if plaintextLength is not valid (too long). */\n-\tvirtual size_t CiphertextLength(size_t plaintextLength) const =0;\n-\n-\t//! this object supports the use of the parameter with the given name\n-\t/*! some possible parameter names: EncodingParameters, KeyDerivationParameters */\n-\tvirtual bool ParameterSupported(const char *name) const =0;\n-\n-\t//! return fixed ciphertext length, if one exists, otherwise return 0\n-\t/*! \\note \"Fixed\" here means length of ciphertext does not depend on length of plaintext.\n-\t\tIt usually does depend on the key length. */\n-\tvirtual size_t FixedCiphertextLength() const {return 0;}\n-\n-\t//! return maximum plaintext length given the fixed ciphertext length, if one exists, otherwise return 0\n-\tvirtual size_t FixedMaxPlaintextLength() const {return 0;}\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\tsize_t MaxPlainTextLength(size_t cipherTextLength) const {return MaxPlaintextLength(cipherTextLength);}\n-\tsize_t CipherTextLength(size_t plainTextLength) const {return CiphertextLength(plainTextLength);}\n-#endif\n-};\n-\n-//! interface for public-key encryptors\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Encryptor : public PK_CryptoSystem, public PublicKeyAlgorithm\n-{\n-public:\n-\t//! exception thrown when trying to encrypt plaintext of invalid length\n-\tclass CRYPTOPP_DLL InvalidPlaintextLength : public Exception\n-\t{\n-\tpublic:\n-\t\tInvalidPlaintextLength() : Exception(OTHER_ERROR, \"PK_Encryptor: invalid plaintext length\") {}\n-\t};\n-\n-\t//! encrypt a byte string\n-\t/*! \\pre CiphertextLength(plaintextLength) != 0 (i.e., plaintext isn't too long)\n-\t\t\\pre size of ciphertext == CiphertextLength(plaintextLength)\n-\t*/\n-\tvirtual void Encrypt(RandomNumberGenerator &rng, \n-\t\tconst byte *plaintext, size_t plaintextLength, \n-\t\tbyte *ciphertext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;\n-\n-\t//! create a new encryption filter\n-\t/*! \\note The caller is responsible for deleting the returned pointer.\n-\t\t\\note Encoding parameters should be passed in the \"EP\" channel.\n-\t*/\n-\tvirtual BufferedTransformation * CreateEncryptionFilter(RandomNumberGenerator &rng, \n-\t\tBufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;\n-};\n-\n-//! interface for public-key decryptors\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Decryptor : public PK_CryptoSystem, public PrivateKeyAlgorithm\n-{\n-public:\n-\t//! decrypt a byte string, and return the length of plaintext\n-\t/*! \\pre size of plaintext == MaxPlaintextLength(ciphertextLength) bytes.\n-\t\t\\return the actual length of the plaintext, indication that decryption failed.\n-\t*/\n-\tvirtual DecodingResult Decrypt(RandomNumberGenerator &rng, \n-\t\tconst byte *ciphertext, size_t ciphertextLength, \n-\t\tbyte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;\n-\n-\t//! create a new decryption filter\n-\t/*! \\note caller is responsible for deleting the returned pointer\n-\t*/\n-\tvirtual BufferedTransformation * CreateDecryptionFilter(RandomNumberGenerator &rng, \n-\t\tBufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;\n-\n-\t//! decrypt a fixed size ciphertext\n-\tDecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *ciphertext, byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const\n-\t\t{return Decrypt(rng, ciphertext, FixedCiphertextLength(), plaintext, parameters);}\n-};\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-typedef PK_CryptoSystem PK_FixedLengthCryptoSystem;\n-typedef PK_Encryptor PK_FixedLengthEncryptor;\n-typedef PK_Decryptor PK_FixedLengthDecryptor;\n-#endif\n-\n-//! interface for public-key signers and verifiers\n-\n-/*! This class provides an interface common to signers and verifiers\n-\tfor querying scheme properties.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_SignatureScheme\n-{\n-public:\n-\t//! invalid key exception, may be thrown by any function in this class if the private or public key has a length that can't be used\n-\tclass CRYPTOPP_DLL InvalidKeyLength : public Exception\n-\t{\n-\tpublic:\n-\t\tInvalidKeyLength(const std::string &message) : Exception(OTHER_ERROR, message) {}\n-\t};\n-\n-\t//! key too short exception, may be thrown by any function in this class if the private or public key is too short to sign or verify anything\n-\tclass CRYPTOPP_DLL KeyTooShort : public InvalidKeyLength\n-\t{\n-\tpublic:\n-\t\tKeyTooShort() : InvalidKeyLength(\"PK_Signer: key too short for this signature scheme\") {}\n-\t};\n-\n-\tvirtual ~PK_SignatureScheme() {}\n-\n-\t//! signature length if it only depends on the key, otherwise 0\n-\tvirtual size_t SignatureLength() const =0;\n-\n-\t//! maximum signature length produced for a given length of recoverable message part\n-\tvirtual size_t MaxSignatureLength(size_t recoverablePartLength = 0) const {return SignatureLength();}\n-\n-\t//! length of longest message that can be recovered, or 0 if this signature scheme does not support message recovery\n-\tvirtual size_t MaxRecoverableLength() const =0;\n-\n-\t//! length of longest message that can be recovered from a signature of given length, or 0 if this signature scheme does not support message recovery\n-\tvirtual size_t MaxRecoverableLengthFromSignatureLength(size_t signatureLength) const =0;\n-\n-\t//! requires a random number generator to sign\n-\t/*! if this returns false, NullRNG() can be passed to functions that take RandomNumberGenerator & */\n-\tvirtual bool IsProbabilistic() const =0;\n-\n-\t//! whether or not a non-recoverable message part can be signed\n-\tvirtual bool AllowNonrecoverablePart() const =0;\n-\n-\t//! if this function returns true, during verification you must input the signature before the message, otherwise you can input it at anytime */\n-\tvirtual bool SignatureUpfront() const {return false;}\n-\n-\t//! whether you must input the recoverable part before the non-recoverable part during signing\n-\tvirtual bool RecoverablePartFirst() const =0;\n-};\n-\n-//! interface for accumulating messages to be signed or verified\n-/*! Only Update() should be called\n-\ton this class. No other functions inherited from HashTransformation should be called.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_MessageAccumulator : public HashTransformation\n-{\n-public:\n-\t//! should not be called on PK_MessageAccumulator\n-\tunsigned int DigestSize() const\n-\t\t{throw NotImplemented(\"PK_MessageAccumulator: DigestSize() should not be called\");}\n-\t//! should not be called on PK_MessageAccumulator\n-\tvoid TruncatedFinal(byte *digest, size_t digestSize) \n-\t\t{throw NotImplemented(\"PK_MessageAccumulator: TruncatedFinal() should not be called\");}\n-};\n-\n-//! interface for public-key signers\n-\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Signer : public PK_SignatureScheme, public PrivateKeyAlgorithm\n-{\n-public:\n-\t//! create a new HashTransformation to accumulate the message to be signed\n-\tvirtual PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng) const =0;\n-\n-\tvirtual void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const =0;\n-\n-\t//! sign and delete messageAccumulator (even in case of exception thrown)\n-\t/*! \\pre size of signature == MaxSignatureLength()\n-\t\t\\return actual signature length\n-\t*/\n-\tvirtual size_t Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const;\n-\n-\t//! sign and restart messageAccumulator\n-\t/*! \\pre size of signature == MaxSignatureLength()\n-\t\t\\return actual signature length\n-\t*/\n-\tvirtual size_t SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const =0;\n-\n-\t//! sign a message\n-\t/*! \\pre size of signature == MaxSignatureLength()\n-\t\t\\return actual signature length\n-\t*/\n-\tvirtual size_t SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const;\n-\n-\t//! sign a recoverable message\n-\t/*! \\pre size of signature == MaxSignatureLength(recoverableMessageLength)\n-\t\t\\return actual signature length\n-\t*/\n-\tvirtual size_t SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, size_t recoverableMessageLength, \n-\t\tconst byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, byte *signature) const;\n-};\n-\n-//! interface for public-key signature verifiers\n-/*! The Recover* functions throw NotImplemented if the signature scheme does not support\n-\tmessage recovery.\n-\tThe Verify* functions throw InvalidDataFormat if the scheme does support message\n-\trecovery and the signature contains a non-empty recoverable message part. The\n-\tRecovery* functions should be used in that case.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Verifier : public PK_SignatureScheme, public PublicKeyAlgorithm\n-{\n-public:\n-\t//! create a new HashTransformation to accumulate the message to be verified\n-\tvirtual PK_MessageAccumulator * NewVerificationAccumulator() const =0;\n-\n-\t//! input signature into a message accumulator\n-\tvirtual void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const =0;\n-\n-\t//! check whether messageAccumulator contains a valid signature and message, and delete messageAccumulator (even in case of exception thrown)\n-\tvirtual bool Verify(PK_MessageAccumulator *messageAccumulator) const;\n-\n-\t//! check whether messageAccumulator contains a valid signature and message, and restart messageAccumulator\n-\tvirtual bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const =0;\n-\n-\t//! check whether input signature is a valid signature for input message\n-\tvirtual bool VerifyMessage(const byte *message, size_t messageLen, \n-\t\tconst byte *signature, size_t signatureLength) const;\n-\n-\t//! recover a message from its signature\n-\t/*! \\pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)\n-\t*/\n-\tvirtual DecodingResult Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const;\n-\n-\t//! recover a message from its signature\n-\t/*! \\pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)\n-\t*/\n-\tvirtual DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const =0;\n-\n-\t//! recover a message from its signature\n-\t/*! \\pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)\n-\t*/\n-\tvirtual DecodingResult RecoverMessage(byte *recoveredMessage, \n-\t\tconst byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, \n-\t\tconst byte *signature, size_t signatureLength) const;\n-};\n-\n-//! interface for domains of simple key agreement protocols\n-\n-/*! A key agreement domain is a set of parameters that must be shared\n-\tby two parties in a key agreement protocol, along with the algorithms\n-\tfor generating key pairs and deriving agreed values.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyAgreementDomain : public KeyAgreementAlgorithm\n-{\n-public:\n-\t//! return length of agreed value produced\n-\tvirtual unsigned int AgreedValueLength() const =0;\n-\t//! return length of private keys in this domain\n-\tvirtual unsigned int PrivateKeyLength() const =0;\n-\t//! return length of public keys in this domain\n-\tvirtual unsigned int PublicKeyLength() const =0;\n-\t//! generate private key\n-\t/*! \\pre size of privateKey == PrivateKeyLength() */\n-\tvirtual void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;\n-\t//! generate public key\n-\t/*!\t\\pre size of publicKey == PublicKeyLength() */\n-\tvirtual void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;\n-\t//! generate private/public key pair\n-\t/*! \\note equivalent to calling GeneratePrivateKey() and then GeneratePublicKey() */\n-\tvirtual void GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;\n-\t//! derive agreed value from your private key and couterparty's public key, return false in case of failure\n-\t/*! \\note If you have previously validated the public key, use validateOtherPublicKey=false to save time.\n-\t\t\\pre size of agreedValue == AgreedValueLength()\n-\t\t\\pre length of privateKey == PrivateKeyLength()\n-\t\t\\pre length of otherPublicKey == PublicKeyLength()\n-\t*/\n-\tvirtual bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const =0;\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\tbool ValidateDomainParameters(RandomNumberGenerator &rng) const\n-\t\t{return GetCryptoParameters().Validate(rng, 2);}\n-#endif\n-};\n-\n-//! interface for domains of authenticated key agreement protocols\n-\n-/*! In an authenticated key agreement protocol, each party has two\n-\tkey pairs. The long-lived key pair is called the static key pair,\n-\tand the short-lived key pair is called the ephemeral key pair.\n-*/\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm\n-{\n-public:\n-\t//! return length of agreed value produced\n-\tvirtual unsigned int AgreedValueLength() const =0;\n-\n-\t//! return length of static private keys in this domain\n-\tvirtual unsigned int StaticPrivateKeyLength() const =0;\n-\t//! return length of static public keys in this domain\n-\tvirtual unsigned int StaticPublicKeyLength() const =0;\n-\t//! generate static private key\n-\t/*! \\pre size of privateKey == PrivateStaticKeyLength() */\n-\tvirtual void GenerateStaticPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;\n-\t//! generate static public key\n-\t/*!\t\\pre size of publicKey == PublicStaticKeyLength() */\n-\tvirtual void GenerateStaticPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;\n-\t//! generate private/public key pair\n-\t/*! \\note equivalent to calling GenerateStaticPrivateKey() and then GenerateStaticPublicKey() */\n-\tvirtual void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;\n-\n-\t//! return length of ephemeral private keys in this domain\n-\tvirtual unsigned int EphemeralPrivateKeyLength() const =0;\n-\t//! return length of ephemeral public keys in this domain\n-\tvirtual unsigned int EphemeralPublicKeyLength() const =0;\n-\t//! generate ephemeral private key\n-\t/*! \\pre size of privateKey == PrivateEphemeralKeyLength() */\n-\tvirtual void GenerateEphemeralPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;\n-\t//! generate ephemeral public key\n-\t/*!\t\\pre size of publicKey == PublicEphemeralKeyLength() */\n-\tvirtual void GenerateEphemeralPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;\n-\t//! generate private/public key pair\n-\t/*! \\note equivalent to calling GenerateEphemeralPrivateKey() and then GenerateEphemeralPublicKey() */\n-\tvirtual void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;\n-\n-\t//! derive agreed value from your private keys and couterparty's public keys, return false in case of failure\n-\t/*! \\note The ephemeral public key will always be validated.\n-\t\t      If you have previously validated the static public key, use validateStaticOtherPublicKey=false to save time.\n-\t\t\\pre size of agreedValue == AgreedValueLength()\n-\t\t\\pre length of staticPrivateKey == StaticPrivateKeyLength()\n-\t\t\\pre length of ephemeralPrivateKey == EphemeralPrivateKeyLength()\n-\t\t\\pre length of staticOtherPublicKey == StaticPublicKeyLength()\n-\t\t\\pre length of ephemeralOtherPublicKey == EphemeralPublicKeyLength()\n-\t*/\n-\tvirtual bool Agree(byte *agreedValue,\n-\t\tconst byte *staticPrivateKey, const byte *ephemeralPrivateKey,\n-\t\tconst byte *staticOtherPublicKey, const byte *ephemeralOtherPublicKey,\n-\t\tbool validateStaticOtherPublicKey=true) const =0;\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-\tbool ValidateDomainParameters(RandomNumberGenerator &rng) const\n-\t\t{return GetCryptoParameters().Validate(rng, 2);}\n-#endif\n-};\n-\n-// interface for password authenticated key agreement protocols, not implemented yet\n-#if 0\n-//! interface for protocol sessions\n-/*! The methods should be called in the following order:\n-\n-\tInitializeSession(rng, parameters);\t// or call initialize method in derived class\n-\twhile (true)\n-\t{\n-\t\tif (OutgoingMessageAvailable())\n-\t\t{\n-\t\t\tlength = GetOutgoingMessageLength();\n-\t\t\tGetOutgoingMessage(message);\n-\t\t\t; // send outgoing message\n-\t\t}\n-\n-\t\tif (LastMessageProcessed())\n-\t\t\tbreak;\n-\n-\t\t; // receive incoming message\n-\t\tProcessIncomingMessage(message);\n-\t}\n-\t; // call methods in derived class to obtain result of protocol session\n-*/\n-class ProtocolSession\n-{\n-public:\n-\t//! exception thrown when an invalid protocol message is processed\n-\tclass ProtocolError : public Exception\n-\t{\n-\tpublic:\n-\t\tProtocolError(ErrorType errorType, const std::string &s) : Exception(errorType, s) {}\n-\t};\n-\n-\t//! exception thrown when a function is called unexpectedly\n-\t/*! for example calling ProcessIncomingMessage() when ProcessedLastMessage() == true */\n-\tclass UnexpectedMethodCall : public Exception\n-\t{\n-\tpublic:\n-\t\tUnexpectedMethodCall(const std::string &s) : Exception(OTHER_ERROR, s) {}\n-\t};\n-\n-\tProtocolSession() : m_rng(NULL), m_throwOnProtocolError(true), m_validState(false) {}\n-\tvirtual ~ProtocolSession() {}\n-\n-\tvirtual void InitializeSession(RandomNumberGenerator &rng, const NameValuePairs &parameters) =0;\n-\n-\tbool GetThrowOnProtocolError() const {return m_throwOnProtocolError;}\n-\tvoid SetThrowOnProtocolError(bool throwOnProtocolError) {m_throwOnProtocolError = throwOnProtocolError;}\n-\n-\tbool HasValidState() const {return m_validState;}\n-\n-\tvirtual bool OutgoingMessageAvailable() const =0;\n-\tvirtual unsigned int GetOutgoingMessageLength() const =0;\n-\tvirtual void GetOutgoingMessage(byte *message) =0;\n-\n-\tvirtual bool LastMessageProcessed() const =0;\n-\tvirtual void ProcessIncomingMessage(const byte *message, unsigned int messageLength) =0;\n-\n-protected:\n-\tvoid HandleProtocolError(Exception::ErrorType errorType, const std::string &s) const;\n-\tvoid CheckAndHandleInvalidState() const;\n-\tvoid SetValidState(bool valid) {m_validState = valid;}\n-\n-\tRandomNumberGenerator *m_rng;\n-\n-private:\n-\tbool m_throwOnProtocolError, m_validState;\n-};\n-\n-class KeyAgreementSession : public ProtocolSession\n-{\n-public:\n-\tvirtual unsigned int GetAgreedValueLength() const =0;\n-\tvirtual void GetAgreedValue(byte *agreedValue) const =0;\n-};\n-\n-class PasswordAuthenticatedKeyAgreementSession : public KeyAgreementSession\n-{\n-public:\n-\tvoid InitializePasswordAuthenticatedKeyAgreementSession(RandomNumberGenerator &rng, \n-\t\tconst byte *myId, unsigned int myIdLength, \n-\t\tconst byte *counterPartyId, unsigned int counterPartyIdLength, \n-\t\tconst byte *passwordOrVerifier, unsigned int passwordOrVerifierLength);\n-};\n-\n-class PasswordAuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm\n-{\n-public:\n-\t//! return whether the domain parameters stored in this object are valid\n-\tvirtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const\n-\t\t{return GetCryptoParameters().Validate(rng, 2);}\n-\n-\tvirtual unsigned int GetPasswordVerifierLength(const byte *password, unsigned int passwordLength) const =0;\n-\tvirtual void GeneratePasswordVerifier(RandomNumberGenerator &rng, const byte *userId, unsigned int userIdLength, const byte *password, unsigned int passwordLength, byte *verifier) const =0;\n-\n-\tenum RoleFlags {CLIENT=1, SERVER=2, INITIATOR=4, RESPONDER=8};\n-\n-\tvirtual bool IsValidRole(unsigned int role) =0;\n-\tvirtual PasswordAuthenticatedKeyAgreementSession * CreateProtocolSession(unsigned int role) const =0;\n-};\n-#endif\n-\n-//! BER Decode Exception Class, may be thrown during an ASN1 BER decode operation\n-class CRYPTOPP_DLL BERDecodeErr : public InvalidArgument\n-{\n-public: \n-\tBERDecodeErr() : InvalidArgument(\"BER decode error\") {}\n-\tBERDecodeErr(const std::string &s) : InvalidArgument(s) {}\n-};\n-\n-//! interface for encoding and decoding ASN1 objects\n-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE ASN1Object\n-{\n-public:\n-\tvirtual ~ASN1Object() {}\n-\t//! decode this object from a BufferedTransformation, using BER (Basic Encoding Rules)\n-\tvirtual void BERDecode(BufferedTransformation &bt) =0;\n-\t//! encode this object into a BufferedTransformation, using DER (Distinguished Encoding Rules)\n-\tvirtual void DEREncode(BufferedTransformation &bt) const =0;\n-\t//! encode this object into a BufferedTransformation, using BER\n-\t/*! this may be useful if DEREncode() would be too inefficient */\n-\tvirtual void BEREncode(BufferedTransformation &bt) const {DEREncode(bt);}\n-};\n-\n-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY\n-typedef PK_SignatureScheme PK_SignatureSystem;\n-typedef SimpleKeyAgreementDomain PK_SimpleKeyAgreementDomain;\n-typedef AuthenticatedKeyAgreementDomain PK_AuthenticatedKeyAgreementDomain;\n-#endif\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "2f5895e2d3ed8d1604653ef7c6d96c6ccaac790e",
        "filename": "src/cryptopp/iterhash.h",
        "status": "removed",
        "additions": 0,
        "deletions": 29,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/iterhash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/iterhash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/iterhash.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,29 +0,0 @@\n-#ifndef CRYPTOPP_ITERHASH_H\n-#define CRYPTOPP_ITERHASH_H\n-\n-#include \"secblock.h\"\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-// *** trimmed down dependency from iterhash.h ***\n-template <class T_HashWordType, class T_Endianness, unsigned int T_BlockSize, unsigned int T_StateSize, class T_Transform, unsigned int T_DigestSize = 0, bool T_StateAligned = false>\n-class CRYPTOPP_NO_VTABLE IteratedHashWithStaticTransform\n-{\n-public:\n-\tCRYPTOPP_CONSTANT(DIGESTSIZE = T_DigestSize ? T_DigestSize : T_StateSize)\n-\tunsigned int DigestSize() const {return DIGESTSIZE;};\n-    typedef T_HashWordType HashWordType;\n-    CRYPTOPP_CONSTANT(BLOCKSIZE = T_BlockSize)\n-\n-protected:\n-\tIteratedHashWithStaticTransform() {this->Init();}\n-\tvoid HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}\n-\tvoid Init() {T_Transform::InitState(this->m_state);}\n-\n-\tT_HashWordType* StateBuf() {return this->m_state;}\n-\tFixedSizeAlignedSecBlock<T_HashWordType, T_BlockSize/sizeof(T_HashWordType), T_StateAligned> m_state;\n-};\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "de8037bf619d6aff87a35d9ae8237f5a78be09c9",
        "filename": "src/cryptopp/misc.h",
        "status": "removed",
        "additions": 0,
        "deletions": 1134,
        "changes": 1134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/misc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/misc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/misc.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,1134 +0,0 @@\n-#ifndef CRYPTOPP_MISC_H\n-#define CRYPTOPP_MISC_H\n-\n-#include \"cryptlib.h\"\n-#include \"smartptr.h\"\n-#include <string.h>\t\t// for memcpy and memmove\n-\n-#ifdef _MSC_VER\n-\t#include <stdlib.h>\n-\t#if _MSC_VER >= 1400\n-\t\t// VC2005 workaround: disable declarations that conflict with winnt.h\n-\t\t#define _interlockedbittestandset CRYPTOPP_DISABLED_INTRINSIC_1\n-\t\t#define _interlockedbittestandreset CRYPTOPP_DISABLED_INTRINSIC_2\n-\t\t#define _interlockedbittestandset64 CRYPTOPP_DISABLED_INTRINSIC_3\n-\t\t#define _interlockedbittestandreset64 CRYPTOPP_DISABLED_INTRINSIC_4\n-\t\t#include <intrin.h>\n-\t\t#undef _interlockedbittestandset\n-\t\t#undef _interlockedbittestandreset\n-\t\t#undef _interlockedbittestandset64\n-\t\t#undef _interlockedbittestandreset64\n-\t\t#define CRYPTOPP_FAST_ROTATE(x) 1\n-\t#elif _MSC_VER >= 1300\n-\t\t#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32 | (x) == 64)\n-\t#else\n-\t\t#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)\n-\t#endif\n-#elif (defined(__MWERKS__) && TARGET_CPU_PPC) || \\\n-\t(defined(__GNUC__) && (defined(_ARCH_PWR2) || defined(_ARCH_PWR) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || defined(_ARCH_COM)))\n-\t#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)\n-#elif defined(__GNUC__) && (CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86)\t// depend on GCC's peephole optimization to generate rotate instructions\n-\t#define CRYPTOPP_FAST_ROTATE(x) 1\n-#else\n-\t#define CRYPTOPP_FAST_ROTATE(x) 0\n-#endif\n-\n-#ifdef __BORLANDC__\n-#include <mem.h>\n-#endif\n-\n-#if defined(__GNUC__) && defined(__linux__)\n-#define CRYPTOPP_BYTESWAP_AVAILABLE\n-#include <byteswap.h>\n-#endif\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-// ************** compile-time assertion ***************\n-\n-template <bool b>\n-struct CompileAssert\n-{\n-\tstatic char dummy[2*b-1];\n-};\n-\n-#define CRYPTOPP_COMPILE_ASSERT(assertion) CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)\n-#if defined(CRYPTOPP_EXPORTS) || defined(CRYPTOPP_IMPORTS)\n-#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance)\n-#else\n-#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance) static CompileAssert<(assertion)> CRYPTOPP_ASSERT_JOIN(cryptopp_assert_, instance)\n-#endif\n-#define CRYPTOPP_ASSERT_JOIN(X, Y) CRYPTOPP_DO_ASSERT_JOIN(X, Y)\n-#define CRYPTOPP_DO_ASSERT_JOIN(X, Y) X##Y\n-\n-// ************** misc classes ***************\n-\n-class CRYPTOPP_DLL Empty\n-{\n-};\n-\n-//! _\n-template <class BASE1, class BASE2>\n-class CRYPTOPP_NO_VTABLE TwoBases : public BASE1, public BASE2\n-{\n-};\n-\n-//! _\n-template <class BASE1, class BASE2, class BASE3>\n-class CRYPTOPP_NO_VTABLE ThreeBases : public BASE1, public BASE2, public BASE3\n-{\n-};\n-\n-template <class T>\n-class ObjectHolder\n-{\n-protected:\n-\tT m_object;\n-};\n-\n-class NotCopyable\n-{\n-public:\n-\tNotCopyable() {}\n-private:\n-    NotCopyable(const NotCopyable &);\n-    void operator=(const NotCopyable &);\n-};\n-\n-template <class T>\n-struct NewObject\n-{\n-\tT* operator()() const {return new T;}\n-};\n-\n-/*! This function safely initializes a static object in a multithreaded environment without using locks.\n-\tIt may leak memory when two threads try to initialize the static object at the same time\n-\tbut this should be acceptable since each static object is only initialized once per session.\n-*/\n-template <class T, class F = NewObject<T>, int instance=0>\n-class Singleton\n-{\n-public:\n-\tSingleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}\n-\n-\t// prevent this function from being inlined\n-\tCRYPTOPP_NOINLINE const T & Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const;\n-\n-private:\n-\tF m_objectFactory;\n-};\n-\n-template <class T, class F, int instance>\n-const T & Singleton<T, F, instance>::Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const\n-{\n-\tstatic simple_ptr<T> s_pObject;\n-\tstatic char s_objectState = 0;\n-\n-retry:\n-\tswitch (s_objectState)\n-\t{\n-\tcase 0:\n-\t\ts_objectState = 1;\n-\t\ttry\n-\t\t{\n-\t\t\ts_pObject.m_p = m_objectFactory();\n-\t\t}\n-\t\tcatch(...)\n-\t\t{\n-\t\t\ts_objectState = 0;\n-\t\t\tthrow;\n-\t\t}\n-\t\ts_objectState = 2;\n-\t\tbreak;\n-\tcase 1:\n-\t\tgoto retry;\n-\tdefault:\n-\t\tbreak;\n-\t}\n-\treturn *s_pObject.m_p;\n-}\n-\n-// ************** misc functions ***************\n-\n-#if (!__STDC_WANT_SECURE_LIB__)\n-inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n-{\n-\tif (count > sizeInBytes)\n-\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n-\tmemcpy(dest, src, count);\n-}\n-\n-inline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n-{\n-\tif (count > sizeInBytes)\n-\t\tthrow InvalidArgument(\"memmove_s: buffer overflow\");\n-\tmemmove(dest, src, count);\n-}\n-#endif\n-\n-inline void * memset_z(void *ptr, int value, size_t num)\n-{\n-// avoid extranous warning on GCC 4.3.2 Ubuntu 8.10\n-#if CRYPTOPP_GCC_VERSION >= 30001\n-\tif (__builtin_constant_p(num) && num==0)\n-\t\treturn ptr;\n-#endif\n-\treturn memset(ptr, value, num);\n-}\n-\n-// can't use std::min or std::max in MSVC60 or Cygwin 1.1.0\n-template <class T> inline const T& STDMIN(const T& a, const T& b)\n-{\n-\treturn b < a ? b : a;\n-}\n-\n-template <class T1, class T2> inline const T1 UnsignedMin(const T1& a, const T2& b)\n-{\n-\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n-\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n-\tassert(b>=0);\n-\n-\tif (sizeof(T1)<=sizeof(T2))\n-\t\treturn b < (T2)a ? (T1)b : a;\n-\telse\n-\t\treturn (T1)b < a ? (T1)b : a;\n-}\n-\n-template <class T> inline const T& STDMAX(const T& a, const T& b)\n-{\n-\treturn a < b ? b : a;\n-}\n-\n-#define RETURN_IF_NONZERO(x) size_t returnedValue = x; if (returnedValue) return returnedValue\n-\n-// this version of the macro is fastest on Pentium 3 and Pentium 4 with MSVC 6 SP5 w/ Processor Pack\n-#define GETBYTE(x, y) (unsigned int)byte((x)>>(8*(y)))\n-// these may be faster on other CPUs/compilers\n-// #define GETBYTE(x, y) (unsigned int)(((x)>>(8*(y)))&255)\n-// #define GETBYTE(x, y) (((byte *)&(x))[y])\n-\n-#define CRYPTOPP_GET_BYTE_AS_BYTE(x, y) byte((x)>>(8*(y)))\n-\n-template <class T>\n-unsigned int Parity(T value)\n-{\n-\tfor (unsigned int i=8*sizeof(value)/2; i>0; i/=2)\n-\t\tvalue ^= value >> i;\n-\treturn (unsigned int)value&1;\n-}\n-\n-template <class T>\n-unsigned int BytePrecision(const T &value)\n-{\n-\tif (!value)\n-\t\treturn 0;\n-\n-\tunsigned int l=0, h=8*sizeof(value);\n-\n-\twhile (h-l > 8)\n-\t{\n-\t\tunsigned int t = (l+h)/2;\n-\t\tif (value >> t)\n-\t\t\tl = t;\n-\t\telse\n-\t\t\th = t;\n-\t}\n-\n-\treturn h/8;\n-}\n-\n-template <class T>\n-unsigned int BitPrecision(const T &value)\n-{\n-\tif (!value)\n-\t\treturn 0;\n-\n-\tunsigned int l=0, h=8*sizeof(value);\n-\n-\twhile (h-l > 1)\n-\t{\n-\t\tunsigned int t = (l+h)/2;\n-\t\tif (value >> t)\n-\t\t\tl = t;\n-\t\telse\n-\t\t\th = t;\n-\t}\n-\n-\treturn h;\n-}\n-\n-template <class T>\n-inline T Crop(T value, size_t size)\n-{\n-\tif (size < 8*sizeof(value))\n-    \treturn T(value & ((T(1) << size) - 1));\n-\telse\n-\t\treturn value;\n-}\n-\n-template <class T1, class T2>\n-inline bool SafeConvert(T1 from, T2 &to)\n-{\n-\tto = (T2)from;\n-\tif (from != to || (from > 0) != (to > 0))\n-\t\treturn false;\n-\treturn true;\n-}\n-\n-inline size_t BitsToBytes(size_t bitCount)\n-{\n-\treturn ((bitCount+7)/(8));\n-}\n-\n-inline size_t BytesToWords(size_t byteCount)\n-{\n-\treturn ((byteCount+WORD_SIZE-1)/WORD_SIZE);\n-}\n-\n-inline size_t BitsToWords(size_t bitCount)\n-{\n-\treturn ((bitCount+WORD_BITS-1)/(WORD_BITS));\n-}\n-\n-inline size_t BitsToDwords(size_t bitCount)\n-{\n-\treturn ((bitCount+2*WORD_BITS-1)/(2*WORD_BITS));\n-}\n-\n-CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *buf, const byte *mask, size_t count);\n-CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *output, const byte *input, const byte *mask, size_t count);\n-\n-CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual(const byte *buf1, const byte *buf2, size_t count);\n-\n-template <class T>\n-inline bool IsPowerOf2(const T &n)\n-{\n-\treturn n > 0 && (n & (n-1)) == 0;\n-}\n-\n-template <class T1, class T2>\n-inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n-{\n-\tassert(IsPowerOf2(b));\n-\treturn T2(a) & (b-1);\n-}\n-\n-template <class T1, class T2>\n-inline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)\n-{\n-\tif (IsPowerOf2(m))\n-\t\treturn n - ModPowerOf2(n, m);\n-\telse\n-\t\treturn n - n%m;\n-}\n-\n-template <class T1, class T2>\n-inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n-{\n-\tif (n+m-1 < n)\n-\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n-\treturn RoundDownToMultipleOf(n+m-1, m);\n-}\n-\n-template <class T>\n-inline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n-{\n-#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-\tif (sizeof(T) < 16)\n-\t\treturn 1;\n-#endif\n-\n-#if (_MSC_VER >= 1300)\n-\treturn __alignof(T);\n-#elif defined(__GNUC__)\n-\treturn __alignof__(T);\n-#elif CRYPTOPP_BOOL_SLOW_WORD64\n-\treturn UnsignedMin(4U, sizeof(T));\n-#else\n-\treturn sizeof(T);\n-#endif\n-}\n-\n-inline bool IsAlignedOn(const void *p, unsigned int alignment)\n-{\n-\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n-}\n-\n-template <class T>\n-inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n-{\n-\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n-}\n-\n-#ifdef IS_LITTLE_ENDIAN\n-\ttypedef LittleEndian NativeByteOrder;\n-#else\n-\ttypedef BigEndian NativeByteOrder;\n-#endif\n-\n-inline ByteOrder GetNativeByteOrder()\n-{\n-\treturn NativeByteOrder::ToEnum();\n-}\n-\n-inline bool NativeByteOrderIs(ByteOrder order)\n-{\n-\treturn order == GetNativeByteOrder();\n-}\n-\n-template <class T>\n-std::string IntToString(T a, unsigned int base = 10)\n-{\n-\tif (a == 0)\n-\t\treturn \"0\";\n-\tbool negate = false;\n-\tif (a < 0)\n-\t{\n-\t\tnegate = true;\n-\t\ta = 0-a;\t// VC .NET does not like -a\n-\t}\n-\tstd::string result;\n-\twhile (a > 0)\n-\t{\n-\t\tT digit = a % base;\n-\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n-\t\ta /= base;\n-\t}\n-\tif (negate)\n-\t\tresult = \"-\" + result;\n-\treturn result;\n-}\n-\n-template <class T1, class T2>\n-inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n-{\n-\treturn T1((a > b) ? (a - b) : 0);\n-}\n-\n-template <class T>\n-inline CipherDir GetCipherDir(const T &obj)\n-{\n-\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n-}\n-\n-CRYPTOPP_DLL void CRYPTOPP_API CallNewHandler();\n-\n-inline void IncrementCounterByOne(byte *inout, unsigned int s)\n-{\n-\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n-\t\tcarry = !++inout[i];\n-}\n-\n-inline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)\n-{\n-\tint i, carry;\n-\tfor (i=s-1, carry=1; i>=0 && carry; i--)\n-\t\tcarry = ((output[i] = input[i]+1) == 0);\n-\tmemcpy_s(output, s, input, i+1);\n-}\n-\n-// ************** rotate functions ***************\n-\n-template <class T> inline T rotlFixed(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotrFixed(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotlVariable(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotrVariable(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotlMod(T x, unsigned int y)\n-{\n-\ty %= sizeof(T)*8;\n-\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotrMod(T x, unsigned int y)\n-{\n-\ty %= sizeof(T)*8;\n-\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n-}\n-\n-#ifdef _MSC_VER\n-\n-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _lrotl(x, y) : x;\n-}\n-\n-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _lrotr(x, y) : x;\n-}\n-\n-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _lrotl(x, y);\n-}\n-\n-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _lrotr(x, y);\n-}\n-\n-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)\n-{\n-\treturn _lrotl(x, y);\n-}\n-\n-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)\n-{\n-\treturn _lrotr(x, y);\n-}\n-\n-#endif // #ifdef _MSC_VER\n-\n-#if _MSC_VER >= 1300 && !defined(__INTEL_COMPILER)\n-// Intel C++ Compiler 10.0 calls a function instead of using the rotate instruction when using these instructions\n-\n-template<> inline word64 rotlFixed<word64>(word64 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotl64(x, y) : x;\n-}\n-\n-template<> inline word64 rotrFixed<word64>(word64 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotr64(x, y) : x;\n-}\n-\n-template<> inline word64 rotlVariable<word64>(word64 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotl64(x, y);\n-}\n-\n-template<> inline word64 rotrVariable<word64>(word64 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotr64(x, y);\n-}\n-\n-template<> inline word64 rotlMod<word64>(word64 x, unsigned int y)\n-{\n-\treturn _rotl64(x, y);\n-}\n-\n-template<> inline word64 rotrMod<word64>(word64 x, unsigned int y)\n-{\n-\treturn _rotr64(x, y);\n-}\n-\n-#endif // #if _MSC_VER >= 1310\n-\n-#if _MSC_VER >= 1400 && !defined(__INTEL_COMPILER)\n-// Intel C++ Compiler 10.0 gives undefined externals with these\n-\n-template<> inline word16 rotlFixed<word16>(word16 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotl16(x, y) : x;\n-}\n-\n-template<> inline word16 rotrFixed<word16>(word16 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotr16(x, y) : x;\n-}\n-\n-template<> inline word16 rotlVariable<word16>(word16 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotl16(x, y);\n-}\n-\n-template<> inline word16 rotrVariable<word16>(word16 x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotr16(x, y);\n-}\n-\n-template<> inline word16 rotlMod<word16>(word16 x, unsigned int y)\n-{\n-\treturn _rotl16(x, y);\n-}\n-\n-template<> inline word16 rotrMod<word16>(word16 x, unsigned int y)\n-{\n-\treturn _rotr16(x, y);\n-}\n-\n-template<> inline byte rotlFixed<byte>(byte x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotl8(x, y) : x;\n-}\n-\n-template<> inline byte rotrFixed<byte>(byte x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn y ? _rotr8(x, y) : x;\n-}\n-\n-template<> inline byte rotlVariable<byte>(byte x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotl8(x, y);\n-}\n-\n-template<> inline byte rotrVariable<byte>(byte x, unsigned int y)\n-{\n-\tassert(y < 8*sizeof(x));\n-\treturn _rotr8(x, y);\n-}\n-\n-template<> inline byte rotlMod<byte>(byte x, unsigned int y)\n-{\n-\treturn _rotl8(x, y);\n-}\n-\n-template<> inline byte rotrMod<byte>(byte x, unsigned int y)\n-{\n-\treturn _rotr8(x, y);\n-}\n-\n-#endif // #if _MSC_VER >= 1400\n-\n-#if (defined(__MWERKS__) && TARGET_CPU_PPC)\n-\n-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 32);\n-\treturn y ? __rlwinm(x,y,0,31) : x;\n-}\n-\n-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 32);\n-\treturn y ? __rlwinm(x,32-y,0,31) : x;\n-}\n-\n-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 32);\n-\treturn (__rlwnm(x,y,0,31));\n-}\n-\n-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)\n-{\n-\tassert(y < 32);\n-\treturn (__rlwnm(x,32-y,0,31));\n-}\n-\n-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)\n-{\n-\treturn (__rlwnm(x,y,0,31));\n-}\n-\n-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)\n-{\n-\treturn (__rlwnm(x,32-y,0,31));\n-}\n-\n-#endif // #if (defined(__MWERKS__) && TARGET_CPU_PPC)\n-\n-// ************** endian reversal ***************\n-\n-template <class T>\n-inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)\n-{\n-\tif (order == LITTLE_ENDIAN_ORDER)\n-\t\treturn GETBYTE(value, index);\n-\telse\n-\t\treturn GETBYTE(value, sizeof(T)-index-1);\n-}\n-\n-inline byte ByteReverse(byte value)\n-{\n-\treturn value;\n-}\n-\n-inline word16 ByteReverse(word16 value)\n-{\n-#ifdef CRYPTOPP_BYTESWAP_AVAILABLE\n-\treturn bswap_16(value);\n-#elif defined(_MSC_VER) && _MSC_VER >= 1300\n-\treturn _byteswap_ushort(value);\n-#else\n-\treturn rotlFixed(value, 8U);\n-#endif\n-}\n-\n-inline word32 ByteReverse(word32 value)\n-{\n-#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE)\n-\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n-\treturn value;\n-#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n-\treturn bswap_32(value);\n-#elif defined(__MWERKS__) && TARGET_CPU_PPC\n-\treturn (word32)__lwbrx(&value,0);\n-#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))\n-\treturn _byteswap_ulong(value);\n-#elif CRYPTOPP_FAST_ROTATE(32)\n-\t// 5 instructions with rotate instruction, 9 without\n-\treturn (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);\n-#else\n-\t// 6 instructions with rotate instruction, 8 without\n-\tvalue = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n-\treturn rotlFixed(value, 16U);\n-#endif\n-}\n-\n-inline word64 ByteReverse(word64 value)\n-{\n-#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n-\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n-\treturn value;\n-#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n-\treturn bswap_64(value);\n-#elif defined(_MSC_VER) && _MSC_VER >= 1300\n-\treturn _byteswap_uint64(value);\n-#elif CRYPTOPP_BOOL_SLOW_WORD64\n-\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n-#else\n-\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n-\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n-\treturn rotlFixed(value, 32U);\n-#endif\n-}\n-\n-inline byte BitReverse(byte value)\n-{\n-\tvalue = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n-\tvalue = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n-\treturn rotlFixed(value, 4U);\n-}\n-\n-inline word16 BitReverse(word16 value)\n-{\n-\tvalue = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);\n-\tvalue = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);\n-\tvalue = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);\n-\treturn ByteReverse(value);\n-}\n-\n-inline word32 BitReverse(word32 value)\n-{\n-\tvalue = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);\n-\tvalue = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);\n-\tvalue = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);\n-\treturn ByteReverse(value);\n-}\n-\n-inline word64 BitReverse(word64 value)\n-{\n-#if CRYPTOPP_BOOL_SLOW_WORD64\n-\treturn (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));\n-#else\n-\tvalue = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);\n-\tvalue = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);\n-\tvalue = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);\n-\treturn ByteReverse(value);\n-#endif\n-}\n-\n-template <class T>\n-inline T BitReverse(T value)\n-{\n-\tif (sizeof(T) == 1)\n-\t\treturn (T)BitReverse((byte)value);\n-\telse if (sizeof(T) == 2)\n-\t\treturn (T)BitReverse((word16)value);\n-\telse if (sizeof(T) == 4)\n-\t\treturn (T)BitReverse((word32)value);\n-\telse\n-\t{\n-\t\tassert(sizeof(T) == 8);\n-\t\treturn (T)BitReverse((word64)value);\n-\t}\n-}\n-\n-template <class T>\n-inline T ConditionalByteReverse(ByteOrder order, T value)\n-{\n-\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n-}\n-\n-template <class T>\n-void ByteReverse(T *out, const T *in, size_t byteCount)\n-{\n-\tassert(byteCount % sizeof(T) == 0);\n-\tsize_t count = byteCount/sizeof(T);\n-\tfor (size_t i=0; i<count; i++)\n-\t\tout[i] = ByteReverse(in[i]);\n-}\n-\n-template <class T>\n-inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n-{\n-\tif (!NativeByteOrderIs(order))\n-\t\tByteReverse(out, in, byteCount);\n-\telse if (in != out)\n-\t\tmemcpy_s(out, byteCount, in, byteCount);\n-}\n-\n-template <class T>\n-inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n-{\n-\tconst size_t U = sizeof(T);\n-\tassert(inlen <= outlen*U);\n-\tmemcpy_s(out, outlen*U, in, inlen);\n-\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n-\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n-}\n-\n-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-inline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const byte *)\n-{\n-\treturn block[0];\n-}\n-\n-inline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word16 *)\n-{\n-\treturn (order == BIG_ENDIAN_ORDER)\n-\t\t? block[1] | (block[0] << 8)\n-\t\t: block[0] | (block[1] << 8);\n-}\n-\n-inline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word32 *)\n-{\n-\treturn (order == BIG_ENDIAN_ORDER)\n-\t\t? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)\n-\t\t: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);\n-}\n-\n-inline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)\n-{\n-\treturn (order == BIG_ENDIAN_ORDER)\n-\t\t?\n-\t\t(word64(block[7]) |\n-\t\t(word64(block[6]) <<  8) |\n-\t\t(word64(block[5]) << 16) |\n-\t\t(word64(block[4]) << 24) |\n-\t\t(word64(block[3]) << 32) |\n-\t\t(word64(block[2]) << 40) |\n-\t\t(word64(block[1]) << 48) |\n-\t\t(word64(block[0]) << 56))\n-\t\t:\n-\t\t(word64(block[0]) |\n-\t\t(word64(block[1]) <<  8) |\n-\t\t(word64(block[2]) << 16) |\n-\t\t(word64(block[3]) << 24) |\n-\t\t(word64(block[4]) << 32) |\n-\t\t(word64(block[5]) << 40) |\n-\t\t(word64(block[6]) << 48) |\n-\t\t(word64(block[7]) << 56));\n-}\n-\n-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, byte value, const byte *xorBlock)\n-{\n-\tblock[0] = xorBlock ? (value ^ xorBlock[0]) : value;\n-}\n-\n-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word16 value, const byte *xorBlock)\n-{\n-\tif (order == BIG_ENDIAN_ORDER)\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t}\n-\telse\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t}\n-\t}\n-}\n-\n-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word32 value, const byte *xorBlock)\n-{\n-\tif (order == BIG_ENDIAN_ORDER)\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t}\n-\telse\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t}\n-\t}\n-}\n-\n-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)\n-{\n-\tif (order == BIG_ENDIAN_ORDER)\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n-\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n-\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n-\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n-\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n-\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n-\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t}\n-\t}\n-\telse\n-\t{\n-\t\tif (xorBlock)\n-\t\t{\n-\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n-\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n-\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n-\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n-\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n-\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n-\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n-\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n-\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n-\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n-\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n-\t\t}\n-\t}\n-}\n-#endif\t// #ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-\n-template <class T>\n-inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)\n-{\n-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-\tif (!assumeAligned)\n-\t\treturn UnalignedGetWordNonTemplate(order, block, (T*)NULL);\n-\tassert(IsAligned<T>(block));\n-#endif\n-\treturn ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));\n-}\n-\n-template <class T>\n-inline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)\n-{\n-\tresult = GetWord<T>(assumeAligned, order, block);\n-}\n-\n-template <class T>\n-inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n-{\n-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n-\tif (!assumeAligned)\n-\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n-\tassert(IsAligned<T>(block));\n-\tassert(IsAligned<T>(xorBlock));\n-#endif\n-\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n-}\n-\n-template <class T, class B, bool A=false>\n-class GetBlock\n-{\n-public:\n-\tGetBlock(const void *block)\n-\t\t: m_block((const byte *)block) {}\n-\n-\ttemplate <class U>\n-\tinline GetBlock<T, B, A> & operator()(U &x)\n-\t{\n-\t\tCRYPTOPP_COMPILE_ASSERT(sizeof(U) >= sizeof(T));\n-\t\tx = GetWord<T>(A, B::ToEnum(), m_block);\n-\t\tm_block += sizeof(T);\n-\t\treturn *this;\n-\t}\n-\n-private:\n-\tconst byte *m_block;\n-};\n-\n-template <class T, class B, bool A=false>\n-class PutBlock\n-{\n-public:\n-\tPutBlock(const void *xorBlock, void *block)\n-\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n-\n-\ttemplate <class U>\n-\tinline PutBlock<T, B, A> & operator()(U x)\n-\t{\n-\t\tPutWord(A, B::ToEnum(), m_block, (T)x, m_xorBlock);\n-\t\tm_block += sizeof(T);\n-\t\tif (m_xorBlock)\n-\t\t\tm_xorBlock += sizeof(T);\n-\t\treturn *this;\n-\t}\n-\n-private:\n-\tconst byte *m_xorBlock;\n-\tbyte *m_block;\n-};\n-\n-template <class T, class B, bool GA=false, bool PA=false>\n-struct BlockGetAndPut\n-{\n-\t// function needed because of C++ grammatical ambiguity between expression-statements and declarations\n-\tstatic inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n-\ttypedef PutBlock<T, B, PA> Put;\n-};\n-\n-template <class T>\n-std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n-{\n-\tif (!NativeByteOrderIs(order))\n-\t\tvalue = ByteReverse(value);\n-\n-\treturn std::string((char *)&value, sizeof(value));\n-}\n-\n-template <class T>\n-T StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)\n-{\n-\tT value = 0;\n-\tmemcpy_s(&value, sizeof(value), str.data(), UnsignedMin(str.size(), sizeof(value)));\n-\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n-}\n-\n-// ************** help remove warning on g++ ***************\n-\n-template <bool overflow> struct SafeShifter;\n-\n-template<> struct SafeShifter<true>\n-{\n-\ttemplate <class T>\n-\tstatic inline T RightShift(T value, unsigned int bits)\n-\t{\n-\t\treturn 0;\n-\t}\n-\n-\ttemplate <class T>\n-\tstatic inline T LeftShift(T value, unsigned int bits)\n-\t{\n-\t\treturn 0;\n-\t}\n-};\n-\n-template<> struct SafeShifter<false>\n-{\n-\ttemplate <class T>\n-\tstatic inline T RightShift(T value, unsigned int bits)\n-\t{\n-\t\treturn value >> bits;\n-\t}\n-\n-\ttemplate <class T>\n-\tstatic inline T LeftShift(T value, unsigned int bits)\n-\t{\n-\t\treturn value << bits;\n-\t}\n-};\n-\n-template <unsigned int bits, class T>\n-inline T SafeRightShift(T value)\n-{\n-\treturn SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);\n-}\n-\n-template <unsigned int bits, class T>\n-inline T SafeLeftShift(T value)\n-{\n-\treturn SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);\n-}\n-\n-// ************** use one buffer for multiple data members ***************\n-\n-#define CRYPTOPP_BLOCK_1(n, t, s) t* m_##n() {return (t *)(m_aggregate+0);}     size_t SS1() {return       sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_2(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS1());} size_t SS2() {return SS1()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_3(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS2());} size_t SS3() {return SS2()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_4(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS3());} size_t SS4() {return SS3()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_5(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS4());} size_t SS5() {return SS4()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_6(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS5());} size_t SS6() {return SS5()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_7(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS6());} size_t SS7() {return SS6()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCK_8(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS7());} size_t SS8() {return SS7()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}\n-#define CRYPTOPP_BLOCKS_END(i) size_t SST() {return SS##i();} void AllocateBlocks() {m_aggregate.New(SST());} AlignedSecByteBlock m_aggregate;\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "d6b7ef32c8478a48c3994dcadc86837f4371184d",
        "filename": "src/cryptopp/obj/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/obj/.gitignore?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,2 +0,0 @@\n-*\n-!.gitignore"
      },
      {
        "sha": "418c39076dfe90dd011eb0fcd819b458b7c0d840",
        "filename": "src/cryptopp/pch.h",
        "status": "removed",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/pch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/pch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/pch.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,21 +0,0 @@\n-#ifndef CRYPTOPP_PCH_H\n-#define CRYPTOPP_PCH_H\n-\n-#ifdef CRYPTOPP_GENERATE_X64_MASM\n-\n-\t#include \"cpu.h\"\n-\n-#else\n-\n-\t#include \"config.h\"\n-\n-\t#ifdef USE_PRECOMPILED_HEADERS\n-\t\t#include \"simple.h\"\n-\t\t#include \"secblock.h\"\n-\t\t#include \"misc.h\"\n-\t\t#include \"smartptr.h\"\n-\t#endif\n-\n-#endif\n-\n-#endif"
      },
      {
        "sha": "2025757dbb58ed2ffc2ea222fcd0cb18a4f88961",
        "filename": "src/cryptopp/secblock.h",
        "status": "removed",
        "additions": 0,
        "deletions": 501,
        "changes": 501,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/secblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/secblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/secblock.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,501 +0,0 @@\n-// secblock.h - written and placed in the public domain by Wei Dai\n-\n-#ifndef CRYPTOPP_SECBLOCK_H\n-#define CRYPTOPP_SECBLOCK_H\n-\n-#include \"config.h\"\n-#include \"misc.h\"\n-#include <assert.h>\n-\n-#if defined(CRYPTOPP_MEMALIGN_AVAILABLE) || defined(CRYPTOPP_MM_MALLOC_AVAILABLE) || defined(QNX)\n-\t#include <malloc.h>\n-#else\n-\t#include <stdlib.h>\n-#endif\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-// ************** secure memory allocation ***************\n-\n-template<class T>\n-class AllocatorBase\n-{\n-public:\n-\ttypedef T value_type;\n-\ttypedef size_t size_type;\n-#ifdef CRYPTOPP_MSVCRT6\n-\ttypedef ptrdiff_t difference_type;\n-#else\n-\ttypedef std::ptrdiff_t difference_type;\n-#endif\n-\ttypedef T * pointer;\n-\ttypedef const T * const_pointer;\n-\ttypedef T & reference;\n-\ttypedef const T & const_reference;\n-\n-\tpointer address(reference r) const {return (&r);}\n-\tconst_pointer address(const_reference r) const {return (&r); }\n-\tvoid construct(pointer p, const T& val) {new (p) T(val);}\n-\tvoid destroy(pointer p) {p->~T();}\n-\tsize_type max_size() const {return ~size_type(0)/sizeof(T);}\t// switch to std::numeric_limits<T>::max later\n-\n-protected:\n-\tstatic void CheckSize(size_t n)\n-\t{\n-\t\tif (n > ~size_t(0) / sizeof(T))\n-\t\t\tthrow InvalidArgument(\"AllocatorBase: requested size would cause integer overflow\");\n-\t}\n-};\n-\n-#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\n-typedef typename AllocatorBase<T>::value_type value_type;\\\n-typedef typename AllocatorBase<T>::size_type size_type;\\\n-typedef typename AllocatorBase<T>::difference_type difference_type;\\\n-typedef typename AllocatorBase<T>::pointer pointer;\\\n-typedef typename AllocatorBase<T>::const_pointer const_pointer;\\\n-typedef typename AllocatorBase<T>::reference reference;\\\n-typedef typename AllocatorBase<T>::const_reference const_reference;\n-\n-#if defined(_MSC_VER) && (_MSC_VER < 1300)\n-// this pragma causes an internal compiler error if placed immediately before std::swap(a, b)\n-#pragma warning(push)\n-#pragma warning(disable: 4700)\t// VC60 workaround: don't know how to get rid of this warning\n-#endif\n-\n-template <class T, class A>\n-typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)\n-{\n-\tif (oldSize == newSize)\n-\t\treturn p;\n-\n-\tif (preserve)\n-\t{\n-\t\ttypename A::pointer newPointer = a.allocate(newSize, NULL);\n-\t\tmemcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));\n-\t\ta.deallocate(p, oldSize);\n-\t\treturn newPointer;\n-\t}\n-\telse\n-\t{\n-\t\ta.deallocate(p, oldSize);\n-\t\treturn a.allocate(newSize, NULL);\n-\t}\n-}\n-\n-#if defined(_MSC_VER) && (_MSC_VER < 1300)\n-#pragma warning(pop)\n-#endif\n-\n-template <class T, bool T_Align16 = false>\n-class AllocatorWithCleanup : public AllocatorBase<T>\n-{\n-public:\n-\tCRYPTOPP_INHERIT_ALLOCATOR_TYPES\n-\n-\tpointer allocate(size_type n, const void * = NULL)\n-\t{\n-\t\tCheckSize(n);\n-\t\tif (n == 0)\n-\t\t\treturn NULL;\n-\n-\t\tif (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16 && n*sizeof(T) >= 16)\n-\t\t{\n-\t\t\tbyte *p;\n-\t\t#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n-\t\t\twhile (!(p = (byte *)_mm_malloc(sizeof(T)*n, 16)))\n-\t\t#elif defined(CRYPTOPP_MEMALIGN_AVAILABLE)\n-\t\t\twhile (!(p = (byte *)memalign(16, sizeof(T)*n)))\n-\t\t#elif defined(CRYPTOPP_MALLOC_ALIGNMENT_IS_16)\n-\t\t\twhile (!(p = (byte *)malloc(sizeof(T)*n)))\n-\t\t#else\n-\t\t\twhile (!(p = (byte *)malloc(sizeof(T)*n + 16)))\n-\t\t#endif\n-\t\t\t\tCallNewHandler();\n-\n-\t\t#ifdef CRYPTOPP_NO_ALIGNED_ALLOC\n-\t\t\tsize_t adjustment = 16-((size_t)p%16);\n-\t\t\tp += adjustment;\n-\t\t\tp[-1] = (byte)adjustment;\n-\t\t#endif\n-\n-\t\t\tassert(IsAlignedOn(p, 16));\n-\t\t\treturn (pointer)p;\n-\t\t}\n-\n-\t\tpointer p;\n-\t\twhile (!(p = (pointer)malloc(sizeof(T)*n)))\n-\t\t\tCallNewHandler();\n-\t\treturn p;\n-\t}\n-\n-\tvoid deallocate(void *p, size_type n)\n-\t{\n-\t\tmemset_z(p, 0, n*sizeof(T));\n-\n-\t\tif (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16 && n*sizeof(T) >= 16)\n-\t\t{\n-\t\t#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n-\t\t\t_mm_free(p);\n-\t\t#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)\n-\t\t\tp = (byte *)p - ((byte *)p)[-1];\n-\t\t\tfree(p);\n-\t\t#else\n-\t\t\tfree(p);\n-\t\t#endif\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tfree(p);\n-\t}\n-\n-\tpointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)\n-\t{\n-\t\treturn StandardReallocate(*this, p, oldSize, newSize, preserve);\n-\t}\n-\n-\t// VS.NET STL enforces the policy of \"All STL-compliant allocators have to provide a\n-\t// template class member called rebind\".\n-    template <class U> struct rebind { typedef AllocatorWithCleanup<U, T_Align16> other; };\n-#if _MSC_VER >= 1500\n-\tAllocatorWithCleanup() {}\n-\ttemplate <class U, bool A> AllocatorWithCleanup(const AllocatorWithCleanup<U, A> &) {}\n-#endif\n-};\n-\n-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<byte>;\n-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word16>;\n-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word32>;\n-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word64>;\n-#if CRYPTOPP_BOOL_X86\n-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word, true>;\t// for Integer\n-#endif\n-\n-template <class T>\n-class NullAllocator : public AllocatorBase<T>\n-{\n-public:\n-\tCRYPTOPP_INHERIT_ALLOCATOR_TYPES\n-\n-\tpointer allocate(size_type n, const void * = NULL)\n-\t{\n-\t\tassert(false);\n-\t\treturn NULL;\n-\t}\n-\n-\tvoid deallocate(void *p, size_type n)\n-\t{\n-\t\t//// Bitcoin: don't know why this trips, probably a false alarm, depends on the compiler used. \n-\t\t//assert(false);\n-\t}\n-\n-\tsize_type max_size() const {return 0;}\n-};\n-\n-// This allocator can't be used with standard collections because\n-// they require that all objects of the same allocator type are equivalent.\n-// So this is for use with SecBlock only.\n-template <class T, size_t S, class A = NullAllocator<T>, bool T_Align16 = false>\n-class FixedSizeAllocatorWithCleanup : public AllocatorBase<T>\n-{\n-public:\n-\tCRYPTOPP_INHERIT_ALLOCATOR_TYPES\n-\n-\tFixedSizeAllocatorWithCleanup() : m_allocated(false) {}\n-\n-\tpointer allocate(size_type n)\n-\t{\n-\t\tassert(IsAlignedOn(m_array, 8));\n-\n-\t\tif (n <= S && !m_allocated)\n-\t\t{\n-\t\t\tm_allocated = true;\n-\t\t\treturn GetAlignedArray();\n-\t\t}\n-\t\telse\n-\t\t\treturn m_fallbackAllocator.allocate(n);\n-\t}\n-\n-\tpointer allocate(size_type n, const void *hint)\n-\t{\n-\t\tif (n <= S && !m_allocated)\n-\t\t{\n-\t\t\tm_allocated = true;\n-\t\t\treturn GetAlignedArray();\n-\t\t}\n-\t\telse\n-\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n-\t}\n-\n-\tvoid deallocate(void *p, size_type n)\n-\t{\n-\t\tif (p == GetAlignedArray())\n-\t\t{\n-\t\t\tassert(n <= S);\n-\t\t\tassert(m_allocated);\n-\t\t\tm_allocated = false;\n-\t\t\tmemset(p, 0, n*sizeof(T));\n-\t\t}\n-\t\telse\n-\t\t\tm_fallbackAllocator.deallocate(p, n);\n-\t}\n-\n-\tpointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n-\t{\n-\t\tif (p == GetAlignedArray() && newSize <= S)\n-\t\t{\n-\t\t\tassert(oldSize <= S);\n-\t\t\tif (oldSize > newSize)\n-\t\t\t\tmemset(p + newSize, 0, (oldSize-newSize)*sizeof(T));\n-\t\t\treturn p;\n-\t\t}\n-\n-\t\tpointer newPointer = allocate(newSize, NULL);\n-\t\tif (preserve)\n-\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n-\t\tdeallocate(p, oldSize);\n-\t\treturn newPointer;\n-\t}\n-\n-\tsize_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}\n-\n-private:\n-#ifdef __BORLANDC__\n-\tT* GetAlignedArray() {return m_array;}\n-\tT m_array[S];\n-#else\n-\tT* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}\n-\tCRYPTOPP_ALIGN_DATA(8) T m_array[(CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? S+8/sizeof(T) : S];\n-#endif\n-\tA m_fallbackAllocator;\n-\tbool m_allocated;\n-};\n-\n-//! a block of memory allocated using A\n-template <class T, class A = AllocatorWithCleanup<T> >\n-class SecBlock\n-{\n-public:\n-\ttypedef typename A::value_type value_type;\n-\ttypedef typename A::pointer iterator;\n-\ttypedef typename A::const_pointer const_iterator;\n-\ttypedef typename A::size_type size_type;\n-\n-\texplicit SecBlock(size_type size=0)\n-\t\t: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}\n-\tSecBlock(const SecBlock<T, A> &t)\n-\t\t: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}\n-\tSecBlock(const T *t, size_type len)\n-\t\t: m_size(len)\n-\t{\n-\t\tm_ptr = m_alloc.allocate(len, NULL);\n-\t\tif (t == NULL)\n-\t\t\tmemset_z(m_ptr, 0, len*sizeof(T));\n-\t\telse\n-\t\t\tmemcpy(m_ptr, t, len*sizeof(T));\n-\t}\n-\n-\t~SecBlock()\n-\t\t{m_alloc.deallocate(m_ptr, m_size);}\n-\n-#ifdef __BORLANDC__\n-\toperator T *() const\n-\t\t{return (T*)m_ptr;}\n-#else\n-\toperator const void *() const\n-\t\t{return m_ptr;}\n-\toperator void *()\n-\t\t{return m_ptr;}\n-\n-\toperator const T *() const\n-\t\t{return m_ptr;}\n-\toperator T *()\n-\t\t{return m_ptr;}\n-#endif\n-\n-//\tT *operator +(size_type offset)\n-//\t\t{return m_ptr+offset;}\n-\n-//\tconst T *operator +(size_type offset) const\n-//\t\t{return m_ptr+offset;}\n-\n-//\tT& operator[](size_type index)\n-//\t\t{assert(index >= 0 && index < m_size); return m_ptr[index];}\n-\n-//\tconst T& operator[](size_type index) const\n-//\t\t{assert(index >= 0 && index < m_size); return m_ptr[index];}\n-\n-\titerator begin()\n-\t\t{return m_ptr;}\n-\tconst_iterator begin() const\n-\t\t{return m_ptr;}\n-\titerator end()\n-\t\t{return m_ptr+m_size;}\n-\tconst_iterator end() const\n-\t\t{return m_ptr+m_size;}\n-\n-\ttypename A::pointer data() {return m_ptr;}\n-\ttypename A::const_pointer data() const {return m_ptr;}\n-\n-\tsize_type size() const {return m_size;}\n-\tbool empty() const {return m_size == 0;}\n-\n-\tbyte * BytePtr() {return (byte *)m_ptr;}\n-\tconst byte * BytePtr() const {return (const byte *)m_ptr;}\n-\tsize_type SizeInBytes() const {return m_size*sizeof(T);}\n-\n-\t//! set contents and size\n-\tvoid Assign(const T *t, size_type len)\n-\t{\n-\t\tNew(len);\n-\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n-\t}\n-\n-\t//! copy contents and size from another SecBlock\n-\tvoid Assign(const SecBlock<T, A> &t)\n-\t{\n-\t\tNew(t.m_size);\n-\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));\n-\t}\n-\n-\tSecBlock<T, A>& operator=(const SecBlock<T, A> &t)\n-\t{\n-\t\tAssign(t);\n-\t\treturn *this;\n-\t}\n-\n-\t// append to this object\n-\tSecBlock<T, A>& operator+=(const SecBlock<T, A> &t)\n-\t{\n-\t\tsize_type oldSize = m_size;\n-\t\tGrow(m_size+t.m_size);\n-\t\tmemcpy_s(m_ptr+oldSize, m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));\n-\t\treturn *this;\n-\t}\n-\n-\t// append operator\n-\tSecBlock<T, A> operator+(const SecBlock<T, A> &t)\n-\t{\n-\t\tSecBlock<T, A> result(m_size+t.m_size);\n-\t\tmemcpy_s(result.m_ptr, result.m_size*sizeof(T), m_ptr, m_size*sizeof(T));\n-\t\tmemcpy_s(result.m_ptr+m_size, t.m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));\n-\t\treturn result;\n-\t}\n-\n-\tbool operator==(const SecBlock<T, A> &t) const\n-\t{\n-\t\treturn m_size == t.m_size && VerifyBufsEqual(m_ptr, t.m_ptr, m_size*sizeof(T));\n-\t}\n-\n-\tbool operator!=(const SecBlock<T, A> &t) const\n-\t{\n-\t\treturn !operator==(t);\n-\t}\n-\n-\t//! change size, without preserving contents\n-\tvoid New(size_type newSize)\n-\t{\n-\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n-\t\tm_size = newSize;\n-\t}\n-\n-\t//! change size and set contents to 0\n-\tvoid CleanNew(size_type newSize)\n-\t{\n-\t\tNew(newSize);\n-\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n-\t}\n-\n-\t//! change size only if newSize > current size. contents are preserved\n-\tvoid Grow(size_type newSize)\n-\t{\n-\t\tif (newSize > m_size)\n-\t\t{\n-\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n-\t\t\tm_size = newSize;\n-\t\t}\n-\t}\n-\n-\t//! change size only if newSize > current size. contents are preserved and additional area is set to 0\n-\tvoid CleanGrow(size_type newSize)\n-\t{\n-\t\tif (newSize > m_size)\n-\t\t{\n-\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n-\t\t\tmemset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));\n-\t\t\tm_size = newSize;\n-\t\t}\n-\t}\n-\n-\t//! change size and preserve contents\n-\tvoid resize(size_type newSize)\n-\t{\n-\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n-\t\tm_size = newSize;\n-\t}\n-\n-\t//! swap contents and size with another SecBlock\n-\tvoid swap(SecBlock<T, A> &b)\n-\t{\n-\t\tstd::swap(m_alloc, b.m_alloc);\n-\t\tstd::swap(m_size, b.m_size);\n-\t\tstd::swap(m_ptr, b.m_ptr);\n-\t}\n-\n-//private:\n-\tA m_alloc;\n-\tsize_type m_size;\n-\tT *m_ptr;\n-};\n-\n-typedef SecBlock<byte> SecByteBlock;\n-typedef SecBlock<byte, AllocatorWithCleanup<byte, true> > AlignedSecByteBlock;\n-typedef SecBlock<word> SecWordBlock;\n-\n-//! a SecBlock with fixed size, allocated statically\n-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S> >\n-class FixedSizeSecBlock : public SecBlock<T, A>\n-{\n-public:\n-\texplicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}\n-};\n-\n-template <class T, unsigned int S, bool T_Align16 = true>\n-class FixedSizeAlignedSecBlock : public FixedSizeSecBlock<T, S, FixedSizeAllocatorWithCleanup<T, S, NullAllocator<T>, T_Align16> >\n-{\n-};\n-\n-//! a SecBlock that preallocates size S statically, and uses the heap when this size is exceeded\n-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S, AllocatorWithCleanup<T> > >\n-class SecBlockWithHint : public SecBlock<T, A>\n-{\n-public:\n-\texplicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}\n-};\n-\n-template<class T, bool A, class U, bool B>\n-inline bool operator==(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (true);}\n-template<class T, bool A, class U, bool B>\n-inline bool operator!=(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (false);}\n-\n-NAMESPACE_END\n-\n-NAMESPACE_BEGIN(std)\n-template <class T, class A>\n-inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)\n-{\n-\ta.swap(b);\n-}\n-\n-#if defined(_STLP_DONT_SUPPORT_REBIND_MEMBER_TEMPLATE) || (defined(_STLPORT_VERSION) && !defined(_STLP_MEMBER_TEMPLATE_CLASSES))\n-// working for STLport 5.1.3 and MSVC 6 SP5\n-template <class _Tp1, class _Tp2>\n-inline CryptoPP::AllocatorWithCleanup<_Tp2>&\n-__stl_alloc_rebind(CryptoPP::AllocatorWithCleanup<_Tp1>& __a, const _Tp2*)\n-{\n-\treturn (CryptoPP::AllocatorWithCleanup<_Tp2>&)(__a);\n-}\n-#endif\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "fd0b0a2596e055ac0f088f5be2e9da0bcd550b30",
        "filename": "src/cryptopp/sha.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 899,
        "changes": 899,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/sha.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/sha.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/sha.cpp?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,899 +0,0 @@\n-// sha.cpp - modified by Wei Dai from Steve Reid's public domain sha1.c\n-\n-// Steve Reid implemented SHA-1. Wei Dai implemented SHA-2.\n-// Both are in the public domain.\n-\n-// use \"cl /EP /P /DCRYPTOPP_GENERATE_X64_MASM sha.cpp\" to generate MASM code\n-\n-#include \"pch.h\"\n-\n-#ifndef CRYPTOPP_IMPORTS\n-#ifndef CRYPTOPP_GENERATE_X64_MASM\n-\n-#include \"sha.h\"\n-#include \"misc.h\"\n-#include \"cpu.h\"\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-// start of Steve Reid's code\n-\n-#define blk0(i) (W[i] = data[i])\n-#define blk1(i) (W[i&15] = rotlFixed(W[(i+13)&15]^W[(i+8)&15]^W[(i+2)&15]^W[i&15],1))\n-\n-void SHA1::InitState(HashWordType *state)\n-{\n-\tstate[0] = 0x67452301L;\n-\tstate[1] = 0xEFCDAB89L;\n-\tstate[2] = 0x98BADCFEL;\n-\tstate[3] = 0x10325476L;\n-\tstate[4] = 0xC3D2E1F0L;\n-}\n-\n-#define f1(x,y,z) (z^(x&(y^z)))\n-#define f2(x,y,z) (x^y^z)\n-#define f3(x,y,z) ((x&y)|(z&(x|y)))\n-#define f4(x,y,z) (x^y^z)\n-\n-/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */\n-#define R0(v,w,x,y,z,i) z+=f1(w,x,y)+blk0(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);\n-#define R1(v,w,x,y,z,i) z+=f1(w,x,y)+blk1(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);\n-#define R2(v,w,x,y,z,i) z+=f2(w,x,y)+blk1(i)+0x6ED9EBA1+rotlFixed(v,5);w=rotlFixed(w,30);\n-#define R3(v,w,x,y,z,i) z+=f3(w,x,y)+blk1(i)+0x8F1BBCDC+rotlFixed(v,5);w=rotlFixed(w,30);\n-#define R4(v,w,x,y,z,i) z+=f4(w,x,y)+blk1(i)+0xCA62C1D6+rotlFixed(v,5);w=rotlFixed(w,30);\n-\n-void SHA1::Transform(word32 *state, const word32 *data)\n-{\n-\tword32 W[16];\n-    /* Copy context->state[] to working vars */\n-    word32 a = state[0];\n-    word32 b = state[1];\n-    word32 c = state[2];\n-    word32 d = state[3];\n-    word32 e = state[4];\n-    /* 4 rounds of 20 operations each. Loop unrolled. */\n-    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n-    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n-    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n-    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n-    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n-    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n-    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n-    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n-    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n-    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n-    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n-    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n-    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n-    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n-    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n-    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n-    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n-    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n-    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n-    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n-    /* Add the working vars back into context.state[] */\n-    state[0] += a;\n-    state[1] += b;\n-    state[2] += c;\n-    state[3] += d;\n-    state[4] += e;\n-}\n-\n-// end of Steve Reid's code\n-\n-// *************************************************************\n-\n-void SHA224::InitState(HashWordType *state)\n-{\n-\tstatic const word32 s[8] = {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};\n-\tmemcpy(state, s, sizeof(s));\n-}\n-\n-void SHA256::InitState(HashWordType *state)\n-{\n-\tstatic const word32 s[8] = {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n-\tmemcpy(state, s, sizeof(s));\n-}\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-CRYPTOPP_ALIGN_DATA(16) extern const word32 SHA256_K[64] CRYPTOPP_SECTION_ALIGN16 = {\n-#else\n-extern const word32 SHA256_K[64] = {\n-#endif\n-\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-\t0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-\t0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-\t0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-\t0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-\t0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-\t0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-\t0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-\t0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n-};\n-\n-#endif // #ifndef CRYPTOPP_GENERATE_X64_MASM\n-\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)\n-\n-#pragma warning(disable: 4731)\t// frame pointer register 'ebp' modified by inline assembly code\n-\n-static void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len\n-#if defined(_MSC_VER) && (_MSC_VER == 1200)\n-\t, ...\t// VC60 workaround: prevent VC 6 from inlining this function\n-#endif\n-\t)\n-{\n-#if defined(_MSC_VER) && (_MSC_VER == 1200)\n-\tAS2(mov ecx, [state])\n-\tAS2(mov edx, [data])\n-#endif\n-\n-\t#define LOCALS_SIZE\t8*4 + 16*4 + 4*WORD_SZ\n-\t#define H(i)\t\t[BASE+ASM_MOD(1024+7-(i),8)*4]\n-\t#define G(i)\t\tH(i+1)\n-\t#define F(i)\t\tH(i+2)\n-\t#define E(i)\t\tH(i+3)\n-\t#define D(i)\t\tH(i+4)\n-\t#define C(i)\t\tH(i+5)\n-\t#define B(i)\t\tH(i+6)\n-\t#define A(i)\t\tH(i+7)\n-\t#define Wt(i)\t\tBASE+8*4+ASM_MOD(1024+15-(i),16)*4\n-\t#define Wt_2(i)\t\tWt((i)-2)\n-\t#define Wt_15(i)\tWt((i)-15)\n-\t#define Wt_7(i)\t\tWt((i)-7)\n-\t#define K_END\t\t[BASE+8*4+16*4+0*WORD_SZ]\n-\t#define STATE_SAVE\t[BASE+8*4+16*4+1*WORD_SZ]\n-\t#define DATA_SAVE\t[BASE+8*4+16*4+2*WORD_SZ]\n-\t#define DATA_END\t[BASE+8*4+16*4+3*WORD_SZ]\n-\t#define Kt(i)\t\tWORD_REG(si)+(i)*4\n-#if CRYPTOPP_BOOL_X86\n-\t#define BASE\t\tesp+4\n-#elif defined(__GNUC__)\n-\t#define BASE\t\tr8\n-#else\n-\t#define BASE\t\trsp\n-#endif\n-\n-#define RA0(i, edx, edi)\t\t\\\n-\tAS2(\tadd edx, [Kt(i)]\t)\\\n-\tAS2(\tadd edx, [Wt(i)]\t)\\\n-\tAS2(\tadd edx, H(i)\t\t)\\\n-\n-#define RA1(i, edx, edi)\n-\n-#define RB0(i, edx, edi)\n-\n-#define RB1(i, edx, edi)\t\\\n-\tAS2(\tmov AS_REG_7d, [Wt_2(i)]\t)\\\n-\tAS2(\tmov edi, [Wt_15(i)])\\\n-\tAS2(\tmov ebx, AS_REG_7d\t)\\\n-\tAS2(\tshr AS_REG_7d, 10\t\t)\\\n-\tAS2(\tror ebx, 17\t\t)\\\n-\tAS2(\txor AS_REG_7d, ebx\t)\\\n-\tAS2(\tror ebx, 2\t\t)\\\n-\tAS2(\txor ebx, AS_REG_7d\t)/* s1(W_t-2) */\\\n-\tAS2(\tadd ebx, [Wt_7(i)])\\\n-\tAS2(\tmov AS_REG_7d, edi\t)\\\n-\tAS2(\tshr AS_REG_7d, 3\t\t)\\\n-\tAS2(\tror edi, 7\t\t)\\\n-\tAS2(\tadd ebx, [Wt(i)])/* s1(W_t-2) + W_t-7 + W_t-16 */\\\n-\tAS2(\txor AS_REG_7d, edi\t)\\\n-\tAS2(\tadd edx, [Kt(i)])\\\n-\tAS2(\tror edi, 11\t\t)\\\n-\tAS2(\tadd edx, H(i)\t)\\\n-\tAS2(\txor AS_REG_7d, edi\t)/* s0(W_t-15) */\\\n-\tAS2(\tadd AS_REG_7d, ebx\t)/* W_t = s1(W_t-2) + W_t-7 + s0(W_t-15) W_t-16*/\\\n-\tAS2(\tmov [Wt(i)], AS_REG_7d)\\\n-\tAS2(\tadd edx, AS_REG_7d\t)\\\n-\n-#define ROUND(i, r, eax, ecx, edi, edx)\\\n-\t/* in: edi = E\t*/\\\n-\t/* unused: eax, ecx, temp: ebx, AS_REG_7d, out: edx = T1 */\\\n-\tAS2(\tmov edx, F(i)\t)\\\n-\tAS2(\txor edx, G(i)\t)\\\n-\tAS2(\tand edx, edi\t)\\\n-\tAS2(\txor edx, G(i)\t)/* Ch(E,F,G) = (G^(E&(F^G))) */\\\n-\tAS2(\tmov AS_REG_7d, edi\t)\\\n-\tAS2(\tror edi, 6\t\t)\\\n-\tAS2(\tror AS_REG_7d, 25\t\t)\\\n-\tRA##r(i, edx, edi\t\t)/* H + Wt + Kt + Ch(E,F,G) */\\\n-\tAS2(\txor AS_REG_7d, edi\t)\\\n-\tAS2(\tror edi, 5\t\t)\\\n-\tAS2(\txor AS_REG_7d, edi\t)/* S1(E) */\\\n-\tAS2(\tadd edx, AS_REG_7d\t)/* T1 = S1(E) + Ch(E,F,G) + H + Wt + Kt */\\\n-\tRB##r(i, edx, edi\t\t)/* H + Wt + Kt + Ch(E,F,G) */\\\n-\t/* in: ecx = A, eax = B^C, edx = T1 */\\\n-\t/* unused: edx, temp: ebx, AS_REG_7d, out: eax = A, ecx = B^C, edx = E */\\\n-\tAS2(\tmov ebx, ecx\t)\\\n-\tAS2(\txor ecx, B(i)\t)/* A^B */\\\n-\tAS2(\tand eax, ecx\t)\\\n-\tAS2(\txor eax, B(i)\t)/* Maj(A,B,C) = B^((A^B)&(B^C) */\\\n-\tAS2(\tmov AS_REG_7d, ebx\t)\\\n-\tAS2(\tror ebx, 2\t\t)\\\n-\tAS2(\tadd eax, edx\t)/* T1 + Maj(A,B,C) */\\\n-\tAS2(\tadd edx, D(i)\t)\\\n-\tAS2(\tmov D(i), edx\t)\\\n-\tAS2(\tror AS_REG_7d, 22\t\t)\\\n-\tAS2(\txor AS_REG_7d, ebx\t)\\\n-\tAS2(\tror ebx, 11\t\t)\\\n-\tAS2(\txor AS_REG_7d, ebx\t)\\\n-\tAS2(\tadd eax, AS_REG_7d\t)/* T1 + S0(A) + Maj(A,B,C) */\\\n-\tAS2(\tmov H(i), eax\t)\\\n-\n-#define SWAP_COPY(i)\t\t\\\n-\tAS2(\tmov\t\tWORD_REG(bx), [WORD_REG(dx)+i*WORD_SZ])\\\n-\tAS1(\tbswap\tWORD_REG(bx))\\\n-\tAS2(\tmov\t\t[Wt(i*(1+CRYPTOPP_BOOL_X64)+CRYPTOPP_BOOL_X64)], WORD_REG(bx))\n-\n-#if defined(__GNUC__)\n-\t#if CRYPTOPP_BOOL_X64\n-\t\tFixedSizeAlignedSecBlock<byte, LOCALS_SIZE> workspace;\n-\t#endif\n-\t__asm__ __volatile__\n-\t(\n-\t#if CRYPTOPP_BOOL_X64\n-\t\t\"lea %4, %%r8;\"\n-\t#endif\n-\t\".intel_syntax noprefix;\"\n-#elif defined(CRYPTOPP_GENERATE_X64_MASM)\n-\t\tALIGN   8\n-\tX86_SHA256_HashBlocks\tPROC FRAME\n-\t\trex_push_reg rsi\n-\t\tpush_reg rdi\n-\t\tpush_reg rbx\n-\t\tpush_reg rbp\n-\t\talloc_stack(LOCALS_SIZE+8)\n-\t\t.endprolog\n-\t\tmov rdi, r8\n-\t\tlea rsi, [?SHA256_K@CryptoPP@@3QBIB + 48*4]\n-#endif\n-\n-#if CRYPTOPP_BOOL_X86\n-\t#ifndef __GNUC__\n-\t\tAS2(\tmov\t\tedi, [len])\n-\t\tAS2(\tlea\t\tWORD_REG(si), [SHA256_K+48*4])\n-\t#endif\n-\t#if !defined(_MSC_VER) || (_MSC_VER < 1400)\n-\t\tAS_PUSH_IF86(bx)\n-\t#endif\n-\n-\tAS_PUSH_IF86(bp)\n-\tAS2(\tmov\t\tebx, esp)\n-\tAS2(\tand\t\tesp, -16)\n-\tAS2(\tsub\t\tWORD_REG(sp), LOCALS_SIZE)\n-\tAS_PUSH_IF86(bx)\n-#endif\n-\tAS2(\tmov\t\tSTATE_SAVE, WORD_REG(cx))\n-\tAS2(\tmov\t\tDATA_SAVE, WORD_REG(dx))\n-\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(dx))\n-\tAS2(\tmov\t\tDATA_END, WORD_REG(di))\n-\tAS2(\tmov\t\tK_END, WORD_REG(si))\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-#if CRYPTOPP_BOOL_X86\n-\tAS2(\ttest\tedi, 1)\n-\tASJ(\tjnz,\t2, f)\n-#endif\n-\tAS2(\tmovdqa\txmm0, XMMWORD_PTR [WORD_REG(cx)+0*16])\n-\tAS2(\tmovdqa\txmm1, XMMWORD_PTR [WORD_REG(cx)+1*16])\n-#endif\n-\n-#if CRYPTOPP_BOOL_X86\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\tASJ(\tjmp,\t0, f)\n-#endif\n-\tASL(2)\t// non-SSE2\n-\tAS2(\tmov\t\tesi, ecx)\n-\tAS2(\tlea\t\tedi, A(0))\n-\tAS2(\tmov\t\tecx, 8)\n-\tAS1(\trep movsd)\n-\tAS2(\tmov\t\tesi, K_END)\n-\tASJ(\tjmp,\t3, f)\n-#endif\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\tASL(0)\n-\tAS2(\tmovdqa\tE(0), xmm1)\n-\tAS2(\tmovdqa\tA(0), xmm0)\n-#endif\n-#if CRYPTOPP_BOOL_X86\n-\tASL(3)\n-#endif\n-\tAS2(\tsub\t\tWORD_REG(si), 48*4)\n-\tSWAP_COPY(0)\tSWAP_COPY(1)\tSWAP_COPY(2)\tSWAP_COPY(3)\n-\tSWAP_COPY(4)\tSWAP_COPY(5)\tSWAP_COPY(6)\tSWAP_COPY(7)\n-#if CRYPTOPP_BOOL_X86\n-\tSWAP_COPY(8)\tSWAP_COPY(9)\tSWAP_COPY(10)\tSWAP_COPY(11)\n-\tSWAP_COPY(12)\tSWAP_COPY(13)\tSWAP_COPY(14)\tSWAP_COPY(15)\n-#endif\n-\tAS2(\tmov\t\tedi, E(0))\t// E\n-\tAS2(\tmov\t\teax, B(0))\t// B\n-\tAS2(\txor\t\teax, C(0))\t// B^C\n-\tAS2(\tmov\t\tecx, A(0))\t// A\n-\n-\tROUND(0, 0, eax, ecx, edi, edx)\n-\tROUND(1, 0, ecx, eax, edx, edi)\n-\tROUND(2, 0, eax, ecx, edi, edx)\n-\tROUND(3, 0, ecx, eax, edx, edi)\n-\tROUND(4, 0, eax, ecx, edi, edx)\n-\tROUND(5, 0, ecx, eax, edx, edi)\n-\tROUND(6, 0, eax, ecx, edi, edx)\n-\tROUND(7, 0, ecx, eax, edx, edi)\n-\tROUND(8, 0, eax, ecx, edi, edx)\n-\tROUND(9, 0, ecx, eax, edx, edi)\n-\tROUND(10, 0, eax, ecx, edi, edx)\n-\tROUND(11, 0, ecx, eax, edx, edi)\n-\tROUND(12, 0, eax, ecx, edi, edx)\n-\tROUND(13, 0, ecx, eax, edx, edi)\n-\tROUND(14, 0, eax, ecx, edi, edx)\n-\tROUND(15, 0, ecx, eax, edx, edi)\n-\n-\tASL(1)\n-\tAS2(add WORD_REG(si), 4*16)\n-\tROUND(0, 1, eax, ecx, edi, edx)\n-\tROUND(1, 1, ecx, eax, edx, edi)\n-\tROUND(2, 1, eax, ecx, edi, edx)\n-\tROUND(3, 1, ecx, eax, edx, edi)\n-\tROUND(4, 1, eax, ecx, edi, edx)\n-\tROUND(5, 1, ecx, eax, edx, edi)\n-\tROUND(6, 1, eax, ecx, edi, edx)\n-\tROUND(7, 1, ecx, eax, edx, edi)\n-\tROUND(8, 1, eax, ecx, edi, edx)\n-\tROUND(9, 1, ecx, eax, edx, edi)\n-\tROUND(10, 1, eax, ecx, edi, edx)\n-\tROUND(11, 1, ecx, eax, edx, edi)\n-\tROUND(12, 1, eax, ecx, edi, edx)\n-\tROUND(13, 1, ecx, eax, edx, edi)\n-\tROUND(14, 1, eax, ecx, edi, edx)\n-\tROUND(15, 1, ecx, eax, edx, edi)\n-\tAS2(\tcmp\t\tWORD_REG(si), K_END)\n-\tASJ(\tjne,\t1, b)\n-\n-\tAS2(\tmov\t\tWORD_REG(dx), DATA_SAVE)\n-\tAS2(\tadd\t\tWORD_REG(dx), 64)\n-\tAS2(\tmov\t\tAS_REG_7, STATE_SAVE)\n-\tAS2(\tmov\t\tDATA_SAVE, WORD_REG(dx))\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-#if CRYPTOPP_BOOL_X86\n-\tAS2(\ttest\tDWORD PTR DATA_END, 1)\n-\tASJ(\tjnz,\t4, f)\n-#endif\n-\tAS2(\tmovdqa\txmm1, XMMWORD_PTR [AS_REG_7+1*16])\n-\tAS2(\tmovdqa\txmm0, XMMWORD_PTR [AS_REG_7+0*16])\n-\tAS2(\tpaddd\txmm1, E(0))\n-\tAS2(\tpaddd\txmm0, A(0))\n-\tAS2(\tmovdqa\t[AS_REG_7+1*16], xmm1)\n-\tAS2(\tmovdqa\t[AS_REG_7+0*16], xmm0)\n-\tAS2(\tcmp\t\tWORD_REG(dx), DATA_END)\n-\tASJ(\tjl,\t\t0, b)\n-#endif\n-\n-#if CRYPTOPP_BOOL_X86\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\tASJ(\tjmp,\t5, f)\n-\tASL(4)\t// non-SSE2\n-#endif\n-\tAS2(\tadd\t\t[AS_REG_7+0*4], ecx)\t// A\n-\tAS2(\tadd\t\t[AS_REG_7+4*4], edi)\t// E\n-\tAS2(\tmov\t\teax, B(0))\n-\tAS2(\tmov\t\tebx, C(0))\n-\tAS2(\tmov\t\tecx, D(0))\n-\tAS2(\tadd\t\t[AS_REG_7+1*4], eax)\n-\tAS2(\tadd\t\t[AS_REG_7+2*4], ebx)\n-\tAS2(\tadd\t\t[AS_REG_7+3*4], ecx)\n-\tAS2(\tmov\t\teax, F(0))\n-\tAS2(\tmov\t\tebx, G(0))\n-\tAS2(\tmov\t\tecx, H(0))\n-\tAS2(\tadd\t\t[AS_REG_7+5*4], eax)\n-\tAS2(\tadd\t\t[AS_REG_7+6*4], ebx)\n-\tAS2(\tadd\t\t[AS_REG_7+7*4], ecx)\n-\tAS2(\tmov\t\tecx, AS_REG_7d)\n-\tAS2(\tcmp\t\tWORD_REG(dx), DATA_END)\n-\tASJ(\tjl,\t\t2, b)\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\tASL(5)\n-#endif\n-#endif\n-\n-\tAS_POP_IF86(sp)\n-\tAS_POP_IF86(bp)\n-\t#if !defined(_MSC_VER) || (_MSC_VER < 1400)\n-\t\tAS_POP_IF86(bx)\n-\t#endif\n-\n-#ifdef CRYPTOPP_GENERATE_X64_MASM\n-\tadd\t\trsp, LOCALS_SIZE+8\n-\tpop\t\trbp\n-\tpop\t\trbx\n-\tpop\t\trdi\n-\tpop\t\trsi\n-\tret\n-\tX86_SHA256_HashBlocks ENDP\n-#endif\n-\n-#ifdef __GNUC__\n-\t\".att_syntax prefix;\"\n-\t: \n-\t: \"c\" (state), \"d\" (data), \"S\" (SHA256_K+48), \"D\" (len)\n-\t#if CRYPTOPP_BOOL_X64\n-\t\t, \"m\" (workspace[0])\n-\t#endif\n-\t: \"memory\", \"cc\", \"%eax\"\n-\t#if CRYPTOPP_BOOL_X64\n-\t\t, \"%rbx\", \"%r8\"\n-\t#endif\n-\t);\n-#endif\n-}\n-\n-#endif\t// #if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)\n-\n-#ifndef CRYPTOPP_GENERATE_X64_MASM\n-\n-#ifdef CRYPTOPP_X64_MASM_AVAILABLE\n-extern \"C\" {\n-void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len);\n-}\n-#endif\n-\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n-\n-size_t SHA256::HashMultipleBlocks(const word32 *input, size_t length)\n-{\n-\tX86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());\n-\treturn length % BLOCKSIZE;\n-}\n-\n-size_t SHA224::HashMultipleBlocks(const word32 *input, size_t length)\n-{\n-\tX86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());\n-\treturn length % BLOCKSIZE;\n-}\n-\n-#endif\n-\n-#define blk2(i) (W[i&15]+=s1(W[(i-2)&15])+W[(i-7)&15]+s0(W[(i-15)&15]))\n-\n-#define Ch(x,y,z) (z^(x&(y^z)))\n-#define Maj(x,y,z) (y^((x^y)&(y^z)))\n-\n-#define a(i) T[(0-i)&7]\n-#define b(i) T[(1-i)&7]\n-#define c(i) T[(2-i)&7]\n-#define d(i) T[(3-i)&7]\n-#define e(i) T[(4-i)&7]\n-#define f(i) T[(5-i)&7]\n-#define g(i) T[(6-i)&7]\n-#define h(i) T[(7-i)&7]\n-\n-#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA256_K[i+j]+(j?blk2(i):blk0(i));\\\n-\td(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))\n-\n-// for SHA256\n-#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))\n-#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))\n-#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))\n-#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))\n-\n-void SHA256::Transform(word32 *state, const word32 *data)\n-{\n-\tword32 W[16];\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n-\t// this byte reverse is a waste of time, but this function is only called by MDC\n-\tByteReverse(W, data, BLOCKSIZE);\n-\tX86_SHA256_HashBlocks(state, W, BLOCKSIZE - !HasSSE2());\n-#else\n-\tword32 T[8];\n-    /* Copy context->state[] to working vars */\n-\tmemcpy(T, state, sizeof(T));\n-    /* 64 operations, partially loop unrolled */\n-\tfor (unsigned int j=0; j<64; j+=16)\n-\t{\n-\t\tR( 0); R( 1); R( 2); R( 3);\n-\t\tR( 4); R( 5); R( 6); R( 7);\n-\t\tR( 8); R( 9); R(10); R(11);\n-\t\tR(12); R(13); R(14); R(15);\n-\t}\n-    /* Add the working vars back into context.state[] */\n-    state[0] += a(0);\n-    state[1] += b(0);\n-    state[2] += c(0);\n-    state[3] += d(0);\n-    state[4] += e(0);\n-    state[5] += f(0);\n-    state[6] += g(0);\n-    state[7] += h(0);\n-#endif\n-}\n-\n-/* \n-// smaller but slower\n-void SHA256::Transform(word32 *state, const word32 *data)\n-{\n-\tword32 T[20];\n-\tword32 W[32];\n-\tunsigned int i = 0, j = 0;\n-\tword32 *t = T+8;\n-\n-\tmemcpy(t, state, 8*4);\n-\tword32 e = t[4], a = t[0];\n-\n-\tdo \n-\t{\n-\t\tword32 w = data[j];\n-\t\tW[j] = w;\n-\t\tw += SHA256_K[j];\n-\t\tw += t[7];\n-\t\tw += S1(e);\n-\t\tw += Ch(e, t[5], t[6]);\n-\t\te = t[3] + w;\n-\t\tt[3] = t[3+8] = e;\n-\t\tw += S0(t[0]);\n-\t\ta = w + Maj(a, t[1], t[2]);\n-\t\tt[-1] = t[7] = a;\n-\t\t--t;\n-\t\t++j;\n-\t\tif (j%8 == 0)\n-\t\t\tt += 8;\n-\t} while (j<16);\n-\n-\tdo\n-\t{\n-\t\ti = j&0xf;\n-\t\tword32 w = s1(W[i+16-2]) + s0(W[i+16-15]) + W[i] + W[i+16-7];\n-\t\tW[i+16] = W[i] = w;\n-\t\tw += SHA256_K[j];\n-\t\tw += t[7];\n-\t\tw += S1(e);\n-\t\tw += Ch(e, t[5], t[6]);\n-\t\te = t[3] + w;\n-\t\tt[3] = t[3+8] = e;\n-\t\tw += S0(t[0]);\n-\t\ta = w + Maj(a, t[1], t[2]);\n-\t\tt[-1] = t[7] = a;\n-\n-\t\tw = s1(W[(i+1)+16-2]) + s0(W[(i+1)+16-15]) + W[(i+1)] + W[(i+1)+16-7];\n-\t\tW[(i+1)+16] = W[(i+1)] = w;\n-\t\tw += SHA256_K[j+1];\n-\t\tw += (t-1)[7];\n-\t\tw += S1(e);\n-\t\tw += Ch(e, (t-1)[5], (t-1)[6]);\n-\t\te = (t-1)[3] + w;\n-\t\t(t-1)[3] = (t-1)[3+8] = e;\n-\t\tw += S0((t-1)[0]);\n-\t\ta = w + Maj(a, (t-1)[1], (t-1)[2]);\n-\t\t(t-1)[-1] = (t-1)[7] = a;\n-\n-\t\tt-=2;\n-\t\tj+=2;\n-\t\tif (j%8 == 0)\n-\t\t\tt += 8;\n-\t} while (j<64);\n-\n-    state[0] += a;\n-    state[1] += t[1];\n-    state[2] += t[2];\n-    state[3] += t[3];\n-    state[4] += e;\n-    state[5] += t[5];\n-    state[6] += t[6];\n-    state[7] += t[7];\n-}\n-*/\n-\n-#undef S0\n-#undef S1\n-#undef s0\n-#undef s1\n-#undef R\n-\n-// *************************************************************\n-\n-void SHA384::InitState(HashWordType *state)\n-{\n-\tstatic const word64 s[8] = {\n-\t\tW64LIT(0xcbbb9d5dc1059ed8), W64LIT(0x629a292a367cd507),\n-\t\tW64LIT(0x9159015a3070dd17), W64LIT(0x152fecd8f70e5939),\n-\t\tW64LIT(0x67332667ffc00b31), W64LIT(0x8eb44a8768581511),\n-\t\tW64LIT(0xdb0c2e0d64f98fa7), W64LIT(0x47b5481dbefa4fa4)};\n-\tmemcpy(state, s, sizeof(s));\n-}\n-\n-void SHA512::InitState(HashWordType *state)\n-{\n-\tstatic const word64 s[8] = {\n-\t\tW64LIT(0x6a09e667f3bcc908), W64LIT(0xbb67ae8584caa73b),\n-\t\tW64LIT(0x3c6ef372fe94f82b), W64LIT(0xa54ff53a5f1d36f1),\n-\t\tW64LIT(0x510e527fade682d1), W64LIT(0x9b05688c2b3e6c1f),\n-\t\tW64LIT(0x1f83d9abfb41bd6b), W64LIT(0x5be0cd19137e2179)};\n-\tmemcpy(state, s, sizeof(s));\n-}\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86\n-CRYPTOPP_ALIGN_DATA(16) static const word64 SHA512_K[80] CRYPTOPP_SECTION_ALIGN16 = {\n-#else\n-static const word64 SHA512_K[80] = {\n-#endif\n-\tW64LIT(0x428a2f98d728ae22), W64LIT(0x7137449123ef65cd),\n-\tW64LIT(0xb5c0fbcfec4d3b2f), W64LIT(0xe9b5dba58189dbbc),\n-\tW64LIT(0x3956c25bf348b538), W64LIT(0x59f111f1b605d019),\n-\tW64LIT(0x923f82a4af194f9b), W64LIT(0xab1c5ed5da6d8118),\n-\tW64LIT(0xd807aa98a3030242), W64LIT(0x12835b0145706fbe),\n-\tW64LIT(0x243185be4ee4b28c), W64LIT(0x550c7dc3d5ffb4e2),\n-\tW64LIT(0x72be5d74f27b896f), W64LIT(0x80deb1fe3b1696b1),\n-\tW64LIT(0x9bdc06a725c71235), W64LIT(0xc19bf174cf692694),\n-\tW64LIT(0xe49b69c19ef14ad2), W64LIT(0xefbe4786384f25e3),\n-\tW64LIT(0x0fc19dc68b8cd5b5), W64LIT(0x240ca1cc77ac9c65),\n-\tW64LIT(0x2de92c6f592b0275), W64LIT(0x4a7484aa6ea6e483),\n-\tW64LIT(0x5cb0a9dcbd41fbd4), W64LIT(0x76f988da831153b5),\n-\tW64LIT(0x983e5152ee66dfab), W64LIT(0xa831c66d2db43210),\n-\tW64LIT(0xb00327c898fb213f), W64LIT(0xbf597fc7beef0ee4),\n-\tW64LIT(0xc6e00bf33da88fc2), W64LIT(0xd5a79147930aa725),\n-\tW64LIT(0x06ca6351e003826f), W64LIT(0x142929670a0e6e70),\n-\tW64LIT(0x27b70a8546d22ffc), W64LIT(0x2e1b21385c26c926),\n-\tW64LIT(0x4d2c6dfc5ac42aed), W64LIT(0x53380d139d95b3df),\n-\tW64LIT(0x650a73548baf63de), W64LIT(0x766a0abb3c77b2a8),\n-\tW64LIT(0x81c2c92e47edaee6), W64LIT(0x92722c851482353b),\n-\tW64LIT(0xa2bfe8a14cf10364), W64LIT(0xa81a664bbc423001),\n-\tW64LIT(0xc24b8b70d0f89791), W64LIT(0xc76c51a30654be30),\n-\tW64LIT(0xd192e819d6ef5218), W64LIT(0xd69906245565a910),\n-\tW64LIT(0xf40e35855771202a), W64LIT(0x106aa07032bbd1b8),\n-\tW64LIT(0x19a4c116b8d2d0c8), W64LIT(0x1e376c085141ab53),\n-\tW64LIT(0x2748774cdf8eeb99), W64LIT(0x34b0bcb5e19b48a8),\n-\tW64LIT(0x391c0cb3c5c95a63), W64LIT(0x4ed8aa4ae3418acb),\n-\tW64LIT(0x5b9cca4f7763e373), W64LIT(0x682e6ff3d6b2b8a3),\n-\tW64LIT(0x748f82ee5defb2fc), W64LIT(0x78a5636f43172f60),\n-\tW64LIT(0x84c87814a1f0ab72), W64LIT(0x8cc702081a6439ec),\n-\tW64LIT(0x90befffa23631e28), W64LIT(0xa4506cebde82bde9),\n-\tW64LIT(0xbef9a3f7b2c67915), W64LIT(0xc67178f2e372532b),\n-\tW64LIT(0xca273eceea26619c), W64LIT(0xd186b8c721c0c207),\n-\tW64LIT(0xeada7dd6cde0eb1e), W64LIT(0xf57d4f7fee6ed178),\n-\tW64LIT(0x06f067aa72176fba), W64LIT(0x0a637dc5a2c898a6),\n-\tW64LIT(0x113f9804bef90dae), W64LIT(0x1b710b35131c471b),\n-\tW64LIT(0x28db77f523047d84), W64LIT(0x32caab7b40c72493),\n-\tW64LIT(0x3c9ebe0a15c9bebc), W64LIT(0x431d67c49c100d4c),\n-\tW64LIT(0x4cc5d4becb3e42b6), W64LIT(0x597f299cfc657e2a),\n-\tW64LIT(0x5fcb6fab3ad6faec), W64LIT(0x6c44198c4a475817)\n-};\n-\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86\n-// put assembly version in separate function, otherwise MSVC 2005 SP1 doesn't generate correct code for the non-assembly version\n-CRYPTOPP_NAKED static void CRYPTOPP_FASTCALL SHA512_SSE2_Transform(word64 *state, const word64 *data)\n-{\n-#ifdef __GNUC__\n-\t__asm__ __volatile__\n-\t(\n-\t\t\".intel_syntax noprefix;\"\n-\tAS1(\tpush\tebx)\n-\tAS2(\tmov\t\tebx, eax)\n-#else\n-\tAS1(\tpush\tebx)\n-\tAS1(\tpush\tesi)\n-\tAS1(\tpush\tedi)\n-\tAS2(\tlea\t\tebx, SHA512_K)\n-#endif\n-\n-\tAS2(\tmov\t\teax, esp)\n-\tAS2(\tand\t\tesp, 0xfffffff0)\n-\tAS2(\tsub\t\tesp, 27*16)\t\t\t\t// 17*16 for expanded data, 20*8 for state\n-\tAS1(\tpush\teax)\n-\tAS2(\txor\t\teax, eax)\n-\tAS2(\tlea\t\tedi, [esp+4+8*8])\t\t// start at middle of state buffer. will decrement pointer each round to avoid copying\n-\tAS2(\tlea\t\tesi, [esp+4+20*8+8])\t// 16-byte alignment, then add 8\n-\n-\tAS2(\tmovdqa\txmm0, [ecx+0*16])\n-\tAS2(\tmovdq2q\tmm4, xmm0)\n-\tAS2(\tmovdqa\t[edi+0*16], xmm0)\n-\tAS2(\tmovdqa\txmm0, [ecx+1*16])\n-\tAS2(\tmovdqa\t[edi+1*16], xmm0)\n-\tAS2(\tmovdqa\txmm0, [ecx+2*16])\n-\tAS2(\tmovdq2q\tmm5, xmm0)\n-\tAS2(\tmovdqa\t[edi+2*16], xmm0)\n-\tAS2(\tmovdqa\txmm0, [ecx+3*16])\n-\tAS2(\tmovdqa\t[edi+3*16], xmm0)\n-\tASJ(\tjmp,\t0, f)\n-\n-#define SSE2_S0_S1(r, a, b, c)\t\\\n-\tAS2(\tmovq\tmm6, r)\\\n-\tAS2(\tpsrlq\tr, a)\\\n-\tAS2(\tmovq\tmm7, r)\\\n-\tAS2(\tpsllq\tmm6, 64-c)\\\n-\tAS2(\tpxor\tmm7, mm6)\\\n-\tAS2(\tpsrlq\tr, b-a)\\\n-\tAS2(\tpxor\tmm7, r)\\\n-\tAS2(\tpsllq\tmm6, c-b)\\\n-\tAS2(\tpxor\tmm7, mm6)\\\n-\tAS2(\tpsrlq\tr, c-b)\\\n-\tAS2(\tpxor\tr, mm7)\\\n-\tAS2(\tpsllq\tmm6, b-a)\\\n-\tAS2(\tpxor\tr, mm6)\n-\n-#define SSE2_s0(r, a, b, c)\t\\\n-\tAS2(\tmovdqa\txmm6, r)\\\n-\tAS2(\tpsrlq\tr, a)\\\n-\tAS2(\tmovdqa\txmm7, r)\\\n-\tAS2(\tpsllq\txmm6, 64-c)\\\n-\tAS2(\tpxor\txmm7, xmm6)\\\n-\tAS2(\tpsrlq\tr, b-a)\\\n-\tAS2(\tpxor\txmm7, r)\\\n-\tAS2(\tpsrlq\tr, c-b)\\\n-\tAS2(\tpxor\tr, xmm7)\\\n-\tAS2(\tpsllq\txmm6, c-a)\\\n-\tAS2(\tpxor\tr, xmm6)\n-\n-#define SSE2_s1(r, a, b, c)\t\\\n-\tAS2(\tmovdqa\txmm6, r)\\\n-\tAS2(\tpsrlq\tr, a)\\\n-\tAS2(\tmovdqa\txmm7, r)\\\n-\tAS2(\tpsllq\txmm6, 64-c)\\\n-\tAS2(\tpxor\txmm7, xmm6)\\\n-\tAS2(\tpsrlq\tr, b-a)\\\n-\tAS2(\tpxor\txmm7, r)\\\n-\tAS2(\tpsllq\txmm6, c-b)\\\n-\tAS2(\tpxor\txmm7, xmm6)\\\n-\tAS2(\tpsrlq\tr, c-b)\\\n-\tAS2(\tpxor\tr, xmm7)\n-\n-\tASL(SHA512_Round)\n-\t// k + w is in mm0, a is in mm4, e is in mm5\n-\tAS2(\tpaddq\tmm0, [edi+7*8])\t\t// h\n-\tAS2(\tmovq\tmm2, [edi+5*8])\t\t// f\n-\tAS2(\tmovq\tmm3, [edi+6*8])\t\t// g\n-\tAS2(\tpxor\tmm2, mm3)\n-\tAS2(\tpand\tmm2, mm5)\n-\tSSE2_S0_S1(mm5,14,18,41)\n-\tAS2(\tpxor\tmm2, mm3)\n-\tAS2(\tpaddq\tmm0, mm2)\t\t\t// h += Ch(e,f,g)\n-\tAS2(\tpaddq\tmm5, mm0)\t\t\t// h += S1(e)\n-\tAS2(\tmovq\tmm2, [edi+1*8])\t\t// b\n-\tAS2(\tmovq\tmm1, mm2)\n-\tAS2(\tpor\t\tmm2, mm4)\n-\tAS2(\tpand\tmm2, [edi+2*8])\t\t// c\n-\tAS2(\tpand\tmm1, mm4)\n-\tAS2(\tpor\t\tmm1, mm2)\n-\tAS2(\tpaddq\tmm1, mm5)\t\t\t// temp = h + Maj(a,b,c)\n-\tAS2(\tpaddq\tmm5, [edi+3*8])\t\t// e = d + h\n-\tAS2(\tmovq\t[edi+3*8], mm5)\n-\tAS2(\tmovq\t[edi+11*8], mm5)\n-\tSSE2_S0_S1(mm4,28,34,39)\t\t\t// S0(a)\n-\tAS2(\tpaddq\tmm4, mm1)\t\t\t// a = temp + S0(a)\n-\tAS2(\tmovq\t[edi-8], mm4)\n-\tAS2(\tmovq\t[edi+7*8], mm4)\n-\tAS1(\tret)\n-\n-\t// first 16 rounds\n-\tASL(0)\n-\tAS2(\tmovq\tmm0, [edx+eax*8])\n-\tAS2(\tmovq\t[esi+eax*8], mm0)\n-\tAS2(\tmovq\t[esi+eax*8+16*8], mm0)\n-\tAS2(\tpaddq\tmm0, [ebx+eax*8])\n-\tASC(\tcall,\tSHA512_Round)\n-\tAS1(\tinc\t\teax)\n-\tAS2(\tsub\t\tedi, 8)\n-\tAS2(\ttest\teax, 7)\n-\tASJ(\tjnz,\t0, b)\n-\tAS2(\tadd\t\tedi, 8*8)\n-\tAS2(\tcmp\t\teax, 16)\n-\tASJ(\tjne,\t0, b)\n-\n-\t// rest of the rounds\n-\tAS2(\tmovdqu\txmm0, [esi+(16-2)*8])\n-\tASL(1)\n-\t// data expansion, W[i-2] already in xmm0\n-\tAS2(\tmovdqu\txmm3, [esi])\n-\tAS2(\tpaddq\txmm3, [esi+(16-7)*8])\n-\tAS2(\tmovdqa\txmm2, [esi+(16-15)*8])\n-\tSSE2_s1(xmm0, 6, 19, 61)\n-\tAS2(\tpaddq\txmm0, xmm3)\n-\tSSE2_s0(xmm2, 1, 7, 8)\n-\tAS2(\tpaddq\txmm0, xmm2)\n-\tAS2(\tmovdq2q\tmm0, xmm0)\n-\tAS2(\tmovhlps\txmm1, xmm0)\n-\tAS2(\tpaddq\tmm0, [ebx+eax*8])\n-\tAS2(\tmovlps\t[esi], xmm0)\n-\tAS2(\tmovlps\t[esi+8], xmm1)\n-\tAS2(\tmovlps\t[esi+8*16], xmm0)\n-\tAS2(\tmovlps\t[esi+8*17], xmm1)\n-\t// 2 rounds\n-\tASC(\tcall,\tSHA512_Round)\n-\tAS2(\tsub\t\tedi, 8)\n-\tAS2(\tmovdq2q\tmm0, xmm1)\n-\tAS2(\tpaddq\tmm0, [ebx+eax*8+8])\n-\tASC(\tcall,\tSHA512_Round)\n-\t// update indices and loop\n-\tAS2(\tadd\t\tesi, 16)\n-\tAS2(\tadd\t\teax, 2)\n-\tAS2(\tsub\t\tedi, 8)\n-\tAS2(\ttest\teax, 7)\n-\tASJ(\tjnz,\t1, b)\n-\t// do housekeeping every 8 rounds\n-\tAS2(\tmov\t\tesi, 0xf)\n-\tAS2(\tand\t\tesi, eax)\n-\tAS2(\tlea\t\tesi, [esp+4+20*8+8+esi*8])\n-\tAS2(\tadd\t\tedi, 8*8)\n-\tAS2(\tcmp\t\teax, 80)\n-\tASJ(\tjne,\t1, b)\n-\n-#define SSE2_CombineState(i)\t\\\n-\tAS2(\tmovdqa\txmm0, [edi+i*16])\\\n-\tAS2(\tpaddq\txmm0, [ecx+i*16])\\\n-\tAS2(\tmovdqa\t[ecx+i*16], xmm0)\n-\n-\tSSE2_CombineState(0)\n-\tSSE2_CombineState(1)\n-\tSSE2_CombineState(2)\n-\tSSE2_CombineState(3)\n-\n-\tAS1(\tpop\t\tesp)\n-\tAS1(\temms)\n-\n-#if defined(__GNUC__)\n-\tAS1(\tpop\t\tebx)\n-\t\".att_syntax prefix;\"\n-\t\t:\n-\t\t: \"a\" (SHA512_K), \"c\" (state), \"d\" (data)\n-\t\t: \"%esi\", \"%edi\", \"memory\", \"cc\"\n-\t);\n-#else\n-\tAS1(\tpop\t\tedi)\n-\tAS1(\tpop\t\tesi)\n-\tAS1(\tpop\t\tebx)\n-\tAS1(\tret)\n-#endif\n-}\n-#endif\t// #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n-\n-void SHA512::Transform(word64 *state, const word64 *data)\n-{\n-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86\n-\tif (HasSSE2())\n-\t{\n-\t\tSHA512_SSE2_Transform(state, data);\n-\t\treturn;\n-\t}\n-#endif\n-\n-#define S0(x) (rotrFixed(x,28)^rotrFixed(x,34)^rotrFixed(x,39))\n-#define S1(x) (rotrFixed(x,14)^rotrFixed(x,18)^rotrFixed(x,41))\n-#define s0(x) (rotrFixed(x,1)^rotrFixed(x,8)^(x>>7))\n-#define s1(x) (rotrFixed(x,19)^rotrFixed(x,61)^(x>>6))\n-\n-#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA512_K[i+j]+(j?blk2(i):blk0(i));\\\n-\td(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))\n-\n-\tword64 W[16];\n-\tword64 T[8];\n-    /* Copy context->state[] to working vars */\n-\tmemcpy(T, state, sizeof(T));\n-    /* 80 operations, partially loop unrolled */\n-\tfor (unsigned int j=0; j<80; j+=16)\n-\t{\n-\t\tR( 0); R( 1); R( 2); R( 3);\n-\t\tR( 4); R( 5); R( 6); R( 7);\n-\t\tR( 8); R( 9); R(10); R(11);\n-\t\tR(12); R(13); R(14); R(15);\n-\t}\n-    /* Add the working vars back into context.state[] */\n-    state[0] += a(0);\n-    state[1] += b(0);\n-    state[2] += c(0);\n-    state[3] += d(0);\n-    state[4] += e(0);\n-    state[5] += f(0);\n-    state[6] += g(0);\n-    state[7] += h(0);\n-}\n-\n-NAMESPACE_END\n-\n-#endif\t// #ifndef CRYPTOPP_GENERATE_X64_MASM\n-#endif\t// #ifndef CRYPTOPP_IMPORTS"
      },
      {
        "sha": "679081e8fa33e8b323e8ac443777055befc9c505",
        "filename": "src/cryptopp/sha.h",
        "status": "removed",
        "additions": 0,
        "deletions": 63,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/sha.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/sha.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/sha.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,63 +0,0 @@\n-#ifndef CRYPTOPP_SHA_H\n-#define CRYPTOPP_SHA_H\n-\n-#include \"iterhash.h\"\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-/// <a href=\"http://www.weidai.com/scan-mirror/md.html#SHA-1\">SHA-1</a>\n-class CRYPTOPP_DLL SHA1 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 20, SHA1>\n-{\n-public:\n-\tstatic void CRYPTOPP_API InitState(HashWordType *state);\n-\tstatic void CRYPTOPP_API Transform(word32 *digest, const word32 *data);\n-\tstatic const char * CRYPTOPP_API StaticAlgorithmName() {return \"SHA-1\";}\n-};\n-\n-typedef SHA1 SHA;\t// for backwards compatibility\n-\n-//! implements the SHA-256 standard\n-class CRYPTOPP_DLL SHA256 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA256, 32, true>\n-{\n-public:\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n-\tsize_t HashMultipleBlocks(const word32 *input, size_t length);\n-#endif\n-\tstatic void CRYPTOPP_API InitState(HashWordType *state);\n-\tstatic void CRYPTOPP_API Transform(word32 *digest, const word32 *data);\n-\tstatic const char * CRYPTOPP_API StaticAlgorithmName() {return \"SHA-256\";}\n-};\n-\n-//! implements the SHA-224 standard\n-class CRYPTOPP_DLL SHA224 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA224, 28, true>\n-{\n-public:\n-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n-\tsize_t HashMultipleBlocks(const word32 *input, size_t length);\n-#endif\n-\tstatic void CRYPTOPP_API InitState(HashWordType *state);\n-\tstatic void CRYPTOPP_API Transform(word32 *digest, const word32 *data) {SHA256::Transform(digest, data);}\n-\tstatic const char * CRYPTOPP_API StaticAlgorithmName() {return \"SHA-224\";}\n-};\n-\n-//! implements the SHA-512 standard\n-class CRYPTOPP_DLL SHA512 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA512, 64, CRYPTOPP_BOOL_X86>\n-{\n-public:\n-\tstatic void CRYPTOPP_API InitState(HashWordType *state);\n-\tstatic void CRYPTOPP_API Transform(word64 *digest, const word64 *data);\n-\tstatic const char * CRYPTOPP_API StaticAlgorithmName() {return \"SHA-512\";}\n-};\n-\n-//! implements the SHA-384 standard\n-class CRYPTOPP_DLL SHA384 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA384, 48, CRYPTOPP_BOOL_X86>\n-{\n-public:\n-\tstatic void CRYPTOPP_API InitState(HashWordType *state);\n-\tstatic void CRYPTOPP_API Transform(word64 *digest, const word64 *data) {SHA512::Transform(digest, data);}\n-\tstatic const char * CRYPTOPP_API StaticAlgorithmName() {return \"SHA-384\";}\n-};\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "8b137891791fe96927ad78e64b0aad7bded08bdc",
        "filename": "src/cryptopp/simple.h",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/simple.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/simple.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/simple.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1 +0,0 @@\n-"
      },
      {
        "sha": "6b4040e9996015e06e1575f72825952bfc376261",
        "filename": "src/cryptopp/smartptr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 223,
        "changes": 223,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/smartptr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/smartptr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/smartptr.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,223 +0,0 @@\n-#ifndef CRYPTOPP_SMARTPTR_H\n-#define CRYPTOPP_SMARTPTR_H\n-\n-#include \"config.h\"\n-#include <algorithm>\n-\n-NAMESPACE_BEGIN(CryptoPP)\n-\n-template <class T> class simple_ptr\n-{\n-public:\n-\tsimple_ptr() : m_p(NULL) {}\n-\t~simple_ptr() {delete m_p;}\n-\tT *m_p;\n-};\n-\n-template <class T> class member_ptr\n-{\n-public:\n-\texplicit member_ptr(T *p = NULL) : m_p(p) {}\n-\n-\t~member_ptr();\n-\n-\tconst T& operator*() const { return *m_p; }\n-\tT& operator*() { return *m_p; }\n-\n-\tconst T* operator->() const { return m_p; }\n-\tT* operator->() { return m_p; }\n-\n-\tconst T* get() const { return m_p; }\n-\tT* get() { return m_p; }\n-\n-\tT* release()\n-\t{\n-\t\tT *old_p = m_p;\n-\t\tm_p = 0;\n-\t\treturn old_p;\n-\t} \n-\n-\tvoid reset(T *p = 0);\n-\n-protected:\n-\tmember_ptr(const member_ptr<T>& rhs);\t\t// copy not allowed\n-\tvoid operator=(const member_ptr<T>& rhs);\t// assignment not allowed\n-\n-\tT *m_p;\n-};\n-\n-template <class T> member_ptr<T>::~member_ptr() {delete m_p;}\n-template <class T> void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n-\n-// ********************************************************\n-\n-template<class T> class value_ptr : public member_ptr<T>\n-{\n-public:\n-\tvalue_ptr(const T &obj) : member_ptr<T>(new T(obj)) {}\n-\tvalue_ptr(T *p = NULL) : member_ptr<T>(p) {}\n-\tvalue_ptr(const value_ptr<T>& rhs)\n-\t\t: member_ptr<T>(rhs.m_p ? new T(*rhs.m_p) : NULL) {}\n-\n-\tvalue_ptr<T>& operator=(const value_ptr<T>& rhs);\n-\tbool operator==(const value_ptr<T>& rhs)\n-\t{\n-\t\treturn (!this->m_p && !rhs.m_p) || (this->m_p && rhs.m_p && *this->m_p == *rhs.m_p);\n-\t}\n-};\n-\n-template <class T> value_ptr<T>& value_ptr<T>::operator=(const value_ptr<T>& rhs)\n-{\n-\tT *old_p = this->m_p;\n-\tthis->m_p = rhs.m_p ? new T(*rhs.m_p) : NULL;\n-\tdelete old_p;\n-\treturn *this;\n-}\n-\n-// ********************************************************\n-\n-template<class T> class clonable_ptr : public member_ptr<T>\n-{\n-public:\n-\tclonable_ptr(const T &obj) : member_ptr<T>(obj.Clone()) {}\n-\tclonable_ptr(T *p = NULL) : member_ptr<T>(p) {}\n-\tclonable_ptr(const clonable_ptr<T>& rhs)\n-\t\t: member_ptr<T>(rhs.m_p ? rhs.m_p->Clone() : NULL) {}\n-\n-\tclonable_ptr<T>& operator=(const clonable_ptr<T>& rhs);\n-};\n-\n-template <class T> clonable_ptr<T>& clonable_ptr<T>::operator=(const clonable_ptr<T>& rhs)\n-{\n-\tT *old_p = this->m_p;\n-\tthis->m_p = rhs.m_p ? rhs.m_p->Clone() : NULL;\n-\tdelete old_p;\n-\treturn *this;\n-}\n-\n-// ********************************************************\n-\n-template<class T> class counted_ptr\n-{\n-public:\n-\texplicit counted_ptr(T *p = 0);\n-\tcounted_ptr(const T &r) : m_p(0) {attach(r);}\n-\tcounted_ptr(const counted_ptr<T>& rhs);\n-\n-\t~counted_ptr();\n-\n-\tconst T& operator*() const { return *m_p; }\n-\tT& operator*() { return *m_p; }\n-\n-\tconst T* operator->() const { return m_p; }\n-\tT* operator->() { return get(); }\n-\n-\tconst T* get() const { return m_p; }\n-\tT* get();\n-\n-\tvoid attach(const T &p);\n-\n-\tcounted_ptr<T> & operator=(const counted_ptr<T>& rhs);\n-\n-private:\n-\tT *m_p;\n-};\n-\n-template <class T> counted_ptr<T>::counted_ptr(T *p)\n-\t: m_p(p) \n-{\n-\tif (m_p)\n-\t\tm_p->m_referenceCount = 1;\n-}\n-\n-template <class T> counted_ptr<T>::counted_ptr(const counted_ptr<T>& rhs)\n-\t: m_p(rhs.m_p)\n-{\n-\tif (m_p)\n-\t\tm_p->m_referenceCount++;\n-}\n-\n-template <class T> counted_ptr<T>::~counted_ptr()\n-{\n-\tif (m_p && --m_p->m_referenceCount == 0)\n-\t\tdelete m_p;\n-}\n-\n-template <class T> void counted_ptr<T>::attach(const T &r)\n-{\n-\tif (m_p && --m_p->m_referenceCount == 0)\n-\t\tdelete m_p;\n-\tif (r.m_referenceCount == 0)\n-\t{\n-\t\tm_p = r.clone();\n-\t\tm_p->m_referenceCount = 1;\n-\t}\n-\telse\n-\t{\n-\t\tm_p = const_cast<T *>(&r);\n-\t\tm_p->m_referenceCount++;\n-\t}\n-}\n-\n-template <class T> T* counted_ptr<T>::get()\n-{\n-\tif (m_p && m_p->m_referenceCount > 1)\n-\t{\n-\t\tT *temp = m_p->clone();\n-\t\tm_p->m_referenceCount--;\n-\t\tm_p = temp;\n-\t\tm_p->m_referenceCount = 1;\n-\t}\n-\treturn m_p;\n-}\n-\n-template <class T> counted_ptr<T> & counted_ptr<T>::operator=(const counted_ptr<T>& rhs)\n-{\n-\tif (m_p != rhs.m_p)\n-\t{\n-\t\tif (m_p && --m_p->m_referenceCount == 0)\n-\t\t\tdelete m_p;\n-\t\tm_p = rhs.m_p;\n-\t\tif (m_p)\n-\t\t\tm_p->m_referenceCount++;\n-\t}\n-\treturn *this;\n-}\n-\n-// ********************************************************\n-\n-template <class T> class vector_member_ptrs\n-{\n-public:\n-\tvector_member_ptrs(size_t size=0)\n-\t\t: m_size(size), m_ptr(new member_ptr<T>[size]) {}\n-\t~vector_member_ptrs()\n-\t\t{delete [] this->m_ptr;}\n-\n-\tmember_ptr<T>& operator[](size_t index)\n-\t\t{assert(index<this->m_size); return this->m_ptr[index];}\n-\tconst member_ptr<T>& operator[](size_t index) const\n-\t\t{assert(index<this->m_size); return this->m_ptr[index];}\n-\n-\tsize_t size() const {return this->m_size;}\n-\tvoid resize(size_t newSize)\n-\t{\n-\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n-\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n-\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n-\t\tdelete [] this->m_ptr;\n-\t\tthis->m_size = newSize;\n-\t\tthis->m_ptr = newPtr;\n-\t}\n-\n-private:\n-\tvector_member_ptrs(const vector_member_ptrs<T> &c);\t// copy not allowed\n-\tvoid operator=(const vector_member_ptrs<T> &x);\t\t// assignment not allowed\n-\n-\tsize_t m_size;\n-\tmember_ptr<T> *m_ptr;\n-};\n-\n-NAMESPACE_END\n-\n-#endif"
      },
      {
        "sha": "9a468ab61ef77c704654450cb49302a0520016e3",
        "filename": "src/cryptopp/stdcpp.h",
        "status": "removed",
        "additions": 0,
        "deletions": 27,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/stdcpp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4769e44a326f61bdf47fa39346e1293b97e31c4/src/cryptopp/stdcpp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cryptopp/stdcpp.h?ref=f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "patch": "@@ -1,27 +0,0 @@\n-#ifndef CRYPTOPP_STDCPP_H\n-#define CRYPTOPP_STDCPP_H\n-\n-#include <stddef.h>\n-#include <assert.h>\n-#include <limits.h>\n-#include <memory>\n-#include <string>\n-#include <exception>\n-#include <typeinfo>\n-\n-\n-#ifdef _MSC_VER\n-#include <string.h>\t// CodeWarrior doesn't have memory.h\n-#include <algorithm>\n-#include <map>\n-#include <vector>\n-\n-// re-disable this\n-#pragma warning(disable: 4231)\n-#endif\n-\n-#if defined(_MSC_VER) && defined(_CRTAPI1)\n-#define CRYPTOPP_MSVCRT6\n-#endif\n-\n-#endif"
      },
      {
        "sha": "f157710816f638404935d7f9acffe9e81827539c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -6,7 +6,6 @@\n #include \"db.h\"\n #include \"net.h\"\n #include \"init.h\"\n-#include \"cryptopp/sha.h\"\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n \n@@ -2614,15 +2613,25 @@ int static FormatHashBlocks(void* pbuffer, unsigned int len)\n     return blocks;\n }\n \n-using CryptoPP::ByteReverse;\n-\n static const unsigned int pSHA256InitState[8] =\n {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n \n-inline void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n+void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n {\n-    memcpy(pstate, pinit, 32);\n-    CryptoPP::SHA256::Transform((CryptoPP::word32*)pstate, (CryptoPP::word32*)pinput);\n+    SHA256_CTX ctx;\n+    unsigned char data[64];\n+\n+    SHA256_Init(&ctx);\n+\n+    for (int i = 0; i < 16; i++)\n+        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n+\n+    for (int i = 0; i < 8; i++)\n+        ctx.h[i] = ((uint32_t*)pinit)[i];\n+\n+    SHA256_Update(&ctx, data, sizeof(data));\n+    for (int i = 0; i < 8; i++) \n+        ((uint32_t*)pstate)[i] = ctx.h[i];\n }\n \n //"
      },
      {
        "sha": "b8ca9e6a1e0cda07592847ed45b5d3a689054c01",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -51,6 +51,7 @@ HEADERS = \\\n     util.h \\\n     wallet.h\n \n+\n ifdef USE_UPNP\n \tLIBPATHS += -L\"$(DEPSDIR)/miniupnpc\"\n \tLIBS += -l miniupnpc -l iphlpapi\n@@ -71,16 +72,10 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/script.o \\\n     obj/util.o \\\n-    obj/wallet.o \\\n-    cryptopp/obj/sha.o \\\n-    cryptopp/obj/cpu.o\n-\n+    obj/wallet.o\n \n all: bitcoind.exe\n \n-cryptopp/obj/%.o: cryptopp/%.cpp\n-\ti586-mingw32msvc-g++ -c $(CFLAGS) -O3 -DCRYPTOPP_DISABLE_ASM -o $@ $<\n-\n obj/nogui/%.o: %.cpp $(HEADERS)\n \ti586-mingw32msvc-g++ -c $(CFLAGS) -o $@ $<\n \n@@ -99,7 +94,6 @@ clean:\n \t-rm -f obj/*.o\n \t-rm -f obj/nogui/*.o\n \t-rm -f obj/test/*.o\n-\t-rm -f cryptopp/obj/*.o\n \t-rm -f test/*.o\n \t-rm -f headers.h.gch\n \t-rm -f bitcoind.exe"
      },
      {
        "sha": "73d3940a5c52f7b5a16e7a2e82a1fe834c392e9c",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -69,16 +69,11 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/script.o \\\n     obj/util.o \\\n-    obj/wallet.o \\\n-    cryptopp/obj/sha.o \\\n-    cryptopp/obj/cpu.o\n+    obj/wallet.o\n \n \n all: bitcoind.exe\n \n-cryptopp/obj/%.o: cryptopp/%.cpp\n-\tg++ -c $(CFLAGS) -O3 -DCRYPTOPP_DISABLE_ASM -o $@ $<\n-\n obj/nogui/%.o: %.cpp $(HEADERS)\n \tg++ -c $(CFLAGS) -o $@ $<\n \n@@ -96,6 +91,5 @@ clean:\n \t-del /Q obj\\*\n \t-del /Q obj\\nogui\\*\n \t-del /Q obj\\test\\*\n-\t-del /Q cryptopp\\obj\\*\n \t-del /Q test\\*.o\n \t-del /Q headers.h.gch"
      },
      {
        "sha": "f9de4d709165a2d4ff9f6e12d7bd8928c61ae203",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -64,9 +64,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/script.o \\\n     obj/util.o \\\n-    obj/wallet.o \\\n-    cryptopp/obj/sha.o \\\n-    cryptopp/obj/cpu.o\n+    obj/wallet.o\n \n ifdef USE_UPNP\n \tLIBS += $(DEPSDIR)/lib/libminiupnpc.a\n@@ -76,9 +74,6 @@ endif\n \n all: bitcoind\n \n-cryptopp/obj/%.o: cryptopp/%.cpp\n-\t$(CXX) -c $(CFLAGS) -O3 -DCRYPTOPP_DISABLE_ASM -o $@ $<\n-\n obj/nogui/%.o: %.cpp $(HEADERS)\n \t$(CXX) -c $(CFLAGS) -o $@ $<\n \n@@ -96,4 +91,3 @@ clean:\n \t-rm -f obj/*.o\n \t-rm -f obj/nogui/*.o\n \t-rm -f obj/test/*.o\n-\t-rm -f cryptopp/obj/*.o"
      },
      {
        "sha": "f9f03b3aa8d70595ac120331e8be1b9207a98e30",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -96,17 +96,12 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/script.o \\\n     obj/util.o \\\n-    obj/wallet.o \\\n-    cryptopp/obj/sha.o \\\n-    cryptopp/obj/cpu.o\n+    obj/wallet.o\n \n \n all: bitcoind\n \n \n-cryptopp/obj/%.o: cryptopp/%.cpp\n-\t$(CXX) -c $(CFLAGS) -O3 -o $@ $<\n-\n obj/nogui/%.o: %.cpp $(HEADERS)\n \t$(CXX) -c $(CXXFLAGS) -o $@ $<\n \n@@ -124,5 +119,4 @@ clean:\n \t-rm -f obj/*.o\n \t-rm -f obj/nogui/*.o\n \t-rm -f obj/test/*.o\n-\t-rm -f cryptopp/obj/*.o\n \t-rm -f headers.h.gch"
      },
      {
        "sha": "c7e8578a95e0b3f6095d3b0bfa45ecea1d149e22",
        "filename": "src/makefile.vc",
        "status": "modified",
        "additions": 2,
        "deletions": 15,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.vc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/makefile.vc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.vc?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -76,13 +76,7 @@ OBJS= \\\n     obj\\protocol.o \\\n     obj\\script.o \\\n     obj\\util.o \\\n-    obj\\wallet.o \\\n-    cryptopp\\obj\\sha.o \\\n-    cryptopp\\obj\\cpu.o\n-\n-CRYPTOPP_OBJS= \\\n-    cryptopp\\obj\\sha.obj \\\n-    cryptopp\\obj\\cpu.obj\n+    obj\\wallet.o\n \n RC=../share\n \n@@ -119,12 +113,6 @@ obj\\ui.obj: $(HEADERS)\n \n obj\\uibase.obj: $(HEADERS)\n \n-cryptopp\\obj\\sha.obj: cryptopp\\sha.cpp\n-    cl $(CFLAGS) /O2 /DCRYPTOPP_DISABLE_ASM /Fo$@ %s\n-\n-cryptopp\\obj\\cpu.obj: cryptopp\\cpu.cpp\n-    cl $(CFLAGS) /O2 /DCRYPTOPP_DISABLE_ASM /Fo$@ %s\n-\n .cpp{obj\\nogui}.obj:\n     cl $(CFLAGS) /Fo$@ %s\n \n@@ -148,13 +136,12 @@ obj\\nogui\\rpc.obj: $(HEADERS)\n \n obj\\nogui\\init.obj: $(HEADERS)\n \n-bitcoind.exe: $(OBJS:obj\\=obj\\nogui\\) $(CRYPTOPP_OBJS) obj\\ui.res\n+bitcoind.exe: $(OBJS:obj\\=obj\\nogui\\) obj\\ui.res\n     link /nologo /OUT:$@ $(LIBPATHS) $** $(LIBS)\n \n clean:\n     -del /Q obj\\*\n     -del /Q obj\\nogui\\*\n-    -del /Q cryptopp\\obj\\*\n     -del /Q *.ilk\n     -del /Q *.pdb\n     -del /Q bitcoind.exe"
      },
      {
        "sha": "e773542d717db0b70124f50da9bab5ff495428e3",
        "filename": "src/test/miner_tests.cpp",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -0,0 +1,35 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"../uint256.h\"\n+\n+extern void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n+\n+BOOST_AUTO_TEST_SUITE(miner_tests)\n+\n+BOOST_AUTO_TEST_CASE(sha256transform_equality)\n+{\n+    unsigned int pSHA256InitState[8] = {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n+\n+\n+    unsigned char pstate[32];\n+    unsigned char pinput[32];\n+\n+    int i;\n+\n+    for (i = 0; i < 32; i++) {\n+        pinput[i] = i;\n+        pstate[i] = 0;\n+    }\n+\n+    uint256 hash;\n+\n+    SHA256Transform(&hash, pinput, pSHA256InitState);\n+\n+\t\tBOOST_TEST_MESSAGE(hash.GetHex());\n+\n+    uint256 hash_reference(\"0x2df5e1c65ef9f8cde240d23cae2ec036d31a15ec64bc68f64be242b1da6631f3\");\n+\n+    BOOST_CHECK(hash == hash_reference);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4c9f7cc87298c13972139d3d3fa4cb92afc65f96",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -10,10 +10,11 @@\n #include \"transaction_tests.cpp\"\n #include \"DoS_tests.cpp\"\n #include \"base64_tests.cpp\"\n+#include \"miner_tests.cpp\"\n \n CWallet* pwalletMain;\n \n void Shutdown(void* parg)\n {\n-\texit(0);\n+  exit(0);\n }"
      },
      {
        "sha": "14853a0a2ec76c331f3db5c47c37766782270d10",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -726,4 +726,29 @@ inline bool AffinityBugWorkaround(void(*pfn)(void*))\n     return false;\n }\n \n+template <class T> inline T rotlFixed(T x, unsigned int y)\n+{\n+\tassert(y < sizeof(T)*8);\n+\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n+}\n+\n+template <class T> inline T rotrFixed(T x, unsigned int y)\n+{\n+\tassert(y < sizeof(T)*8);\n+\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n+}\n+\n+inline uint32_t ByteReverse(uint32_t value)\n+{\n+#if defined(__MWERKS__) && TARGET_CPU_PPC\n+\treturn (uint32_t)__lwbrx(&value,0);\n+#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))\n+\treturn _byteswap_ulong(value);\n+#else\n+\t// 6 instructions with rotate instruction, 8 without\n+\tvalue = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n+\treturn rotlFixed(value, 16U);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "30a561dcb454c56d667fb298b000fb2678b10907",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ccff2cbdebca38e4913b679784a4865edfbb12a/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "patch": "@@ -5,7 +5,6 @@\n \n #include \"headers.h\"\n #include \"db.h\"\n-#include \"cryptopp/sha.h\"\n #include \"crypter.h\"\n \n using namespace std;"
      }
    ]
  },
  {
    "sha": "452506fc4153be072fe443fe3e3cbf76d9563a42",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTI1MDZmYzQxNTNiZTA3MmZlNDQzZmUzZTNjYmY3NmQ5NTYzYTQy",
    "commit": {
      "author": {
        "name": "Nils Schneider",
        "email": "nils.schneider@gmail.com",
        "date": "2011-09-30T14:23:26Z"
      },
      "committer": {
        "name": "Nils Schneider",
        "email": "nils.schneider@gmail.com",
        "date": "2011-09-30T18:00:30Z"
      },
      "message": "simpler ByteReverse",
      "tree": {
        "sha": "fa05694eb45068da2d54f8c33c0131cb68e617d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa05694eb45068da2d54f8c33c0131cb68e617d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/452506fc4153be072fe443fe3e3cbf76d9563a42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/452506fc4153be072fe443fe3e3cbf76d9563a42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/452506fc4153be072fe443fe3e3cbf76d9563a42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/452506fc4153be072fe443fe3e3cbf76d9563a42/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ccff2cbdebca38e4913b679784a4865edfbb12a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6ccff2cbdebca38e4913b679784a4865edfbb12a"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 1,
      "deletions": 20
    },
    "files": [
      {
        "sha": "c05143becee3ff953b998e5866983aa83c3c9080",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 20,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/452506fc4153be072fe443fe3e3cbf76d9563a42/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/452506fc4153be072fe443fe3e3cbf76d9563a42/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=452506fc4153be072fe443fe3e3cbf76d9563a42",
        "patch": "@@ -726,29 +726,10 @@ inline bool AffinityBugWorkaround(void(*pfn)(void*))\n     return false;\n }\n \n-template <class T> inline T rotlFixed(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n-}\n-\n-template <class T> inline T rotrFixed(T x, unsigned int y)\n-{\n-\tassert(y < sizeof(T)*8);\n-\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n-}\n-\n inline uint32_t ByteReverse(uint32_t value)\n {\n-#if defined(__MWERKS__) && TARGET_CPU_PPC\n-\treturn (uint32_t)__lwbrx(&value,0);\n-#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))\n-\treturn _byteswap_ulong(value);\n-#else\n-\t// 6 instructions with rotate instruction, 8 without\n \tvalue = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n-\treturn rotlFixed(value, 16U);\n-#endif\n+\treturn (value<<16) | (value>>16);\n }\n \n #endif"
      }
    ]
  }
]