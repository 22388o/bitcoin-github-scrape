[
  {
    "sha": "151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTFmM2U5Y2YxYmJjZjMwYTRmYzc3NDk2ODJlNjZiNGE3M2RkZmMy",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-04-11T20:54:47Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-04-22T12:10:05Z"
      },
      "message": "Add settings merge test to prevent regresssions",
      "tree": {
        "sha": "a8891bd5c6fb052315fc024e0408e9aa047b219b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8891bd5c6fb052315fc024e0408e9aa047b219b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "08bd21a3bda9f621948c535e951880d7e318caa5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08bd21a3bda9f621948c535e951880d7e318caa5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/08bd21a3bda9f621948c535e951880d7e318caa5"
      }
    ],
    "stats": {
      "total": 229,
      "additions": 229,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0f1834240d0cfd0bfa90bfe4d48ba8d78e350e07",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 229,
        "deletions": 0,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=151f3e9cf1bbcf30a4fc7749682e66b4a73ddfc2",
        "patch": "@@ -158,6 +158,9 @@ struct TestArgsManager : public ArgsManager\n             AddArg(args[i], \"\", false, OptionsCategory::OPTIONS);\n         }\n     }\n+    using ArgsManager::ReadConfigStream;\n+    using ArgsManager::cs_args;\n+    using ArgsManager::m_network;\n };\n \n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n@@ -575,6 +578,232 @@ BOOST_AUTO_TEST_CASE(util_GetChainName)\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n }\n \n+// Test different ways settings can be merged, and verify results. This test can\n+// be used to confirm that updates to settings code don't change behavior\n+// unintentially.\n+//\n+// The test covers:\n+//\n+// - Combining different setting actions. Possible actions are: configuring a\n+//   setting, negating a setting (adding \"-no\" prefix), and configuring/negating\n+//   settings in a network section (adding \"main.\" or \"test.\" prefixes).\n+//\n+// - Combining settings from command line arguments and a config file.\n+//\n+// - Combining SoftSet and ForceSet calls.\n+//\n+// - Testing \"main\" and \"test\" network values to make sure settings from network\n+//   sections are applied and to check for mainnet-specific behaviors like\n+//   inheriting settings from the default section.\n+//\n+// - Testing network-specific settings like \"-wallet\", that may be ignored\n+//   outside a network section, and non-network specific settings like \"-server\"\n+//   that aren't sensitive to the network.\n+//\n+struct SettingsMergeTestingSetup : public BasicTestingSetup {\n+    //! Max number of actions to sequence together. Can decrease this when\n+    //! debugging to make test results easier to understand.\n+    static constexpr int MAX_ACTIONS = 3;\n+\n+    enum Action { SET = 0, NEGATE, SECTION_SET, SECTION_NEGATE, END };\n+    using ActionList = Action[MAX_ACTIONS];\n+\n+    //! Enumerate all possible test configurations.\n+    template <typename Fn>\n+    void ForEachMergeSetup(Fn&& fn)\n+    {\n+        ForEachActionList([&](const ActionList& arg_actions) {\n+            ForEachActionList([&](const ActionList& conf_actions) {\n+                for (bool soft_set : {false, true}) {\n+                    for (bool force_set : {false, true}) {\n+                        for (const std::string& section : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n+                            for (const std::string& network : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n+                                for (bool net_specific : {false, true}) {\n+                                    fn(arg_actions, conf_actions, soft_set, force_set, section, network, net_specific);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    //! Enumerate interesting combinations of actions.\n+    template <typename Fn>\n+    void ForEachActionList(Fn&& fn)\n+    {\n+        ActionList actions = {SET};\n+        for (bool done = false; !done;) {\n+            int prev_action = -1;\n+            bool skip_actions = false;\n+            for (Action action : actions) {\n+                if ((prev_action == END && action != END) || (prev_action != END && action == prev_action)) {\n+                    // To cut down list of enumerated settings, skip enumerating\n+                    // settings with ignored actions after an END, and settings that\n+                    // repeat the same action twice in a row.\n+                    skip_actions = true;\n+                    break;\n+                }\n+                prev_action = action;\n+            }\n+            if (!skip_actions) fn(actions);\n+            done = true;\n+            for (Action& action : actions) {\n+                action = Action(action < END ? action + 1 : 0);\n+                if (action) {\n+                    done = false;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    //! Translate actions into a list of <key>=<value> setting strings.\n+    std::vector<std::string> GetValues(const ActionList& actions,\n+        const std::string& section,\n+        const std::string& name,\n+        const std::string& value_prefix)\n+    {\n+        std::vector<std::string> values;\n+        int suffix = 0;\n+        for (Action action : actions) {\n+            if (action == END) break;\n+            std::string prefix;\n+            if (action == SECTION_SET || action == SECTION_NEGATE) prefix = section + \".\";\n+            if (action == SET || action == SECTION_SET) {\n+                for (int i = 0; i < 2; ++i) {\n+                    values.push_back(prefix + name + \"=\" + value_prefix + std::to_string(++suffix));\n+                }\n+            }\n+            if (action == NEGATE || action == SECTION_NEGATE) {\n+                values.push_back(prefix + \"no\" + name + \"=1\");\n+            }\n+        }\n+        return values;\n+    }\n+};\n+\n+// Regression test covering different ways config settings can be merged. The\n+// test parses and merges settings, representing the results as strings that get\n+// compared against an expected hash. To debug, the result strings can be dumped\n+// to a file (see below).\n+BOOST_FIXTURE_TEST_CASE(util_SettingsMerge, SettingsMergeTestingSetup)\n+{\n+    CHash256 out_sha;\n+    FILE* out_file = nullptr;\n+    if (const char* out_path = getenv(\"SETTINGS_MERGE_TEST_OUT\")) {\n+        out_file = fsbridge::fopen(out_path, \"w\");\n+        if (!out_file) throw std::system_error(errno, std::generic_category(), \"fopen failed\");\n+    }\n+\n+    ForEachMergeSetup([&](const ActionList& arg_actions, const ActionList& conf_actions, bool soft_set, bool force_set,\n+                          const std::string& section, const std::string& network, bool net_specific) {\n+        TestArgsManager parser;\n+        LOCK(parser.cs_args);\n+\n+        std::string desc = \"net=\";\n+        desc += network;\n+        parser.m_network = network;\n+\n+        const std::string& name = net_specific ? \"server\" : \"wallet\";\n+        const std::string key = \"-\" + name;\n+        parser.AddArg(key, name, false, OptionsCategory::OPTIONS);\n+        if (net_specific) parser.SetNetworkOnlyArg(key);\n+\n+        auto args = GetValues(arg_actions, section, name, \"a\");\n+        std::vector<const char*> argv = {\"ignored\"};\n+        for (auto& arg : args) {\n+            arg.insert(0, \"-\");\n+            desc += \" \";\n+            desc += arg;\n+            argv.push_back(arg.c_str());\n+        }\n+        std::string error;\n+        BOOST_CHECK(parser.ParseParameters(argv.size(), argv.data(), error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        std::string conf;\n+        for (auto& conf_val : GetValues(conf_actions, section, name, \"c\")) {\n+            desc += \" \";\n+            desc += conf_val;\n+            conf += conf_val;\n+            conf += \"\\n\";\n+        }\n+        std::istringstream conf_stream(conf);\n+        BOOST_CHECK(parser.ReadConfigStream(conf_stream, \"filepath\", error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        if (soft_set) {\n+            desc += \" soft\";\n+            parser.SoftSetArg(key, \"soft1\");\n+            parser.SoftSetArg(key, \"soft2\");\n+        }\n+\n+        if (force_set) {\n+            desc += \" force\";\n+            parser.ForceSetArg(key, \"force1\");\n+            parser.ForceSetArg(key, \"force2\");\n+        }\n+\n+        desc += \" || \";\n+\n+        if (!parser.IsArgSet(key)) {\n+            desc += \"unset\";\n+            BOOST_CHECK(!parser.IsArgNegated(key));\n+            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"default\");\n+            BOOST_CHECK(parser.GetArgs(key).empty());\n+        } else if (parser.IsArgNegated(key)) {\n+            desc += \"negated\";\n+            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"0\");\n+            BOOST_CHECK(parser.GetArgs(key).empty());\n+        } else {\n+            desc += parser.GetArg(key, \"default\");\n+            desc += \" |\";\n+            for (const auto& arg : parser.GetArgs(key)) {\n+                desc += \" \";\n+                desc += arg;\n+            }\n+        }\n+\n+        std::set<std::string> ignored = parser.GetUnsuitableSectionOnlyArgs();\n+        if (!ignored.empty()) {\n+            desc += \" | ignored\";\n+            for (const auto& arg : ignored) {\n+                desc += \" \";\n+                desc += arg;\n+            }\n+        }\n+\n+        desc += \"\\n\";\n+\n+        out_sha.Write((const unsigned char*)desc.data(), desc.size());\n+        if (out_file) {\n+            BOOST_REQUIRE(fwrite(desc.data(), 1, desc.size(), out_file) == desc.size());\n+        }\n+    });\n+\n+    if (out_file) {\n+        if (fclose(out_file)) throw std::system_error(errno, std::generic_category(), \"fclose failed\");\n+        out_file = nullptr;\n+    }\n+\n+    unsigned char out_sha_bytes[CSHA256::OUTPUT_SIZE];\n+    out_sha.Finalize(out_sha_bytes);\n+    std::string out_sha_hex = HexStr(std::begin(out_sha_bytes), std::end(out_sha_bytes));\n+\n+    // If check below fails, should manually dump the results with:\n+    //\n+    //   SETTINGS_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_SettingsMerge\n+    //\n+    // And verify diff against previous results to make sure the changes are expected.\n+    //\n+    // Results file is formatted like:\n+    //\n+    //   <input> || <IsArgSet/IsArgNegated/GetArg output> | <GetArgs output> | <GetUnsuitable output>\n+    BOOST_CHECK_EQUAL(out_sha_hex, \"80964e17fbd3c5569d3c824d032e28e2d319ef57494735b0e76eb7aad9957f2c\");\n+}\n+\n BOOST_AUTO_TEST_CASE(util_FormatMoney)\n {\n     BOOST_CHECK_EQUAL(FormatMoney(0), \"0.00\");"
      }
    ]
  }
]