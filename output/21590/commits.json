[
  {
    "sha": "bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
    "node_id": "C_kwDOABII59oAKGJkOTBhMWEwN2M4OTYyZTA0ZGE4ZjJhYTFjNWIyNTYyZTkxYWFlNzU",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-01-13T20:09:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-12-01T16:44:08Z"
      },
      "message": "Add benchmark for MuHash finalization",
      "tree": {
        "sha": "c0d47106c9de423821fb28848ba098f3492af87f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c0d47106c9de423821fb28848ba098f3492af87f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e7507f333bc93047d0baadea4fde19f770dacb56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7507f333bc93047d0baadea4fde19f770dacb56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e7507f333bc93047d0baadea4fde19f770dacb56"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5416a109c8174dfd5e110399a62a61b217a73b11",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
        "patch": "@@ -150,6 +150,19 @@ static void MuHashPrecompute(benchmark::Bench& bench)\n     });\n }\n \n+static void MuHashFinalize(benchmark::Bench& bench)\n+{\n+    FastRandomContext rng(true);\n+    MuHash3072 acc{rng.randbytes(32)};\n+    acc /= MuHash3072{rng.rand256()};\n+\n+    bench.run([&] {\n+        uint256 out;\n+        acc.Finalize(out);\n+        acc /= MuHash3072{out};\n+    });\n+}\n+\n BENCHMARK(RIPEMD160);\n BENCHMARK(SHA1);\n BENCHMARK(SHA256);\n@@ -166,3 +179,4 @@ BENCHMARK(MuHash);\n BENCHMARK(MuHashMul);\n BENCHMARK(MuHashDiv);\n BENCHMARK(MuHashPrecompute);\n+BENCHMARK(MuHashFinalize);"
      }
    ]
  },
  {
    "sha": "76d0a5b011d2f70100e417eca2f342b91b6688e0",
    "node_id": "C_kwDOABII59oAKDc2ZDBhNWIwMTFkMmY3MDEwMGU0MTdlY2EyZjM0MmI5MWI2Njg4ZTA",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-01-13T21:56:51Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-12-01T16:45:33Z"
      },
      "message": "Safegcd based modular inverse for Num3072",
      "tree": {
        "sha": "616f01ad582b6a73838aed89a53e9e11113afa3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/616f01ad582b6a73838aed89a53e9e11113afa3b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/76d0a5b011d2f70100e417eca2f342b91b6688e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d0a5b011d2f70100e417eca2f342b91b6688e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/76d0a5b011d2f70100e417eca2f342b91b6688e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d0a5b011d2f70100e417eca2f342b91b6688e0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd90a1a07c8962e04da8f2aa1c5b2562e91aae75"
      }
    ],
    "stats": {
      "total": 483,
      "additions": 393,
      "deletions": 90
    },
    "files": [
      {
        "sha": "469f89a5ee7a8bcf28fe223e8555d5edce04f00d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76d0a5b011d2f70100e417eca2f342b91b6688e0/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76d0a5b011d2f70100e417eca2f342b91b6688e0/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=76d0a5b011d2f70100e417eca2f342b91b6688e0",
        "patch": "@@ -977,6 +977,30 @@ AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n                  #include <byteswap.h>\n                  #endif])\n \n+AC_MSG_CHECKING([for __builtin_ctz])\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ ]], [[\n+ (void) __builtin_clz(0);\n+  ]])],\n+ [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_BUILTIN_CTZ, [1], [Define this symbol if you have __builtin_ctz])],\n+ [ AC_MSG_RESULT([no])]\n+)\n+\n+AC_MSG_CHECKING([for __builtin_ctzl])\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ ]], [[\n+ (void) __builtin_ctzl(0);\n+  ]])],\n+ [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_BUILTIN_CTZL, [1], [Define this symbol if you have __builtin_ctzl])],\n+ [ AC_MSG_RESULT([no])]\n+)\n+\n+AC_MSG_CHECKING([for __builtin_ctzll])\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ ]], [[\n+ (void) __builtin_ctzll(0);\n+  ]])],\n+ [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_BUILTIN_CTZLL, [1], [Define this symbol if you have __builtin_ctzll])],\n+ [ AC_MSG_RESULT([no])]\n+)\n+\n AC_MSG_CHECKING([for __builtin_clzl])\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ ]], [[\n  (void) __builtin_clzl(0);"
      },
      {
        "sha": "4b01ff599fc8e07dd720e3702b1caf03ffae4dbb",
        "filename": "src/crypto/muhash.cpp",
        "status": "modified",
        "additions": 359,
        "deletions": 89,
        "changes": 448,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76d0a5b011d2f70100e417eca2f342b91b6688e0/src/crypto/muhash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76d0a5b011d2f70100e417eca2f342b91b6688e0/src/crypto/muhash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/muhash.cpp?ref=76d0a5b011d2f70100e417eca2f342b91b6688e0",
        "patch": "@@ -15,8 +15,15 @@\n namespace {\n \n using limb_t = Num3072::limb_t;\n+using signed_limb_t = Num3072::signed_limb_t;\n using double_limb_t = Num3072::double_limb_t;\n+using signed_double_limb_t = Num3072::signed_double_limb_t;\n constexpr int LIMB_SIZE = Num3072::LIMB_SIZE;\n+constexpr int SIGNED_LIMB_SIZE = Num3072::SIGNED_LIMB_SIZE;\n+constexpr int LIMBS = Num3072::LIMBS;\n+constexpr int SIGNED_LIMBS = Num3072::SIGNED_LIMBS;\n+constexpr limb_t MAX_LIMB = (limb_t)(-1);\n+constexpr limb_t MAX_SIGNED_LIMB = (((limb_t)1) << SIGNED_LIMB_SIZE) - 1;\n /** 2^3072 - 1103717, the largest 3072-bit safe prime number, is used as the modulus. */\n constexpr limb_t MAX_PRIME_DIFF = 1103717;\n \n@@ -72,23 +79,6 @@ inline void muladd3(limb_t& c0, limb_t& c1, limb_t& c2, const limb_t& a, const l\n     c2 += (c1 < th) ? 1 : 0;\n }\n \n-/** [c0,c1,c2] += 2 * a * b */\n-inline void muldbladd3(limb_t& c0, limb_t& c1, limb_t& c2, const limb_t& a, const limb_t& b)\n-{\n-    double_limb_t t = (double_limb_t)a * b;\n-    limb_t th = t >> LIMB_SIZE;\n-    limb_t tl = t;\n-\n-    c0 += tl;\n-    limb_t tt = th + ((c0 < tl) ? 1 : 0);\n-    c1 += tt;\n-    c2 += (c1 < tt) ? 1 : 0;\n-    c0 += tl;\n-    th += (c0 < tl) ? 1 : 0;\n-    c1 += th;\n-    c2 += (c1 < th) ? 1 : 0;\n-}\n-\n /**\n  * Add limb a to [c0,c1]: [c0,c1] += a. Then extract the lowest\n  * limb of [c0,c1] into n, and left shift the number by 1 limb.\n@@ -103,8 +93,7 @@ inline void addnextract2(limb_t& c0, limb_t& c1, const limb_t& a, limb_t& n)\n         c1 += 1;\n \n         // Handle case when c1 has overflown\n-        if (c1 == 0)\n-            c2 = 1;\n+        if (c1 == 0) c2 = 1;\n     }\n \n     // extract\n@@ -113,13 +102,6 @@ inline void addnextract2(limb_t& c0, limb_t& c1, const limb_t& a, limb_t& n)\n     c1 = c2;\n }\n \n-/** in_out = in_out^(2^sq) * mul */\n-inline void square_n_mul(Num3072& in_out, const int sq, const Num3072& mul)\n-{\n-    for (int j = 0; j < sq; ++j) in_out.Square();\n-    in_out.Multiply(mul);\n-}\n-\n } // namespace\n \n /** Indicates whether d is larger than the modulus. */\n@@ -141,98 +123,386 @@ void Num3072::FullReduce()\n     }\n }\n \n-Num3072 Num3072::GetInverse() const\n+namespace {\n+/** A type representing a number in signed limb representation. */\n+struct Num3072Signed\n {\n-    // For fast exponentiation a sliding window exponentiation with repunit\n-    // precomputation is utilized. See \"Fast Point Decompression for Standard\n-    // Elliptic Curves\" (Brumley, J\u00e4rvinen, 2008).\n+    /** The represented value is sum(limbs[i]*2^(SIGNED_LIMB_SIZE*i), i=0..SIGNED_LIMBS-1).\n+     *  Note that limbs may be negative, or exceed 2^SIGNED_LIMB_SIZE-1. */\n+    signed_limb_t limbs[SIGNED_LIMBS];\n+\n+    /** Construct a Num3072Signed with value 0. */\n+    Num3072Signed()\n+    {\n+        memset(limbs, 0, sizeof(limbs));\n+    }\n \n-    Num3072 p[12]; // p[i] = a^(2^(2^i)-1)\n-    Num3072 out;\n+    /** Convert a Num3072 to a Num3072Signed. Output will be normalized and in\n+     *  range 0..2^3072-1. */\n+    void FromNum3072(const Num3072& in)\n+    {\n+        double_limb_t c = 0;\n+        int b = 0, outpos = 0;\n+        for (int i = 0; i < LIMBS; ++i) {\n+            c += ((double_limb_t)in.limbs[i]) << b;\n+            b += LIMB_SIZE;\n+            while (b >= SIGNED_LIMB_SIZE) {\n+                limbs[outpos++] = (limb_t)c & MAX_SIGNED_LIMB;\n+                c >>= SIGNED_LIMB_SIZE;\n+                b -= SIGNED_LIMB_SIZE;\n+            }\n+        }\n+        assert(outpos == SIGNED_LIMBS - 1);\n+        limbs[SIGNED_LIMBS - 1] = c;\n+        c >>= SIGNED_LIMB_SIZE;\n+        assert(c == 0);\n+    }\n \n-    p[0] = *this;\n+    /** Convert a Num3072Signed to a Num3072. Input must be in range 0..modulus-1. */\n+    void ToNum3072(Num3072& out) const\n+    {\n+        double_limb_t c = 0;\n+        int b = 0, outpos = 0;\n+        for (int i = 0; i < SIGNED_LIMBS; ++i) {\n+            c += ((double_limb_t)limbs[i]) << b;\n+            b += SIGNED_LIMB_SIZE;\n+            if (b >= LIMB_SIZE) {\n+                out.limbs[outpos++] = (limb_t)c;\n+                c >>= LIMB_SIZE;\n+                b -= LIMB_SIZE;\n+            }\n+        }\n+        assert(outpos == LIMBS);\n+        assert(c == 0);\n+    }\n \n-    for (int i = 0; i < 11; ++i) {\n-        p[i + 1] = p[i];\n-        for (int j = 0; j < (1 << i); ++j) p[i + 1].Square();\n-        p[i + 1].Multiply(p[i]);\n+    /** Take a Num3072Signed in range 1-2*2^3072..2^3072-1, and:\n+     *  - optionally negate it (if negate is true)\n+     *  - reduce it modulo the modulus (2^3072 - MAX_PRIME_DIFF)\n+     *  - produce output with all limbs in range 0..2^SIGNED_LIMB_SIZE-1\n+     */\n+    void Normalize(bool negate)\n+    {\n+        // Add modulus if this was negative. This brings the range of *this to 1-2^3072..2^3072-1.\n+        signed_limb_t cond_add = limbs[SIGNED_LIMBS-1] >> (LIMB_SIZE-1); // -1 if this is negative; 0 otherwise\n+        limbs[0] += signed_limb_t(-MAX_PRIME_DIFF) & cond_add;\n+        limbs[3072 / SIGNED_LIMB_SIZE] += (signed_limb_t(1) << (3072 % SIGNED_LIMB_SIZE)) & cond_add;\n+        // Next negate all limbs if negate was set. This does not change the range of *this.\n+        signed_limb_t cond_negate = -signed_limb_t(negate); // -1 if this negate is true; 0 otherwise\n+        for (int i = 0; i < SIGNED_LIMBS; ++i) {\n+            limbs[i] = (limbs[i] ^ cond_negate) - cond_negate;\n+        }\n+        // Perform carry (make all limbs except the top one be in range 0..2^SIGNED_LIMB_SIZE-1).\n+        for (int i = 0; i < SIGNED_LIMBS - 1; ++i) {\n+            limbs[i + 1] += limbs[i] >> SIGNED_LIMB_SIZE;\n+            limbs[i] &= MAX_SIGNED_LIMB;\n+        }\n+        // Again add modulus if *this was negative. This brings the range of *this to 0..2^3072-1.\n+        cond_add = limbs[SIGNED_LIMBS-1] >> (LIMB_SIZE-1); // -1 if this is negative; 0 otherwise\n+        limbs[0] += signed_limb_t(-MAX_PRIME_DIFF) & cond_add;\n+        limbs[3072 / SIGNED_LIMB_SIZE] += (signed_limb_t(1) << (3072 % SIGNED_LIMB_SIZE)) & cond_add;\n+        // Perform another carry. Now all limbs are in range 0..2^SIGNED_LIMB_SIZE-1.\n+        for (int i = 0; i < SIGNED_LIMBS - 1; ++i) {\n+            limbs[i + 1] += limbs[i] >> SIGNED_LIMB_SIZE;\n+            limbs[i] &= MAX_SIGNED_LIMB;\n+        }\n     }\n+};\n \n-    out = p[11];\n-\n-    square_n_mul(out, 512, p[9]);\n-    square_n_mul(out, 256, p[8]);\n-    square_n_mul(out, 128, p[7]);\n-    square_n_mul(out, 64, p[6]);\n-    square_n_mul(out, 32, p[5]);\n-    square_n_mul(out, 8, p[3]);\n-    square_n_mul(out, 2, p[1]);\n-    square_n_mul(out, 1, p[0]);\n-    square_n_mul(out, 5, p[2]);\n-    square_n_mul(out, 3, p[0]);\n-    square_n_mul(out, 2, p[0]);\n-    square_n_mul(out, 4, p[0]);\n-    square_n_mul(out, 4, p[1]);\n-    square_n_mul(out, 3, p[0]);\n+/** 2x2 transformation matrix with signed_limb_t elements. */\n+struct SignedMatrix\n+{\n+    signed_limb_t u, v, q, r;\n+};\n \n-    return out;\n+/** Compute the trailing zeroes of a non-zero number v. */\n+inline int CountTrailingZeroes(limb_t v)\n+{\n+#ifdef HAVE_BUILTIN_CTZ\n+    /* Use __builtin_ctz if available, and sufficient for the size of limb_t. */\n+    if constexpr (std::numeric_limits<limb_t>::max() <= std::numeric_limits<unsigned>::max()) {\n+        return __builtin_ctz(v);\n+    }\n+#endif\n+#ifdef HAVE_BUILTIN_CTZL\n+    /* Use __builtin_ctzl if available, and sufficient for the size of limb_t. */\n+    if constexpr (std::numeric_limits<limb_t>::max() <= std::numeric_limits<unsigned long>::max()) {\n+        return __builtin_ctzl(v);\n+    }\n+#endif\n+#ifdef HAVE_BUILTIN_CTZLL\n+    /* Use __builtin_ctzll if available, and sufficient for the size of limb_t. */\n+    if constexpr (std::numeric_limits<limb_t>::max() <= std::numeric_limits<unsigned long long>::max()) {\n+        return __builtin_ctzll(v);\n+    }\n+#endif\n+    /* Otherwise fall back to a software implementation. */\n+    if constexpr (LIMB_SIZE <= 32) {\n+        static constexpr uint8_t debruijn[32] = {\n+            0, 1, 2, 24, 3, 19, 6, 25, 26, 4, 20, 10, 16, 7, 12, 26, 31, 23,\n+            18, 5, 21, 9, 15, 11, 30, 17, 8, 14, 29, 13, 28, 27\n+        };\n+        return debruijn[((v & -v) * 0x04D7651F) >> 27];\n+    } else {\n+        static_assert(LIMB_SIZE <= 64);\n+        static constexpr uint8_t debruijn[64] = {\n+            0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28, 62, 5, 39,\n+            46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11, 63, 52, 6, 26,\n+            37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10, 51, 25, 36, 32, 60,\n+            20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+        };\n+        return debruijn[((v & -v) * 0x022FDD63CC95386D) >> 58];\n+    }\n }\n \n-void Num3072::Multiply(const Num3072& a)\n+/** Compute the transformation matrix for SIGNED_LIMB_SIZE divsteps.\n+ *\n+ * eta: initial eta value\n+ * f:   bottom SIGNED_LIMB_SIZE bits of initial f value\n+ * g:   bottom SIGNED_LIMB_SIZE bits of initial g value\n+ * out: resulting transformation matrix, scaled by 2^SIGNED_LIMB_SIZE\n+ * return: eta value after SIGNED_LIMB_SIZE divsteps\n+ */\n+limb_t ComputeDivstepMatrix(signed_limb_t eta, limb_t f, limb_t g, SignedMatrix& out)\n {\n-    limb_t c0 = 0, c1 = 0, c2 = 0;\n-    Num3072 tmp;\n-\n-    /* Compute limbs 0..N-2 of this*a into tmp, including one reduction. */\n-    for (int j = 0; j < LIMBS - 1; ++j) {\n-        limb_t d0 = 0, d1 = 0, d2 = 0;\n-        mul(d0, d1, this->limbs[1 + j], a.limbs[LIMBS + j - (1 + j)]);\n-        for (int i = 2 + j; i < LIMBS; ++i) muladd3(d0, d1, d2, this->limbs[i], a.limbs[LIMBS + j - i]);\n-        mulnadd3(c0, c1, c2, d0, d1, d2, MAX_PRIME_DIFF);\n-        for (int i = 0; i < j + 1; ++i) muladd3(c0, c1, c2, this->limbs[i], a.limbs[j - i]);\n-        extract3(c0, c1, c2, tmp.limbs[j]);\n+    /** inv256[i] = -1/(2*i+1) (mod 256) */\n+    static const uint8_t NEGINV256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+    // Coefficients of returned SignedMatrix; starts off as identity matrix. */\n+    limb_t u = 1, v = 0, q = 0, r = 1;\n+    // The number of divsteps still left.\n+    int i = SIGNED_LIMB_SIZE;\n+    while (true) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        int zeros = CountTrailingZeroes(g | (MAX_LIMB << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+         /* We're done once we've performed SIGNED_LIMB_SIZE divsteps. */\n+        if (i == 0) break;\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            limb_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        int limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        limb_t m = (MAX_LIMB >> (LIMB_SIZE - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        limb_t w = (g * NEGINV256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n     }\n+    out.u = (signed_limb_t)u;\n+    out.v = (signed_limb_t)v;\n+    out.q = (signed_limb_t)q;\n+    out.r = (signed_limb_t)r;\n+    return eta;\n+}\n \n-    /* Compute limb N-1 of a*b into tmp. */\n-    assert(c2 == 0);\n-    for (int i = 0; i < LIMBS; ++i) muladd3(c0, c1, c2, this->limbs[i], a.limbs[LIMBS - 1 - i]);\n-    extract3(c0, c1, c2, tmp.limbs[LIMBS - 1]);\n+/** Apply matrix t/2^SIGNED_LIMB_SIZE to vector [d,e], modulo modulus.\n+ *\n+ * On input and output, d and e are in range 1-2*modulus..modulus-1.\n+ */\n+void UpdateDE(Num3072Signed& d, Num3072Signed& e, const SignedMatrix& t)\n+{\n+    const signed_limb_t u = t.u, v=t.v, q=t.q, r=t.r;\n+\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    signed_limb_t sd = d.limbs[SIGNED_LIMBS - 1] >> (LIMB_SIZE - 1);\n+    signed_limb_t se = e.limbs[SIGNED_LIMBS - 1] >> (LIMB_SIZE - 1);\n+    signed_limb_t md = (u & sd) + (v & se);\n+    signed_limb_t me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    signed_limb_t di = d.limbs[0], ei = e.limbs[0];\n+    signed_double_limb_t cd = (signed_double_limb_t)u * di + (signed_double_limb_t)v * ei;\n+    signed_double_limb_t ce = (signed_double_limb_t)q * di + (signed_double_limb_t)r * ei;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has SIGNED_LIMB_SIZE zero bottom bits. */\n+    md -= (limb_t(0x70a1421da087d93) * limb_t(cd) + md) & MAX_SIGNED_LIMB;\n+    me -= (limb_t(0x70a1421da087d93) * limb_t(ce) + me) & MAX_SIGNED_LIMB;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd -= (signed_double_limb_t)1103717 * md;\n+    ce -= (signed_double_limb_t)1103717 * me;\n+    /* Verify that the low SIGNED_LIMB_SIZE bits of the computation are indeed zero, and then throw them away. */\n+    assert((cd & MAX_SIGNED_LIMB) == 0);\n+    assert((ce & MAX_SIGNED_LIMB) == 0);\n+    cd >>= SIGNED_LIMB_SIZE;\n+    ce >>= SIGNED_LIMB_SIZE;\n+    /* Now iteratively compute limb i=1..SIGNED_LIMBS-2 of t*[d,e]+modulus*[md,me], and store them in output\n+     * limb i-1 (shifting down by SIGNED_LIMB_SIZE bits). The corresponding limbs in modulus are all zero,\n+     * so modulus/md/me are not actually involved here. */\n+    for (int i = 1; i < SIGNED_LIMBS - 1; ++i) {\n+        di = d.limbs[i];\n+        ei = e.limbs[i];\n+        cd += (signed_double_limb_t)u * di + (signed_double_limb_t)v * ei;\n+        ce += (signed_double_limb_t)q * di + (signed_double_limb_t)r * ei;\n+        d.limbs[i - 1] = (signed_limb_t)cd & MAX_SIGNED_LIMB; cd >>= SIGNED_LIMB_SIZE;\n+        e.limbs[i - 1] = (signed_limb_t)ce & MAX_SIGNED_LIMB; ce >>= SIGNED_LIMB_SIZE;\n+    }\n+    /* Compute limb SIGNED_LIMBS-1 of t*[d,e]+modulus*[md,me], and store it in output limb SIGNED_LIMBS-2. */\n+    di = d.limbs[SIGNED_LIMBS - 1];\n+    ei = e.limbs[SIGNED_LIMBS - 1];\n+    cd += (signed_double_limb_t)u * di + (signed_double_limb_t)v * ei;\n+    ce += (signed_double_limb_t)q * di + (signed_double_limb_t)r * ei;\n+    cd += (signed_double_limb_t)md << (3072 % SIGNED_LIMB_SIZE);\n+    ce += (signed_double_limb_t)me << (3072 % SIGNED_LIMB_SIZE);\n+    d.limbs[SIGNED_LIMBS - 2] = (signed_limb_t)cd & MAX_SIGNED_LIMB; cd >>= SIGNED_LIMB_SIZE;\n+    e.limbs[SIGNED_LIMBS - 2] = (signed_limb_t)ce & MAX_SIGNED_LIMB; ce >>= SIGNED_LIMB_SIZE;\n+    /* What remains goes into output limb SINGED_LIMBS-1 */\n+    d.limbs[SIGNED_LIMBS - 1] = (signed_limb_t)cd;\n+    e.limbs[SIGNED_LIMBS - 1] = (signed_limb_t)ce;\n+}\n \n-    /* Perform a second reduction. */\n-    muln2(c0, c1, MAX_PRIME_DIFF);\n-    for (int j = 0; j < LIMBS; ++j) {\n-        addnextract2(c0, c1, tmp.limbs[j], this->limbs[j]);\n+/** Apply matrix t/2^SIGNED_LIMB_SIZE to vector (f,g).\n+ *\n+ * The matrix t must be chosen such that t*(f,g) results in multiples of 2^SIGNED_LIMB_SIZE.\n+ * This is the case for matrices computed by ComputeDivstepMatrix().\n+ */\n+void UpdateFG(Num3072Signed& f, Num3072Signed& g, const SignedMatrix& t, int len)\n+{\n+    const signed_limb_t u = t.u, v=t.v, q=t.q, r=t.r;\n+\n+    signed_limb_t fi, gi;\n+    signed_double_limb_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    fi = f.limbs[0];\n+    gi = g.limbs[0];\n+    cf = (signed_double_limb_t)u * fi + (signed_double_limb_t)v * gi;\n+    cg = (signed_double_limb_t)q * fi + (signed_double_limb_t)r * gi;\n+    /* Verify that the bottom SIGNED_LIMB_BITS bits of the result are zero, and then throw them away. */\n+    assert((cf & MAX_SIGNED_LIMB) == 0);\n+    assert((cg & MAX_SIGNED_LIMB) == 0);\n+    cf >>= SIGNED_LIMB_SIZE;\n+    cg >>= SIGNED_LIMB_SIZE;\n+    /* Now iteratively compute limb i=1..SIGNED_LIMBS-1 of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by SIGNED_LIMB_BITS bits). */\n+    for (int i = 1; i < len; ++i) {\n+        fi = f.limbs[i];\n+        gi = g.limbs[i];\n+        cf += (signed_double_limb_t)u * fi + (signed_double_limb_t)v * gi;\n+        cg += (signed_double_limb_t)q * fi + (signed_double_limb_t)r * gi;\n+        f.limbs[i - 1] = (signed_limb_t)cf & MAX_SIGNED_LIMB; cf >>= SIGNED_LIMB_SIZE;\n+        g.limbs[i - 1] = (signed_limb_t)cg & MAX_SIGNED_LIMB; cg >>= SIGNED_LIMB_SIZE;\n     }\n+    /* What remains is limb SIGNED_LIMBS of t*[f,g]; store it as output limb SIGNED_LIMBS-1. */\n+    f.limbs[len - 1] = (signed_limb_t)cf;\n+    g.limbs[len - 1] = (signed_limb_t)cg;\n \n-    assert(c1 == 0);\n-    assert(c0 == 0 || c0 == 1);\n+}\n+} // namespace\n \n-    /* Perform up to two more reductions if the internal state has already\n-     * overflown the MAX of Num3072 or if it is larger than the modulus or\n-     * if both are the case.\n-     * */\n-    if (this->IsOverflow()) this->FullReduce();\n-    if (c0) this->FullReduce();\n+Num3072 Num3072::GetInverse() const\n+{\n+    // Compute a modular inverse based on a variant of the safegcd algorithm:\n+    // - Paper: https://gcd.cr.yp.to/papers.html\n+    // - Inspired by this code in libsecp256k1:\n+    //   https://github.com/bitcoin-core/secp256k1/blob/master/src/modinv32_impl.h\n+    // - Explanation of the algorithm:\n+    //   https://github.com/bitcoin-core/secp256k1/blob/master/doc/safegcd_implementation.md\n+\n+    // Local variables d, e, f, g:\n+    // - f and g are the variables whose gcd we compute (despite knowing the answer is 1):\n+    //   - f is always odd, and initialized as modulus\n+    //   - g is initialized as *this (called x in what follows)\n+    // - d and e are the numbers for which at every step it is the case that:\n+    //   - f = d * x mod modulus; d is initialized as 0\n+    //   - g = e * x mod modulus; e is initialized as 1\n+    Num3072Signed d, e, f, g;\n+    e.limbs[0] = 1;\n+    // F is initialized as modulus, which in signed limb representation can be expressed\n+    // simply as 2^3072 + -MAX_PRIME_DIFF.\n+    f.limbs[0] = -MAX_PRIME_DIFF;\n+    f.limbs[3072 / SIGNED_LIMB_SIZE] = ((limb_t)1) << (3072 % SIGNED_LIMB_SIZE);\n+    g.FromNum3072(*this);\n+    int len = SIGNED_LIMBS; //!< The number of significant limbs in f and g\n+    signed_limb_t eta = -1; //!< State to track knowledge about ratio of f and g\n+    // Perform divsteps on [f,g] until g=0 is reached, keeping (d,e) synchronized with them.\n+    while (true) {\n+        // Compute transformation matrix t that represents the next SIGNED_LIMB_SIZE divsteps\n+        // to apply. This can be computed from just the bottom limb of f and g, and eta.\n+        SignedMatrix t;\n+        eta = ComputeDivstepMatrix(eta, f.limbs[0], g.limbs[0], t);\n+        // Apply that transformation matrix to the full [f,g] vector.\n+        UpdateFG(f, g, t, len);\n+        // Apply that transformation matrix to the full [d,e] vector (mod modulus).\n+        UpdateDE(d, e, t);\n+\n+        // Check if g is zero.\n+        if (g.limbs[0] == 0) {\n+            signed_limb_t cond = 0;\n+            for (int j = 1; j < len; ++j) {\n+                cond |= g.limbs[j];\n+            }\n+            // If so, we're done.\n+            if (cond == 0) break;\n+        }\n+\n+        // Check if the top limbs of both f and g are both 0 or -1.\n+        signed_limb_t fn = f.limbs[len - 1], gn = g.limbs[len - 1];\n+        signed_limb_t cond = ((signed_limb_t)len - 2) >> (LIMB_SIZE - 1);\n+        cond |= fn ^ (fn >> (LIMB_SIZE - 1));\n+        cond |= gn ^ (gn >> (LIMB_SIZE - 1));\n+        if (cond == 0) {\n+            // If so, drop the top limb, shrinking the size of f and g, by\n+            // propagating the sign to the previous limb.\n+            f.limbs[len - 2] |= (limb_t)f.limbs[len - 1] << SIGNED_LIMB_SIZE;\n+            g.limbs[len - 2] |= (limb_t)g.limbs[len - 1] << SIGNED_LIMB_SIZE;\n+            --len;\n+        }\n+    }\n+    // At some point, [f,g] will have been rewritten into [f',0], such that gcd(f,g) = gcd(f',0).\n+    // This is proven in the paper. As f started out being modulus, a prime number, we know that\n+    // gcd is 1, and thus f' is 1 or -1.\n+    assert((f.limbs[0] & MAX_SIGNED_LIMB) == 1 || (f.limbs[0] & MAX_SIGNED_LIMB) == MAX_SIGNED_LIMB);\n+    // As we've maintained the invariant that f = d * x mod modulus, we get d/f mod modulus is the\n+    // modular inverse of x we're looking for. As f is 1 or -1, it is also true that d/f = d*f.\n+    // Normalize d to prepare it for output, while negating it if f is negative.\n+    d.Normalize(f.limbs[len - 1] >> (LIMB_SIZE  - 1));\n+    Num3072 ret;\n+    d.ToNum3072(ret);\n+    return ret;\n }\n \n-void Num3072::Square()\n+void Num3072::Multiply(const Num3072& a)\n {\n     limb_t c0 = 0, c1 = 0, c2 = 0;\n     Num3072 tmp;\n \n-    /* Compute limbs 0..N-2 of this*this into tmp, including one reduction. */\n+    /* Compute limbs 0..N-2 of this*a into tmp, including one reduction. */\n     for (int j = 0; j < LIMBS - 1; ++j) {\n         limb_t d0 = 0, d1 = 0, d2 = 0;\n-        for (int i = 0; i < (LIMBS - 1 - j) / 2; ++i) muldbladd3(d0, d1, d2, this->limbs[i + j + 1], this->limbs[LIMBS - 1 - i]);\n-        if ((j + 1) & 1) muladd3(d0, d1, d2, this->limbs[(LIMBS - 1 - j) / 2 + j + 1], this->limbs[LIMBS - 1 - (LIMBS - 1 - j) / 2]);\n+        mul(d0, d1, this->limbs[1 + j], a.limbs[LIMBS + j - (1 + j)]);\n+        for (int i = 2 + j; i < LIMBS; ++i) muladd3(d0, d1, d2, this->limbs[i], a.limbs[LIMBS + j - i]);\n         mulnadd3(c0, c1, c2, d0, d1, d2, MAX_PRIME_DIFF);\n-        for (int i = 0; i < (j + 1) / 2; ++i) muldbladd3(c0, c1, c2, this->limbs[i], this->limbs[j - i]);\n-        if ((j + 1) & 1) muladd3(c0, c1, c2, this->limbs[(j + 1) / 2], this->limbs[j - (j + 1) / 2]);\n+        for (int i = 0; i < j + 1; ++i) muladd3(c0, c1, c2, this->limbs[i], a.limbs[j - i]);\n         extract3(c0, c1, c2, tmp.limbs[j]);\n     }\n \n+    /* Compute limb N-1 of a*b into tmp. */\n     assert(c2 == 0);\n-    for (int i = 0; i < LIMBS / 2; ++i) muldbladd3(c0, c1, c2, this->limbs[i], this->limbs[LIMBS - 1 - i]);\n+    for (int i = 0; i < LIMBS; ++i) muladd3(c0, c1, c2, this->limbs[i], a.limbs[LIMBS - 1 - i]);\n     extract3(c0, c1, c2, tmp.limbs[LIMBS - 1]);\n \n     /* Perform a second reduction. */"
      },
      {
        "sha": "f06bb950c36befa1f08af29b540e5b403708cf8b",
        "filename": "src/crypto/muhash.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76d0a5b011d2f70100e417eca2f342b91b6688e0/src/crypto/muhash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76d0a5b011d2f70100e417eca2f342b91b6688e0/src/crypto/muhash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/muhash.h?ref=76d0a5b011d2f70100e417eca2f342b91b6688e0",
        "patch": "@@ -26,29 +26,38 @@ class Num3072\n \n #ifdef HAVE___INT128\n     typedef unsigned __int128 double_limb_t;\n+    typedef signed __int128 signed_double_limb_t;\n     typedef uint64_t limb_t;\n+    typedef int64_t signed_limb_t;\n     static constexpr int LIMBS = 48;\n+    static constexpr int SIGNED_LIMBS = 50;\n     static constexpr int LIMB_SIZE = 64;\n+    static constexpr int SIGNED_LIMB_SIZE = 62;\n #else\n     typedef uint64_t double_limb_t;\n+    typedef int64_t signed_double_limb_t;\n     typedef uint32_t limb_t;\n+    typedef int32_t signed_limb_t;\n     static constexpr int LIMBS = 96;\n+    static constexpr int SIGNED_LIMBS = 103;\n     static constexpr int LIMB_SIZE = 32;\n+    static constexpr int SIGNED_LIMB_SIZE = 30;\n #endif\n     limb_t limbs[LIMBS];\n \n     // Sanity check for Num3072 constants\n     static_assert(LIMB_SIZE * LIMBS == 3072, \"Num3072 isn't 3072 bits\");\n     static_assert(sizeof(double_limb_t) == sizeof(limb_t) * 2, \"bad size for double_limb_t\");\n     static_assert(sizeof(limb_t) * 8 == LIMB_SIZE, \"LIMB_SIZE is incorrect\");\n+    static_assert(SIGNED_LIMB_SIZE * SIGNED_LIMBS > 3072, \"SIGNED_LIMBS * SIGNED_LIMB_SIZE is too small\");\n+    static_assert(3072 / SIGNED_LIMB_SIZE == SIGNED_LIMBS - 1, \"Bit 3072 must land in top signed limb\");\n \n     // Hard coded values in MuHash3072 constructor and Finalize\n     static_assert(sizeof(limb_t) == 4 || sizeof(limb_t) == 8, \"bad size for limb_t\");\n \n     void Multiply(const Num3072& a);\n     void Divide(const Num3072& a);\n     void SetToOne();\n-    void Square();\n     void ToBytes(unsigned char (&out)[BYTE_SIZE]);\n \n     Num3072() { this->SetToOne(); };"
      }
    ]
  },
  {
    "sha": "0bf165c300aef6eebf7194795e79c2a5c5c5e93a",
    "node_id": "C_kwDOABII59oAKDBiZjE2NWMzMDBhZWY2ZWViZjcxOTQ3OTVlNzljMmE1YzVjNWU5M2E",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-04T04:53:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-12-01T16:45:38Z"
      },
      "message": "Disable false positive warnings in MSVC",
      "tree": {
        "sha": "c63c8220c3778c15874d77fd54041c9f2c70cc94",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c63c8220c3778c15874d77fd54041c9f2c70cc94"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bf165c300aef6eebf7194795e79c2a5c5c5e93a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bf165c300aef6eebf7194795e79c2a5c5c5e93a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0bf165c300aef6eebf7194795e79c2a5c5c5e93a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bf165c300aef6eebf7194795e79c2a5c5c5e93a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76d0a5b011d2f70100e417eca2f342b91b6688e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d0a5b011d2f70100e417eca2f342b91b6688e0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76d0a5b011d2f70100e417eca2f342b91b6688e0"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "db9720642b3c46a6415913b81b6c0f75d42eef30",
        "filename": "build_msvc/libbitcoin_crypto/libbitcoin_crypto.vcxproj.in",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0bf165c300aef6eebf7194795e79c2a5c5c5e93a/build_msvc/libbitcoin_crypto/libbitcoin_crypto.vcxproj.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0bf165c300aef6eebf7194795e79c2a5c5c5e93a/build_msvc/libbitcoin_crypto/libbitcoin_crypto.vcxproj.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoin_crypto/libbitcoin_crypto.vcxproj.in?ref=0bf165c300aef6eebf7194795e79c2a5c5c5e93a",
        "patch": "@@ -10,6 +10,11 @@\n   <ItemGroup>\n @SOURCE_FILES@\n   </ItemGroup>\n+  <ItemDefinitionGroup>\n+    <ClCompile>\n+      <DisableSpecificWarnings>4146;4244;4267;4334</DisableSpecificWarnings>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n   <Import Project=\"..\\common.vcxproj\" />"
      }
    ]
  }
]