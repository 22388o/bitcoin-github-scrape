[
  {
    "sha": "cd03513dc2fcccaa142e9632a28b38efd0056436",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDAzNTEzZGMyZmNjY2FhMTQyZTk2MzJhMjhiMzhlZmQwMDU2NDM2",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2020-12-08T20:49:06Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2020-12-15T16:21:06Z"
      },
      "message": "init: Signal-safe instant shutdown\n\nReplace the 200ms polling loop with a faster and more efficient waiting\noperation.\n\nThis was tried a few times before, but given up every time because\nsolutions use a condition variable which is not safe for use in signals\nas they need to be reentrant.\n\nOn UNIX-ish OSes, use a safe way: a pipe. When shutdown is requested\nwrite a dummy byte to the pipe. Waiting for shutdown is a matter of a\nblocking read from the pipe.\n\nOn Windows, there are no signals so using a condition variable is safe.",
      "tree": {
        "sha": "639d20a2fe5c505279d276517d3ddd868c812ba0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/639d20a2fe5c505279d276517d3ddd868c812ba0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd03513dc2fcccaa142e9632a28b38efd0056436",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd03513dc2fcccaa142e9632a28b38efd0056436",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd03513dc2fcccaa142e9632a28b38efd0056436",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd03513dc2fcccaa142e9632a28b38efd0056436/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16b31cc4c516cdcaf6d2eb2dd1255cc3e6973ba1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16b31cc4c516cdcaf6d2eb2dd1255cc3e6973ba1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16b31cc4c516cdcaf6d2eb2dd1255cc3e6973ba1"
      }
    ],
    "stats": {
      "total": 126,
      "additions": 112,
      "deletions": 14
    },
    "files": [
      {
        "sha": "b7bcb534ef03495182d29efb1bc43567b378a5b5",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 14,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd03513dc2fcccaa142e9632a28b38efd0056436/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd03513dc2fcccaa142e9632a28b38efd0056436/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=cd03513dc2fcccaa142e9632a28b38efd0056436",
        "patch": "@@ -28,15 +28,6 @@\n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n UrlDecodeFn* const URL_DECODE = urlDecode;\n \n-static void WaitForShutdown(NodeContext& node)\n-{\n-    while (!ShutdownRequested())\n-    {\n-        UninterruptibleSleep(std::chrono::milliseconds{200});\n-    }\n-    Interrupt(node);\n-}\n-\n static bool AppInit(int argc, char* argv[])\n {\n     NodeContext node;\n@@ -147,12 +138,10 @@ static bool AppInit(int argc, char* argv[])\n         PrintExceptionContinue(nullptr, \"AppInit()\");\n     }\n \n-    if (!fRet)\n-    {\n-        Interrupt(node);\n-    } else {\n-        WaitForShutdown(node);\n+    if (fRet) {\n+        WaitForShutdown();\n     }\n+    Interrupt(node);\n     Shutdown(node);\n \n     return fRet;"
      },
      {
        "sha": "a9d8e7e40cb8d06e7331bedb9dfda73fd783cb20",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd03513dc2fcccaa142e9632a28b38efd0056436/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd03513dc2fcccaa142e9632a28b38efd0056436/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=cd03513dc2fcccaa142e9632a28b38efd0056436",
        "patch": "@@ -917,6 +917,9 @@ bool AppInitBasicSetup(const ArgsManager& args)\n     // Enable heap terminate-on-corruption\n     HeapSetInformation(nullptr, HeapEnableTerminationOnCorruption, nullptr, 0);\n #endif\n+    if (!InitShutdownState()) {\n+        return InitError(Untranslated(\"Initializing wait-for-shutdown state failed.\"));\n+    }\n \n     if (!SetupNetworking()) {\n         return InitError(Untranslated(\"Initializing networking failed.\"));"
      },
      {
        "sha": "a3321a6106cbed4d0c7aa62b29d2c1bfd91b83e5",
        "filename": "src/shutdown.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd03513dc2fcccaa142e9632a28b38efd0056436/src/shutdown.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd03513dc2fcccaa142e9632a28b38efd0056436/src/shutdown.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/shutdown.cpp?ref=cd03513dc2fcccaa142e9632a28b38efd0056436",
        "patch": "@@ -5,19 +5,108 @@\n \n #include <shutdown.h>\n \n+#include <config/bitcoin-config.h>\n+\n+#include <assert.h>\n #include <atomic>\n+#ifdef WIN32\n+#include <condition_variable>\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#endif\n \n static std::atomic<bool> fRequestShutdown(false);\n+#ifdef WIN32\n+/** On windows it is possible to simply use a condition variable. */\n+std::mutex g_shutdown_mutex;\n+std::condition_variable g_shutdown_cv;\n+#else\n+/** On UNIX-like operating systems use the self-pipe trick.\n+ * Index 0 will be the read end of the pipe, index 1 the write end.\n+ */\n+static int g_shutdown_pipe[2] = {-1, -1};\n+#endif\n+\n+bool InitShutdownState()\n+{\n+#ifndef WIN32\n+#if HAVE_O_CLOEXEC\n+    // If we can, make sure that the file descriptors are closed on exec()\n+    // to prevent interference.\n+    if (pipe2(g_shutdown_pipe, O_CLOEXEC) != 0) {\n+        return false;\n+    }\n+#else\n+    if (pipe(g_shutdown_pipe) != 0) {\n+        return false;\n+    }\n+#endif\n+#endif\n+    return true;\n+}\n \n void StartShutdown()\n {\n+#ifdef WIN32\n+    std::unique_lock<std::mutex> lk(g_shutdown_mutex);\n     fRequestShutdown = true;\n+    g_shutdown_cv.notify_one();\n+#else\n+    // This must be reentrant and safe for calling in a signal handler, so using a condition variable is not safe.\n+    // Make sure that the token is only written once even if multiple threads call this concurrently or in\n+    // case of a reentrant signal.\n+    if (!fRequestShutdown.exchange(true)) {\n+        // Write an arbitrary byte to the write end of the shutdown pipe.\n+        const char token = 'x';\n+        while (true) {\n+            int result = write(g_shutdown_pipe[1], &token, 1);\n+            if (result < 0) {\n+                // Failure. It's possible that the write was interrupted by another signal.\n+                // Other errors are unexpected here.\n+                assert(errno == EINTR);\n+            } else {\n+                assert(result == 1);\n+                break;\n+            }\n+        }\n+    }\n+#endif\n }\n+\n void AbortShutdown()\n {\n+    if (fRequestShutdown) {\n+        // Cancel existing shutdown by waiting for it, this will reset condition flags and remove\n+        // the shutdown token from the pipe.\n+        WaitForShutdown();\n+    }\n     fRequestShutdown = false;\n }\n+\n bool ShutdownRequested()\n {\n     return fRequestShutdown;\n }\n+\n+void WaitForShutdown()\n+{\n+#ifdef WIN32\n+    std::unique_lock<std::mutex> lk(g_shutdown_mutex);\n+    g_shutdown_cv.wait(lk, [] { return fRequestShutdown.load(); });\n+#else\n+    char token;\n+    while (true) {\n+        int result = read(g_shutdown_pipe[0], &token, 1);\n+        if (result < 0) {\n+            // Failure. Check if the read was interrupted by a signal.\n+            // Other errors are unexpected here.\n+            assert(errno == EINTR);\n+        } else {\n+            assert(result == 1);\n+            break;\n+        }\n+    }\n+#endif\n+}"
      },
      {
        "sha": "23f84179e964a4c04d05d314706a959cec52c1e2",
        "filename": "src/shutdown.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd03513dc2fcccaa142e9632a28b38efd0056436/src/shutdown.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd03513dc2fcccaa142e9632a28b38efd0056436/src/shutdown.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/shutdown.h?ref=cd03513dc2fcccaa142e9632a28b38efd0056436",
        "patch": "@@ -6,8 +6,25 @@\n #ifndef BITCOIN_SHUTDOWN_H\n #define BITCOIN_SHUTDOWN_H\n \n+/** Initialize shutdown state. This must be called before using either StartShutdown(),\n+ * AbortShutdown() or WaitForShutdown(). Calling ShutdownRequested() is always safe.\n+ */\n+bool InitShutdownState();\n+\n+/** Request shutdown of the application. */\n void StartShutdown();\n+\n+/** Clear shutdown flag. Only use this during init (before calling WaitForShutdown in any\n+ * thread), or in the unit tests. Calling it in other circumstances will cause a race condition.\n+ */\n void AbortShutdown();\n+\n+/** Returns true if a shutdown is requested, false otherwise. */\n bool ShutdownRequested();\n \n+/** Wait for StartShutdown to be called in any thread. This can only be used\n+ * from a single thread.\n+ */\n+void WaitForShutdown();\n+\n #endif"
      }
    ]
  }
]