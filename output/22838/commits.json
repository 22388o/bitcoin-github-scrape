[
  {
    "sha": "3bc62dd98e6036a6f427f06240b4d183ccfd7505",
    "node_id": "C_kwDOABII59oAKDNiYzYyZGQ5OGU2MDM2YTZmNDI3ZjA2MjQwYjRkMTgzY2NmZDc1MDU",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T20:13:01Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:18:55Z"
      },
      "message": "descriptors: Add PubkeyProvider::Clone",
      "tree": {
        "sha": "780e673f1a5a99828f6102e0c7f25d005acdfa48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/780e673f1a5a99828f6102e0c7f25d005acdfa48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bc62dd98e6036a6f427f06240b4d183ccfd7505",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bc62dd98e6036a6f427f06240b4d183ccfd7505",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3bc62dd98e6036a6f427f06240b4d183ccfd7505",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bc62dd98e6036a6f427f06240b4d183ccfd7505/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04437ee721e66a7b76bef5ec2f88dd1efcd03b84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04437ee721e66a7b76bef5ec2f88dd1efcd03b84",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04437ee721e66a7b76bef5ec2f88dd1efcd03b84"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 15,
      "deletions": 0
    },
    "files": [
      {
        "sha": "348a169c838e9931a815720a2c3a69618abad6dd",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bc62dd98e6036a6f427f06240b4d183ccfd7505/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bc62dd98e6036a6f427f06240b4d183ccfd7505/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=3bc62dd98e6036a6f427f06240b4d183ccfd7505",
        "patch": "@@ -185,6 +185,9 @@ struct PubkeyProvider\n \n     /** Derive a private key, if private data is available in arg. */\n     virtual bool GetPrivKey(int pos, const SigningProvider& arg, CKey& key) const = 0;\n+\n+    /** Make a deep copy of this PubkeyProvider */\n+    virtual std::unique_ptr<PubkeyProvider> Clone() const = 0;\n };\n \n class OriginPubkeyProvider final : public PubkeyProvider\n@@ -235,6 +238,10 @@ class OriginPubkeyProvider final : public PubkeyProvider\n     {\n         return m_provider->GetPrivKey(pos, arg, key);\n     }\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        return std::make_unique<OriginPubkeyProvider>(m_expr_index, m_origin, m_provider->Clone());\n+    }\n };\n \n /** An object representing a parsed constant public key in a descriptor. */\n@@ -272,6 +279,10 @@ class ConstPubkeyProvider final : public PubkeyProvider\n     {\n         return arg.GetKey(m_pubkey.GetID(), key);\n     }\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        return std::make_unique<ConstPubkeyProvider>(m_expr_index, m_pubkey, m_xonly);\n+    }\n };\n \n enum class DeriveType {\n@@ -480,6 +491,10 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n         key = extkey.key;\n         return true;\n     }\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        return std::make_unique<BIP32PubkeyProvider>(m_expr_index, m_root_extkey, m_path, m_derive);\n+    }\n };\n \n /** Base class for all Descriptor implementations. */"
      }
    ]
  },
  {
    "sha": "f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
    "node_id": "C_kwDOABII59oAKGYxZDhlMjVlZDhlMjBhZjE1MTMzYTNlZDQ2ODZhODE2OGFkMzQ4NWE",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T20:13:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:18:55Z"
      },
      "message": "descriptors: Add DescriptorImpl::Clone",
      "tree": {
        "sha": "5cda0672e13d6ecde1fc18c28aeb62b982b72ce1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cda0672e13d6ecde1fc18c28aeb62b982b72ce1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1d8e25ed8e20af15133a3ed4686a8168ad3485a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3bc62dd98e6036a6f427f06240b4d183ccfd7505",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bc62dd98e6036a6f427f06240b4d183ccfd7505",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3bc62dd98e6036a6f427f06240b4d183ccfd7505"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 49,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8ce646c1c8978551df164b564f8fbaae6fa37da4",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 1,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1d8e25ed8e20af15133a3ed4686a8168ad3485a/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1d8e25ed8e20af15133a3ed4686a8168ad3485a/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
        "patch": "@@ -500,12 +500,12 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n /** Base class for all Descriptor implementations. */\n class DescriptorImpl : public Descriptor\n {\n+protected:\n     //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size for Multisig).\n     const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n     //! The string name of the descriptor function.\n     const std::string m_name;\n \n-protected:\n     //! The sub-descriptor arguments (empty for everything but SH and WSH).\n     //! In doc/descriptors.m this is referred to as SCRIPT expressions sh(SCRIPT)\n     //! and wsh(SCRIPT), and distinct from KEY expressions and ADDR expressions.\n@@ -673,6 +673,8 @@ class DescriptorImpl : public Descriptor\n     }\n \n     std::optional<OutputType> GetOutputType() const override { return std::nullopt; }\n+\n+    virtual std::unique_ptr<DescriptorImpl> Clone() const = 0;\n };\n \n /** A parsed addr(A) descriptor. */\n@@ -691,6 +693,10 @@ class AddressDescriptor final : public DescriptorImpl\n         return OutputTypeFromDestination(m_destination);\n     }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<AddressDescriptor>(m_destination);\n+    }\n };\n \n /** A parsed raw(H) descriptor. */\n@@ -711,6 +717,10 @@ class RawDescriptor final : public DescriptorImpl\n         return OutputTypeFromDestination(dest);\n     }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<RawDescriptor>(m_script);\n+    }\n };\n \n /** A parsed pk(P) descriptor. */\n@@ -731,6 +741,10 @@ class PKDescriptor final : public DescriptorImpl\n public:\n     PKDescriptor(std::unique_ptr<PubkeyProvider> prov, bool xonly = false) : DescriptorImpl(Vector(std::move(prov)), \"pk\"), m_xonly(xonly) {}\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<PKDescriptor>(m_pubkey_args.at(0)->Clone(), m_xonly);\n+    }\n };\n \n /** A parsed pkh(P) descriptor. */\n@@ -747,6 +761,10 @@ class PKHDescriptor final : public DescriptorImpl\n     PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"pkh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::LEGACY; }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<PKHDescriptor>(m_pubkey_args.at(0)->Clone());\n+    }\n };\n \n /** A parsed wpkh(P) descriptor. */\n@@ -763,6 +781,10 @@ class WPKHDescriptor final : public DescriptorImpl\n     WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"wpkh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<WPKHDescriptor>(m_pubkey_args.at(0)->Clone());\n+    }\n };\n \n /** A parsed combo(P) descriptor. */\n@@ -787,6 +809,10 @@ class ComboDescriptor final : public DescriptorImpl\n public:\n     ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"combo\") {}\n     bool IsSingleType() const final { return false; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<ComboDescriptor>(m_pubkey_args.at(0)->Clone());\n+    }\n };\n \n /** A parsed multi(...) or sortedmulti(...) descriptor */\n@@ -807,6 +833,13 @@ class MultisigDescriptor final : public DescriptorImpl\n public:\n     MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), sorted ? \"sortedmulti\" : \"multi\"), m_threshold(threshold), m_sorted(sorted) {}\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_pubkey_args.size());\n+        std::transform(m_pubkey_args.begin(), m_pubkey_args.end(), providers.begin(), [](const std::unique_ptr<PubkeyProvider>& p) { return p->Clone(); });\n+        return std::make_unique<MultisigDescriptor>(m_threshold, std::move(providers), m_sorted);\n+    }\n };\n \n /** A parsed sh(...) descriptor. */\n@@ -829,6 +862,10 @@ class SHDescriptor final : public DescriptorImpl\n         return OutputType::LEGACY;\n     }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<SHDescriptor>(m_subdescriptor_args.at(0)->Clone());\n+    }\n };\n \n /** A parsed wsh(...) descriptor. */\n@@ -845,6 +882,10 @@ class WSHDescriptor final : public DescriptorImpl\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        return std::make_unique<WSHDescriptor>(m_subdescriptor_args.at(0)->Clone());\n+    }\n };\n \n /** A parsed tr(...) descriptor. */\n@@ -897,6 +938,13 @@ class TRDescriptor final : public DescriptorImpl\n     }\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32M; }\n     bool IsSingleType() const final { return true; }\n+    std::unique_ptr<DescriptorImpl> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<DescriptorImpl>> subdescs;\n+        subdescs.reserve(m_subdescriptor_args.size());\n+        std::transform(m_subdescriptor_args.begin(), m_subdescriptor_args.end(), subdescs.begin(), [](const std::unique_ptr<DescriptorImpl>& d) { return d->Clone(); });\n+        return std::make_unique<TRDescriptor>(m_pubkey_args.at(0)->Clone(), std::move(subdescs), m_depths);\n+    }\n };\n \n ////////////////////////////////////////////////////////////////////////////"
      }
    ]
  },
  {
    "sha": "7071f955e04004eac1009c754bea35553594f928",
    "node_id": "C_kwDOABII59oAKDcwNzFmOTU1ZTA0MDA0ZWFjMTAwOWM3NTRiZWEzNTU1MzU5NGY5Mjg",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T20:42:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:18:55Z"
      },
      "message": "descriptors: Change ParseScript to return pair of descriptors\n\nTo prepare for returning multipath descriptors which will be a shorthand\nfor specifying 2 descriptors, change ParseScript's signature to return a\npair.",
      "tree": {
        "sha": "b7ef431d7eec77d34d06250019ac0cf4cdf4cb09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7ef431d7eec77d34d06250019ac0cf4cdf4cb09"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7071f955e04004eac1009c754bea35553594f928",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7071f955e04004eac1009c754bea35553594f928",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7071f955e04004eac1009c754bea35553594f928",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7071f955e04004eac1009c754bea35553594f928/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1d8e25ed8e20af15133a3ed4686a8168ad3485a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1d8e25ed8e20af15133a3ed4686a8168ad3485a"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 81,
      "deletions": 49
    },
    "files": [
      {
        "sha": "64f064a3c4a2052c2d34f00ca260ac5145a3c395",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 81,
        "deletions": 49,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7071f955e04004eac1009c754bea35553594f928/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7071f955e04004eac1009c754bea35553594f928/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=7071f955e04004eac1009c754bea35553594f928",
        "patch": "@@ -1089,132 +1089,156 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<c\n }\n \n /** Parse a script in a particular context. */\n-std::unique_ptr<DescriptorImpl> ParseScript(uint32_t& key_exp_index, Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> ParseScript(uint32_t& key_exp_index, Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n     auto expr = Expr(sp);\n     bool sorted_multi = false;\n     if (Func(\"pk\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return nullptr;\n+        if (!pubkey) return {nullptr, nullptr};\n         ++key_exp_index;\n-        return std::make_unique<PKDescriptor>(std::move(pubkey), ctx == ParseScriptContext::P2TR);\n+        return {\n+            std::make_unique<PKDescriptor>(std::move(pubkey), ctx == ParseScriptContext::P2TR),\n+            nullptr\n+        };\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && Func(\"pkh\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return nullptr;\n+        if (!pubkey) return {nullptr, nullptr};\n         ++key_exp_index;\n-        return std::make_unique<PKHDescriptor>(std::move(pubkey));\n+        return {\n+            std::make_unique<PKHDescriptor>(std::move(pubkey)),\n+            nullptr\n+        };\n     } else if (Func(\"pkh\", expr)) {\n         error = \"Can only have pkh at top level, in sh(), or in wsh()\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return nullptr;\n+        if (!pubkey) return {nullptr, nullptr};\n         ++key_exp_index;\n-        return std::make_unique<ComboDescriptor>(std::move(pubkey));\n+        return {\n+            std::make_unique<ComboDescriptor>(std::move(pubkey)),\n+            nullptr\n+        };\n     } else if (Func(\"combo\", expr)) {\n         error = \"Can only have combo() at top level\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && ((sorted_multi = Func(\"sortedmulti\", expr)) || Func(\"multi\", expr))) {\n         auto threshold = Expr(expr);\n         uint32_t thres;\n         std::vector<std::unique_ptr<PubkeyProvider>> providers;\n         if (!ParseUInt32(std::string(threshold.begin(), threshold.end()), &thres)) {\n             error = strprintf(\"Multi threshold '%s' is not valid\", std::string(threshold.begin(), threshold.end()));\n-            return nullptr;\n+            return {nullptr, nullptr};\n         }\n         size_t script_size = 0;\n         while (expr.size()) {\n             if (!Const(\",\", expr)) {\n                 error = strprintf(\"Multi: expected ',', got '%c'\", expr[0]);\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n             auto arg = Expr(expr);\n             auto pk = ParsePubkey(key_exp_index, arg, ctx, out, error);\n-            if (!pk) return nullptr;\n+            if (!pk) return {nullptr, nullptr};\n             script_size += pk->GetSize() + 1;\n             providers.emplace_back(std::move(pk));\n             key_exp_index++;\n         }\n         if (providers.empty() || providers.size() > MAX_PUBKEYS_PER_MULTISIG) {\n             error = strprintf(\"Cannot have %u keys in multisig; must have between 1 and %d keys, inclusive\", providers.size(), MAX_PUBKEYS_PER_MULTISIG);\n-            return nullptr;\n+            return {nullptr, nullptr};\n         } else if (thres < 1) {\n             error = strprintf(\"Multisig threshold cannot be %d, must be at least 1\", thres);\n-            return nullptr;\n+            return {nullptr, nullptr};\n         } else if (thres > providers.size()) {\n             error = strprintf(\"Multisig threshold cannot be larger than the number of keys; threshold is %d but only %u keys specified\", thres, providers.size());\n-            return nullptr;\n+            return {nullptr, nullptr};\n         }\n         if (ctx == ParseScriptContext::TOP) {\n             if (providers.size() > 3) {\n                 error = strprintf(\"Cannot have %u pubkeys in bare multisig; only at most 3 pubkeys\", providers.size());\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n         }\n         if (ctx == ParseScriptContext::P2SH) {\n             // This limits the maximum number of compressed pubkeys to 15.\n             if (script_size + 3 > MAX_SCRIPT_ELEMENT_SIZE) {\n                 error = strprintf(\"P2SH script is too large, %d bytes is larger than %d bytes\", script_size + 3, MAX_SCRIPT_ELEMENT_SIZE);\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n         }\n-        return std::make_unique<MultisigDescriptor>(thres, std::move(providers), sorted_multi);\n+        return {\n+            std::make_unique<MultisigDescriptor>(thres, std::move(providers), sorted_multi),\n+            nullptr\n+        };\n     } else if (Func(\"sortedmulti\", expr) || Func(\"multi\", expr)) {\n         error = \"Can only have multi/sortedmulti at top level, in sh(), or in wsh()\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH) && Func(\"wpkh\", expr)) {\n         auto pubkey = ParsePubkey(key_exp_index, expr, ParseScriptContext::P2WPKH, out, error);\n-        if (!pubkey) return nullptr;\n+        if (!pubkey) return {nullptr, nullptr};\n         key_exp_index++;\n-        return std::make_unique<WPKHDescriptor>(std::move(pubkey));\n+        return {\n+            std::make_unique<WPKHDescriptor>(std::move(pubkey)),\n+            nullptr\n+        };\n     } else if (Func(\"wpkh\", expr)) {\n         error = \"Can only have wpkh() at top level or inside sh()\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2SH, out, error);\n-        if (!desc || expr.size()) return nullptr;\n-        return std::make_unique<SHDescriptor>(std::move(desc));\n+        if (!desc.first || expr.size()) return {nullptr, nullptr};\n+        return {\n+            std::make_unique<SHDescriptor>(std::move(desc.first)),\n+            nullptr\n+        };\n     } else if (Func(\"sh\", expr)) {\n         error = \"Can only have sh() at top level\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH) && Func(\"wsh\", expr)) {\n         auto desc = ParseScript(key_exp_index, expr, ParseScriptContext::P2WSH, out, error);\n-        if (!desc || expr.size()) return nullptr;\n-        return std::make_unique<WSHDescriptor>(std::move(desc));\n+        if (!desc.first || expr.size()) return {nullptr, nullptr};\n+        return {\n+            std::make_unique<WSHDescriptor>(std::move(desc.first)),\n+            nullptr\n+        };\n     } else if (Func(\"wsh\", expr)) {\n         error = \"Can only have wsh() at top level or inside sh()\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n         CTxDestination dest = DecodeDestination(std::string(expr.begin(), expr.end()));\n         if (!IsValidDestination(dest)) {\n             error = \"Address is not valid\";\n-            return nullptr;\n+            return {nullptr, nullptr};\n         }\n-        return std::make_unique<AddressDescriptor>(std::move(dest));\n+        return {\n+            std::make_unique<AddressDescriptor>(std::move(dest)),\n+            nullptr\n+        };\n     } else if (Func(\"addr\", expr)) {\n         error = \"Can only have addr() at top level\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"tr\", expr)) {\n         auto arg = Expr(expr);\n         auto internal_key = ParsePubkey(key_exp_index, arg, ParseScriptContext::P2TR, out, error);\n-        if (!internal_key) return nullptr;\n+        if (!internal_key) return {nullptr, nullptr};\n         ++key_exp_index;\n-        std::vector<std::unique_ptr<DescriptorImpl>> subscripts; //!< list of script subexpressions\n+        std::pair<std::vector<std::unique_ptr<DescriptorImpl>>, std::vector<std::unique_ptr<DescriptorImpl>>> subscripts; //!< list of script subexpressions\n         std::vector<int> depths; //!< depth in the tree of each subexpression (same length subscripts)\n         if (expr.size()) {\n             if (!Const(\",\", expr)) {\n                 error = strprintf(\"tr: expected ',', got '%c'\", expr[0]);\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n             /** The path from the top of the tree to what we're currently processing.\n              * branches[i] == false: left branch in the i'th step from the top; true: right branch.\n@@ -1228,64 +1252,72 @@ std::unique_ptr<DescriptorImpl> ParseScript(uint32_t& key_exp_index, Span<const\n                     branches.push_back(false); // new left branch\n                     if (branches.size() > TAPROOT_CONTROL_MAX_NODE_COUNT) {\n                         error = strprintf(\"tr() supports at most %i nesting levels\", TAPROOT_CONTROL_MAX_NODE_COUNT);\n-                        return nullptr;\n+                        return {nullptr, nullptr};\n                     }\n                 }\n                 // Process the actual script expression.\n                 auto sarg = Expr(expr);\n-                subscripts.emplace_back(ParseScript(key_exp_index, sarg, ParseScriptContext::P2TR, out, error));\n-                if (!subscripts.back()) return nullptr;\n+                auto parsed_scripts = ParseScript(key_exp_index, sarg, ParseScriptContext::P2TR, out, error);\n+                if (!parsed_scripts.first) return {nullptr, nullptr};\n+                subscripts.second.emplace_back(parsed_scripts.second ? std::move(parsed_scripts.second) : std::move(parsed_scripts.first->Clone()));\n+                subscripts.first.emplace_back(std::move(parsed_scripts.first));\n                 depths.push_back(branches.size());\n                 // Process closing braces; one is expected for every right branch we were in.\n                 while (branches.size() && branches.back()) {\n                     if (!Const(\"}\", expr)) {\n                         error = strprintf(\"tr(): expected '}' after script expression\");\n-                        return nullptr;\n+                        return {nullptr, nullptr};\n                     }\n                     branches.pop_back(); // move up one level after encountering '}'\n                 }\n                 // If after that, we're at the end of a left branch, expect a comma.\n                 if (branches.size() && !branches.back()) {\n                     if (!Const(\",\", expr)) {\n                         error = strprintf(\"tr(): expected ',' after script expression\");\n-                        return nullptr;\n+                        return {nullptr, nullptr};\n                     }\n                     branches.back() = true; // And now we're in a right branch.\n                 }\n             } while (branches.size());\n             // After we've explored a whole tree, we must be at the end of the expression.\n             if (expr.size()) {\n                 error = strprintf(\"tr(): expected ')' after script expression\");\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n         }\n         assert(TaprootBuilder::ValidDepths(depths));\n-        return std::make_unique<TRDescriptor>(std::move(internal_key), std::move(subscripts), std::move(depths));\n+        return {\n+            std::make_unique<TRDescriptor>(std::move(internal_key), std::move(subscripts.first), std::move(depths)),\n+            nullptr\n+        };\n     } else if (Func(\"tr\", expr)) {\n         error = \"Can only have tr at top level\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"raw\", expr)) {\n         std::string str(expr.begin(), expr.end());\n         if (!IsHex(str)) {\n             error = \"Raw script is not hex\";\n-            return nullptr;\n+            return {nullptr, nullptr};\n         }\n         auto bytes = ParseHex(str);\n-        return std::make_unique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n+        return {\n+            std::make_unique<RawDescriptor>(CScript(bytes.begin(), bytes.end())),\n+            nullptr\n+        };\n     } else if (Func(\"raw\", expr)) {\n         error = \"Can only have raw() at top level\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::P2SH) {\n         error = \"A function is needed within P2SH\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     } else if (ctx == ParseScriptContext::P2WSH) {\n         error = \"A function is needed within P2WSH\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     error = strprintf(\"%s is not a valid descriptor function\", std::string(expr.begin(), expr.end()));\n-    return nullptr;\n+    return {nullptr, nullptr};\n }\n \n std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptContext, const SigningProvider& provider)\n@@ -1459,7 +1491,7 @@ std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProv\n     if (!CheckChecksum(sp, require_checksum, error)) return nullptr;\n     uint32_t key_exp_index = 0;\n     auto ret = ParseScript(key_exp_index, sp, ParseScriptContext::TOP, out, error);\n-    if (sp.size() == 0 && ret) return std::unique_ptr<Descriptor>(std::move(ret));\n+    if (sp.size() == 0 && ret.first) return std::unique_ptr<Descriptor>(std::move(ret.first));\n     return nullptr;\n }\n "
      }
    ]
  },
  {
    "sha": "cfc49e44376b9fdea40370fd1c641b6fbd958a32",
    "node_id": "C_kwDOABII59oAKGNmYzQ5ZTQ0Mzc2YjlmZGVhNDAzNzBmZDFjNjQxYjZmYmQ5NThhMzI",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T21:00:45Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:18:55Z"
      },
      "message": "descriptors: Have ParsePubkey return a pair\n\nTo prepare for multipath descriptors, have ParsePubkey return a pair of\nPubkeyProviders and have ParseScript be able to handle them.",
      "tree": {
        "sha": "ca64538b7fb803ed83476adda4f69abbcefe7029",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca64538b7fb803ed83476adda4f69abbcefe7029"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfc49e44376b9fdea40370fd1c641b6fbd958a32",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfc49e44376b9fdea40370fd1c641b6fbd958a32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cfc49e44376b9fdea40370fd1c641b6fbd958a32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfc49e44376b9fdea40370fd1c641b6fbd958a32/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7071f955e04004eac1009c754bea35553594f928",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7071f955e04004eac1009c754bea35553594f928",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7071f955e04004eac1009c754bea35553594f928"
      }
    ],
    "stats": {
      "total": 129,
      "additions": 74,
      "deletions": 55
    },
    "files": [
      {
        "sha": "489f8084bc3c2f94707a3cf27fe7a36a00ab2cda",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 55,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cfc49e44376b9fdea40370fd1c641b6fbd958a32/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cfc49e44376b9fdea40370fd1c641b6fbd958a32/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=cfc49e44376b9fdea40370fd1c641b6fbd958a32",
        "patch": "@@ -983,7 +983,7 @@ enum class ParseScriptContext {\n }\n \n /** Parse a public key that excludes origin information. */\n-std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+std::pair<std::unique_ptr<PubkeyProvider>, std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n@@ -992,47 +992,47 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n     std::string str(split[0].begin(), split[0].end());\n     if (str.size() == 0) {\n         error = \"No key provided\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (split.size() == 1) {\n         if (IsHex(str)) {\n             std::vector<unsigned char> data = ParseHex(str);\n             CPubKey pubkey(data);\n             if (pubkey.IsFullyValid()) {\n                 if (permit_uncompressed || pubkey.IsCompressed()) {\n-                    return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, false);\n+                    return {std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, false), nullptr};\n                 } else {\n                     error = \"Uncompressed keys are not allowed\";\n-                    return nullptr;\n+                    return {nullptr, nullptr};\n                 }\n             } else if (data.size() == 32 && ctx == ParseScriptContext::P2TR) {\n                 unsigned char fullkey[33] = {0x02};\n                 std::copy(data.begin(), data.end(), fullkey + 1);\n                 pubkey.Set(std::begin(fullkey), std::end(fullkey));\n                 if (pubkey.IsFullyValid()) {\n-                    return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, true);\n+                    return {std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, true), nullptr};\n                 }\n             }\n             error = strprintf(\"Pubkey '%s' is invalid\", str);\n-            return nullptr;\n+            return {nullptr, nullptr};\n         }\n         CKey key = DecodeSecret(str);\n         if (key.IsValid()) {\n             if (permit_uncompressed || key.IsCompressed()) {\n                 CPubKey pubkey = key.GetPubKey();\n                 out.keys.emplace(pubkey.GetID(), key);\n-                return std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, ctx == ParseScriptContext::P2TR);\n+                return {std::make_unique<ConstPubkeyProvider>(key_exp_index, pubkey, ctx == ParseScriptContext::P2TR), nullptr};\n             } else {\n                 error = \"Uncompressed keys are not allowed\";\n-                return nullptr;\n+                return {nullptr, nullptr};\n             }\n         }\n     }\n     CExtKey extkey = DecodeExtKey(str);\n     CExtPubKey extpubkey = DecodeExtPubKey(str);\n     if (!extkey.key.IsValid() && !extpubkey.pubkey.IsValid()) {\n         error = strprintf(\"key '%s' is not valid\", str);\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     KeyPath path;\n     DeriveType type = DeriveType::NO;\n@@ -1043,49 +1043,55 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n         split.pop_back();\n         type = DeriveType::HARDENED;\n     }\n-    if (!ParseKeyPath(split, path, error)) return nullptr;\n+    if (!ParseKeyPath(split, path, error)) return {nullptr, nullptr};\n     if (extkey.key.IsValid()) {\n         extpubkey = extkey.Neuter();\n         out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n     }\n-    return std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path), type);\n+    return {\n+        std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path), type),\n+        nullptr\n+    };\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::unique_ptr<PubkeyProvider> ParsePubkey(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+std::pair<std::unique_ptr<PubkeyProvider>, std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     using namespace spanparsing;\n \n     auto origin_split = Split(sp, ']');\n     if (origin_split.size() > 2) {\n         error = \"Multiple ']' characters found for a single pubkey\";\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     if (origin_split.size() == 1) return ParsePubkeyInner(key_exp_index, origin_split[0], ctx, out, error);\n     if (origin_split[0].empty() || origin_split[0][0] != '[') {\n         error = strprintf(\"Key origin start '[ character expected but not found, got '%c' instead\",\n                           origin_split[0].empty() ? /** empty, implies split char */ ']' : origin_split[0][0]);\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     auto slash_split = Split(origin_split[0].subspan(1), '/');\n     if (slash_split[0].size() != 8) {\n         error = strprintf(\"Fingerprint is not 4 bytes (%u characters instead of 8 characters)\", slash_split[0].size());\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     std::string fpr_hex = std::string(slash_split[0].begin(), slash_split[0].end());\n     if (!IsHex(fpr_hex)) {\n         error = strprintf(\"Fingerprint '%s' is not hex\", fpr_hex);\n-        return nullptr;\n+        return {nullptr, nullptr};\n     }\n     auto fpr_bytes = ParseHex(fpr_hex);\n     KeyOriginInfo info;\n     static_assert(sizeof(info.fingerprint) == 4, \"Fingerprint must be 4 bytes\");\n     assert(fpr_bytes.size() == 4);\n     std::copy(fpr_bytes.begin(), fpr_bytes.end(), info.fingerprint);\n-    if (!ParseKeyPath(slash_split, info.path, error)) return nullptr;\n-    auto provider = ParsePubkeyInner(key_exp_index, origin_split[1], ctx, out, error);\n-    if (!provider) return nullptr;\n-    return std::make_unique<OriginPubkeyProvider>(key_exp_index, std::move(info), std::move(provider));\n+    if (!ParseKeyPath(slash_split, info.path, error)) return {nullptr, nullptr};\n+    auto providers = ParsePubkeyInner(key_exp_index, origin_split[1], ctx, out, error);\n+    if (!providers.first) return {nullptr, nullptr};\n+    return {\n+        std::make_unique<OriginPubkeyProvider>(key_exp_index, info, std::move(providers.first)),\n+        providers.second ? std::make_unique<OriginPubkeyProvider>(key_exp_index, info, std::move(providers.second)) : nullptr\n+    };\n }\n \n /** Parse a script in a particular context. */\n@@ -1096,33 +1102,33 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n     auto expr = Expr(sp);\n     bool sorted_multi = false;\n     if (Func(\"pk\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return {nullptr, nullptr};\n+        auto pubkeys = ParsePubkey(key_exp_index, expr, ctx, out, error);\n+        if (!pubkeys.first) return {nullptr, nullptr};\n         ++key_exp_index;\n         return {\n-            std::make_unique<PKDescriptor>(std::move(pubkey), ctx == ParseScriptContext::P2TR),\n-            nullptr\n+            std::make_unique<PKDescriptor>(std::move(pubkeys.first), ctx == ParseScriptContext::P2TR),\n+            pubkeys.second ? std::make_unique<PKDescriptor>(std::move(pubkeys.second), ctx == ParseScriptContext::P2TR) : nullptr\n         };\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && Func(\"pkh\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return {nullptr, nullptr};\n+        auto pubkeys = ParsePubkey(key_exp_index, expr, ctx, out, error);\n+        if (!pubkeys.first) return {nullptr, nullptr};\n         ++key_exp_index;\n         return {\n-            std::make_unique<PKHDescriptor>(std::move(pubkey)),\n-            nullptr\n+            std::make_unique<PKHDescriptor>(std::move(pubkeys.first)),\n+            pubkeys.second ? std::make_unique<PKHDescriptor>(std::move(pubkeys.second)) : nullptr\n         };\n     } else if (Func(\"pkh\", expr)) {\n         error = \"Can only have pkh at top level, in sh(), or in wsh()\";\n         return {nullptr, nullptr};\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ctx, out, error);\n-        if (!pubkey) return {nullptr, nullptr};\n+        auto pubkeys = ParsePubkey(key_exp_index, expr, ctx, out, error);\n+        if (!pubkeys.first) return {nullptr, nullptr};\n         ++key_exp_index;\n         return {\n-            std::make_unique<ComboDescriptor>(std::move(pubkey)),\n-            nullptr\n+            std::make_unique<ComboDescriptor>(std::move(pubkeys.first)),\n+            pubkeys.second ? std::make_unique<ComboDescriptor>(std::move(pubkeys.second)) : nullptr\n         };\n     } else if (Func(\"combo\", expr)) {\n         error = \"Can only have combo() at top level\";\n@@ -1131,37 +1137,43 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && ((sorted_multi = Func(\"sortedmulti\", expr)) || Func(\"multi\", expr))) {\n         auto threshold = Expr(expr);\n         uint32_t thres;\n-        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        std::pair<std::vector<std::unique_ptr<PubkeyProvider>>, std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n         if (!ParseUInt32(std::string(threshold.begin(), threshold.end()), &thres)) {\n             error = strprintf(\"Multi threshold '%s' is not valid\", std::string(threshold.begin(), threshold.end()));\n             return {nullptr, nullptr};\n         }\n         size_t script_size = 0;\n+        bool has_multipath = false;\n         while (expr.size()) {\n             if (!Const(\",\", expr)) {\n                 error = strprintf(\"Multi: expected ',', got '%c'\", expr[0]);\n                 return {nullptr, nullptr};\n             }\n             auto arg = Expr(expr);\n-            auto pk = ParsePubkey(key_exp_index, arg, ctx, out, error);\n-            if (!pk) return {nullptr, nullptr};\n-            script_size += pk->GetSize() + 1;\n-            providers.emplace_back(std::move(pk));\n+            auto pks = ParsePubkey(key_exp_index, arg, ctx, out, error);\n+            if (!pks.first) return {nullptr, nullptr};\n+            if (pks.second) {\n+                has_multipath = true;\n+            }\n+            script_size += pks.first->GetSize() + 1;\n+            providers.first.emplace_back(std::move(pks.first));\n+            providers.second.emplace_back(pks.second ? std::move(pks.second) : std::move(pks.first->Clone()));\n             key_exp_index++;\n         }\n-        if (providers.empty() || providers.size() > MAX_PUBKEYS_PER_MULTISIG) {\n-            error = strprintf(\"Cannot have %u keys in multisig; must have between 1 and %d keys, inclusive\", providers.size(), MAX_PUBKEYS_PER_MULTISIG);\n+        assert(providers.first.size() == providers.second.size());\n+        if (providers.first.empty() || providers.first.size() > MAX_PUBKEYS_PER_MULTISIG) {\n+            error = strprintf(\"Cannot have %u keys in multisig; must have between 1 and %d keys, inclusive\", providers.first.size(), MAX_PUBKEYS_PER_MULTISIG);\n             return {nullptr, nullptr};\n         } else if (thres < 1) {\n             error = strprintf(\"Multisig threshold cannot be %d, must be at least 1\", thres);\n             return {nullptr, nullptr};\n-        } else if (thres > providers.size()) {\n-            error = strprintf(\"Multisig threshold cannot be larger than the number of keys; threshold is %d but only %u keys specified\", thres, providers.size());\n+        } else if (thres > providers.first.size()) {\n+            error = strprintf(\"Multisig threshold cannot be larger than the number of keys; threshold is %d but only %u keys specified\", thres, providers.first.size());\n             return {nullptr, nullptr};\n         }\n         if (ctx == ParseScriptContext::TOP) {\n-            if (providers.size() > 3) {\n-                error = strprintf(\"Cannot have %u pubkeys in bare multisig; only at most 3 pubkeys\", providers.size());\n+            if (providers.first.size() > 3) {\n+                error = strprintf(\"Cannot have %u pubkeys in bare multisig; only at most 3 pubkeys\", providers.first.size());\n                 return {nullptr, nullptr};\n             }\n         }\n@@ -1173,20 +1185,20 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n             }\n         }\n         return {\n-            std::make_unique<MultisigDescriptor>(thres, std::move(providers), sorted_multi),\n-            nullptr\n+            std::make_unique<MultisigDescriptor>(thres, std::move(providers.first), sorted_multi),\n+            has_multipath ? std::make_unique<MultisigDescriptor>(thres, std::move(providers.second), sorted_multi) : nullptr\n         };\n     } else if (Func(\"sortedmulti\", expr) || Func(\"multi\", expr)) {\n         error = \"Can only have multi/sortedmulti at top level, in sh(), or in wsh()\";\n         return {nullptr, nullptr};\n     }\n     if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH) && Func(\"wpkh\", expr)) {\n-        auto pubkey = ParsePubkey(key_exp_index, expr, ParseScriptContext::P2WPKH, out, error);\n-        if (!pubkey) return {nullptr, nullptr};\n+        auto pubkeys = ParsePubkey(key_exp_index, expr, ParseScriptContext::P2WPKH, out, error);\n+        if (!pubkeys.first) return {nullptr, nullptr};\n         key_exp_index++;\n         return {\n-            std::make_unique<WPKHDescriptor>(std::move(pubkey)),\n-            nullptr\n+            std::make_unique<WPKHDescriptor>(std::move(pubkeys.first)),\n+            pubkeys.second ? std::make_unique<WPKHDescriptor>(std::move(pubkeys.second)) : nullptr\n         };\n     } else if (Func(\"wpkh\", expr)) {\n         error = \"Can only have wpkh() at top level or inside sh()\";\n@@ -1197,7 +1209,7 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n         if (!desc.first || expr.size()) return {nullptr, nullptr};\n         return {\n             std::make_unique<SHDescriptor>(std::move(desc.first)),\n-            nullptr\n+            desc.second ? std::make_unique<SHDescriptor>(std::move(desc.second)) : nullptr\n         };\n     } else if (Func(\"sh\", expr)) {\n         error = \"Can only have sh() at top level\";\n@@ -1208,7 +1220,7 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n         if (!desc.first || expr.size()) return {nullptr, nullptr};\n         return {\n             std::make_unique<WSHDescriptor>(std::move(desc.first)),\n-            nullptr\n+            desc.second ? std::make_unique<WSHDescriptor>(std::move(desc.second)) : nullptr\n         };\n     } else if (Func(\"wsh\", expr)) {\n         error = \"Can only have wsh() at top level or inside sh()\";\n@@ -1230,8 +1242,12 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"tr\", expr)) {\n         auto arg = Expr(expr);\n-        auto internal_key = ParsePubkey(key_exp_index, arg, ParseScriptContext::P2TR, out, error);\n-        if (!internal_key) return {nullptr, nullptr};\n+        auto internal_keys = ParsePubkey(key_exp_index, arg, ParseScriptContext::P2TR, out, error);\n+        if (!internal_keys.first) return {nullptr, nullptr};\n+        bool has_multipath = (bool)internal_keys.second;\n+        if (!has_multipath) {\n+            internal_keys.second = internal_keys.first->Clone();\n+        }\n         ++key_exp_index;\n         std::pair<std::vector<std::unique_ptr<DescriptorImpl>>, std::vector<std::unique_ptr<DescriptorImpl>>> subscripts; //!< list of script subexpressions\n         std::vector<int> depths; //!< depth in the tree of each subexpression (same length subscripts)\n@@ -1257,10 +1273,13 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n                 }\n                 // Process the actual script expression.\n                 auto sarg = Expr(expr);\n+\n                 auto parsed_scripts = ParseScript(key_exp_index, sarg, ParseScriptContext::P2TR, out, error);\n                 if (!parsed_scripts.first) return {nullptr, nullptr};\n                 subscripts.second.emplace_back(parsed_scripts.second ? std::move(parsed_scripts.second) : std::move(parsed_scripts.first->Clone()));\n                 subscripts.first.emplace_back(std::move(parsed_scripts.first));\n+                has_multipath |= (bool)parsed_scripts.second;\n+\n                 depths.push_back(branches.size());\n                 // Process closing braces; one is expected for every right branch we were in.\n                 while (branches.size() && branches.back()) {\n@@ -1287,8 +1306,8 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n         }\n         assert(TaprootBuilder::ValidDepths(depths));\n         return {\n-            std::make_unique<TRDescriptor>(std::move(internal_key), std::move(subscripts.first), std::move(depths)),\n-            nullptr\n+            std::make_unique<TRDescriptor>(std::move(internal_keys.first), std::move(subscripts.first), std::move(depths)),\n+            has_multipath ? std::make_unique<TRDescriptor>(std::move(internal_keys.second), std::move(subscripts.second), std::move(depths)) : nullptr\n         };\n     } else if (Func(\"tr\", expr)) {\n         error = \"Can only have tr at top level\";"
      }
    ]
  },
  {
    "sha": "d6da820cb972a6b349f292d251c479586f6a4190",
    "node_id": "C_kwDOABII59oAKGQ2ZGE4MjBjYjk3MmE2YjM0OWYyOTJkMjUxYzQ3OTU4NmY2YTQxOTA",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T21:13:02Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:18:55Z"
      },
      "message": "descriptors: Have ParseKeypath handle multipath specifiers\n\nMultipath specifiers are derivation path indexes of the form `<r;c>`\nused for specifying derivation paths for receiving and change\ndescriptors. Only one multipath specifier is allowed per PubkeyProvider,\nand it must only contain two path indexes. This is syntactic sugar which\nis parsed into two distinct descriptors. One descriptor will have all of\nthe `r` paths, the other all of the `c` paths.\n\nParseKeypath will always return a pair of keypaths. If no multipath\ndescriptor is provided, the second one will be a std::nullopt. The\ncallers of this function are updated to deal with this case and return\nmultiple PubkeyProviders. Their callers have also been updated to handle\npairs of PubkeyProviders.",
      "tree": {
        "sha": "a586cfa33ad98a4fbca4c29b248d0e0f2644f5ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a586cfa33ad98a4fbca4c29b248d0e0f2644f5ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6da820cb972a6b349f292d251c479586f6a4190",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6da820cb972a6b349f292d251c479586f6a4190",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6da820cb972a6b349f292d251c479586f6a4190",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6da820cb972a6b349f292d251c479586f6a4190/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cfc49e44376b9fdea40370fd1c641b6fbd958a32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfc49e44376b9fdea40370fd1c641b6fbd958a32",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cfc49e44376b9fdea40370fd1c641b6fbd958a32"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 69,
      "deletions": 20
    },
    "files": [
      {
        "sha": "8ad322c0cae6d36171edc0947ded883a4ca1bf95",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 20,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6da820cb972a6b349f292d251c479586f6a4190/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6da820cb972a6b349f292d251c479586f6a4190/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=d6da820cb972a6b349f292d251c479586f6a4190",
        "patch": "@@ -960,25 +960,72 @@ enum class ParseScriptContext {\n };\n \n /** Parse a key path, being passed a split list of elements (the first element is ignored). */\n-[[nodiscard]] bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out, std::string& error)\n+[[nodiscard]] bool ParseKeyPath(const std::vector<Span<const char>>& split, std::pair<KeyPath, std::optional<KeyPath>>& out, std::string& error, bool allow_multipath = false)\n {\n+    using namespace spanparsing;\n+\n+    out.second.reset();\n+\n+    KeyPath a;\n+    KeyPath b;\n+    bool is_multi = false;\n+    bool has_multi = false;\n     for (size_t i = 1; i < split.size(); ++i) {\n-        Span<const char> elem = split[i];\n-        bool hardened = false;\n-        if (elem.size() > 0 && (elem[elem.size() - 1] == '\\'' || elem[elem.size() - 1] == 'h')) {\n-            elem = elem.first(elem.size() - 1);\n-            hardened = true;\n+        std::vector<Span<const char>> to_process;\n+        Span<const char> item = split[i];\n+        if (item.size() > 0 && item[0] == '<' && item[item.size() - 1] == '>') {\n+            if (!allow_multipath) {\n+                error = strprintf(\"Key path value '%s' specifies multipath in a section where multipath is not allowed\", std::string(item.begin(), item.end()));\n+                return false;\n+            }\n+            if (has_multi) {\n+                error = \"Multiple multipath key path specifiers found\";\n+                return false;\n+            }\n+            to_process = Split(item.subspan(1, item.size() - 2), ';');\n+            if (to_process.size() != 2) {\n+                error = strprintf(\"Multipath key path value '%s' can only specify 2 paths\", std::string(item.begin(), item.end()));\n+                return false;\n+            }\n+            has_multi = true;\n+            is_multi = true;\n+        } else {\n+            to_process.push_back(item);\n         }\n-        uint32_t p;\n-        if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p)) {\n-            error = strprintf(\"Key path value '%s' is not a valid uint32\", std::string(elem.begin(), elem.end()));\n-            return false;\n-        } else if (p > 0x7FFFFFFFUL) {\n-            error = strprintf(\"Key path value %u is out of range\", p);\n-            return false;\n+        for (size_t j = 0; j < to_process.size(); ++j) {\n+            auto& elem = to_process[j];\n+            bool is_multipath_elem = to_process.size() == 2;\n+            bool is_multipath_second = j == 1;\n+            bool hardened = false;\n+            if (elem.size() > 0 && (elem[elem.size() - 1] == '\\'' || elem[elem.size() - 1] == 'h')) {\n+                elem = elem.first(elem.size() - 1);\n+                hardened = true;\n+            }\n+            uint32_t p;\n+            if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p)) {\n+                error = strprintf(\"Key path value '%s' is not a valid uint32\", std::string(elem.begin(), elem.end()));\n+                return false;\n+            } else if (p > 0x7FFFFFFFUL) {\n+                error = strprintf(\"Key path value %u is out of range\", p);\n+                return false;\n+            }\n+            p |= ((uint32_t)hardened) << 31;\n+\n+            if (is_multipath_elem && is_multipath_second) {\n+                b.push_back(p);\n+            } else {\n+                a.push_back(p);\n+                if (!is_multipath_elem) {\n+                    b.push_back(p);\n+                }\n+            }\n         }\n-        out.push_back(p | (((uint32_t)hardened) << 31));\n     }\n+    out.first = a;\n+    if (is_multi) {\n+        out.second = b;\n+    }\n+\n     return true;\n }\n \n@@ -1034,7 +1081,7 @@ std::pair<std::unique_ptr<PubkeyProvider>, std::unique_ptr<PubkeyProvider>> Pars\n         error = strprintf(\"key '%s' is not valid\", str);\n         return {nullptr, nullptr};\n     }\n-    KeyPath path;\n+    std::pair<KeyPath, std::optional<KeyPath>> path;\n     DeriveType type = DeriveType::NO;\n     if (split.back() == MakeSpan(\"*\").first(1)) {\n         split.pop_back();\n@@ -1043,14 +1090,14 @@ std::pair<std::unique_ptr<PubkeyProvider>, std::unique_ptr<PubkeyProvider>> Pars\n         split.pop_back();\n         type = DeriveType::HARDENED;\n     }\n-    if (!ParseKeyPath(split, path, error)) return {nullptr, nullptr};\n+    if (!ParseKeyPath(split, path, error, true)) return {nullptr, nullptr};\n     if (extkey.key.IsValid()) {\n         extpubkey = extkey.Neuter();\n         out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n     }\n     return {\n-        std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path), type),\n-        nullptr\n+        std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path.first), type),\n+        path.second ? std::make_unique<BIP32PubkeyProvider>(key_exp_index, extpubkey, std::move(path.second.value()), type) : nullptr\n     };\n }\n \n@@ -1085,7 +1132,9 @@ std::pair<std::unique_ptr<PubkeyProvider>, std::unique_ptr<PubkeyProvider>> Pars\n     static_assert(sizeof(info.fingerprint) == 4, \"Fingerprint must be 4 bytes\");\n     assert(fpr_bytes.size() == 4);\n     std::copy(fpr_bytes.begin(), fpr_bytes.end(), info.fingerprint);\n-    if (!ParseKeyPath(slash_split, info.path, error)) return {nullptr, nullptr};\n+    std::pair<KeyPath, std::optional<KeyPath>> path;\n+    if (!ParseKeyPath(slash_split, path, error)) return {nullptr, nullptr};\n+    info.path = path.first;\n     auto providers = ParsePubkeyInner(key_exp_index, origin_split[1], ctx, out, error);\n     if (!providers.first) return {nullptr, nullptr};\n     return {\n@@ -1156,8 +1205,8 @@ std::pair<std::unique_ptr<DescriptorImpl>, std::unique_ptr<DescriptorImpl>> Pars\n                 has_multipath = true;\n             }\n             script_size += pks.first->GetSize() + 1;\n-            providers.first.emplace_back(std::move(pks.first));\n             providers.second.emplace_back(pks.second ? std::move(pks.second) : std::move(pks.first->Clone()));\n+            providers.first.emplace_back(std::move(pks.first));\n             key_exp_index++;\n         }\n         assert(providers.first.size() == providers.second.size());"
      }
    ]
  },
  {
    "sha": "39074b7a058036fa9e690995b50d85b819f379dd",
    "node_id": "C_kwDOABII59oAKDM5MDc0YjdhMDU4MDM2ZmE5ZTY5MDk5NWI1MGQ4NWI4MTlmMzc5ZGQ",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-16T21:20:35Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "descriptors: Change Parse to return pair of descriptors\n\nWhen given a descriptor which contins a multipath derivation specifier,\na pair of descriptors will be returned.",
      "tree": {
        "sha": "48f1943f689d2dca1b75bcd505d9af75a1e166e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/48f1943f689d2dca1b75bcd505d9af75a1e166e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39074b7a058036fa9e690995b50d85b819f379dd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39074b7a058036fa9e690995b50d85b819f379dd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39074b7a058036fa9e690995b50d85b819f379dd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39074b7a058036fa9e690995b50d85b819f379dd/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6da820cb972a6b349f292d251c479586f6a4190",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6da820cb972a6b349f292d251c479586f6a4190",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6da820cb972a6b349f292d251c479586f6a4190"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 71,
      "deletions": 42
    },
    "files": [
      {
        "sha": "465988bd9d1f446f8bb63bdb8d3fcc82f6d6b854",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -151,7 +151,7 @@ void TestGUI(interfaces::Node& node)\n         // Add the coinbase key\n         FlatSigningProvider provider;\n         std::string error;\n-        std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(test.coinbaseKey) + \")\", provider, error, /* require_checksum=*/ false);\n+        std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(test.coinbaseKey) + \")\", provider, error, /* require_checksum=*/ false).first;\n         assert(desc);\n         WalletDescriptor w_desc(std::move(desc), 0, 0, 1, 1);\n         if (!wallet->AddWalletDescriptor(w_desc, provider, \"\", false)) assert(false);"
      },
      {
        "sha": "3d9845ffc82a3b723fe4fc8d1be4b3265f6bc763",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -175,7 +175,11 @@ static UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me\n static bool getScriptFromDescriptor(const std::string& descriptor, CScript& script, std::string& error)\n {\n     FlatSigningProvider key_provider;\n-    const auto desc = Parse(descriptor, key_provider, error, /* require_checksum = */ false);\n+    const auto descs = Parse(descriptor, key_provider, error, /* require_checksum = */ false);\n+    if (descs.second) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Multipath descriptor not accepted\");\n+    }\n+    const auto& desc = descs.first;\n     if (desc) {\n         if (desc->IsRange()) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Ranged descriptor not accepted. Maybe pass through deriveaddresses first?\");"
      },
      {
        "sha": "130d6381851b60ca3c46155d2e43f8b75d3c5f2e",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 7,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -170,6 +170,7 @@ static RPCHelpMan getdescriptorinfo()\n                 RPCResult::Type::OBJ, \"\", \"\",\n                 {\n                     {RPCResult::Type::STR, \"descriptor\", \"The descriptor in canonical form, without private keys\"},\n+                    {RPCResult::Type::STR, \"descriptor_change\", \"The change descriptor in canonical form, without private keys. Only if the provided descriptor specifies derivation paths for both receiving and change.\"},\n                     {RPCResult::Type::STR, \"checksum\", \"The checksum for the input descriptor\"},\n                     {RPCResult::Type::BOOL, \"isrange\", \"Whether the descriptor is ranged\"},\n                     {RPCResult::Type::BOOL, \"issolvable\", \"Whether the descriptor is solvable\"},\n@@ -187,16 +188,21 @@ static RPCHelpMan getdescriptorinfo()\n \n     FlatSigningProvider provider;\n     std::string error;\n-    auto desc = Parse(request.params[0].get_str(), provider, error);\n-    if (!desc) {\n+    auto descs = Parse(request.params[0].get_str(), provider, error);\n+    auto& recv_desc = descs.first;\n+    auto& change_desc = descs.second;\n+    if (!recv_desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n \n     UniValue result(UniValue::VOBJ);\n-    result.pushKV(\"descriptor\", desc->ToString());\n+    result.pushKV(\"descriptor\", recv_desc->ToString());\n+    if (change_desc) {\n+        result.pushKV(\"descriptor_change\", change_desc->ToString());\n+    }\n     result.pushKV(\"checksum\", GetDescriptorChecksum(request.params[0].get_str()));\n-    result.pushKV(\"isrange\", desc->IsRange());\n-    result.pushKV(\"issolvable\", desc->IsSolvable());\n+    result.pushKV(\"isrange\", recv_desc->IsRange());\n+    result.pushKV(\"issolvable\", recv_desc->IsSolvable());\n     result.pushKV(\"hasprivatekeys\", provider.keys.size() > 0);\n     return result;\n },\n@@ -216,7 +222,8 @@ static RPCHelpMan deriveaddresses()\n             \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n             \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n             \"or more path elements separated by \\\"/\\\", where \\\"h\\\" represents a hardened child key.\\n\"\n-            \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\"},\n+            \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\"\n+            \"Note that only descriptors that specify a single derivation path can be derived.\\n\"},\n             {\n                 {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The descriptor.\"},\n                 {\"range\", RPCArg::Type::RANGE, RPCArg::Optional::OMITTED_NAMED_ARG, \"If a ranged descriptor is used, this specifies the end or the range (in [begin,end] notation) to derive.\"},\n@@ -246,7 +253,11 @@ static RPCHelpMan deriveaddresses()\n \n     FlatSigningProvider key_provider;\n     std::string error;\n-    auto desc = Parse(desc_str, key_provider, error, /* require_checksum = */ true);\n+    auto descs = Parse(desc_str, key_provider, error, /* require_checksum = */ true);\n+    if (descs.second) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor specifying both receiving and change derivation paths are not allowed\");\n+    }\n+    auto& desc = descs.first;\n     if (!desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }"
      },
      {
        "sha": "588a6a22d5565baccaaf009b6eb561e4bb205dfb",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -1008,21 +1008,25 @@ std::vector<CScript> EvalDescriptorStringOrObject(const UniValue& scanobject, Fl\n     }\n \n     std::string error;\n-    auto desc = Parse(desc_str, provider, error);\n-    if (!desc) {\n+    auto descs = Parse(desc_str, provider, error);\n+    if (!descs.first) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n-    if (!desc->IsRange()) {\n+    if (!descs.first->IsRange()) {\n         range.first = 0;\n         range.second = 0;\n     }\n     std::vector<CScript> ret;\n     for (int i = range.first; i <= range.second; ++i) {\n-        std::vector<CScript> scripts;\n-        if (!desc->Expand(i, provider, scripts, provider)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys: '%s'\", desc_str));\n+        for (int j = 0; j < 2; ++j) {\n+            const auto& desc = j == 0 ? descs.first : descs.second;\n+            if (!desc) continue;\n+            std::vector<CScript> scripts;\n+            if (!desc->Expand(i, provider, scripts, provider)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys: '%s'\", desc_str));\n+            }\n+            std::move(scripts.begin(), scripts.end(), std::back_inserter(ret));\n         }\n-        std::move(scripts.begin(), scripts.end(), std::back_inserter(ret));\n     }\n     return ret;\n }"
      },
      {
        "sha": "53729d7a6926a29f0ae712f47664656fa61f34c4",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -1553,14 +1553,14 @@ bool CheckChecksum(Span<const char>& sp, bool require_checksum, std::string& err\n     return true;\n }\n \n-std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out, std::string& error, bool require_checksum)\n+std::pair<std::unique_ptr<Descriptor>, std::unique_ptr<Descriptor>> Parse(const std::string& descriptor, FlatSigningProvider& out, std::string& error, bool require_checksum)\n {\n     Span<const char> sp{descriptor};\n-    if (!CheckChecksum(sp, require_checksum, error)) return nullptr;\n+    if (!CheckChecksum(sp, require_checksum, error)) return {nullptr, nullptr};\n     uint32_t key_exp_index = 0;\n     auto ret = ParseScript(key_exp_index, sp, ParseScriptContext::TOP, out, error);\n-    if (sp.size() == 0 && ret.first) return std::unique_ptr<Descriptor>(std::move(ret.first));\n-    return nullptr;\n+    if (sp.size() == 0 && ret.first) return {std::unique_ptr<Descriptor>(std::move(ret.first)), ret.second ? std::unique_ptr<Descriptor>(std::move(ret.second)) : nullptr};\n+    return {nullptr, nullptr};\n }\n \n std::string GetDescriptorChecksum(const std::string& descriptor)"
      },
      {
        "sha": "5cdf8bc726070f75dbed34d3fc84bc618e6cdcb5",
        "filename": "src/script/descriptor.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/script/descriptor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/script/descriptor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.h?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -156,7 +156,7 @@ struct Descriptor {\n  * If a parse error occurs, or the checksum is missing/invalid, or anything\n  * else is wrong, `nullptr` is returned.\n  */\n-std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out, std::string& error, bool require_checksum = false);\n+std::pair<std::unique_ptr<Descriptor>, std::unique_ptr<Descriptor>> Parse(const std::string& descriptor, FlatSigningProvider& out, std::string& error, bool require_checksum = false);\n \n /** Get the checksum for a `descriptor`.\n  *"
      },
      {
        "sha": "da9a974109e29fc4b329920811ee553114a5b6a1",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -21,8 +21,8 @@ void CheckUnparsable(const std::string& prv, const std::string& pub, const std::\n {\n     FlatSigningProvider keys_priv, keys_pub;\n     std::string error;\n-    auto parse_priv = Parse(prv, keys_priv, error);\n-    auto parse_pub = Parse(pub, keys_pub, error);\n+    auto parse_priv = Parse(prv, keys_priv, error).first;\n+    auto parse_pub = Parse(pub, keys_pub, error).first;\n     BOOST_CHECK_MESSAGE(!parse_priv, prv);\n     BOOST_CHECK_MESSAGE(!parse_pub, pub);\n     BOOST_CHECK_EQUAL(error, expected_error);\n@@ -86,14 +86,14 @@ void DoCheck(const std::string& prv, const std::string& pub, const std::string&\n     std::unique_ptr<Descriptor> parse_pub;\n     // Check that parsing succeeds.\n     if (replace_apostrophe_with_h_in_prv) {\n-        parse_priv = Parse(UseHInsteadOfApostrophe(prv), keys_priv, error);\n+        parse_priv = Parse(UseHInsteadOfApostrophe(prv), keys_priv, error).first;\n     } else {\n-        parse_priv = Parse(prv, keys_priv, error);\n+        parse_priv = Parse(prv, keys_priv, error).first;\n     }\n     if (replace_apostrophe_with_h_in_pub) {\n-        parse_pub = Parse(UseHInsteadOfApostrophe(pub), keys_pub, error);\n+        parse_pub = Parse(UseHInsteadOfApostrophe(pub), keys_pub, error).first;\n     } else {\n-        parse_pub = Parse(pub, keys_pub, error);\n+        parse_pub = Parse(pub, keys_pub, error).first;\n     }\n \n     BOOST_CHECK(parse_priv);"
      },
      {
        "sha": "ce91b70b40f0c0e6f4682d9e5d69bf927a064063",
        "filename": "src/test/fuzz/descriptor_parse.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/test/fuzz/descriptor_parse.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/test/fuzz/descriptor_parse.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/descriptor_parse.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -21,10 +21,16 @@ FUZZ_TARGET_INIT(descriptor_parse, initialize_descriptor_parse)\n     std::string error;\n     for (const bool require_checksum : {true, false}) {\n         const auto desc = Parse(descriptor, signing_provider, error, require_checksum);\n-        if (desc) {\n-            (void)desc->ToString();\n-            (void)desc->IsRange();\n-            (void)desc->IsSolvable();\n+        if (desc.first) {\n+            (void)desc.first->ToString();\n+            (void)desc.first->IsRange();\n+            (void)desc.first->IsSolvable();\n+        }\n+        if (desc.second) {\n+            assert(desc.first);\n+            (void)desc.second->ToString();\n+            assert(desc.first->IsRange() == desc.second->IsRange());\n+            assert(desc.first->IsSolvable() == desc.second->IsSolvable());\n         }\n     }\n }"
      },
      {
        "sha": "445c154723099c040675c31f66d46fc727d960b0",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -1094,7 +1094,7 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n     const std::string& descriptor = data[\"desc\"].get_str();\n     FlatSigningProvider keys;\n     std::string error;\n-    auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true);\n+    auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true).first;\n     if (!parsed_desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n@@ -1471,7 +1471,7 @@ static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, c\n         // Parse descriptor string\n         FlatSigningProvider keys;\n         std::string error;\n-        auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true);\n+        auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true).first;\n         if (!parsed_desc) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n         }"
      },
      {
        "sha": "09e613f392062fe2552e61b126228b86bf954dd9",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -3384,12 +3384,16 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n                 FlatSigningProvider desc_out;\n                 std::string error;\n                 std::vector<CScript> scripts_temp;\n-                std::unique_ptr<Descriptor> desc = Parse(desc_str, desc_out, error, true);\n-                if (!desc) {\n+                std::pair<std::unique_ptr<Descriptor>, std::unique_ptr<Descriptor>> descs = Parse(desc_str, desc_out, error, true);\n+                if (!descs.first) {\n                     throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Unable to parse descriptor '%s': %s\", desc_str, error));\n                 }\n-                desc->Expand(0, desc_out, scripts_temp, desc_out);\n+                descs.first->Expand(0, desc_out, scripts_temp, desc_out);\n                 coinControl.m_external_provider = Merge(coinControl.m_external_provider, desc_out);\n+                if (descs.second) {\n+                    descs.second->Expand(0, desc_out, scripts_temp, desc_out);\n+                    coinControl.m_external_provider = Merge(coinControl.m_external_provider, desc_out);\n+                }\n             }\n         }\n     }"
      },
      {
        "sha": "012292bd991b6755e41aad6c1275ae0746d58fe6",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -1928,7 +1928,7 @@ bool DescriptorScriptPubKeyMan::SetupDescriptorGeneration(const CExtKey& master_\n     // Make the descriptor\n     FlatSigningProvider keys;\n     std::string error;\n-    std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, error, false);\n+    std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, error, false).first;\n     WalletDescriptor w_desc(std::move(desc), creation_time, 0, 0, 0);\n     m_wallet_descriptor = w_desc;\n "
      },
      {
        "sha": "85faf7640a61252e961731fd0087ce2d53f33293",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -18,7 +18,7 @@ static void import_descriptor(CWallet& wallet, const std::string& descriptor)\n     LOCK(wallet.cs_wallet);\n     FlatSigningProvider provider;\n     std::string error;\n-    std::unique_ptr<Descriptor> desc = Parse(descriptor, provider, error, /* require_checksum=*/ false);\n+    std::unique_ptr<Descriptor> desc = Parse(descriptor, provider, error, /* require_checksum=*/ false).first;\n     assert(desc);\n     WalletDescriptor w_desc(std::move(desc), 0, 0, 10, 0);\n     wallet.AddWalletDescriptor(w_desc, provider, \"\", false);"
      },
      {
        "sha": "bfce3cbe34e1808fe72908318a21b33c792a2ad1",
        "filename": "src/wallet/test/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/util.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -30,7 +30,7 @@ std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cc\n \n         FlatSigningProvider provider;\n         std::string error;\n-        std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(key) + \")\", provider, error, /* require_checksum=*/ false);\n+        std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(key) + \")\", provider, error, /* require_checksum=*/ false).first;\n         assert(desc);\n         WalletDescriptor w_desc(std::move(desc), 0, 0, 1, 1);\n         if (!wallet->AddWalletDescriptor(w_desc, provider, \"\", false)) assert(false);"
      },
      {
        "sha": "46c926a39f875f1c96ee7518151c5a5660655e51",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -82,7 +82,7 @@ static void AddKey(CWallet& wallet, const CKey& key)\n     LOCK(wallet.cs_wallet);\n     FlatSigningProvider provider;\n     std::string error;\n-    std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(key) + \")\", provider, error, /* require_checksum=*/ false);\n+    std::unique_ptr<Descriptor> desc = Parse(\"combo(\" + EncodeSecret(key) + \")\", provider, error, /* require_checksum=*/ false).first;\n     assert(desc);\n     WalletDescriptor w_desc(std::move(desc), 0, 0, 1, 1);\n     if (!wallet.AddWalletDescriptor(w_desc, provider, \"\", false)) assert(false);"
      },
      {
        "sha": "8248b9fba429c10eb744e4cba67dfbca2372f980",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -3199,7 +3199,7 @@ void CWallet::SetupDescriptorScriptPubKeyMans()\n                 std::string desc_str = desc_val.getValStr();\n                 FlatSigningProvider keys;\n                 std::string dummy_error;\n-                std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, dummy_error, false);\n+                std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, dummy_error, false).first;\n                 if (!desc->GetOutputType()) {\n                     continue;\n                 }"
      },
      {
        "sha": "948ffe548b29f5a6b226ca5b250f3e34e3ac8b0b",
        "filename": "src/wallet/walletutil.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/walletutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39074b7a058036fa9e690995b50d85b819f379dd/src/wallet/walletutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletutil.h?ref=39074b7a058036fa9e690995b50d85b819f379dd",
        "patch": "@@ -86,7 +86,7 @@ class WalletDescriptor\n     {\n         std::string error;\n         FlatSigningProvider keys;\n-        descriptor = Parse(str, keys, error, true);\n+        descriptor = Parse(str, keys, error, true).first;\n         if (!descriptor) {\n             throw std::ios_base::failure(\"Invalid descriptor: \" + error);\n         }"
      }
    ]
  },
  {
    "sha": "236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
    "node_id": "C_kwDOABII59oAKDIzNmU2MzU0ZGI0YzIwNGNjNThjOTNmZGIzZWM4NmRhZTJhNGFjZjk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-23T20:39:57Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "tests: Add unit tests for multipath descriptors",
      "tree": {
        "sha": "8763b77cd4bdc25275cbea9dd94bb3e5593fcdaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8763b77cd4bdc25275cbea9dd94bb3e5593fcdaf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/236e6354db4c204cc58c93fdb3ec86dae2a4acf9/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39074b7a058036fa9e690995b50d85b819f379dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39074b7a058036fa9e690995b50d85b819f379dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39074b7a058036fa9e690995b50d85b819f379dd"
      }
    ],
    "stats": {
      "total": 185,
      "additions": 165,
      "deletions": 20
    },
    "files": [
      {
        "sha": "efcecb115ba6599bf75e1bf06de3da629f35a16d",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 165,
        "deletions": 20,
        "changes": 185,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/236e6354db4c204cc58c93fdb3ec86dae2a4acf9/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/236e6354db4c204cc58c93fdb3ec86dae2a4acf9/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
        "patch": "@@ -37,11 +37,13 @@ void CheckInferRaw(const CScript& script)\n }\n \n constexpr int DEFAULT = 0;\n-constexpr int RANGE = 1; // Expected to be ranged descriptor\n-constexpr int HARDENED = 2; // Derivation needs access to private keys\n-constexpr int UNSOLVABLE = 4; // This descriptor is not expected to be solvable\n-constexpr int SIGNABLE = 8; // We can sign with this descriptor (this is not true when actual BIP32 derivation is used, as that's not integrated in our signing code)\n-constexpr int DERIVE_HARDENED = 16; // The final derivation is hardened, i.e. ends with *' or *h\n+constexpr int RANGE = 1 << 0; // Expected to be ranged descriptor\n+constexpr int HARDENED = 1 << 1; // Derivation needs access to private keys\n+constexpr int UNSOLVABLE = 1 << 2; // This descriptor is not expected to be solvable\n+constexpr int SIGNABLE = 1 << 3; // We can sign with this descriptor (this is not true when actual BIP32 derivation is used, as that's not integrated in our signing code)\n+constexpr int DERIVE_HARDENED = 1 << 4; // The final derivation is hardened, i.e. ends with *' or *h\n+constexpr int MULTIPATH_FIRST = 1 << 5; // Must be a multipath descriptor. Use the first descriptor in the pair (the receive descriptor).\n+constexpr int MULTIPATH_SECOND = 1 << 6; // Must be a multipath descriptor. Use the second descriptor in the pair (the change descriptor).\n \n /** Compare two descriptors. If only one of them has a checksum, the checksum is ignored. */\n bool EqualDescriptor(std::string a, std::string b)\n@@ -76,24 +78,42 @@ std::string UseHInsteadOfApostrophe(const std::string& desc)\n const std::set<std::vector<uint32_t>> ONLY_EMPTY{{}};\n \n void DoCheck(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const std::optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY,\n-    bool replace_apostrophe_with_h_in_prv=false, bool replace_apostrophe_with_h_in_pub=false)\n+    bool replace_apostrophe_with_h_in_prv=false, bool replace_apostrophe_with_h_in_pub=false, std::optional<std::string> expected_prv = std::nullopt, std::optional<std::string> expected_pub = std::nullopt)\n {\n+    bool multipath = (flags & MULTIPATH_FIRST) || (flags & MULTIPATH_SECOND);\n     FlatSigningProvider keys_priv, keys_pub;\n     std::set<std::vector<uint32_t>> left_paths = paths;\n     std::string error;\n \n     std::unique_ptr<Descriptor> parse_priv;\n     std::unique_ptr<Descriptor> parse_pub;\n     // Check that parsing succeeds.\n+    std::pair<std::unique_ptr<Descriptor>, std::unique_ptr<Descriptor>> parsed;\n     if (replace_apostrophe_with_h_in_prv) {\n-        parse_priv = Parse(UseHInsteadOfApostrophe(prv), keys_priv, error).first;\n+        parsed = Parse(UseHInsteadOfApostrophe(prv), keys_priv, error);\n     } else {\n-        parse_priv = Parse(prv, keys_priv, error).first;\n+        parsed = Parse(prv, keys_priv, error);\n+    }\n+    BOOST_CHECK_MESSAGE((!multipath && !parsed.second) || (multipath && parsed.second), prv);\n+    if (!multipath || flags & MULTIPATH_FIRST) {\n+        parse_priv = std::move(parsed.first);\n+    } else if (flags & MULTIPATH_SECOND) {\n+        parse_priv = std::move(parsed.second);\n+    } else {\n+        assert(false);\n     }\n     if (replace_apostrophe_with_h_in_pub) {\n-        parse_pub = Parse(UseHInsteadOfApostrophe(pub), keys_pub, error).first;\n+        parsed = Parse(UseHInsteadOfApostrophe(pub), keys_pub, error);\n+    } else {\n+        parsed = Parse(pub, keys_pub, error);\n+    }\n+    BOOST_CHECK_MESSAGE((!multipath && !parsed.second) || (multipath && parsed.second), pub);\n+    if (!multipath || flags & MULTIPATH_FIRST) {\n+        parse_pub = std::move(parsed.first);\n+    } else if (flags & MULTIPATH_SECOND) {\n+        parse_pub = std::move(parsed.second);\n     } else {\n-        parse_pub = Parse(pub, keys_pub, error).first;\n+        assert(false);\n     }\n \n     BOOST_CHECK(parse_priv);\n@@ -107,19 +127,33 @@ void DoCheck(const std::string& prv, const std::string& pub, const std::string&\n     BOOST_CHECK(keys_priv.keys.size());\n     BOOST_CHECK(!keys_pub.keys.size());\n \n-    // Check that both versions serialize back to the public version.\n+    // If expected_pub is provided, check that the serialize matches that.\n+    // Otherwse check that they serialize back to the public version.\n     std::string pub1 = parse_priv->ToString();\n     std::string pub2 = parse_pub->ToString();\n-    BOOST_CHECK(EqualDescriptor(pub, pub1));\n-    BOOST_CHECK(EqualDescriptor(pub, pub2));\n+    if (expected_pub) {\n+        BOOST_CHECK(EqualDescriptor(*expected_pub, pub1));\n+        BOOST_CHECK(EqualDescriptor(*expected_pub, pub2));\n+    } else {\n+        BOOST_CHECK(EqualDescriptor(pub, pub1));\n+        BOOST_CHECK(EqualDescriptor(pub, pub2));\n+    }\n \n     // Check that both can be serialized with private key back to the private version, but not without private key.\n     std::string prv1;\n     BOOST_CHECK(parse_priv->ToPrivateString(keys_priv, prv1));\n-    BOOST_CHECK(EqualDescriptor(prv, prv1));\n+    if (expected_prv) {\n+        BOOST_CHECK(EqualDescriptor(*expected_prv, prv1));\n+    } else {\n+        BOOST_CHECK(EqualDescriptor(prv, prv1));\n+    }\n     BOOST_CHECK(!parse_priv->ToPrivateString(keys_pub, prv1));\n     BOOST_CHECK(parse_pub->ToPrivateString(keys_priv, prv1));\n-    BOOST_CHECK(EqualDescriptor(prv, prv1));\n+    if (expected_prv) {\n+        BOOST_CHECK(EqualDescriptor(*expected_prv, prv1));\n+    } else {\n+        BOOST_CHECK(EqualDescriptor(prv, prv1));\n+    }\n     BOOST_CHECK(!parse_pub->ToPrivateString(keys_pub, prv1));\n \n     // Check that private can produce the normalized descriptors\n@@ -268,32 +302,53 @@ void DoCheck(const std::string& prv, const std::string& pub, const std::string&\n     BOOST_CHECK_MESSAGE(left_paths.empty(), \"Not all expected key paths found: \" + prv);\n }\n \n-void Check(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const std::optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY)\n+void Check(const std::string& prv, const std::string& pub, const std::string& norm_prv, const std::string& norm_pub, int flags, const std::vector<std::vector<std::string>>& scripts, const std::optional<OutputType>& type, const std::set<std::vector<uint32_t>>& paths = ONLY_EMPTY, std::optional<std::string> expected_prv = std::nullopt, std::optional<std::string> expected_pub = std::nullopt)\n {\n     bool found_apostrophes_in_prv = false;\n     bool found_apostrophes_in_pub = false;\n \n     // Do not replace apostrophes with 'h' in prv and pub\n-    DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths);\n+    DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, false, false, expected_prv, expected_pub);\n \n     // Replace apostrophes with 'h' in prv but not in pub, if apostrophes are found in prv\n     if (prv.find('\\'') != std::string::npos) {\n         found_apostrophes_in_prv = true;\n-        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */true, /*replace_apostrophe_with_h_in_pub = */false);\n+        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */true, /*replace_apostrophe_with_h_in_pub = */false, expected_prv, expected_pub);\n     }\n \n     // Replace apostrophes with 'h' in pub but not in prv, if apostrophes are found in pub\n     if (pub.find('\\'') != std::string::npos) {\n         found_apostrophes_in_pub = true;\n-        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */false, /*replace_apostrophe_with_h_in_pub = */true);\n+        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */false, /*replace_apostrophe_with_h_in_pub = */true, expected_prv, expected_pub);\n     }\n \n     // Replace apostrophes with 'h' both in prv and in pub, if apostrophes are found in both\n     if (found_apostrophes_in_prv && found_apostrophes_in_pub) {\n-        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */true, /*replace_apostrophe_with_h_in_pub = */true);\n+        DoCheck(prv, pub, norm_prv, norm_pub, flags, scripts, type, paths, /* replace_apostrophe_with_h_in_prv = */true, /*replace_apostrophe_with_h_in_pub = */true, expected_prv, expected_pub);\n     }\n }\n \n+void CheckMultipath(const std::string& prv,\n+        const std::string& pub,\n+        const std::string& recv_prv,\n+        const std::string& recv_pub,\n+        const std::string& chng_prv,\n+        const std::string& chng_pub,\n+        const std::string& recv_norm_prv,\n+        const std::string& recv_norm_pub,\n+        const std::string& chng_norm_prv,\n+        const std::string& chng_norm_pub,\n+        int flags,\n+        const std::vector<std::vector<std::string>>& recv_scripts,\n+        const std::vector<std::vector<std::string>>& chng_scripts,\n+        const std::optional<OutputType>& type,\n+        const std::set<std::vector<uint32_t>>& recv_paths = ONLY_EMPTY,\n+        const std::set<std::vector<uint32_t>>& chng_paths = ONLY_EMPTY)\n+{\n+    Check(prv, pub, recv_norm_prv, recv_norm_pub, flags | MULTIPATH_FIRST, recv_scripts, type, recv_paths, recv_prv, recv_pub);\n+    Check(prv, pub, chng_norm_prv, chng_norm_pub, flags | MULTIPATH_SECOND, chng_scripts, type, chng_paths, chng_prv, chng_pub);\n+}\n+\n }\n \n BOOST_FIXTURE_TEST_SUITE(descriptor_tests, BasicTestingSetup)\n@@ -338,6 +393,96 @@ BOOST_AUTO_TEST_CASE(descriptor_test)\n     CheckUnparsable(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/1aa)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/1aa)\", \"Key path value '1aa' is not a valid uint32\"); // Path is not valid uint\n     Check(\"pkh([01234567/10/20]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0)\", \"pkh([01234567/10/20]xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483647'/0)\", \"pkh([01234567/10/20/2147483647']xprv9vHkqa6XAPwKqSKSEJMcAB3yoCZhaSVsGZbSkFY5L3Lfjjk8sjZucbsbvEw5o3QrSA69nPfZDCgFnNnLhQ2ohpZuwummndnPasDw2Qr6dC2/0)\", \"pkh([01234567/10/20/2147483647']xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0)\", HARDENED, {{\"76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac\"}}, OutputType::LEGACY, {{10, 20, 0xFFFFFFFFUL, 0}});\n \n+    // Multipath versions with BIP32 derivations\n+    CheckMultipath(\"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/<0;1>)\",\n+            \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/<0;1>)\",\n+            \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\",\n+            \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\",\n+            \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/1)\",\n+            \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/1)\",\n+            \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)\",\n+            \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)\",\n+            \"pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/1)\",\n+            \"pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/1)\",\n+            DEFAULT,\n+            {{\"210379e45b3cf75f9c5f9befd8e9506fb962f6a9d185ac87001ec44a8d3df8d4a9e3ac\"}},\n+            {{\"21034f8d02282ac6786737d0f37f0df7655f49daa24843bc7de3f4ea88603d26d10aac\"}},\n+            std::nullopt,\n+            {{0}},\n+            {{1}}\n+    );\n+    CheckMultipath(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/<2147483647';0>/0)\",\n+            \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<2147483647';0>/0)\",\n+            \"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0)\",\n+            \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2147483647'/0)\",\n+            \"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/0/0)\",\n+            \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0/0)\",\n+            \"pkh([bd16bee5/2147483647']xprv9vHkqa6XAPwKqSKSEJMcAB3yoCZhaSVsGZbSkFY5L3Lfjjk8sjZucbsbvEw5o3QrSA69nPfZDCgFnNnLhQ2ohpZuwummndnPasDw2Qr6dC2/0)\",\n+            \"pkh([bd16bee5/2147483647']xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0)\",\n+            \"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/0/0)\",\n+            \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0/0)\",\n+            HARDENED,\n+            {{\"76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac\"}},\n+            {{\"76a914f103317b9f0b758a62cb3879281d23e3b1deb90d88ac\"}},\n+            OutputType::LEGACY,\n+            {{0xFFFFFFFFUL,0}},\n+            {{0,0}}\n+    );\n+    CheckMultipath(\"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/<1;3>/2/*)\",\n+            \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/<1;3>/2/*)\",\n+            \"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*)\",\n+            \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)\",\n+            \"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/3/2/*)\",\n+            \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/3/2/*)\",\n+            \"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*)\",\n+            \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)\",\n+            \"wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/3/2/*)\",\n+            \"wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/3/2/*)\",\n+            RANGE,\n+            {{\"0014326b2249e3a25d5dc60935f044ee835d090ba859\"},{\"0014af0bd98abc2f2cae66e36896a39ffe2d32984fb7\"},{\"00141fa798efd1cbf95cebf912c031b8a4a6e9fb9f27\"}},\n+            {{\"001426183882ef9c76b9a44386e9b387f33cee7c3a2d\"},{\"001447c1b9dc215c3f8b47e572981eb97528768cde4e\"},{\"00146e92cbaa397f9caeccf9a049460258af6ccd67e2\"}},\n+            OutputType::BECH32,\n+            {{0x8000000DUL, 1, 2, 0}, {0x8000000DUL, 1, 2, 1}, {0x8000000DUL, 1, 2, 2}},\n+            {{0x8000000DUL, 3, 2, 0}, {0x8000000DUL, 3, 2, 1}, {0x8000000DUL, 3, 2, 2}}\n+    );\n+    CheckMultipath(\"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/<10;100'>/20/30/40/*'))\",\n+            \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/<10;100'>/20/30/40/*'))\",\n+            \"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\",\n+            \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\",\n+            \"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/100'/20/30/40/*'))\",\n+            \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/100'/20/30/40/*'))\",\n+            \"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))\",\n+            \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/10/20/30/40/*'))\",\n+            \"sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/100'/20/30/40/*'))\",\n+            \"sh(wpkh(xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8/100'/20/30/40/*'))\",\n+            RANGE | HARDENED | DERIVE_HARDENED,\n+            {{\"a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87\"},{\"a914bed59fc0024fae941d6e20a3b44a109ae740129287\"},{\"a9148483aa1116eb9c05c482a72bada4b1db24af654387\"}},\n+            {{\"a91470192039cb9529aadf4e53e46d9ac6a13790865787\"},{\"a914855859faffabf1e4ed2bb7411ab66f4599b1abd287\"},{\"a9148f2cfd4b486de247c44684160da164617ccf2c2687\"}},\n+            OutputType::P2SH_SEGWIT,\n+            {{10, 20, 30, 40, 0x80000000UL}, {10, 20, 30, 40, 0x80000001UL}, {10, 20, 30, 40, 0x80000002UL}},\n+            {{0x80000064UL, 20, 30, 40, 0x80000000UL}, {0x80000064UL, 20, 30, 40, 0x80000001UL}, {0x80000064UL, 20, 30, 40, 0x80000002UL}}\n+    );\n+    CheckMultipath(\"multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/<1;2>/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/<3;4>/0/*)\",\n+            \"multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<1;2>/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/<3;4>/0/*)\",\n+            \"multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/1/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/3/0/*)\",\n+            \"multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/3/0/*)\",\n+            \"multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/2/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/4/0/*)\",\n+            \"multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/2/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/4/0/*)\",\n+            \"multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/1/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/3/0/*)\",\n+            \"multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/3/0/*)\",\n+            \"multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/2/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/4/0/*)\",\n+            \"multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/2/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/4/0/*)\",\n+            RANGE,\n+            {{\"522103095e95d8c50ae3f3fea93fa8e983f710489f60ff681a658c06eba64622c824b121020443e9e729b42628913f1a69b46b7d43ff87c46e86140e12ee420d7e2e8caf8c52ae\"},{\"5221027512d6bd74e24eeb1ad752d5be800adc5886ded11c5293a9a701db83658b526a2102371e912dea5fefa56158908fe4c9f66bc925a8939b10f3821e8f8be797b9ca8252ae\"},{\"522102cc9fd211dc0a1c8bb7a106ff831be0e253bc992f21d08fb8a6fd43fae51b9b892103e43eddc68afc9746c9d09ce0bf8067b4f2416287abbc422ed1ac300673b1104952ae\"}},\n+            {{\"5221031c0517fff3d483f06ca769bd2326bf30aca1c4de278e676e6ef760c3301244c6210316e171ff4f82dc62ad3f0d84c97865034fc5041eaa508b48c1d7af77f301c8bd52ae\"},{\"52210240f010ccff4202ade2ef87756f6b9af57bbf5ebcb0393b949e6e5d45d30bff36210229057a7e03510b8cb66727fab3f47a52a02ea94eae03e7c2e81b72a26781bfde52ae\"},{\"5221034052522058a07b647bd08fa1a9eaedae0222eac76ddd122ff8096ec969398de721038cb8180dd4c956848bcf191e45aaf297146207559fb8737881156aadaf13704152ae\"}},\n+            std::nullopt,\n+            {{1, 0}, {1, 1}, {1, 2}, {3, 0, 0}, {3, 0, 1}, {3, 0, 2}},\n+            {{2, 0}, {2, 1}, {2, 2}, {4, 0, 0}, {4, 0, 1}, {4, 0, 2}}\n+    );\n+    CheckUnparsable(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/<0;1;2>)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0;1;2>)\", \"Multipath key path value \\'<0;1;2>\\' can only specify 2 paths\");\n+    CheckUnparsable(\"pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/<0;1>/<2;3>)\", \"pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0;1>/<2;3>)\", \"Multiple multipath key path specifiers found\");\n+    CheckUnparsable(\"pkh([deadbeef/<0;1>]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/0)\", \"pkh([deadbeef/<0;1>]xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0)\", \"Key path value \\'<0;1>\\' specifies multipath in a section where multipath is not allowed\");\n+\n     // Multisig constructions\n     Check(\"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, std::nullopt);\n     Check(\"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", \"sortedmulti(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)\", \"sortedmulti(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)\", SIGNABLE, {{\"512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae\"}}, std::nullopt);"
      }
    ]
  },
  {
    "sha": "af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
    "node_id": "C_kwDOABII59oAKGFmNWQ2MmRmMjdjN2UwZmQyNzNmYjgyZThlMGZiMjRmMWI3MTczMzc",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-30T19:13:34Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "tests: Multipath descriptors for getdescriptorinfo",
      "tree": {
        "sha": "e359092b26ab3730df201e4299ad2f828455716c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e359092b26ab3730df201e4299ad2f828455716c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5d62df27c7e0fd273fb82e8e0fb24f1b717337/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/236e6354db4c204cc58c93fdb3ec86dae2a4acf9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/236e6354db4c204cc58c93fdb3ec86dae2a4acf9"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 16,
      "deletions": 2
    },
    "files": [
      {
        "sha": "af28df88384982f4e2185b728b6a10ee55e903dd",
        "filename": "test/functional/rpc_getdescriptorinfo.py",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af5d62df27c7e0fd273fb82e8e0fb24f1b717337/test/functional/rpc_getdescriptorinfo.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af5d62df27c7e0fd273fb82e8e0fb24f1b717337/test/functional/rpc_getdescriptorinfo.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getdescriptorinfo.py?ref=af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
        "patch": "@@ -19,10 +19,17 @@ def set_test_params(self):\n         self.extra_args = [[\"-disablewallet\"]]\n         self.wallet_names = []\n \n-    def test_desc(self, desc, isrange, issolvable, hasprivatekeys):\n+    def test_desc(self, desc, isrange, issolvable, hasprivatekeys, receive_desc=None, change_desc=None):\n         info = self.nodes[0].getdescriptorinfo(desc)\n         assert_equal(info, self.nodes[0].getdescriptorinfo(descsum_create(desc)))\n-        assert_equal(info['descriptor'], descsum_create(desc))\n+        if receive_desc is not None:\n+            assert_equal(info[\"descriptor\"], descsum_create(receive_desc))\n+        else:\n+            assert_equal(info['descriptor'], descsum_create(desc))\n+        if change_desc is not None:\n+            assert_equal(info[\"descriptor_change\"], descsum_create(change_desc))\n+        else:\n+            assert \"descriptor_change\" not in info\n         assert_equal(info['isrange'], isrange)\n         assert_equal(info['issolvable'], issolvable)\n         assert_equal(info['hasprivatekeys'], hasprivatekeys)\n@@ -60,6 +67,13 @@ def run_test(self):\n         self.test_desc(\"pkh([d34db33f/44'/0'/0']tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/*)\", isrange=True, issolvable=True, hasprivatekeys=False)\n         # A set of *1-of-2* P2WSH multisig outputs where the first multisig key is the *1/0/`i`* child of the first specified xpub and the second multisig key is the *0/0/`i`* child of the second specified xpub, and `i` is any number in a configurable range (`0-1000` by default).\n         self.test_desc(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/0/*,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/0/0/*))\", isrange=True, issolvable=True, hasprivatekeys=False)\n+        # A multipath descriptor\n+        self.test_desc(\"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/<0;1>/*)\", isrange=True, issolvable=True, hasprivatekeys=False,\n+            receive_desc=\"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/0/*)\",\n+            change_desc=\"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/*)\")\n+        self.test_desc(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/<1;2>/0/*,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/<2;3>/0/*))\", isrange=True, issolvable=True, hasprivatekeys=False,\n+            receive_desc=\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/0/*,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/2/0/*))\",\n+            change_desc=\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/2/0/*,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/3/0/*))\")\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
    "node_id": "C_kwDOABII59oAKGVhYTRjOWViZDUwOTIzYzdjM2MyNGU5ZDJmNWY5OWU4MjA1YTJlNGY",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-23T18:56:23Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "rpc: Have deriveaddresses derive receiving and change\n\nWhen given a multipath descriptor, derive both the receiving and change\ndescriptors. The derived addresses will be returned in an object\nconsisting of 2 arrays. For compatibility, when given a single path\ndescriptor, the addresses are provided in a single array as before.",
      "tree": {
        "sha": "28d55f1387ea02f6a370232734b42d79e5cb97e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28d55f1387ea02f6a370232734b42d79e5cb97e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5d62df27c7e0fd273fb82e8e0fb24f1b717337",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af5d62df27c7e0fd273fb82e8e0fb24f1b717337"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 62,
      "deletions": 33
    },
    "files": [
      {
        "sha": "0aef1e84a59adc2da854f043843cea597463d370",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 33,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
        "patch": "@@ -209,6 +209,35 @@ static RPCHelpMan getdescriptorinfo()\n     };\n }\n \n+static UniValue DeriveAddresses(const Descriptor* desc, int64_t range_begin, int64_t range_end, FlatSigningProvider& key_provider)\n+{\n+    UniValue addresses(UniValue::VARR);\n+\n+    for (int i = range_begin; i <= range_end; ++i) {\n+        FlatSigningProvider provider;\n+        std::vector<CScript> scripts;\n+        if (!desc->Expand(i, key_provider, scripts, provider)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys\"));\n+        }\n+\n+        for (const CScript &script : scripts) {\n+            CTxDestination dest;\n+            if (!ExtractDestination(script, dest)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Descriptor does not have a corresponding address\"));\n+            }\n+\n+            addresses.push_back(EncodeDestination(dest));\n+        }\n+    }\n+\n+    // This should not be possible, but an assert seems overkill:\n+    if (addresses.empty()) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Unexpected empty result\");\n+    }\n+\n+    return addresses;\n+}\n+\n static RPCHelpMan deriveaddresses()\n {\n     const std::string EXAMPLE_DESCRIPTOR = \"wpkh([d34db33f/84h/0h/0h]xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/*)#cjjspncu\";\n@@ -222,17 +251,35 @@ static RPCHelpMan deriveaddresses()\n             \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n             \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n             \"or more path elements separated by \\\"/\\\", where \\\"h\\\" represents a hardened child key.\\n\"\n-            \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\"\n-            \"Note that only descriptors that specify a single derivation path can be derived.\\n\"},\n+            \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\"},\n             {\n                 {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The descriptor.\"},\n                 {\"range\", RPCArg::Type::RANGE, RPCArg::Optional::OMITTED_NAMED_ARG, \"If a ranged descriptor is used, this specifies the end or the range (in [begin,end] notation) to derive.\"},\n             },\n-            RPCResult{\n-                RPCResult::Type::ARR, \"\", \"\",\n-                {\n-                    {RPCResult::Type::STR, \"address\", \"the derived addresses\"},\n-                }\n+            {\n+                RPCResult{\"for single derivation descriptors\",\n+                    RPCResult::Type::ARR, \"\", \"\",\n+                    {\n+                        {RPCResult::Type::STR, \"address\", \"the derived addresses\"},\n+                    }\n+                },\n+                RPCResult{\"for multipath descriptors\",\n+                    RPCResult::Type::OBJ, \"\", \"\",\n+                    {\n+                        {\n+                            RPCResult::Type::ARR, \"receive\", \"the derived receiving addresses (derived using the first path specifier in the multipath index)\",\n+                            {\n+                                {RPCResult::Type::STR, \"address\", \"the derived address\"},\n+                            },\n+                        },\n+                        {\n+                            RPCResult::Type::ARR, \"change\", \"the derived change addresses (derived using the second path specifier in the multipath index)\",\n+                            {\n+                                {RPCResult::Type::STR, \"address\", \"the derived address\"},\n+                            },\n+                        },\n+                    },\n+                },\n             },\n             RPCExamples{\n                 \"First three native segwit receive addresses\\n\" +\n@@ -254,9 +301,6 @@ static RPCHelpMan deriveaddresses()\n     FlatSigningProvider key_provider;\n     std::string error;\n     auto descs = Parse(desc_str, key_provider, error, /* require_checksum = */ true);\n-    if (descs.second) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor specifying both receiving and change derivation paths are not allowed\");\n-    }\n     auto& desc = descs.first;\n     if (!desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n@@ -270,31 +314,16 @@ static RPCHelpMan deriveaddresses()\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range must be specified for a ranged descriptor\");\n     }\n \n-    UniValue addresses(UniValue::VARR);\n+    UniValue addresses = DeriveAddresses(desc.get(), range_begin, range_end, key_provider);\n \n-    for (int i = range_begin; i <= range_end; ++i) {\n-        FlatSigningProvider provider;\n-        std::vector<CScript> scripts;\n-        if (!desc->Expand(i, key_provider, scripts, provider)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys\"));\n-        }\n-\n-        for (const CScript &script : scripts) {\n-            CTxDestination dest;\n-            if (!ExtractDestination(script, dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Descriptor does not have a corresponding address\"));\n-            }\n-\n-            addresses.push_back(EncodeDestination(dest));\n-        }\n-    }\n-\n-    // This should not be possible, but an assert seems overkill:\n-    if (addresses.empty()) {\n-        throw JSONRPCError(RPC_MISC_ERROR, \"Unexpected empty result\");\n+    if (descs.second) {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"receive\", addresses);\n+        obj.pushKV(\"change\", DeriveAddresses(descs.second.get(), range_begin, range_end, key_provider));\n+        return obj;\n+    } else {\n+        return addresses;\n     }\n-\n-    return addresses;\n },\n     };\n }"
      }
    ]
  },
  {
    "sha": "70b570d958f56f936ec801d7bc1b12c80ec88929",
    "node_id": "C_kwDOABII59oAKDcwYjU3MGQ5NThmNTZmOTM2ZWM4MDFkN2JjMWIxMmM4MGVjODg5Mjk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-30T19:29:54Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "tests: Multipath descriptors for scantxoutset and deriveaddresses",
      "tree": {
        "sha": "d99e8729d7f61c49ad15af8f277f1899c5e44e99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d99e8729d7f61c49ad15af8f277f1899c5e44e99"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/70b570d958f56f936ec801d7bc1b12c80ec88929",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70b570d958f56f936ec801d7bc1b12c80ec88929",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/70b570d958f56f936ec801d7bc1b12c80ec88929",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70b570d958f56f936ec801d7bc1b12c80ec88929/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eaa4c9ebd50923c7c3c24e9d2f5f99e8205a2e4f"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6cf2e2be26902ba39721da42e247ca8478f4e092",
        "filename": "test/functional/rpc_deriveaddresses.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70b570d958f56f936ec801d7bc1b12c80ec88929/test/functional/rpc_deriveaddresses.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70b570d958f56f936ec801d7bc1b12c80ec88929/test/functional/rpc_deriveaddresses.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deriveaddresses.py?ref=70b570d958f56f936ec801d7bc1b12c80ec88929",
        "patch": "@@ -29,6 +29,9 @@ def run_test(self):\n         assert_equal(self.nodes[0].deriveaddresses(ranged_descriptor, [1, 2]), [\"bcrt1qhku5rq7jz8ulufe2y6fkcpnlvpsta7rq4442dy\", \"bcrt1qpgptk2gvshyl0s9lqshsmx932l9ccsv265tvaq\"])\n         assert_equal(self.nodes[0].deriveaddresses(ranged_descriptor, 2), [address, \"bcrt1qhku5rq7jz8ulufe2y6fkcpnlvpsta7rq4442dy\", \"bcrt1qpgptk2gvshyl0s9lqshsmx932l9ccsv265tvaq\"])\n \n+        ranged_descriptor = descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/<0;1>/*)\")\n+        assert_equal(self.nodes[0].deriveaddresses(ranged_descriptor, [1, 2]), {\"receive\": [\"bcrt1q7c8mdmdktrzs8xgpjmqw90tjn65j5a3yj04m3n\", \"bcrt1qs6n37uzu0v0qfzf0r0csm0dwa7prc0v5uavgy0\"], \"change\":[\"bcrt1qhku5rq7jz8ulufe2y6fkcpnlvpsta7rq4442dy\", \"bcrt1qpgptk2gvshyl0s9lqshsmx932l9ccsv265tvaq\"]})\n+\n         assert_raises_rpc_error(-8, \"Range should not be specified for an un-ranged descriptor\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"), [0, 2])\n \n         assert_raises_rpc_error(-8, \"Range must be specified for a ranged descriptor\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"))"
      },
      {
        "sha": "ddceb9537852e84d9f96bcdc3f17701b346fe0d5",
        "filename": "test/functional/rpc_scantxoutset.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70b570d958f56f936ec801d7bc1b12c80ec88929/test/functional/rpc_scantxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70b570d958f56f936ec801d7bc1b12c80ec88929/test/functional/rpc_scantxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_scantxoutset.py?ref=70b570d958f56f936ec801d7bc1b12c80ec88929",
        "patch": "@@ -111,6 +111,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": 1499}])['total_amount'], Decimal(\"12.288\"))\n         assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": 1500}])['total_amount'], Decimal(\"28.672\"))\n         assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": [1500,1500]}])['total_amount'], Decimal(\"16.384\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"pkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/<0;1>)\"}])[\"total_amount\"], Decimal(\"12.288\"))\n \n         # Test the reported descriptors for a few matches\n         assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/*)\", \"range\": 1499}])), [\"pkh([0c5f9a1e/0'/0'/0]026dbd8b2315f296d36e6b6920b1579ca75569464875c7ebe869b536a7d9503c8c)#dzxw429x\", \"pkh([0c5f9a1e/0'/0'/1]033e6f25d76c00bedb3a8993c7d5739ee806397f0529b1b31dda31ef890f19a60c)#43rvceed\"])"
      }
    ]
  },
  {
    "sha": "77c9a456947beff40364a8f371b7c7d8cfc558d9",
    "node_id": "C_kwDOABII59oAKDc3YzlhNDU2OTQ3YmVmZjQwMzY0YThmMzcxYjdjN2Q4Y2ZjNTU4ZDk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-23T21:02:05Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "wallet: Move internal to be per key when importing\n\nInstead of applying internal-ness to all keys being imported at the same\ntime, apply it on a per key basis. So each key that is imported will\ncarry with it whether it is for the change keypool.",
      "tree": {
        "sha": "e1c9495c68cc49b58c84f54f166131886bc5f3ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e1c9495c68cc49b58c84f54f166131886bc5f3ff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77c9a456947beff40364a8f371b7c7d8cfc558d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77c9a456947beff40364a8f371b7c7d8cfc558d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77c9a456947beff40364a8f371b7c7d8cfc558d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77c9a456947beff40364a8f371b7c7d8cfc558d9/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70b570d958f56f936ec801d7bc1b12c80ec88929",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70b570d958f56f936ec801d7bc1b12c80ec88929",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70b570d958f56f936ec801d7bc1b12c80ec88929"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 15,
      "deletions": 13
    },
    "files": [
      {
        "sha": "471366bdde9fc76c7735938abf46aa517035ef71",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "patch": "@@ -489,7 +489,7 @@ RPCHelpMan importpubkey()\n \n         pwallet->ImportScriptPubKeys(strLabel, script_pub_keys, true /* have_solving_data */, true /* apply_label */, 1 /* timestamp */);\n \n-        pwallet->ImportPubKeys({pubKey.GetID()}, {{pubKey.GetID(), pubKey}} , {} /* key_origins */, false /* add_keypool */, false /* internal */, 1 /* timestamp */);\n+        pwallet->ImportPubKeys({{pubKey.GetID(), false}}, {{pubKey.GetID(), pubKey}} , {} /* key_origins */, false /* add_keypool */, 1 /* timestamp */);\n     }\n     if (fRescan)\n     {\n@@ -940,7 +940,7 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     CHECK_NONFATAL(false);\n }\n \n-static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys)\n {\n     UniValue warnings(UniValue::VARR);\n \n@@ -1014,7 +1014,7 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n         }\n         pubkey_map.emplace(pubkey.GetID(), pubkey);\n-        ordered_pubkeys.push_back(pubkey.GetID());\n+        ordered_pubkeys.push_back({pubkey.GetID(), internal});\n     }\n     for (size_t i = 0; i < keys.size(); ++i) {\n         const auto& str = keys[i].get_str();\n@@ -1087,8 +1087,10 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n-static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys)\n {\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+\n     UniValue warnings(UniValue::VARR);\n \n     const std::string& descriptor = data[\"desc\"].get_str();\n@@ -1124,7 +1126,7 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n         std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n         for (const auto& key_pair : out_keys.pubkeys) {\n-            ordered_pubkeys.push_back(key_pair.first);\n+            ordered_pubkeys.push_back({key_pair.first, internal});\n         }\n \n         for (const auto& x : out_keys.scripts) {\n@@ -1199,7 +1201,7 @@ static UniValue ProcessImport(CWallet& wallet, const UniValue& data, const int64\n         std::map<CKeyID, CPubKey> pubkey_map;\n         std::map<CKeyID, CKey> privkey_map;\n         std::set<CScript> script_pub_keys;\n-        std::vector<CKeyID> ordered_pubkeys;\n+        std::vector<std::pair<CKeyID, bool>> ordered_pubkeys;\n         bool have_solving_data;\n \n         if (data.exists(\"scriptPubKey\") && data.exists(\"desc\")) {\n@@ -1232,7 +1234,7 @@ static UniValue ProcessImport(CWallet& wallet, const UniValue& data, const int64\n         if (!wallet.ImportPrivKeys(privkey_map, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n         }\n-        if (!wallet.ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {\n+        if (!wallet.ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n         }\n         if (!wallet.ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {"
      },
      {
        "sha": "b6860316bdd69ca087d674650725dfc4902f5fce",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "patch": "@@ -1555,13 +1555,13 @@ bool LegacyScriptPubKeyMan::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey\n     return true;\n }\n \n-bool LegacyScriptPubKeyMan::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n+bool LegacyScriptPubKeyMan::ImportPubKeys(const std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const int64_t timestamp)\n {\n     WalletBatch batch(m_storage.GetDatabase());\n     for (const auto& entry : key_origins) {\n         AddKeyOriginWithDB(batch, entry.second.first, entry.second.second);\n     }\n-    for (const CKeyID& id : ordered_pubkeys) {\n+    for (const auto& [id, internal] : ordered_pubkeys) {\n         auto entry = pubkey_map.find(id);\n         if (entry == pubkey_map.end()) {\n             continue;"
      },
      {
        "sha": "be4a2525e7c5f87daababf6f7e091aaf2d9839ac",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "patch": "@@ -448,7 +448,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n \n     bool ImportScripts(const std::set<CScript> scripts, int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n     bool ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n-    bool ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n+    bool ImportPubKeys(const std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n     bool ImportScriptPubKeys(const std::set<CScript>& script_pub_keys, const bool have_solving_data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n \n     /* Returns true if the wallet can generate new keys */"
      },
      {
        "sha": "9b0801073f96b2f4bff5f2b10a8609f24935af6e",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "patch": "@@ -1505,14 +1505,14 @@ bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const in\n     return spk_man->ImportPrivKeys(privkey_map, timestamp);\n }\n \n-bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n+bool CWallet::ImportPubKeys(const std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const int64_t timestamp)\n {\n     auto spk_man = GetLegacyScriptPubKeyMan();\n     if (!spk_man) {\n         return false;\n     }\n     LOCK(spk_man->cs_KeyStore);\n-    return spk_man->ImportPubKeys(ordered_pubkeys, pubkey_map, key_origins, add_keypool, internal, timestamp);\n+    return spk_man->ImportPubKeys(ordered_pubkeys, pubkey_map, key_origins, add_keypool, timestamp);\n }\n \n bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)"
      },
      {
        "sha": "643cbaa3140b8692709f537f84a301dd236f0b6a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c9a456947beff40364a8f371b7c7d8cfc558d9/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "patch": "@@ -586,7 +586,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     bool ImportScripts(const std::set<CScript> scripts, int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool ImportPubKeys(const std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     CFeeRate m_pay_tx_fee{DEFAULT_PAY_TX_FEE};"
      }
    ]
  },
  {
    "sha": "7d913bcf199875863594030f5327d4797c2d9541",
    "node_id": "C_kwDOABII59oAKDdkOTEzYmNmMTk5ODc1ODYzNTk0MDMwZjUzMjdkNDc5N2MyZDk1NDE",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-23T21:23:25Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "rpc: Allow importmulti to import multipath descriptors correctly\n\nMultipath descriptors will be imported as two separate descriptors with\nthe first one for receiving addreses, and the second for change\naddresses. When importing a multipath descriptor, 'internal' cannot be\nspecified because of the implicit receive and change descriptors.",
      "tree": {
        "sha": "3f508fe9d46edcacff63bfdcd0ae877abc4beec5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3f508fe9d46edcacff63bfdcd0ae877abc4beec5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d913bcf199875863594030f5327d4797c2d9541",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d913bcf199875863594030f5327d4797c2d9541",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d913bcf199875863594030f5327d4797c2d9541",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d913bcf199875863594030f5327d4797c2d9541/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77c9a456947beff40364a8f371b7c7d8cfc558d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77c9a456947beff40364a8f371b7c7d8cfc558d9"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 34,
      "deletions": 24
    },
    "files": [
      {
        "sha": "ee809717a83e758d8b3bd0e954d2bdf9ac1a4eb1",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 24,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d913bcf199875863594030f5327d4797c2d9541/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d913bcf199875863594030f5327d4797c2d9541/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=7d913bcf199875863594030f5327d4797c2d9541",
        "patch": "@@ -1089,28 +1089,35 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n \n static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<std::pair<CKeyID, bool>>& ordered_pubkeys)\n {\n-    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-\n     UniValue warnings(UniValue::VARR);\n \n     const std::string& descriptor = data[\"desc\"].get_str();\n     FlatSigningProvider keys;\n     std::string error;\n-    auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true).first;\n-    if (!parsed_desc) {\n+    auto parsed_descs = Parse(descriptor, keys, error, /* require_checksum = */ true);\n+    if (!parsed_descs.first) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n-    if (parsed_desc->GetOutputType() == OutputType::BECH32M) {\n+    if (parsed_descs.first->GetOutputType() == OutputType::BECH32M) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Bech32m descriptors cannot be imported into legacy wallets\");\n     }\n \n-    have_solving_data = parsed_desc->IsSolvable();\n+    std::optional<bool> internal;\n+    bool multipath = parsed_descs.second != nullptr;\n+    if (data.exists(\"internal\")) {\n+        if (multipath) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Cannot have multipath descriptor while also specifying \\'internal\\'\");\n+        }\n+        internal = data[\"internal\"].get_bool();\n+    }\n+\n+    have_solving_data = parsed_descs.first->IsSolvable();\n     const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n     int64_t range_start = 0, range_end = 0;\n-    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+    if (!parsed_descs.first->IsRange() && data.exists(\"range\")) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n-    } else if (parsed_desc->IsRange()) {\n+    } else if (parsed_descs.first->IsRange()) {\n         if (!data.exists(\"range\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n@@ -1119,25 +1126,28 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n \n     const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n \n-    // Expand all descriptors to get public keys and scripts, and private keys if available.\n-    for (int i = range_start; i <= range_end; ++i) {\n-        FlatSigningProvider out_keys;\n-        std::vector<CScript> scripts_temp;\n-        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n-        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n-        for (const auto& key_pair : out_keys.pubkeys) {\n-            ordered_pubkeys.push_back({key_pair.first, internal});\n-        }\n+    for (int j = 0; j < (multipath ? 2 : 1); ++j) {\n+        const auto& parsed_desc = j ? parsed_descs.second : parsed_descs.first;\n+        // Expand all descriptors to get public keys and scripts, and private keys if available.\n+        for (int i = range_start; i <= range_end; ++i) {\n+            FlatSigningProvider out_keys;\n+            std::vector<CScript> scripts_temp;\n+            parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+            std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+            for (const auto& key_pair : out_keys.pubkeys) {\n+                ordered_pubkeys.push_back({key_pair.first, (internal.has_value() ? internal.value() : j)});\n+            }\n \n-        for (const auto& x : out_keys.scripts) {\n-            import_data.import_scripts.emplace(x.second);\n-        }\n+            for (const auto& x : out_keys.scripts) {\n+                import_data.import_scripts.emplace(x.second);\n+            }\n \n-        parsed_desc->ExpandPrivate(i, keys, out_keys);\n+            parsed_desc->ExpandPrivate(i, keys, out_keys);\n \n-        std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n-        std::copy(out_keys.keys.begin(), out_keys.keys.end(), std::inserter(privkey_map, privkey_map.end()));\n-        import_data.key_origins.insert(out_keys.origins.begin(), out_keys.origins.end());\n+            std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+            std::copy(out_keys.keys.begin(), out_keys.keys.end(), std::inserter(privkey_map, privkey_map.end()));\n+            import_data.key_origins.insert(out_keys.origins.begin(), out_keys.origins.end());\n+        }\n     }\n \n     for (size_t i = 0; i < priv_keys.size(); ++i) {"
      }
    ]
  },
  {
    "sha": "01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
    "node_id": "C_kwDOABII59oAKDAxYzkyOGIwMGQxZjJhNDdhYTRiOGUyYTg0ZGEzNjBiNmJhMGY1NzY",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-23T21:33:14Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "wallet, rpc: Allow importdescriptors to import multipath descriptors\n\nMultipath descriptors will be imported as two separate descriptors with\nthe first for receiving addresses and the second for change. This\nmirrors importmulti.",
      "tree": {
        "sha": "8729015cbd82685a597dfaf877c1ddc4a6de8d37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8729015cbd82685a597dfaf877c1ddc4a6de8d37"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d913bcf199875863594030f5327d4797c2d9541",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d913bcf199875863594030f5327d4797c2d9541",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d913bcf199875863594030f5327d4797c2d9541"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 80,
      "deletions": 64
    },
    "files": [
      {
        "sha": "3a1c814ac4dfd16e7ff55f7b453266d69889a2e7",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 64,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
        "patch": "@@ -1477,22 +1477,30 @@ static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, c\n \n         const std::string& descriptor = data[\"desc\"].get_str();\n         const bool active = data.exists(\"active\") ? data[\"active\"].get_bool() : false;\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n         // Parse descriptor string\n         FlatSigningProvider keys;\n         std::string error;\n-        auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true).first;\n-        if (!parsed_desc) {\n+        auto parsed_descs = Parse(descriptor, keys, error, /* require_checksum = */ true);\n+        if (!parsed_descs.first) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n         }\n \n+        std::optional<bool> internal;\n+        bool multipath = parsed_descs.second != nullptr;\n+        if (data.exists(\"internal\")) {\n+            if (multipath) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Cannot have multipath descriptor while also specifying \\'internal\\'\");\n+            }\n+            internal = data[\"internal\"].get_bool();\n+        }\n+\n         // Range check\n         int64_t range_start = 0, range_end = 1, next_index = 0;\n-        if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        if (!parsed_descs.first->IsRange() && data.exists(\"range\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n-        } else if (parsed_desc->IsRange()) {\n+        } else if (parsed_descs.first->IsRange()) {\n             if (data.exists(\"range\")) {\n                 auto range = ParseDescriptorRange(data[\"range\"]);\n                 range_start = range.first;\n@@ -1514,10 +1522,15 @@ static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, c\n         }\n \n         // Active descriptors must be ranged\n-        if (active && !parsed_desc->IsRange()) {\n+        if (active && !parsed_descs.first->IsRange()) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Active descriptors must be ranged\");\n         }\n \n+        // Multipath descriptors should not have a label\n+        if (multipath && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Multipath descriptors should not have a label\");\n+        }\n+\n         // Ranged descriptors should not have a label\n         if (data.exists(\"range\") && data.exists(\"label\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Ranged descriptors should not have a label\");\n@@ -1529,7 +1542,7 @@ static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, c\n         }\n \n         // Combo descriptor check\n-        if (active && !parsed_desc->IsSingleType()) {\n+        if (active && !parsed_descs.first->IsSingleType()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Combo descriptors cannot be set to active\");\n         }\n \n@@ -1538,73 +1551,76 @@ static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, c\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n         }\n \n-        // Need to ExpandPrivate to check if private keys are available for all pubkeys\n-        FlatSigningProvider expand_keys;\n-        std::vector<CScript> scripts;\n-        if (!parsed_desc->Expand(0, keys, scripts, expand_keys)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot expand descriptor. Probably because of hardened derivations without private keys provided\");\n-        }\n-        parsed_desc->ExpandPrivate(0, keys, expand_keys);\n-\n-        // Check if all private keys are provided\n-        bool have_all_privkeys = !expand_keys.keys.empty();\n-        for (const auto& entry : expand_keys.origins) {\n-            const CKeyID& key_id = entry.first;\n-            CKey key;\n-            if (!expand_keys.GetKey(key_id, key)) {\n-                have_all_privkeys = false;\n-                break;\n+        for (int j = 0; j < (multipath ? 2 : 1); ++j) {\n+            auto parsed_desc = j ? std::move(parsed_descs.second) : std::move(parsed_descs.first);\n+            // Need to ExpandPrivate to check if private keys are available for all pubkeys\n+            FlatSigningProvider expand_keys;\n+            std::vector<CScript> scripts;\n+            if (!parsed_desc->Expand(0, keys, scripts, expand_keys)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot expand descriptor. Probably because of hardened derivations without private keys provided\");\n+            }\n+            parsed_desc->ExpandPrivate(0, keys, expand_keys);\n+\n+            // Check if all private keys are provided\n+            bool have_all_privkeys = !expand_keys.keys.empty();\n+            for (const auto& entry : expand_keys.origins) {\n+                const CKeyID& key_id = entry.first;\n+                CKey key;\n+                if (!expand_keys.GetKey(key_id, key)) {\n+                    have_all_privkeys = false;\n+                    break;\n+                }\n             }\n-        }\n \n-        // Taproot descriptors cannot be imported if Taproot is not yet active.\n-        // Check if this is a Taproot descriptor\n-        CTxDestination dest;\n-        ExtractDestination(scripts[0], dest);\n-        if (std::holds_alternative<WitnessV1Taproot>(dest)) {\n-            // Check if Taproot is active\n-            if (!wallet.chain().isTaprootActive()) {\n-                // Taproot is not active, raise an error\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import tr() descriptor when Taproot is not active\");\n+            // Taproot descriptors cannot be imported if Taproot is not yet active.\n+            // Check if this is a Taproot descriptor\n+            CTxDestination dest;\n+            ExtractDestination(scripts[0], dest);\n+            if (std::holds_alternative<WitnessV1Taproot>(dest)) {\n+                // Check if Taproot is active\n+                if (!wallet.chain().isTaprootActive()) {\n+                    // Taproot is not active, raise an error\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import tr() descriptor when Taproot is not active\");\n+                }\n             }\n-        }\n \n-        // If private keys are enabled, check some things.\n-        if (!wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n-           if (keys.keys.empty()) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import descriptor without private keys to a wallet with private keys enabled\");\n-           }\n-           if (!have_all_privkeys) {\n-               warnings.push_back(\"Not all private keys provided. Some wallet functionality may return unexpected errors\");\n-           }\n-        }\n+            // If private keys are enabled, check some things.\n+            if (!wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+               if (keys.keys.empty()) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import descriptor without private keys to a wallet with private keys enabled\");\n+               }\n+               if (!have_all_privkeys) {\n+                   warnings.push_back(\"Not all private keys provided. Some wallet functionality may return unexpected errors\");\n+               }\n+            }\n \n-        WalletDescriptor w_desc(std::move(parsed_desc), timestamp, range_start, range_end, next_index);\n+            WalletDescriptor w_desc(std::move(parsed_desc), timestamp, range_start, range_end, next_index);\n \n-        // Check if the wallet already contains the descriptor\n-        auto existing_spk_manager = wallet.GetDescriptorScriptPubKeyMan(w_desc);\n-        if (existing_spk_manager) {\n-            if (!existing_spk_manager->CanUpdateToWalletDescriptor(w_desc, error)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, error);\n+            // Check if the wallet already contains the descriptor\n+            auto existing_spk_manager = wallet.GetDescriptorScriptPubKeyMan(w_desc);\n+            if (existing_spk_manager) {\n+                if (!existing_spk_manager->CanUpdateToWalletDescriptor(w_desc, error)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, error);\n+                }\n             }\n-        }\n \n-        // Add descriptor to the wallet\n-        auto spk_manager = wallet.AddWalletDescriptor(w_desc, keys, label, internal);\n-        if (spk_manager == nullptr) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Could not add descriptor '%s'\", descriptor));\n-        }\n+            // Add descriptor to the wallet\n+            auto spk_manager = wallet.AddWalletDescriptor(w_desc, keys, label, (internal.has_value() ? internal.value() : j));\n+            if (spk_manager == nullptr) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Could not add descriptor '%s'\", descriptor));\n+            }\n \n-        // Set descriptor as active if necessary\n-        if (active) {\n-            if (!w_desc.descriptor->GetOutputType()) {\n-                warnings.push_back(\"Unknown output type, cannot set descriptor to active.\");\n+            // Set descriptor as active if necessary\n+            if (active) {\n+                if (!w_desc.descriptor->GetOutputType()) {\n+                    warnings.push_back(\"Unknown output type, cannot set descriptor to active.\");\n+                } else {\n+                    wallet.AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), (internal.has_value() ? internal.value() : j));\n+                }\n             } else {\n-                wallet.AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n-            }\n-        } else {\n-            if (w_desc.descriptor->GetOutputType()) {\n-                wallet.DeactivateScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n+                if (w_desc.descriptor->GetOutputType()) {\n+                    wallet.DeactivateScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), (internal.has_value() ? internal.value() : j));\n+                }\n             }\n         }\n "
      }
    ]
  },
  {
    "sha": "0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
    "node_id": "C_kwDOABII59oAKDBkMGFhMWJmOWQ3Y2E3OTk1ODhiODI2YmU5ZTY2YjQwZWZiYzAwMGU",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-30T19:01:04Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "tests: Test importing of multipath descriptors\n\nTest that both importmulti and importdescriptors behave as expected when\nimporting a multipath descriptor.",
      "tree": {
        "sha": "0d852bb3b29ff7876a8d9407b9a395a609c4ccbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0d852bb3b29ff7876a8d9407b9a395a609c4ccbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d0aa1bf9d7ca799588b826be9e66b40efbc000e/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/01c928b00d1f2a47aa4b8e2a84da360b6ba0f576"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 90,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f0c1fb3a555e2d0bf41c36ad0d04fe2400dd986e",
        "filename": "test/functional/wallet_importdescriptors.py",
        "status": "modified",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d0aa1bf9d7ca799588b826be9e66b40efbc000e/test/functional/wallet_importdescriptors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d0aa1bf9d7ca799588b826be9e66b40efbc000e/test/functional/wallet_importdescriptors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importdescriptors.py?ref=0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
        "patch": "@@ -15,6 +15,8 @@\n - `test_address()` is called to call getaddressinfo for an address on node1\n   and test the values returned.\"\"\"\n \n+import time\n+\n from test_framework.address import key_to_p2pkh\n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n@@ -667,5 +669,56 @@ def run_test(self):\n                               success=True,\n                               warnings=[\"Unknown output type, cannot set descriptor to active.\"])\n \n+        self.log.info(\"Multipath descriptors\")\n+        self.nodes[1].createwallet(wallet_name=\"multipath\", descriptors=True, blank=True)\n+        w_multipath = self.nodes[1].get_wallet_rpc(\"multipath\")\n+        self.nodes[1].createwallet(wallet_name=\"multipath_split\", descriptors=True, blank=True)\n+        w_multisplit = self.nodes[1].get_wallet_rpc(\"multipath_split\")\n+        timestamp = int(time.time())\n+\n+        self.test_importdesc({\"desc\": descsum_create(f\"wpkh({xpriv}/<10;20>/0/*)\"),\n+                              \"active\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": \"now\",\n+                              \"label\": \"some label\"},\n+                              success=False,\n+                              error_code=-8,\n+                              error_message=\"Multipath descriptors should not have a label\",\n+                              wallet=w_multipath)\n+        self.test_importdesc({\"desc\": descsum_create(f\"wpkh({xpriv}/<10;20>/0/*)\"),\n+                              \"active\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": timestamp,\n+                              \"internal\": True},\n+                              success=False,\n+                              error_code=-5,\n+                              error_message=\"Cannot have multipath descriptor while also specifying \\'internal\\'\",\n+                              wallet=w_multipath)\n+\n+        self.test_importdesc({\"desc\": descsum_create(f\"wpkh({xpriv}/<10;20>/0/*)\"),\n+                              \"active\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": timestamp},\n+                              success=True,\n+                              wallet=w_multipath)\n+\n+        self.test_importdesc({\"desc\": descsum_create(f\"wpkh({xpriv}/10/0/*)\"),\n+                              \"active\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": timestamp},\n+                              success=True,\n+                              wallet=w_multisplit)\n+        self.test_importdesc({\"desc\": descsum_create(f\"wpkh({xpriv}/20/0/*)\"),\n+                              \"active\": True,\n+                              \"range\": 10,\n+                              \"internal\": True,\n+                              \"timestamp\": timestamp},\n+                              success=True,\n+                              wallet=w_multisplit)\n+        for _ in range(0, 10):\n+            assert_equal(w_multipath.getnewaddress(address_type=\"bech32\"), w_multisplit.getnewaddress(address_type=\"bech32\"))\n+            assert_equal(w_multipath.getrawchangeaddress(address_type=\"bech32\"), w_multisplit.getrawchangeaddress(address_type=\"bech32\"))\n+        assert_equal(sorted(w_multipath.listdescriptors()[\"descriptors\"], key=lambda x: x[\"desc\"]), sorted(w_multisplit.listdescriptors()[\"descriptors\"], key=lambda x: x[\"desc\"]))\n+\n if __name__ == '__main__':\n     ImportDescriptorsTest().main()"
      },
      {
        "sha": "2290116339ae80cd016a8163291a4ef971094dd1",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d0aa1bf9d7ca799588b826be9e66b40efbc000e/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d0aa1bf9d7ca799588b826be9e66b40efbc000e/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
        "patch": "@@ -879,6 +879,43 @@ def run_test(self):\n             addr = wrpc.getnewaddress('', 'bech32')\n             assert_equal(addr, addresses[i])\n \n+        self.log.info(\"Multipath descriptors\")\n+        self.nodes[1].createwallet(wallet_name=\"multipath\", blank=True, disable_private_keys=True)\n+        w_multipath = self.nodes[1].get_wallet_rpc(\"multipath\")\n+        self.nodes[1].createwallet(wallet_name=\"multipath_split\", blank=True, disable_private_keys=True)\n+        w_multisplit = self.nodes[1].get_wallet_rpc(\"multipath_split\")\n+\n+        res = w_multipath.importmulti([{\"desc\": descsum_create(f\"wpkh({xpub}/<10;20>/0/*)\"),\n+                              \"keypool\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": \"now\",\n+                              \"internal\": True}])\n+        assert_equal(res[0][\"success\"], False)\n+        assert_equal(res[0][\"error\"][\"code\"], -5)\n+        assert_equal(res[0][\"error\"][\"message\"], \"Cannot have multipath descriptor while also specifying 'internal'\")\n+\n+        res = w_multipath.importmulti([{\"desc\": descsum_create(f\"wpkh({xpub}/<10;20>/0/*)\"),\n+                              \"keypool\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": \"now\"}])\n+        assert_equal(res[0][\"success\"], True)\n+\n+        res = w_multisplit.importmulti([{\"desc\": descsum_create(f\"wpkh({xpub}/10/0/*)\"),\n+                              \"keypool\": True,\n+                              \"range\": 10,\n+                              \"timestamp\": \"now\"}])\n+        assert_equal(res[0][\"success\"], True)\n+        res = w_multisplit.importmulti([{\"desc\": descsum_create(f\"wpkh({xpub}/20/0/*)\"),\n+                              \"keypool\": True,\n+                              \"range\": 10,\n+                              \"internal\": True,\n+                              \"timestamp\": timestamp}])\n+        assert_equal(res[0][\"success\"], True)\n+\n+        for _ in range(0, 9):\n+            assert_equal(w_multipath.getnewaddress(address_type=\"bech32\"), w_multisplit.getnewaddress(address_type=\"bech32\"))\n+            assert_equal(w_multipath.getrawchangeaddress(address_type=\"bech32\"), w_multisplit.getrawchangeaddress(address_type=\"bech32\"))\n+\n \n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  },
  {
    "sha": "a6ff1c7246df81b627a7418ed498242ebfe56217",
    "node_id": "C_kwDOABII59oAKGE2ZmYxYzcyNDZkZjgxYjYyN2E3NDE4ZWQ0OTgyNDJlYmZlNTYyMTc",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-08-30T19:34:41Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-24T22:23:27Z"
      },
      "message": "doc: Mention multipath specifier",
      "tree": {
        "sha": "b8684ff5f74238b2a5d65a3e2e0b05b099037de3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b8684ff5f74238b2a5d65a3e2e0b05b099037de3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6ff1c7246df81b627a7418ed498242ebfe56217",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6ff1c7246df81b627a7418ed498242ebfe56217",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a6ff1c7246df81b627a7418ed498242ebfe56217",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6ff1c7246df81b627a7418ed498242ebfe56217/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d0aa1bf9d7ca799588b826be9e66b40efbc000e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d0aa1bf9d7ca799588b826be9e66b40efbc000e"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8755a33c46a6a6b315e6fd759815f86532ed1f05",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6ff1c7246df81b627a7418ed498242ebfe56217/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6ff1c7246df81b627a7418ed498242ebfe56217/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=a6ff1c7246df81b627a7418ed498242ebfe56217",
        "patch": "@@ -87,6 +87,7 @@ Descriptors consist of several types of expressions. The top level expression is\n   - [WIF](https://en.bitcoin.it/wiki/Wallet_import_format) encoded private keys may be specified instead of the corresponding public key, with the same meaning.\n   - `xpub` encoded extended public key or `xprv` encoded extended private key (as defined in [BIP 32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)).\n     - Followed by zero or more `/NUM` unhardened and `/NUM'` hardened BIP32 derivation steps.\n+      - No more than one of these derivation steps may be of the form `<NUM;NUM>` (including hardened indicators with either or both `NUM`). If such specifiers are included, the descriptor will be parsed as two descriptors where the first descriptor uses all of the first `NUM` in the pair, and the second descriptor uses the second `NUM` in the pair for all `KEY` expressions.\n     - Optionally followed by a single `/*` or `/*'` final step to denote all (direct) unhardened or hardened children.\n     - The usage of hardened derivation steps requires providing the private key.\n \n@@ -235,6 +236,28 @@ supported, a private key in WIF format or xprv may be provided instead.\n This is useful when private keys are necessary for hardened derivation\n steps, or for dumping wallet descriptors including private key material.\n \n+### Specifying receiving and change descriptors in one descriptor\n+\n+Since receiving and change addresses are frequently derived from the same\n+extended key(s) but with a single derivation index changed, it is convenient\n+to be able to specify a descriptor that can derive at the two different\n+indexes. Thus a single pair of indexes is allowed in each derivation path\n+following the extended key. When this descriptor is parsed, two descriptors\n+will be produced, the first one will use the first index in the pair for all\n+key expressions, and the second will use the second index.\n+\n+For example, a descriptor of the form:\n+\n+    multi(2,xpub.../<0;1>/0/*,xpub.../<2;3>/*)\n+\n+will expand to the two descriptors\n+\n+   multi(2,xpub.../0/0/*,xpub.../2/*)\n+   multi(2,xpub.../1/0/*,xpub.../3/*)\n+\n+Then wallet implementations can use the first descriptor for receiving addresses\n+and the second descriptor for change addresses.\n+\n ### Compatibility with old wallets\n \n In order to easily represent the sets of scripts currently supported by"
      }
    ]
  }
]