DrahtBot,2020-01-14 22:27:29,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17786](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17786.html) (refactor: Nuke policy/fees->mempool circula",https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-574403928,574403928,
sdaftuar,2020-01-16 15:32:36,"I don't know what's up with the appveyor build but I think this code is correct, it passes all tests for me locally.  \n\nAs a sanity check, I verified that this code does give a speedup in a simple scenario where it would be expected to improve things: create a transaction with 2000 outputs that is confirmed in a block; then spend each of those outputs in a separate transaction in the mempool; ",https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-575206318,575206318,
hebasto,2020-01-28 19:29:13,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-579414760,579414760,
hebasto,2020-01-29 08:14:02,"@JeremyRubin \n> @sdaftuar and I spent like at least an hour trying to come up with a better semantic name than the predecessor to visited, and decided that visited was sufficiently semantic.\n\nGood to know it. Let @ajtowns and me join your discussion ;)\n\n> I don't care about the names that much though, other than it causes negligible more rebase work for me -- @ajtowns will refactor some ",https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-579643248,579643248,
JeremyRubin,2020-01-29 09:06:20,"Apologies, that was an offline discussion!\n\nfirst_seen or FirstSeen is no good for this use case. If you negate visited then you impose that callers of visited has to check the negation of the call or to nest the code a level deeper inside an if, which adds more cognitive overhead IMO. Most of the code that I've written uses an `if (visited(it)) continue;` guard to check the next element, this",https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-579660932,579660932,
adamjonas,2020-01-29 20:33:18,"Just to summarize for those looking to review - as of bd5a026 there are 3 ACKs (@sdaftuar, @ariard, and @hebasto) and one ""looks good"" from @ajtowns with no NACKs or any show-stopping concerns raised.\n\n- In review, there have been some style nits and naming convention disagreements along with a suggested follow on [PR](https://github.com/bitcoin/bitcoin/pull/18017) from @ajtowns which uses cla",https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-579946380,579946380,
ajtowns,2020-01-30 02:12:15,ACK bd5a02692853f7240a4fdc593d7d0123d7916e45 (code review),https://github.com/bitcoin/bitcoin/pull/17925#issuecomment-580052200,580052200,
sdaftuar,2020-01-14 21:40:24,I don't see initializations for these variables anywhere?,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r366586660,366586660,src/txmempool.h
sdaftuar,2020-01-14 21:52:02,"A bit confusing to have this comment (about a function) right before a class definition, I'm guessing it is leftover from something else (or should be moved a few lines down). \n\nActually I think it'd make sense to explain here a little bit about what these epochs are and why/how to use them?  (Also, as this would be the first introduction of epochs in the code, it'd be helpful for reviewers of",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r366591661,366591661,src/txmempool.h
JeremyRubin,2020-01-15 03:31:01,great comment; rewrote it slightly to a format I think is more clear & also to emphasize that replacement with epochs is ongoing work :),https://github.com/bitcoin/bitcoin/pull/17925#discussion_r366682083,366682083,src/txmempool.h
ajtowns,2020-01-23 03:06:51,"I think this would be cleaner with the 'epoch' concept split out. I'm thinking:\n\n```c++\nclass Epoch {\npublic:\n    uint64_t m_epoch;\n    bool m_guarded;\n\n    Epoch() : m_epoch{0}, m_guarded{false} {}\n    Epoch(const Epoch&) = delete; // no copy constructor\n    Epoch& operator=(const Epoch&) = delete; // not assignable\n\n    class SCOPED_LOCKABLE Guard {\n        Epoch& m_epo",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r369914044,369914044,src/txmempool.h
ajtowns,2020-01-23 03:11:07,This function doesn't seem to be needed yet; suggest deferring it until it is.,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r369914759,369914759,src/txmempool.h
ajtowns,2020-01-23 03:15:24,"I think:\n\n```c++\nbool visited(txiter it) const {\n    assert(m_has_epoch_guard);\n    bool visited = it->m_epoch == m_epoch; // only visits this epoch count\n    if (!visited) it->m_epoch = m_epoch;\n    return visited;\n}\n```\n\nwould be clearer. (Also, this could be `const txiter it` since you're only changing what the iter points at)",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r369915441,369915441,src/txmempool.h
JeremyRubin,2020-01-24 00:05:37,"Hmm... I think that you're right that this code is somehow better, but TBH I don't really understand how the clang lock analyzing stuff works & don't know if I could personally maintain this code... Is there anything better to look at than http://releases.llvm.org/3.5.0/tools/clang/docs/ThreadSafetyAnalysis.html on how to understand this clang extension?\n\nAny objection to this being a follow o",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r370418775,370418775,src/txmempool.h
JeremyRubin,2020-01-24 00:09:38,"See above for note on future recursive locking -- given that this is a future concern, I agree it could be postponed, but I like that the current version of the code wouldn't have to change if modified.\n\nIn your version it's also not clear that if `it->m_epoch != m_epoch`, that `!(it->m_epoch > m_epoch)`, which violates the contract that `it->m_epoch` should be monotonic.\n\nIt's easier IMO ",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r370419851,370419851,src/txmempool.h
JeremyRubin,2020-01-24 00:19:04,"Correct; it's not needed yet. I'm indifferent on if it stays or goes. I figured it's better for it to live in the same commit as the introduction of it's non-optioned version, but unused functions aren't great to introduce.\n\nGiven that:\n1) It will be introduced in later work, relatively soon\n2) There's already an ack for this specific revision -- meaning both that this function has already",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r370422247,370422247,src/txmempool.h
ariard,2020-01-27 22:19:18,"2ccb7cc\n\nI think you considered it but why not m_entry_epoch, to avoid names collision for reviewers?",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371514906,371514906,src/txmempool.h
ariard,2020-01-27 22:40:23,"2ccb7cc\n\nWhat kind of stale scenario do you envision here ? \n\nIf taking twice the epoch is attempted, the assert will be hit and should be able to spot this kind of programming error. \n\nOtherwise, if you prevent `visited` returning true for past value, I think that's bettter than enforcing lock taking on epoch (because worst-case you reprocess an entry, which is better than taking a lo",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371523359,371523359,src/txmempool.cpp
ajtowns,2020-01-28 02:55:51,"If you're doing an ""already held"" thing, as far as clang goes that's just marking up the function with ""EXCLUSIVE_LOCKS_REQUIRED(epoch)"". I think something like:\n\n```c++\nclass SubEpoch { uint64_t subepoch; }\nclass TxMemPool {\n  ...\n  GetAllAncestorsEpochAlreadyHeld(elt, vector<txiter>& component, const SubEpoch& subepoch) EXCLUSIVE_LOCKS_REQUIRED(epoch);\n};\n```\n\nwould make thin",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371589102,371589102,src/txmempool.h
JeremyRubin,2020-01-28 18:37:47,"@ajtowns so I think you're missing the algorithm that I suggested slightly, you'd actually in this case traverse all of {A, B, C, D} in the first sub-epoch, because you would be traversing all parents and children recursively.\n\nSo if you had another transaction E, with only confirmed inputs, and F which spends E.0, then you would output:\n\n{{A, B, C, D}, {E, F}}\n\nHence being able to tra",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371984087,371984087,src/txmempool.h
JeremyRubin,2020-01-28 18:43:40,"It's not required for correctness, but I like that it enforces the invariant that if an epoch guard is not held that all mempool entries are ""younger"" than the mempool's m_epoch.\n\nBy ""prevents stale results being used"", I meant that if some nefarious caller wanted to manually check epochs outside of the context of an epoch guard, they wouldn't ""gain"" information about the previous traversal. O",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371986990,371986990,src/txmempool.cpp
JeremyRubin,2020-01-28 18:50:22,"fair point -- I felt that prefixing it with the class name was a bit gauche compared to just naming it the same thing. It's also an internal detail that isn't going to be referenced or inspected by any callers, so it isn't going to yield much name colliding code.\n\nI suggest that when @ajtowns refactors a lock analyzer friendly interface he can pick whatever variable names he thinks appropriate",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r371990443,371990443,src/txmempool.h
hebasto,2020-01-28 20:31:24,nit: might default member initializer be used instead?,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372039818,372039818,src/txmempool.cpp
hebasto,2020-01-28 20:32:21,nit: might default member initializers be used instead?,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372040196,372040196,src/txmempool.cpp
hebasto,2020-01-28 20:34:01,Is this comment still relevant?,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372040887,372040887,src/txmempool.cpp
hebasto,2020-01-28 20:43:56,typo: incomaptible --> incompatible,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372045194,372045194,src/txmempool.h
hebasto,2020-01-28 20:45:54,"nit: since epoch is monotonously increasing, might `GetNextEpoch()` be a more appropriate name?",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372046051,372046051,src/txmempool.h
hebasto,2020-01-28 20:50:07,"Agree with @ajtowns that replacing `std::max()` with conditional statement makes things clearer.\n",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372047993,372047993,src/txmempool.h
hebasto,2020-01-28 20:52:34,"nit: mind adding a comment about ""recursive locking"" you mention in https://github.com/bitcoin/bitcoin/pull/17925/files#r370419851?",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372049211,372049211,src/txmempool.h
hebasto,2020-01-28 20:58:15,"If `Optional<txiter> it` has no value, returned value `visited() == true` seems semantically a bit weird. Could function naming be improved?",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372051752,372051752,src/txmempool.h
JeremyRubin,2020-01-28 21:07:13,I think it's best to be style consistent with the other fields which are also set by the initializer list.,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372055970,372055970,src/txmempool.cpp
JeremyRubin,2020-01-28 21:07:27,I think it's best to be style consistent with the other fields which are also set by the initializer list.,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372056084,372056084,src/txmempool.cpp
JeremyRubin,2020-01-28 21:18:20,"Hmm. The comment is still relevant insofar as it explains what the EpochGuard is doing, but specifically the word ""cache"" is perhaps a bit vague.",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372062930,372062930,src/txmempool.cpp
JeremyRubin,2020-01-28 21:18:44,good catch,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372063109,372063109,src/txmempool.h
JeremyRubin,2020-01-28 21:24:20,"I think Fresh better encapsulates that it's an epoch that is unused by any element. Fresh, New, Unused are better to me than Next. All else equal, Fresh is already written.\n\nI don't care about the names that much though, other than it causes negligible more rebase work for me -- @ajtowns will refactor some of this in a follow up with a new interface, I think if we want to bikeshed names more w",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372065702,372065702,src/txmempool.h
JeremyRubin,2020-01-28 21:30:37,"It's not that weird of a decision once you look at the code that depends on it.\n\nEssentially, if I code something like:\n```c++\nfor (auto& it : mapTx) {\n    auto it2 = FindIterByPrevout(it->GetTransaction()->vin[0].prevout);\n    if (visited(it2)) continue;\n}\n```\n\nthis is kind of semantic, because if the FindByPrevout returns nullopt then we want to skip it because we've (in theo",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372068689,372068689,src/txmempool.h
JeremyRubin,2020-01-28 21:34:55,"if i were to update it, I would prefer:\n\n```c++\nif (!ret) it->m_epoch = m_epoch\n```\nto preserve the aforementioned invariant of monotonicity. This is equivalent to std::max, so I don't have any preference on the style, with a slight preference to what's already there and reviewed. ",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372070708,372070708,src/txmempool.h
JeremyRubin,2020-01-28 21:37:17,"Wouldn't mind, but don't want to confuse anyone with a currently unsupported use case.\n\n",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372071837,372071837,src/txmempool.h
ajtowns,2020-01-29 03:14:25,"`needs_processing(it2)` or similar could work, but `visited` seems pretty fine to me. (I would prefer it if it more clearly indicated that it's not idempotent/const; ie `bool a = visited(it); bool b = visited(it);` could result in `!a && b`, so maybe `first_visit()` or similar would be better? But still, it's already fine)",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372170803,372170803,src/txmempool.h
JeremyRubin,2020-01-29 03:59:09,"Things like needs_processing aren't great because there can be some sort of implication that it2 needs processing after it's been marked, and doesn't convey the action. What it is a bit better for is conveying the optionality aspect (something that's an nullopt doesn't need processing).\n\nThe reason we liked visited as a name is that there is a hint that it's not idempotent, that visited sugges",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372178583,372178583,src/txmempool.h
ajtowns,2020-01-29 04:41:56,"Depends how you traversed mapTx -- if you picked `elt=B` first, then ""C"" would not be a parent or child of ""B"" so you'd only do {A,B,D} in the first subepoch. You'd need to be ordered by feerate or something weird for this to happen, though. But yeah, I can't think of something where sub-epochs is actually useful either. But whatever, `>=` vs `==` doesn't make much difference.",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372186131,372186131,src/txmempool.h
ajtowns,2020-01-29 04:46:47,follow-on PR is #18017 ,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372186915,372186915,src/txmempool.h
JeremyRubin,2020-01-29 04:57:44,"Ah I think here's the miscommunication of what the algorithm ""GetComponents"" does. It's something like:\n\n```c++\nvector<vector<txiter>> components;\nfor (auto elt: mapTx) {\n   vector<txiter> to_process;\n   vector<txiter> processed;\n   if (visited(elt)) continue;\n   to_process.push_back(elt);\n   while (to_process.size()) {\n    auto todo = to_process.back();\n    to_process.pop_ba",https://github.com/bitcoin/bitcoin/pull/17925#discussion_r372188833,372188833,src/txmempool.h
jonatack,2020-02-03 11:30:29,typo for follow-ups: s/traverals/traversals/,https://github.com/bitcoin/bitcoin/pull/17925#discussion_r374052497,374052497,src/txmempool.h
