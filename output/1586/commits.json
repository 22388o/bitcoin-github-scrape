[
  {
    "sha": "0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZmM2Y2Y2ZDM1ZTE3MTBkNGIzZjJmZmFkYjlmYjliMzkxNzZiMTY3",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-17T16:38:25Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-08-12T23:29:53Z"
      },
      "message": "Relay blocks as a \"preview\" before checking the transactions in them",
      "tree": {
        "sha": "97be7e9a0fb298c35a766c0d470055d889b0846d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97be7e9a0fb298c35a766c0d470055d889b0846d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "198947c19fe1452cbef3265c280cd96afa084012",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/198947c19fe1452cbef3265c280cd96afa084012",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/198947c19fe1452cbef3265c280cd96afa084012"
      }
    ],
    "stats": {
      "total": 88,
      "additions": 70,
      "deletions": 18
    },
    "files": [
      {
        "sha": "cbbe7d86d1e1102f8d1b3a847fa372579f6a20f6",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 18,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "patch": "@@ -1741,34 +1741,42 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n \n \n \n-bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n+bool CBlock::CheckBlockHeader(bool fCheckPOW) const\n {\n-    // These are checks that are independent of context\n-    // that can be verified before saving an orphan block.\n-\n-    // Size limits\n-    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+    // These are checks that are independent of transaction count/content\n+    // that can be verified with just the block header\n \n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(GetHash(), nBits))\n-        return DoS(50, error(\"CheckBlock() : proof of work failed\"));\n+        return DoS(50, error(\"CheckBlockHeader() : proof of work failed\"));\n \n     // Check timestamp\n     if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return error(\"CheckBlock() : block timestamp too far in the future\");\n+        return error(\"CheckBlockHeader() : block timestamp too far in the future\");\n+\n+    return true;\n+}\n+\n+bool CBlock::CheckBlockBody(bool fCheckMerkleRoot) const\n+{\n+    // These are checks that are independent of context\n+    // that can be verified before saving an orphan block.\n+\n+    // Size limits\n+    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+        return DoS(100, error(\"CheckBlockBody() : size limits failed\"));\n \n     // First transaction must be coinbase, the rest must not be\n     if (vtx.empty() || !vtx[0].IsCoinBase())\n-        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n+        return DoS(100, error(\"CheckBlockBody() : first tx is not coinbase\"));\n     for (unsigned int i = 1; i < vtx.size(); i++)\n         if (vtx[i].IsCoinBase())\n-            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n+            return DoS(100, error(\"CheckBlockBody() : more than one coinbase\"));\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n         if (!tx.CheckTransaction())\n-            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n+            return DoS(tx.nDoS, error(\"CheckBlockBody() : CheckTransaction failed\"));\n \n     // Check for duplicate txids. This is caught by ConnectInputs(),\n     // but catching it earlier avoids a potential DoS attack:\n@@ -1778,23 +1786,28 @@ bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n         uniqueTx.insert(tx.GetHash());\n     }\n     if (uniqueTx.size() != vtx.size())\n-        return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n+        return DoS(100, error(\"CheckBlockBody() : duplicate transaction\"));\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         nSigOps += tx.GetLegacySigOpCount();\n     }\n     if (nSigOps > MAX_BLOCK_SIGOPS)\n-        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n+        return DoS(100, error(\"CheckBlockBody() : out-of-bounds SigOpCount\"));\n \n     // Check merkle root\n     if (fCheckMerkleRoot && hashMerkleRoot != BuildMerkleTree())\n-        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n+        return DoS(100, error(\"CheckBlockBody() : hashMerkleRoot mismatch\"));\n \n     return true;\n }\n \n+bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n+{\n+    return CheckBlockHeader(fCheckPOW) && CheckBlockBody(fCheckMerkleRoot);\n+}\n+\n bool CBlock::AcceptBlock()\n {\n     // Check for duplicate\n@@ -1859,8 +1872,8 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!pblock->CheckBlockHeader(true))\n+        return error(\"ProcessBlock() : CheckBlockHeader FAILED\");\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n     if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n@@ -1885,6 +1898,35 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         }\n     }\n \n+    bool fEnablePreview;\n+    // Only enable block preview broadcasts when the difficulty in making them is high enough that it's not worth DoSing with them\n+    {\n+        double dDiff = (double)0x0000ffff / (double)(pblock->nBits & 0x00ffffff);\n+        for (int nShift = pblock->nBits >> 24; nShift < 29; ++nShift)\n+            dDiff *= 0x100;\n+        fEnablePreview = dDiff >= 0x20000;\n+    }\n+\n+    if (pblock->hashPrevBlock == pindexBest->GetBlockHash())\n+    {\n+        // We can check the immediate next block's time and bits headers earlier\n+        if (pblock->GetBlockTime() <= pindexBest->GetMedianTimePast())\n+            return error(\"ProcessBlock() : block's timestamp is too early\");\n+\n+        if (pblock->nBits != GetNextWorkRequired(pindexBest, pblock))\n+            return pblock->DoS(100, error(\"ProcessBlock() : incorrect proof of work\"));\n+\n+        if (fEnablePreview)\n+            // Relay blocks after only checking their header, so we don't bias them against including transactions too much\n+            RelayMessage(CInv(MSG_BLOCK_PREVIEW, hash), *pblock);\n+    }\n+\n+    if (!pblock->CheckBlockBody(true))\n+    {\n+        if (fEnablePreview)\n+            pblock->nDoS = 0;\n+        return error(\"ProcessBlock() : CheckBlockBody FAILED\");\n+    }\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n     if (!mapBlockIndex.count(pblock->hashPrevBlock))\n@@ -1902,7 +1944,11 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n \n     // Store to disk\n     if (!pblock->AcceptBlock())\n+    {\n+        if (fEnablePreview)\n+            pblock->nDoS = 0;\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n     vector<uint256> vWorkQueue;\n@@ -2355,6 +2401,7 @@ bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n         }\n \n     case MSG_BLOCK:\n+    case MSG_BLOCK_PREVIEW:\n         return mapBlockIndex.count(inv.hash) ||\n                mapOrphanBlocks.count(inv.hash);\n     }\n@@ -2590,7 +2637,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         // find last block in inv vector\n         unsigned int nLastBlock = (unsigned int)(-1);\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n-            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n+            int& type = vInv[vInv.size() - 1 - nInv].type;\n+            if (type == MSG_BLOCK || type == MSG_BLOCK_PREVIEW) {\n                 nLastBlock = vInv.size() - 1 - nInv;\n                 break;\n             }"
      },
      {
        "sha": "5a7d99763d32efebebd313e9e2283967c4237cf5",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "patch": "@@ -1021,6 +1021,8 @@ class CBlock\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n     bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n     bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n+    bool CheckBlockHeader(bool fCheckPOW) const;\n+    bool CheckBlockBody(bool fCheckMerkleRoot) const;\n     bool CheckBlock(bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n     bool AcceptBlock();\n "
      },
      {
        "sha": "92d92443c553e8672cf4bec488018512cfd5db97",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "patch": "@@ -72,6 +72,7 @@ enum\n {\n     MSG_TX = 1,\n     MSG_BLOCK,\n+    MSG_BLOCK_PREVIEW,\n };\n \n class CRequestTracker"
      },
      {
        "sha": "2282abbdb2ec5e62f032e048e4d95f64453bcef7",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "patch": "@@ -16,6 +16,7 @@ static const char* ppszTypeName[] =\n     \"ERROR\",\n     \"tx\",\n     \"block\",\n+    \"block\",\n };\n \n CMessageHeader::CMessageHeader()"
      }
    ]
  },
  {
    "sha": "4e54ea804ccdd2223e622497f0d46cceb27b9d22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZTU0ZWE4MDRjY2RkMjIyM2U2MjI0OTdmMGQ0NmNjZWIyN2I5ZDIy",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-08-13T00:42:48Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-08-13T03:36:05Z"
      },
      "message": "Begin relaying blocks immediately after doing validity checks on the header, even before our own download has completed",
      "tree": {
        "sha": "65a6c0a9e2b0d5407e0d530d2b801d100e76c4a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65a6c0a9e2b0d5407e0d530d2b801d100e76c4a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e54ea804ccdd2223e622497f0d46cceb27b9d22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e54ea804ccdd2223e622497f0d46cceb27b9d22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4e54ea804ccdd2223e622497f0d46cceb27b9d22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e54ea804ccdd2223e622497f0d46cceb27b9d22/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0fc6cf6d35e1710d4b3f2ffadb9fb9b39176b167"
      }
    ],
    "stats": {
      "total": 125,
      "additions": 96,
      "deletions": 29
    },
    "files": [
      {
        "sha": "e4cb9faa0454e075f88f1aafbb87fd22902ec1f6",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 29,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e54ea804ccdd2223e622497f0d46cceb27b9d22/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e54ea804ccdd2223e622497f0d46cceb27b9d22/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4e54ea804ccdd2223e622497f0d46cceb27b9d22",
        "patch": "@@ -1862,18 +1862,17 @@ bool CBlock::AcceptBlock()\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool ProcessBlockHeader(CNode* pfrom, CBlock* pblock, const uint256& hash, bool& fEnablePreview)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n     if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n+        return error(\"ProcessBlockHeader() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n     if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+        return error(\"ProcessBlockHeader() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n \n     // Preliminary checks\n     if (!pblock->CheckBlockHeader(true))\n-        return error(\"ProcessBlock() : CheckBlockHeader FAILED\");\n+        return error(\"ProcessBlockHeader() : CheckBlockHeader FAILED\");\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n     if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n@@ -1884,7 +1883,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         {\n             if (pfrom)\n                 pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            return error(\"ProcessBlockHeader() : block with timestamp before last checkpoint\");\n         }\n         CBigNum bnNewBlock;\n         bnNewBlock.SetCompact(pblock->nBits);\n@@ -1894,11 +1893,10 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         {\n             if (pfrom)\n                 pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            return error(\"ProcessBlockHeader() : block with too little proof-of-work\");\n         }\n     }\n \n-    bool fEnablePreview;\n     // Only enable block preview broadcasts when the difficulty in making them is high enough that it's not worth DoSing with them\n     {\n         double dDiff = (double)0x0000ffff / (double)(pblock->nBits & 0x00ffffff);\n@@ -1911,27 +1909,32 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n     {\n         // We can check the immediate next block's time and bits headers earlier\n         if (pblock->GetBlockTime() <= pindexBest->GetMedianTimePast())\n-            return error(\"ProcessBlock() : block's timestamp is too early\");\n+            return error(\"ProcessBlockHeader() : block's timestamp is too early\");\n \n         if (pblock->nBits != GetNextWorkRequired(pindexBest, pblock))\n-            return pblock->DoS(100, error(\"ProcessBlock() : incorrect proof of work\"));\n+            return pblock->DoS(100, error(\"ProcessBlockHeader() : incorrect proof of work\"));\n \n         if (fEnablePreview)\n+        {\n             // Relay blocks after only checking their header, so we don't bias them against including transactions too much\n+            pblock->csBlockDownload = new std::pair<boost::mutex, boost::condition_variable>();\n+            pblock->fBlockDownloading = true;\n             RelayMessage(CInv(MSG_BLOCK_PREVIEW, hash), *pblock);\n+        }\n     }\n \n+    return true;\n+}\n+\n+bool ProcessBlockBody(CNode* pfrom, CBlock* pblock, const uint256& hash)\n+{\n     if (!pblock->CheckBlockBody(true))\n-    {\n-        if (fEnablePreview)\n-            pblock->nDoS = 0;\n-        return error(\"ProcessBlock() : CheckBlockBody FAILED\");\n-    }\n+        return error(\"ProcessBlockBody() : CheckBlockBody FAILED\");\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n     if (!mapBlockIndex.count(pblock->hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n+        printf(\"ProcessBlockBody: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n         CBlock* pblock2 = new CBlock(*pblock);\n         mapOrphanBlocks.insert(make_pair(hash, pblock2));\n         mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n@@ -1944,11 +1947,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n \n     // Store to disk\n     if (!pblock->AcceptBlock())\n-    {\n-        if (fEnablePreview)\n-            pblock->nDoS = 0;\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n-    }\n+        return error(\"ProcessBlockBody() : AcceptBlock FAILED\");\n \n     // Recursively process any orphan blocks that depended on this one\n     vector<uint256> vWorkQueue;\n@@ -1969,7 +1968,22 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n+    printf(\"ProcessBlockBody: ACCEPTED\\n\");\n+    return true;\n+}\n+\n+bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+{\n+    uint256 hash = pblock->GetHash();\n+    bool fEnablePreview;\n+    if (!ProcessBlockHeader(pfrom, pblock, hash, fEnablePreview))\n+        return false;\n+    if (!ProcessBlockBody(pfrom, pblock, hash))\n+    {\n+        if (fEnablePreview)\n+            pblock->nDoS = 0;\n+        return false;\n+    }\n     return true;\n }\n \n@@ -2877,18 +2891,55 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"block\")\n     {\n+        bool fFullBlock = vRecv.nType & SER_BLOCKHEADERONLY;\n+        if (!fFullBlock)\n+            // FIXME: Do we need to support this?\n+            printf(\"received block with SER_BLOCKHEADERONLY already set; this is not supported!\\n\");\n+\n         CBlock block;\n+        vRecv.nType |= SER_BLOCKHEADERONLY;\n         vRecv >> block;\n+        if (fFullBlock)\n+            vRecv.nType &= ~SER_BLOCKHEADERONLY;\n+        uint256 hashBlock = block.GetHash();\n+        printf(\"received block header %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n+        bool fEnablePreview;\n+        // NOTE: ProcessBlockHeader potentially begins this block relaying as a preview.\n+        if (!ProcessBlockHeader(pfrom, &block, hashBlock, fEnablePreview))\n+        {\n+            // We don't want this block. Can we skip the download? TODO\n+            if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+            {\n+                boost::lock_guard<boost::mutex> lock(block.csBlockDownload->first);\n+                block.fBlockDownloading = false;\n+            }\n+            block.csBlockDownload->second.notify_all();\n+        }\n+        else\n+        {\n+            // Download the block contents\n+            vRecv >> block.vtx;\n+            {\n+                boost::lock_guard<boost::mutex> lock(block.csBlockDownload->first);\n+                block.fBlockDownloading = false;\n+            }\n+            block.csBlockDownload->second.notify_all();\n+            printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n \n-        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n-        // block.print();\n+            CInv inv(MSG_BLOCK, block.GetHash());\n+            pfrom->AddInventoryKnown(inv);\n \n-        CInv inv(MSG_BLOCK, block.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n+            if (ProcessBlockBody(pfrom, &block, hashBlock))\n+                mapAlreadyAskedFor.erase(inv);\n \n-        if (ProcessBlock(pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n-        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+            /* Ignore DoS if block previewing is enabled:\n+             * - We might have been relayed the body before or without\n+             *   checking it.\n+             * - Previewing is only enabled when the block difficulty is\n+             *   sufficiently high to make it costly for a DoS.\n+             */\n+            if (block.nDoS && !fEnablePreview) pfrom->Misbehaving(block.nDoS);\n+        }\n     }\n \n "
      },
      {
        "sha": "827b32fa5378abcf1c90561c916147c6455da180",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e54ea804ccdd2223e622497f0d46cceb27b9d22/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e54ea804ccdd2223e622497f0d46cceb27b9d22/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4e54ea804ccdd2223e622497f0d46cceb27b9d22",
        "patch": "@@ -12,6 +12,9 @@\n \n #include <list>\n \n+#include <boost/thread/condition_variable.hpp>\n+#include <boost/thread/mutex.hpp>\n+\n class CWallet;\n class CBlock;\n class CBlockIndex;\n@@ -837,6 +840,10 @@ class CBlock\n     mutable int nDoS;\n     bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n \n+    // Fast block relay\n+    bool fBlockDownloading;\n+    std::pair<boost::mutex, boost::condition_variable> *csBlockDownload;\n+\n     CBlock()\n     {\n         SetNull();\n@@ -854,7 +861,15 @@ class CBlock\n \n         // ConnectBlock depends on vtx being last so it can calculate offset\n         if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n+        {\n+            if (fBlockDownloading)\n+            {\n+                boost::unique_lock<boost::mutex> lock(csBlockDownload->first);\n+                while (fBlockDownloading)\n+                    csBlockDownload->second.wait(lock);\n+            }\n             READWRITE(vtx);\n+        }\n         else if (fRead)\n             const_cast<CBlock*>(this)->vtx.clear();\n     )\n@@ -870,6 +885,7 @@ class CBlock\n         vtx.clear();\n         vMerkleTree.clear();\n         nDoS = 0;\n+        fBlockDownloading = false;\n     }\n \n     bool IsNull() const"
      }
    ]
  }
]