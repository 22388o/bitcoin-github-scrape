[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432885176",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-432885176",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 432885176,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjg4NTE3Ng==",
    "user": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?u=a0e0040aacd7d4f0787481e8ac30b494fa429e11&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T01:48:38Z",
    "updated_at": "2018-10-25T01:48:38Z",
    "author_association": "MEMBER",
    "body": "Travis is sad about trailing whitespace:\r\n```\r\nThis diff appears to have added new lines with trailing whitespace.\r\nThe following changes were suspected:\r\ndiff --git a/src/wallet/rpcdump.cpp b/src/wallet/rpcdump.cpp\r\n@@ -915,0 +969,10 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\r\n+\r\n^---- failure generated from test/lint/lint-whitespace.sh\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432885176/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432901906",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-432901906",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 432901906,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjkwMTkwNg==",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?u=447cdc9e2966cbee415545c8ff452954ee1209af&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T03:28:07Z",
    "updated_at": "2018-10-25T08:39:11Z",
    "author_association": "MEMBER",
    "body": "Concept ACK, I think I prefer this over #14558 but will review both more in-depth first",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432901906/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432905054",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-432905054",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 432905054,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjkwNTA1NA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T03:49:16Z",
    "updated_at": "2018-11-20T00:40:17Z",
    "author_association": "MEMBER",
    "body": "~~I've also discovered when writing this that `importmulti` does not actually require that `watchonly` is set when no solvability is desired. I've kept the existing behavior for now, as it seems pretty invasive to people who may be relying on that, though I've added a TODO.~~\r\n\r\nEDIT: seems I misunderstand the original purpose; the \"watchonly\" is there to support importing something as watch-only without importing all the private keys (and is thus about spendability, not about solvability). That both matches the name better, and the existing (lack of) errors related to it. It also makes more sense, as there is no point in providing keys/script when no solvability is desired, while it makes perfect sense to include private keys when no spendability is desired.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432905054/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432912078",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-432912078",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 432912078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjkxMjA3OA==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-25T04:38:21Z",
    "updated_at": "2018-12-21T13:56:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14918](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14918.html) (RPCHelpMan: Check default values are given at compile-time by MarcoFalke)\n* [#14912](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14912.html) ([WIP] External signer support (e.g. hardware wallet) by Sjors)\n* [#14491](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14491.html) (Allow descriptor imports with importmulti by MeshCollider)\n* [#14075](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14075.html) (Import watch only pubkeys to the keypool if private keys are disabled by achow101)\n* [#14021](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14021.html) (Import key origin data through descriptors in importmulti by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/432912078/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/433255039",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-433255039",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 433255039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzI1NTAzOQ==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-26T01:16:42Z",
    "updated_at": "2018-10-26T01:16:42Z",
    "author_association": "MEMBER",
    "body": "> There's still a bunch of processing and checking happening outside of ProcessSolvingImportStep though, which is less easy to follow, but at least that code is now shorter.\r\n\r\nThat's intentional. It's a recursive function to deal with analysing script specific solvability information. Anything that isn't specific to the script being imported isn't in there.\r\n\r\n> Do the existing tests cover the new sanity checks you added?\r\n\r\nNot yet, will add those soon.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/433255039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435553681",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-435553681",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 435553681,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTU1MzY4MQ==",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?u=447cdc9e2966cbee415545c8ff452954ee1209af&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-03T02:28:58Z",
    "updated_at": "2018-11-03T02:28:58Z",
    "author_association": "MEMBER",
    "body": "utACK https://github.com/bitcoin/bitcoin/pull/14565/commits/33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435553681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435957864",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-435957864",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 435957864,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTk1Nzg2NA==",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T17:18:24Z",
    "updated_at": "2018-11-05T17:18:38Z",
    "author_association": "MEMBER",
    "body": "I noticed we have no `getaddressinfo[\"ischange\"]` tests yet, and would be a good time to add those.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435957864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435958733",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-435958733",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 435958733,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTk1ODczMw==",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T17:20:59Z",
    "updated_at": "2018-11-05T17:35:17Z",
    "author_association": "MEMBER",
    "body": "utACK 33855fec46dbc3a7cad76875ca2a7660fcc19e92 aside from the `ischange` test, I can't seem to convince myself we even honor the flag, even in master/0.17...\r\n\r\nedit: https://github.com/bitcoin/bitcoin/issues/14662",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435958733/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436914666",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-436914666",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 436914666,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjkxNDY2Ng==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T08:36:58Z",
    "updated_at": "2018-11-08T08:36:58Z",
    "author_association": "MEMBER",
    "body": "@achow101 wrote in inline comment:\r\n\r\n> Instead of a `std::set`, could `std::vector` be used for these in order to preserve the order in which things will be imported? This is useful for #14075 where we want to have the order in which things are added to the wallet be the order that was specified in the import.\r\n\r\nIt's also better for recoverability if the wallet strives to use derivation paths in ascending order. Otherwise the user needs to remember what range they imported before.\r\n\r\nIt would be also keep us a bit closer to honouring a BIP44-style gap limit (if the user generates more than 20 addresses without receiving coins on any of them, we'd still break that gap, but at least that's not the common case). ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436914666/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437238010",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-437238010",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 437238010,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzIzODAxMA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T03:27:46Z",
    "updated_at": "2018-11-09T03:27:46Z",
    "author_association": "MEMBER",
    "body": "I realized I misread what \"watchonly\" was supposed to mean; it means it's fine if the resulting address is not *spendable* (I was under the assumption it meant being fine if it's not *solvable*).\r\n\r\nI made some significant logic changes as a result to reflect the warning messages for that. All other comments are addressed, apart from the ordering of keys, and adding tests (which I will do soon).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437238010/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/438314197",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-438314197",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 438314197,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODMxNDE5Nw==",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-13T15:46:08Z",
    "updated_at": "2018-11-13T15:46:08Z",
    "author_association": "MEMBER",
    "body": "LGTM, awaiting tests",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/438314197/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/440105516",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-440105516",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 440105516,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDEwNTUxNg==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-20T01:40:38Z",
    "updated_at": "2018-11-20T01:49:14Z",
    "author_association": "MEMBER",
    "body": "> re: #14565 (comment):\r\n>> I've also discovered when writing this that importmulti does not actually require that watchonly is set when no solvability is desired. I've kept the existing behavior for now, as it seems pretty invasive to people who may be relying on that, though I've added a TODO.\r\n> I don't see the TODO. Would the TODO just be to turn the \"Assuming watchonly as not all private keys are provided.\" warning into an error?\r\n\r\nIt refers to an earlier misunderstanding I had, which I first tried to fix the even-more-wrong way. I've updated the comment now.\r\n\r\n> re: #14565 (comment):\r\n>> I realized I misread what \"watchonly\" was supposed to mean; it means it's fine if the resulting address is not spendable (I was under the assumption it meant being fine if it's not solvable).\r\n> Was having trouble understanding this. I think it is saying an earlier version of this PR allowed importing non-solvable scriptPubKeys as watch only, but now even watch-only scripts must be solvable. But is this actually a good requirement to have? Or is it just this way to avoid changing behavior?\r\n\r\nSorry for the confusion. Your comment made me read through history and make a few more changes. Here is my view:\r\n* The initial *intended* behavior (see https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214397377) of \"watchonly\" was that it would let the user indicate explicitly that he did not desire spendability (i.e. the RPC should import the address/script as watched even though not all private keys were available).\r\n* In #7551 this was not implemented correctly; instead of making sure that the result was spendable when \"watchonly\" was *not* specified, it would refuse importing private keys entirely when it *was* specified. I don't think that behavior made any sense, but embarrasingly, I don't think anyone ever noticed.\r\n* When I first opened this PR, I misremembered the intent, and assumed \"watchonly\" was intended to (but still failed to) permit non-*solvable* imports rather than non-*spendable* ones (that's what https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-432905054 refers to). As a result, I made a number of changes initially to correct this.\r\n* Later (https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-437238010) I discovered that the intent was permitting non-spendability rather than non-solvability (which makes a lot more sense; it required fewer code and test changes, and importing something non-solvable isn't prone to error, while something non-spendable is - you may randomly miss a private key), and adapted the PR to work towards.\r\n* Now with your comment above, I noticed the earlier \"refuse private keys when watchonly is set\" behaviour, and reverted it.\r\n\r\nOverall, as errors/warnings go, I think that the result of the above is that a number of previously permitted (but unnecessary) ways of calling this RPC now get detected. As it has a reasonable chance of breaking usage, I'm turning as many of those as possible into warnings into failures. All previously supported things should still work (but some more).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/440105516/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/441119110",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-441119110",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 441119110,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTExOTExMA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-22T20:57:56Z",
    "updated_at": "2018-11-22T20:57:56Z",
    "author_association": "MEMBER",
    "body": "utACK 8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/441119110/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442730298",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-442730298",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 442730298,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjczMDI5OA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-29T07:14:13Z",
    "updated_at": "2018-11-29T07:14:13Z",
    "author_association": "MEMBER",
    "body": "> I still don't understand this. There are three cases, right?\r\n>\r\n> * Solvable and spendable\r\n> * Solvable but not spendable\r\n> * Not solvable, not spendable\r\n>\r\n> It seems like all three cases are permitted in this PR, except there will be warnings if unused keys are provided, and errors if solving data is provided but some keys are missing. I guess I don't know if this is the final state or you want to make more changes in the future.\r\n\r\nRight, that's correct. The way to use them is:\r\n\r\n* Solvable and spendable: give all scripts, all private keys\r\n* Solvable but not spendable: give all scripts, all pubkeys for the pubkeyhashes in those scripts, plus optionally some (but not all) private keys, plus \"watchonly\".\r\n* Not solvable, not spendable: give no scripts or keys, plus \"watchonly\".\r\n\r\nThe reason for the \"watchonly\" is distinguishing between solvable/spendable and solvable/unspendable: even if the non-spendable case you may want to import some of the related private keys. If you accidentally miss one of the keys however, the result will not be spendable. To make sure this is intentional, a warning will be given, which can be suppressed by saying \"watchonly\".",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442730298/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442846923",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-442846923",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 442846923,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Mjg0NjkyMw==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-29T14:11:41Z",
    "updated_at": "2018-11-29T14:11:41Z",
    "author_association": "MEMBER",
    "body": "> If you accidentally miss one of the keys however, the result will not be spendable. To make sure this is intentional, a warning will be given, which can be suppressed by saying \"watchonly\".\r\n\r\nNow that's a sentence worthy of going into the release notes (or help).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442846923/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442968190",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-442968190",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 442968190,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Mjk2ODE5MA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-29T19:46:13Z",
    "updated_at": "2018-11-29T19:46:13Z",
    "author_association": "MEMBER",
    "body": "This PR absolutely needs more tests, but I won't have time for that the next few days at least. If someone is interested in helping out, I think it would be useful to rewrite the existing tests to use the following pattern:K\r\n* Keys are generated on node1\r\n* Addresses/scripts/pubkeys are computed from those keys\r\n* An `importmulti` query is constructed\r\n* A function is called which is passed all this information, which calls `getaddressinfo` on the script/address itself (if it exists), but also calls it for all subscripts, P2SH/P2WSH wrapped versions, P2PK and P2PKH and P2WPKH versions of the involved keys, and tests that only the desired things are spendable/solvable/watched.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442968190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/444918143",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-444918143",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 444918143,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDkxODE0Mw==",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?u=71263a00d1269c7f0ed6660aa0c15c894df78a88&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-06T15:47:44Z",
    "updated_at": "2018-12-06T15:47:44Z",
    "author_association": "MEMBER",
    "body": "> I've started refactoring the wallet_importmulti.py into this style. It's a WIP here: https://github.com/jnewbery/bitcoin/tree/importmulti_tests . I hope to continue working on it this week.\r\n\r\nThis work is (mostly) complete. Intermediate commits could probably do with some tidy-up, which I intend to do later today.\r\n\r\nPR here: #14886",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/444918143/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445043413",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-445043413",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 445043413,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NTA0MzQxMw==",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?u=71263a00d1269c7f0ed6660aa0c15c894df78a88&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-06T21:53:23Z",
    "updated_at": "2018-12-06T21:53:23Z",
    "author_association": "MEMBER",
    "body": "I've started writing tests for this PR: https://github.com/jnewbery/bitcoin/tree/pr14565.tests\r\n\r\nIt's certainly not complete, but it makes a start by:\r\n- testing the return object from `importmulti` for the right `warnings` return value.\r\n- calling `getaddressinfo` for the different address variants when privkeys are imported.\r\n\r\nTo continue, we should:\r\n\r\n- restructure the test so in order, it's testing:\r\n    - P2PKH (scriptPubKey and address)\r\n    - P2WPKH (scriptPubKey and address)\r\n    - P2SH-P2WPKH (scriptPubKey and address)\r\n    - bare multisig (scriptPubKey only)\r\n    - P2SH (scriptPubKey and address)\r\n    - P2WSH (scriptPubKey and address)\r\n    - P2SH-P2WSH (scriptPubKey and address)\r\n- increase coverage, so that all warnings and errors are hit.\r\n\r\nI'm unlikely to be able to spend time on the tests for the next few days. Anyone is free to take the branch and continue building on it.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445043413/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446415794",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-446415794",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 446415794,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NjQxNTc5NA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-12T00:30:09Z",
    "updated_at": "2018-12-12T00:30:09Z",
    "author_association": "MEMBER",
    "body": "I've addressed many of the comments above, rebased on top of the new test changes from #14886, and made a few behavior changes as well:\r\n* Instead of sticking to a \"what used to be an error and is still not supported remains an error, other things are warnings\", as that resulted in pretty inconsistent behavior. I think I've changed things to be more consistently only errorring for actual failures. I still think we should do a deprecatedrpc thing to turn all warnings into errors, preferably in the same release, but maybe not in this PR.\r\n* Added a warning for specifying \"watchonly\" while providing all private keys.\r\n* Removed the special case error for redeemscript-for-P2WSH, while all other mismatches of this type are just warnings that result in non-solvability.\r\n* More explanations in warning messages.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446415794/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446799251",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-446799251",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 446799251,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Njc5OTI1MQ==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-13T00:40:40Z",
    "updated_at": "2018-12-13T00:40:40Z",
    "author_association": "MEMBER",
    "body": "@Sjors \r\n\r\n> Or just add that as an option? It seems like a useful feature, especially since we can't delete keys and don't have a dry-run option. Different PR is fine.\r\n\r\nI'd really like to avoid that. There is no reason for that to be an option (which we may need to maintain forever), as the intended behavior is that these things are just errors, always. The only reason why they aren't is because we don't want to break existing software immediately.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446799251/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446894935",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-446894935",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 446894935,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0Njg5NDkzNQ==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-13T09:11:15Z",
    "updated_at": "2018-12-13T09:11:29Z",
    "author_association": "MEMBER",
    "body": "re-utACK eacff95",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446894935/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449715385",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#issuecomment-449715385",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/14565",
    "id": 449715385,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0OTcxNTM4NQ==",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?u=447cdc9e2966cbee415545c8ff452954ee1209af&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-24T10:25:18Z",
    "updated_at": "2018-12-24T10:25:18Z",
    "author_association": "MEMBER",
    "body": "utACK https://github.com/bitcoin/bitcoin/pull/14565/commits/eacff95de4751b500f1cef623e4024918dcb05bb\r\n\r\nAgree with John, the final nits can be addressed in a followup",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449715385/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040392",
    "pull_request_review_id": 168215750,
    "id": 228040392,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODA0MDM5Mg==",
    "diff_hunk": "@@ -805,6 +805,87 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript;\n+    std::unique_ptr<CScript> witnessscript;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class SolverContext\n+{\n+    TOP,\n+    P2SH,\n+    WITNESS_V0,\n+};\n+\n+static void ProcessSolvingImportStep(const CScript& script, ImportData& data, SolverContext ctx)\n+{",
    "path": "src/wallet/rpcdump.cpp",
    "position": 25,
    "original_position": 26,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It's not immediately obvious what this is doing, until you read `txnouttype Solver` documentation in `standard.h`.\r\n\r\nSuggested comment: \r\n```\r\n// Use Solver to obtain script type and parsed pubkeys or hashes:\r\n```",
    "created_at": "2018-10-25T05:44:51Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228040392",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040392"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228040392"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040392/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 860,
    "original_line": 860,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040464",
    "pull_request_review_id": 168215750,
    "id": 228040464,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODA0MDQ2NA==",
    "diff_hunk": "@@ -805,6 +805,87 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript;\n+    std::unique_ptr<CScript> witnessscript;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class SolverContext\n+{\n+    TOP,\n+    P2SH,\n+    WITNESS_V0,\n+};\n+\n+static void ProcessSolvingImportStep(const CScript& script, ImportData& data, SolverContext ctx)\n+{\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype typ = Solver(script, solverdata);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`script_type` would be clearer",
    "created_at": "2018-10-25T05:45:22Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228040464",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040464"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228040464"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228040464/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 832,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228051747",
    "pull_request_review_id": 168215750,
    "id": 228051747,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODA1MTc0Nw==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": 119,
    "original_position": 110,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It would be nice if the call to `ExtractDestination(s)` and various parsing happening below was also a `ProcessSolvingImportStep` (`SolverContext::TOP` or a new context?), but I suppose the different types make that difficult?",
    "created_at": "2018-10-25T06:51:03Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228051747",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228051747"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228051747"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228051747/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 964,
    "original_line": 964,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228052708",
    "pull_request_review_id": 168215750,
    "id": 228052708,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODA1MjcwOA==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n+        if (watchOnly && (import_data.pubkeys.size() || import_data.redeemscript || import_data.witnessscript)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include any keys or scripts\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // TODO: it seems we're not actually requiring watchonly to be set for non-solvable inputs, fix this",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 229,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Add a warning to the result output?",
    "created_at": "2018-10-25T06:55:39Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228052708",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228052708"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228052708"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228052708/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 980,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228053700",
    "pull_request_review_id": 168215750,
    "id": 228053700,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODA1MzcwMA==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n+        if (watchOnly && (import_data.pubkeys.size() || import_data.redeemscript || import_data.witnessscript)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include any keys or scripts\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // TODO: it seems we're not actually requiring watchonly to be set for non-solvable inputs, fix this\n+        watchOnly = !(import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size());\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n-            }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+        // Verify and process input data\n+        bool spendable = !watchOnly;\n+        if (!watchOnly) {\n+            ProcessSolvingImportStep(script, import_data, SolverContext::TOP);\n+            if (import_data.redeemscript) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Redeemscript provided for a non-P2SH script\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 281,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why check this here, rather than passing `watchOnly` into `ProcessSolvingImportStep` and check there?",
    "created_at": "2018-10-25T07:00:12Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228053700",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228053700"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228053700"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228053700/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 997,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380388",
    "pull_request_review_id": 168641314,
    "id": 228380388,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODM4MDM4OA==",
    "diff_hunk": "@@ -805,6 +805,87 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript;\n+    std::unique_ptr<CScript> witnessscript;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class SolverContext\n+{\n+    TOP,\n+    P2SH,\n+    WITNESS_V0,\n+};\n+\n+static void ProcessSolvingImportStep(const CScript& script, ImportData& data, SolverContext ctx)\n+{",
    "path": "src/wallet/rpcdump.cpp",
    "position": 25,
    "original_position": 26,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-10-26T01:01:56Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380388",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380388"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380388"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380388/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 860,
    "original_line": 860,
    "side": "RIGHT",
    "in_reply_to_id": 228040392
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380402",
    "pull_request_review_id": 168641335,
    "id": 228380402,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODM4MDQwMg==",
    "diff_hunk": "@@ -805,6 +805,87 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript;\n+    std::unique_ptr<CScript> witnessscript;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class SolverContext\n+{\n+    TOP,\n+    P2SH,\n+    WITNESS_V0,\n+};\n+\n+static void ProcessSolvingImportStep(const CScript& script, ImportData& data, SolverContext ctx)\n+{\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype typ = Solver(script, solverdata);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-10-26T01:02:02Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380402",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380402"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380402"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380402/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 832,
    "side": "RIGHT",
    "in_reply_to_id": 228040464
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380649",
    "pull_request_review_id": 168641676,
    "id": 228380649,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODM4MDY0OQ==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": 119,
    "original_position": 110,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think that would be completely the wrong place; perhaps the control flow isn't clear?\r\n\r\n`ProcessSolvingImportStep` is a recursive function that matches up the parsed solvability information (only the `keys`, `pubkeys`, `redeemscript`, and `witnessscript` fields) with the provided address/script, recursing into subscripts as needed. Anything that isn't specific to the type of script being imported doesn't belong there. In particular, labels are unrelated to script types.\r\n\r\nI've added some comments and renamed the function to `RecurseImportData`. Perhaps that is clearer?\r\n\r\n",
    "created_at": "2018-10-26T01:04:28Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380649",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380649"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380649"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 964,
    "original_line": 964,
    "side": "RIGHT",
    "in_reply_to_id": 228051747
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380989",
    "pull_request_review_id": 168642107,
    "id": 228380989,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODM4MDk4OQ==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n+        if (watchOnly && (import_data.pubkeys.size() || import_data.redeemscript || import_data.witnessscript)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include any keys or scripts\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // TODO: it seems we're not actually requiring watchonly to be set for non-solvable inputs, fix this",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 229,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That's a great idea. I've implemented that and taken it a bit further. I think all new error conditions (that don't signify seriously broken things like P2SH-inside-P2SH) are now reported as warnings instead of causing the RPC to fail.\r\n\r\nPerhaps we want to introduce a new mode where all these warnings become errors, though `-deprecatedrpc`, but let's discuss that in a separate RPC.",
    "created_at": "2018-10-26T01:07:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380989",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380989"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228380989"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228380989/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 980,
    "side": "RIGHT",
    "in_reply_to_id": 228052708
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228381482",
    "pull_request_review_id": 168642710,
    "id": 228381482,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODM4MTQ4Mg==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n+        if (watchOnly && (import_data.pubkeys.size() || import_data.redeemscript || import_data.witnessscript)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include any keys or scripts\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // TODO: it seems we're not actually requiring watchonly to be set for non-solvable inputs, fix this\n+        watchOnly = !(import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size());\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n-            }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+        // Verify and process input data\n+        bool spendable = !watchOnly;\n+        if (!watchOnly) {\n+            ProcessSolvingImportStep(script, import_data, SolverContext::TOP);\n+            if (import_data.redeemscript) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Redeemscript provided for a non-P2SH script\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 281,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If `watchonly` is true, there is nothing to do for `ProcessSolvingImportStep`, as there is no script to be analysed (see other comment).",
    "created_at": "2018-10-26T01:12:00Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228381482",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228381482"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228381482"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228381482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 997,
    "side": "RIGHT",
    "in_reply_to_id": 228053700
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228408379",
    "pull_request_review_id": 168674842,
    "id": 228408379,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODQwODM3OQ==",
    "diff_hunk": "@@ -805,6 +805,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 7,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "b4cc694759a6911f8932a5a6f30eb28fc122a680",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: typo \"mvoed\"",
    "created_at": "2018-10-26T05:23:22Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228408379",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228408379"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228408379"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228408379/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 810,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228409405",
    "pull_request_review_id": 168674842,
    "id": 228409405,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODQwOTQwNQ==",
    "diff_hunk": "@@ -840,198 +924,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        // Warn about inconsistencies between watchonly and provided keys/scripts\n+        UniValue warnings(UniValue::VARR);\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (watchOnly && have_solving_data) {\n+            warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n         }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        if (!watchOnly && !have_solving_data) {\n+            warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+            watchOnly = true;\n         }\n \n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+        // Verify and process input data\n+        if (!watchOnly) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n+                }\n             }\n \n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);\n+                import_data = ImportData();\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript \" + strRedeemScript + \" as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript \" + witness_script_hex + \" as this is not a P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n+                }\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key \" + HexStr(pubkey.second.begin(), pubkey.second.end()) + \" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n+                }\n             }\n+        }\n \n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n \n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        // All good, time to import\n+        pwallet->MarkDirty();\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+            }\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (watchOnly || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for watchOnly, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (IsValidDestination(dest)) {\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n+        if (warnings.size()) result.pushKV(\"warnings\", warnings);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 414,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "b4cc694759a6911f8932a5a6f30eb28fc122a680",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Probably needs an RPC example:\r\n<img width=\"909\" alt=\"schermafbeelding 2018-10-26 om 13 30 19\" src=\"https://user-images.githubusercontent.com/10217/47546368-89931280-d923-11e8-89e6-811162e6580b.png\">\r\n",
    "created_at": "2018-10-26T05:32:19Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228409405",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228409405"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228409405"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228409405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1097,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228410472",
    "pull_request_review_id": 168674842,
    "id": 228410472,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODQxMDQ3Mg==",
    "diff_hunk": "@@ -840,195 +920,144 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": 119,
    "original_position": 110,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "f96edc357f0499f581d3baf66871c8b43b245d89",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The rename and comments help. Still `ProcessImport` is fairly large with lots of `if` branches and loops, so splitting it into multiple functions would help. The first function could be `prepare_import_data`, the second `verify_and_import_data` which calls `RecurseImportData` and then a third `add_to_wallet`. Not sure if they can be cleanly disentangled. Maybe some other time. ",
    "created_at": "2018-10-26T05:41:27Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228410472",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228410472"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228410472"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228410472/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 964,
    "original_line": 964,
    "side": "RIGHT",
    "in_reply_to_id": 228051747
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228423720",
    "pull_request_review_id": 168693463,
    "id": 228423720,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyODQyMzcyMA==",
    "diff_hunk": "@@ -805,36 +805,115 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::WITNESS_V0);\n+        break;\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the full script imported\n+        break;\n+    }\n+    default:",
    "path": "src/wallet/rpcdump.cpp",
    "position": 86,
    "original_position": 84,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6341c592422632d6d3c84bae1cc2db2664232165",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: Also handle `TX_NONSTANDARD`, `TX_NULL_DATA` and `TX_WITNESS_UNKNOWN` explicitly to make it exhaustive? That will allow for `-Wswitch-enum` :-)",
    "created_at": "2018-10-26T07:04:58Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228423720",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228423720"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r228423720"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/228423720/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 921,
    "original_line": 921,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811053",
    "pull_request_review_id": 171627127,
    "id": 230811053,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxMTA1Mw==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 27,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "please make `ctx` constant",
    "created_at": "2018-11-05T16:13:22Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230811053",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811053"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230811053"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 830,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811453",
    "pull_request_review_id": 171627127,
    "id": 230811453,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxMTQ1Mw==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 27,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: s/data/import_data/g, lots of \"data\" in this chunk of code already e.g., `solverdata`",
    "created_at": "2018-11-05T16:14:19Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230811453",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811453"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230811453"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230811453/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 830,
    "side": "RIGHT",
    "in_reply_to_id": 230811053
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812463",
    "pull_request_review_id": 171627127,
    "id": 230812463,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxMjQ2Mw==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 15,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "munit: \"... for solveability\"? ",
    "created_at": "2018-11-05T16:16:43Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230812463",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812463"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230812463"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812463/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 818,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812909",
    "pull_request_review_id": 171627127,
    "id": 230812909,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxMjkwOQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 27,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: s/ctx/script_ctx/ , to directly link it to `script`",
    "created_at": "2018-11-05T16:17:48Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230812909",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812909"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230812909"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230812909/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 830,
    "side": "RIGHT",
    "in_reply_to_id": 230811053
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230813869",
    "pull_request_review_id": 171627127,
    "id": 230813869,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxMzg2OQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 47,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "might as well assert that it's `ctx == TOP`",
    "created_at": "2018-11-05T16:19:47Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230813869",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230813869"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230813869"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230813869/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 850,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814669",
    "pull_request_review_id": 171627127,
    "id": 230814669,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxNDY2OQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": 66,
    "original_position": 70,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "note for self: check if we're checking this error",
    "created_at": "2018-11-05T16:21:34Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230814669",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814669"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230814669"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814669/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 901,
    "original_line": 901,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814787",
    "pull_request_review_id": 171627127,
    "id": 230814787,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxNDc4Nw==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": 48,
    "original_position": 51,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "note for self: check if we're checking this error",
    "created_at": "2018-11-05T16:21:48Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230814787",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814787"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230814787"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230814787/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 883,
    "original_line": 883,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230818405",
    "pull_request_review_id": 171627127,
    "id": 230818405,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgxODQwNQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 71,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: s/full/ full TOP/",
    "created_at": "2018-11-05T16:30:12Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230818405",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230818405"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230818405"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230818405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 874,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821010",
    "pull_request_review_id": 171627127,
    "id": 230821010,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgyMTAxMA==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        // Warn about inconsistencies between watchonly and provided keys/scripts\n+        UniValue warnings(UniValue::VARR);\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (watchOnly && have_solving_data) {\n+            warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 295,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "note: the privkey check happens at https://github.com/bitcoin/bitcoin/pull/14565/commits/10a26e9f3826f162a0b04dad62f029c78e53c42b#diff-522490d83dce5375d423b23886e4125eR976 already",
    "created_at": "2018-11-05T16:36:27Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230821010",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821010"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230821010"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821010/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 984,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821181",
    "pull_request_review_id": 171627127,
    "id": 230821181,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgyMTE4MQ==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 283,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this check subsumed by https://github.com/bitcoin/bitcoin/pull/14565/commits/10a26e9f3826f162a0b04dad62f029c78e53c42b#diff-522490d83dce5375d423b23886e4125eR983 ?",
    "created_at": "2018-11-05T16:36:44Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230821181",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821181"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230821181"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230821181/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 997,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230823123",
    "pull_request_review_id": 171627127,
    "id": 230823123,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDgyMzEyMw==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        // Warn about inconsistencies between watchonly and provided keys/scripts\n+        UniValue warnings(UniValue::VARR);\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (watchOnly && have_solving_data) {\n+            warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n         }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        if (!watchOnly && !have_solving_data) {\n+            warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+            watchOnly = true;\n         }\n \n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+        // Verify and process input data\n+        if (!watchOnly) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n+                }\n             }\n \n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 348,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`s/::/:/`",
    "created_at": "2018-11-05T16:41:23Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230823123",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230823123"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r230823123"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230823123/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1016,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231668340",
    "pull_request_review_id": 172688369,
    "id": 231668340,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTY2ODM0MA==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 11,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Instead of a `std::set`, could `std::vector` be used for these in order to preserve the order in which things will be imported? This is useful for #14075 where we want to have the order in which things are added to the wallet be the order that was specified in the import.",
    "created_at": "2018-11-07T20:39:05Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231668340",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231668340"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231668340"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231668340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 846,
    "original_line": 846,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231693179",
    "pull_request_review_id": 172719518,
    "id": 231693179,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTY5MzE3OQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 11,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "A few more changes would be required, see a fairly minimal change set(I made vectors of all the sets): https://gist.github.com/instagibbs/bd11e8666d929d84e4abc2214962e752",
    "created_at": "2018-11-07T21:58:17Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231693179",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231693179"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231693179"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231693179/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 846,
    "original_line": 846,
    "side": "RIGHT",
    "in_reply_to_id": 231668340
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231967853",
    "pull_request_review_id": 173054770,
    "id": 231967853,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTk2Nzg1Mw==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 11,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This has been implemented in #14075 as that is where this behavior is desired.",
    "created_at": "2018-11-08T16:33:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231967853",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231967853"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231967853"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231967853/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 846,
    "original_line": 846,
    "side": "RIGHT",
    "in_reply_to_id": 231668340
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231973774",
    "pull_request_review_id": 173061040,
    "id": 231973774,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTk3Mzc3NA==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 11,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think it's always desired, particularly when someone imports private keys, as those would get added to the keypool in order of their occurrence in the wallet IIUC.\r\n\r\nBut if it's an existing \"feature\" then of course it's fine to change in it in the other PR.",
    "created_at": "2018-11-08T16:44:26Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231973774",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231973774"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r231973774"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231973774/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 846,
    "original_line": 846,
    "side": "RIGHT",
    "in_reply_to_id": 231668340
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232121900",
    "pull_request_review_id": 173248613,
    "id": 232121900,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEyMTkwMA==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 283,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This one is an error, as it's always been there. The other one is just a warning (I'd very much like to make it all errors, but I fear about breaking compatibility).",
    "created_at": "2018-11-09T01:51:22Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232121900",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232121900"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232121900"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232121900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 997,
    "side": "RIGHT",
    "in_reply_to_id": 230821181
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232122136",
    "pull_request_review_id": 173248916,
    "id": 232122136,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEyMjEzNg==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 11,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "33855fec46dbc3a7cad76875ca2a7660fcc19e92",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "@Sjors As of this PR, there is no reason for doing so as we can't import into the keypool yet. Follow-ups can add the ordering.",
    "created_at": "2018-11-09T01:53:19Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232122136",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232122136"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232122136"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232122136/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 846,
    "original_line": 846,
    "side": "RIGHT",
    "in_reply_to_id": 231668340
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133646",
    "pull_request_review_id": 173263088,
    "id": 232133646,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzY0Ng==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 27,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done, done, done.",
    "created_at": "2018-11-09T03:24:20Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133646",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133646"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133646"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133646/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 830,
    "side": "RIGHT",
    "in_reply_to_id": 230811053
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133671",
    "pull_request_review_id": 173263120,
    "id": 232133671,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzY3MQ==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 15,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Reformulated.",
    "created_at": "2018-11-09T03:24:30Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133671",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133671"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133671"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133671/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 818,
    "side": "RIGHT",
    "in_reply_to_id": 230812463
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133683",
    "pull_request_review_id": 173263135,
    "id": 232133683,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzY4Mw==",
    "diff_hunk": "@@ -805,36 +805,115 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::WITNESS_V0);\n+        break;\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the full script imported\n+        break;\n+    }\n+    default:",
    "path": "src/wallet/rpcdump.cpp",
    "position": 86,
    "original_position": 84,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6341c592422632d6d3c84bae1cc2db2664232165",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T03:24:38Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133683",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133683"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133683"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133683/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 921,
    "original_line": 921,
    "side": "RIGHT",
    "in_reply_to_id": 228423720
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133699",
    "pull_request_review_id": 173263156,
    "id": 232133699,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzY5OQ==",
    "diff_hunk": "@@ -840,198 +924,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        // Warn about inconsistencies between watchonly and provided keys/scripts\n+        UniValue warnings(UniValue::VARR);\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (watchOnly && have_solving_data) {\n+            warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n         }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        if (!watchOnly && !have_solving_data) {\n+            warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+            watchOnly = true;\n         }\n \n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+        // Verify and process input data\n+        if (!watchOnly) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n+                }\n             }\n \n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);\n+                import_data = ImportData();\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript \" + strRedeemScript + \" as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript \" + witness_script_hex + \" as this is not a P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n+                }\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key \" + HexStr(pubkey.second.begin(), pubkey.second.end()) + \" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n+                }\n             }\n+        }\n \n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n \n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        // All good, time to import\n+        pwallet->MarkDirty();\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+            }\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (watchOnly || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for watchOnly, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (IsValidDestination(dest)) {\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n+        if (warnings.size()) result.pushKV(\"warnings\", warnings);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 414,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "b4cc694759a6911f8932a5a6f30eb28fc122a680",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T03:24:45Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133699",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133699"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133699"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133699/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1097,
    "side": "RIGHT",
    "in_reply_to_id": 228409405
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133712",
    "pull_request_review_id": 173263173,
    "id": 232133712,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzcxMg==",
    "diff_hunk": "@@ -805,6 +805,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 7,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "b4cc694759a6911f8932a5a6f30eb28fc122a680",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T03:24:50Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133712",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133712"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133712"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133712/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 810,
    "side": "RIGHT",
    "in_reply_to_id": 228408379
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133726",
    "pull_request_review_id": 173263191,
    "id": 232133726,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzcyNg==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 47,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T03:25:00Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133726",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133726"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133726"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133726/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 850,
    "side": "RIGHT",
    "in_reply_to_id": 230813869
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133750",
    "pull_request_review_id": 173263221,
    "id": 232133750,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzc1MA==",
    "diff_hunk": "@@ -804,6 +804,91 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 71,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Reformulated.",
    "created_at": "2018-11-09T03:25:11Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133750",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133750"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133750"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133750/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 874,
    "side": "RIGHT",
    "in_reply_to_id": 230818405
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133832",
    "pull_request_review_id": 173263325,
    "id": 232133832,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzgzMg==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 283,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Actually, I got rid of all this as I was mistaken about what \"watchonly\" meant; see further.",
    "created_at": "2018-11-09T03:25:54Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133832",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133832"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133832"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133832/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 997,
    "side": "RIGHT",
    "in_reply_to_id": 230821181
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133848",
    "pull_request_review_id": 173263344,
    "id": 232133848,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjEzMzg0OA==",
    "diff_hunk": "@@ -839,198 +923,160 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n-\n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n             }\n+            import_data.privkeys.emplace(id, key);\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        // Warn about inconsistencies between watchonly and provided keys/scripts\n+        UniValue warnings(UniValue::VARR);\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (watchOnly && have_solving_data) {\n+            warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n         }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        if (!watchOnly && !have_solving_data) {\n+            warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+            watchOnly = true;\n         }\n \n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+        // Verify and process input data\n+        if (!watchOnly) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n+                }\n             }\n \n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 348,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "10a26e9f3826f162a0b04dad62f029c78e53c42b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T03:26:02Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133848",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133848"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232133848"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232133848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1016,
    "side": "RIGHT",
    "in_reply_to_id": 230823123
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232171795",
    "pull_request_review_id": 173310321,
    "id": 232171795,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE3MTc5NQ==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 297,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: Could use `std::any_of`? :-)",
    "created_at": "2018-11-09T08:24:34Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232171795",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232171795"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232171795"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232171795/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1013,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328654",
    "pull_request_review_id": 173508269,
    "id": 232328654,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjMyODY1NA==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {\n+                if (import_data.privkeys.count(used_key) == 0) {\n+                    have_all_privkeys = false;\n+                    break;\n                 }\n+            }\n+            if (!have_all_privkeys && !watchOnly) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+                watchOnly = true;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 305,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "what does changing this do exactly? this variable is never used later.",
    "created_at": "2018-11-09T17:17:09Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232328654",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328654"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232328654"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328654/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1021,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328886",
    "pull_request_review_id": 173508556,
    "id": 232328886,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjMyODg4Ng==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {\n+                if (import_data.privkeys.count(used_key) == 0) {\n+                    have_all_privkeys = false;\n+                    break;\n                 }\n+            }\n+            if (!have_all_privkeys && !watchOnly) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+                watchOnly = true;\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for watchOnly, so that watch timestamp gets updated",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 411,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "old reference to `watchOnly` here",
    "created_at": "2018-11-09T17:17:55Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232328886",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328886"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232328886"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232328886/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1077,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384923",
    "pull_request_review_id": 173579456,
    "id": 232384923,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjM4NDkyMw==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 297,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-11-09T20:30:54Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232384923",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384923"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232384923"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384923/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1013,
    "side": "RIGHT",
    "in_reply_to_id": 232171795
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384947",
    "pull_request_review_id": 173579495,
    "id": 232384947,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjM4NDk0Nw==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {\n+                if (import_data.privkeys.count(used_key) == 0) {\n+                    have_all_privkeys = false;\n+                    break;\n                 }\n+            }\n+            if (!have_all_privkeys && !watchOnly) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+                watchOnly = true;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 305,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed.",
    "created_at": "2018-11-09T20:31:02Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232384947",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384947"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232384947"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232384947/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1021,
    "side": "RIGHT",
    "in_reply_to_id": 232328654
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232385340",
    "pull_request_review_id": 173580010,
    "id": 232385340,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjM4NTM0MA==",
    "diff_hunk": "@@ -839,198 +927,165 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool have_all_privkeys = true;\n+            for (const auto& used_key : import_data.used_keys) {\n+                if (import_data.privkeys.count(used_key) == 0) {\n+                    have_all_privkeys = false;\n+                    break;\n                 }\n+            }\n+            if (!have_all_privkeys && !watchOnly) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+                watchOnly = true;\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for watchOnly, so that watch timestamp gets updated",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 411,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6aab00f9622d4b077d95137302f066b8c0f3a761",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed (also made a change that sets have_solving_data to `false` when the solvability data is bad).",
    "created_at": "2018-11-09T20:32:38Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232385340",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232385340"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232385340"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232385340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1077,
    "side": "RIGHT",
    "in_reply_to_id": 232328886
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232534932",
    "pull_request_review_id": 173751879,
    "id": 232534932,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjUzNDkzMg==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This will still import the private keys provided, so I'm not 100% sure this message is clear, it may imply an all-or-nothingness with watchonly?",
    "created_at": "2018-11-12T04:57:26Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232534932",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232534932"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232534932"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232534932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232536910",
    "pull_request_review_id": 173754298,
    "id": 232536910,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjUzNjkxMA==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Any suggestion for an improved message?",
    "created_at": "2018-11-12T05:18:13Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232536910",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232536910"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232536910"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232536910/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT",
    "in_reply_to_id": 232534932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232537448",
    "pull_request_review_id": 173754847,
    "id": 232537448,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjUzNzQ0OA==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps \"Some private keys are missing, address will be considered watchonly\". Only a minor nit.",
    "created_at": "2018-11-12T05:22:16Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232537448",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232537448"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r232537448"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232537448/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT",
    "in_reply_to_id": 232534932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234254224",
    "pull_request_review_id": 175863241,
    "id": 234254224,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI1NDIyNA==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 25,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "spelling: accordingly",
    "created_at": "2018-11-16T15:54:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234254224",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234254224"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234254224"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234254224/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 843,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234256747",
    "pull_request_review_id": 175863241,
    "id": 234256747,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI1Njc0Nw==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 25,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Description is a bit vague. Would maybe say \"Analyse the provided `scriptPubKey`, determining which keys and which redeem scripts from the `ImportData` struct are needed to spend it, and mark them as used.\"",
    "created_at": "2018-11-16T16:01:01Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234256747",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234256747"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234256747"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234256747/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 843,
    "side": "RIGHT",
    "in_reply_to_id": 234254224
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234260710",
    "pull_request_review_id": 175863241,
    "id": 234260710,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI2MDcxMA==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What's the story with this IsMine rule? Was it a mistake for IsMine to require this, and we are now stuck with it so new wallets can remain compatible with old software? Or was there a reason for IsMine to require this (or is there a reason still)?",
    "created_at": "2018-11-16T16:12:17Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234260710",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234260710"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234260710"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234260710/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234265236",
    "pull_request_review_id": 175863241,
    "id": 234265236,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI2NTIzNg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 54,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Doesn't this need to return the value of RecurseImportData to avoid losing the error string?\r\n\r\nAlso, I think having a mix of breaks and returns here makes this function harder to follow. I think it'd be better if all the breaks were replaced by explicit returns, or if all returns were replaced with breaks (by assigning a `std::string ret` variable and returning it at the end).",
    "created_at": "2018-11-16T16:25:07Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234265236",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234265236"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234265236"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234265236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 872,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234271426",
    "pull_request_review_id": 175863241,
    "id": 234271426,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI3MTQyNg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 9,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why are `pubkeys` and `privkeys` struct members instead of freestanding variables in ProcessImport? It seems odd because the `RecurseImportData` function never touches them.",
    "created_at": "2018-11-16T16:42:10Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234271426",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234271426"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234271426"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234271426/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 827,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234278403",
    "pull_request_review_id": 175863241,
    "id": 234278403,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI3ODQwMw==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 392,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This seems like a change in behavior. It looks mapKeyMetadata was only set for previously for private keys, not public keys.\r\n\r\nCan you drop this line or add a comment about what effect it has? It seems like whatever effect it has might be temporary because AddWatchOnly() won't write this value to the database.",
    "created_at": "2018-11-16T17:02:39Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234278403",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234278403"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234278403"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234278403/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1079,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234282003",
    "pull_request_review_id": 175863241,
    "id": 234282003,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI4MjAwMw==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!internal) {\n+            assert(IsValidDestination(dest));\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n+        if (warnings.size()) result.pushKV(\"warnings\", warnings);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 410,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It might be nice to return warnings alongside errors in the exceptional cases below. You could do this by moving the `result` and `warnings` declarations above the try block, and moving `result.pushKV(\"warnings\")` and `return result` below.",
    "created_at": "2018-11-16T17:10:26Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234282003",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234282003"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234282003"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234282003/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1097,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234839776",
    "pull_request_review_id": 176567874,
    "id": 234839776,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgzOTc3Ng==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 25,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed, done.",
    "created_at": "2018-11-20T01:13:51Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234839776",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234839776"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234839776"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234839776/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 843,
    "side": "RIGHT",
    "in_reply_to_id": 234254224
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840153",
    "pull_request_review_id": 176568335,
    "id": 234840153,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDg0MDE1Mw==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There is a comment in script/ismine.cpp about this. It was necessary to prevent an attack before SegWit activation (where someone who owes you would be able to take (another) pubkey they knew was yours, construct a P2WPKH address for it, and pay you; the wallet would show it as an incoming payment, despite it being spendable by anyone before activation). It was a terrible hack, but a necessary one, and actually what motivated me to start working on the descriptors idea (which would let us make explicit what we treat as ours, rather than relying on what we can spend).",
    "created_at": "2018-11-20T01:16:13Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840153",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840153"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840153"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840153/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT",
    "in_reply_to_id": 234260710
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840212",
    "pull_request_review_id": 176568398,
    "id": 234840212,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDg0MDIxMg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 54,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good point. Fixed, and turned it all into returns.",
    "created_at": "2018-11-20T01:16:34Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840212",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840212"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840212"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 872,
    "side": "RIGHT",
    "in_reply_to_id": 234265236
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840336",
    "pull_request_review_id": 176568523,
    "id": 234840336,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDg0MDMzNg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 9,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oh, I wasn't even away they weren't being used (they were in an earlier version of this code). Moved them up to local variables.",
    "created_at": "2018-11-20T01:17:10Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840336",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840336"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840336"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840336/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 827,
    "side": "RIGHT",
    "in_reply_to_id": 234271426
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840465",
    "pull_request_review_id": 176568661,
    "id": 234840465,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDg0MDQ2NQ==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 392,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think this was a copy-paste error, mimicking the private key code where it was necessary. Fixed.",
    "created_at": "2018-11-20T01:17:57Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840465",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840465"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840465"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840465/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1079,
    "side": "RIGHT",
    "in_reply_to_id": 234278403
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840484",
    "pull_request_review_id": 176568680,
    "id": 234840484,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDg0MDQ4NA==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : import_data.privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (const auto& pubkey : import_data.pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // add to address book or update label\n-        if (IsValidDestination(scriptpubkey_dest)) {\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : import_data.privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : import_data.pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!internal) {\n+            assert(IsValidDestination(dest));\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n+        if (warnings.size()) result.pushKV(\"warnings\", warnings);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 410,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good idea, done.",
    "created_at": "2018-11-20T01:18:06Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840484",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840484"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234840484"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234840484/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1097,
    "side": "RIGHT",
    "in_reply_to_id": 234282003
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235079946",
    "pull_request_review_id": 176863814,
    "id": 235079946,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTA3OTk0Ng==",
    "diff_hunk": "@@ -854,211 +941,162 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 314,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6ce3bea4ffe579eaabcdecc3b686af29ac2527ab",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The warning says that the irrelevant private key will be ignored, but it looks like the private key will still be imported anyways.\r\n\r\nAlso, why exit this loop when an irrelevant private key is encountered?",
    "created_at": "2018-11-20T16:40:37Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235079946",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235079946"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235079946"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235079946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1037,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235080142",
    "pull_request_review_id": 176863814,
    "id": 235080142,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTA4MDE0Mg==",
    "diff_hunk": "@@ -854,211 +941,162 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n+                }\n+                for (const auto& pubkey : pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 319,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6ce3bea4ffe579eaabcdecc3b686af29ac2527ab",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Same thing as with the private keys, the pubkey will still be imported even when it is considered irrelevant.",
    "created_at": "2018-11-20T16:41:08Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235080142",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235080142"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235080142"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235080142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1046,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140823",
    "pull_request_review_id": 176939264,
    "id": 235140823,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTE0MDgyMw==",
    "diff_hunk": "@@ -854,211 +941,162 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 314,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6ce3bea4ffe579eaabcdecc3b686af29ac2527ab",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nice catch, fixed.",
    "created_at": "2018-11-20T19:32:56Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235140823",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140823"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235140823"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140823/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1037,
    "side": "RIGHT",
    "in_reply_to_id": 235079946
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140883",
    "pull_request_review_id": 176939326,
    "id": 235140883,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTE0MDg4Mw==",
    "diff_hunk": "@@ -854,211 +941,162 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (const auto& privkey : privkeys) {\n+                    if (import_data.used_keys.count(privkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        break;\n+                    }\n+                }\n+                for (const auto& pubkey : pubkeys) {\n+                    if (import_data.require_keys.count(pubkey.first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 319,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "6ce3bea4ffe579eaabcdecc3b686af29ac2527ab",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed.",
    "created_at": "2018-11-20T19:33:04Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235140883",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140883"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r235140883"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235140883/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1046,
    "side": "RIGHT",
    "in_reply_to_id": 235080142
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236898632",
    "pull_request_review_id": 179073149,
    "id": 236898632,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNjg5ODYzMg==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 142,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could move these declarations below closer to where they are used. This would prevent adding code that tries to use them before they are initialized.",
    "created_at": "2018-11-28T00:17:49Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r236898632",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236898632"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r236898632"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236898632/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 953,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236899461",
    "pull_request_review_id": 179073149,
    "id": 236899461,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNjg5OTQ2MQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 142,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Might be good to name this `pubkey_map` to distinguish it from the `pubKey` variable. Or could rename the other variable.",
    "created_at": "2018-11-28T00:22:36Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r236899461",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236899461"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r236899461"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236899461/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 953,
    "side": "RIGHT",
    "in_reply_to_id": 236898632
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237209285",
    "pull_request_review_id": 179073149,
    "id": 237209285,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzIwOTI4NQ==",
    "diff_hunk": "@@ -207,25 +207,6 @@ def run_test (self):\n         assert_equal(result[0]['error']['code'], -4)\n         assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n \n-        # Address + Private key + watchonly\n-        self.log.info(\"Should not import an address with private key and with watchonly\")",
    "path": "test/functional/wallet_importmulti.py",
    "position": 48,
    "original_position": 5,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "61b3f37ea2e1b16ac8829e752bdad5871706773a",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would it be better to check for unused private key warnings instead of dropping these test cases entirely?",
    "created_at": "2018-11-28T18:35:14Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r237209285",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237209285"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r237209285"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237209285/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 287,
    "original_line": 287,
    "side": "LEFT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237232263",
    "pull_request_review_id": 179073149,
    "id": 237232263,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzIzMjI2Mw==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think it'd be good to mention that `require_keys` is a subset of `used_keys`. Could also choose a more normalized representation like `std::map<CKeyID, bool /* required */> used_keys`.",
    "created_at": "2018-11-28T19:40:39Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r237232263",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237232263"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r237232263"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237232263/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 831,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238407103",
    "pull_request_review_id": 180941606,
    "id": 238407103,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQwNzEwMw==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 217,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can you add the pubkey to the error message? (multiple pubkeys can be given in a request, and this error doesn't indicate which one is invalid).\r\n\r\nSame comment for other pubkey and privkey errors below.",
    "created_at": "2018-12-03T19:33:37Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238407103",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238407103"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238407103"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238407103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 972,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238408053",
    "pull_request_review_id": 180941606,
    "id": 238408053,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQwODA1Mw==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 251,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It's not obvious from the help text that both private and public keys shouldn't be given. Can you update the help text to indicate that's an error?",
    "created_at": "2018-12-03T19:36:12Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238408053",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238408053"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238408053"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238408053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 990,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238416989",
    "pull_request_review_id": 180941606,
    "id": 238416989,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQxNjk4OQ==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 69,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This comment is a bit confusing, since the `emplace` will be called on `script` even if this is P2SH-P2WSH, but it'll be a no-op since `emplace(*subscript)` was already called in the outer run through `RecurseImportData()`. I think it may be clearer to either make that explicit in this comment or only call this emplace if `script_ctx == ScriptContext::TOP`.",
    "created_at": "2018-12-03T20:02:26Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238416989",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238416989"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238416989"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238416989/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238417816",
    "pull_request_review_id": 180941606,
    "id": 238417816,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQxNzgxNg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can you include a reference to the `script.cpp` comment here, so future readers of this code understand why this is required?",
    "created_at": "2018-12-03T20:04:57Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238417816",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238417816"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238417816"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238417816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT",
    "in_reply_to_id": 234260710
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238419596",
    "pull_request_review_id": 180941606,
    "id": 238419596,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQxOTU5Ng==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported\n+        return \"\";\n+    }\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+        return \"unrecognized script\";\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    }\n+    return \"\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 87,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "assert? We should never drop through to here.",
    "created_at": "2018-12-03T20:10:49Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238419596",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238419596"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238419596"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238419596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 905,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238422419",
    "pull_request_review_id": 180941606,
    "id": 238422419,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQyMjQxOQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 298,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't understand why this is just a warning, rather than causing the import to fail. The client has asked to import a script/address as not watchonly but hasn't provided the keys - shouldn't we fail (and make the client import with watchonly set and no privkeys provided if they want to import as watchonly)?\r\n\r\nEDIT: I see your earlier comment:\r\n\r\n> Perhaps we want to introduce a new mode where all these warnings become errors, though -deprecatedrpc, but let's discuss that in a separate RPC.\r\n\r\nMy preference would be for all of these things to cause the import to fail by default, but we can save that for a future PR.",
    "created_at": "2018-12-03T20:20:12Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238422419",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238422419"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238422419"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238422419/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238428932",
    "pull_request_review_id": 180941606,
    "id": 238428932,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQyODkzMg==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 394,
    "original_position": 387,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Is there a good reason that the key's createtime metadata is updated *before* adding the key to the wallet?",
    "created_at": "2018-12-03T20:41:52Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238428932",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238428932"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238428932"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238428932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1088,
    "original_line": 1088,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238438618",
    "pull_request_review_id": 180941606,
    "id": 238438618,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQzODYxOA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 397,
    "original_position": 389,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think the error messages in all these throws could be improved. Here, for example, the error text could be:\r\n\r\n```\r\nthrow JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Script import failed due to problem importing private key %s.\", EncodeSecret(key));\r\n```\r\n\r\nAs it is, it's not clear that failing to import this key also causes the script to not be imported. Same comment for failures to import pubkey below.\r\n\r\nIt's a bit of a shame that this operation isn't atomic and failing to import one key or script will result in the prior keys being imported but the following keys not being imported. Might be worth adding a comment somewhere to highlight that?",
    "created_at": "2018-12-03T21:11:31Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238438618",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238438618"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238438618"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238438618/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1091,
    "original_line": 1091,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238439489",
    "pull_request_review_id": 180941606,
    "id": 238439489,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQzOTQ4OQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 407,
    "original_position": 399,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Same comment as above about making the impact of this error clearer. Also perhaps change to 'error adding Pay-to-pubkey script for pubkey %s')",
    "created_at": "2018-12-03T21:14:00Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238439489",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238439489"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238439489"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238439489/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1100,
    "original_line": 1100,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238440785",
    "pull_request_review_id": 180941606,
    "id": 238440785,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODQ0MDc4NQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!internal) {\n+            assert(IsValidDestination(dest));\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n-        return result;\n     } catch (const UniValue& e) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n         result.pushKV(\"error\", e);\n-        return result;\n     } catch (...) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n+\n         result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));",
    "path": "src/wallet/rpcdump.cpp",
    "position": 432,
    "original_position": 424,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't understand where this error text \"Missing required fields\" comes from? It's also not very helpful for the client (which fields were missing?)",
    "created_at": "2018-12-03T21:18:07Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238440785",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238440785"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238440785"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238440785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1120,
    "original_line": 1120,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238814043",
    "pull_request_review_id": 181448833,
    "id": 238814043,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODgxNDA0Mw==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why was this check removed? Now it looks like if you provide a private key but set watchonly to true, it will still import that private key?",
    "created_at": "2018-12-04T19:52:51Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238814043",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238814043"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238814043"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238814043/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238820386",
    "pull_request_review_id": 181456817,
    "id": 238820386,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODgyMDM4Ng==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes, how else would you import a private key for something you don't have all keys for? The old behavior was bogus.\n\nI think I explained it elsewhere in this PR, but the intended behavior of watchonly is \"import this, even though I don't have *all* the relevant keys\". It wasn't supposed to prevent importing any keys at all.",
    "created_at": "2018-12-04T20:11:31Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238820386",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238820386"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238820386"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238820386/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238836988",
    "pull_request_review_id": 181477503,
    "id": 238836988,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODgzNjk4OA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 394,
    "original_position": 387,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Is there a good reason that the key's createtime metadata is updated before adding the key to the wallet?\r\n\r\nIt would be good to add a comment, but the map needs to be updated before calling AddKeyPubKey, because AddKeyPubKey uses it here: https://github.com/bitcoin/bitcoin/blob/86ff0413bb8f8173d3b3a1987875ff40b1094926/src/wallet/wallet.cpp#L291\r\n\r\nA good cleanup would be to drop this line and instead pass the time as an argument to AddKeyPubKey, the same way it is passed as an argument to AddWatchOnly below.\r\n ",
    "created_at": "2018-12-04T21:02:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238836988",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238836988"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238836988"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238836988/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1088,
    "original_line": 1088,
    "side": "RIGHT",
    "in_reply_to_id": 238428932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238878599",
    "pull_request_review_id": 181529157,
    "id": 238878599,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODg3ODU5OQ==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "For members, doxygen uses `//!<`\r\nhttp://www.doxygen.nl/manual/docblocks.html#memberdoc",
    "created_at": "2018-12-04T23:22:18Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238878599",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238878599"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238878599"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238878599/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 826,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238879474",
    "pull_request_review_id": 181530180,
    "id": 238879474,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODg3OTQ3NA==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported\n+        return \"\";\n+    }\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+        return \"unrecognized script\";\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    }\n+    return \"\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 87,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think there's a compiler check against missing cases in switch statement, which would be a good reason to assert.",
    "created_at": "2018-12-04T23:26:08Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238879474",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238879474"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238879474"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238879474/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 905,
    "side": "RIGHT",
    "in_reply_to_id": 238419596
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239000762",
    "pull_request_review_id": 181675650,
    "id": 239000762,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTAwMDc2Mg==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Ah, so now the only point of the watchonly parameter is to be explicit so we don't get a warning thrown",
    "created_at": "2018-12-05T10:06:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239000762",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239000762"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239000762"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239000762/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239573986",
    "pull_request_review_id": 182396441,
    "id": 239573986,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTU3Mzk4Ng==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think the RPC help text for `watchonly` needs to be updated. It's currently `Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty`.",
    "created_at": "2018-12-06T19:00:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239573986",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239573986"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239573986"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239573986/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239587718",
    "pull_request_review_id": 182414062,
    "id": 239587718,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTU4NzcxOA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "re: https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239573986\r\n\r\n> I think the RPC help text for watchonly needs to be updated.\r\n\r\nI suggested one possible update in https://github.com/bitcoin/bitcoin/pull/14565#pullrequestreview-179073149:\r\n\r\n> I think the documentation would be clearer if it just said that \"watchonly\" has no actual effect on the import, and only disables a warning if there are missing private keys.\r\n",
    "created_at": "2018-12-06T19:41:32Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239587718",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239587718"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r239587718"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239587718/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240810431",
    "pull_request_review_id": 183928150,
    "id": 240810431,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDgxMDQzMQ==",
    "diff_hunk": "@@ -207,25 +207,6 @@ def run_test (self):\n         assert_equal(result[0]['error']['code'], -4)\n         assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n \n-        # Address + Private key + watchonly\n-        self.log.info(\"Should not import an address with private key and with watchonly\")",
    "path": "test/functional/wallet_importmulti.py",
    "position": 48,
    "original_position": 5,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "61b3f37ea2e1b16ac8829e752bdad5871706773a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes, the tests need updating (which I think others are working on now, I'm not entirely up to date).",
    "created_at": "2018-12-11T22:09:46Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240810431",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240810431"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240810431"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240810431/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 287,
    "original_line": 287,
    "side": "LEFT",
    "in_reply_to_id": 237209285
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841747",
    "pull_request_review_id": 183965486,
    "id": 240841747,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MTc0Nw==",
    "diff_hunk": "@@ -839,198 +927,159 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        UniValue warnings(UniValue::VARR);\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+        }\n+        if (witness_script_hex.size()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (import_data.pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                import_data.pubkeys.erase(id);\n             }\n+            import_data.privkeys.emplace(id, key);\n+        }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Watchonly and private keys\n+        if (watchOnly && import_data.privkeys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return import_data.privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-12-12T00:17:45Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841747",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841747"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841747"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841747/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT",
    "in_reply_to_id": 232534932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841772",
    "pull_request_review_id": 183965521,
    "id": 240841772,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MTc3Mg==",
    "diff_hunk": "@@ -804,6 +804,95 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "3ce71a03fbf15482a4b341231b520748c9236634",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-12-12T00:17:54Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841772",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841772"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841772"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT",
    "in_reply_to_id": 234260710
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841833",
    "pull_request_review_id": 183965601,
    "id": 240841833,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MTgzMw==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 142,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done. Same with `privkey_map` for consistency.",
    "created_at": "2018-12-12T00:18:18Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841833",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841833"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841833"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 953,
    "side": "RIGHT",
    "in_reply_to_id": 236898632
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841872",
    "pull_request_review_id": 183965652,
    "id": 240841872,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MTg3Mg==",
    "diff_hunk": "@@ -207,25 +207,6 @@ def run_test (self):\n         assert_equal(result[0]['error']['code'], -4)\n         assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n \n-        # Address + Private key + watchonly\n-        self.log.info(\"Should not import an address with private key and with watchonly\")",
    "path": "test/functional/wallet_importmulti.py",
    "position": 48,
    "original_position": 5,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "61b3f37ea2e1b16ac8829e752bdad5871706773a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Ok, reverted this change.",
    "created_at": "2018-12-12T00:18:34Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841872",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841872"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841872"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841872/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 287,
    "original_line": 287,
    "side": "LEFT",
    "in_reply_to_id": 237209285
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841919",
    "pull_request_review_id": 183965705,
    "id": 240841919,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MTkxOQ==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 13,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-12-12T00:18:46Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841919",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841919"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240841919"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240841919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 831,
    "side": "RIGHT",
    "in_reply_to_id": 237232263
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842118",
    "pull_request_review_id": 183965949,
    "id": 240842118,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjExOA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 217,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done. I thought about doing this before but worried it would complicate writing tests. Since you've volunteered to help out with that, I don't assume that'll be a problem :p",
    "created_at": "2018-12-12T00:19:54Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842118",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842118"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842118"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842118/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 972,
    "side": "RIGHT",
    "in_reply_to_id": 238407103
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842156",
    "pull_request_review_id": 183965992,
    "id": 240842156,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjE1Ng==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 69,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good idea, done.",
    "created_at": "2018-12-12T00:20:05Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842156",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842156"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842156"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842156/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 887,
    "side": "RIGHT",
    "in_reply_to_id": 238416989
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842233",
    "pull_request_review_id": 183966084,
    "id": 240842233,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjIzMw==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 251,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I realized that there is very little reason for forbidding this (or even warning about it). I just removed the warning.",
    "created_at": "2018-12-12T00:20:28Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842233",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842233"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842233"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 990,
    "side": "RIGHT",
    "in_reply_to_id": 238408053
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842363",
    "pull_request_review_id": 183966238,
    "id": 240842363,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjM2Mw==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // These public keys are required for solvability\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID());\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID());\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.require_keys.emplace(id);\n+        import_data.used_keys.emplace(id);\n+        import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported\n+        return \"\";\n+    }\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+        return \"unrecognized script\";\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    }\n+    return \"\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 87,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I wish there was a way to tell the compiler \"Generate a warning if you can't prove this code is unreachable\", but an assert in this case seems not worth the risk.",
    "created_at": "2018-12-12T00:21:14Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842363",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842363"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842363"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842363/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 905,
    "side": "RIGHT",
    "in_reply_to_id": 238419596
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842671",
    "pull_request_review_id": 183966564,
    "id": 240842671,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjY3MQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 298,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "@jnewbery If designing from scratch, I absolutely agree - but I'm afraid this would be a far too invasive compatibility break. That compatibility concern was the reason for introducing a warnings field in the first place.",
    "created_at": "2018-12-12T00:22:37Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842671",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842671"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842671"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842671/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1023,
    "side": "RIGHT",
    "in_reply_to_id": 238422419
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842724",
    "pull_request_review_id": 183966633,
    "id": 240842724,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjcyNA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 394,
    "original_position": 387,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Let's leave this for later.",
    "created_at": "2018-12-12T00:22:55Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842724",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842724"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842724"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842724/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1088,
    "original_line": 1088,
    "side": "RIGHT",
    "in_reply_to_id": 238428932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842835",
    "pull_request_review_id": 183966764,
    "id": 240842835,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MjgzNQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 397,
    "original_position": 389,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This sort of failure can only occur when there is an I/O error or so, I'm not sure we can do much about it.",
    "created_at": "2018-12-12T00:23:33Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842835",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842835"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842835"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842835/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1091,
    "original_line": 1091,
    "side": "RIGHT",
    "in_reply_to_id": 238438618
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842884",
    "pull_request_review_id": 183966826,
    "id": 240842884,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0Mjg4NA==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkeys) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!internal) {\n+            assert(IsValidDestination(dest));\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n-        return result;\n     } catch (const UniValue& e) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n         result.pushKV(\"error\", e);\n-        return result;\n     } catch (...) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n+\n         result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));",
    "path": "src/wallet/rpcdump.cpp",
    "position": 432,
    "original_position": 424,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't understand either, I haven't touched it.",
    "created_at": "2018-12-12T00:23:49Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842884",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842884"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842884"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842884/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1120,
    "original_line": 1120,
    "side": "RIGHT",
    "in_reply_to_id": 238440785
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842941",
    "pull_request_review_id": 183966889,
    "id": 240842941,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0Mjk0MQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I've made some help text changes.",
    "created_at": "2018-12-12T00:24:06Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842941",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842941"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240842941"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240842941/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240843013",
    "pull_request_review_id": 183966977,
    "id": 240843013,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0MzAxMw==",
    "diff_hunk": "@@ -819,9 +819,97 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed.",
    "created_at": "2018-12-12T00:24:28Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240843013",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240843013"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240843013"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240843013/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 826,
    "side": "RIGHT",
    "in_reply_to_id": 238878599
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240846519",
    "pull_request_review_id": 183971085,
    "id": 240846519,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDg0NjUxOQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 126,
    "original_position": 120,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'd rather not say it's just disabling a warning, as it may change to a failure later.",
    "created_at": "2018-12-12T00:43:00Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240846519",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240846519"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r240846519"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240846519/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 884,
    "original_line": 884,
    "side": "LEFT",
    "in_reply_to_id": 238814043
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241003870",
    "pull_request_review_id": 184164546,
    "id": 241003870,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTAwMzg3MA==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 46,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Suggested comment (above, and in `TX_WITNESS_V0_SCRIPTHASH`):\r\n```\r\n// Remove redeemscript from import_data to check for superfluous script later.\r\n```",
    "created_at": "2018-12-12T12:59:56Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241003870",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241003870"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241003870"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241003870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 881,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241017930",
    "pull_request_review_id": 184164546,
    "id": 241017930,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTAxNzkzMA==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 38,
    "original_position": 38,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why are you not using `emplace()` here like with `TX_PUBKEY`?",
    "created_at": "2018-12-12T13:43:28Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241017930",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241017930"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241017930"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241017930/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 873,
    "original_line": 873,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241044001",
    "pull_request_review_id": 184164546,
    "id": 241044001,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTA0NDAwMQ==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 394,
    "original_position": 387,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Isn't it safer to only update `mapKeyMetadata[id].nCreateTime` if `timestamp` is older than the current value? Otherwise what if:\r\n* a user adds a private key to an existing public key, which they already used\r\n* they set `\"timestamp\": \"now\"`\r\n* after import they do `bitcoind -zapwallettxes` and then rescan\r\nIn that case, would rescan pick it up anyway regardless of `nCreateTime` because it starts at genesis block?  ",
    "created_at": "2018-12-12T14:51:15Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241044001",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241044001"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241044001"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241044001/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1088,
    "original_line": 1088,
    "side": "RIGHT",
    "in_reply_to_id": 238428932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241048130",
    "pull_request_review_id": 184164546,
    "id": 241048130,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTA0ODEzMA==",
    "diff_hunk": "@@ -860,222 +949,177 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-            }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkey_map) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": 396,
    "original_position": 395,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Suggested comment (above), because `HaveKey` is an ambiguous function name:\r\n```\r\n// If the private key is not present in the wallet, insert it or add it to an existing public key.\r\n```",
    "created_at": "2018-12-12T15:00:12Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241048130",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241048130"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241048130"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241048130/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1090,
    "original_line": 1090,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241051227",
    "pull_request_review_id": 184225036,
    "id": 241051227,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTA1MTIyNw==",
    "diff_hunk": "@@ -0,0 +1,5 @@\n+Low-level RPC changes\n+---------------------\n+\n+The `importmulti` RPC will now contain a new `warnings` field with strings",
    "path": "doc/release-notes-14565.md",
    "position": null,
    "original_position": 4,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit, could say:\r\n - it's per request result\r\n - it's not present if there are no warnings",
    "created_at": "2018-12-12T15:07:57Z",
    "updated_at": "2018-12-13T00:37:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241051227",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241051227"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241051227"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241051227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241052825",
    "pull_request_review_id": 184225036,
    "id": 241052825,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTA1MjgyNQ==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": 24,
    "original_position": 24,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "IMO could do better than empty string as success \u2014 despite the fact that it works.\r\n\r\nAlternatives:\r\n- could return `std::pair<bool, std::string>`\r\n- could have return `bool` and add argument `std::string& error`",
    "created_at": "2018-12-12T15:11:52Z",
    "updated_at": "2018-12-13T00:37:05Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241052825",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241052825"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241052825"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241052825/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 859,
    "original_line": 859,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241229980",
    "pull_request_review_id": 184451222,
    "id": 241229980,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIyOTk4MA==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 38,
    "original_position": 38,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`emplace()` doesn't overwrite the entry if it already exists (which could possible leave it with required=false).",
    "created_at": "2018-12-12T23:59:54Z",
    "updated_at": "2018-12-13T00:37:05Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241229980",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241229980"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241229980"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241229980/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 873,
    "original_line": 873,
    "side": "RIGHT",
    "in_reply_to_id": 241017930
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241234157",
    "pull_request_review_id": 184456302,
    "id": 241234157,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIzNDE1Nw==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)",
    "path": "src/wallet/rpcdump.cpp",
    "position": 24,
    "original_position": 24,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Both of these options result in uglier code, I think.",
    "created_at": "2018-12-13T00:22:59Z",
    "updated_at": "2018-12-13T00:37:05Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241234157",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241234157"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241234157"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241234157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 859,
    "original_line": 859,
    "side": "RIGHT",
    "in_reply_to_id": 241052825
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241236822",
    "pull_request_review_id": 184459499,
    "id": 241236822,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIzNjgyMg==",
    "diff_hunk": "@@ -0,0 +1,5 @@\n+Low-level RPC changes\n+---------------------\n+\n+The `importmulti` RPC will now contain a new `warnings` field with strings",
    "path": "doc/release-notes-14565.md",
    "position": null,
    "original_position": 4,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-12-13T00:37:19Z",
    "updated_at": "2018-12-13T00:37:19Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241236822",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241236822"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241236822"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241236822/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4,
    "side": "RIGHT",
    "in_reply_to_id": 241051227
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237035",
    "pull_request_review_id": 184459775,
    "id": 241237035,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIzNzAzNQ==",
    "diff_hunk": "@@ -860,222 +949,177 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-            }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkey_map) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {",
    "path": "src/wallet/rpcdump.cpp",
    "position": 396,
    "original_position": 395,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There isn't such a thing as \"adding it to an existing public key\", private and public keys are pretty much unrelated in every way in the wallet (the former is needed for signing and affects spendability; the latter is needed just to recurse into PKH/WPKH and not anything else). I've added some of the test you suggest, but dropped the pubkey part.",
    "created_at": "2018-12-13T00:38:41Z",
    "updated_at": "2018-12-13T00:38:41Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241237035",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237035"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241237035"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237035/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1090,
    "original_line": 1090,
    "side": "RIGHT",
    "in_reply_to_id": 241048130
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237069",
    "pull_request_review_id": 184459822,
    "id": 241237069,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIzNzA2OQ==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);",
    "path": "src/wallet/rpcdump.cpp",
    "position": null,
    "original_position": 46,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "d6f2b340128c66251cbdf49fa7180ad9f703e4cb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-12-13T00:38:53Z",
    "updated_at": "2018-12-13T00:38:53Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241237069",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237069"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241237069"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241237069/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 881,
    "side": "RIGHT",
    "in_reply_to_id": 241003870
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241238436",
    "pull_request_review_id": 184461536,
    "id": 241238436,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTIzODQzNg==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-            }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkey_map) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            // If the private key is not present in the wallet, insert it.\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkey_map) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 404,
    "original_position": 404,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Do we also need to update `mapKeyMetadata` here to include the timestamp?",
    "created_at": "2018-12-13T00:47:18Z",
    "updated_at": "2018-12-13T00:47:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241238436",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241238436"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241238436"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241238436/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1097,
    "original_line": 1097,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241872742",
    "pull_request_review_id": 185262357,
    "id": 241872742,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTg3Mjc0Mg==",
    "diff_hunk": "@@ -119,9 +119,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']\n+        assert_equal(\"\\n\".join(sorted(warnings)), \"\\n\".join(sorted(observed_warnings)))",
    "path": "test/functional/wallet_importmulti.py",
    "position": 11,
    "original_position": 11,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "are the `\"\\n\".join` adding anything here?\r\n\r\nPresumably `\"\\n\".join(list1) == \"\\n\".join(list2)` \u21d4 `list1 == list2`?",
    "created_at": "2018-12-14T19:56:35Z",
    "updated_at": "2018-12-20T00:09:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241872742",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241872742"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241872742"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241872742/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 128,
    "original_line": 128,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876095",
    "pull_request_review_id": 185262357,
    "id": 241876095,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTg3NjA5NQ==",
    "diff_hunk": "@@ -398,75 +408,78 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n-                              False,\n-                              error_code=-8,\n-                              error_message='Watch-only addresses should not include private keys')\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          solvable=True,\n+                          timestamp=timestamp)\n \n         # Address + Public key + !Internal + Wrong pubkey\n-        self.log.info(\"Should not import an address with a wrong public key\")\n+        self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                              True,\n+                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n-        self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n+        self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                              True,\n+                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # Address + Private key + !watchonly + Wrong private key\n-        self.log.info(\"Should not import an address with a wrong private key\")\n+        self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                               True,",
    "path": "test/functional/wallet_importmulti.py",
    "position": 169,
    "original_position": 169,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: misaligned, please remove space",
    "created_at": "2018-12-14T20:10:04Z",
    "updated_at": "2018-12-20T00:09:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241876095",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876095"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241876095"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876095/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 459,
    "original_line": 459,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876155",
    "pull_request_review_id": 185262357,
    "id": 241876155,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTg3NjE1NQ==",
    "diff_hunk": "@@ -591,14 +606,17 @@ def run_test(self):\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n+        address = multisig.p2sh_p2wsh_addr\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          solvable=True)\n+                          solvable=True,\n+                          ismine=False)",
    "path": "test/functional/wallet_importmulti.py",
    "position": 241,
    "original_position": 241,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: test for watchonly?",
    "created_at": "2018-12-14T20:10:16Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241876155",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876155"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241876155"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241876155/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 619,
    "original_line": 619,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241888102",
    "pull_request_review_id": 185262357,
    "id": 241888102,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTg4ODEwMg==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 225,
    "original_position": 225,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: should identify which private key was invalid in error message.\r\n\r\nEDIT: same for all error messages below. `importmulti` can contain multiple scripts, addresses and keys. Any error messages should indicate which address/script/key was at fault.",
    "created_at": "2018-12-14T20:51:57Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241888102",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241888102"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241888102"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241888102/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1003,
    "original_line": 1003,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942294",
    "pull_request_review_id": 185347159,
    "id": 241942294,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTk0MjI5NA==",
    "diff_hunk": "@@ -119,9 +119,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']",
    "path": "test/functional/wallet_importmulti.py",
    "position": 10,
    "original_position": 10,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Indentation is not a multiple of four :-)",
    "created_at": "2018-12-15T08:17:36Z",
    "updated_at": "2018-12-15T08:17:37Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241942294",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942294"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241942294"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942294/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 127,
    "original_line": 127,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942304",
    "pull_request_review_id": 185347171,
    "id": 241942304,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTk0MjMwNA==",
    "diff_hunk": "@@ -119,9 +119,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):",
    "path": "test/functional/wallet_importmulti.py",
    "position": 5,
    "original_position": 5,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I suggest using `warnings=None` (see example below) instead to clarify that `warnings` is not meant to be remembered across calls.\r\n\r\nBackground:\r\n\r\n```\r\n>>> def test(i, i_arr=[]):\r\n...     i_arr.append(i)\r\n...     return i_arr\r\n...\r\n>>> test(1)\r\n[1]\r\n>>> test(2)\r\n[1, 2]\r\n>>> test(3)\r\n[1, 2, 3]\r\n```\r\n\r\nSuggested alternative:\r\n\r\n```\r\n>>> def test(i, i_arr=None):\r\n...     if i_arr is None:\r\n...         i_arr=[]\r\n...     i_arr.append(i)\r\n...     return i_arr\r\n...\r\n>>> test(1)\r\n[1]\r\n>>> test(2)\r\n[2]\r\n>>> test(3)\r\n[3]\r\n```",
    "created_at": "2018-12-15T08:18:04Z",
    "updated_at": "2018-12-15T08:18:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241942304",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942304"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241942304"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241942304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 122,
    "original_line": 122,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241944704",
    "pull_request_review_id": 185349750,
    "id": 241944704,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTk0NDcwNA==",
    "diff_hunk": "@@ -119,9 +119,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):",
    "path": "test/functional/wallet_importmulti.py",
    "position": 5,
    "original_position": 5,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yikes, I thought only Javascript behaved like that...",
    "created_at": "2018-12-15T10:03:07Z",
    "updated_at": "2018-12-15T10:03:07Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241944704",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241944704"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241944704"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241944704/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 1,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 122,
    "original_line": 122,
    "side": "RIGHT",
    "in_reply_to_id": 241942304
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243090573",
    "pull_request_review_id": 185262357,
    "id": 243090573,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzA5MDU3Mw==",
    "diff_hunk": "@@ -398,75 +408,78 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n-                              False,\n-                              error_code=-8,\n-                              error_message='Watch-only addresses should not include private keys')\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          solvable=True,\n+                          timestamp=timestamp)\n \n         # Address + Public key + !Internal + Wrong pubkey\n-        self.log.info(\"Should not import an address with a wrong public key\")\n+        self.log.info(\"Should not import an address with the wrong public key as non-solvable\")",
    "path": "test/functional/wallet_importmulti.py",
    "position": 114,
    "original_position": 114,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "remove word 'not'",
    "created_at": "2018-12-19T21:59:57Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243090573",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243090573"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243090573"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243090573/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 419,
    "original_line": 419,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243100321",
    "pull_request_review_id": 185262357,
    "id": 243100321,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzEwMDMyMQ==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 341,
    "original_position": 341,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "(unchanged by this PR)\r\n\r\nThis error message is slightly wrong, since ISMINE_SPENDABLE could mean that the wallet already contains private key**s**. I think it would be better to say that the address or script is already owned by the wallet.",
    "created_at": "2018-12-19T22:36:39Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243100321",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243100321"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243100321"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243100321/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1073,
    "original_line": 1073,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243105890",
    "pull_request_review_id": 185262357,
    "id": 243105890,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzEwNTg5MA==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";",
    "path": "src/wallet/rpcdump.cpp",
    "position": 294,
    "original_position": 294,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Error message could indicate which key, eg \"key for pubkey hash <x> is missing\"",
    "created_at": "2018-12-19T22:58:33Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243105890",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243105890"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243105890"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243105890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1038,
    "original_line": 1038,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243111922",
    "pull_request_review_id": 185262357,
    "id": 243111922,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzExMTkyMg==",
    "diff_hunk": "@@ -854,211 +941,167 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkeys;\n+        std::map<CKeyID, CKey> privkeys;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n             }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n-            }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-\n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n             }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            pubkeys.emplace(pubkey.GetID(), pubkey);\n+        }\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkeys.count(id)) {\n+                warnings.push_back(\"Both public and private key provided.\");\n+                pubkeys.erase(id);\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n+            privkeys.emplace(id, key);\n+        }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkeys.size() || privkeys.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.require_keys) {\n+                    if (pubkeys.count(require_key) == 0 && privkeys.count(require_key) == 0) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                    }\n                 }\n+            }\n \n-                pwallet->MarkDirty();\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            if (!watchOnly && std::any_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const CKeyID& used_key){ return privkeys.count(used_key) == 0; })) {\n+                warnings.push_back(\"Assuming watchonly as not all private keys are provided.\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkeys.clear();\n+                privkeys.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkeys.begin(); it != privkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkeys.erase(oldit);\n+                    }\n+                }\n+                for (auto it = pubkeys.begin(); it != pubkeys.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.require_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring public key as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkeys.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkeys) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 394,
    "original_position": 387,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "8a079e88f7a00cfbef0bb8b1d2016e5157343091",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Let's leave this for later.\r\n\r\nAgree. When this does get changed, we should also update `CWallet::AddKeyPubKey()` to also call `UpdateTimeFirstKey()` (in the same way that `CWallet::AddWatchOnly()` does).",
    "created_at": "2018-12-19T23:26:47Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243111922",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243111922"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243111922"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243111922/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1088,
    "original_line": 1088,
    "side": "RIGHT",
    "in_reply_to_id": 238428932
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243113167",
    "pull_request_review_id": 185262357,
    "id": 243113167,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzExMzE2Nw==",
    "diff_hunk": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript); // Remove redeemscript from import_data to check for superfluous script later.\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript); // Remove redeemscript from import_data to check for superfluous script later.\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n+        }\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n+        }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)",
    "path": "src/wallet/rpcdump.cpp",
    "position": 91,
    "original_position": 91,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a fairly involved function, so it'd be friendly to have a function-level comment:\r\n\r\n- called once for each request within an importmulti call\r\n- doesn't throw. All errors are caught and returned in the error field\r\n- all input data is parsed and validated first. Then scripts, pubkeys and keys are imported.",
    "created_at": "2018-12-19T23:33:55Z",
    "updated_at": "2018-12-20T00:09:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243113167",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243113167"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243113167"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243113167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 926,
    "original_line": 926,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243241253",
    "pull_request_review_id": 186956824,
    "id": 243241253,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI0MTI1Mw==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 225,
    "original_position": 225,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I really don't think that putting private keys in error messages is a good idea. They may get logged unintentionally, etc.",
    "created_at": "2018-12-20T11:36:40Z",
    "updated_at": "2018-12-20T11:36:40Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243241253",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243241253"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243241253"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243241253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1003,
    "original_line": 1003,
    "side": "RIGHT",
    "in_reply_to_id": 241888102
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243245864",
    "pull_request_review_id": 186962447,
    "id": 243245864,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI0NTg2NA==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 225,
    "original_position": 225,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Absolutely agree with @sipa. Could show a couple chars only or the error message could say the index of the invalid entry?",
    "created_at": "2018-12-20T11:53:47Z",
    "updated_at": "2018-12-20T11:53:47Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243245864",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243245864"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243245864"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243245864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1003,
    "original_line": 1003,
    "side": "RIGHT",
    "in_reply_to_id": 241888102
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243259567",
    "pull_request_review_id": 186980456,
    "id": 243259567,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI1OTU2Nw==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");",
    "path": "src/wallet/rpcdump.cpp",
    "position": 225,
    "original_position": 225,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes, very good point. I think Promag's suggestions are good.\r\n\r\nIn any case, this doesn't need to be included in this PR. A future PR to improve logging and test all failure modes would be nice.",
    "created_at": "2018-12-20T12:49:26Z",
    "updated_at": "2018-12-20T12:49:26Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243259567",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243259567"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243259567"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243259567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1003,
    "original_line": 1003,
    "side": "RIGHT",
    "in_reply_to_id": 241888102
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243368429",
    "pull_request_review_id": 187120835,
    "id": 243368429,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzM2ODQyOQ==",
    "diff_hunk": "@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-            }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkey_map) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            // If the private key is not present in the wallet, insert it.\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkey_map) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;",
    "path": "src/wallet/rpcdump.cpp",
    "position": 404,
    "original_position": 404,
    "commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "original_commit_id": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "re: https://github.com/bitcoin/bitcoin/pull/14565#discussion_r241238436\r\n\r\n> Do we also need to update mapKeyMetadata here to include the timestamp?\r\n\r\nI requested not doing this here: https://github.com/bitcoin/bitcoin/pull/14565#discussion_r234278403. It shouldn't be necessary because timestamp is passed to AddWatchOnly below. In the future the mapKeyMetadata update above could also be removed, see https://github.com/bitcoin/bitcoin/pull/14565#discussion_r238836988.",
    "created_at": "2018-12-20T18:12:17Z",
    "updated_at": "2018-12-20T20:08:07Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243368429",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243368429"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/14565#discussion_r243368429"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/14565"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243368429/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1097,
    "original_line": 1097,
    "side": "RIGHT",
    "in_reply_to_id": 241238436
  }
]