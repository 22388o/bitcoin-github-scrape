[
  {
    "sha": "ed61abedb262d1a9772ca51916fefaeaadcc5b22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZDYxYWJlZGIyNjJkMWE5NzcyY2E1MTkxNmZlZmFlYWFkY2M1YjIy",
    "commit": {
      "author": {
        "name": "lucash-dev",
        "email": "lucash.dev@gmail.com",
        "date": "2018-12-08T23:38:12Z"
      },
      "committer": {
        "name": "lucash-dev",
        "email": "lucash.dev@gmail.com",
        "date": "2018-12-12T03:43:35Z"
      },
      "message": "Removed implicit CTransaction constructor from tests",
      "tree": {
        "sha": "4cecd36f300987fa58e548d6ea6dca6f0481c92c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4cecd36f300987fa58e548d6ea6dca6f0481c92c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed61abedb262d1a9772ca51916fefaeaadcc5b22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed61abedb262d1a9772ca51916fefaeaadcc5b22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ed61abedb262d1a9772ca51916fefaeaadcc5b22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed61abedb262d1a9772ca51916fefaeaadcc5b22/comments",
    "author": {
      "login": "lucash-dev",
      "id": 31627588,
      "node_id": "MDQ6VXNlcjMxNjI3NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/31627588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lucash-dev",
      "html_url": "https://github.com/lucash-dev",
      "followers_url": "https://api.github.com/users/lucash-dev/followers",
      "following_url": "https://api.github.com/users/lucash-dev/following{/other_user}",
      "gists_url": "https://api.github.com/users/lucash-dev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lucash-dev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lucash-dev/subscriptions",
      "organizations_url": "https://api.github.com/users/lucash-dev/orgs",
      "repos_url": "https://api.github.com/users/lucash-dev/repos",
      "events_url": "https://api.github.com/users/lucash-dev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lucash-dev/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lucash-dev",
      "id": 31627588,
      "node_id": "MDQ6VXNlcjMxNjI3NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/31627588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lucash-dev",
      "html_url": "https://github.com/lucash-dev",
      "followers_url": "https://api.github.com/users/lucash-dev/followers",
      "following_url": "https://api.github.com/users/lucash-dev/following{/other_user}",
      "gists_url": "https://api.github.com/users/lucash-dev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lucash-dev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lucash-dev/subscriptions",
      "organizations_url": "https://api.github.com/users/lucash-dev/orgs",
      "repos_url": "https://api.github.com/users/lucash-dev/repos",
      "events_url": "https://api.github.com/users/lucash-dev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lucash-dev/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f65bce858f266b352c9ddd1f5480431dca56fcae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f65bce858f266b352c9ddd1f5480431dca56fcae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f65bce858f266b352c9ddd1f5480431dca56fcae"
      }
    ],
    "stats": {
      "total": 232,
      "additions": 116,
      "deletions": 116
    },
    "files": [
      {
        "sha": "403f3e592f251d19c183a2e52ea95fbc41efec45",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -377,7 +377,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n-            UpdateCoins(tx, *(stack.back()), undo, height);\n+            UpdateCoins(CTransaction(tx), *(stack.back()), undo, height);\n \n             // Update the utxo set for future spends\n             utxoset.insert(outpoint);"
      },
      {
        "sha": "2396aba0f1db3f789f141832fbb974536a6549e9",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -59,13 +59,13 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n \n     // Nothing in pool, remove should do nothing:\n     unsigned int poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n \n     // Just the parent:\n     testPool.addUnchecked(entry.FromTx(txParent));\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 1);\n \n     // Parent, children, grandchildren:\n@@ -77,18 +77,18 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     }\n     // Remove Child[0], GrandChild[0] should be removed:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txChild[0]);\n+    testPool.removeRecursive(CTransaction(txChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 2);\n     // ... make sure grandchild and child are gone:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txGrandChild[0]);\n+    testPool.removeRecursive(CTransaction(txGrandChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txChild[0]);\n+    testPool.removeRecursive(CTransaction(txChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n     // Remove parent, all children/grandchildren should go:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 5);\n     BOOST_CHECK_EQUAL(testPool.size(), 0U);\n \n@@ -101,7 +101,7 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     // Now remove the parent, as might happen if a block-re-org occurs but the parent cannot be\n     // put into the mempool (maybe because it is non-standard):\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 6);\n     BOOST_CHECK_EQUAL(testPool.size(), 0U);\n }\n@@ -309,7 +309,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx2.vout[0].nValue = 2 * COIN;\n     pool.addUnchecked(entry.Fee(20000LL).FromTx(tx2));\n-    uint64_t tx2Size = GetVirtualTransactionSize(tx2);\n+    uint64_t tx2Size = GetVirtualTransactionSize(CTransaction(tx2));\n \n     /* lowest fee */\n     CMutableTransaction tx3 = CMutableTransaction();\n@@ -357,7 +357,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx6.vout.resize(1);\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n-    uint64_t tx6Size = GetVirtualTransactionSize(tx6);\n+    uint64_t tx6Size = GetVirtualTransactionSize(CTransaction(tx6));\n \n     pool.addUnchecked(entry.Fee(0LL).FromTx(tx6));\n     BOOST_CHECK_EQUAL(pool.size(), 6U);\n@@ -376,7 +376,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx7.vout.resize(1);\n     tx7.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx7.vout[0].nValue = 10 * COIN;\n-    uint64_t tx7Size = GetVirtualTransactionSize(tx7);\n+    uint64_t tx7Size = GetVirtualTransactionSize(CTransaction(tx7));\n \n     /* set the fee to just below tx2's feerate when including ancestor */\n     CAmount fee = (20000/tx2Size)*(tx7Size + tx6Size) - 1;\n@@ -464,12 +464,12 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     BOOST_CHECK(pool.exists(tx2.GetHash()));\n     BOOST_CHECK(pool.exists(tx3.GetHash()));\n \n-    pool.TrimToSize(GetVirtualTransactionSize(tx1)); // mempool is limited to tx1's size in memory usage, so nothing fits\n+    pool.TrimToSize(GetVirtualTransactionSize(CTransaction(tx1))); // mempool is limited to tx1's size in memory usage, so nothing fits\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n     BOOST_CHECK(!pool.exists(tx3.GetHash()));\n \n-    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(tx3) + GetVirtualTransactionSize(tx2));\n+    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));\n     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n \n     CMutableTransaction tx4 = CMutableTransaction();"
      },
      {
        "sha": "f3648e2eeec8b073b1816b92df990696ec5a8a39",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -159,7 +159,7 @@ static void TestPackageSelection(const CChainParams& chainparams, const CScript&\n     // Test that packages above the min relay fee do get included, even if one\n     // of the transactions is below the min relay fee\n     // Remove the low fee transaction and replace with a higher fee transaction\n-    mempool.removeRecursive(tx);\n+    mempool.removeRecursive(CTransaction(tx));\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     mempool.addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n@@ -441,22 +441,22 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n \n     // relative time locked\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n     prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n \n@@ -467,9 +467,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = chainActive.Tip()->nHeight + 1;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+    BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n \n     // absolute time locked\n     tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n@@ -478,23 +478,23 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     prevheights[0] = baseheight + 4;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+    BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n \n     // mempool-dependent transactions (not added)\n     tx.vin[0].prevout.hash = hash;\n     prevheights[0] = chainActive.Tip()->nHeight + 1;\n     tx.nLockTime = 0;\n     tx.vin[0].nSequence = 0;\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     tx.vin[0].nSequence = 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG;\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n "
      },
      {
        "sha": "33308c574970125536236479741042c24d277c72",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -76,20 +76,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     // Test a AND b:\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n-    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+    s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n     BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n@@ -98,7 +98,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n-        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n+        s = sign_multisig(a_or_b, keys, CTransaction(txTo[1]), 0);\n         if (i == 0 || i == 1)\n         {\n             BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         {\n             keys.assign(1,key[i]);\n             keys.push_back(key[j]);\n-            s = sign_multisig(escrow, keys, txTo[2], 0);\n+            s = sign_multisig(escrow, keys, CTransaction(txTo[2]), 0);\n             if (i < j && i < 3 && j < 3)\n             {\n                 BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n \n     for (int i = 0; i < 3; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n }\n "
      },
      {
        "sha": "431b16cfc282f8d69a5cf7a7bf33f54c09f43000",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -44,7 +44,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     tx.vin[0].scriptSig = garbage;\n     tx.vout.resize(1);\n     tx.vout[0].nValue=0LL;\n-    CFeeRate baseRate(basefee, GetVirtualTransactionSize(tx));\n+    CFeeRate baseRate(basefee, GetVirtualTransactionSize(CTransaction(tx)));\n \n     // Create a fake block\n     std::vector<CTransactionRef> block;"
      },
      {
        "sha": "a532de565948d1ff7e381b819dc3d5e74beb90ce",
        "filename": "src/test/script_p2sh_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/script_p2sh_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/script_p2sh_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_p2sh_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -88,7 +88,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n         txFrom.vout[i+4].nValue = COIN;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(txFrom), reason));\n \n     CMutableTransaction txTo[8]; // Spending transactions\n     for (int i = 0; i < 8; i++)\n@@ -102,7 +102,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     }\n     for (int i = 0; i < 8; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n@@ -112,7 +112,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n+            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], CTransaction(txTo[i]), 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else\n@@ -184,7 +184,7 @@ BOOST_AUTO_TEST_CASE(set)\n         txFrom.vout[i].scriptPubKey = outer[i];\n         txFrom.vout[i].nValue = CENT;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(txFrom), reason));\n \n     CMutableTransaction txTo[4]; // Spending transactions\n     for (int i = 0; i < 4; i++)\n@@ -199,8 +199,8 @@ BOOST_AUTO_TEST_CASE(set)\n     }\n     for (int i = 0; i < 4; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n-        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(IsStandardTx(CTransaction(txTo[i]), reason), strprintf(\"txTo[%d].IsStandard\", i));\n     }\n }\n \n@@ -316,7 +316,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n \n-    AddCoins(coins, txFrom, 0);\n+    AddCoins(coins, CTransaction(txFrom), 0);\n \n     CMutableTransaction txTo;\n     txTo.vout.resize(1);\n@@ -328,18 +328,18 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n         txTo.vin[i].prevout.n = i;\n         txTo.vin[i].prevout.hash = txFrom.GetHash();\n     }\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 1, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 2, SIGHASH_ALL));\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:\n     txTo.vin[3].scriptSig << OP_11 << OP_11 << std::vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n     txTo.vin[4].scriptSig << std::vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n \n-    BOOST_CHECK(::AreInputsStandard(txTo, coins));\n+    BOOST_CHECK(::AreInputsStandard(CTransaction(txTo), coins));\n     // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txTo), coins), 22U);\n \n     CMutableTransaction txToNonStd1;\n     txToNonStd1.vout.resize(1);\n@@ -350,8 +350,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd1.vin[0].scriptSig << std::vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n+    BOOST_CHECK(!::AreInputsStandard(CTransaction(txToNonStd1), coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txToNonStd1), coins), 16U);\n \n     CMutableTransaction txToNonStd2;\n     txToNonStd2.vout.resize(1);\n@@ -362,8 +362,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd2.vin[0].scriptSig << std::vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n+    BOOST_CHECK(!::AreInputsStandard(CTransaction(txToNonStd2), coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txToNonStd2), coins), 20U);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9a801901b766e2f2450dc558f6726afced6af039",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -1078,18 +1078,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     const CTransaction txFrom12{BuildCreditingTransaction(scriptPubKey12)};\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n-    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n+    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, CTransaction(txTo12));\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n     BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n-    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n+    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, CTransaction(txTo12));\n     BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n+    CScript badsig1 = sign_multisig(scriptPubKey12, key3, CTransaction(txTo12));\n     BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n@@ -1111,54 +1111,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n \n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n-    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n-    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n-    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n-    CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n-    CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n-    CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n-    CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig4 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n-    CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig5 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n-    CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig6 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n@@ -1189,7 +1189,7 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     }\n \n     CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n-    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom);\n+    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), CTransaction(txFrom));\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n     SignatureData scriptSig;\n \n@@ -1198,15 +1198,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     BOOST_CHECK(combined.scriptSig.empty());\n \n     // Single signature case:\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL); // changes scriptSig\n+    SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL); // changes scriptSig\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     SignatureData scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL);\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n@@ -1215,22 +1215,22 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL);\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     scriptSigCopy = scriptSig;\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL);\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL);\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);"
      },
      {
        "sha": "04d5462acb20a06a6e06b583a617094df13a2916",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -137,7 +137,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n         int nIn = InsecureRandRange(txTo.vin.size());\n \n         uint256 sh, sho;\n-        sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n+        sho = SignatureHashOld(scriptCode, CTransaction(txTo), nIn, nHashType);\n         sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "6a0349cd4e433708945d2a6a2537428b1bcc3700",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -102,7 +102,7 @@ static void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CM\n     spendingTx.vout[0].nValue = 1;\n     spendingTx.vout[0].scriptPubKey = CScript();\n \n-    AddCoins(coins, creationTx, 0);\n+    AddCoins(coins, CTransaction(creationTx), 0);\n }\n \n BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         // is not accurate.\n         assert(GetTransactionSigOpCost(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n         // Sanity check: script verification fails because of an invalid signature.\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // Multisig nested in P2SH\n@@ -149,7 +149,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CScriptWitness());\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // P2WPKH witness program\n@@ -166,7 +166,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n         // No signature operations if we don't verify the witness.\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n \n         // The sig op cost for witness version != 0 is zero.\n         assert(scriptPubKey[0] == 0x00);\n@@ -193,7 +193,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n     }\n \n     // P2WSH witness program\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // P2WSH nested in P2SH\n@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n }\n "
      },
      {
        "sha": "87de7242cdff71fa1974a549cc3de8c9c7c676cc",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -273,11 +273,11 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     CMutableTransaction tx;\n     stream >> tx;\n     CValidationState state;\n-    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n+    BOOST_CHECK_MESSAGE(CheckTransaction(CTransaction(tx), state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n \n     // Check that duplicate txins fail\n     tx.vin.push_back(tx.vin[0]);\n-    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n+    BOOST_CHECK_MESSAGE(!CheckTransaction(CTransaction(tx), state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n }\n \n //\n@@ -306,14 +306,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    AddCoins(coinsRet, dummyTransactions[0], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[0]), 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    AddCoins(coinsRet, dummyTransactions[1], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[1]), 0);\n \n     return dummyTransactions;\n }\n@@ -340,8 +340,8 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n-    BOOST_CHECK(AreInputsStandard(t1, coins));\n-    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n+    BOOST_CHECK(AreInputsStandard(CTransaction(t1), coins));\n+    BOOST_CHECK_EQUAL(coins.GetValueIn(CTransaction(t1)), (50+21+22)*CENT);\n }\n \n static void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\n@@ -697,75 +697,75 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n \n     std::string reason;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Check dust with default relay fee:\n     CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\n     BOOST_CHECK_EQUAL(nDustThreshold, 546);\n     // dust:\n     t.vout[0].nValue = nDustThreshold - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n     // not dust:\n     t.vout[0].nValue = nDustThreshold;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Check dust with odd relay fee to verify rounding:\n     // nDustThreshold = 182 * 3702 / 1000\n     dustRelayFee = CFeeRate(3702);\n     // dust:\n     t.vout[0].nValue = 673 - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n     // not dust:\n     t.vout[0].nValue = 673;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\n \n     t.vout[0].scriptPubKey = CScript() << OP_1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // MAX_OP_RETURN_RELAY-byte TX_NULL_DATA (standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // MAX_OP_RETURN_RELAY+1-byte TX_NULL_DATA (non-standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // Data payload can be encoded in any way...\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // ...so long as it only contains PUSHDATA's\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // TX_NULL_DATA w/o PUSHDATA\n     t.vout.resize(1);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Only one TX_NULL_DATA permitted in all cases\n     t.vout.resize(2);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d0c99d64f6c05f0f5fd4ff086cd1d168095d327a",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed61abedb262d1a9772ca51916fefaeaadcc5b22/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "patch": "@@ -198,20 +198,20 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n         // not present.  Don't add these checks to the cache, so that we can\n         // test later that block validation works fine in the absence of cached\n         // successes.\n-        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n+        ValidateCheckInputsForAllFlags(CTransaction(spend_tx), SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n     }\n \n     // And if we produce a block with this tx, it should be valid (DERSIG not\n@@ -238,7 +238,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n         invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n \n-        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_under_p2sh_tx), SCRIPT_VERIFY_P2SH, true);\n     }\n \n     // Test CHECKLOCKTIMEVERIFY\n@@ -261,13 +261,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n \n-        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_with_cltv_tx), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\n \n         // Make it valid, and check again\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -289,13 +289,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n \n-        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_with_csv_tx), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\n \n         // Make it valid, and check again\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -318,11 +318,11 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         UpdateInput(valid_with_witness_tx.vin[0], sigdata);\n \n         // This should be valid under all script flags.\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(valid_with_witness_tx), 0, true);\n \n         // Remove the witness, and check that it is now invalid.\n         valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(valid_with_witness_tx), SCRIPT_VERIFY_WITNESS, true);\n     }\n \n     {\n@@ -347,7 +347,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         }\n \n         // This should be valid under all script flags\n-        ValidateCheckInputsForAllFlags(tx, 0, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(tx), 0, true);\n \n         // Check that if the second input is invalid, but the first input is\n         // valid, the transaction is not cached.\n@@ -357,12 +357,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      }
    ]
  },
  {
    "sha": "8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZGIwYzNkNDJiMDYzMTE4ZDE3YWI4M2JhOGJlZWIzODUyZjhmYzZl",
    "commit": {
      "author": {
        "name": "lucash-dev",
        "email": "lucash.dev@gmail.com",
        "date": "2018-12-09T00:30:55Z"
      },
      "committer": {
        "name": "lucash-dev",
        "email": "lucash.dev@gmail.com",
        "date": "2018-12-12T03:43:35Z"
      },
      "message": "Removed implicit CTransaction conversion from benchmaks",
      "tree": {
        "sha": "2717f0290a2b2d6f967c57039411304579ad2034",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2717f0290a2b2d6f967c57039411304579ad2034"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e/comments",
    "author": {
      "login": "lucash-dev",
      "id": 31627588,
      "node_id": "MDQ6VXNlcjMxNjI3NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/31627588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lucash-dev",
      "html_url": "https://github.com/lucash-dev",
      "followers_url": "https://api.github.com/users/lucash-dev/followers",
      "following_url": "https://api.github.com/users/lucash-dev/following{/other_user}",
      "gists_url": "https://api.github.com/users/lucash-dev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lucash-dev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lucash-dev/subscriptions",
      "organizations_url": "https://api.github.com/users/lucash-dev/orgs",
      "repos_url": "https://api.github.com/users/lucash-dev/repos",
      "events_url": "https://api.github.com/users/lucash-dev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lucash-dev/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lucash-dev",
      "id": 31627588,
      "node_id": "MDQ6VXNlcjMxNjI3NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/31627588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lucash-dev",
      "html_url": "https://github.com/lucash-dev",
      "followers_url": "https://api.github.com/users/lucash-dev/followers",
      "following_url": "https://api.github.com/users/lucash-dev/following{/other_user}",
      "gists_url": "https://api.github.com/users/lucash-dev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lucash-dev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lucash-dev/subscriptions",
      "organizations_url": "https://api.github.com/users/lucash-dev/orgs",
      "repos_url": "https://api.github.com/users/lucash-dev/repos",
      "events_url": "https://api.github.com/users/lucash-dev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lucash-dev/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed61abedb262d1a9772ca51916fefaeaadcc5b22",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ed61abedb262d1a9772ca51916fefaeaadcc5b22"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 6,
      "deletions": 5
    },
    "files": [
      {
        "sha": "9cfd5d23effe120ba17ede3c51e94b5b69b4b12a",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * COIN;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    AddCoins(coinsRet, dummyTransactions[0], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[0]), 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * COIN;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * COIN;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    AddCoins(coinsRet, dummyTransactions[1], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[1]), 0);\n \n     return dummyTransactions;\n }\n@@ -76,10 +76,11 @@ static void CCoinsCaching(benchmark::State& state)\n     t1.vout[0].scriptPubKey << OP_1;\n \n     // Benchmark.\n+    const CTransaction tx_1(t1);\n     while (state.KeepRunning()) {\n-        bool success = AreInputsStandard(t1, coins);\n+        bool success = AreInputsStandard(tx_1, coins);\n         assert(success);\n-        CAmount value = coins.GetValueIn(t1);\n+        CAmount value = coins.GetValueIn(tx_1);\n         assert(value == (50 + 21 + 22) * COIN);\n     }\n }"
      },
      {
        "sha": "49ea6e88b5ea9dfd2a6403fb3e613e4fe0671a58",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8db0c3d42b063118d17ab83ba8beeb3852f8fc6e/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=8db0c3d42b063118d17ab83ba8beeb3852f8fc6e",
        "patch": "@@ -127,7 +127,7 @@ static void MempoolEviction(benchmark::State& state)\n         AddTx(tx6_r, 1100LL, pool);\n         AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n-        pool.TrimToSize(GetVirtualTransactionSize(tx1));\n+        pool.TrimToSize(GetVirtualTransactionSize(*tx1_r));\n     }\n }\n "
      }
    ]
  }
]