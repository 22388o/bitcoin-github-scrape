[
  {
    "sha": "f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmM2MyNjRlOWE2ZGVhYTEyZTg5ZmFhNzgzZDNjN2M5OWI5NDVmMThl",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-04T04:22:19Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-03-08T16:07:55Z"
      },
      "message": "Refactor: Remove using namespace <xxx> from rpc/",
      "tree": {
        "sha": "e7dddfc1c89f95d2045b13e197508dce7101c2b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7dddfc1c89f95d2045b13e197508dce7101c2b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYwCxcAAoJEFevdi2zNTMiMNQP/1J4IHsDDE9MKXA6uToW/57O\nE56EEwym6G0EKtMc9ao8gaX9cOR1zPxWEhdL+oQESL5GrU202y89U/93Ag1ivmyT\nRnFPpbvbPJOV+U8LNQ9bLxwvfFSoJJHOvd+Zn0tfzKJdGr4rBvAYCcWGB3YOrYJE\nlDfyoW+K0U+O98wW6VuqybMm7Rl2x5Y4AEY0959vrD5IPrgF1mjbQqA5G8P4Kks0\nH5ZUA3fRWAlfFtV0DeosJreghgM9B7UBnCnSI7dsaIotnUoRO3oapgQ3MImSiRvl\nIgkxcGOuDw71VqIJBGDcuIP7uH22FzQwaAKT69kQtkNfN9DE2fwyS2TmHRGXdM+z\nssBaUTkfSxUxoIRAefUxr/KaLb9OMcEvlYKadLKVaeBFF2hvZQZAOJriYBGBZXXW\nW2QjHLGbGvlbpwonefxQkwh998rwcHXxBMA+QpYhTfJFmXW3wEJhzamUVpiaOff/\nZ3UR2MPKD3x6x+W+XKgfdDhxf+C4T/FhL/CBHVbTq9DBi7uiDf3Zw8TFna6ZdbLA\nlZ/1cqc9CHIb9uOR8PC8qkaJp5+uus5ka7GExOQRrCJlEpmZHFgstrlhZRvnTbZ7\nK+5SibFHlwVgXcHdzFB0GjnuwImXtlS4Z31S37Go6t9ML8qE6aLV32bqNHtb+5MV\n1KdjLtknalfALfbfs7XE\n=fXe5\n-----END PGP SIGNATURE-----",
        "payload": "tree e7dddfc1c89f95d2045b13e197508dce7101c2b9\nparent 6996e066b538f03b8aa1f617dbb959b57ff6e727\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1483503739 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1488989275 -0800\n\nRefactor: Remove using namespace <xxx> from rpc/\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6996e066b538f03b8aa1f617dbb959b57ff6e727"
      }
    ],
    "stats": {
      "total": 318,
      "additions": 151,
      "deletions": 167
    },
    "files": [
      {
        "sha": "f38b8f88aab7d9623f2c0460a063df8f0e310e6f",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 29,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -28,7 +28,6 @@\n \n #include <mutex>\n #include <condition_variable>\n-using namespace std;\n \n struct CUpdatedBlock\n {\n@@ -154,7 +153,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n UniValue getblockcount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockcount\\n\"\n             \"\\nReturns the number of blocks in the longest blockchain.\\n\"\n             \"\\nResult:\\n\"\n@@ -171,7 +170,7 @@ UniValue getblockcount(const JSONRPCRequest& request)\n UniValue getbestblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getbestblockhash\\n\"\n             \"\\nReturns the hash of the best (tip) block in the longest blockchain.\\n\"\n             \"\\nResult:\\n\"\n@@ -198,7 +197,7 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n UniValue waitfornewblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitfornewblock (timeout)\\n\"\n             \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n             \"\\nReturns the current block on timeout or exit.\\n\"\n@@ -236,7 +235,7 @@ UniValue waitfornewblock(const JSONRPCRequest& request)\n UniValue waitforblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitforblock <blockhash> (timeout)\\n\"\n             \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n             \"\\nReturns the current block on timeout or exit.\\n\"\n@@ -278,7 +277,7 @@ UniValue waitforblock(const JSONRPCRequest& request)\n UniValue waitforblockheight(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitforblockheight <height> (timeout)\\n\"\n             \"\\nWaits for (at least) block height and returns the height and hash\\n\"\n             \"of the current tip.\\n\"\n@@ -320,7 +319,7 @@ UniValue waitforblockheight(const JSONRPCRequest& request)\n UniValue getdifficulty(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getdifficulty\\n\"\n             \"\\nReturns the proof-of-work difficulty as a multiple of the minimum difficulty.\\n\"\n             \"\\nResult:\\n\"\n@@ -368,15 +367,15 @@ void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n     info.push_back(Pair(\"ancestorsize\", e.GetSizeWithAncestors()));\n     info.push_back(Pair(\"ancestorfees\", e.GetModFeesWithAncestors()));\n     const CTransaction& tx = e.GetTx();\n-    set<string> setDepends;\n+    std::set<std::string> setDepends;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n     {\n         if (mempool.exists(txin.prevout.hash))\n             setDepends.insert(txin.prevout.hash.ToString());\n     }\n \n     UniValue depends(UniValue::VARR);\n-    BOOST_FOREACH(const string& dep, setDepends)\n+    BOOST_FOREACH(const std::string& dep, setDepends)\n     {\n         depends.push_back(dep);\n     }\n@@ -401,7 +400,7 @@ UniValue mempoolToJSON(bool fVerbose = false)\n     }\n     else\n     {\n-        vector<uint256> vtxid;\n+        std::vector<uint256> vtxid;\n         mempool.queryHashes(vtxid);\n \n         UniValue a(UniValue::VARR);\n@@ -415,7 +414,7 @@ UniValue mempoolToJSON(bool fVerbose = false)\n UniValue getrawmempool(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawmempool ( verbose )\\n\"\n             \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n             \"\\nArguments:\\n\"\n@@ -446,7 +445,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n UniValue getmempoolancestors(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolancestors txid (verbose)\\n\"\n             \"\\nIf txid is in the mempool, returns all in-mempool ancestors.\\n\"\n             \"\\nArguments:\\n\"\n@@ -510,7 +509,7 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n UniValue getmempooldescendants(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempooldescendants txid (verbose)\\n\"\n             \"\\nIf txid is in the mempool, returns all in-mempool descendants.\\n\"\n             \"\\nArguments:\\n\"\n@@ -574,7 +573,7 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n UniValue getmempoolentry(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolentry txid\\n\"\n             \"\\nReturns mempool data for given transaction\\n\"\n             \"\\nArguments:\\n\"\n@@ -607,7 +606,7 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n UniValue getblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockhash height\\n\"\n             \"\\nReturns hash of block in best-block-chain at height provided.\\n\"\n             \"\\nArguments:\\n\"\n@@ -632,7 +631,7 @@ UniValue getblockhash(const JSONRPCRequest& request)\n UniValue getblockheader(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockheader \\\"hash\\\" ( verbose )\\n\"\n             \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.\\n\"\n             \"If verbose is true, returns an Object with information about blockheader <hash>.\\n\"\n@@ -691,7 +690,7 @@ UniValue getblockheader(const JSONRPCRequest& request)\n UniValue getblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblock \\\"blockhash\\\" ( verbose )\\n\"\n             \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n             \"If verbose is true, returns an Object with information about block <hash>.\\n\"\n@@ -818,7 +817,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n UniValue pruneblockchain(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"pruneblockchain\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or a unix timestamp\\n\"\n@@ -867,7 +866,7 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxoutsetinfo\\n\"\n             \"\\nReturns statistics about the unspent transaction output set.\\n\"\n             \"Note this call may take some time.\\n\"\n@@ -907,7 +906,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n UniValue gettxout(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxout \\\"txid\\\" n ( include_mempool )\\n\"\n             \"\\nReturns details about an unspent transaction output.\\n\"\n             \"\\nArguments:\\n\"\n@@ -989,7 +988,7 @@ UniValue verifychain(const JSONRPCRequest& request)\n     int nCheckLevel = GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL);\n     int nCheckDepth = GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS);\n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifychain ( checklevel nblocks )\\n\"\n             \"\\nVerifies blockchain database.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1075,7 +1074,7 @@ void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const std::string &name,\n UniValue getblockchaininfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockchaininfo\\n\"\n             \"Returns an object containing various state info regarding blockchain processing.\\n\"\n             \"\\nResult:\\n\"\n@@ -1168,7 +1167,7 @@ struct CompareBlocksByHeight\n UniValue getchaintips(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getchaintips\\n\"\n             \"Return information about all known tips in the block tree,\"\n             \" including the main chain as well as orphaned branches.\\n\"\n@@ -1201,7 +1200,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n     LOCK(cs_main);\n \n     /*\n-     * Idea:  the set of chain tips is chainActive.tip, plus orphan blocks which do not have another orphan building off of them. \n+     * Idea:  the set of chain tips is chainActive.tip, plus orphan blocks which do not have another orphan building off of them.\n      * Algorithm:\n      *  - Make one pass through mapBlockIndex, picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n      *  - Iterate through the orphan blocks. If the block isn't pointed to by another orphan, it is a chain tip.\n@@ -1240,7 +1239,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n         const int branchLen = block->nHeight - chainActive.FindFork(block)->nHeight;\n         obj.push_back(Pair(\"branchlen\", branchLen));\n \n-        string status;\n+        std::string status;\n         if (chainActive.Contains(block)) {\n             // This block is part of the currently active chain.\n             status = \"active\";\n@@ -1284,7 +1283,7 @@ UniValue mempoolInfoToJSON()\n UniValue getmempoolinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolinfo\\n\"\n             \"\\nReturns details on the active state of the TX memory pool.\\n\"\n             \"\\nResult:\\n\"\n@@ -1306,7 +1305,7 @@ UniValue getmempoolinfo(const JSONRPCRequest& request)\n UniValue preciousblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"preciousblock \\\"blockhash\\\"\\n\"\n             \"\\nTreats a block as if it were received before others with the same work.\\n\"\n             \"\\nA later preciousblock call can override the effect of an earlier one.\\n\"\n@@ -1344,7 +1343,7 @@ UniValue preciousblock(const JSONRPCRequest& request)\n UniValue invalidateblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"invalidateblock \\\"blockhash\\\"\\n\"\n             \"\\nPermanently marks a block as invalid, as if it violated a consensus rule.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1382,7 +1381,7 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n UniValue reconsiderblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"reconsiderblock \\\"blockhash\\\"\\n\"\n             \"\\nRemoves invalidity status of a block and its descendants, reconsider them for activation.\\n\"\n             \"This can be used to undo the effects of invalidateblock.\\n\""
      },
      {
        "sha": "2cb250a198074fe7c4bcd7c54e5df7f1577e0b9e",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -13,8 +13,6 @@\n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <univalue.h>\n \n-using namespace std;\n-\n class CRPCConvertParam\n {\n public:\n@@ -168,7 +166,7 @@ UniValue ParseNonRFCJSONValue(const std::string& strVal)\n     UniValue jVal;\n     if (!jVal.read(std::string(\"[\")+strVal+std::string(\"]\")) ||\n         !jVal.isArray() || jVal.size()!=1)\n-        throw runtime_error(string(\"Error parsing JSON:\")+strVal);\n+        throw std::runtime_error(std::string(\"Error parsing JSON:\")+strVal);\n     return jVal[0];\n }\n "
      },
      {
        "sha": "abdfa651abc5b8e3ab284bea5742eae957c30902",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 13,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -30,8 +30,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n /**\n  * Return average network hashes per second based on the last 'lookup' blocks,\n  * or from the last difficulty change if 'lookup' is nonpositive.\n@@ -77,7 +75,7 @@ UniValue GetNetworkHashPS(int lookup, int height) {\n UniValue getnetworkhashps(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnetworkhashps ( nblocks height )\\n\"\n             \"\\nReturns the estimated network hashes per second based on the last n blocks.\\n\"\n             \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\n@@ -149,7 +147,7 @@ UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nG\n UniValue generate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"generate nblocks ( maxtries )\\n\"\n             \"\\nMine up to nblocks blocks immediately (before the RPC call returns)\\n\"\n             \"\\nArguments:\\n\"\n@@ -185,7 +183,7 @@ UniValue generate(const JSONRPCRequest& request)\n UniValue generatetoaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"generatetoaddress nblocks address (maxtries)\\n\"\n             \"\\nMine blocks immediately to a specified address (before the RPC call returns)\\n\"\n             \"\\nArguments:\\n\"\n@@ -208,7 +206,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n     CBitcoinAddress address(request.params[1].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\n-    \n+\n     boost::shared_ptr<CReserveScript> coinbaseScript(new CReserveScript());\n     coinbaseScript->reserveScript = GetScriptForDestination(address.Get());\n \n@@ -218,7 +216,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n UniValue getmininginfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmininginfo\\n\"\n             \"\\nReturns a json object containing mining-related information.\"\n             \"\\nResult:\\n\"\n@@ -259,7 +257,7 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"prioritisetransaction <txid> <fee delta>\\n\"\n             \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n             \"\\nArguments:\\n\"\n@@ -315,7 +313,7 @@ std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n UniValue getblocktemplate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblocktemplate ( TemplateRequest )\\n\"\n             \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n             \"It returns data needed to construct a block to work on.\\n\"\n@@ -553,7 +551,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n     UniValue transactions(UniValue::VARR);\n-    map<uint256, int64_t> setTxIndex;\n+    std::map<uint256, int64_t> setTxIndex;\n     int i = 0;\n     for (const auto& it : pblock->vtx) {\n         const CTransaction& tx = *it;\n@@ -712,7 +710,7 @@ class submitblock_StateCatcher : public CValidationInterface\n UniValue submitblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"submitblock \\\"hexdata\\\" ( \\\"jsonparametersobject\\\" )\\n\"\n             \"\\nAttempts to submit new block to network.\\n\"\n             \"The 'jsonparametersobject' parameter is currently ignored.\\n\"\n@@ -777,7 +775,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n UniValue estimatefee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatefee nblocks\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks. Uses virtual transaction size of transaction\\n\"\n@@ -811,7 +809,7 @@ UniValue estimatefee(const JSONRPCRequest& request)\n UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatesmartfee nblocks\\n\"\n             \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\""
      },
      {
        "sha": "2a8f95b6157c5477ce61f548d50220d2aa264c38",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 30,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -25,8 +25,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n /**\n  * @note Do not add or change anything in the information returned by this\n  * method. `getinfo` exists for backwards-compatibility only. It combines\n@@ -43,7 +41,7 @@ using namespace std;\n UniValue getinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getinfo\\n\"\n             \"\\nDEPRECATED. Returns an object containing various state info.\\n\"\n             \"\\nResult:\\n\"\n@@ -94,7 +92,7 @@ UniValue getinfo(const JSONRPCRequest& request)\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     if(g_connman)\n         obj.push_back(Pair(\"connections\",   (int)g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL)));\n-    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : std::string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"testnet\",       Params().NetworkIDString() == CBaseChainParams::TESTNET));\n #ifdef ENABLE_WALLET\n@@ -159,7 +157,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n UniValue validateaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"validateaddress \\\"address\\\"\\n\"\n             \"\\nReturn information about the given bitcoin address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -200,7 +198,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n     if (isValid)\n     {\n         CTxDestination dest = address.Get();\n-        string currentAddress = address.ToString();\n+        std::string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n \n         CScript scriptPubKey = GetScriptForDestination(dest);\n@@ -248,13 +246,13 @@ CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& pa\n \n     // Gather public keys\n     if (nRequired < 1)\n-        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n+        throw std::runtime_error(\"a multisignature address must require at least one key to redeem\");\n     if ((int)keys.size() < nRequired)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             strprintf(\"not enough keys supplied \"\n                       \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n     if (keys.size() > 16)\n-        throw runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n+        throw std::runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n     std::vector<CPubKey> pubkeys;\n     pubkeys.resize(keys.size());\n     for (unsigned int i = 0; i < keys.size(); i++)\n@@ -266,15 +264,15 @@ CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& pa\n         if (pwallet && address.IsValid()) {\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n-                throw runtime_error(\n+                throw std::runtime_error(\n                     strprintf(\"%s does not refer to a key\",ks));\n             CPubKey vchPubKey;\n             if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n-                throw runtime_error(\n+                throw std::runtime_error(\n                     strprintf(\"no full public key for address %s\",ks));\n             }\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw std::runtime_error(\" Invalid public key: \"+ks);\n             pubkeys[i] = vchPubKey;\n         }\n \n@@ -285,18 +283,18 @@ CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& pa\n         {\n             CPubKey vchPubKey(ParseHex(ks));\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw std::runtime_error(\" Invalid public key: \"+ks);\n             pubkeys[i] = vchPubKey;\n         }\n         else\n         {\n-            throw runtime_error(\" Invalid public key: \"+ks);\n+            throw std::runtime_error(\" Invalid public key: \"+ks);\n         }\n     }\n     CScript result = GetScriptForMultisig(nRequired, pubkeys);\n \n     if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                 strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n \n     return result;\n@@ -312,7 +310,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n     {\n-        string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n+        std::string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n             \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n             \"It returns a json object with the address and redeemScript.\\n\"\n \n@@ -336,7 +334,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n             \"\\nAs a json rpc call\\n\"\n             + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     // Construct using pay-to-script-hash:\n@@ -354,7 +352,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n UniValue verifymessage(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifymessage \\\"address\\\" \\\"signature\\\" \\\"message\\\"\\n\"\n             \"\\nVerify a signed message\\n\"\n             \"\\nArguments:\\n\"\n@@ -376,9 +374,9 @@ UniValue verifymessage(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    string strAddress  = request.params[0].get_str();\n-    string strSign     = request.params[1].get_str();\n-    string strMessage  = request.params[2].get_str();\n+    std::string strAddress  = request.params[0].get_str();\n+    std::string strSign     = request.params[1].get_str();\n+    std::string strMessage  = request.params[2].get_str();\n \n     CBitcoinAddress addr(strAddress);\n     if (!addr.IsValid())\n@@ -389,7 +387,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n \n     bool fInvalid = false;\n-    vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n+    std::vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n \n     if (fInvalid)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n@@ -408,7 +406,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signmessagewithprivkey \\\"privkey\\\" \\\"message\\\"\\n\"\n             \"\\nSign a message with the private key of an address\\n\"\n             \"\\nArguments:\\n\"\n@@ -425,8 +423,8 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"signmessagewithprivkey\", \"\\\"privkey\\\", \\\"my message\\\"\")\n         );\n \n-    string strPrivkey = request.params[0].get_str();\n-    string strMessage = request.params[1].get_str();\n+    std::string strPrivkey = request.params[0].get_str();\n+    std::string strMessage = request.params[1].get_str();\n \n     CBitcoinSecret vchSecret;\n     bool fGood = vchSecret.SetString(strPrivkey);\n@@ -440,7 +438,7 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n     ss << strMessageMagic;\n     ss << strMessage;\n \n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!key.SignCompact(ss.GetHash(), vchSig))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n \n@@ -450,7 +448,7 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n UniValue setmocktime(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setmocktime timestamp\\n\"\n             \"\\nSet the local time to given timestamp (-regtest only)\\n\"\n             \"\\nArguments:\\n\"\n@@ -459,7 +457,7 @@ UniValue setmocktime(const JSONRPCRequest& request)\n         );\n \n     if (!Params().MineBlocksOnDemand())\n-        throw runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n+        throw std::runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n \n     // For now, don't change mocktime if we're in the middle of validation, as\n     // this could have an effect on mempool time-based eviction, as well as\n@@ -493,7 +491,7 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n      * as users will undoubtedly confuse it with the other \"memory pool\"\n      */\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmemoryinfo\\n\"\n             \"Returns an object containing information about memory usage.\\n\"\n             \"\\nResult:\\n\"\n@@ -519,7 +517,7 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n UniValue echo(const JSONRPCRequest& request)\n {\n     if (request.fHelp)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"echo|echojson \\\"message\\\" ...\\n\"\n             \"\\nSimply echo back the input arguments. This command is for testing.\\n\"\n             \"\\nThe difference between echo and echojson is that echojson has argument conversion enabled in the client-side table in\""
      },
      {
        "sha": "b946a64ec6fd757a01d221fda624b3da1e2a15e1",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -23,12 +23,10 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n UniValue getconnectioncount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getconnectioncount\\n\"\n             \"\\nReturns the number of connections to other nodes.\\n\"\n             \"\\nResult:\\n\"\n@@ -47,7 +45,7 @@ UniValue getconnectioncount(const JSONRPCRequest& request)\n UniValue ping(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"ping\\n\"\n             \"\\nRequests that a ping be sent to all other nodes, to measure ping time.\\n\"\n             \"Results provided in getpeerinfo, pingtime and pingwait fields are decimal seconds.\\n\"\n@@ -70,7 +68,7 @@ UniValue ping(const JSONRPCRequest& request)\n UniValue getpeerinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getpeerinfo\\n\"\n             \"\\nReturns data about each connected network node as a json array of objects.\\n\"\n             \"\\nResult:\\n\"\n@@ -102,7 +100,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"       n,                        (numeric) The heights of blocks we're currently asking from this peer\\n\"\n             \"       ...\\n\"\n             \"    ],\\n\"\n-            \"    \\\"whitelisted\\\": true|false, (boolean) Whether the peer is whitelisted\\n\"\t\t\t\t\t\n+            \"    \\\"whitelisted\\\": true|false, (boolean) Whether the peer is whitelisted\\n\"\n             \"    \\\"bytessent_per_msg\\\": {\\n\"\n             \"       \\\"addr\\\": n,              (numeric) The total bytes sent aggregated by message type\\n\"\n             \"       ...\\n\"\n@@ -122,7 +120,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    vector<CNodeStats> vstats;\n+    std::vector<CNodeStats> vstats;\n     g_connman->GetNodeStats(vstats);\n \n     UniValue ret(UniValue::VARR);\n@@ -191,12 +189,12 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n \n UniValue addnode(const JSONRPCRequest& request)\n {\n-    string strCommand;\n+    std::string strCommand;\n     if (request.params.size() == 2)\n         strCommand = request.params[1].get_str();\n     if (request.fHelp || request.params.size() != 2 ||\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n             \"\\nAttempts add or remove a node from the addnode list.\\n\"\n             \"Or try a connection to a node once.\\n\"\n@@ -211,7 +209,7 @@ UniValue addnode(const JSONRPCRequest& request)\n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    string strNode = request.params[0].get_str();\n+    std::string strNode = request.params[0].get_str();\n \n     if (strCommand == \"onetry\")\n     {\n@@ -237,7 +235,7 @@ UniValue addnode(const JSONRPCRequest& request)\n UniValue disconnectnode(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"disconnectnode \\\"node\\\" \\n\"\n             \"\\nImmediately disconnects from the specified node.\\n\"\n             \"\\nArguments:\\n\"\n@@ -260,7 +258,7 @@ UniValue disconnectnode(const JSONRPCRequest& request)\n UniValue getaddednodeinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaddednodeinfo ( \\\"node\\\" )\\n\"\n             \"\\nReturns information about the given added node, or all added nodes\\n\"\n             \"(note that onetry addnodes are not listed here)\\n\"\n@@ -328,7 +326,7 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n UniValue getnettotals(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnettotals\\n\"\n             \"\\nReturns information about network traffic, including bytes in, bytes out,\\n\"\n             \"and current time.\\n\"\n@@ -384,7 +382,7 @@ static UniValue GetNetworksInfo()\n         obj.push_back(Pair(\"name\", GetNetworkName(network)));\n         obj.push_back(Pair(\"limited\", IsLimited(network)));\n         obj.push_back(Pair(\"reachable\", IsReachable(network)));\n-        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string()));\n+        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.proxy.ToStringIPPort() : std::string()));\n         obj.push_back(Pair(\"proxy_randomize_credentials\", proxy.randomize_credentials));\n         networks.push_back(obj);\n     }\n@@ -394,7 +392,7 @@ static UniValue GetNetworksInfo()\n UniValue getnetworkinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnetworkinfo\\n\"\n             \"Returns an object containing various state info regarding P2P networking.\\n\"\n             \"\\nResult:\\n\"\n@@ -469,12 +467,12 @@ UniValue getnetworkinfo(const JSONRPCRequest& request)\n \n UniValue setban(const JSONRPCRequest& request)\n {\n-    string strCommand;\n+    std::string strCommand;\n     if (request.params.size() >= 2)\n         strCommand = request.params[1].get_str();\n     if (request.fHelp || request.params.size() < 2 ||\n         (strCommand != \"add\" && strCommand != \"remove\"))\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"setban \\\"subnet\\\" \\\"add|remove\\\" (bantime) (absolute)\\n\"\n                             \"\\nAttempts add or remove a IP/Subnet from the banned list.\\n\"\n                             \"\\nArguments:\\n\"\n@@ -494,7 +492,7 @@ UniValue setban(const JSONRPCRequest& request)\n     CNetAddr netAddr;\n     bool isSubnet = false;\n \n-    if (request.params[0].get_str().find(\"/\") != string::npos)\n+    if (request.params[0].get_str().find(\"/\") != std::string::npos)\n         isSubnet = true;\n \n     if (!isSubnet) {\n@@ -534,7 +532,7 @@ UniValue setban(const JSONRPCRequest& request)\n UniValue listbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"listbanned\\n\"\n                             \"\\nList all banned IPs/Subnets.\\n\"\n                             \"\\nExamples:\\n\"\n@@ -567,7 +565,7 @@ UniValue listbanned(const JSONRPCRequest& request)\n UniValue clearbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"clearbanned\\n\"\n                             \"\\nClear all banned IPs.\\n\"\n                             \"\\nExamples:\\n\"\n@@ -585,7 +583,7 @@ UniValue clearbanned(const JSONRPCRequest& request)\n UniValue setnetworkactive(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setnetworkactive true|false\\n\"\n             \"\\nDisable/enable all p2p network activity.\\n\"\n             \"\\nArguments:\\n\""
      },
      {
        "sha": "2be1edb5a6f50216ed2bfe015480789d4cca26e4",
        "filename": "src/rpc/protocol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -15,8 +15,6 @@\n #include <stdint.h>\n #include <fstream>\n \n-using namespace std;\n-\n /**\n  * JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n  * but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n@@ -26,7 +24,7 @@ using namespace std;\n  * 1.2 spec: http://jsonrpc.org/historical/json-rpc-over-http.html\n  */\n \n-UniValue JSONRPCRequestObj(const string& strMethod, const UniValue& params, const UniValue& id)\n+UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id)\n {\n     UniValue request(UniValue::VOBJ);\n     request.push_back(Pair(\"method\", strMethod));\n@@ -47,13 +45,13 @@ UniValue JSONRPCReplyObj(const UniValue& result, const UniValue& error, const Un\n     return reply;\n }\n \n-string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id)\n+std::string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id)\n {\n     UniValue reply = JSONRPCReplyObj(result, error, id);\n     return reply.write() + \"\\n\";\n }\n \n-UniValue JSONRPCError(int code, const string& message)\n+UniValue JSONRPCError(int code, const std::string& message)\n {\n     UniValue error(UniValue::VOBJ);\n     error.push_back(Pair(\"code\", code));"
      },
      {
        "sha": "c438d90a479d39bb630049679821afd9284d2e0e",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 37,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -34,12 +34,10 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex)\n {\n     txnouttype type;\n-    vector<CTxDestination> addresses;\n+    std::vector<CTxDestination> addresses;\n     int nRequired;\n \n     out.push_back(Pair(\"asm\", ScriptToAsmStr(scriptPubKey)));\n@@ -127,7 +125,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n UniValue getrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawtransaction \\\"txid\\\" ( verbose )\\n\"\n \n             \"\\nNOTE: By default this function only works for mempool transactions. If the -txindex option is\\n\"\n@@ -215,7 +213,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n         }\n         else {\n             throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid type provided. Verbose parameter must be a boolean.\");\n-        } \n+        }\n     }\n \n     CTransactionRef tx;\n@@ -225,7 +223,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n             : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\") +\n             \". Use gettransaction for wallet transactions.\");\n \n-    string strHex = EncodeHexTx(*tx, RPCSerializationFlags());\n+    std::string strHex = EncodeHexTx(*tx, RPCSerializationFlags());\n \n     if (!fVerbose)\n         return strHex;\n@@ -239,7 +237,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n UniValue gettxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxoutproof [\\\"txid\\\",...] ( blockhash )\\n\"\n             \"\\nReturns a hex-encoded proof that \\\"txid\\\" was included in a block.\\n\"\n             \"\\nNOTE: By default this function only works sometimes. This is when there is an\\n\"\n@@ -257,16 +255,16 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             \"\\\"data\\\"           (string) A string that is a serialized, hex-encoded data for the proof.\\n\"\n         );\n \n-    set<uint256> setTxids;\n+    std::set<uint256> setTxids;\n     uint256 oneTxid;\n     UniValue txids = request.params[0].get_array();\n     for (unsigned int idx = 0; idx < txids.size(); idx++) {\n         const UniValue& txid = txids[idx];\n         if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid txid \")+txid.get_str());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid txid \")+txid.get_str());\n         uint256 hash(uint256S(txid.get_str()));\n         if (setTxids.count(hash))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\n        setTxids.insert(hash);\n        oneTxid = hash;\n     }\n@@ -319,7 +317,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n UniValue verifytxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifytxoutproof \\\"proof\\\"\\n\"\n             \"\\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\\n\"\n             \"and throwing an RPC error if the block is not in our best chain\\n\"\n@@ -335,8 +333,8 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n     UniValue res(UniValue::VARR);\n \n-    vector<uint256> vMatch;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatch;\n+    std::vector<unsigned int> vIndex;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\n         return res;\n \n@@ -353,7 +351,7 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime )\\n\"\n             \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n             \"Outputs can be addresses or data.\\n\"\n@@ -434,9 +432,9 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         rawTx.vin.push_back(in);\n     }\n \n-    set<CBitcoinAddress> setAddress;\n-    vector<string> addrList = sendTo.getKeys();\n-    BOOST_FOREACH(const string& name_, addrList) {\n+    std::set<CBitcoinAddress> setAddress;\n+    std::vector<std::string> addrList = sendTo.getKeys();\n+    BOOST_FOREACH(const std::string& name_, addrList) {\n \n         if (name_ == \"data\") {\n             std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\n@@ -446,10 +444,10 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         } else {\n             CBitcoinAddress address(name_);\n             if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+name_);\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n \n             if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+name_);\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n             setAddress.insert(address);\n \n             CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -466,7 +464,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n UniValue decoderawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"decoderawtransaction \\\"hexstring\\\"\\n\"\n             \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\"\n \n@@ -535,7 +533,7 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n UniValue decodescript(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"decodescript \\\"hexstring\\\"\\n\"\n             \"\\nDecode a hex-encoded script.\\n\"\n             \"\\nArguments:\\n\"\n@@ -562,7 +560,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n     UniValue r(UniValue::VOBJ);\n     CScript script;\n     if (request.params[0].get_str().size() > 0){\n-        vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\n+        std::vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\n         script = CScript(scriptData.begin(), scriptData.end());\n     } else {\n         // Empty scripts are valid\n@@ -600,7 +598,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #endif\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\n             \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n             \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n@@ -665,9 +663,9 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #endif\n     RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR)(UniValue::VARR)(UniValue::VSTR), true);\n \n-    vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n+    std::vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    vector<CMutableTransaction> txVariants;\n+    std::vector<CMutableTransaction> txVariants;\n     while (!ssData.empty()) {\n         try {\n             CMutableTransaction tx;\n@@ -750,13 +748,13 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n             if (nOut < 0)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n \n-            vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n+            std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n                 CCoinsModifier coins = view.ModifyCoins(txid);\n                 if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n-                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n+                    std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n@@ -782,7 +780,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n                     });\n                 UniValue v = find_value(prevOut, \"redeemScript\");\n                 if (!v.isNull()) {\n-                    vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n+                    std::vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n                     CScript redeemScript(rsData.begin(), rsData.end());\n                     tempKeystore.AddCScript(redeemScript);\n                 }\n@@ -798,16 +796,16 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n     int nHashType = SIGHASH_ALL;\n     if (request.params.size() > 3 && !request.params[3].isNull()) {\n-        static map<string, int> mapSigHashValues =\n+        static std::map<std::string, int> mapSigHashValues =\n             boost::assign::map_list_of\n-            (string(\"ALL\"), int(SIGHASH_ALL))\n-            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n-            (string(\"NONE\"), int(SIGHASH_NONE))\n-            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n-            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n-            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n+            (std::string(\"ALL\"), int(SIGHASH_ALL))\n+            (std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n+            (std::string(\"NONE\"), int(SIGHASH_NONE))\n+            (std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n+            (std::string(\"SINGLE\"), int(SIGHASH_SINGLE))\n+            (std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n             ;\n-        string strHashType = request.params[3].get_str();\n+        std::string strHashType = request.params[3].get_str();\n         if (mapSigHashValues.count(strHashType))\n             nHashType = mapSigHashValues[strHashType];\n         else\n@@ -867,7 +865,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n UniValue sendrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendrawtransaction \\\"hexstring\\\" ( allowhighfees )\\n\"\n             \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n             \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\""
      },
      {
        "sha": "f689b4a28eb7b57ad74eb00e6fc645262c509b55",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 29,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3c264e9a6deaa12e89faa783d3c7c99b945f18e/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "patch": "@@ -26,9 +26,6 @@\n #include <memory> // for unique_ptr\n #include <unordered_map>\n \n-using namespace RPCServer;\n-using namespace std;\n-\n static bool fRPCRunning = false;\n static bool fRPCInWarmup = true;\n static std::string rpcWarmupStatus(\"RPC server started\");\n@@ -67,7 +64,7 @@ void RPCServer::OnPostCommand(boost::function<void (const CRPCCommand&)> slot)\n }\n \n void RPCTypeCheck(const UniValue& params,\n-                  const list<UniValue::VType>& typesExpected,\n+                  const std::list<UniValue::VType>& typesExpected,\n                   bool fAllowNull)\n {\n     unsigned int i = 0;\n@@ -92,7 +89,7 @@ void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected)\n }\n \n void RPCTypeCheckObj(const UniValue& o,\n-    const map<string, UniValueType>& typesExpected,\n+    const std::map<std::string, UniValueType>& typesExpected,\n     bool fAllowNull,\n     bool fStrict)\n {\n@@ -102,19 +99,19 @@ void RPCTypeCheckObj(const UniValue& o,\n             throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first));\n \n         if (!(t.second.typeAny || v.type() == t.second.type || (fAllowNull && v.isNull()))) {\n-            string err = strprintf(\"Expected type %s for %s, got %s\",\n+            std::string err = strprintf(\"Expected type %s for %s, got %s\",\n                 uvTypeName(t.second.type), t.first, uvTypeName(v.type()));\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n     }\n \n     if (fStrict)\n     {\n-        BOOST_FOREACH(const string& k, o.getKeys())\n+        BOOST_FOREACH(const std::string& k, o.getKeys())\n         {\n             if (typesExpected.count(k) == 0)\n             {\n-                string err = strprintf(\"Unexpected key %s\", k);\n+                std::string err = strprintf(\"Unexpected key %s\", k);\n                 throw JSONRPCError(RPC_TYPE_ERROR, err);\n             }\n         }\n@@ -143,9 +140,9 @@ UniValue ValueFromAmount(const CAmount& amount)\n             strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\n }\n \n-uint256 ParseHashV(const UniValue& v, string strName)\n+uint256 ParseHashV(const UniValue& v, std::string strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.get_str();\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n@@ -156,20 +153,20 @@ uint256 ParseHashV(const UniValue& v, string strName)\n     result.SetHex(strHex);\n     return result;\n }\n-uint256 ParseHashO(const UniValue& o, string strKey)\n+uint256 ParseHashO(const UniValue& o, std::string strKey)\n {\n     return ParseHashV(find_value(o, strKey), strKey);\n }\n-vector<unsigned char> ParseHexV(const UniValue& v, string strName)\n+std::vector<unsigned char> ParseHexV(const UniValue& v, std::string strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.get_str();\n     if (!IsHex(strHex))\n         throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n     return ParseHex(strHex);\n }\n-vector<unsigned char> ParseHexO(const UniValue& o, string strKey)\n+std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey)\n {\n     return ParseHexV(find_value(o, strKey), strKey);\n }\n@@ -180,23 +177,23 @@ vector<unsigned char> ParseHexO(const UniValue& o, string strKey)\n \n std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest& helpreq) const\n {\n-    string strRet;\n-    string category;\n-    set<rpcfn_type> setDone;\n-    vector<pair<string, const CRPCCommand*> > vCommands;\n+    std::string strRet;\n+    std::string category;\n+    std::set<rpcfn_type> setDone;\n+    std::vector<std::pair<std::string, const CRPCCommand*> > vCommands;\n \n-    for (map<string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n+    for (std::map<std::string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n         vCommands.push_back(make_pair(mi->second->category + mi->first, mi->second));\n     sort(vCommands.begin(), vCommands.end());\n \n     JSONRPCRequest jreq(helpreq);\n     jreq.fHelp = true;\n     jreq.params = UniValue();\n \n-    BOOST_FOREACH(const PAIRTYPE(string, const CRPCCommand*)& command, vCommands)\n+    BOOST_FOREACH(const PAIRTYPE(std::string, const CRPCCommand*)& command, vCommands)\n     {\n         const CRPCCommand *pcmd = command.second;\n-        string strMethod = pcmd->name;\n+        std::string strMethod = pcmd->name;\n         if ((strCommand != \"\" || pcmd->category == \"hidden\") && strMethod != strCommand)\n             continue;\n         jreq.strMethod = strMethod;\n@@ -209,18 +206,18 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n         catch (const std::exception& e)\n         {\n             // Help text is returned in an exception\n-            string strHelp = string(e.what());\n+            std::string strHelp = std::string(e.what());\n             if (strCommand == \"\")\n             {\n-                if (strHelp.find('\\n') != string::npos)\n+                if (strHelp.find('\\n') != std::string::npos)\n                     strHelp = strHelp.substr(0, strHelp.find('\\n'));\n \n                 if (category != pcmd->category)\n                 {\n                     if (!category.empty())\n                         strRet += \"\\n\";\n                     category = pcmd->category;\n-                    string firstLetter = category.substr(0,1);\n+                    std::string firstLetter = category.substr(0,1);\n                     boost::to_upper(firstLetter);\n                     strRet += \"== \" + firstLetter + category.substr(1) + \" ==\\n\";\n                 }\n@@ -237,7 +234,7 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n UniValue help(const JSONRPCRequest& jsonRequest)\n {\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"help ( \\\"command\\\" )\\n\"\n             \"\\nList all commands, or get help for a specified command.\\n\"\n             \"\\nArguments:\\n\"\n@@ -246,7 +243,7 @@ UniValue help(const JSONRPCRequest& jsonRequest)\n             \"\\\"text\\\"     (string) The help text\\n\"\n         );\n \n-    string strCommand;\n+    std::string strCommand;\n     if (jsonRequest.params.size() > 0)\n         strCommand = jsonRequest.params[0].get_str();\n \n@@ -258,7 +255,7 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n {\n     // Accept the deprecated and ignored 'detach' boolean argument\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"stop\\n\"\n             \"\\nStop Bitcoin server.\");\n     // Event loop will exit after current HTTP requests have been handled, so\n@@ -292,7 +289,7 @@ CRPCTable::CRPCTable()\n \n const CRPCCommand *CRPCTable::operator[](const std::string &name) const\n {\n-    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n+    std::map<std::string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it == mapCommands.end())\n         return NULL;\n     return (*it).second;\n@@ -304,7 +301,7 @@ bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)\n         return false;\n \n     // don't allow overwriting for now\n-    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n+    std::map<std::string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it != mapCommands.end())\n         return false;\n "
      }
    ]
  },
  {
    "sha": "8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Y2JmYzRlNDcyMTZjYmY5ZTNlNzU4NjA0ZTIzOTUxZjQwZDc2Y2Y5",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-04T05:42:14Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-03-08T16:08:17Z"
      },
      "message": "Refactor: Remove using namespace <xxx> from script/",
      "tree": {
        "sha": "4c4dda796b108f27286cd73b63307b5b4109a53d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c4dda796b108f27286cd73b63307b5b4109a53d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYwCxxAAoJEFevdi2zNTMiOX4QAIybFLJV4/1Hi5e7bP8MDTUS\ncIjM4Z+eezNcF8NdabZcJ1ebLjAiNfWk7EyKzwPcEGT2XB+Oa1qvzvdH8kUmotBS\njkn0Gsb/WVS6CJGpHqXoakGD5mLpY5LG9m8BkA51JFJymbthyI3kj+KQYmvaRzBU\nuGD2g5fMJv0af2Jq3+/1BiZGWU0H4LCPGYT3YLpcvMaJklvPuAE/Z6GccfzkemC2\njkf2LyW2pD5R/IIvOJ6hBRM5h7okGo40TI27brql5CIWug9IH+B+ZwS3Srl0ji3k\nFXRYR2XsmNJOm3I9F/BNd4qzX4uaCQYdsxdlWIh3pqH8Okh9tRiGfQl2qDa5h0ei\nsHuS9fiuTPavIGCTnFAh4vDjtaXle7GdRwUEfUtnJZOaLRl1XyqaAP1tw5awW/K8\nzPFCBrso6/HGKOjgZBFsMS2Zl8W0g9O9CDUis77tDNVL2s+2LJY3A6rqDcJazLSW\nOq63l9LL7bkhSNiwTZ1mHJ+LtAjwof3k7JKlSvPE4KVGucEuqQwAiEJd+2uYRfPF\nS6ggPc4CgCpltZkIo2x3xrsIcrLTlWpfHdp7EN33erX8y1eI30+4Hsm+dBbw6wNH\nLUeBcHv82pLtF6HppIJ0rpMK14mJZb46p8ZXxIs+Fby3+sggpYkA1h+sGFlr4Z79\nIR3UI30ZBGTdcXZnKmHm\n=ryFS\n-----END PGP SIGNATURE-----",
        "payload": "tree 4c4dda796b108f27286cd73b63307b5b4109a53d\nparent f3c264e9a6deaa12e89faa783d3c7c99b945f18e\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1483508534 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1488989297 -0800\n\nRefactor: Remove using namespace <xxx> from script/\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3c264e9a6deaa12e89faa783d3c7c99b945f18e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3c264e9a6deaa12e89faa783d3c7c99b945f18e"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 41,
      "deletions": 51
    },
    "files": [
      {
        "sha": "8ecf0bbdacbc895b094085dfe584b1c812d9dd5b",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
        "patch": "@@ -13,9 +13,7 @@\n #include \"script/script.h\"\n #include \"uint256.h\"\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n namespace {\n \n@@ -56,10 +54,10 @@ bool CastToBool(const valtype& vch)\n  */\n #define stacktop(i)  (stack.at(stack.size()+(i)))\n #define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n-static inline void popstack(vector<valtype>& stack)\n+static inline void popstack(std::vector<valtype>& stack)\n {\n     if (stack.empty())\n-        throw runtime_error(\"popstack(): stack empty\");\n+        throw std::runtime_error(\"popstack(): stack empty\");\n     stack.pop_back();\n }\n \n@@ -194,7 +192,7 @@ bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n     return true;\n }\n \n-bool CheckSignatureEncoding(const vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror) {\n+bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror) {\n     // Empty signature. Not strictly DER encoded, but allowed to provide a\n     // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n     if (vchSig.size() == 0) {\n@@ -245,7 +243,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -260,8 +258,8 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    vector<bool> vfExec;\n-    vector<valtype> altstack;\n+    std::vector<bool> vfExec;\n+    std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     if (script.size() > MAX_SCRIPT_SIZE)\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n@@ -1250,14 +1248,14 @@ bool TransactionSignatureChecker::VerifySignature(const std::vector<unsigned cha\n     return pubkey.Verify(sighash, vchSig);\n }\n \n-bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool TransactionSignatureChecker::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n         return false;\n \n     // Hash type is one byte tacked on to the end of the signature\n-    vector<unsigned char> vchSig(vchSigIn);\n+    std::vector<unsigned char> vchSig(vchSigIn);\n     if (vchSig.empty())\n         return false;\n     int nHashType = vchSig.back();\n@@ -1355,7 +1353,7 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n \n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n-    vector<vector<unsigned char> > stack;\n+    std::vector<std::vector<unsigned char> > stack;\n     CScript scriptPubKey;\n \n     if (witversion == 0) {\n@@ -1420,7 +1418,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n-    vector<vector<unsigned char> > stack, stackCopy;\n+    std::vector<std::vector<unsigned char> > stack, stackCopy;\n     if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n@@ -1558,7 +1556,7 @@ size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey,\n \n     if (scriptPubKey.IsPayToScriptHash() && scriptSig.IsPushOnly()) {\n         CScript::const_iterator pc = scriptSig.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < scriptSig.end()) {\n             opcodetype opcode;\n             scriptSig.GetOp(pc, opcode, data);"
      },
      {
        "sha": "a4743281b1c8a85513c3296a01a60c8e0dcb5df7",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
        "patch": "@@ -13,11 +13,9 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n+typedef std::vector<unsigned char> valtype;\n \n-typedef vector<unsigned char> valtype;\n-\n-unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n+unsigned int HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n     unsigned int nResult = 0;\n     BOOST_FOREACH(const valtype& pubkey, pubkeys)\n@@ -49,7 +47,7 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions)) {\n         if (keystore.HaveWatchOnly(scriptPubKey))\n@@ -132,7 +130,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         // partially owned (somebody else has a key that can spend\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n-        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n         if (sigversion != SIGVERSION_BASE) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {"
      },
      {
        "sha": "70eb8a139b0a8f6ea6bb8890a8c4de774038a7a4",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
        "patch": "@@ -8,8 +8,6 @@\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n const char* GetOpName(opcodetype opcode)\n {\n     switch (opcode)\n@@ -186,7 +184,7 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     // get the last item that the scriptSig\n     // pushes onto the stack:\n     const_iterator pc = scriptSig.begin();\n-    vector<unsigned char> vData;\n+    std::vector<unsigned char> vData;\n     while (pc < scriptSig.end())\n     {\n         opcodetype opcode;"
      },
      {
        "sha": "5682418546640685619a4653657892d3af37b1a7",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
        "patch": "@@ -14,8 +14,6 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n typedef std::vector<unsigned char> valtype;\n \n TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n@@ -39,14 +37,14 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n \n static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!creator.CreateSig(vchSig, address, scriptCode, sigversion))\n         return false;\n     ret.push_back(vchSig);\n     return true;\n }\n \n-static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n+static bool SignN(const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n@@ -73,7 +71,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n     uint160 h160;\n     ret.clear();\n \n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n         return false;\n \n@@ -125,7 +123,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n     }\n }\n \n-static CScript PushAll(const vector<valtype>& values)\n+static CScript PushAll(const std::vector<valtype>& values)\n {\n     CScript result;\n     BOOST_FOREACH(const valtype& v, values) {\n@@ -228,12 +226,12 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutab\n     return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n-static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                               const vector<valtype>& vSolutions,\n-                               const vector<valtype>& sigs1, const vector<valtype>& sigs2, SigVersion sigversion)\n+static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+                               const std::vector<valtype>& vSolutions,\n+                               const std::vector<valtype>& sigs1, const std::vector<valtype>& sigs2, SigVersion sigversion)\n {\n     // Combine all the signatures we've got:\n-    set<valtype> allsigs;\n+    std::set<valtype> allsigs;\n     BOOST_FOREACH(const valtype& v, sigs1)\n     {\n         if (!v.empty())\n@@ -249,7 +247,7 @@ static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSi\n     assert(vSolutions.size() > 1);\n     unsigned int nSigsRequired = vSolutions.front()[0];\n     unsigned int nPubKeys = vSolutions.size()-2;\n-    map<valtype, valtype> sigs;\n+    std::map<valtype, valtype> sigs;\n     BOOST_FOREACH(const valtype& sig, allsigs)\n     {\n         for (unsigned int i = 0; i < nPubKeys; i++)\n@@ -306,7 +304,7 @@ struct Stacks\n }\n \n static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                                 const txnouttype txType, const vector<valtype>& vSolutions,\n+                                 const txnouttype txType, const std::vector<valtype>& vSolutions,\n                                  Stacks sigs1, Stacks sigs2, SigVersion sigversion)\n {\n     switch (txType)\n@@ -340,7 +338,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             CScript pubKey2(spk.begin(), spk.end());\n \n             txnouttype txType2;\n-            vector<vector<unsigned char> > vSolutions2;\n+            std::vector<std::vector<unsigned char> > vSolutions2;\n             Solver(pubKey2, txType2, vSolutions2);\n             sigs1.script.pop_back();\n             sigs2.script.pop_back();\n@@ -360,7 +358,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             // Recur to combine:\n             CScript pubKey2(sigs1.witness.back().begin(), sigs1.witness.back().end());\n             txnouttype txType2;\n-            vector<valtype> vSolutions2;\n+            std::vector<valtype> vSolutions2;\n             Solver(pubKey2, txType2, vSolutions2);\n             sigs1.witness.pop_back();\n             sigs1.script = sigs1.witness;\n@@ -383,7 +381,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n                           const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n {\n     txnouttype txType;\n-    vector<vector<unsigned char> > vSolutions;\n+    std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n     return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();"
      },
      {
        "sha": "63f20b099320968bdd55364abfb32c3b3538d1f1",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 13,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cbfc4e47216cbf9e3e758604e23951f40d76cf9/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=8cbfc4e47216cbf9e3e758604e23951f40d76cf9",
        "patch": "@@ -12,9 +12,7 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n bool fAcceptDatacarrier = DEFAULT_ACCEPT_DATACARRIER;\n unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY;\n@@ -40,20 +38,20 @@ const char* GetTxnOutputType(txnouttype t)\n /**\n  * Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n  */\n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n {\n     // Templates\n-    static multimap<txnouttype, CScript> mTemplates;\n+    static std::multimap<txnouttype, CScript> mTemplates;\n     if (mTemplates.empty())\n     {\n         // Standard tx, sender provides pubkey, receiver adds signature\n-        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n+        mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n \n         // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n+        mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n \n         // Sender provides N pubkeys, receivers provides M signatures\n-        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+        mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n     }\n \n     vSolutionsRet.clear();\n@@ -63,7 +61,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n     if (scriptPubKey.IsPayToScriptHash())\n     {\n         typeRet = TX_SCRIPTHASH;\n-        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n+        std::vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n         vSolutionsRet.push_back(hashBytes);\n         return true;\n     }\n@@ -102,7 +100,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n         vSolutionsRet.clear();\n \n         opcodetype opcode1, opcode2;\n-        vector<unsigned char> vch1, vch2;\n+        std::vector<unsigned char> vch1, vch2;\n \n         // Compare\n         CScript::const_iterator pc1 = script1.begin();\n@@ -181,7 +179,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n \n bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n {\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n@@ -209,11 +207,11 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n     return false;\n }\n \n-bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n+bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet)\n {\n     addressRet.clear();\n     typeRet = TX_NONSTANDARD;\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, typeRet, vSolutions))\n         return false;\n     if (typeRet == TX_NULL_DATA){"
      }
    ]
  }
]