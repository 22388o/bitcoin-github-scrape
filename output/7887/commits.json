[
  {
    "sha": "91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MWYwMGE2NmEwY2VlMzE0ZGNmOWNkN2Y4MmFhYzgwY2FhN2U0Njgw",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2016-04-15T14:48:43Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2016-04-15T20:18:56Z"
      },
      "message": "Remove mapBlockSource\n\nThis refactor is part of larger work I'm doing for faster\nblock relay. It was inspired by noticing that mapBlockSource\nis redundant with mapBlocksInFlight -- mapBlocksInFlight already\ncontains a mapping from blockhash to peer id.\n\nmapBlockSource was used to DoS-ban peers that send us bad blocks,\nbut the banning logic was sometimes broken-- InvalidBlockFound\ncould DoS ban, and then another ban for the same bad block would\nbe applied in ProcessMessages. Just removing mapBlockSource is\nthe simplest fix.\n\nThere is a corner case where a peer might have been banned before,\nbut will not get banned now: if we get an out-of-order block\nfrom a peer that double-spends an output spent in a previous block\nthat we don't yet have. The requirement that the block have valid\nproof-of-work prevents this from being a practical DoS attack.\n\nProcessNewBlock loses it's *pfrom argument, which is nice--\nProcessNewBlock shouldn't care about networking stuff.",
      "tree": {
        "sha": "dfefdd22a80ee9b37fbd0453a253644df811de83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dfefdd22a80ee9b37fbd0453a253644df811de83"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlcRTLwACgkQdYgkL74406hLigCff1zL2tl79AFRsS57J9qwKTB1\nLkQAoNddEnbiEYHtnNq14XkHGrsBt1s1\n=LYWz\n-----END PGP SIGNATURE-----",
        "payload": "tree dfefdd22a80ee9b37fbd0453a253644df811de83\nparent 73fc922ed64333d45f18d8a448f30cfa2ae0281e\nauthor Gavin Andresen <gavinandresen@gmail.com> 1460731723 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1460751536 -0400\n\nRemove mapBlockSource\n\nThis refactor is part of larger work I'm doing for faster\nblock relay. It was inspired by noticing that mapBlockSource\nis redundant with mapBlocksInFlight -- mapBlocksInFlight already\ncontains a mapping from blockhash to peer id.\n\nmapBlockSource was used to DoS-ban peers that send us bad blocks,\nbut the banning logic was sometimes broken-- InvalidBlockFound\ncould DoS ban, and then another ban for the same bad block would\nbe applied in ProcessMessages. Just removing mapBlockSource is\nthe simplest fix.\n\nThere is a corner case where a peer might have been banned before,\nbut will not get banned now: if we get an out-of-order block\nfrom a peer that double-spends an output spent in a previous block\nthat we don't yet have. The requirement that the block have valid\nproof-of-work prevents this from being a practical DoS attack.\n\nProcessNewBlock loses it's *pfrom argument, which is nice--\nProcessNewBlock shouldn't care about networking stuff.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "73fc922ed64333d45f18d8a448f30cfa2ae0281e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73fc922ed64333d45f18d8a448f30cfa2ae0281e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/73fc922ed64333d45f18d8a448f30cfa2ae0281e"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 9,
      "deletions": 33
    },
    "files": [
      {
        "sha": "f8c821cfc3be7a7a748820bb9a2a3082d8436a97",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 27,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
        "patch": "@@ -161,13 +161,6 @@ namespace {\n     /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n     uint32_t nBlockSequenceId = 1;\n \n-    /**\n-     * Sources of received blocks, saved to be able to send them reject\n-     * messages or ban them when processing happens afterwards. Protected by\n-     * cs_main.\n-     */\n-    map<uint256, NodeId> mapBlockSource;\n-\n     /**\n      * Filter for transactions that were recently rejected by\n      * AcceptToMemoryPool. These are not rerequested until the chain tip\n@@ -1725,17 +1718,6 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n }\n \n void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n-    int nDoS = 0;\n-    if (state.IsInvalid(nDoS)) {\n-        std::map<uint256, NodeId>::iterator it = mapBlockSource.find(pindex->GetBlockHash());\n-        if (it != mapBlockSource.end() && State(it->second)) {\n-            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n-            CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), pindex->GetBlockHash()};\n-            State(it->second)->rejects.push_back(reject);\n-            if (nDoS > 0)\n-                Misbehaving(it->second, nDoS);\n-        }\n-    }\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         setDirtyBlockIndex.insert(pindex);\n@@ -2711,7 +2693,6 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n                 InvalidBlockFound(pindexNew, state);\n             return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n         }\n-        mapBlockSource.erase(pindexNew->GetBlockHash());\n         nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;\n         LogPrint(\"bench\", \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);\n         assert(view.Flush());\n@@ -3481,7 +3462,7 @@ static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned\n }\n \n \n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CNode* pfrom, const CBlock* pblock, bool fForceProcessing, CDiskBlockPos* dbp)\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock, bool fForceProcessing, CDiskBlockPos* dbp)\n {\n     {\n         LOCK(cs_main);\n@@ -3491,9 +3472,6 @@ bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, c\n         // Store to disk\n         CBlockIndex *pindex = NULL;\n         bool ret = AcceptBlock(*pblock, state, chainparams, &pindex, fRequested, dbp);\n-        if (pindex && pfrom) {\n-            mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n-        }\n         CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret)\n             return error(\"%s: AcceptBlock FAILED\", __func__);\n@@ -3917,7 +3895,6 @@ void UnloadBlockIndex()\n     vinfoBlockFile.clear();\n     nLastBlockFile = 0;\n     nBlockSequenceId = 1;\n-    mapBlockSource.clear();\n     mapBlocksInFlight.clear();\n     nPreferredDownload = 0;\n     setDirtyBlockIndex.clear();\n@@ -4045,7 +4022,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 // process in case the block isn't known yet\n                 if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n                     CValidationState state;\n-                    if (ProcessNewBlock(state, chainparams, NULL, &block, true, dbp))\n+                    if (ProcessNewBlock(state, chainparams, &block, true, dbp))\n                         nLoaded++;\n                     if (state.IsError())\n                         break;\n@@ -4067,7 +4044,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                             LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n                                     head.ToString());\n                             CValidationState dummy;\n-                            if (ProcessNewBlock(dummy, chainparams, NULL, &block, true, &it->second))\n+                            if (ProcessNewBlock(dummy, chainparams, &block, true, &it->second))\n                             {\n                                 nLoaded++;\n                                 queue.push_back(block.GetHash());\n@@ -5185,7 +5162,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Such an unrequested block may still be processed, subject to the\n         // conditions in AcceptBlock().\n         bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n-        ProcessNewBlock(state, chainparams, pfrom, &block, forceProcessing, NULL);\n+        ProcessNewBlock(state, chainparams, &block, forceProcessing, NULL);\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes"
      },
      {
        "sha": "80f53a1daa0c84d0a3d09b038ebe60dcbbb14958",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
        "patch": "@@ -206,13 +206,12 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n  * specific block passed to it has been checked for validity!\n  * \n  * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n- * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n  * @param[in]   pblock  The block we want to process.\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n  * @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CNode* pfrom, const CBlock* pblock, bool fForceProcessing, CDiskBlockPos* dbp);\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock, bool fForceProcessing, CDiskBlockPos* dbp);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */"
      },
      {
        "sha": "67f9cbb69b6110e930447ead49103fb9006a1793",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
        "patch": "@@ -130,7 +130,7 @@ UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nG\n             continue;\n         }\n         CValidationState state;\n-        if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL))\n+        if (!ProcessNewBlock(state, Params(), pblock, true, NULL))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -635,7 +635,7 @@ UniValue submitblock(const UniValue& params, bool fHelp)\n     CValidationState state;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, NULL);\n+    bool fAccepted = ProcessNewBlock(state, Params(), &block, true, NULL);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent)\n     {"
      },
      {
        "sha": "65ac5ac25af41b3c1e8f663d6982a78cea2e102d",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
        "patch": "@@ -114,7 +114,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n+        BOOST_CHECK(ProcessNewBlock(state, chainparams, pblock, true, NULL));\n         BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      },
      {
        "sha": "061433b7e1687ddf99f47bac0d400f1aae86b885",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91f00a66a0cee314dcf9cd7f82aac80caa7e4680/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=91f00a66a0cee314dcf9cd7f82aac80caa7e4680",
        "patch": "@@ -137,7 +137,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     CValidationState state;\n-    ProcessNewBlock(state, chainparams, NULL, &block, true, NULL);\n+    ProcessNewBlock(state, chainparams, &block, true, NULL);\n \n     CBlock result = block;\n     delete pblocktemplate;"
      }
    ]
  }
]