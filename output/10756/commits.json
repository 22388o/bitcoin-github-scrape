[
  {
    "sha": "28f11e9406b185dc87144f1f29af0d93eb115b4e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOGYxMWU5NDA2YjE4NWRjODcxNDRmMWYyOWFmMGQ5M2ViMTE1YjRl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T17:53:52Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-06T23:03:39Z"
      },
      "message": "net: pass CConnman via pointer rather than reference\n\nThere are a few too many edge-cases here to make this a scripted diff.\n\nThe following commits will move a few functions into PeerLogicValidation, where\nthe local connman instance can be used. This change prepares for that usage.",
      "tree": {
        "sha": "27f8a55fc1e1ee47a682f6944b69190824c6dbcc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27f8a55fc1e1ee47a682f6944b69190824c6dbcc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28f11e9406b185dc87144f1f29af0d93eb115b4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28f11e9406b185dc87144f1f29af0d93eb115b4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/28f11e9406b185dc87144f1f29af0d93eb115b4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28f11e9406b185dc87144f1f29af0d93eb115b4e/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bcc8a620eae9cd8fe95f0a02f17183c4a132e5a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcc8a620eae9cd8fe95f0a02f17183c4a132e5a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bcc8a620eae9cd8fe95f0a02f17183c4a132e5a2"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 104,
      "deletions": 104
    },
    "files": [
      {
        "sha": "5e29e6fee4f5c6fafcfd784bdcb38d61cadae043",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "patch": "@@ -1114,7 +1114,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    GetNodeSignals().InitializeNode(pnode, *this);\n+    GetNodeSignals().InitializeNode(pnode, this);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1966,7 +1966,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (fAddnode)\n         pnode->fAddnode = true;\n \n-    GetNodeSignals().InitializeNode(pnode, *this);\n+    GetNodeSignals().InitializeNode(pnode, this);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1996,15 +1996,15 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, *this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, this, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n \n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                GetNodeSignals().SendMessages(pnode, *this, flagInterruptMsgProc);\n+                GetNodeSignals().SendMessages(pnode, this, flagInterruptMsgProc);\n             }\n             if (flagInterruptMsgProc)\n                 return;"
      },
      {
        "sha": "f170cdac25d7b03b5d174c48ee715876ca527ff7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "patch": "@@ -441,9 +441,9 @@ struct CombinerAll\n // Signals for message handling\n struct CNodeSignals\n {\n-    boost::signals2::signal<bool (CNode*, CConnman&, std::atomic<bool>&), CombinerAll> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, CConnman&, std::atomic<bool>&), CombinerAll> SendMessages;\n-    boost::signals2::signal<void (CNode*, CConnman&)> InitializeNode;\n+    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> ProcessMessages;\n+    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> SendMessages;\n+    boost::signals2::signal<void (CNode*, CConnman*)> InitializeNode;\n     boost::signals2::signal<void (NodeId, bool&)> FinalizeNode;\n };\n "
      },
      {
        "sha": "1e4713235daa968128fcc16dd43a561465cf9612",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 84,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "patch": "@@ -244,7 +244,7 @@ void UpdatePreferredDownload(CNode* node, CNodeState* state)\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n+void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n {\n     ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n     uint64_t nonce = pnode->GetLocalNonce();\n@@ -255,7 +255,7 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n-    connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+    connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n             nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes));\n \n     if (fLogIPs) {\n@@ -265,7 +265,7 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     }\n }\n \n-void InitializeNode(CNode *pnode, CConnman& connman) {\n+void InitializeNode(CNode *pnode, CConnman* connman) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n@@ -404,7 +404,7 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n-void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) {\n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n@@ -419,20 +419,20 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) {\n                 return;\n             }\n         }\n-        connman.ForNode(nodeid, [&connman](CNode* pfrom){\n+        connman->ForNode(nodeid, [connman](CNode* pfrom){\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n-                connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                    connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                connman->ForNode(lNodesAnnouncingHeaderAndIDs.front(), [connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                    connman->PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n                     return true;\n                 });\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n             }\n             fAnnounceUsingCMPCTBLOCK = true;\n-            connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman->PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n             return true;\n         });\n@@ -867,7 +867,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n              !IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n-            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n+            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n         }\n     }\n     if (it != mapBlockSource.end())\n@@ -912,24 +912,24 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     return true;\n }\n \n-static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n+static void RelayTransaction(const CTransaction& tx, CConnman* connman)\n {\n     CInv inv(MSG_TX, tx.GetHash());\n-    connman.ForEachNode([&inv](CNode* pnode)\n+    connman->ForEachNode([&inv](CNode* pnode)\n     {\n         pnode->PushInventory(inv);\n     });\n }\n \n-static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connman)\n+static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connman)\n {\n     unsigned int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n \n     // Relay to a limited number of other nodes\n     // Use deterministic randomness to send to the same nodes for 24 hours\n     // at a time so the addrKnowns of the chosen nodes prevent repeats\n     uint64_t hashAddr = addr.GetHash();\n-    const CSipHasher hasher = connman.GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));\n+    const CSipHasher hasher = connman->GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));\n     FastRandomContext insecure_rand;\n \n     std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};\n@@ -954,10 +954,10 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n         }\n     };\n \n-    connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n+    connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n@@ -1019,7 +1019,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n                 // never disconnect whitelisted nodes\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n-                if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+                if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n                     LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1042,9 +1042,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         pblock = pblockRead;\n                     }\n                     if (inv.type == MSG_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -1057,7 +1057,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             }\n                         }\n                         if (sendMerkleBlock) {\n-                            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                             // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                             // This avoids hurting performance by pointlessly requiring a round-trip\n                             // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -1066,7 +1066,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             for (PairType& pair : merkleBlock.vMatchedTxn)\n-                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+                                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n                             // no response\n@@ -1081,13 +1081,13 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n                             if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n-                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                             } else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                         } else {\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                            connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n                         }\n                     }\n \n@@ -1099,7 +1099,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // wait for other stuff first.\n                         std::vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                         pfrom->hashContinue.SetNull();\n                     }\n                 }\n@@ -1111,14 +1111,14 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 auto mi = mapRelay.find(inv.hash);\n                 int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n                 if (mi != mapRelay.end()) {\n-                    connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                     push = true;\n                 } else if (pfrom->timeLastMempoolReq) {\n                     auto txinfo = mempool.info(inv.hash);\n                     // To protect privacy, do not answer getdata using the mempool when\n                     // that TX couldn't have been INVed in reply to a MEMPOOL request.\n                     if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n+                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                         push = true;\n                     }\n                 }\n@@ -1145,7 +1145,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n         // do that because they want to know about (and store and rebroadcast and\n         // risk analyze) the dependencies of transactions relevant to them, without\n         // having to download the entire memory pool.\n-        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n+        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n@@ -1157,7 +1157,7 @@ uint32_t GetFetchFlags(CNode* pfrom) {\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman& connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n@@ -1171,10 +1171,10 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-    connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n+    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -1227,7 +1227,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -1251,12 +1251,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom->fInbound)\n         {\n-            connman.SetServices(pfrom->addr, nServices);\n+            connman->SetServices(pfrom->addr, nServices);\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1277,7 +1277,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1297,7 +1297,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!vRecv.empty())\n             vRecv >> fRelay;\n         // Disconnect if we connected to ourself\n-        if (pfrom->fInbound && !connman.CheckIncomingNonce(nNonce))\n+        if (pfrom->fInbound && !connman->CheckIncomingNonce(nNonce))\n         {\n             LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());\n             pfrom->fDisconnect = true;\n@@ -1313,7 +1313,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pfrom->fInbound)\n             PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n-        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom->nServices = nServices;\n         pfrom->SetAddrLocal(addrMe);\n@@ -1364,12 +1364,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n \n             // Get recent addresses\n-            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman.GetAddressCount() < 1000)\n+            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)\n             {\n-                connman.PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n+                connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n                 pfrom->fGetAddr = true;\n             }\n-            connman.MarkAddressGood(pfrom->addr);\n+            connman->MarkAddressGood(pfrom->addr);\n         }\n \n         std::string remoteAddr;\n@@ -1388,7 +1388,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // If the peer is old enough to have the old alert system, send it the final alert.\n         if (pfrom->nVersion <= 70012) {\n             CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);\n-            connman.PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n+            connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n         }\n \n         // Feeler connections exist only to verify if address is online.\n@@ -1426,7 +1426,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -1437,9 +1437,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom->fSuccessfullyConnected = true;\n     }\n@@ -1458,7 +1458,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < CADDR_TIME_VERSION && connman.GetAddressCount() > 1000)\n+        if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n             return true;\n         if (vAddr.size() > 1000)\n         {\n@@ -1492,7 +1492,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        connman.AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);\n+        connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom->fGetAddr = false;\n         if (pfrom->fOneShot)\n@@ -1570,7 +1570,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n                     LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n@@ -1776,7 +1776,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n-        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n     }\n \n \n@@ -1957,7 +1957,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n@@ -1977,7 +1977,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n         }\n@@ -2032,7 +2032,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n         }\n@@ -2076,7 +2076,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n \n@@ -2093,7 +2093,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     fProcessBLOCKTXN = true;\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n                 // This block is either already in flight from a different\n@@ -2119,7 +2119,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -2193,7 +2193,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -2274,7 +2274,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -2329,7 +2329,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -2379,7 +2379,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                 }\n             }\n         }\n@@ -2440,7 +2440,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->fSentAddr = true;\n \n         pfrom->vAddrToSend.clear();\n-        std::vector<CAddress> vAddr = connman.GetAddresses();\n+        std::vector<CAddress> vAddr = connman->GetAddresses();\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n@@ -2456,7 +2456,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        if (connman.OutboundTargetReached(false) && !pfrom->fWhitelisted)\n+        if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n             LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n@@ -2485,7 +2485,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n     }\n \n@@ -2631,13 +2631,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     return true;\n }\n \n-static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n+static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n {\n     AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n     for (const CBlockReject& reject : state.rejects) {\n-        connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+        connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n     }\n     state.rejects.clear();\n \n@@ -2653,15 +2653,15 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n                 LogPrintf(\"Warning: not banning local peer %s!\\n\", pnode->addr.ToString());\n             else\n             {\n-                connman.Ban(pnode->addr, BanReasonNodeMisbehaving);\n+                connman->Ban(pnode->addr, BanReasonNodeMisbehaving);\n             }\n         }\n         return true;\n     }\n     return false;\n }\n \n-bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2695,7 +2695,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n         // Just take one message\n         msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n         pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n-        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman->GetReceiveFloodSize();\n         fMoreWork = !pfrom->vProcessMsg.empty();\n     }\n     CNetMessage& msg(msgs.front());\n@@ -2744,7 +2744,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     }\n     catch (const std::ios_base::failure& e)\n     {\n-        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n         if (strstr(e.what(), \"end of data\"))\n         {\n             // Allow exceptions from under-length message on vRecv\n@@ -2798,7 +2798,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {\n@@ -2830,11 +2830,11 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->nPingUsecStart = GetTimeMicros();\n             if (pto->nVersion > BIP0031_VERSION) {\n                 pto->nPingNonceSent = nonce;\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive.\n                 pto->nPingNonceSent = 0;\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n             }\n         }\n \n@@ -2869,14 +2869,14 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)\n                     {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();\n@@ -2903,7 +2903,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -2912,7 +2912,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n         // transactions become unconfirmed and spams other nodes.\n         if (!fReindex && !fImporting && !IsInitialBlockDownload())\n         {\n-            GetMainSignals().Broadcast(nTimeBestReceived, &connman);\n+            GetMainSignals().Broadcast(nTimeBestReceived, connman);\n         }\n \n         //\n@@ -2996,10 +2996,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                             if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n-                                connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n+                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n-                                connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n                         }\n@@ -3009,7 +3009,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n                         CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                        connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n@@ -3022,7 +3022,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -3068,7 +3068,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             for (const uint256& hash : pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n             }\n@@ -3114,7 +3114,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                 }\n@@ -3180,15 +3180,15 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         }\n                     }\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n         if (!vInv.empty())\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n@@ -3283,7 +3283,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                     vGetData.clear();\n                 }\n             } else {\n@@ -3293,7 +3293,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n         //\n         // Message: feefilter\n@@ -3310,7 +3310,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n                 if (filterToSend != pto->lastSentFeeFilter) {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n                     pto->lastSentFeeFilter = filterToSend;\n                 }\n                 pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);"
      },
      {
        "sha": "461dc9a90d4af559c0bd47a4619a174de7eea548",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "patch": "@@ -53,7 +53,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n void Misbehaving(NodeId nodeid, int howmuch);\n \n /** Process protocol messages received from a given node */\n-bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& interrupt);\n+bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interrupt);\n /**\n  * Send queued protocol messages to be sent to a give node.\n  *\n@@ -62,6 +62,6 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n  * @param[in]   interrupt       Interrupt condition for processing threads\n  * @return                      True if there is more work to be done\n  */\n-bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interrupt);\n+bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interrupt);\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "39a75f7c820cef98f889cfaaf2b7f0a239553b6f",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28f11e9406b185dc87144f1f29af0d93eb115b4e/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode2, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode2, connman);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, *connman, interruptDummy);\n+    SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, *connman, interruptDummy);\n+    SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode, connman);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    SendMessages(&dummyNode, *connman, interruptDummy);\n+    SendMessages(&dummyNode, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      }
    ]
  },
  {
    "sha": "8ad663c1fa88d68843e45580deced56112343183",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YWQ2NjNjMWZhODhkNjg4NDNlNDU1ODBkZWNlZDU2MTEyMzQzMTgz",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T17:40:09Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-06T23:32:04Z"
      },
      "message": "net: use an interface class rather than signals for message processing\n\nDrop boost signals in favor of a stateful class. This will allow the message\nprocessing loop to actually move to net_processing in a future step.",
      "tree": {
        "sha": "0f9ea07ea36d86b04230950199e44ee7d48ceaef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f9ea07ea36d86b04230950199e44ee7d48ceaef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ad663c1fa88d68843e45580deced56112343183",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ad663c1fa88d68843e45580deced56112343183",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8ad663c1fa88d68843e45580deced56112343183",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ad663c1fa88d68843e45580deced56112343183/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28f11e9406b185dc87144f1f29af0d93eb115b4e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/28f11e9406b185dc87144f1f29af0d93eb115b4e"
      }
    ],
    "stats": {
      "total": 229,
      "additions": 103,
      "deletions": 126
    },
    "files": [
      {
        "sha": "9e8029971f335126e2a6f15b37ab4bdff4590b1c",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -195,11 +195,10 @@ void Shutdown()\n #endif\n     MapPort(false);\n     UnregisterValidationInterface(peerLogic.get());\n-    peerLogic.reset();\n     g_connman.reset();\n+    peerLogic.reset();\n \n     StopTorControl();\n-    UnregisterNodeSignals(GetNodeSignals());\n     if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n     }\n@@ -1268,7 +1267,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     peerLogic.reset(new PeerLogicValidation(&connman));\n     RegisterValidationInterface(peerLogic.get());\n-    RegisterNodeSignals(GetNodeSignals());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n@@ -1659,6 +1657,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxFeeler = 1;\n     connOptions.nBestHeight = chainActive.Height();\n     connOptions.uiInterface = &uiInterface;\n+    connOptions.m_msgproc = peerLogic.get();\n     connOptions.nSendBufferMaxSize = 1000*gArgs.GetArg(\"-maxsendbuffer\", DEFAULT_MAXSENDBUFFER);\n     connOptions.nReceiveFloodSize = 1000*gArgs.GetArg(\"-maxreceivebuffer\", DEFAULT_MAXRECEIVEBUFFER);\n "
      },
      {
        "sha": "52b66ccab890529806a50338c35eec6c3b8ff7b6",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -89,10 +89,6 @@ std::string strSubVersion;\n \n limitedmap<uint256, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n \n-// Signals for message handling\n-static CNodeSignals g_signals;\n-CNodeSignals& GetNodeSignals() { return g_signals; }\n-\n void CConnman::AddOneShot(const std::string& strDest)\n {\n     LOCK(cs_vOneShots);\n@@ -1114,7 +1110,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    GetNodeSignals().InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode, this);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1966,7 +1962,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (fAddnode)\n         pnode->fAddnode = true;\n \n-    GetNodeSignals().InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode, this);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1996,16 +1992,16 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, this, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n-\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                GetNodeSignals().SendMessages(pnode, this, flagInterruptMsgProc);\n+                m_msgproc->SendMessages(pnode, this, flagInterruptMsgProc);\n             }\n+\n             if (flagInterruptMsgProc)\n                 return;\n         }\n@@ -2324,6 +2320,7 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n     //\n     // Start threads\n     //\n+    assert(m_msgproc);\n     InterruptSocks5(false);\n     interruptNet.reset();\n     flagInterruptMsgProc = false;\n@@ -2450,9 +2447,10 @@ void CConnman::DeleteNode(CNode* pnode)\n {\n     assert(pnode);\n     bool fUpdateConnectionTime = false;\n-    GetNodeSignals().FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n-    if(fUpdateConnectionTime)\n+    m_msgproc->FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n+    if(fUpdateConnectionTime) {\n         addrman.Connected(pnode->addr);\n+    }\n     delete pnode;\n }\n "
      },
      {
        "sha": "4a503f6f36320345a454ff9d958cb1133d940f00",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -33,7 +33,6 @@\n #include <arpa/inet.h>\n #endif\n \n-#include <boost/signals2/signal.hpp>\n \n class CScheduler;\n class CNode;\n@@ -116,7 +115,7 @@ struct CSerializedNetMsg\n     std::string command;\n };\n \n-\n+class NetEventsInterface;\n class CConnman\n {\n public:\n@@ -138,6 +137,7 @@ class CConnman\n         int nMaxFeeler = 0;\n         int nBestHeight = 0;\n         CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n         unsigned int nSendBufferMaxSize = 0;\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n@@ -158,6 +158,7 @@ class CConnman\n         nMaxFeeler = connOptions.nMaxFeeler;\n         nBestHeight = connOptions.nBestHeight;\n         clientInterface = connOptions.uiInterface;\n+        m_msgproc = connOptions.m_msgproc;\n         nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n         nReceiveFloodSize = connOptions.nReceiveFloodSize;\n         nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n@@ -398,6 +399,7 @@ class CConnman\n     int nMaxFeeler;\n     std::atomic<int> nBestHeight;\n     CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n \n     /** SipHasher seeds for deterministic randomness */\n     const uint64_t nSeed0, nSeed1;\n@@ -438,19 +440,18 @@ struct CombinerAll\n     }\n };\n \n-// Signals for message handling\n-struct CNodeSignals\n+/**\n+ * Interface for message handling\n+ */\n+class NetEventsInterface\n {\n-    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> SendMessages;\n-    boost::signals2::signal<void (CNode*, CConnman*)> InitializeNode;\n-    boost::signals2::signal<void (NodeId, bool&)> FinalizeNode;\n+public:\n+    virtual bool ProcessMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n+    virtual void InitializeNode(CNode* pnode, CConnman* connman) = 0;\n+    virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n };\n \n-\n-CNodeSignals& GetNodeSignals();\n-\n-\n enum\n {\n     LOCAL_NONE,   // unknown"
      },
      {
        "sha": "9bd1adc571682911ad7b5a2e20d5d9d049d84f9b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 67,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -123,11 +123,6 @@ namespace {\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n } // namespace\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// Registration of network node signals.\n-//\n-\n namespace {\n \n struct CBlockReject {\n@@ -265,50 +260,6 @@ void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n     }\n }\n \n-void InitializeNode(CNode *pnode, CConnman* connman) {\n-    CAddress addr = pnode->addr;\n-    std::string addrName = pnode->GetAddrName();\n-    NodeId nodeid = pnode->GetId();\n-    {\n-        LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n-    }\n-    if(!pnode->fInbound)\n-        PushNodeVersion(pnode, connman, GetTime());\n-}\n-\n-void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n-    fUpdateConnectionTime = false;\n-    LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    if (state->fSyncStarted)\n-        nSyncStarted--;\n-\n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n-        fUpdateConnectionTime = true;\n-    }\n-\n-    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n-    }\n-    EraseOrphansFor(nodeid);\n-    nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n-\n-    mapNodeState.erase(nodeid);\n-\n-    if (mapNodeState.empty()) {\n-        // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n-        assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n-    }\n-    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n-}\n-\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n@@ -545,6 +496,50 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+void PeerLogicValidation::InitializeNode(CNode *pnode, CConnman* connman) {\n+    CAddress addr = pnode->addr;\n+    std::string addrName = pnode->GetAddrName();\n+    NodeId nodeid = pnode->GetId();\n+    {\n+        LOCK(cs_main);\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n+    }\n+    if(!pnode->fInbound)\n+        PushNodeVersion(pnode, connman, GetTime());\n+}\n+\n+void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n+    fUpdateConnectionTime = false;\n+    LOCK(cs_main);\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    if (state->fSyncStarted)\n+        nSyncStarted--;\n+\n+    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+        fUpdateConnectionTime = true;\n+    }\n+\n+    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n+        mapBlocksInFlight.erase(entry.hash);\n+    }\n+    EraseOrphansFor(nodeid);\n+    nPreferredDownload -= state->fPreferredDownload;\n+    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n+    assert(nPeersWithValidatedDownloads >= 0);\n+\n+    mapNodeState.erase(nodeid);\n+\n+    if (mapNodeState.empty()) {\n+        // Do a consistency check after the last peer is removed.\n+        assert(mapBlocksInFlight.empty());\n+        assert(nPreferredDownload == 0);\n+        assert(nPeersWithValidatedDownloads == 0);\n+    }\n+    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n+}\n+\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n@@ -560,22 +555,6 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     return true;\n }\n \n-void RegisterNodeSignals(CNodeSignals& nodeSignals)\n-{\n-    nodeSignals.ProcessMessages.connect(&ProcessMessages);\n-    nodeSignals.SendMessages.connect(&SendMessages);\n-    nodeSignals.InitializeNode.connect(&InitializeNode);\n-    nodeSignals.FinalizeNode.connect(&FinalizeNode);\n-}\n-\n-void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n-{\n-    nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n-    nodeSignals.SendMessages.disconnect(&SendMessages);\n-    nodeSignals.InitializeNode.disconnect(&InitializeNode);\n-    nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n-}\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapOrphanTransactions\n@@ -2661,7 +2640,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n     return false;\n }\n \n-bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2798,7 +2777,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {"
      },
      {
        "sha": "d79b74fcb7f71ec057282f66538f66fc17a2bf12",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 17,
        "deletions": 19,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -22,22 +22,32 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n \n-/** Register with a network node to receive its signals */\n-void RegisterNodeSignals(CNodeSignals& nodeSignals);\n-/** Unregister a network node */\n-void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n-\n-class PeerLogicValidation : public CValidationInterface {\n+class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* connman;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connmanIn);\n+    explicit PeerLogicValidation(CConnman* connman);\n \n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n     void BlockChecked(const CBlock& block, const CValidationState& state) override;\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+\n+\n+    void InitializeNode(CNode* pnode, CConnman* connman) override;\n+    void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) override;\n+    /** Process protocol messages received from a given node */\n+    bool ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    /**\n+    * Send queued protocol messages to be sent to a give node.\n+    *\n+    * @param[in]   pto             The node which we are sending messages to.\n+    * @param[in]   connman         The connection manager for that node.\n+    * @param[in]   interrupt       Interrupt condition for processing threads\n+    * @return                      True if there is more work to be done\n+    */\n+    bool SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interrupt) override;\n };\n \n struct CNodeStateStats {\n@@ -52,16 +62,4 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n \n-/** Process protocol messages received from a given node */\n-bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interrupt);\n-/**\n- * Send queued protocol messages to be sent to a give node.\n- *\n- * @param[in]   pto             The node which we are sending messages to.\n- * @param[in]   connman         The connection manager for that node.\n- * @param[in]   interrupt       Interrupt condition for processing threads\n- * @return                      True if there is more work to be done\n- */\n-bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interrupt);\n-\n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "fc5ef84ad2ac5f06709de1508b29fd5af7e9b894",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode2, connman);\n+    peerLogic->InitializeNode(&dummyNode2, connman);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode, connman);\n+    peerLogic->InitializeNode(&dummyNode, connman);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    SendMessages(&dummyNode, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      },
      {
        "sha": "045655983c66fdbafc0679b8a6fb0befc3a1bd19",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -48,7 +48,6 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n BasicTestingSetup::~BasicTestingSetup()\n {\n         ECC_Stop();\n-        g_connman.reset();\n }\n \n TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n@@ -86,16 +85,17 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        RegisterNodeSignals(GetNodeSignals());\n+        peerLogic.reset(new PeerLogicValidation(connman));\n }\n \n TestingSetup::~TestingSetup()\n {\n-        UnregisterNodeSignals(GetNodeSignals());\n         threadGroup.interrupt_all();\n         threadGroup.join_all();\n         GetMainSignals().FlushBackgroundCallbacks();\n         GetMainSignals().UnregisterBackgroundSignalScheduler();\n+        g_connman.reset();\n+        peerLogic.reset();\n         UnloadBlockIndex();\n         delete pcoinsTip;\n         delete pcoinsdbview;"
      },
      {
        "sha": "6ada96f887e8b9ffdea4764696caafdfb863030e",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ad663c1fa88d68843e45580deced56112343183/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ad663c1fa88d68843e45580deced56112343183/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=8ad663c1fa88d68843e45580deced56112343183",
        "patch": "@@ -49,12 +49,14 @@ struct BasicTestingSetup {\n  * Included are data directory, coins database, script check threads setup.\n  */\n class CConnman;\n+class PeerLogicValidation;\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;\n     fs::path pathTemp;\n     boost::thread_group threadGroup;\n     CConnman* connman;\n     CScheduler scheduler;\n+    std::unique_ptr<PeerLogicValidation> peerLogic;\n \n     explicit TestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~TestingSetup();"
      }
    ]
  },
  {
    "sha": "80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MGUyZTlkMGNlYzg5MGM1ZDJmODEzNjBlYmI4MWU4MWMwN2NjYjhj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T18:08:23Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-06T23:32:04Z"
      },
      "message": "net: drop unused connman param\n\nThe copy in PeerLogicValidation can be used instead.",
      "tree": {
        "sha": "aa0cdef4b62b87bc9832b30efb75c7b0e177ba2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa0cdef4b62b87bc9832b30efb75c7b0e177ba2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ad663c1fa88d68843e45580deced56112343183",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ad663c1fa88d68843e45580deced56112343183",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ad663c1fa88d68843e45580deced56112343183"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 24,
      "deletions": 25
    },
    "files": [
      {
        "sha": "587c9e51106f2d1bc26998ff725f6a2764c81953",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "patch": "@@ -1110,7 +1110,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    m_msgproc->InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1962,7 +1962,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (fAddnode)\n         pnode->fAddnode = true;\n \n-    m_msgproc->InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1992,14 +1992,14 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                m_msgproc->SendMessages(pnode, this, flagInterruptMsgProc);\n+                m_msgproc->SendMessages(pnode, flagInterruptMsgProc);\n             }\n \n             if (flagInterruptMsgProc)"
      },
      {
        "sha": "ca2433aa54ddfe99bb35bc6c71709bbac107f599",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "patch": "@@ -446,9 +446,9 @@ struct CombinerAll\n class NetEventsInterface\n {\n public:\n-    virtual bool ProcessMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n-    virtual void InitializeNode(CNode* pnode, CConnman* connman) = 0;\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n };\n "
      },
      {
        "sha": "b8900d9888257fc5e3c62395dd098844064c5940",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "patch": "@@ -496,7 +496,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n-void PeerLogicValidation::InitializeNode(CNode *pnode, CConnman* connman) {\n+void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n@@ -2640,7 +2640,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n     return false;\n }\n \n-bool PeerLogicValidation::ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2777,7 +2777,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool PeerLogicValidation::SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {"
      },
      {
        "sha": "79745cdd42c96ad765b27703b313ce2b6278ad59",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "patch": "@@ -35,19 +35,18 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n \n-    void InitializeNode(CNode* pnode, CConnman* connman) override;\n+    void InitializeNode(CNode* pnode) override;\n     void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) override;\n     /** Process protocol messages received from a given node */\n-    bool ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n     /**\n     * Send queued protocol messages to be sent to a give node.\n     *\n     * @param[in]   pto             The node which we are sending messages to.\n-    * @param[in]   connman         The connection manager for that node.\n     * @param[in]   interrupt       Interrupt condition for processing threads\n     * @return                      True if there is more work to be done\n     */\n-    bool SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "b88ad5ed1b8ab892c358a4f6b6b1e7cb9248e8fc",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode2, connman);\n+    peerLogic->InitializeNode(&dummyNode2);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode, connman);\n+    peerLogic->InitializeNode(&dummyNode);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    peerLogic->SendMessages(&dummyNode, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      }
    ]
  },
  {
    "sha": "2525b972af6645ca239ac1078cffb132b402bfbb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTI1Yjk3MmFmNjY0NWNhMjM5YWMxMDc4Y2ZmYjEzMmI0MDJiZmJi",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-07T18:26:20Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-07T18:26:23Z"
      },
      "message": "net: stop both net/net_processing before destroying them\n\nThis should avoid either attempting to use an invalid reference/pointer to the\nother.",
      "tree": {
        "sha": "40e39b0d9258c870f3c32e18ce708a484da9b6c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40e39b0d9258c870f3c32e18ce708a484da9b6c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2525b972af6645ca239ac1078cffb132b402bfbb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2525b972af6645ca239ac1078cffb132b402bfbb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2525b972af6645ca239ac1078cffb132b402bfbb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2525b972af6645ca239ac1078cffb132b402bfbb/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "810368b9d7c096c079534ff963ef0b416be57957",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2525b972af6645ca239ac1078cffb132b402bfbb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2525b972af6645ca239ac1078cffb132b402bfbb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2525b972af6645ca239ac1078cffb132b402bfbb",
        "patch": "@@ -194,9 +194,13 @@ void Shutdown()\n     }\n #endif\n     MapPort(false);\n+\n+    // Because these depend on each-other, we make sure that neither can be\n+    // using the other before destroying them.\n     UnregisterValidationInterface(peerLogic.get());\n-    g_connman.reset();\n+    g_connman->Stop();\n     peerLogic.reset();\n+    g_connman.reset();\n \n     StopTorControl();\n     if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {"
      }
    ]
  }
]