jonasschnelli,2019-03-22T21:04:12Z,"Benchmark compared with dbl-SHA256 (Intel x86 and ARM64 both **with enabled and supported SHA256 asm**)\n\nEDIT: **Attention**, those benchmark test a decryption that fails the MAC test (that's why its faster).\n```\ni7-8700 CPU @ 3.20GHz\n# Benchmark, evals, iterations, total, min, max, median\nCHACHA20_POLY1305_AEAD_1MB_DECRYPT, 5, 340, 0.974806, 0.000571213, 0.000575483, 0.000573147\nCHA",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-475782376,475782376,
DrahtBot,2019-03-22T22:35:10Z,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14032](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14032.html) (Add p2p layer encryption with ECDH/ChaCha20",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-475804607,475804607,
sipa,2019-03-26T19:48:42Z,Why is encrypting ~3 times slower than decrypting?,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-476819283,476819283,
jonasschnelli,2019-03-26T20:34:25Z,"> Why is encrypting ~3 times slower than decrypting?\n\nBecause the decryption in the benchmark always fails the MAC check... *facepalm*. Currently fixing.",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-476838884,476838884,
jonasschnelli,2019-03-26T21:23:54Z,"Overhauled the AEAD benchmark, now it measures:\n* only encryption of 64, 256 and 1MB\n* encryption and decryption (also including the previous-to-decryption `GetLength()` call)",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-476858336,476858336,
sipa,2019-03-26T22:01:13Z,Feel like posting new numbers?,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-476870170,476870170,
jonasschnelli,2019-03-26T22:09:00Z,"```\ni7-8700 CPU @ 3.20GHz\n# Benchmark, evals, iterations, total, min, max, median\nCHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT, 5, 340, 6.89749, 0.00401996, 0.004089, 0.00405691\nCHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT, 5, 340, 3.42802, 0.00199702, 0.00206066, 0.00200356\nCHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT, 5, 250000, 1.73244, 1.38097e-06, 1.39262e-06, 1.38631e-06\nCHACHA20_POL",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-476872498,476872498,
jonasschnelli,2019-03-27T16:40:17Z,rebased,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-477244965,477244965,
jonasschnelli,2019-05-10T07:53:15Z,Rebased,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-491195230,491195230,
jonasschnelli,2019-05-11T13:45:42Z,"Here are some number of the comparison against the @openSSH form of the AEAD (quick implementation is [here](https://github.com/jonasschnelli/bitcoin/commit/48e7f5bd1ba55dd9648befcd160d495a5fabd274)) on Intel i7 and RK [arm64])\n\nThere are moderate gains with our @Bitcoin AEAD construct especially for 64byte messages (~1.4 times faster)\n\nI also added HASH (dbl sha256) with no asm (to compar",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-491512397,491512397,
Empact,2019-05-27T21:19:11Z,"I compared the implementation to http://bxr.su/OpenBSD/usr.bin/ssh/cipher-chachapoly.c and did not find any notable incongruities.\n\nDisclaimer: I am not a cryptographer.",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-496307505,496307505,
jonasschnelli,2019-06-12T07:00:33Z,Removed the XOR macro in the test as well.,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-501146704,501146704,
jonasschnelli,2019-06-18T15:50:56Z,Followed the advice by @promag and added default constructor avoidance.,https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-503197017,503197017,
prusnak,2019-07-02T12:48:24Z,"Is the construct [RFC7539](https://tools.ietf.org/html/rfc7539) compliant?\n\n",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-507661811,507661811,
jonasschnelli,2019-07-02T20:19:38Z,"@prusnak \n\nThanks for asking. It probably belongs more to the mailing list discussion (here we discuss the actual implementation). However:\n\nInitially, the plan was to use the [OpenSSH version](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.chacha20poly1305) of the AEAD construct over the IETF one because encrypting the length field seems desirable in our case (would allo",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-507829497,507829497,
jonasschnelli,2019-07-03T09:54:59Z,"* Removed the invalid byte swapping in `crypto_tests`\n* Followed @practicalswift recommondation to not directly check and execute in `assert()` in the `chacha_poly_aead` bench",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-508026366,508026366,
laanwj,2019-07-11T19:48:00Z,"code review ACK bb326add9f38f2a8e5ce5ee29d98ce08038200d8\n\nthere's nothing to test yet (besides running the unit tests), as this is the first step and the code here is currently unused",https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-510628307,510628307,
skwp,2019-03-23T19:40:08Z,"not sure if these magic numbers are supposed to be obvious, but some named constants might be nice for people who are new to this stuff",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r268407005,268407005,src/bench/chacha_poly_aead.cpp
practicalswift,2019-03-26T09:24:00Z,"Nit:\n\nShadows existing `len_cmp` and also redundant initialization to zero?\n\nCould be just `uint64_t len_cmp_inner = XOR(ciphertext_buf[0], ‚Ä¶`?",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269006034,269006034,src/test/crypto_tests.cpp
practicalswift,2019-03-26T09:25:11Z,This `res` is never used. Should be checked?,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269006541,269006541,src/test/crypto_tests.cpp
practicalswift,2019-03-26T09:25:48Z,Scope can be reduced?,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269006819,269006819,src/crypto/chacha_poly_aead.cpp
practicalswift,2019-03-26T09:26:42Z,"Should be ""operation"" :-)",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269007161,269007161,src/test/crypto_tests.cpp
jonasschnelli,2019-03-26T21:15:53Z,You mean of `expected_tag`? Not sure it this makes things cleaner or more optimized.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269318910,269318910,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2019-03-26T21:17:18Z,Fixed,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269319397,269319397,src/test/crypto_tests.cpp
jonasschnelli,2019-03-26T21:17:28Z,Thanks. Fixed.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269319459,269319459,src/test/crypto_tests.cpp
jonasschnelli,2019-03-26T21:18:17Z,Thanks. Using the available constantes now.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269319725,269319725,src/bench/chacha_poly_aead.cpp
practicalswift,2019-03-27T09:28:12Z,Could be `bool ok = aead.Crypt(‚Ä¶); assert(ok);` to guarantee side-effect free use of `assert(...);`?,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269469109,269469109,src/bench/chacha_poly_aead.cpp
practicalswift,2019-03-27T09:30:26Z,Same here :-),https://github.com/bitcoin/bitcoin/pull/15649#discussion_r269469947,269469947,src/bench/chacha_poly_aead.cpp
practicalswift,2019-04-02T07:40:52Z,` *len24_out = 0;` here serves no purpose AFAICT since assigned on the next line?,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r271168248,271168248,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2019-05-10T07:54:19Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r282781242,282781242,src/crypto/chacha_poly_aead.cpp
Empact,2019-05-27T20:48:06Z,I would say it makes things cleaner by virtue of narrower scope. ü§∑‚Äç‚ôÇ ,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r287879764,287879764,src/crypto/chacha_poly_aead.cpp
Empact,2019-05-27T21:14:18Z,nit: `BOOST_CHECK()`,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r287882789,287882789,src/test/crypto_tests.cpp
Empact,2019-05-27T21:18:03Z,"How about splitting out `TestChaCha20Poly1305AEADFails`, rather than passing `must_succeed`?",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r287883196,287883196,src/test/crypto_tests.cpp
laanwj,2019-06-05T12:56:17Z,"What is the advantage of defining `XOR` as a macro here ?\n(same in `chacha_poly_aead.cpp`)",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r290723084,290723084,src/test/crypto_tests.cpp
jonasschnelli,2019-06-06T10:14:55Z,I thought it improves readability (got inspired by DJBs code). But happy to remove it since it saves space.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r291114182,291114182,src/test/crypto_tests.cpp
laanwj,2019-06-06T10:56:13Z,"It doesn't make the code more readable to me, at least. I recognize the C operator but the macro I had to look up. But I don't feel strongly about it.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r291128105,291128105,src/test/crypto_tests.cpp
jonasschnelli,2019-06-11T08:07:15Z,Thanks. Fixed.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292326579,292326579,src/test/crypto_tests.cpp
jonasschnelli,2019-06-11T08:07:43Z,I think passing the `must_succeed` argument is fine and simpler.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292326837,292326837,src/test/crypto_tests.cpp
jonasschnelli,2019-06-11T08:19:42Z,Removed the extra XOR macro.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292331959,292331959,src/test/crypto_tests.cpp
promag,2019-06-11T13:44:02Z,"Could add a auxiliary function at the top like:\n```cpp\ntemplate <typename T>\nvoid memory_cleanse(T v) {\n    memory_cleanse(v, sizeof(T));\n}\n```\nto prevent an invalid 2nd argument?",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292462148,292462148,src/crypto/chacha_poly_aead.cpp
promag,2019-06-11T13:46:11Z,"ü§î  there are still 6 `XOR` usages, is this intended?",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292463262,292463262,src/test/crypto_tests.cpp
jonasschnelli,2019-06-12T06:54:42Z,Both cleansed values can only be `POLY1305_TAGLEN` and I think it's fine using the default `memory_cleanse`.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292768095,292768095,src/crypto/chacha_poly_aead.cpp
promag,2019-06-12T07:07:51Z,I think it's fine as it is.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r292771439,292771439,src/crypto/chacha_poly_aead.cpp
elichai,2019-06-17T01:15:04Z,"Is the ""message sequence number"" randomly generate or is it a counter?\n\nCould it be reseted while the key will still be in use?",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294111372,294111372,src/crypto/chacha_poly_aead.h
elichai,2019-06-17T01:16:48Z,"A. If it could get reseted without getting rid of the key this is not a good source for the nonce.\n\nB. If it's randomly generated then 64bit isn't secure enough. We should either move to the chacha20 from the RFC which has 96bit nonce and 32bit counter or increment it manually every time.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294111551,294111551,src/crypto/chacha_poly_aead.h
sipa,2019-06-17T01:47:36Z,"@elichai I think discussion of the proposed AEAD should probably go on the mailing list discussing the BIP (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016806.html). Comments here should probably be just about implementation, or on discrepancies between the implementation and the BIP.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294114487,294114487,src/crypto/chacha_poly_aead.h
sipa,2019-06-17T01:49:26Z,"That said, I believe the sequence number is a simple counter, counting up from 0, incrementing by one for every message. It will get reset only when rekeying. Note that the security of ChaCha20 does not rely on the nonce being unpredictable, just on not reusing one, so it doesn't need any entropy.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294114671,294114671,src/crypto/chacha_poly_aead.h
elichai,2019-06-17T02:00:35Z,I'll move it to the mailing list thanks.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294115900,294115900,src/crypto/chacha_poly_aead.h
jonasschnelli,2019-06-18T14:50:15Z,This has been resolved on the mailing list: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017034.html,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r294865581,294865581,src/crypto/chacha_poly_aead.h
laanwj,2019-06-20T15:15:48Z,"are you sure the `htole64` is correct here? `SetIV` is implemented as\n```c++\nvoid ChaCha20::SetIV(uint64_t iv)\n{\n    input[14] = iv;\n    input[15] = iv >> 32;\n}\n```\nwhere `input` is an array of 32-bit unsigned integers that are (afaik) always used in LE fashion with `ReadLE32` / `WriteLE32` when doing byte operations.\n`htole64` flips the bytes of an integer on a big-endian platfo",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r295857986,295857986,src/crypto/chacha_poly_aead.cpp
elichai,2019-06-20T16:49:43Z,"I think it is necessary, because even though `input` is always used with `ReadLE32`/`WriteLE32` when you shift the iv and split it into `input[14]` and `input[15]` you'll get different results in BE or LE platforms.\n(unless you use `htole64` or something equivalent to make sure that the bits are sorted the same way)\n\nBut I do agree that this should be part of the chacha20 implementation. bec",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r295899078,295899078,src/crypto/chacha_poly_aead.cpp
elichai,2019-06-20T17:06:28Z,shouldn't that be a 32bit number? (because of `le32toh` and that you later compare with `expected_aad_length` which is `unsigned int`(so either 32 or 64)),https://github.com/bitcoin/bitcoin/pull/15649#discussion_r295906236,295906236,src/test/crypto_tests.cpp
sipa,2019-06-20T17:22:42Z,"There should not be any need for byteswapping. The IV is specified as an integer _before serialization_. The ChaCha20 implementation uses the LE serialization of that number, even on BE platforms.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r295912711,295912711,src/crypto/chacha_poly_aead.cpp
laanwj,2019-06-20T18:12:18Z,"> I think it is necessary, because even though input is always used with \n\nIf this is true, I still think it's done in the wrong way if the goal is to be consistent between LE and BE, you'd need a different kind of word-level swap. But I think @sipa is right here.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r295932468,295932468,src/crypto/chacha_poly_aead.cpp
elichai,2019-06-20T21:09:26Z,"The only thing that bothers me is the split using r/l shift.\nChacha20 defines everything as LE serialized/deserialized and if you shift than you bypass this requirement on BE platforms.\n\n(unless `seqnr_payload` is somehow already LE and not the host native endianess)",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r296011894,296011894,src/crypto/chacha_poly_aead.cpp
sipa,2019-06-20T21:12:28Z,seqnr_payload is an integer. The IV argument to ChaCha20 is an integer. Byte orders are only relevant when byte arrays are encoded as integers; that's not the case here. This is a pointless discussion. The `htole` call needs to go away.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r296014552,296014552,src/crypto/chacha_poly_aead.cpp
elichai,2019-06-20T21:16:51Z,"Ok, I went back to look at the definitions and tested, and right/left shifts work the same in all platforms (which actually is the sane thing, otherwise it will be a bit UB). you and Wladimir are right, the `htole64` isn't needed here. Sorry.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r296017351,296017351,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2019-06-25T08:41:16Z,"Thanks for looking into this...\nI'm actually unsure also by comparing against openSSH's implementation:\n* https://github.com/openssh/openssh-portable/blob/master/chacha.c#L85\n* https://github.com/openssh/openssh-portable/blob/master/cipher-chachapoly.c#L65\n\nGoing to setup a BE machine to test against various test vectors.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r297071752,297071752,src/crypto/chacha_poly_aead.cpp
laanwj,2019-06-25T12:18:14Z,"> and right/left shifts work the same in all platforms \n\nC++ has plenty of cruel and unusual cases of UB and IDB, but this luckily isn't one\n\n> I'm actually unsure also by comparing against openSSH's implementation:\n\nLooking at these, they have `POKE_U64` which pokes a unsigned 64-bit integer into memory (big-endian byte order, see https://github.com/openssh/openssh-portable/blob/maste",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r297156191,297156191,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2019-06-25T12:57:05Z,Indeed. Fixed.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r297172692,297172692,src/test/crypto_tests.cpp
jonasschnelli,2019-06-25T13:13:44Z,"Thanks for clearing up.\n@sipa and @laanwj are def. correct. \nRemoved all byteswappings.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r297180256,297180256,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2019-06-25T13:21:39Z,"The only important part is, that ""producers"" or the AEAD stream (which is not part of this PR, we only intend to test against already produced test vectors) need to make sure that the 3 byte length is correctly in LE order (which is easy to screw up because htole32 won't work in the 24bit case).",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r297184142,297184142,src/crypto/chacha_poly_aead.cpp
laanwj,2019-07-01T13:40:20Z,there's still IV byte swapping here (another one below),https://github.com/bitcoin/bitcoin/pull/15649#discussion_r299047516,299047516,src/test/crypto_tests.cpp
jonasschnelli,2019-07-02T20:08:21Z,Missed the ones in test. Will fix asap.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r299663126,299663126,src/test/crypto_tests.cpp
rajarshimaitra,2020-06-16T11:28:11Z,"BIP324 says the following on poly1305 key. \n> The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero.\n\nHere to me, it seems the key is being derived by encrypting a vector of zeros with `m",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r440779294,440779294,src/crypto/chacha_poly_aead.cpp
rajarshimaitra,2020-06-16T11:31:00Z,"Nit: \nFrom BIP draft\n>The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n\nTo keep parity with the BIP should",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r440780669,440780669,src/crypto/chacha_poly_aead.cpp
elichai,2020-06-16T15:03:06Z,"encrypting in chacha means generating a random string and XORing with the plaintext, so yes taking a stream is equal to encrypting zeros.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r440922076,440922076,src/crypto/chacha_poly_aead.cpp
rajarshimaitra,2020-06-16T15:11:06Z,Thanks for clarifying. ,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r440927978,440927978,src/crypto/chacha_poly_aead.cpp
jonasschnelli,2020-06-16T15:15:09Z,Good point. It's technically not wrong but confusing. Code update would probably be better.,https://github.com/bitcoin/bitcoin/pull/15649#discussion_r440931014,440931014,src/crypto/chacha_poly_aead.cpp
dhruv,2021-06-23T17:00:53Z,"If it's helpful, I've created #22331 to fix this.",https://github.com/bitcoin/bitcoin/pull/15649#discussion_r657297517,657297517,src/crypto/chacha_poly_aead.cpp
