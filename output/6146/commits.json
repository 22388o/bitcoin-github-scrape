[
  {
    "sha": "f50105486f3a664c3ecd2d7a5552f2767941f4d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNTAxMDU0ODZmM2E2NjRjM2VjZDJkN2E1NTUyZjI3Njc5NDFmNGQ3",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-05-15T16:40:36Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-05-16T21:59:23Z"
      },
      "message": "More robust CScheduler unit test\n\nOn a busy or slow system, the CScheduler unit test could fail because it\nassumed all threads would be done after a couple of milliseconds.\n\nReplace the hard-coded sleep with CScheduler stop() method that\nwill cleanly exit the servicing threads when all tasks are completely\nfinished.",
      "tree": {
        "sha": "9297f7b38a0219abe9aef0706f597a7aef4b7da5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9297f7b38a0219abe9aef0706f597a7aef4b7da5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f50105486f3a664c3ecd2d7a5552f2767941f4d7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlVXvb4ACgkQdYgkL74406g+ggCbB9PCOzLfRX0QRxCJbiJgmEpF\nyMkAnAvDVQywkrFkhlIAqiXq3aeNT3ps\n=DDCX\n-----END PGP SIGNATURE-----",
        "payload": "tree 9297f7b38a0219abe9aef0706f597a7aef4b7da5\nparent e47c94e64c44e817ac80cf682a68ba0c4580952f\nauthor Gavin Andresen <gavinandresen@gmail.com> 1431708036 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1431813563 -0400\n\nMore robust CScheduler unit test\n\nOn a busy or slow system, the CScheduler unit test could fail because it\nassumed all threads would be done after a couple of milliseconds.\n\nReplace the hard-coded sleep with CScheduler stop() method that\nwill cleanly exit the servicing threads when all tasks are completely\nfinished.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f50105486f3a664c3ecd2d7a5552f2767941f4d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f50105486f3a664c3ecd2d7a5552f2767941f4d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f50105486f3a664c3ecd2d7a5552f2767941f4d7/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e47c94e64c44e817ac80cf682a68ba0c4580952f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e47c94e64c44e817ac80cf682a68ba0c4580952f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e47c94e64c44e817ac80cf682a68ba0c4580952f"
      }
    ],
    "stats": {
      "total": 88,
      "additions": 70,
      "deletions": 18
    },
    "files": [
      {
        "sha": "4f1d8be7c0bf44e3e5e39cb1b3dcdbd3a4dbcd4d",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 8,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=f50105486f3a664c3ecd2d7a5552f2767941f4d7",
        "patch": "@@ -8,7 +8,7 @@\n #include <boost/bind.hpp>\n #include <utility>\n \n-CScheduler::CScheduler() : nThreadsServicingQueue(0)\n+CScheduler::CScheduler() : nThreadsServicingQueue(0), stopRequested(false), stopWhenEmpty(false)\n {\n }\n \n@@ -29,32 +29,37 @@ void CScheduler::serviceQueue()\n {\n     boost::unique_lock<boost::mutex> lock(newTaskMutex);\n     ++nThreadsServicingQueue;\n+    stopRequested = false;\n+    stopWhenEmpty = false;\n \n     // newTaskMutex is locked throughout this loop EXCEPT\n     // when the thread is waiting or when the user's function\n     // is called.\n-    while (1) {\n+    while (!shouldStop()) {\n         try {\n-            while (taskQueue.empty()) {\n+            while (!shouldStop() && taskQueue.empty()) {\n                 // Wait until there is something to do.\n                 newTaskScheduled.wait(lock);\n             }\n-// Wait until either there is a new task, or until\n-// the time of the first item on the queue:\n+\n+            // Wait until either there is a new task, or until\n+            // the time of the first item on the queue:\n \n // wait_until needs boost 1.50 or later; older versions have timed_wait:\n #if BOOST_VERSION < 105000\n-            while (!taskQueue.empty() && newTaskScheduled.timed_wait(lock, toPosixTime(taskQueue.begin()->first))) {\n+            while (!shouldStop() && !taskQueue.empty() &&\n+                   newTaskScheduled.timed_wait(lock, toPosixTime(taskQueue.begin()->first))) {\n                 // Keep waiting until timeout\n             }\n #else\n-            while (!taskQueue.empty() && newTaskScheduled.wait_until(lock, taskQueue.begin()->first) != boost::cv_status::timeout) {\n+            while (!shouldStop() && !taskQueue.empty() &&\n+                   newTaskScheduled.wait_until(lock, taskQueue.begin()->first) != boost::cv_status::timeout) {\n                 // Keep waiting until timeout\n             }\n #endif\n             // If there are multiple threads, the queue can empty while we're waiting (another\n             // thread may service the task we were waiting on).\n-            if (taskQueue.empty())\n+            if (shouldStop() || taskQueue.empty())\n                 continue;\n \n             Function f = taskQueue.begin()->second;\n@@ -70,6 +75,19 @@ void CScheduler::serviceQueue()\n             throw;\n         }\n     }\n+    --nThreadsServicingQueue;\n+}\n+\n+void CScheduler::stop(bool drain)\n+{\n+    {\n+        boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+        if (drain)\n+            stopWhenEmpty = true;\n+        else\n+            stopRequested = true;\n+    }\n+    newTaskScheduled.notify_all();\n }\n \n void CScheduler::schedule(CScheduler::Function f, boost::chrono::system_clock::time_point t)\n@@ -96,3 +114,15 @@ void CScheduler::scheduleEvery(CScheduler::Function f, int64_t deltaSeconds)\n {\n     scheduleFromNow(boost::bind(&Repeat, this, f, deltaSeconds), deltaSeconds);\n }\n+\n+size_t CScheduler::getQueueInfo(boost::chrono::system_clock::time_point &first,\n+                             boost::chrono::system_clock::time_point &last) const\n+{\n+    boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+    size_t result = taskQueue.size();\n+    if (!taskQueue.empty()) {\n+        first = taskQueue.begin()->first;\n+        last = taskQueue.rbegin()->first;\n+    }\n+    return result;\n+}"
      },
      {
        "sha": "436659e58bb5a9adf9d7ef9574030c4c3070a7b6",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 14,
        "deletions": 1,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=f50105486f3a664c3ecd2d7a5552f2767941f4d7",
        "patch": "@@ -60,11 +60,24 @@ class CScheduler\n     // and interrupted using boost::interrupt_thread\n     void serviceQueue();\n \n+    // Tell any threads running serviceQueue to stop as soon as they're\n+    // done servicing whatever task they're currently servicing (drain=false)\n+    // or when there is no work left to be done (drain=true)\n+    void stop(bool drain=false);\n+\n+    // Returns number of tasks waiting to be serviced,\n+    // and first and last task times\n+    size_t getQueueInfo(boost::chrono::system_clock::time_point &first,\n+                        boost::chrono::system_clock::time_point &last) const;\n+\n private:\n     std::multimap<boost::chrono::system_clock::time_point, Function> taskQueue;\n     boost::condition_variable newTaskScheduled;\n-    boost::mutex newTaskMutex;\n+    mutable boost::mutex newTaskMutex;\n     int nThreadsServicingQueue;\n+    bool stopRequested;\n+    bool stopWhenEmpty;\n+    bool shouldStop() { return stopRequested || (stopWhenEmpty && taskQueue.empty()); }\n };\n \n #endif"
      },
      {
        "sha": "cb1a427db00e92846ec0a99890d484c7156369fd",
        "filename": "src/test/scheduler_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 9,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/test/scheduler_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f50105486f3a664c3ecd2d7a5552f2767941f4d7/src/test/scheduler_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scheduler_tests.cpp?ref=f50105486f3a664c3ecd2d7a5552f2767941f4d7",
        "patch": "@@ -42,6 +42,8 @@ static void MicroSleep(uint64_t n)\n \n BOOST_AUTO_TEST_CASE(manythreads)\n {\n+    seed_insecure_rand(false);\n+\n     // Stress test: hundreds of microsecond-scheduled tasks,\n     // serviced by 10 threads.\n     //\n@@ -54,10 +56,6 @@ BOOST_AUTO_TEST_CASE(manythreads)\n     // counters should sum to the number of initial tasks performed.\n     CScheduler microTasks;\n \n-    boost::thread_group microThreads;\n-    for (int i = 0; i < 5; i++)\n-        microThreads.create_thread(boost::bind(&CScheduler::serviceQueue, &microTasks));\n-\n     boost::mutex counterMutex[10];\n     int counter[10] = { 0 };\n     boost::random::mt19937 rng(insecure_rand());\n@@ -67,6 +65,9 @@ BOOST_AUTO_TEST_CASE(manythreads)\n \n     boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();\n     boost::chrono::system_clock::time_point now = start;\n+    boost::chrono::system_clock::time_point first, last;\n+    size_t nTasks = microTasks.getQueueInfo(first, last);\n+    BOOST_CHECK(nTasks == 0);\n \n     for (int i = 0; i < 100; i++) {\n         boost::chrono::system_clock::time_point t = now + boost::chrono::microseconds(randomMsec(rng));\n@@ -77,9 +78,19 @@ BOOST_AUTO_TEST_CASE(manythreads)\n                                              randomDelta(rng), tReschedule);\n         microTasks.schedule(f, t);\n     }\n+    nTasks = microTasks.getQueueInfo(first, last);\n+    BOOST_CHECK(nTasks == 100);\n+    BOOST_CHECK(first < last);\n+    BOOST_CHECK(last > now);\n+\n+    // As soon as these are created they will start running and servicing the queue\n+    boost::thread_group microThreads;\n+    for (int i = 0; i < 5; i++)\n+        microThreads.create_thread(boost::bind(&CScheduler::serviceQueue, &microTasks));\n \n     MicroSleep(600);\n     now = boost::chrono::system_clock::now();\n+\n     // More threads and more tasks:\n     for (int i = 0; i < 5; i++)\n         microThreads.create_thread(boost::bind(&CScheduler::serviceQueue, &microTasks));\n@@ -93,11 +104,9 @@ BOOST_AUTO_TEST_CASE(manythreads)\n         microTasks.schedule(f, t);\n     }\n \n-    // All 2,000 tasks should be finished within 2 milliseconds. Sleep a bit longer.\n-    MicroSleep(2100);\n-\n-    microThreads.interrupt_all();\n-    microThreads.join_all();\n+    // Drain the task queue then exit threads\n+    microTasks.stop(true);\n+    microThreads.join_all(); // ... wait until all the threads are done\n \n     int counterSum = 0;\n     for (int i = 0; i < 10; i++) {"
      }
    ]
  }
]