[
  {
    "sha": "2eca46b0aa0ecf4738500b53523d7013985b387d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZWNhNDZiMGFhMGVjZjQ3Mzg1MDBiNTM1MjNkNzAxMzk4NWIzODdk",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-09T21:22:27Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-09T23:31:27Z"
      },
      "message": "test: use MiniWallet for feature_csv_activation.py\n\nThis test can now be run even with the Bitcoin Core wallet disabled.",
      "tree": {
        "sha": "4b2c7ed708c142c3e908c67c00d955326f167c4a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b2c7ed708c142c3e908c67c00d955326f167c4a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2eca46b0aa0ecf4738500b53523d7013985b387d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2eca46b0aa0ecf4738500b53523d7013985b387d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2eca46b0aa0ecf4738500b53523d7013985b387d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2eca46b0aa0ecf4738500b53523d7013985b387d/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9313c4e6aa4b707c06a86b33d5d2753cd8383340",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9313c4e6aa4b707c06a86b33d5d2753cd8383340",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9313c4e6aa4b707c06a86b33d5d2753cd8383340"
      }
    ],
    "stats": {
      "total": 146,
      "additions": 72,
      "deletions": 74
    },
    "files": [
      {
        "sha": "01b86e7a2930f88084844d778b1c3355ab004c41",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 67,
        "deletions": 72,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2eca46b0aa0ecf4738500b53523d7013985b387d/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2eca46b0aa0ecf4738500b53523d7013985b387d/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=2eca46b0aa0ecf4738500b53523d7013985b387d",
        "patch": "@@ -37,13 +37,13 @@\n bip112tx_special - test negative argument to OP_CSV\n bip112tx_emptystack - test empty stack (= no argument) OP_CSV\n \"\"\"\n-from decimal import Decimal\n from itertools import product\n-from io import BytesIO\n import time\n \n-from test_framework.blocktools import create_coinbase, create_block, create_transaction\n-from test_framework.messages import ToHex, CTransaction\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n from test_framework.p2p import P2PDataStore\n from test_framework.script import (\n     CScript,\n@@ -53,9 +53,9 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes,\n     softfork_active,\n )\n+from test_framework.wallet import MiniWallet\n \n TESTING_TX_COUNT = 83  # Number of testing transactions: 1 BIP113 tx, 16 BIP68 txs, 66 BIP112 txs (see comments above)\n COINBASE_BLOCK_COUNT = TESTING_TX_COUNT  # Number of coinbase blocks we need to generate as inputs for our txs\n@@ -83,65 +83,60 @@ def relative_locktime(sdf, srhb, stf, srlb):\n def all_rlt_txs(txs):\n     return [tx['tx'] for tx in txs]\n \n-def sign_transaction(node, unsignedtx):\n-    rawtx = ToHex(unsignedtx)\n-    signresult = node.signrawtransactionwithwallet(rawtx)\n-    tx = CTransaction()\n-    f = BytesIO(hex_str_to_bytes(signresult['hex']))\n-    tx.deserialize(f)\n+def create_self_transfer_from_utxo(node, input_tx):\n+    utxo = miniwallet.get_utxo(txid=input_tx.rehash(), mark_as_spent=False)\n+    tx = miniwallet.create_self_transfer(from_node=node, utxo_to_spend=utxo)['tx']\n     return tx\n \n-def create_bip112special(node, input, txversion, address):\n-    tx = create_transaction(node, input, address, amount=Decimal(\"49.98\"))\n+def create_bip112special(node, input, txversion):\n+    tx = create_self_transfer_from_utxo(node, input)\n     tx.nVersion = txversion\n-    signtx = sign_transaction(node, tx)\n-    signtx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-    return signtx\n+    tx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n+    return tx\n \n-def create_bip112emptystack(node, input, txversion, address):\n-    tx = create_transaction(node, input, address, amount=Decimal(\"49.98\"))\n+def create_bip112emptystack(node, input, txversion):\n+    tx = create_self_transfer_from_utxo(node, input)\n     tx.nVersion = txversion\n-    signtx = sign_transaction(node, tx)\n-    signtx.vin[0].scriptSig = CScript([OP_CHECKSEQUENCEVERIFY] + list(CScript(signtx.vin[0].scriptSig)))\n-    return signtx\n+    tx.vin[0].scriptSig = CScript([OP_CHECKSEQUENCEVERIFY] + list(CScript(tx.vin[0].scriptSig)))\n+    return tx\n \n-def send_generic_input_tx(node, coinbases, address):\n-    return node.sendrawtransaction(ToHex(sign_transaction(node, create_transaction(node, node.getblock(coinbases.pop())['tx'][0], address, amount=Decimal(\"49.99\")))))\n+def send_generic_input_tx(node, coinbases):\n+    input_txid = node.getblock(coinbases.pop(), 2)['tx'][0]['txid']\n+    utxo_to_spend = miniwallet.get_utxo(txid=input_txid)\n+    return miniwallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)['tx']\n \n-def create_bip68txs(node, bip68inputs, txversion, address, locktime_delta=0):\n+def create_bip68txs(node, bip68inputs, txversion, locktime_delta=0):\n     \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n     txs = []\n     assert len(bip68inputs) >= 16\n     for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n         locktime = relative_locktime(sdf, srhb, stf, srlb)\n-        tx = create_transaction(node, bip68inputs[i], address, amount=Decimal(\"49.98\"))\n+        tx = create_self_transfer_from_utxo(node, bip68inputs[i])\n         tx.nVersion = txversion\n         tx.vin[0].nSequence = locktime + locktime_delta\n-        tx = sign_transaction(node, tx)\n         tx.rehash()\n         txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n \n     return txs\n \n-def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, address, locktime_delta=0):\n+def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n     \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n     txs = []\n     assert len(bip112inputs) >= 16\n     for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n         locktime = relative_locktime(sdf, srhb, stf, srlb)\n-        tx = create_transaction(node, bip112inputs[i], address, amount=Decimal(\"49.98\"))\n+        tx = create_self_transfer_from_utxo(node, bip112inputs[i])\n         if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n             tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n         else:  # vary nSequence instead, OP_CSV is fixed\n             tx.vin[0].nSequence = locktime + locktime_delta\n         tx.nVersion = txversion\n-        signtx = sign_transaction(node, tx)\n         if (varyOP_CSV):\n-            signtx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+            tx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n         else:\n-            signtx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+            tx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n         tx.rehash()\n-        txs.append({'tx': signtx, 'sdf': sdf, 'stf': stf})\n+        txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n     return txs\n \n class BIP68_112_113Test(BitcoinTestFramework):\n@@ -150,14 +145,11 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         self.extra_args = [[\n             '-whitelist=noban@127.0.0.1',\n-            '-addresstype=legacy',\n+            '-acceptnonstdtxn=1',\n             '-par=1',  # Use only one script thread to get the exact reject reason for testing\n         ]]\n         self.supports_cli = False\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n     def generate_blocks(self, number):\n         test_blocks = []\n         for _ in range(number):\n@@ -185,16 +177,18 @@ def send_blocks(self, blocks, success=True, reject_reason=None):\n \n     def run_test(self):\n         self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())\n+        # TODO: store as class member to get rid of global variable\n+        global miniwallet\n+        miniwallet = MiniWallet(self.nodes[0], raw_script=True)\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = self.nodes[0].generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n+        self.coinbase_blocks = miniwallet.generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n         self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n         self.tipheight = COINBASE_BLOCK_COUNT  # height of the next block to build\n         self.last_block_time = long_past_time\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        self.nodeaddress = self.nodes[0].getnewaddress()\n \n         # Activation height is hardcoded\n         # We advance to block height five below BIP112 activation for the following tests\n@@ -209,31 +203,31 @@ def run_test(self):\n         # 16 normal inputs\n         bip68inputs = []\n         for _ in range(16):\n-            bip68inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n+            bip68inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n \n         # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112basicinputs = []\n         for _ in range(2):\n             inputs = []\n             for _ in range(16):\n-                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n+                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n             bip112basicinputs.append(inputs)\n \n         # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112diverseinputs = []\n         for _ in range(2):\n             inputs = []\n             for _ in range(16):\n-                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n+                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n             bip112diverseinputs.append(inputs)\n \n         # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n-        bip112specialinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress)\n+        bip112specialinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n         # 1 special input with (empty stack) OP_CSV (actually will be prepended to spending scriptSig)\n-        bip112emptystackinput = send_generic_input_tx(self.nodes[0],self.coinbase_blocks, self.nodeaddress)\n+        bip112emptystackinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n \n         # 1 normal input\n-        bip113input = send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress)\n+        bip113input = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n         inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 431\n@@ -253,36 +247,36 @@ def run_test(self):\n \n         # Test both version 1 and version 2 transactions for all tests\n         # BIP113 test transaction will be modified before each use to put in appropriate block time\n-        bip113tx_v1 = create_transaction(self.nodes[0], bip113input, self.nodeaddress, amount=Decimal(\"49.98\"))\n+        bip113tx_v1 = create_self_transfer_from_utxo(self.nodes[0], bip113input)\n         bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v1.nVersion = 1\n-        bip113tx_v2 = create_transaction(self.nodes[0], bip113input, self.nodeaddress, amount=Decimal(\"49.98\"))\n+        bip113tx_v2 = create_self_transfer_from_utxo(self.nodes[0], bip113input)\n         bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v2.nVersion = 2\n \n         # For BIP68 test all 16 relative sequence locktimes\n-        bip68txs_v1 = create_bip68txs(self.nodes[0], bip68inputs, 1, self.nodeaddress)\n-        bip68txs_v2 = create_bip68txs(self.nodes[0], bip68inputs, 2, self.nodeaddress)\n+        bip68txs_v1 = create_bip68txs(self.nodes[0], bip68inputs, 1)\n+        bip68txs_v2 = create_bip68txs(self.nodes[0], bip68inputs, 2)\n \n         # For BIP112 test:\n         # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 1, self.nodeaddress)\n-        bip112txs_vary_nSequence_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 2, self.nodeaddress)\n+        bip112txs_vary_nSequence_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 2)\n         # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_9_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 1, self.nodeaddress, -1)\n-        bip112txs_vary_nSequence_9_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 2, self.nodeaddress, -1)\n+        bip112txs_vary_nSequence_9_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 2, -1)\n         # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 1, self.nodeaddress)\n-        bip112txs_vary_OP_CSV_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 2, self.nodeaddress)\n+        bip112txs_vary_OP_CSV_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 2)\n         # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_9_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 1, self.nodeaddress, -1)\n-        bip112txs_vary_OP_CSV_9_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 2, self.nodeaddress, -1)\n+        bip112txs_vary_OP_CSV_9_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 2, -1)\n         # -1 OP_CSV OP_DROP input\n-        bip112tx_special_v1 = create_bip112special(self.nodes[0], bip112specialinput, 1, self.nodeaddress)\n-        bip112tx_special_v2 = create_bip112special(self.nodes[0], bip112specialinput, 2, self.nodeaddress)\n+        bip112tx_special_v1 = create_bip112special(self.nodes[0], bip112specialinput, 1)\n+        bip112tx_special_v2 = create_bip112special(self.nodes[0], bip112specialinput, 2)\n         # (empty stack) OP_CSV input\n-        bip112tx_emptystack_v1 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 1, self.nodeaddress)\n-        bip112tx_emptystack_v2 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 2, self.nodeaddress)\n+        bip112tx_emptystack_v1 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 1)\n+        bip112tx_emptystack_v2 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 2)\n \n         self.log.info(\"TESTING\")\n \n@@ -292,8 +286,8 @@ def run_test(self):\n         success_txs = []\n         # BIP113 tx, -1 CSV tx and empty stack CSV tx should succeed\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n-        success_txs.append(bip113signed1)\n+        bip113tx_v1.rehash()\n+        success_txs.append(bip113tx_v1)\n         success_txs.append(bip112tx_special_v1)\n         success_txs.append(bip112tx_emptystack_v1)\n         # add BIP 68 txs\n@@ -312,8 +306,8 @@ def run_test(self):\n         success_txs = []\n         # BIP113 tx, -1 CSV tx and empty stack CSV tx should succeed\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n-        success_txs.append(bip113signed2)\n+        bip113tx_v2.rehash()\n+        success_txs.append(bip113tx_v2)\n         success_txs.append(bip112tx_special_v2)\n         success_txs.append(bip112tx_emptystack_v2)\n         # add BIP 68 txs\n@@ -338,17 +332,18 @@ def run_test(self):\n         self.log.info(\"BIP 113 tests\")\n         # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v1.rehash()\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n-        for bip113tx in [bip113signed1, bip113signed2]:\n+        bip113tx_v2.rehash()\n+        for bip113tx in [bip113tx_v1, bip113tx_v2]:\n             self.send_blocks([self.create_test_block([bip113tx])], success=False, reject_reason='bad-txns-nonfinal')\n+\n         # BIP 113 tests should now pass if the locktime is < MTP\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n-        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v1.rehash()\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n-        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n-        for bip113tx in [bip113signed1, bip113signed2]:\n+        bip113tx_v2.rehash()\n+        for bip113tx in [bip113tx_v1, bip113tx_v2]:\n             self.send_blocks([self.create_test_block([bip113tx])])\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n@@ -471,8 +466,8 @@ def run_test(self):\n         time_txs = []\n         for tx in [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]:\n             tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME | SEQ_TYPE_FLAG\n-            signtx = sign_transaction(self.nodes[0], tx)\n-            time_txs.append(signtx)\n+            tx.rehash()\n+            time_txs.append(tx)\n \n         self.send_blocks([self.create_test_block(time_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())"
      },
      {
        "sha": "57b0a170f0063b853c9abc5c72505c66c382470c",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2eca46b0aa0ecf4738500b53523d7013985b387d/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2eca46b0aa0ecf4738500b53523d7013985b387d/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=2eca46b0aa0ecf4738500b53523d7013985b387d",
        "patch": "@@ -61,7 +61,7 @@ def generate(self, num_blocks):\n     def get_address(self):\n         return self._address\n \n-    def get_utxo(self, *, txid=''):\n+    def get_utxo(self, *, txid='', mark_as_spent=True):\n         \"\"\"\n         Returns a utxo and marks it as spent (pops it from the internal list)\n \n@@ -74,7 +74,10 @@ def get_utxo(self, *, txid=''):\n         if txid:\n             utxo = next(filter(lambda utxo: txid == utxo['txid'], self._utxos))\n             index = self._utxos.index(utxo)\n-        return self._utxos.pop(index)\n+        if mark_as_spent:\n+            return self._utxos.pop(index)\n+        else:\n+            return self._utxos[index]\n \n     def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None):\n         \"\"\"Create and send a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\""
      }
    ]
  },
  {
    "sha": "bd7f27d16dacf6f7de3b4f6bd052def41d9601be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDdmMjdkMTZkYWNmNmY3ZGUzYjRmNmJkMDUyZGVmNDFkOTYwMWJl",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-09T22:16:37Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-09T23:31:33Z"
      },
      "message": "refactor: feature_csv_activation.py: move tx helper functions to methods\n\nThis allows to get rid of the global miniwallet variable and to specify\nthe used node self.nodes[0] at only one place, instead of passing it to\nevery tx creation/send method again and again.\n\nCan be reviewed with --ignore-all-space --color-moved=dimmed-zebra",
      "tree": {
        "sha": "b0da87cbb699ec607e05047ef42665690839b8ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0da87cbb699ec607e05047ef42665690839b8ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd7f27d16dacf6f7de3b4f6bd052def41d9601be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd7f27d16dacf6f7de3b4f6bd052def41d9601be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd7f27d16dacf6f7de3b4f6bd052def41d9601be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd7f27d16dacf6f7de3b4f6bd052def41d9601be/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2eca46b0aa0ecf4738500b53523d7013985b387d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2eca46b0aa0ecf4738500b53523d7013985b387d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2eca46b0aa0ecf4738500b53523d7013985b387d"
      }
    ],
    "stats": {
      "total": 161,
      "additions": 80,
      "deletions": 81
    },
    "files": [
      {
        "sha": "28062590fd973388809da573a9aed4e42c5a6e54",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 80,
        "deletions": 81,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd7f27d16dacf6f7de3b4f6bd052def41d9601be/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd7f27d16dacf6f7de3b4f6bd052def41d9601be/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=bd7f27d16dacf6f7de3b4f6bd052def41d9601be",
        "patch": "@@ -83,61 +83,6 @@ def relative_locktime(sdf, srhb, stf, srlb):\n def all_rlt_txs(txs):\n     return [tx['tx'] for tx in txs]\n \n-def create_self_transfer_from_utxo(node, input_tx):\n-    utxo = miniwallet.get_utxo(txid=input_tx.rehash(), mark_as_spent=False)\n-    tx = miniwallet.create_self_transfer(from_node=node, utxo_to_spend=utxo)['tx']\n-    return tx\n-\n-def create_bip112special(node, input, txversion):\n-    tx = create_self_transfer_from_utxo(node, input)\n-    tx.nVersion = txversion\n-    tx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n-    return tx\n-\n-def create_bip112emptystack(node, input, txversion):\n-    tx = create_self_transfer_from_utxo(node, input)\n-    tx.nVersion = txversion\n-    tx.vin[0].scriptSig = CScript([OP_CHECKSEQUENCEVERIFY] + list(CScript(tx.vin[0].scriptSig)))\n-    return tx\n-\n-def send_generic_input_tx(node, coinbases):\n-    input_txid = node.getblock(coinbases.pop(), 2)['tx'][0]['txid']\n-    utxo_to_spend = miniwallet.get_utxo(txid=input_txid)\n-    return miniwallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)['tx']\n-\n-def create_bip68txs(node, bip68inputs, txversion, locktime_delta=0):\n-    \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n-    txs = []\n-    assert len(bip68inputs) >= 16\n-    for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n-        locktime = relative_locktime(sdf, srhb, stf, srlb)\n-        tx = create_self_transfer_from_utxo(node, bip68inputs[i])\n-        tx.nVersion = txversion\n-        tx.vin[0].nSequence = locktime + locktime_delta\n-        tx.rehash()\n-        txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n-\n-    return txs\n-\n-def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n-    \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n-    txs = []\n-    assert len(bip112inputs) >= 16\n-    for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n-        locktime = relative_locktime(sdf, srhb, stf, srlb)\n-        tx = create_self_transfer_from_utxo(node, bip112inputs[i])\n-        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n-            tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n-        else:  # vary nSequence instead, OP_CSV is fixed\n-            tx.vin[0].nSequence = locktime + locktime_delta\n-        tx.nVersion = txversion\n-        if (varyOP_CSV):\n-            tx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n-        else:\n-            tx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n-        tx.rehash()\n-        txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n-    return txs\n \n class BIP68_112_113Test(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -150,6 +95,62 @@ def set_test_params(self):\n         ]]\n         self.supports_cli = False\n \n+    def create_self_transfer_from_utxo(self, input_tx):\n+        utxo = self.miniwallet.get_utxo(txid=input_tx.rehash(), mark_as_spent=False)\n+        tx = self.miniwallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo)['tx']\n+        return tx\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_self_transfer_from_utxo(input)\n+        tx.nVersion = txversion\n+        tx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n+        return tx\n+\n+    def create_bip112emptystack(self, input, txversion):\n+        tx = self.create_self_transfer_from_utxo(input)\n+        tx.nVersion = txversion\n+        tx.vin[0].scriptSig = CScript([OP_CHECKSEQUENCEVERIFY] + list(CScript(tx.vin[0].scriptSig)))\n+        return tx\n+\n+    def send_generic_input_tx(self, coinbases):\n+        input_txid = self.nodes[0].getblock(coinbases.pop(), 2)['tx'][0]['txid']\n+        utxo_to_spend = self.miniwallet.get_utxo(txid=input_txid)\n+        return self.miniwallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_to_spend)['tx']\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta=0):\n+        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n+        txs = []\n+        assert len(bip68inputs) >= 16\n+        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+            locktime = relative_locktime(sdf, srhb, stf, srlb)\n+            tx = self.create_self_transfer_from_utxo(bip68inputs[i])\n+            tx.nVersion = txversion\n+            tx.vin[0].nSequence = locktime + locktime_delta\n+            tx.rehash()\n+            txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n+\n+        return txs\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n+        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n+        txs = []\n+        assert len(bip112inputs) >= 16\n+        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+            locktime = relative_locktime(sdf, srhb, stf, srlb)\n+            tx = self.create_self_transfer_from_utxo(bip112inputs[i])\n+            if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n+                tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n+            else:  # vary nSequence instead, OP_CSV is fixed\n+                tx.vin[0].nSequence = locktime + locktime_delta\n+            tx.nVersion = txversion\n+            if (varyOP_CSV):\n+                tx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n+            else:\n+                tx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n+            tx.rehash()\n+            txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n+        return txs\n+\n     def generate_blocks(self, number):\n         test_blocks = []\n         for _ in range(number):\n@@ -177,14 +178,12 @@ def send_blocks(self, blocks, success=True, reject_reason=None):\n \n     def run_test(self):\n         self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())\n-        # TODO: store as class member to get rid of global variable\n-        global miniwallet\n-        miniwallet = MiniWallet(self.nodes[0], raw_script=True)\n+        self.miniwallet = MiniWallet(self.nodes[0], raw_script=True)\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = miniwallet.generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n+        self.coinbase_blocks = self.miniwallet.generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n         self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n         self.tipheight = COINBASE_BLOCK_COUNT  # height of the next block to build\n         self.last_block_time = long_past_time\n@@ -203,31 +202,31 @@ def run_test(self):\n         # 16 normal inputs\n         bip68inputs = []\n         for _ in range(16):\n-            bip68inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip68inputs.append(self.send_generic_input_tx(self.coinbase_blocks))\n \n         # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112basicinputs = []\n         for _ in range(2):\n             inputs = []\n             for _ in range(16):\n-                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+                inputs.append(self.send_generic_input_tx(self.coinbase_blocks))\n             bip112basicinputs.append(inputs)\n \n         # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112diverseinputs = []\n         for _ in range(2):\n             inputs = []\n             for _ in range(16):\n-                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+                inputs.append(self.send_generic_input_tx(self.coinbase_blocks))\n             bip112diverseinputs.append(inputs)\n \n         # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n-        bip112specialinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        bip112specialinput = self.send_generic_input_tx(self.coinbase_blocks)\n         # 1 special input with (empty stack) OP_CSV (actually will be prepended to spending scriptSig)\n-        bip112emptystackinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        bip112emptystackinput = self.send_generic_input_tx(self.coinbase_blocks)\n \n         # 1 normal input\n-        bip113input = send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        bip113input = self.send_generic_input_tx(self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n         inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 431\n@@ -247,36 +246,36 @@ def run_test(self):\n \n         # Test both version 1 and version 2 transactions for all tests\n         # BIP113 test transaction will be modified before each use to put in appropriate block time\n-        bip113tx_v1 = create_self_transfer_from_utxo(self.nodes[0], bip113input)\n+        bip113tx_v1 = self.create_self_transfer_from_utxo(bip113input)\n         bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v1.nVersion = 1\n-        bip113tx_v2 = create_self_transfer_from_utxo(self.nodes[0], bip113input)\n+        bip113tx_v2 = self.create_self_transfer_from_utxo(bip113input)\n         bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v2.nVersion = 2\n \n         # For BIP68 test all 16 relative sequence locktimes\n-        bip68txs_v1 = create_bip68txs(self.nodes[0], bip68inputs, 1)\n-        bip68txs_v2 = create_bip68txs(self.nodes[0], bip68inputs, 2)\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n \n         # For BIP112 test:\n         # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 1)\n-        bip112txs_vary_nSequence_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 2)\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n         # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_9_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 1, -1)\n-        bip112txs_vary_nSequence_9_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 2, -1)\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n         # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 1)\n-        bip112txs_vary_OP_CSV_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 2)\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n         # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_9_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 1, -1)\n-        bip112txs_vary_OP_CSV_9_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 2, -1)\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n         # -1 OP_CSV OP_DROP input\n-        bip112tx_special_v1 = create_bip112special(self.nodes[0], bip112specialinput, 1)\n-        bip112tx_special_v2 = create_bip112special(self.nodes[0], bip112specialinput, 2)\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n         # (empty stack) OP_CSV input\n-        bip112tx_emptystack_v1 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 1)\n-        bip112tx_emptystack_v2 = create_bip112emptystack(self.nodes[0], bip112emptystackinput, 2)\n+        bip112tx_emptystack_v1 = self.create_bip112emptystack(bip112emptystackinput, 1)\n+        bip112tx_emptystack_v2 = self.create_bip112emptystack(bip112emptystackinput, 2)\n \n         self.log.info(\"TESTING\")\n "
      }
    ]
  }
]