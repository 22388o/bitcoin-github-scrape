[
  {
    "sha": "2613c545f529f7c91462c12831d41dcb164bd0e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjEzYzU0NWY1MjlmN2M5MTQ2MmMxMjgzMWQ0MWRjYjE2NGJkMGUy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T14:53:35Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T14:53:35Z"
      },
      "message": "[tests] fix flake8 warnings in sendheaders.py",
      "tree": {
        "sha": "1f4540717c9513f9da59c85dd6847e13ce64cebf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f4540717c9513f9da59c85dd6847e13ce64cebf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2613c545f529f7c91462c12831d41dcb164bd0e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2613c545f529f7c91462c12831d41dcb164bd0e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2613c545f529f7c91462c12831d41dcb164bd0e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2613c545f529f7c91462c12831d41dcb164bd0e2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99bc0b428b03b571afbc311b7f18fd3a707ac5af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99bc0b428b03b571afbc311b7f18fd3a707ac5af",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99bc0b428b03b571afbc311b7f18fd3a707ac5af"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 54,
      "deletions": 38
    },
    "files": [
      {
        "sha": "8fdbcc6c0f9eeb578da7b550ec6f654633424cdb",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 54,
        "deletions": 38,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2613c545f529f7c91462c12831d41dcb164bd0e2/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2613c545f529f7c91462c12831d41dcb164bd0e2/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=2613c545f529f7c91462c12831d41dcb164bd0e2",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test behavior of headers messages to announce blocks.\n \n-Setup: \n+Setup:\n \n - Two nodes, two p2p connections to node0. One p2p connection should only ever\n   receive inv's (omitted from testing description below, this is our control).\n@@ -83,16 +83,32 @@\n e. Announce one more that doesn't connect.\n    Expect: disconnect.\n \"\"\"\n-\n-from test_framework.mininode import *\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import (\n+    CBlockHeader,\n+    CInv,\n+    NODE_WITNESS,\n+    NetworkThread,\n+    NodeConnCB,\n+    mininode_lock,\n+    msg_block,\n+    msg_getblocks,\n+    msg_getdata,\n+    msg_getheaders,\n+    msg_headers,\n+    msg_inv,\n+    msg_sendheaders,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    sync_blocks,\n+    wait_until,\n+)\n \n+DIRECT_FETCH_RESPONSE_TIME = 0.05\n \n-direct_fetch_response_time = 0.05\n-\n-class TestNode(NodeConnCB):\n+class BaseNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n         self.block_announced = False\n@@ -136,8 +152,8 @@ def on_headers(self, conn, message):\n     # right header or the right inv\n     # inv and headers should be lists of block hashes\n     def check_last_announcement(self, headers=None, inv=None):\n-        expect_headers = headers if headers != None else []\n-        expect_inv = inv if inv != None else []\n+        expect_headers = headers if headers is not None else []\n+        expect_inv = inv if inv is not None else []\n         test_function = lambda: self.block_announced\n         wait_until(test_function, timeout=60, lock=mininode_lock)\n         with mininode_lock:\n@@ -153,7 +169,7 @@ def check_last_announcement(self, headers=None, inv=None):\n             hash_headers = []\n             if \"headers\" in self.last_message:\n                 # treat headers as a list of block hashes\n-                hash_headers = [ x.sha256 for x in self.last_message[\"headers\"].headers ]\n+                hash_headers = [x.sha256 for x in self.last_message[\"headers\"].headers]\n             if hash_headers != expect_headers:\n                 success = False\n \n@@ -176,7 +192,7 @@ def wait_for_block_announcement(self, block_hash, timeout=60):\n \n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n-        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n         self.send_message(headers_message)\n \n     def send_getblocks(self, locator):\n@@ -202,27 +218,27 @@ def mine_blocks(self, count):\n     # to-be-reorged-out blocks are mined, so that we don't break later tests.\n     # return the list of block hashes newly mined\n     def mine_reorg(self, length):\n-        self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n+        self.nodes[0].generate(length)  # make sure all invalidated blocks are node0's\n         sync_blocks(self.nodes, wait=0.1)\n         for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n             x.clear_last_announcement()\n \n         tip_height = self.nodes[1].getblockcount()\n-        hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n+        hash_to_invalidate = self.nodes[1].getblockhash(tip_height - (length - 1))\n         self.nodes[1].invalidateblock(hash_to_invalidate)\n-        all_hashes = self.nodes[1].generate(length+1) # Must be longer than the orig chain\n+        all_hashes = self.nodes[1].generate(length + 1)  # Must be longer than the orig chain\n         sync_blocks(self.nodes, wait=0.1)\n         return [int(x, 16) for x in all_hashes]\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        inv_node = self.nodes[0].add_p2p_connection(TestNode())\n+        inv_node = self.nodes[0].add_p2p_connection(BaseNode())\n         # Set nServices to 0 for test_node, so no block download will occur outside of\n         # direct fetching\n-        test_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_WITNESS)\n+        test_node = self.nodes[0].add_p2p_connection(BaseNode(), services=NODE_WITNESS)\n \n-        NetworkThread().start() # Start up network handling in another thread\n+        NetworkThread().start()  # Start up network handling in another thread\n \n         # Test logic begins here\n         inv_node.wait_for_verack()\n@@ -275,18 +291,18 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.get_headers(locator=[old_tip], hashstop=tip)\n                 test_node.get_data([tip])\n                 test_node.wait_for_block(tip)\n-                test_node.clear_last_announcement() # since we requested headers...\n+                test_node.clear_last_announcement()  # since we requested headers...\n             elif i == 2:\n                 # this time announce own block via headers\n                 height = self.nodes[0].getblockcount()\n                 last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n                 block_time = last_time + 1\n-                new_block = create_block(tip, create_coinbase(height+1), block_time)\n+                new_block = create_block(tip, create_coinbase(height + 1), block_time)\n                 new_block.solve()\n                 test_node.send_header_for_blocks([new_block])\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_message(msg_block(new_block))\n-                test_node.sync_with_ping() # make sure this block is processed\n+                test_node.sync_with_ping()  # make sure this block is processed\n                 inv_node.clear_last_announcement()\n                 test_node.clear_last_announcement()\n \n@@ -305,7 +321,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n         assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n \n-        height = self.nodes[0].getblockcount()+1\n+        height = self.nodes[0].getblockcount() + 1\n         block_time += 10  # Advance far enough ahead\n         for i in range(10):\n             # Mine i blocks, and alternate announcing either via\n@@ -314,7 +330,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             # with block header, even though the blocks are never requested\n             for j in range(2):\n                 blocks = []\n-                for b in range(i+1):\n+                for b in range(i + 1):\n                     blocks.append(create_block(tip, create_coinbase(height), block_time))\n                     blocks[-1].solve()\n                     tip = blocks[-1].sha256\n@@ -328,7 +344,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                     test_node.send_header_for_blocks(blocks)\n                     # Test that duplicate inv's won't result in duplicate\n                     # getdata requests, or duplicate headers announcements\n-                    [ inv_node.send_block_inv(x.sha256) for x in blocks ]\n+                    [inv_node.send_block_inv(x.sha256) for x in blocks]\n                     test_node.wait_for_getdata([x.sha256 for x in blocks])\n                     inv_node.sync_with_ping()\n                 else:\n@@ -339,7 +355,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                     # getdata requests (the check is further down)\n                     inv_node.send_header_for_blocks(blocks)\n                     inv_node.sync_with_ping()\n-                [ test_node.send_message(msg_block(x)) for x in blocks ]\n+                [test_node.send_message(msg_block(x)) for x in blocks]\n                 test_node.sync_with_ping()\n                 inv_node.sync_with_ping()\n                 # This block should not be announced to the inv node (since it also\n@@ -365,7 +381,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n             assert_equal(test_node.check_last_announcement(headers=new_block_hashes), True)\n \n-            block_time += 8 \n+            block_time += 8\n \n             # Mine a too-large reorg, which should be announced with a single inv\n             new_block_hashes = self.mine_reorg(length=8)\n@@ -379,7 +395,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             fork_point = int(fork_point, 16)\n \n             # Use getblocks/getdata\n-            test_node.send_getblocks(locator = [fork_point])\n+            test_node.send_getblocks(locator=[fork_point])\n             assert_equal(test_node.check_last_announcement(inv=new_block_hashes), True)\n             test_node.get_data(new_block_hashes)\n             test_node.wait_for_block(new_block_hashes[-1])\n@@ -403,7 +419,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                     test_node.get_data([tip])\n                     test_node.wait_for_block(tip)\n                     # This time, try sending either a getheaders to trigger resumption\n-                    # of headers announcements, or mine a new block and inv it, also \n+                    # of headers announcements, or mine a new block and inv it, also\n                     # triggering resumption of headers announcements.\n                     if j == 0:\n                         test_node.get_headers(locator=[tip], hashstop=0)\n@@ -434,7 +450,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             height += 1\n             inv_node.send_message(msg_block(blocks[-1]))\n \n-        inv_node.sync_with_ping() # Make sure blocks are processed\n+        inv_node.sync_with_ping()  # Make sure blocks are processed\n         test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n@@ -453,9 +469,9 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=direct_fetch_response_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=DIRECT_FETCH_RESPONSE_TIME)\n \n-        [ test_node.send_message(msg_block(x)) for x in blocks ]\n+        [test_node.send_message(msg_block(x)) for x in blocks]\n \n         test_node.sync_with_ping()\n \n@@ -484,13 +500,13 @@ def test_nonnull_locators(self, test_node, inv_node):\n         # both blocks (same work as tip)\n         test_node.send_header_for_blocks(blocks[1:2])\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks[0:2]], timeout=direct_fetch_response_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[0:2]], timeout=DIRECT_FETCH_RESPONSE_TIME)\n \n         # Announcing 16 more headers should trigger direct fetch for 14 more\n         # blocks\n         test_node.send_header_for_blocks(blocks[2:18])\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=direct_fetch_response_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=DIRECT_FETCH_RESPONSE_TIME)\n \n         # Announcing 1 more header should not trigger any response\n         test_node.last_message.pop(\"getdata\", None)\n@@ -502,7 +518,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         self.log.info(\"Part 4: success!\")\n \n         # Now deliver all those blocks we announced.\n-        [ test_node.send_message(msg_block(x)) for x in blocks ]\n+        [test_node.send_message(msg_block(x)) for x in blocks]\n \n         self.log.info(\"Part 5: Testing handling of unconnecting headers\")\n         # First we test that receipt of an unconnecting header doesn't prevent\n@@ -524,15 +540,15 @@ def test_nonnull_locators(self, test_node, inv_node):\n             test_node.wait_for_getheaders()\n             test_node.send_header_for_blocks(blocks)\n             test_node.wait_for_getdata([x.sha256 for x in blocks])\n-            [ test_node.send_message(msg_block(x)) for x in blocks ]\n+            [test_node.send_message(msg_block(x)) for x in blocks]\n             test_node.sync_with_ping()\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), blocks[1].sha256)\n \n         blocks = []\n         # Now we test that if we repeatedly don't send connecting headers, we\n         # don't go into an infinite loop trying to get them to connect.\n         MAX_UNCONNECTING_HEADERS = 10\n-        for j in range(MAX_UNCONNECTING_HEADERS+1):\n+        for j in range(MAX_UNCONNECTING_HEADERS + 1):\n             blocks.append(create_block(tip, create_coinbase(height), block_time))\n             blocks[-1].solve()\n             tip = blocks[-1].sha256\n@@ -554,11 +570,11 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n         # Now try to see how many unconnecting headers we can send\n         # before we get disconnected.  Should be 5*MAX_UNCONNECTING_HEADERS\n-        for i in range(5*MAX_UNCONNECTING_HEADERS - 1):\n+        for i in range(5 * MAX_UNCONNECTING_HEADERS - 1):\n             # Send a header that doesn't connect, check that we get a getheaders.\n             with mininode_lock:\n                 test_node.last_message.pop(\"getheaders\", None)\n-            test_node.send_header_for_blocks([blocks[i%len(blocks)]])\n+            test_node.send_header_for_blocks([blocks[i % len(blocks)]])\n             test_node.wait_for_getheaders()\n \n         # Eventually this stops working."
      }
    ]
  },
  {
    "sha": "f39d4bbd1e328cb04a6ddb133511385491a90d84",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzlkNGJiZDFlMzI4Y2IwNGE2ZGRiMTMzNTExMzg1NDkxYTkwZDg0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T16:07:40Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T16:58:01Z"
      },
      "message": "[tests] tidy up BaseNode in sendheaders.py",
      "tree": {
        "sha": "dacb8c7114200277158ae1b68e092a7f5fe05ccb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dacb8c7114200277158ae1b68e092a7f5fe05ccb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f39d4bbd1e328cb04a6ddb133511385491a90d84",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f39d4bbd1e328cb04a6ddb133511385491a90d84",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f39d4bbd1e328cb04a6ddb133511385491a90d84",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f39d4bbd1e328cb04a6ddb133511385491a90d84/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2613c545f529f7c91462c12831d41dcb164bd0e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2613c545f529f7c91462c12831d41dcb164bd0e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2613c545f529f7c91462c12831d41dcb164bd0e2"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 51,
      "deletions": 53
    },
    "files": [
      {
        "sha": "5c8b70a707d349c6982ef0da3b3588067e0c32d0",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 51,
        "deletions": 53,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f39d4bbd1e328cb04a6ddb133511385491a90d84/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f39d4bbd1e328cb04a6ddb133511385491a90d84/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=f39d4bbd1e328cb04a6ddb133511385491a90d84",
        "patch": "@@ -114,20 +114,14 @@ def __init__(self):\n         self.block_announced = False\n         self.last_blockhash_announced = None\n \n-    def clear_last_announcement(self):\n-        with mininode_lock:\n-            self.block_announced = False\n-            self.last_message.pop(\"inv\", None)\n-            self.last_message.pop(\"headers\", None)\n-\n-    # Request data for a list of block hashes\n-    def get_data(self, block_hashes):\n+    def send_get_data(self, block_hashes):\n+        \"\"\"Request data for a list of block hashes.\"\"\"\n         msg = msg_getdata()\n         for x in block_hashes:\n             msg.inv.append(CInv(2, x))\n         self.connection.send_message(msg)\n \n-    def get_headers(self, locator, hashstop):\n+    def send_get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n         msg.locator.vHave = locator\n         msg.hashstop = hashstop\n@@ -138,6 +132,25 @@ def send_block_inv(self, blockhash):\n         msg.inv = [CInv(2, blockhash)]\n         self.connection.send_message(msg)\n \n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n+        self.send_message(headers_message)\n+\n+    def send_getblocks(self, locator):\n+        getblocks_message = msg_getblocks()\n+        getblocks_message.locator.vHave = locator\n+        self.send_message(getblocks_message)\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list != []:\n+            test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n+            wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_block_announcement(self, block_hash, timeout=60):\n+        test_function = lambda: self.last_blockhash_announced == block_hash\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n     def on_inv(self, conn, message):\n         self.block_announced = True\n         self.last_blockhash_announced = message.inv[-1].hash\n@@ -148,10 +161,16 @@ def on_headers(self, conn, message):\n             message.headers[-1].calc_sha256()\n             self.last_blockhash_announced = message.headers[-1].sha256\n \n-    # Test whether the last announcement we received had the\n-    # right header or the right inv\n-    # inv and headers should be lists of block hashes\n+    def clear_last_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+\n     def check_last_announcement(self, headers=None, inv=None):\n+        \"\"\"Test whether the last announcement received had the right header or the right inv.\n+\n+        inv and headers should be lists of block hashes.\"\"\"\n         expect_headers = headers if headers is not None else []\n         expect_inv = inv if inv is not None else []\n         test_function = lambda: self.block_announced\n@@ -177,47 +196,26 @@ def check_last_announcement(self, headers=None, inv=None):\n             self.last_message.pop(\"headers\", None)\n         return success\n \n-    def wait_for_getdata(self, hash_list, timeout=60):\n-        if hash_list == []:\n-            return\n-\n-        test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-        return\n-\n-    def wait_for_block_announcement(self, block_hash, timeout=60):\n-        test_function = lambda: self.last_blockhash_announced == block_hash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-        return\n-\n-    def send_header_for_blocks(self, new_blocks):\n-        headers_message = msg_headers()\n-        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n-        self.send_message(headers_message)\n-\n-    def send_getblocks(self, locator):\n-        getblocks_message = msg_getblocks()\n-        getblocks_message.locator.vHave = locator\n-        self.send_message(getblocks_message)\n-\n class SendHeadersTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n \n-    # mine count blocks and return the new tip\n     def mine_blocks(self, count):\n+        \"\"\"Mine count blocks and return the new tip.\"\"\"\n+\n         # Clear out last block announcement from each p2p listener\n         [x.clear_last_announcement() for x in self.nodes[0].p2ps]\n         self.nodes[0].generate(count)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n-    # mine a reorg that invalidates length blocks (replacing them with\n-    # length+1 blocks).\n-    # Note: we clear the state of our p2p connections after the\n-    # to-be-reorged-out blocks are mined, so that we don't break later tests.\n-    # return the list of block hashes newly mined\n     def mine_reorg(self, length):\n+        \"\"\"Mine a reorg that invalidates length blocks (replacing them with # length+1 blocks).\n+\n+        Note: we clear the state of our p2p connections after the\n+        to-be-reorged-out blocks are mined, so that we don't break later tests.\n+        return the list of block hashes newly mined.\"\"\"\n+\n         self.nodes[0].generate(length)  # make sure all invalidated blocks are node0's\n         sync_blocks(self.nodes, wait=0.1)\n         for x in self.nodes[0].p2ps:\n@@ -257,15 +255,15 @@ def test_null_locators(self, test_node):\n \n         self.log.info(\"Verify getheaders with null locator and valid hashstop returns headers.\")\n         test_node.clear_last_announcement()\n-        test_node.get_headers(locator=[], hashstop=tip_hash)\n+        test_node.send_get_headers(locator=[], hashstop=tip_hash)\n         assert_equal(test_node.check_last_announcement(headers=[tip_hash]), True)\n \n         self.log.info(\"Verify getheaders with null locator and invalid hashstop does not return headers.\")\n         block = create_block(int(tip[\"hash\"], 16), create_coinbase(tip[\"height\"] + 1), tip[\"mediantime\"] + 1)\n         block.solve()\n         test_node.send_header_for_blocks([block])\n         test_node.clear_last_announcement()\n-        test_node.get_headers(locator=[], hashstop=int(block.hash, 16))\n+        test_node.send_get_headers(locator=[], hashstop=int(block.hash, 16))\n         test_node.sync_with_ping()\n         assert_equal(test_node.block_announced, False)\n         test_node.send_message(msg_block(block))\n@@ -284,12 +282,12 @@ def test_nonnull_locators(self, test_node, inv_node):\n             # Try a few different responses; none should affect next announcement\n             if i == 0:\n                 # first request the block\n-                test_node.get_data([tip])\n+                test_node.send_get_data([tip])\n                 test_node.wait_for_block(tip)\n             elif i == 1:\n                 # next try requesting header and block\n-                test_node.get_headers(locator=[old_tip], hashstop=tip)\n-                test_node.get_data([tip])\n+                test_node.send_get_headers(locator=[old_tip], hashstop=tip)\n+                test_node.send_get_data([tip])\n                 test_node.wait_for_block(tip)\n                 test_node.clear_last_announcement()  # since we requested headers...\n             elif i == 2:\n@@ -313,7 +311,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         # commence and keep working.\n         test_node.send_message(msg_sendheaders())\n         prev_tip = int(self.nodes[0].getbestblockhash(), 16)\n-        test_node.get_headers(locator=[prev_tip], hashstop=0)\n+        test_node.send_get_headers(locator=[prev_tip], hashstop=0)\n         test_node.sync_with_ping()\n \n         # Now that we've synced headers, headers announcements should work\n@@ -397,7 +395,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             # Use getblocks/getdata\n             test_node.send_getblocks(locator=[fork_point])\n             assert_equal(test_node.check_last_announcement(inv=new_block_hashes), True)\n-            test_node.get_data(new_block_hashes)\n+            test_node.send_get_data(new_block_hashes)\n             test_node.wait_for_block(new_block_hashes[-1])\n \n             for i in range(3):\n@@ -407,22 +405,22 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n                 if i == 0:\n                     # Just get the data -- shouldn't cause headers announcements to resume\n-                    test_node.get_data([tip])\n+                    test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n                 elif i == 1:\n                     # Send a getheaders message that shouldn't trigger headers announcements\n                     # to resume (best header sent will be too old)\n-                    test_node.get_headers(locator=[fork_point], hashstop=new_block_hashes[1])\n-                    test_node.get_data([tip])\n+                    test_node.send_get_headers(locator=[fork_point], hashstop=new_block_hashes[1])\n+                    test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n                 elif i == 2:\n-                    test_node.get_data([tip])\n+                    test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n                     # This time, try sending either a getheaders to trigger resumption\n                     # of headers announcements, or mine a new block and inv it, also\n                     # triggering resumption of headers announcements.\n                     if j == 0:\n-                        test_node.get_headers(locator=[tip], hashstop=0)\n+                        test_node.send_get_headers(locator=[tip], hashstop=0)\n                         test_node.sync_with_ping()\n                     else:\n                         test_node.send_block_inv(tip)"
      }
    ]
  },
  {
    "sha": "25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNWZkNmUyYzIwMmMxMTNhMjQxM2JhOWRmNzZmZTBlYTBlNGNiZTVj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T16:52:45Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T17:05:27Z"
      },
      "message": "[tests] refactor check_last_announcement() in sendheaders.py\n\nAll calls of check_last_announcement() asserted that the return\nvalue was True. Just assert inside the function instead. This\ngives better debug information if the assert fails.\n\nAlso only check the contents of the most recent inv and header if\ncheck_last_announcement() is called with the relevant argument.",
      "tree": {
        "sha": "d6fc572fef926c3bdfa74365ebf4bd0c9e92da49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6fc572fef926c3bdfa74365ebf4bd0c9e92da49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f39d4bbd1e328cb04a6ddb133511385491a90d84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f39d4bbd1e328cb04a6ddb133511385491a90d84",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f39d4bbd1e328cb04a6ddb133511385491a90d84"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 24,
      "deletions": 27
    },
    "files": [
      {
        "sha": "1a585dd111f0d7caaf0fb5f3afb124c71c8ca191",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 24,
        "deletions": 27,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
        "patch": "@@ -171,30 +171,27 @@ def check_last_announcement(self, headers=None, inv=None):\n         \"\"\"Test whether the last announcement received had the right header or the right inv.\n \n         inv and headers should be lists of block hashes.\"\"\"\n-        expect_headers = headers if headers is not None else []\n-        expect_inv = inv if inv is not None else []\n+\n         test_function = lambda: self.block_announced\n         wait_until(test_function, timeout=60, lock=mininode_lock)\n+\n         with mininode_lock:\n             self.block_announced = False\n \n-            success = True\n             compare_inv = []\n             if \"inv\" in self.last_message:\n                 compare_inv = [x.hash for x in self.last_message[\"inv\"].inv]\n-            if compare_inv != expect_inv:\n-                success = False\n+            if inv is not None:\n+                assert_equal(compare_inv, inv)\n \n-            hash_headers = []\n+            compare_headers = []\n             if \"headers\" in self.last_message:\n-                # treat headers as a list of block hashes\n-                hash_headers = [x.sha256 for x in self.last_message[\"headers\"].headers]\n-            if hash_headers != expect_headers:\n-                success = False\n+                compare_headers = [x.sha256 for x in self.last_message[\"headers\"].headers]\n+            if headers is not None:\n+                assert_equal(compare_headers, headers)\n \n             self.last_message.pop(\"inv\", None)\n             self.last_message.pop(\"headers\", None)\n-        return success\n \n class SendHeadersTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -256,7 +253,7 @@ def test_null_locators(self, test_node):\n         self.log.info(\"Verify getheaders with null locator and valid hashstop returns headers.\")\n         test_node.clear_last_announcement()\n         test_node.send_get_headers(locator=[], hashstop=tip_hash)\n-        assert_equal(test_node.check_last_announcement(headers=[tip_hash]), True)\n+        test_node.check_last_announcement(headers=[tip_hash])\n \n         self.log.info(\"Verify getheaders with null locator and invalid hashstop does not return headers.\")\n         block = create_block(int(tip[\"hash\"], 16), create_coinbase(tip[\"height\"] + 1), tip[\"mediantime\"] + 1)\n@@ -277,8 +274,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n         for i in range(4):\n             old_tip = tip\n             tip = self.mine_blocks(1)\n-            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            inv_node.check_last_announcement(inv=[tip], headers=[])\n+            test_node.check_last_announcement(inv=[tip], headers=[])\n             # Try a few different responses; none should affect next announcement\n             if i == 0:\n                 # first request the block\n@@ -316,8 +313,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n         # Now that we've synced headers, headers announcements should work\n         tip = self.mine_blocks(1)\n-        assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-        assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+        inv_node.check_last_announcement(inv=[tip], headers=[])\n+        test_node.check_last_announcement(headers=[tip])\n \n         height = self.nodes[0].getblockcount() + 1\n         block_time += 10  # Advance far enough ahead\n@@ -361,8 +358,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 assert \"inv\" not in inv_node.last_message\n                 assert \"headers\" not in inv_node.last_message\n                 tip = self.mine_blocks(1)\n-                assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-                assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+                inv_node.check_last_announcement(inv=[tip], headers=[])\n+                test_node.check_last_announcement(headers=[tip])\n                 height += 1\n                 block_time += 1\n \n@@ -376,16 +373,16 @@ def test_nonnull_locators(self, test_node, inv_node):\n             # First try mining a reorg that can propagate with header announcement\n             new_block_hashes = self.mine_reorg(length=7)\n             tip = new_block_hashes[-1]\n-            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-            assert_equal(test_node.check_last_announcement(headers=new_block_hashes), True)\n+            inv_node.check_last_announcement(inv=[tip], headers=[])\n+            test_node.check_last_announcement(headers=new_block_hashes)\n \n             block_time += 8\n \n             # Mine a too-large reorg, which should be announced with a single inv\n             new_block_hashes = self.mine_reorg(length=8)\n             tip = new_block_hashes[-1]\n-            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            inv_node.check_last_announcement(inv=[tip], headers=[])\n+            test_node.check_last_announcement(inv=[tip], headers=[])\n \n             block_time += 9\n \n@@ -394,15 +391,15 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n             # Use getblocks/getdata\n             test_node.send_getblocks(locator=[fork_point])\n-            assert_equal(test_node.check_last_announcement(inv=new_block_hashes), True)\n+            test_node.check_last_announcement(inv=new_block_hashes, headers=[])\n             test_node.send_get_data(new_block_hashes)\n             test_node.wait_for_block(new_block_hashes[-1])\n \n             for i in range(3):\n                 # Mine another block, still should get only an inv\n                 tip = self.mine_blocks(1)\n-                assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-                assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+                inv_node.check_last_announcement(inv=[tip], headers=[])\n+                test_node.check_last_announcement(inv=[tip], headers=[])\n                 if i == 0:\n                     # Just get the data -- shouldn't cause headers announcements to resume\n                     test_node.send_get_data([tip])\n@@ -427,8 +424,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n                         test_node.sync_with_ping()\n             # New blocks should now be announced with header\n             tip = self.mine_blocks(1)\n-            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n-            assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+            inv_node.check_last_announcement(inv=[tip], headers=[])\n+            test_node.check_last_announcement(headers=[tip])\n \n         self.log.info(\"Part 3: success!\")\n "
      }
    ]
  },
  {
    "sha": "f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMGM0YWI5YTcwMzRhY2E2YmU4M2ZjYjZjZDg0NzljZDE5YTE5NmEy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T16:52:59Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-16T18:45:46Z"
      },
      "message": "[tests] fix flakiness in sendheaders.py\n\nFixes to sources of intermittent failure in sendheaders.py\n\n- at the start of test_null_locators(), a new block is generated and\nthen a getheaders is sent. check_last_accouncement() is called to assert\nthat the headers message is received. However, the new block triggers an\ninv to be sent over both P2P connections, so there's a race. If the inv\nis received at the wrong time, the test fails.\n\n- test_null_locators() ends by sending a block to the node under test.\nAt the start of test_nonnull_locators(), a block is mined and\ncheck_last_announcement() is called to assert that the inv received is\nfor the same block. That means there's a race: if the inv from the block\nsent in test_null_locators() is received at the wrong time, the test\nfails.",
      "tree": {
        "sha": "9094a4b07d53ccb34a14475ea43f5617af96fef4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9094a4b07d53ccb34a14475ea43f5617af96fef4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25fd6e2c202c113a2413ba9df76fe0ea0e4cbe5c"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 8,
      "deletions": 2
    },
    "files": [
      {
        "sha": "056471370b3ba5f6f2c3ca2a0fcb1374471b41b9",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
        "patch": "@@ -243,13 +243,16 @@ def run_test(self):\n         inv_node.sync_with_ping()\n         test_node.sync_with_ping()\n \n-        self.test_null_locators(test_node)\n+        self.test_null_locators(test_node, inv_node)\n         self.test_nonnull_locators(test_node, inv_node)\n \n-    def test_null_locators(self, test_node):\n+    def test_null_locators(self, test_node, inv_node):\n         tip = self.nodes[0].getblockheader(self.nodes[0].generate(1)[0])\n         tip_hash = int(tip[\"hash\"], 16)\n \n+        inv_node.check_last_announcement(inv=[tip_hash], headers=[])\n+        test_node.check_last_announcement(inv=[tip_hash], headers=[])\n+\n         self.log.info(\"Verify getheaders with null locator and valid hashstop returns headers.\")\n         test_node.clear_last_announcement()\n         test_node.send_get_headers(locator=[], hashstop=tip_hash)\n@@ -263,7 +266,10 @@ def test_null_locators(self, test_node):\n         test_node.send_get_headers(locator=[], hashstop=int(block.hash, 16))\n         test_node.sync_with_ping()\n         assert_equal(test_node.block_announced, False)\n+        inv_node.clear_last_announcement()\n         test_node.send_message(msg_block(block))\n+        inv_node.check_last_announcement(inv=[int(block.hash, 16)], headers=[])\n+        inv_node.clear_last_announcement()\n \n     def test_nonnull_locators(self, test_node, inv_node):\n         tip = int(self.nodes[0].getbestblockhash(), 16)"
      }
    ]
  },
  {
    "sha": "9d42cc333139d7101a9223421d9eabcddfd0b025",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDQyY2MzMzMxMzlkNzEwMWE5MjIzNDIxZDllYWJjZGRmZDBiMDI1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-17T22:15:28Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-17T22:15:28Z"
      },
      "message": "[tests] address review comments",
      "tree": {
        "sha": "bb84891e5c9a5616f9fdd8dae710a46f2045d77f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb84891e5c9a5616f9fdd8dae710a46f2045d77f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d42cc333139d7101a9223421d9eabcddfd0b025",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d42cc333139d7101a9223421d9eabcddfd0b025",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d42cc333139d7101a9223421d9eabcddfd0b025",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d42cc333139d7101a9223421d9eabcddfd0b025/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f0c4ab9a7034aca6be83fcb6cd8479cd19a196a2"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 12,
      "deletions": 9
    },
    "files": [
      {
        "sha": "68c0d95b4f9912b6c11a3870423269ab453e103c",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d42cc333139d7101a9223421d9eabcddfd0b025/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d42cc333139d7101a9223421d9eabcddfd0b025/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=9d42cc333139d7101a9223421d9eabcddfd0b025",
        "patch": "@@ -6,9 +6,11 @@\n \n Setup:\n \n-- Two nodes, two p2p connections to node0. One p2p connection should only ever\n-  receive inv's (omitted from testing description below, this is our control).\n-  Second node is used for creating reorgs.\n+- Two nodes:\n+    - node0 is the node-under-test. We create two p2p connections to it. The\n+      first p2p connection is a control and should only ever receive inv's. The\n+      second p2p connection tests the headers sending logic.\n+    - node1 is used to create reorgs.\n \n test_null_locators\n ==================\n@@ -143,9 +145,11 @@ def send_getblocks(self, locator):\n         self.send_message(getblocks_message)\n \n     def wait_for_getdata(self, hash_list, timeout=60):\n-        if hash_list != []:\n-            test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n-            wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_block_announcement(self, block_hash, timeout=60):\n         test_function = lambda: self.last_blockhash_announced == block_hash\n@@ -229,8 +233,8 @@ def mine_reorg(self, length):\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         inv_node = self.nodes[0].add_p2p_connection(BaseNode())\n-        # Set nServices to 0 for test_node, so no block download will occur outside of\n-        # direct fetching\n+        # Make sure NODE_NETWORK is not set for test_node, so no block download\n+        # will occur outside of direct fetching\n         test_node = self.nodes[0].add_p2p_connection(BaseNode(), services=NODE_WITNESS)\n \n         NetworkThread().start()  # Start up network handling in another thread\n@@ -269,7 +273,6 @@ def test_null_locators(self, test_node, inv_node):\n         inv_node.clear_last_announcement()\n         test_node.send_message(msg_block(block))\n         inv_node.check_last_announcement(inv=[int(block.hash, 16)], headers=[])\n-        inv_node.clear_last_announcement()\n \n     def test_nonnull_locators(self, test_node, inv_node):\n         tip = int(self.nodes[0].getbestblockhash(), 16)"
      }
    ]
  }
]