[
  {
    "sha": "391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTFhN2I3ZGJmMTE5ZjNmYTE2YzgwODM0YThlZmY0ZGQxNzI3ZDZi",
    "commit": {
      "author": {
        "name": "alex",
        "email": "alex.sd3@gmail.com",
        "date": "2018-05-24T08:36:30Z"
      },
      "committer": {
        "name": "alex",
        "email": "alex.sd3@gmail.com",
        "date": "2018-05-24T13:05:23Z"
      },
      "message": "remove ZMQ message limit",
      "tree": {
        "sha": "8b8010a0bd78336cb40e736bae942feeb4fa2dee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b8010a0bd78336cb40e736bae942feeb4fa2dee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/comments",
    "author": {
      "login": "Alex-CodeLab",
      "id": 1678423,
      "node_id": "MDQ6VXNlcjE2Nzg0MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1678423?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Alex-CodeLab",
      "html_url": "https://github.com/Alex-CodeLab",
      "followers_url": "https://api.github.com/users/Alex-CodeLab/followers",
      "following_url": "https://api.github.com/users/Alex-CodeLab/following{/other_user}",
      "gists_url": "https://api.github.com/users/Alex-CodeLab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Alex-CodeLab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Alex-CodeLab/subscriptions",
      "organizations_url": "https://api.github.com/users/Alex-CodeLab/orgs",
      "repos_url": "https://api.github.com/users/Alex-CodeLab/repos",
      "events_url": "https://api.github.com/users/Alex-CodeLab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Alex-CodeLab/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Alex-CodeLab",
      "id": 1678423,
      "node_id": "MDQ6VXNlcjE2Nzg0MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1678423?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Alex-CodeLab",
      "html_url": "https://github.com/Alex-CodeLab",
      "followers_url": "https://api.github.com/users/Alex-CodeLab/followers",
      "following_url": "https://api.github.com/users/Alex-CodeLab/following{/other_user}",
      "gists_url": "https://api.github.com/users/Alex-CodeLab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Alex-CodeLab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Alex-CodeLab/subscriptions",
      "organizations_url": "https://api.github.com/users/Alex-CodeLab/orgs",
      "repos_url": "https://api.github.com/users/Alex-CodeLab/repos",
      "events_url": "https://api.github.com/users/Alex-CodeLab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Alex-CodeLab/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f4db9a7c3549a36e45d70fc3c159367aa1e99a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f4db9a7c3549a36e45d70fc3c159367aa1e99a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f4db9a7c3549a36e45d70fc3c159367aa1e99a4"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2cbd0dd263d1c5ab0f29a57003e3e871fdbc0a77",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "patch": "@@ -46,6 +46,7 @@ def __init__(self):\n         self.zmqContext = zmq.asyncio.Context()\n \n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")"
      },
      {
        "sha": "d27135fcc87127e9555e3aa2825b9e51ecb6c98d",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "patch": "@@ -75,6 +75,9 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n             zmqError(\"Failed to create socket\");\n             return false;\n         }\n+        \n+        int HWMlimit = 0;\n+        zmq_setsockopt(psocket, ZMQ_SNDHWM, &HWMlimit, sizeof(HWMlimit));\n \n         int rc = zmq_bind(psocket, address.c_str());\n         if (rc!=0)"
      }
    ]
  },
  {
    "sha": "43dd7dabf153afe6113fb533a31052cff8f25061",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0M2RkN2RhYmYxNTNhZmU2MTEzZmI1MzNhMzEwNTJjZmY4ZjI1MDYx",
    "commit": {
      "author": {
        "name": "Alex \u26a1",
        "email": "1678423+FeedTheWeb@users.noreply.github.com",
        "date": "2018-06-30T13:52:07Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-06-30T13:52:07Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nmerge upstr.",
      "tree": {
        "sha": "862effa032761e9fcf22b3849b294111b85bfbd3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/862effa032761e9fcf22b3849b294111b85bfbd3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43dd7dabf153afe6113fb533a31052cff8f25061",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbN4sHCRBK7hj4Ov3rIwAAdHIIAHjnwz9ad6r+rqDH+iwI+AL6\nGijMtuCwAqLC5vFazA647HUrzdE2KGAgdGAEiQYP3xQJOmTsbsIzQmeJHHKqCPWd\nnFVNwISuVhZOOUUPAKurLsrL4iAGAaTkUQQhxt9NYGtV2YSPODfuICr2zZhX8tdG\nQcHZXvR2HdSicZgH+7R7+0Wg7g1QrfiBiUMxJ23rp+RHUFhCGL+gui6OTyy97ffX\neM+QPTlqxw4FwE0+aKrR4ug9LbRjC+KVQsjvTZ7p1d44oBzxN0OkzEAY8+rwxaxt\n/6BTsu03OgibkSqQXnJQ1PDjlzPczAylDYzpfsPzZfp0ZoP9QUS4c0CJpvkHCN0=\n=2gtb\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 862effa032761e9fcf22b3849b294111b85bfbd3\nparent 391a7b7dbf119f3fa16c80834a8eff4dd1727d6b\nparent a6ed99a1e6facd38913711106bce6fb65bd14862\nauthor Alex \u26a1 <1678423+FeedTheWeb@users.noreply.github.com> 1530366727 +0200\ncommitter GitHub <noreply@github.com> 1530366727 +0200\n\nMerge pull request #1 from bitcoin/master\n\nmerge upstr."
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43dd7dabf153afe6113fb533a31052cff8f25061",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/43dd7dabf153afe6113fb533a31052cff8f25061",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43dd7dabf153afe6113fb533a31052cff8f25061/comments",
    "author": {
      "login": "Alex-CodeLab",
      "id": 1678423,
      "node_id": "MDQ6VXNlcjE2Nzg0MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1678423?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Alex-CodeLab",
      "html_url": "https://github.com/Alex-CodeLab",
      "followers_url": "https://api.github.com/users/Alex-CodeLab/followers",
      "following_url": "https://api.github.com/users/Alex-CodeLab/following{/other_user}",
      "gists_url": "https://api.github.com/users/Alex-CodeLab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Alex-CodeLab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Alex-CodeLab/subscriptions",
      "organizations_url": "https://api.github.com/users/Alex-CodeLab/orgs",
      "repos_url": "https://api.github.com/users/Alex-CodeLab/repos",
      "events_url": "https://api.github.com/users/Alex-CodeLab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Alex-CodeLab/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b"
      },
      {
        "sha": "a6ed99a1e6facd38913711106bce6fb65bd14862",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6ed99a1e6facd38913711106bce6fb65bd14862",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a6ed99a1e6facd38913711106bce6fb65bd14862"
      }
    ],
    "stats": {
      "total": 8858,
      "additions": 5726,
      "deletions": 3132
    },
    "files": [
      {
        "sha": "ec78896f443382ad5930ba6da9e49e55ad86914e",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 40,
        "deletions": 35,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -19,58 +19,60 @@ env:\n     - CCACHE_SIZE=100M\n     - CCACHE_TEMPDIR=/tmp/.ccache-temp\n     - CCACHE_COMPRESS=1\n+    - CCACHE_DIR=$HOME/.ccache\n     - BASE_OUTDIR=$TRAVIS_BUILD_DIR/out\n     - SDK_URL=https://bitcoincore.org/depends-sources/sdks\n     - WINEDEBUG=fixme-all\n+    - DOCKER_PACKAGES=\"build-essential libtool autotools-dev automake pkg-config bsdmainutils curl git ca-certificates ccache\"\n   matrix:\n # ARM\n     - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n-    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine-binfmt wine32\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # Win64\n-    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=x86_64-w64-mingw32 DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" CONFIG_SHELL=\"/bin/dash\"\n # x86_64 Linux (uses qt5 dev package instead of depends Qt to speed up build and avoid timeout)\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools protobuf-compiler libdbus-1-dev libharfbuzz-dev\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1 ALLOW_HOST_PACKAGES=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n-# Qt4 & system libs\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qt4-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev libdb5.1++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev xvfb\" NO_DEPENDS=1 NEED_XVFB=1 RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt4 CPPFLAGS=-DDEBUG_LOCKORDER\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools protobuf-compiler libdbus-1-dev libharfbuzz-dev libprotobuf-dev\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1 ALLOW_HOST_PACKAGES=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports --enable-debug\"\n+# x86_64 Linux (Qt5 & system libs)\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools libssl1.0-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\" NO_DEPENDS=1 RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER\"\n # x86_64 Linux, No wallet\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n-    - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports --enable-werror\" OSX_SDK=10.11 GOAL=\"deploy\"\n+    - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev python3-setuptools-git\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports --enable-werror\" OSX_SDK=10.11 GOAL=\"all deploy\"\n \n before_install:\n     - export PATH=$(echo $PATH | tr ':' \"\\n\" | sed '/\\/opt\\/python/d' | tr \"\\n\" \":\" | sed \"s|::|:|g\")\n install:\n-    - if [ -n \"$DPKG_ADD_ARCH\" ]; then sudo dpkg --add-architecture \"$DPKG_ADD_ARCH\" ; fi\n-    - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n-    - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n+    - env | grep -E '^(CCACHE_|WINEDEBUG|BOOST_TEST_RANDOM|CONFIG_SHELL)' | tee /tmp/env\n+    - if [[ $HOST = *-mingw32 ]]; then DOCKER_ADMIN=\"--cap-add SYS_ADMIN\"; fi\n+    - DOCKER_ID=$(docker run $DOCKER_ADMIN -idt --mount type=bind,src=$TRAVIS_BUILD_DIR,dst=$TRAVIS_BUILD_DIR --mount type=bind,src=$CCACHE_DIR,dst=$CCACHE_DIR -w $TRAVIS_BUILD_DIR --env-file /tmp/env ubuntu:18.04)\n+    - DOCKER_EXEC () { docker exec $DOCKER_ID bash -c \"cd $PWD && $*\"; }\n+    - if [ -n \"$DPKG_ADD_ARCH\" ]; then DOCKER_EXEC dpkg --add-architecture \"$DPKG_ADD_ARCH\" ; fi\n+    - travis_retry DOCKER_EXEC apt-get update\n+    - travis_retry DOCKER_EXEC apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES $DOCKER_PACKAGES\n before_script:\n-    - unset CC; unset CXX\n     - mkdir -p depends/SDKs depends/sdk-sources\n     - if [ -n \"$OSX_SDK\" -a ! -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then curl --location --fail $SDK_URL/MacOSX${OSX_SDK}.sdk.tar.gz -o depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n     - if [ -n \"$OSX_SDK\" -a -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then tar -C depends/SDKs -xf depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n-    - if [ -z \"$NO_DEPENDS\" ]; then make $MAKEJOBS -C depends HOST=$HOST $DEP_OPTS; fi\n-    # Start xvfb if needed, as documented at https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\n-    - if [ \"$NEED_XVFB\" = 1 ]; then export DISPLAY=:99.0; /sbin/start-stop-daemon --start --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -ac; fi\n+    - if [[ $HOST = *-mingw32 ]]; then DOCKER_EXEC update-alternatives --set $HOST-g++ \\$\\(which $HOST-g++-posix\\); fi\n+    - if [ -z \"$NO_DEPENDS\" ]; then DOCKER_EXEC CONFIG_SHELL= make $MAKEJOBS -C depends HOST=$HOST $DEP_OPTS; fi\n script:\n     - export TRAVIS_COMMIT_LOG=`git log --format=fuller -1`\n-    - if [ -n \"$USE_SHELL\" ]; then export CONFIG_SHELL=\"$USE_SHELL\"; fi\n     - OUTDIR=$BASE_OUTDIR/$TRAVIS_PULL_REQUEST/$TRAVIS_JOB_NUMBER-$HOST\n     - BITCOIN_CONFIG_ALL=\"--disable-dependency-tracking --prefix=$TRAVIS_BUILD_DIR/depends/$HOST --bindir=$OUTDIR/bin --libdir=$OUTDIR/lib\"\n-    - if [ -z \"$NO_DEPENDS\" ]; then ccache --max-size=$CCACHE_SIZE; fi\n-    - test -n \"$USE_SHELL\" && eval '\"$USE_SHELL\" -c \"./autogen.sh\"' || ./autogen.sh\n+    - if [ -z \"$NO_DEPENDS\" ]; then DOCKER_EXEC ccache --max-size=$CCACHE_SIZE; fi\n+    - test -n \"$CONFIG_SHELL\" && DOCKER_EXEC \"$CONFIG_SHELL\" -c \"./autogen.sh\" || DOCKER_EXEC ./autogen.sh\n     - mkdir build && cd build\n-    - ../configure --cache-file=config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n-    - make distdir VERSION=$HOST\n+    - DOCKER_EXEC ../configure --cache-file=config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n+    - DOCKER_EXEC make distdir VERSION=$HOST\n     - cd bitcoin-$HOST\n-    - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n-    - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n-    - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 50 make $MAKEJOBS check VERBOSE=1; fi\n+    - DOCKER_EXEC ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n+    - DOCKER_EXEC make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && DOCKER_EXEC make $GOAL V=1 ; false )\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then DOCKER_EXEC LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude feature_pruning,feature_dbcrash\"; fi\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet --failfast ${extended}; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then DOCKER_EXEC test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet --failfast ${extended}; fi\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n@@ -79,23 +81,26 @@ jobs:\n   include:\n     - stage: lint\n       sudo: false\n+      cache: false\n       addons:\n         apt:\n           packages:\n             - python3-pip\n             - shellcheck\n       install:\n-        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then travis_retry pip3 install flake8 --user; fi\n+        - travis_retry pip3 install flake8 --user\n       before_script:\n         - git fetch --unshallow\n-        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n-        - contrib/devtools/git-subtree-check.sh src/crypto/ctaes\n-        - contrib/devtools/git-subtree-check.sh src/secp256k1\n-        - contrib/devtools/git-subtree-check.sh src/univalue\n-        - contrib/devtools/git-subtree-check.sh src/leveldb\n-        - contrib/devtools/check-doc.py\n-        - contrib/devtools/check-rpc-mappings.py .\n-        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/lint-all.sh; fi\n       script:\n-        - if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n-        - if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then travis_wait 30 contrib/verify-commits/verify-commits.sh; fi\n+        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then test/lint/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n+        - test/lint/git-subtree-check.sh src/crypto/ctaes\n+        - test/lint/git-subtree-check.sh src/secp256k1\n+        - test/lint/git-subtree-check.sh src/univalue\n+        - test/lint/git-subtree-check.sh src/leveldb\n+        - test/lint/check-doc.py\n+        - test/lint/check-rpc-mappings.py .\n+        - test/lint/lint-all.sh\n+        - if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then\n+              while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys &&\n+              travis_wait 50 contrib/verify-commits/verify-commits.py;\n+          fi"
      },
      {
        "sha": "3ee5a04796e75462be07fea2c0e9720e1dc76cfc",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -127,10 +127,10 @@ before it will be merged. The basic squashing workflow is shown below.\n \n     git checkout your_branch_name\n     git rebase -i HEAD~n\n-    # n is normally the number of commits in the pull\n-    # set commits from 'pick' to 'squash', save and quit\n-    # on the next screen, edit/refine commit messages\n-    # save and quit\n+    # n is normally the number of commits in the pull request.\n+    # Set commits (except the one in the first line) from 'pick' to 'squash', save and quit.\n+    # On the next screen, edit/refine commit messages.\n+    # Save and quit.\n     git push -f # (force push to GitHub)\n \n If you have problems with squashing (or other workflows with `git`), you can"
      },
      {
        "sha": "f3f3302fce77bdf7eaf21c2d87f4ad62b224e306",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -95,9 +95,9 @@ $(OSX_APP)/Contents/Resources/bitcoin.icns: $(OSX_INSTALLER_ICONS)\n \t$(MKDIR_P) $(@D)\n \t$(INSTALL_DATA) $< $@\n \n-$(OSX_APP)/Contents/MacOS/Bitcoin-Qt: $(BITCOIN_QT_BIN)\n+$(OSX_APP)/Contents/MacOS/Bitcoin-Qt: all-recursive\n \t$(MKDIR_P) $(@D)\n-\tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM)  $< $@\n+\tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM)  $(BITCOIN_QT_BIN) $@\n \n $(OSX_APP)/Contents/Resources/Base.lproj/InfoPlist.strings:\n \t$(MKDIR_P) $(@D)"
      },
      {
        "sha": "4e830109c21dc2f1d25a01c95ce19a228a1cb772",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -52,7 +52,7 @@ There are also [regression and integration tests](/test), written\n in Python, that are run automatically on the build server.\n These tests can be run (if the [test dependencies](/test) are installed) with: `test/functional/test_runner.py`\n \n-The Travis CI system makes sure that every pull request is built for Windows, Linux, and OS X, and that unit/sanity tests are run automatically.\n+The Travis CI system makes sure that every pull request is built for Windows, Linux, and macOS, and that unit/sanity tests are run automatically.\n \n ### Manual Quality Assurance (QA) Testing\n "
      },
      {
        "sha": "0c05626ccce5852cac8f496ba228025151297ddc",
        "filename": "autogen.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n set -e\n srcdir=\"$(dirname $0)\"\n cd \"$srcdir\""
      },
      {
        "sha": "fe0cc6c36d14b9e069d7c21712f189a07f86bdc2",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 90,
        "deletions": 147,
        "changes": 237,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -53,8 +53,8 @@ dnl CAUTION: Do not use this inside of a conditional.\n AC_DEFUN([BITCOIN_QT_INIT],[\n   dnl enable qt support\n   AC_ARG_WITH([gui],\n-    [AS_HELP_STRING([--with-gui@<:@=no|qt4|qt5|auto@:>@],\n-    [build bitcoin-qt GUI (default=auto, qt5 tried first)])],\n+    [AS_HELP_STRING([--with-gui@<:@=no|qt5|auto@:>@],\n+    [build bitcoin-qt GUI (default=auto)])],\n     [\n      bitcoin_qt_want_version=$withval\n      if test \"x$bitcoin_qt_want_version\" = xyes; then\n@@ -94,82 +94,66 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   fi\n \n   if test \"x$use_pkgconfig\" = xyes; then\n-    BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG([$2])])\n+    BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG])\n   else\n     BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG])\n   fi\n \n   dnl This is ugly and complicated. Yuck. Works as follows:\n-  dnl We can't discern whether Qt4 builds are static or not. For Qt5, we can\n-  dnl check a header to find out. When Qt is built statically, some plugins must\n-  dnl be linked into the final binary as well. These plugins have changed between\n-  dnl Qt4 and Qt5. With Qt5, languages moved into core and the WindowsIntegration\n-  dnl plugin was added. Since we can't tell if Qt4 is static or not, it is\n-  dnl assumed for windows builds.\n+  dnl For Qt5, we can check a header to find out whether Qt is build\n+  dnl statically. When Qt is built statically, some plugins must be linked into\n+  dnl the final binary as well.\n+  dnl With Qt5, languages moved into core and the WindowsIntegration plugin was\n+  dnl added.\n   dnl _BITCOIN_QT_CHECK_STATIC_PLUGINS does a quick link-check and appends the\n   dnl results to QT_LIBS.\n   BITCOIN_QT_CHECK([\n   TEMP_CPPFLAGS=$CPPFLAGS\n   TEMP_CXXFLAGS=$CXXFLAGS\n   CPPFLAGS=\"$QT_INCLUDES $CPPFLAGS\"\n   CXXFLAGS=\"$PIC_FLAGS $CXXFLAGS\"\n-  if test \"x$bitcoin_qt_got_major_vers\" = x5; then\n-    _BITCOIN_QT_IS_STATIC\n-    if test \"x$bitcoin_cv_static_qt\" = xyes; then\n-      _BITCOIN_QT_FIND_STATIC_PLUGINS\n-      AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n-      AC_CACHE_CHECK(for Qt < 5.4, bitcoin_cv_need_acc_widget,[\n-        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-            #include <QtCore/qconfig.h>\n-            #ifndef QT_VERSION\n-            #  include <QtCore/qglobal.h>\n-            #endif\n-          ]],\n-          [[\n-            #if QT_VERSION >= 0x050400\n-            choke\n-            #endif\n-          ]])],\n-        [bitcoin_cv_need_acc_widget=yes],\n-        [bitcoin_cv_need_acc_widget=no])\n-      ])\n-      if test \"x$bitcoin_cv_need_acc_widget\" = xyes; then\n-        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(AccessibleFactory)], [-lqtaccessiblewidgets])\n-      fi\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin)],[-lqminimal])\n-      AC_DEFINE(QT_QPA_PLATFORM_MINIMAL, 1, [Define this symbol if the minimal qt platform exists])\n-      if test \"x$TARGET_OS\" = xwindows; then\n-        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n-        AC_DEFINE(QT_QPA_PLATFORM_WINDOWS, 1, [Define this symbol if the qt platform is windows])\n-      elif test \"x$TARGET_OS\" = xlinux; then\n-        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QXcbIntegrationPlugin)],[-lqxcb -lxcb-static])\n-        AC_DEFINE(QT_QPA_PLATFORM_XCB, 1, [Define this symbol if the qt platform is xcb])\n-      elif test \"x$TARGET_OS\" = xdarwin; then\n-        AX_CHECK_LINK_FLAG([[-framework IOKit]],[QT_LIBS=\"$QT_LIBS -framework IOKit\"],[AC_MSG_ERROR(could not iokit framework)])\n-        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin)],[-lqcocoa])\n-        AC_DEFINE(QT_QPA_PLATFORM_COCOA, 1, [Define this symbol if the qt platform is cocoa])\n-      fi\n+  _BITCOIN_QT_IS_STATIC\n+  if test \"x$bitcoin_cv_static_qt\" = xyes; then\n+    _BITCOIN_QT_FIND_STATIC_PLUGINS\n+    AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n+    AC_CACHE_CHECK(for Qt < 5.4, bitcoin_cv_need_acc_widget,[\n+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+          #include <QtCore/qconfig.h>\n+          #ifndef QT_VERSION\n+          #  include <QtCore/qglobal.h>\n+          #endif\n+        ]],\n+        [[\n+          #if QT_VERSION >= 0x050400\n+          choke\n+          #endif\n+        ]])],\n+      [bitcoin_cv_need_acc_widget=yes],\n+      [bitcoin_cv_need_acc_widget=no])\n+    ])\n+    if test \"x$bitcoin_cv_need_acc_widget\" = xyes; then\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(AccessibleFactory)], [-lqtaccessiblewidgets])\n     fi\n-  else\n+    _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin)],[-lqminimal])\n+    AC_DEFINE(QT_QPA_PLATFORM_MINIMAL, 1, [Define this symbol if the minimal qt platform exists])\n     if test \"x$TARGET_OS\" = xwindows; then\n-      AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([\n-         Q_IMPORT_PLUGIN(qcncodecs)\n-         Q_IMPORT_PLUGIN(qjpcodecs)\n-         Q_IMPORT_PLUGIN(qtwcodecs)\n-         Q_IMPORT_PLUGIN(qkrcodecs)\n-         Q_IMPORT_PLUGIN(AccessibleFactory)],\n-         [-lqcncodecs -lqjpcodecs -lqtwcodecs -lqkrcodecs -lqtaccessiblewidgets])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n+      AC_DEFINE(QT_QPA_PLATFORM_WINDOWS, 1, [Define this symbol if the qt platform is windows])\n+    elif test \"x$TARGET_OS\" = xlinux; then\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QXcbIntegrationPlugin)],[-lqxcb -lxcb-static])\n+      AC_DEFINE(QT_QPA_PLATFORM_XCB, 1, [Define this symbol if the qt platform is xcb])\n+    elif test \"x$TARGET_OS\" = xdarwin; then\n+      AX_CHECK_LINK_FLAG([[-framework IOKit]],[QT_LIBS=\"$QT_LIBS -framework IOKit\"],[AC_MSG_ERROR(could not iokit framework)])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin)],[-lqcocoa])\n+      AC_DEFINE(QT_QPA_PLATFORM_COCOA, 1, [Define this symbol if the qt platform is cocoa])\n     fi\n   fi\n   CPPFLAGS=$TEMP_CPPFLAGS\n   CXXFLAGS=$TEMP_CXXFLAGS\n   ])\n \n   if test \"x$use_pkgconfig$qt_bin_path\" = xyes; then\n-    if test \"x$bitcoin_qt_got_major_vers\" = x5; then\n-      qt_bin_path=\"`$PKG_CONFIG --variable=host_bins Qt5Core 2>/dev/null`\"\n-    fi\n+    qt_bin_path=\"`$PKG_CONFIG --variable=host_bins Qt5Core 2>/dev/null`\"\n   fi\n \n   if test \"x$use_hardening\" != xno; then\n@@ -219,11 +203,11 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n     ])\n   fi\n \n-  BITCOIN_QT_PATH_PROGS([MOC], [moc-qt${bitcoin_qt_got_major_vers} moc${bitcoin_qt_got_major_vers} moc], $qt_bin_path)\n-  BITCOIN_QT_PATH_PROGS([UIC], [uic-qt${bitcoin_qt_got_major_vers} uic${bitcoin_qt_got_major_vers} uic], $qt_bin_path)\n-  BITCOIN_QT_PATH_PROGS([RCC], [rcc-qt${bitcoin_qt_got_major_vers} rcc${bitcoin_qt_got_major_vers} rcc], $qt_bin_path)\n-  BITCOIN_QT_PATH_PROGS([LRELEASE], [lrelease-qt${bitcoin_qt_got_major_vers} lrelease${bitcoin_qt_got_major_vers} lrelease], $qt_bin_path)\n-  BITCOIN_QT_PATH_PROGS([LUPDATE], [lupdate-qt${bitcoin_qt_got_major_vers} lupdate${bitcoin_qt_got_major_vers} lupdate],$qt_bin_path, yes)\n+  BITCOIN_QT_PATH_PROGS([MOC], [moc-qt5 moc5 moc], $qt_bin_path)\n+  BITCOIN_QT_PATH_PROGS([UIC], [uic-qt5 uic5 uic], $qt_bin_path)\n+  BITCOIN_QT_PATH_PROGS([RCC], [rcc-qt5 rcc5 rcc], $qt_bin_path)\n+  BITCOIN_QT_PATH_PROGS([LRELEASE], [lrelease-qt5 lrelease5 lrelease], $qt_bin_path)\n+  BITCOIN_QT_PATH_PROGS([LUPDATE], [lupdate-qt5 lupdate5 lupdate],$qt_bin_path, yes)\n \n   MOC_DEFS='-DHAVE_CONFIG_H -I$(srcdir)'\n   case $host in\n@@ -262,7 +246,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   ],[\n     bitcoin_enable_qt=no\n   ])\n-  AC_MSG_RESULT([$bitcoin_enable_qt (Qt${bitcoin_qt_got_major_vers})])\n+  AC_MSG_RESULT([$bitcoin_enable_qt (Qt5)])\n \n   AC_SUBST(QT_PIE_FLAGS)\n   AC_SUBST(QT_INCLUDES)\n@@ -272,7 +256,7 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   AC_SUBST(QT_DBUS_LIBS)\n   AC_SUBST(QT_TEST_INCLUDES)\n   AC_SUBST(QT_TEST_LIBS)\n-  AC_SUBST(QT_SELECT, qt${bitcoin_qt_got_major_vers})\n+  AC_SUBST(QT_SELECT, qt5)\n   AC_SUBST(MOC_DEFS)\n ])\n \n@@ -301,7 +285,7 @@ AC_DEFUN([_BITCOIN_QT_CHECK_QT5],[\n ])])\n \n dnl Internal. Check if the linked version of Qt was built as static libs.\n-dnl Requires: Qt5. This check cannot determine if Qt4 is static.\n+dnl Requires: Qt5.\n dnl Requires: INCLUDES and LIBS must be populated as necessary.\n dnl Output: bitcoin_cv_static_qt=yes|no\n dnl Output: Defines QT_STATICPLUGIN if plugins are static.\n@@ -346,58 +330,50 @@ AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_PLUGINS],[\n ])\n \n dnl Internal. Find paths necessary for linking qt static plugins\n-dnl Inputs: bitcoin_qt_got_major_vers. 4 or 5.\n dnl Inputs: qt_plugin_path. optional.\n dnl Outputs: QT_LIBS is appended\n AC_DEFUN([_BITCOIN_QT_FIND_STATIC_PLUGINS],[\n-  if test \"x$bitcoin_qt_got_major_vers\" = x5; then\n-      if test \"x$qt_plugin_path\" != x; then\n-        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms\"\n-        if test -d \"$qt_plugin_path/accessible\"; then\n-          QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n-        fi\n+    if test \"x$qt_plugin_path\" != x; then\n+      QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms\"\n+      if test -d \"$qt_plugin_path/accessible\"; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n       fi\n-     if test \"x$use_pkgconfig\" = xyes; then\n-     : dnl\n-     m4_ifdef([PKG_CHECK_MODULES],[\n-       PKG_CHECK_MODULES([QTPLATFORM], [Qt5PlatformSupport], [QT_LIBS=\"$QTPLATFORM_LIBS $QT_LIBS\"])\n-       if test \"x$TARGET_OS\" = xlinux; then\n-         PKG_CHECK_MODULES([X11XCB], [x11-xcb], [QT_LIBS=\"$X11XCB_LIBS $QT_LIBS\"])\n-         if ${PKG_CONFIG} --exists \"Qt5Core >= 5.5\" 2>/dev/null; then\n-           PKG_CHECK_MODULES([QTXCBQPA], [Qt5XcbQpa], [QT_LIBS=\"$QTXCBQPA_LIBS $QT_LIBS\"])\n-         fi\n-       elif test \"x$TARGET_OS\" = xdarwin; then\n-         PKG_CHECK_MODULES([QTPRINT], [Qt5PrintSupport], [QT_LIBS=\"$QTPRINT_LIBS $QT_LIBS\"])\n+    fi\n+   if test \"x$use_pkgconfig\" = xyes; then\n+   : dnl\n+   m4_ifdef([PKG_CHECK_MODULES],[\n+     PKG_CHECK_MODULES([QTPLATFORM], [Qt5PlatformSupport], [QT_LIBS=\"$QTPLATFORM_LIBS $QT_LIBS\"])\n+     if test \"x$TARGET_OS\" = xlinux; then\n+       PKG_CHECK_MODULES([X11XCB], [x11-xcb], [QT_LIBS=\"$X11XCB_LIBS $QT_LIBS\"])\n+       if ${PKG_CONFIG} --exists \"Qt5Core >= 5.5\" 2>/dev/null; then\n+         PKG_CHECK_MODULES([QTXCBQPA], [Qt5XcbQpa], [QT_LIBS=\"$QTXCBQPA_LIBS $QT_LIBS\"])\n        fi\n-     ])\n-     else\n-       if test \"x$TARGET_OS\" = xwindows; then\n-         AC_CACHE_CHECK(for Qt >= 5.6, bitcoin_cv_need_platformsupport,[\n-           AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-               #include <QtCore/qconfig.h>\n-               #ifndef QT_VERSION\n-               #  include <QtCore/qglobal.h>\n-               #endif\n-             ]],\n-             [[\n-               #if QT_VERSION < 0x050600\n-               choke\n-               #endif\n-             ]])],\n-           [bitcoin_cv_need_platformsupport=yes],\n-           [bitcoin_cv_need_platformsupport=no])\n-         ])\n-         if test \"x$bitcoin_cv_need_platformsupport\" = xyes; then\n-           BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}PlatformSupport],[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}PlatformSupport not found)))\n-         fi\n+     elif test \"x$TARGET_OS\" = xdarwin; then\n+       PKG_CHECK_MODULES([QTPRINT], [Qt5PrintSupport], [QT_LIBS=\"$QTPRINT_LIBS $QT_LIBS\"])\n+     fi\n+   ])\n+   else\n+     if test \"x$TARGET_OS\" = xwindows; then\n+       AC_CACHE_CHECK(for Qt >= 5.6, bitcoin_cv_need_platformsupport,[\n+         AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+             #include <QtCore/qconfig.h>\n+             #ifndef QT_VERSION\n+             #  include <QtCore/qglobal.h>\n+             #endif\n+           ]],\n+           [[\n+             #if QT_VERSION < 0x050600\n+             choke\n+             #endif\n+           ]])],\n+         [bitcoin_cv_need_platformsupport=yes],\n+         [bitcoin_cv_need_platformsupport=no])\n+       ])\n+       if test \"x$bitcoin_cv_need_platformsupport\" = xyes; then\n+         BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}PlatformSupport],[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}PlatformSupport not found)))\n        fi\n      fi\n-  else\n-    if test \"x$qt_plugin_path\" != x; then\n-      QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n-      QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/codecs\"\n-    fi\n-  fi\n+   fi\n ])\n \n dnl Internal. Find Qt libraries using pkg-config.\n@@ -406,38 +382,14 @@ dnl         first.\n dnl Inputs: $1: If bitcoin_qt_want_version is \"auto\", check for this version\n dnl         first.\n dnl Outputs: All necessary QT_* variables are set.\n-dnl Outputs: bitcoin_qt_got_major_vers is set to \"4\" or \"5\".\n dnl Outputs: have_qt_test and have_qt_dbus are set (if applicable) to yes|no.\n AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG],[\n   m4_ifdef([PKG_CHECK_MODULES],[\n-  auto_priority_version=$1\n-  if test \"x$auto_priority_version\" = x; then\n-    auto_priority_version=qt5\n-  fi\n-    if test \"x$bitcoin_qt_want_version\" = xqt5 ||  ( test \"x$bitcoin_qt_want_version\" = xauto && test \"x$auto_priority_version\" = xqt5 ); then\n-      QT_LIB_PREFIX=Qt5\n-      bitcoin_qt_got_major_vers=5\n-    else\n-      QT_LIB_PREFIX=Qt\n-      bitcoin_qt_got_major_vers=4\n-    fi\n+    QT_LIB_PREFIX=Qt5\n     qt5_modules=\"Qt5Core Qt5Gui Qt5Network Qt5Widgets\"\n-    qt4_modules=\"QtCore QtGui QtNetwork\"\n     BITCOIN_QT_CHECK([\n-      if test \"x$bitcoin_qt_want_version\" = xqt5 || ( test \"x$bitcoin_qt_want_version\" = xauto && test \"x$auto_priority_version\" = xqt5 ); then\n-        PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" have_qt=yes],[have_qt=no])\n-      elif test \"x$bitcoin_qt_want_version\" = xqt4 || ( test \"x$bitcoin_qt_want_version\" = xauto && test \"x$auto_priority_version\" = xqt4 ); then\n-        PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes], [have_qt=no])\n-      fi\n+      PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" have_qt=yes],[have_qt=no])\n \n-      dnl qt version is set to 'auto' and the preferred version wasn't found. Now try the other.\n-      if test \"x$have_qt\" = xno && test \"x$bitcoin_qt_want_version\" = xauto; then\n-        if test \"x$auto_priority_version\" = xqt5; then\n-          PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt; bitcoin_qt_got_major_vers=4], [have_qt=no])\n-        else\n-          PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt5; bitcoin_qt_got_major_vers=5], [have_qt=no])\n-        fi\n-      fi\n       if test \"x$have_qt\" != xyes; then\n         have_qt=no\n         BITCOIN_QT_FAIL([Qt dependencies not found])\n@@ -458,7 +410,6 @@ dnl from the discovered headers.\n dnl Inputs: bitcoin_qt_want_version (from --with-gui=). The version to use.\n dnl         If \"auto\", the version will be discovered by _BITCOIN_QT_CHECK_QT5.\n dnl Outputs: All necessary QT_* variables are set.\n-dnl Outputs: bitcoin_qt_got_major_vers is set to \"4\" or \"5\".\n dnl Outputs: have_qt_test and have_qt_dbus are set (if applicable) to yes|no.\n AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG],[\n   TEMP_CPPFLAGS=\"$CPPFLAGS\"\n@@ -480,13 +431,7 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG],[\n     if test \"x$bitcoin_qt_want_version\" = xauto; then\n       _BITCOIN_QT_CHECK_QT5\n     fi\n-    if test \"x$bitcoin_cv_qt5\" = xyes || test \"x$bitcoin_qt_want_version\" = xqt5; then\n-      QT_LIB_PREFIX=Qt5\n-      bitcoin_qt_got_major_vers=5\n-    else\n-      QT_LIB_PREFIX=Qt\n-      bitcoin_qt_got_major_vers=4\n-    fi\n+    QT_LIB_PREFIX=Qt5\n   ])\n \n   BITCOIN_QT_CHECK([\n@@ -508,9 +453,7 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG],[\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Core]   ,[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}Core not found)))\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Gui]    ,[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}Gui not found)))\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Network],[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}Network not found)))\n-  if test \"x$bitcoin_qt_got_major_vers\" = x5; then\n-    BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Widgets],[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}Widgets not found)))\n-  fi\n+  BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Widgets],[main],,BITCOIN_QT_FAIL(lib${QT_LIB_PREFIX}Widgets not found)))\n   QT_LIBS=\"$LIBS\"\n   LIBS=\"$TEMP_LIBS\"\n "
      },
      {
        "sha": "e4142f576235f1c31fd4dceb5ab3a0c632f55ca0",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 86,
        "deletions": 35,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -243,6 +243,10 @@ AC_LANG_PUSH([C++])\n AX_CHECK_COMPILE_FLAG([-Werror],[CXXFLAG_WERROR=\"-Werror\"],[CXXFLAG_WERROR=\"\"])\n \n if test \"x$enable_debug\" = xyes; then\n+  # Clear default -g -O2 flags\n+  if test \"x$CXXFLAGS_overridden\" = xno; then\n+\tCXXFLAGS=\"\"\n+  fi\n   # Prefer -Og, fall back to -O0 if that is unavailable.\n   AX_CHECK_COMPILE_FLAG(\n     [-Og],\n@@ -259,6 +263,7 @@ if test \"x$enable_debug\" = xyes; then\n \n   AX_CHECK_PREPROC_FLAG([-DDEBUG],[[DEBUG_CPPFLAGS=\"$DEBUG_CPPFLAGS -DDEBUG\"]],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_PREPROC_FLAG([-DDEBUG_LOCKORDER],[[DEBUG_CPPFLAGS=\"$DEBUG_CPPFLAGS -DDEBUG_LOCKORDER\"]],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-ftrapv],[DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -ftrapv\"],,[[$CXXFLAG_WERROR]])\n fi\n \n if test x$use_sanitizers != x; then\n@@ -291,27 +296,30 @@ if test \"x$enable_werror\" = \"xyes\"; then\n fi\n \n if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n-  AX_CHECK_COMPILE_FLAG([-Wall],[CXXFLAGS=\"$CXXFLAGS -Wall\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wextra],[CXXFLAGS=\"$CXXFLAGS -Wextra\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wformat],[CXXFLAGS=\"$CXXFLAGS -Wformat\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wvla],[CXXFLAGS=\"$CXXFLAGS -Wvla\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wformat-security],[CXXFLAGS=\"$CXXFLAGS -Wformat-security\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wthread-safety-analysis],[CXXFLAGS=\"$CXXFLAGS -Wthread-safety-analysis\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wall],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wall\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wextra],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wextra\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wformat],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wformat\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wvla],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wvla\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wformat-security],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wformat-security\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wthread-safety-analysis],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wthread-safety-analysis\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wrange-loop-analysis],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wrange-loop-analysis\"],,[[$CXXFLAG_WERROR]])\n \n   ## Some compilers (gcc) ignore unknown -Wno-* options, but warn about all\n   ## unknown options if any other warning is produced. Test the -Wfoo case, and\n   ## set the -Wno-foo case if it works.\n-  AX_CHECK_COMPILE_FLAG([-Wunused-parameter],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-parameter\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wself-assign],[CXXFLAGS=\"$CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[CXXFLAGS=\"$CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wunused-parameter],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-parameter\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wself-assign],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n fi\n \n # Check for optional instruction set support. Enabling these does _not_ imply that all code will\n # be compiled with them, rather that specific objects/libs may use them after checking for runtime\n # compatibility.\n AX_CHECK_COMPILE_FLAG([-msse4.2],[[SSE42_CXXFLAGS=\"-msse4.2\"]],,[[$CXXFLAG_WERROR]])\n+AX_CHECK_COMPILE_FLAG([-msse4.1],[[SSE41_CXXFLAGS=\"-msse4.1\"]],,[[$CXXFLAG_WERROR]])\n+AX_CHECK_COMPILE_FLAG([-mavx -mavx2],[[AVX2_CXXFLAGS=\"-mavx -mavx2\"]],,[[$CXXFLAG_WERROR]])\n \n TEMP_CXXFLAGS=\"$CXXFLAGS\"\n CXXFLAGS=\"$CXXFLAGS $SSE42_CXXFLAGS\"\n@@ -335,6 +343,44 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n )\n CXXFLAGS=\"$TEMP_CXXFLAGS\"\n \n+TEMP_CXXFLAGS=\"$CXXFLAGS\"\n+CXXFLAGS=\"$CXXFLAGS $SSE41_CXXFLAGS\"\n+AC_MSG_CHECKING(for SSE4.1 intrinsics)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+    #include <stdint.h>\n+    #if defined(_MSC_VER)\n+    #include <immintrin.h>\n+    #elif defined(__GNUC__)\n+    #include <x86intrin.h>\n+    #endif\n+  ]],[[\n+    __m128i l = _mm_set1_epi32(0);\n+    return _mm_extract_epi32(l, 3);\n+  ]])],\n+ [ AC_MSG_RESULT(yes); enable_sse41=yes; AC_DEFINE(ENABLE_SSE41, 1, [Define this symbol to build code that uses SSE4.1 intrinsics]) ],\n+ [ AC_MSG_RESULT(no)]\n+)\n+CXXFLAGS=\"$TEMP_CXXFLAGS\"\n+\n+TEMP_CXXFLAGS=\"$CXXFLAGS\"\n+CXXFLAGS=\"$CXXFLAGS $AVX2_CXXFLAGS\"\n+AC_MSG_CHECKING(for AVX2 intrinsics)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+    #include <stdint.h>\n+    #if defined(_MSC_VER)\n+    #include <immintrin.h>\n+    #elif defined(__GNUC__) && defined(__AVX2__)\n+    #include <x86intrin.h>\n+    #endif\n+  ]],[[\n+    __m256i l = _mm256_set1_epi32(0);\n+    return _mm256_extract_epi32(l, 7);\n+  ]])],\n+ [ AC_MSG_RESULT(yes); enable_avx2=yes; AC_DEFINE(ENABLE_AVX2, 1, [Define this symbol to build code that uses AVX2 intrinsics]) ],\n+ [ AC_MSG_RESULT(no)]\n+)\n+CXXFLAGS=\"$TEMP_CXXFLAGS\"\n+\n CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n@@ -363,25 +409,25 @@ case $host in\n      use_pkgconfig=no\n \n      TARGET_OS=windows\n-     AC_CHECK_LIB([mingwthrd],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([kernel32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([user32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([gdi32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([comdlg32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([winspool],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([winmm],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([shell32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([comctl32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([ole32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([oleaut32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([uuid],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([rpcrt4],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([advapi32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([ws2_32],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([mswsock],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([shlwapi],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([iphlpapi],      [main],, AC_MSG_ERROR(lib missing))\n-     AC_CHECK_LIB([crypt32],      [main],, AC_MSG_ERROR(lib missing))\n+     AC_CHECK_LIB([mingwthrd],      [main],, AC_MSG_ERROR(libmingwthrd missing))\n+     AC_CHECK_LIB([kernel32],      [main],, AC_MSG_ERROR(libkernel32 missing))\n+     AC_CHECK_LIB([user32],      [main],, AC_MSG_ERROR(libuser32 missing))\n+     AC_CHECK_LIB([gdi32],      [main],, AC_MSG_ERROR(libgdi32 missing))\n+     AC_CHECK_LIB([comdlg32],      [main],, AC_MSG_ERROR(libcomdlg32 missing))\n+     AC_CHECK_LIB([winspool],      [main],, AC_MSG_ERROR(libwinspool missing))\n+     AC_CHECK_LIB([winmm],      [main],, AC_MSG_ERROR(libwinmm missing))\n+     AC_CHECK_LIB([shell32],      [main],, AC_MSG_ERROR(libshell32 missing))\n+     AC_CHECK_LIB([comctl32],      [main],, AC_MSG_ERROR(libcomctl32 missing))\n+     AC_CHECK_LIB([ole32],      [main],, AC_MSG_ERROR(libole32 missing))\n+     AC_CHECK_LIB([oleaut32],      [main],, AC_MSG_ERROR(liboleaut32 missing))\n+     AC_CHECK_LIB([uuid],      [main],, AC_MSG_ERROR(libuuid missing))\n+     AC_CHECK_LIB([rpcrt4],      [main],, AC_MSG_ERROR(librpcrt4 missing))\n+     AC_CHECK_LIB([advapi32],      [main],, AC_MSG_ERROR(libadvapi32 missing))\n+     AC_CHECK_LIB([ws2_32],      [main],, AC_MSG_ERROR(libws2_32 missing))\n+     AC_CHECK_LIB([mswsock],      [main],, AC_MSG_ERROR(libmswsock missing))\n+     AC_CHECK_LIB([shlwapi],      [main],, AC_MSG_ERROR(libshlwapi missing))\n+     AC_CHECK_LIB([iphlpapi],      [main],, AC_MSG_ERROR(libiphlpapi missing))\n+     AC_CHECK_LIB([crypt32],      [main],, AC_MSG_ERROR(libcrypt32 missing))\n \n      # -static is interpreted by libtool, where it has a different meaning.\n      # In libtool-speak, it's -all-static.\n@@ -580,7 +626,7 @@ if test x$use_glibc_compat != xno; then\n \n   #glibc absorbed clock_gettime in 2.17. librt (its previous location) is safe to link\n   #in anyway for back-compat.\n-  AC_CHECK_LIB([rt],[clock_gettime],, AC_MSG_ERROR(lib missing))\n+  AC_CHECK_LIB([rt],[clock_gettime],, AC_MSG_ERROR(librt missing))\n \n   #__fdelt_chk's params and return type have changed from long unsigned int to long int.\n   # See which one is present here.\n@@ -642,7 +688,7 @@ if test x$use_hardening != xno; then\n \n   case $host in\n     *mingw*)\n-       AC_CHECK_LIB([ssp],      [main],, AC_MSG_ERROR(lib missing))\n+       AC_CHECK_LIB([ssp],      [main],, AC_MSG_ERROR(libssp missing))\n     ;;\n   esac\n fi\n@@ -793,7 +839,7 @@ fi\n BITCOIN_QT_INIT\n \n dnl sets $bitcoin_enable_qt, $bitcoin_enable_qt_test, $bitcoin_enable_qt_dbus\n-BITCOIN_QT_CONFIGURE([$use_pkgconfig], [qt5])\n+BITCOIN_QT_CONFIGURE([$use_pkgconfig])\n \n if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n     use_boost=no\n@@ -1253,6 +1299,8 @@ AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n AM_CONDITIONAL([ENABLE_HWCRC32],[test x$enable_hwcrc32 = xyes])\n+AM_CONDITIONAL([ENABLE_SSE41],[test x$enable_sse41 = xyes])\n+AM_CONDITIONAL([ENABLE_AVX2],[test x$enable_avx2 = xyes])\n AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n@@ -1281,6 +1329,8 @@ AC_SUBST(BITCOIN_TX_NAME)\n \n AC_SUBST(RELDFLAGS)\n AC_SUBST(DEBUG_CPPFLAGS)\n+AC_SUBST(WARN_CXXFLAGS)\n+AC_SUBST(NOWARN_CXXFLAGS)\n AC_SUBST(DEBUG_CXXFLAGS)\n AC_SUBST(ERROR_CXXFLAGS)\n AC_SUBST(GPROF_CXXFLAGS)\n@@ -1293,6 +1343,8 @@ AC_SUBST(PIE_FLAGS)\n AC_SUBST(SANITIZER_CXXFLAGS)\n AC_SUBST(SANITIZER_LDFLAGS)\n AC_SUBST(SSE42_CXXFLAGS)\n+AC_SUBST(SSE41_CXXFLAGS)\n+AC_SUBST(AVX2_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n AC_SUBST(USE_QRCODE)\n@@ -1372,7 +1424,6 @@ echo \"Options used to compile and link:\"\n echo \"  with wallet   = $enable_wallet\"\n echo \"  with gui / qt = $bitcoin_enable_qt\"\n if test x$bitcoin_enable_qt != xno; then\n-    echo \"    qt version  = $bitcoin_qt_got_major_vers\"\n     echo \"    with qr     = $use_qr\"\n fi\n echo \"  with zmq      = $use_zmq\"\n@@ -1392,7 +1443,7 @@ echo \"  CC            = $CC\"\n echo \"  CFLAGS        = $CFLAGS\"\n echo \"  CPPFLAGS      = $DEBUG_CPPFLAGS $HARDENED_CPPFLAGS $CPPFLAGS\"\n echo \"  CXX           = $CXX\"\n-echo \"  CXXFLAGS      = $DEBUG_CXXFLAGS $HARDENED_CXXFLAGS $ERROR_CXXFLAGS $GPROF_CXXFLAGS $CXXFLAGS\"\n+echo \"  CXXFLAGS      = $DEBUG_CXXFLAGS $HARDENED_CXXFLAGS $WARN_CXXFLAGS $NOWARN_CXXFLAGS $ERROR_CXXFLAGS $GPROF_CXXFLAGS $CXXFLAGS\"\n echo \"  LDFLAGS       = $PTHREAD_CFLAGS $HARDENED_LDFLAGS $GPROF_LDFLAGS $LDFLAGS\"\n echo \"  ARFLAGS       = $ARFLAGS\"\n echo"
      },
      {
        "sha": "a0b6225345a42942bf2422d5ad1e94780d8043c6",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,12 +2,6 @@ Contents\n ========\n This directory contains tools for developers working on this repository.\n \n-check-doc.py\n-============\n-\n-Check if all command line args are documented. The return value indicates the\n-number of undocumented args.\n-\n clang-format-diff.py\n ===================\n \n@@ -93,23 +87,6 @@ example:\n BUILDDIR=$PWD/build contrib/devtools/gen-manpages.sh\n ```\n \n-git-subtree-check.sh\n-====================\n-\n-Run this script from the root of the repository to verify that a subtree matches the contents of\n-the commit it claims to have been updated to.\n-\n-To use, make sure that you have fetched the upstream repository branch in which the subtree is\n-maintained:\n-* for `src/secp256k1`: https://github.com/bitcoin-core/secp256k1.git (branch master)\n-* for `src/leveldb`: https://github.com/bitcoin-core/leveldb.git (branch bitcoin-fork)\n-* for `src/univalue`: https://github.com/bitcoin-core/univalue.git (branch master)\n-* for `src/crypto/ctaes`: https://github.com/bitcoin-core/ctaes.git (branch master)\n-\n-Usage: `git-subtree-check.sh DIR (COMMIT)`\n-\n-`COMMIT` may be omitted, in which case `HEAD` is used.\n-\n github-merge.py\n ===============\n "
      },
      {
        "sha": "abfa5ed5ae7b01a86f7bbe8b9229fb69f2356b9f",
        "filename": "contrib/devtools/circular-dependencies.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/circular-dependencies.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/circular-dependencies.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/circular-dependencies.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -37,7 +37,7 @@ def module_name(path):\n # TODO: implement support for multiple include directories\n for arg in sorted(files.keys()):\n     module = files[arg]\n-    with open(arg, 'r') as f:\n+    with open(arg, 'r', encoding=\"utf8\") as f:\n         for line in f:\n             match = RE.match(line)\n             if match:"
      },
      {
        "sha": "77e845a9b4976c2ae1f7438e734b9bb9bad9fa49",
        "filename": "contrib/devtools/clang-format-diff.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/clang-format-diff.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/clang-format-diff.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/clang-format-diff.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -152,7 +152,7 @@ def main():\n       sys.exit(p.returncode)\n \n     if not args.i:\n-      with open(filename) as f:\n+      with open(filename, encoding=\"utf8\") as f:\n         code = f.readlines()\n       formatted_code = io.StringIO(stdout).readlines()\n       diff = difflib.unified_diff(code, formatted_code,"
      },
      {
        "sha": "da7d74bdc45459ac44008035739fe82a8943711a",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -146,7 +146,7 @@ def file_has_without_c_style_copyright_for_holder(contents, holder_name):\n ################################################################################\n \n def read_file(filename):\n-    return open(os.path.abspath(filename), 'r').read()\n+    return open(os.path.abspath(filename), 'r', encoding=\"utf8\").read()\n \n def gather_file_info(filename):\n     info = {}\n@@ -325,13 +325,13 @@ def get_most_recent_git_change_year(filename):\n ################################################################################\n \n def read_file_lines(filename):\n-    f = open(os.path.abspath(filename), 'r')\n+    f = open(os.path.abspath(filename), 'r', encoding=\"utf8\")\n     file_lines = f.readlines()\n     f.close()\n     return file_lines\n \n def write_file_lines(filename, file_lines):\n-    f = open(os.path.abspath(filename), 'w')\n+    f = open(os.path.abspath(filename), 'w', encoding=\"utf8\")\n     f.write(''.join(file_lines))\n     f.close()\n "
      },
      {
        "sha": "b5de5a395f10dd573ece96b9cb39b56c3a53722a",
        "filename": "contrib/devtools/gen-manpages.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/gen-manpages.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/gen-manpages.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/gen-manpages.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,5 +1,6 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n+export LC_ALL=C\n TOPDIR=${TOPDIR:-$(git rev-parse --show-toplevel)}\n BUILDDIR=${BUILDDIR:-$TOPDIR}\n "
      },
      {
        "sha": "4e90f85f5033db4c6e9ec23204a66e9c62398491",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -191,7 +191,7 @@ def main():\n     merge_branch = 'pull/'+pull+'/merge'\n     local_merge_branch = 'pull/'+pull+'/local-merge'\n \n-    devnull = open(os.devnull,'w')\n+    devnull = open(os.devnull, 'w', encoding=\"utf8\")\n     try:\n         subprocess.check_call([GIT,'checkout','-q',branch])\n     except subprocess.CalledProcessError:"
      },
      {
        "sha": "f54be46b529da74c7a95894c1cb25152da084a5b",
        "filename": "contrib/devtools/lint-includes.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 32,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/devtools/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/devtools/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-includes.sh?ref=391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "patch": "@@ -1,32 +0,0 @@\n-#!/bin/bash\n-#\n-# Copyright (c) 2018 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#\n-# Check for duplicate includes.\n-\n-filter_suffix() {\n-    git ls-files | grep -E \"^src/.*\\.${1}\"'$' | grep -Ev \"/(leveldb|secp256k1|univalue)/\"\n-}\n-\n-EXIT_CODE=0\n-for HEADER_FILE in $(filter_suffix h); do\n-    DUPLICATE_INCLUDES_IN_HEADER_FILE=$(grep -E \"^#include \" < \"${HEADER_FILE}\" | sort | uniq -d)\n-    if [[ ${DUPLICATE_INCLUDES_IN_HEADER_FILE} != \"\" ]]; then\n-        echo \"Duplicate include(s) in ${HEADER_FILE}:\"\n-        echo \"${DUPLICATE_INCLUDES_IN_HEADER_FILE}\"\n-        echo\n-        EXIT_CODE=1\n-    fi\n-done\n-for CPP_FILE in $(filter_suffix cpp); do\n-    DUPLICATE_INCLUDES_IN_CPP_FILE=$(grep -E \"^#include \" < \"${CPP_FILE}\" | sort | uniq -d)\n-    if [[ ${DUPLICATE_INCLUDES_IN_CPP_FILE} != \"\" ]]; then\n-        echo \"Duplicate include(s) in ${CPP_FILE}:\"\n-        echo \"${DUPLICATE_INCLUDES_IN_CPP_FILE}\"\n-        echo\n-        EXIT_CODE=1\n-    fi\n-done\n-exit ${EXIT_CODE}"
      },
      {
        "sha": "9b6d6bf6658bd7509b7297a5f9fd0b770bd6cf39",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -9,7 +9,7 @@\n import unittest\n \n def write_testcode(filename):\n-    with open(filename, 'w') as f:\n+    with open(filename, 'w', encoding=\"utf8\") as f:\n         f.write('''\n     #include <stdio.h>\n     int main()"
      },
      {
        "sha": "f0098cfcdf9cc58b7d92358d3569c3f43c6816fa",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -30,6 +30,8 @@\n LOCALE_DIR = 'src/qt/locale'\n # Minimum number of messages for translation to be considered at all\n MIN_NUM_MESSAGES = 10\n+# Regexp to check for Bitcoin addresses\n+ADDRESS_REGEXP = re.compile('([13]|bc1)[a-zA-Z0-9]{30,}')\n \n def check_at_repository_root():\n     if not os.path.exists('.git'):\n@@ -122,6 +124,12 @@ def escape_cdata(text):\n     text = text.replace('\"', '&quot;')\n     return text\n \n+def contains_bitcoin_addr(text, errors):\n+    if text != None and ADDRESS_REGEXP.search(text) != None:\n+        errors.append('Translation \"%s\" contains a bitcoin address. This will be removed.' % (text))\n+        return True\n+    return False\n+\n def postprocess_translations(reduce_diff_hacks=False):\n     print('Checking and postprocessing...')\n \n@@ -160,7 +168,7 @@ def postprocess_translations(reduce_diff_hacks=False):\n                     if translation is None:\n                         continue\n                     errors = []\n-                    valid = check_format_specifiers(source, translation, errors, numerus)\n+                    valid = check_format_specifiers(source, translation, errors, numerus) and not contains_bitcoin_addr(translation, errors)\n \n                     for error in errors:\n                         print('%s: %s' % (filename, error))"
      },
      {
        "sha": "df1db76e924ef025d1449441cfd01fdf14cc3f85",
        "filename": "contrib/filter-lcov.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/filter-lcov.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/filter-lcov.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/filter-lcov.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -13,8 +13,8 @@\n outfile = args.outfile\n \n in_remove = False\n-with open(tracefile, 'r') as f:\n-    with open(outfile, 'w') as wf:\n+with open(tracefile, 'r', encoding=\"utf8\") as f:\n+    with open(outfile, 'w', encoding=\"utf8\") as wf:\n         for line in f:\n             for p in pattern:\n                 if line.startswith(\"SF:\") and p in line:"
      },
      {
        "sha": "05e7d6f4c667c84b459fc7dbe3c55c8b4336c11e",
        "filename": "contrib/gitian-build.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-build.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,7 +1,9 @@\n+#!/usr/bin/env bash\n # Copyright (c) 2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n # What to do\n sign=false\n verify=false"
      },
      {
        "sha": "f78eea73a34fcc1a0e62877943b6d2656116c68c",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -56,7 +56,7 @@ script: |\n \n   function create_global_faketime_wrappers {\n   for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/bin/bash' > ${WRAP_DIR}/${prog}\n+    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n     echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n     echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${prog}\n     echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n@@ -68,7 +68,7 @@ script: |\n   function create_per-host_faketime_wrappers {\n   for i in $HOSTS; do\n     for prog in ${FAKETIME_HOST_PROGS}; do\n-        echo '#!/bin/bash' > ${WRAP_DIR}/${i}-${prog}\n+        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n         echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n         echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${i}-${prog}\n         echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n@@ -98,7 +98,7 @@ script: |\n   for prog in gcc g++; do\n   rm -f ${WRAP_DIR}/${prog}\n   cat << EOF > ${WRAP_DIR}/${prog}\n-  #!/bin/bash\n+  #!/usr/bin/env bash\n   REAL=\"`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1`\"\n   for var in \"\\$@\"\n   do"
      },
      {
        "sha": "b5c863bb143dba6e18d13458259a3b94c6d1c982",
        "filename": "contrib/gitian-descriptors/gitian-osx-signer.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-signer.yml?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -19,7 +19,7 @@ script: |\n \n   # Create global faketime wrappers\n   for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/bin/bash' > ${WRAP_DIR}/${prog}\n+    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n     echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n     echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${prog}\n     echo \"export FAKETIME=\\\"${REFERENCE_DATETIME}\\\"\" >> ${WRAP_DIR}/${prog}"
      },
      {
        "sha": "2cc62d4ce71b6e40777e6419a83fe0caf9028c58",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -55,7 +55,7 @@ script: |\n \n   function create_global_faketime_wrappers {\n   for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/bin/bash' > ${WRAP_DIR}/${prog}\n+    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n     echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n     echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${prog}\n     echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n@@ -67,7 +67,7 @@ script: |\n   function create_per-host_faketime_wrappers {\n   for i in $HOSTS; do\n     for prog in ${FAKETIME_HOST_PROGS}; do\n-        echo '#!/bin/bash' > ${WRAP_DIR}/${i}-${prog}\n+        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n         echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n         echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${i}-${prog}\n         echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}"
      },
      {
        "sha": "f6eb1815f62b727c90ff33c36684a951124e3cb7",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -48,7 +48,7 @@ script: |\n \n   function create_global_faketime_wrappers {\n   for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/bin/bash' > ${WRAP_DIR}/${prog}\n+    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n     echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n     echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${prog}\n     echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n@@ -60,7 +60,7 @@ script: |\n   function create_per-host_faketime_wrappers {\n   for i in $HOSTS; do\n     for prog in ${FAKETIME_HOST_PROGS}; do\n-        echo '#!/bin/bash' > ${WRAP_DIR}/${i}-${prog}\n+        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n         echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n         echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${i}-${prog}\n         echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n@@ -76,14 +76,14 @@ script: |\n   for i in $HOSTS; do\n     mkdir -p ${WRAP_DIR}/${i}\n     for prog in collect2; do\n-        echo '#!/bin/bash' > ${WRAP_DIR}/${i}/${prog}\n+        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}/${prog}\n         REAL=$(${i}-gcc -print-prog-name=${prog})\n         echo \"export MALLOC_PERTURB_=255\" >> ${WRAP_DIR}/${i}/${prog}\n         echo \"${REAL} \\$@\" >> $WRAP_DIR/${i}/${prog}\n         chmod +x ${WRAP_DIR}/${i}/${prog}\n     done\n     for prog in gcc g++; do\n-        echo '#!/bin/bash' > ${WRAP_DIR}/${i}-${prog}\n+        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n         echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n         echo 'export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/faketime/libfaketime.so.1' >> ${WRAP_DIR}/${i}-${prog}\n         echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}"
      },
      {
        "sha": "8d3e57c5268cfc6af2f5ec11b7342cffaf61abec",
        "filename": "contrib/init/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/init/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/init/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -5,7 +5,7 @@ Upstart: bitcoind.conf\n OpenRC:  bitcoind.openrc\n          bitcoind.openrcconf\n CentOS:  bitcoind.init\n-OS X:    org.bitcoin.bitcoind.plist\n+macOS:    org.bitcoin.bitcoind.plist\n ```\n have been made available to assist packagers in creating node packages here.\n "
      },
      {
        "sha": "0c95baf3a1b4494aad65d05633c281d29d595d5c",
        "filename": "contrib/init/bitcoind.init",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/init/bitcoind.init",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/init/bitcoind.init",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.init?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n #  bitcoind The bitcoin core server.\n #"
      },
      {
        "sha": "4f74e67f2faafdc0b35210ceebb9838c8520a314",
        "filename": "contrib/install_db4.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/install_db4.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/install_db4.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/install_db4.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,6 +2,7 @@\n \n # Install libdb4.8 (Berkeley DB).\n \n+export LC_ALL=C\n set -e\n \n if [ -z \"${1}\" ]; then"
      },
      {
        "sha": "b501388fd2b4123d5c0a5d22e020994cede66117",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -75,7 +75,7 @@ def get_blk_dt(blk_hdr):\n # When getting the list of block hashes, undo any byte reversals.\n def get_block_hashes(settings):\n     blkindex = []\n-    f = open(settings['hashlist'], \"r\")\n+    f = open(settings['hashlist'], \"r\", encoding=\"utf8\")\n     for line in f:\n         line = line.rstrip()\n         if settings['rev_hash_bytes'] == 'true':\n@@ -261,7 +261,7 @@ def run(self):\n         print(\"Usage: linearize-data.py CONFIG-FILE\")\n         sys.exit(1)\n \n-    f = open(sys.argv[1])\n+    f = open(sys.argv[1], encoding=\"utf8\")\n     for line in f:\n         # skip comment lines\n         m = re.search('^\\s*#', line)"
      },
      {
        "sha": "bfd21719475a3df63c82014e86ba229976f75fdb",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -96,7 +96,7 @@ def get_block_hashes(settings, max_blocks_per_call=10000):\n \n def get_rpc_cookie():\n     # Open the cookie file\n-    with open(os.path.join(os.path.expanduser(settings['datadir']), '.cookie'), 'r') as f:\n+    with open(os.path.join(os.path.expanduser(settings['datadir']), '.cookie'), 'r', encoding=\"ascii\") as f:\n         combined = f.readline()\n         combined_split = combined.split(\":\")\n         settings['rpcuser'] = combined_split[0]\n@@ -107,7 +107,7 @@ def get_rpc_cookie():\n         print(\"Usage: linearize-hashes.py CONFIG-FILE\")\n         sys.exit(1)\n \n-    f = open(sys.argv[1])\n+    f = open(sys.argv[1], encoding=\"utf8\")\n     for line in f:\n         # skip comment lines\n         m = re.search('^\\s*#', line)"
      },
      {
        "sha": "f8503e4de8c52dcef54d46c7861143fd53a7ee1a",
        "filename": "contrib/macdeploy/detached-sig-apply.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/detached-sig-apply.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/detached-sig-apply.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/detached-sig-apply.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n set -e\n \n UNSIGNED=\"$1\""
      },
      {
        "sha": "5281ebcc47dc62c0165453c3fbecde5b1c58900b",
        "filename": "contrib/macdeploy/detached-sig-create.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/detached-sig-create.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/detached-sig-create.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/detached-sig-create.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n set -e\n \n ROOTDIR=dist"
      },
      {
        "sha": "4c175156f4e4bc2f96fc220d4d13bf39f9fb6419",
        "filename": "contrib/macdeploy/extract-osx-sdk.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/extract-osx-sdk.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/macdeploy/extract-osx-sdk.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/extract-osx-sdk.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,8 +1,9 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright (c) 2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n set -e\n \n INPUTFILE=\"Xcode_7.3.1.dmg\""
      },
      {
        "sha": "738ea70dbe1e7c8ccfa72d5988260d72c38438ea",
        "filename": "contrib/qos/tc.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/qos/tc.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/qos/tc.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/qos/tc.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,6 +2,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n #network interface on which to limit traffic\n IF=\"eth0\"\n #limit of the network interface in question"
      },
      {
        "sha": "fe7cd1d5974dc86db7ca437659268f82f72f40cf",
        "filename": "contrib/seeds/generate-seeds.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/seeds/generate-seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/seeds/generate-seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/generate-seeds.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -127,10 +127,10 @@ def main():\n     g.write(' * Each line contains a 16-byte IPv6 address and a port.\\n')\n     g.write(' * IPv4 as well as onion addresses are wrapped inside an IPv6 address accordingly.\\n')\n     g.write(' */\\n')\n-    with open(os.path.join(indir,'nodes_main.txt'),'r') as f:\n+    with open(os.path.join(indir,'nodes_main.txt'), 'r', encoding=\"utf8\") as f:\n         process_nodes(g, f, 'pnSeed6_main', 8333)\n     g.write('\\n')\n-    with open(os.path.join(indir,'nodes_test.txt'),'r') as f:\n+    with open(os.path.join(indir,'nodes_test.txt'), 'r', encoding=\"utf8\") as f:\n         process_nodes(g, f, 'pnSeed6_test', 18333)\n     g.write('#endif // BITCOIN_CHAINPARAMSSEEDS_H\\n')\n "
      },
      {
        "sha": "aa805ad1b96b962c4eb571732cba4edfb08728db",
        "filename": "contrib/verify-commits/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -7,18 +7,18 @@ are PGP signed (nearly always merge commits), as well as a script to verify\n commits against a trusted keys list.\n \n \n-Using verify-commits.sh safely\n+Using verify-commits.py safely\n ------------------------------\n \n Remember that you can't use an untrusted script to verify itself. This means\n-that checking out code, then running `verify-commits.sh` against `HEAD` is\n-_not_ safe, because the version of `verify-commits.sh` that you just ran could\n+that checking out code, then running `verify-commits.py` against `HEAD` is\n+_not_ safe, because the version of `verify-commits.py` that you just ran could\n be backdoored. Instead, you need to use a trusted version of verify-commits\n prior to checkout to make sure you're checking out only code signed by trusted\n keys:\n \n     git fetch origin && \\\n-      ./contrib/verify-commits/verify-commits.sh origin/master && \\\n+      ./contrib/verify-commits/verify-commits.py origin/master && \\\n       git checkout origin/master\n \n Note that the above isn't a good UI/UX yet, and needs significant improvements\n@@ -42,6 +42,6 @@ said key. In order to avoid bumping the root-of-trust `trusted-git-root`\n file, individual commits which were signed by such a key can be added to the\n `allow-revsig-commits` file. That way, the PGP signatures are still verified\n but no new commits can be signed by any expired/revoked key. To easily build a\n-list of commits which need to be added, verify-commits.sh can be edited to test\n+list of commits which need to be added, verify-commits.py can be edited to test\n each commit with BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG set to both 1 and 0, and\n those which need it set to 1 printed."
      },
      {
        "sha": "c572806f2612e8c6cec07251e232e4d342ab3186",
        "filename": "contrib/verify-commits/allow-incorrect-sha512-commits",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/allow-incorrect-sha512-commits",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/allow-incorrect-sha512-commits",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/allow-incorrect-sha512-commits?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,2 @@\n+f8feaa4636260b599294c7285bcf1c8b7737f74e\n+8040ae6fc576e9504186f2ae3ff2c8125de1095c"
      },
      {
        "sha": "7aab274b9a848fce47a53acf71b54dfb1bf3db0e",
        "filename": "contrib/verify-commits/allow-unclean-merge-commits",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/allow-unclean-merge-commits",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/allow-unclean-merge-commits",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/allow-unclean-merge-commits?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,4 @@\n+6052d509105790a26b3ad5df43dd61e7f1b24a12\n+3798e5de334c3deb5f71302b782f6b8fbd5087f1\n+326ffed09bfcc209a2efd6a2ebc69edf6bd200b5\n+97d83739db0631be5d4ba86af3616014652c00ec"
      },
      {
        "sha": "7a10ba7d7d530b82490f0a04bcf03d943acdab3a",
        "filename": "contrib/verify-commits/gpg.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/gpg.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/gpg.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/gpg.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n INPUT=$(cat /dev/stdin)\n VALID=false\n REVSIG=false\n@@ -57,7 +58,7 @@ if ! $VALID; then\n \texit 1\n fi\n if $VALID && $REVSIG; then\n-\tprintf '%s\\n' \"$INPUT\" | gpg --trust-model always \"$@\" 2>/dev/null | grep \"\\[GNUPG:\\] \\(NEWSIG\\|SIG_ID\\|VALIDSIG\\)\"\n+\tprintf '%s\\n' \"$INPUT\" | gpg --trust-model always \"$@\" 2>/dev/null | grep \"^\\[GNUPG:\\] \\(NEWSIG\\|SIG_ID\\|VALIDSIG\\)\"\n \techo \"$GOODREVSIG\"\n else\n \tprintf '%s\\n' \"$INPUT\" | gpg --trust-model always \"$@\" 2>/dev/null"
      },
      {
        "sha": "4db4a908531ce39d27a14b884513fc65717f533a",
        "filename": "contrib/verify-commits/pre-push-hook.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/pre-push-hook.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/pre-push-hook.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/pre-push-hook.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,8 +1,9 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n if ! [[ \"$2\" =~ ^(git@)?(www.)?github.com(:|/)bitcoin/bitcoin(.git)?$ ]]; then\n     exit 0\n fi\n@@ -12,9 +13,9 @@ while read LINE; do\n     if [ \"$4\" != \"refs/heads/master\" ]; then\n         continue\n     fi\n-    if ! ./contrib/verify-commits/verify-commits.sh $3 > /dev/null 2>&1; then\n+    if ! ./contrib/verify-commits/verify-commits.py $3 > /dev/null 2>&1; then\n         echo \"ERROR: A commit is not signed, can't push\"\n-        ./contrib/verify-commits/verify-commits.sh\n+        ./contrib/verify-commits/verify-commits.py\n         exit 1\n     fi\n done < /dev/stdin"
      },
      {
        "sha": "a9e4977715208f398183b28e80c9db36571daf91",
        "filename": "contrib/verify-commits/verify-commits.py",
        "status": "added",
        "additions": 155,
        "deletions": 0,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/verify-commits.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verify-commits/verify-commits.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/verify-commits.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,155 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Verify commits against a trusted keys list.\"\"\"\n+import argparse\n+import hashlib\n+import os\n+import subprocess\n+import sys\n+import time\n+\n+GIT = os.getenv('GIT', 'git')\n+\n+def tree_sha512sum(commit='HEAD'):\n+    \"\"\"Calculate the Tree-sha512 for the commit.\n+\n+    This is copied from github-merge.py.\"\"\"\n+\n+    # request metadata for entire tree, recursively\n+    files = []\n+    blob_by_name = {}\n+    for line in subprocess.check_output([GIT, 'ls-tree', '--full-tree', '-r', commit]).splitlines():\n+        name_sep = line.index(b'\\t')\n+        metadata = line[:name_sep].split()  # perms, 'blob', blobid\n+        assert metadata[1] == b'blob'\n+        name = line[name_sep + 1:]\n+        files.append(name)\n+        blob_by_name[name] = metadata[2]\n+\n+    files.sort()\n+    # open connection to git-cat-file in batch mode to request data for all blobs\n+    # this is much faster than launching it per file\n+    p = subprocess.Popen([GIT, 'cat-file', '--batch'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n+    overall = hashlib.sha512()\n+    for f in files:\n+        blob = blob_by_name[f]\n+        # request blob\n+        p.stdin.write(blob + b'\\n')\n+        p.stdin.flush()\n+        # read header: blob, \"blob\", size\n+        reply = p.stdout.readline().split()\n+        assert reply[0] == blob and reply[1] == b'blob'\n+        size = int(reply[2])\n+        # hash the blob data\n+        intern = hashlib.sha512()\n+        ptr = 0\n+        while ptr < size:\n+            bs = min(65536, size - ptr)\n+            piece = p.stdout.read(bs)\n+            if len(piece) == bs:\n+                intern.update(piece)\n+            else:\n+                raise IOError('Premature EOF reading git cat-file output')\n+            ptr += bs\n+        dig = intern.hexdigest()\n+        assert p.stdout.read(1) == b'\\n'  # ignore LF that follows blob data\n+        # update overall hash with file hash\n+        overall.update(dig.encode(\"utf-8\"))\n+        overall.update(\"  \".encode(\"utf-8\"))\n+        overall.update(f)\n+        overall.update(\"\\n\".encode(\"utf-8\"))\n+    p.stdin.close()\n+    if p.wait():\n+        raise IOError('Non-zero return value executing git cat-file')\n+    return overall.hexdigest()\n+\n+def main():\n+    # Parse arguments\n+    parser = argparse.ArgumentParser(usage='%(prog)s [options] [commit id]')\n+    parser.add_argument('--disable-tree-check', action='store_false', dest='verify_tree', help='disable SHA-512 tree check')\n+    parser.add_argument('--clean-merge', type=float, dest='clean_merge', default=float('inf'), help='Only check clean merge after <NUMBER> days ago (default: %(default)s)', metavar='NUMBER')\n+    parser.add_argument('commit', nargs='?', default='HEAD', help='Check clean merge up to commit <commit>')\n+    args = parser.parse_args()\n+\n+    # get directory of this program and read data files\n+    dirname = os.path.dirname(os.path.abspath(__file__))\n+    print(\"Using verify-commits data from \" + dirname)\n+    verified_root = open(dirname + \"/trusted-git-root\", \"r\", encoding=\"utf8\").read().splitlines()[0]\n+    verified_sha512_root = open(dirname + \"/trusted-sha512-root-commit\", \"r\", encoding=\"utf8\").read().splitlines()[0]\n+    revsig_allowed = open(dirname + \"/allow-revsig-commits\", \"r\", encoding=\"utf-8\").read().splitlines()\n+    unclean_merge_allowed = open(dirname + \"/allow-unclean-merge-commits\", \"r\", encoding=\"utf-8\").read().splitlines()\n+    incorrect_sha512_allowed = open(dirname + \"/allow-incorrect-sha512-commits\", \"r\", encoding=\"utf-8\").read().splitlines()\n+\n+    # Set commit and branch and set variables\n+    current_commit = args.commit\n+    if ' ' in current_commit:\n+        print(\"Commit must not contain spaces\", file=sys.stderr)\n+        sys.exit(1)\n+    verify_tree = args.verify_tree\n+    no_sha1 = True\n+    prev_commit = \"\"\n+    initial_commit = current_commit\n+    branch = subprocess.check_output([GIT, 'show', '-s', '--format=%H', initial_commit], universal_newlines=True).splitlines()[0]\n+\n+    # Iterate through commits\n+    while True:\n+        if current_commit == verified_root:\n+            print('There is a valid path from \"{}\" to {} where all commits are signed!'.format(initial_commit, verified_root))\n+            sys.exit(0)\n+        if current_commit == verified_sha512_root:\n+            if verify_tree:\n+                print(\"All Tree-SHA512s matched up to {}\".format(verified_sha512_root), file=sys.stderr)\n+            verify_tree = False\n+            no_sha1 = False\n+\n+        os.environ['BITCOIN_VERIFY_COMMITS_ALLOW_SHA1'] = \"0\" if no_sha1 else \"1\"\n+        os.environ['BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG'] = \"1\" if current_commit in revsig_allowed else \"0\"\n+\n+        # Check that the commit (and parents) was signed with a trusted key\n+        if subprocess.call([GIT, '-c', 'gpg.program={}/gpg.sh'.format(dirname), 'verify-commit', current_commit], stdout=subprocess.DEVNULL):\n+            if prev_commit != \"\":\n+                print(\"No parent of {} was signed with a trusted key!\".format(prev_commit), file=sys.stderr)\n+                print(\"Parents are:\", file=sys.stderr)\n+                parents = subprocess.check_output([GIT, 'show', '-s', '--format=format:%P', prev_commit], universal_newlines=True).splitlines()[0].split(' ')\n+                for parent in parents:\n+                    subprocess.call([GIT, 'show', '-s', parent], stdout=sys.stderr)\n+            else:\n+                print(\"{} was not signed with a trusted key!\".format(current_commit), file=sys.stderr)\n+            sys.exit(1)\n+\n+        # Check the Tree-SHA512\n+        if (verify_tree or prev_commit == \"\") and current_commit not in incorrect_sha512_allowed:\n+            tree_hash = tree_sha512sum(current_commit)\n+            if (\"Tree-SHA512: {}\".format(tree_hash)) not in subprocess.check_output([GIT, 'show', '-s', '--format=format:%B', current_commit], universal_newlines=True).splitlines():\n+                print(\"Tree-SHA512 did not match for commit \" + current_commit, file=sys.stderr)\n+                sys.exit(1)\n+\n+        # Merge commits should only have two parents\n+        parents = subprocess.check_output([GIT, 'show', '-s', '--format=format:%P', current_commit], universal_newlines=True).splitlines()[0].split(' ')\n+        if len(parents) > 2:\n+            print(\"Commit {} is an octopus merge\".format(current_commit), file=sys.stderr)\n+            sys.exit(1)\n+\n+        # Check that the merge commit is clean\n+        commit_time = int(subprocess.check_output([GIT, 'show', '-s', '--format=format:%ct', current_commit], universal_newlines=True).splitlines()[0])\n+        check_merge = commit_time > time.time() - args.clean_merge * 24 * 60 * 60  # Only check commits in clean_merge days\n+        allow_unclean = current_commit in unclean_merge_allowed\n+        if len(parents) == 2 and check_merge and not allow_unclean:\n+            current_tree = subprocess.check_output([GIT, 'show', '--format=%T', current_commit], universal_newlines=True).splitlines()[0]\n+            subprocess.call([GIT, 'checkout', '--force', '--quiet', parents[0]])\n+            subprocess.call([GIT, 'merge', '--no-ff', '--quiet', parents[1]], stdout=subprocess.DEVNULL)\n+            recreated_tree = subprocess.check_output([GIT, 'show', '--format=format:%T', 'HEAD'], universal_newlines=True).splitlines()[0]\n+            if current_tree != recreated_tree:\n+                print(\"Merge commit {} is not clean\".format(current_commit), file=sys.stderr)\n+                subprocess.call([GIT, 'diff', current_commit])\n+                subprocess.call([GIT, 'checkout', '--force', '--quiet', branch])\n+                sys.exit(1)\n+            subprocess.call([GIT, 'checkout', '--force', '--quiet', branch])\n+\n+        prev_commit = current_commit\n+        current_commit = parents[0]\n+\n+if __name__ == '__main__':\n+    main()"
      },
      {
        "sha": "6415eea4d53fe805367f1cf7ed06d5e7339f55db",
        "filename": "contrib/verify-commits/verify-commits.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 153,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/verify-commits/verify-commits.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/391a7b7dbf119f3fa16c80834a8eff4dd1727d6b/contrib/verify-commits/verify-commits.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/verify-commits.sh?ref=391a7b7dbf119f3fa16c80834a8eff4dd1727d6b",
        "patch": "@@ -1,153 +0,0 @@\n-#!/bin/sh\n-# Copyright (c) 2014-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-DIR=$(dirname \"$0\")\n-[ \"/${DIR#/}\" != \"$DIR\" ] && DIR=$(dirname \"$(pwd)/$0\")\n-\n-echo \"Using verify-commits data from ${DIR}\"\n-\n-VERIFIED_ROOT=$(cat \"${DIR}/trusted-git-root\")\n-VERIFIED_SHA512_ROOT=$(cat \"${DIR}/trusted-sha512-root-commit\")\n-REVSIG_ALLOWED=$(cat \"${DIR}/allow-revsig-commits\")\n-\n-HAVE_GNU_SHA512=1\n-[ ! -x \"$(which sha512sum)\" ] && HAVE_GNU_SHA512=0\n-\n-if [ x\"$1\" = \"x\" ]; then\n-\tCURRENT_COMMIT=\"HEAD\"\n-else\n-\tCURRENT_COMMIT=\"$1\"\n-fi\n-\n-if [ \"${CURRENT_COMMIT#* }\" != \"$CURRENT_COMMIT\" ]; then\n-\techo \"Commit must not contain spaces?\" > /dev/stderr\n-\texit 1\n-fi\n-\n-VERIFY_TREE=0\n-if [ x\"$2\" = \"x--tree-checks\" ]; then\n-\tVERIFY_TREE=1\n-fi\n-\n-NO_SHA1=1\n-PREV_COMMIT=\"\"\n-INITIAL_COMMIT=\"${CURRENT_COMMIT}\"\n-\n-BRANCH=\"$(git rev-parse --abbrev-ref HEAD)\"\n-\n-while true; do\n-\tif [ \"$CURRENT_COMMIT\" = $VERIFIED_ROOT ]; then\n-\t\techo \"There is a valid path from \\\"$INITIAL_COMMIT\\\" to $VERIFIED_ROOT where all commits are signed!\"\n-\t\texit 0\n-\tfi\n-\n-\tif [ \"$CURRENT_COMMIT\" = $VERIFIED_SHA512_ROOT ]; then\n-\t\tif [ \"$VERIFY_TREE\" = \"1\" ]; then\n-\t\t\techo \"All Tree-SHA512s matched up to $VERIFIED_SHA512_ROOT\" > /dev/stderr\n-\t\tfi\n-\t\tVERIFY_TREE=0\n-\t\tNO_SHA1=0\n-\tfi\n-\n-\tif [ \"$NO_SHA1\" = \"1\" ]; then\n-\t\texport BITCOIN_VERIFY_COMMITS_ALLOW_SHA1=0\n-\telse\n-\t\texport BITCOIN_VERIFY_COMMITS_ALLOW_SHA1=1\n-\tfi\n-\n-\tif [ \"${REVSIG_ALLOWED#*$CURRENT_COMMIT}\" != \"$REVSIG_ALLOWED\" ]; then\n-\t\texport BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG=1\n-\telse\n-\t\texport BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG=0\n-\tfi\n-\n-\tif ! git -c \"gpg.program=${DIR}/gpg.sh\" verify-commit \"$CURRENT_COMMIT\" > /dev/null; then\n-\t\tif [ \"$PREV_COMMIT\" != \"\" ]; then\n-\t\t\techo \"No parent of $PREV_COMMIT was signed with a trusted key!\" > /dev/stderr\n-\t\t\techo \"Parents are:\" > /dev/stderr\n-\t\t\tPARENTS=$(git show -s --format=format:%P $PREV_COMMIT)\n-\t\t\tfor PARENT in $PARENTS; do\n-\t\t\t\tgit show -s $PARENT > /dev/stderr\n-\t\t\tdone\n-\t\telse\n-\t\t\techo \"$CURRENT_COMMIT was not signed with a trusted key!\" > /dev/stderr\n-\t\tfi\n-\t\texit 1\n-\tfi\n-\n-\t# We always verify the top of the tree\n-\tif [ \"$VERIFY_TREE\" = 1 -o \"$PREV_COMMIT\" = \"\" ]; then\n-\t\tIFS_CACHE=\"$IFS\"\n-\t\tIFS='\n-'\n-\t\tfor LINE in $(git ls-tree --full-tree -r \"$CURRENT_COMMIT\"); do\n-\t\t\tcase \"$LINE\" in\n-\t\t\t\t\"12\"*)\n-\t\t\t\t\techo \"Repo contains symlinks\" > /dev/stderr\n-\t\t\t\t\tIFS=\"$IFS_CACHE\"\n-\t\t\t\t\texit 1\n-\t\t\t\t\t;;\n-\t\t\tesac\n-\t\tdone\n-\t\tIFS=\"$IFS_CACHE\"\n-\n-\t\tFILE_HASHES=\"\"\n-\t\tfor FILE in $(git ls-tree --full-tree -r --name-only \"$CURRENT_COMMIT\" | LC_ALL=C sort); do\n-\t\t\tif [ \"$HAVE_GNU_SHA512\" = 1 ]; then\n-\t\t\t\tHASH=$(git cat-file blob \"$CURRENT_COMMIT\":\"$FILE\" | sha512sum | { read FIRST _; echo $FIRST; } )\n-\t\t\telse\n-\t\t\t\tHASH=$(git cat-file blob \"$CURRENT_COMMIT\":\"$FILE\" | shasum -a 512 | { read FIRST _; echo $FIRST; } )\n-\t\t\tfi\n-\t\t\t[ \"$FILE_HASHES\" != \"\" ] && FILE_HASHES=\"$FILE_HASHES\"'\n-'\n-\t\t\tFILE_HASHES=\"$FILE_HASHES$HASH  $FILE\"\n-\t\tdone\n-\n-\t\tif [ \"$HAVE_GNU_SHA512\" = 1 ]; then\n-\t\t\tTREE_HASH=\"$(echo \"$FILE_HASHES\" | sha512sum)\"\n-\t\telse\n-\t\t\tTREE_HASH=\"$(echo \"$FILE_HASHES\" | shasum -a 512)\"\n-\t\tfi\n-\t\tHASH_MATCHES=0\n-\t\tMSG=\"$(git show -s --format=format:%B \"$CURRENT_COMMIT\" | tail -n1)\"\n-\n-\t\tcase \"$MSG  -\" in\n-\t\t\t\"Tree-SHA512: $TREE_HASH\")\n-\t\t\t\tHASH_MATCHES=1;;\n-\t\tesac\n-\n-\t\tif [ \"$HASH_MATCHES\" = \"0\" ]; then\n-\t\t\techo \"Tree-SHA512 did not match for commit $CURRENT_COMMIT\" > /dev/stderr\n-\t\t\texit 1\n-\t\tfi\n-\tfi\n-\n-\tPARENTS=$(git show -s --format=format:%P \"$CURRENT_COMMIT\")\n-\tPARENT1=${PARENTS%% *}\n-\tPARENT2=\"\"\n-\tif [ \"x$PARENT1\" != \"x$PARENTS\" ]; then\n-\t\tPARENTX=${PARENTS#* }\n-\t\tPARENT2=${PARENTX%% *}\n-\t\tif [ \"x$PARENT2\" != \"x$PARENTX\" ]; then\n-\t\t\techo \"Commit $CURRENT_COMMIT is an octopus merge\" > /dev/stderr\n-\t\t\texit 1\n-\t\tfi\n-\tfi\n-\tif [ \"x$PARENT2\" != \"x\" ]; then\n-\t\tCURRENT_TREE=\"$(git show --format=\"%T\" \"$CURRENT_COMMIT\")\"\n-\t\tgit checkout --force --quiet \"$PARENT1\"\n-\t\tgit merge --no-ff --quiet \"$PARENT2\" >/dev/null\n-\t\tRECREATED_TREE=\"$(git show --format=\"%T\" HEAD)\"\n-\t\tif [ \"$CURRENT_TREE\" != \"$RECREATED_TREE\" ]; then\n-\t\t\techo \"Merge commit $CURRENT_COMMIT is not clean\" > /dev/stderr\n-\t\t\tgit diff \"$CURRENT_COMMIT\"\n-\t\t\tgit checkout --force --quiet \"$BRANCH\"\n-\t\t\texit 1\n-\t\tfi\n-\t\tgit checkout --force --quiet \"$BRANCH\"\n-\tfi\n-\tPREV_COMMIT=\"$CURRENT_COMMIT\"\n-\tCURRENT_COMMIT=\"$PARENT1\"\n-done"
      },
      {
        "sha": "fc7492ad3b79657180533ce12ebbeb27561befb0",
        "filename": "contrib/verifybinaries/verify.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verifybinaries/verify.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/verifybinaries/verify.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/verify.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright (c) 2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -11,6 +11,7 @@\n ###   The script returns 0 if everything passes the checks. It returns 1 if either the\n ###   signature check or the hash check doesn't pass. If an error occurs the return value is 2\n \n+export LC_ALL=C\n function clean_up {\n    for file in $*\n    do"
      },
      {
        "sha": "15f8108cf011f6f5dc59d7c6f4e4acf87d89b3ac",
        "filename": "contrib/windeploy/detached-sig-create.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/windeploy/detached-sig-create.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/contrib/windeploy/detached-sig-create.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/windeploy/detached-sig-create.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n if [ -z \"$OSSLSIGNCODE\" ]; then\n   OSSLSIGNCODE=osslsigncode\n fi"
      },
      {
        "sha": "482b94a64f752a90a180a1f6d1f5846111bfc86c",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -22,7 +22,7 @@ Common `host-platform-triplets` for cross compilation are:\n \n - `i686-w64-mingw32` for Win32\n - `x86_64-w64-mingw32` for Win64\n-- `x86_64-apple-darwin11` for MacOSX\n+- `x86_64-apple-darwin11` for macOS\n - `arm-linux-gnueabihf` for Linux ARM 32 bit\n - `aarch64-linux-gnu` for Linux ARM 64 bit\n \n@@ -49,7 +49,7 @@ The following can be set when running make: make FOO=bar\n \n     SOURCES_PATH: downloaded sources will be placed here\n     BASE_CACHE: built packages will be placed here\n-    SDK_PATH: Path where sdk's can be found (used by OSX)\n+    SDK_PATH: Path where sdk's can be found (used by macOS)\n     FALLBACK_DOWNLOAD_PATH: If a source file can't be fetched, try here before giving up\n     NO_QT: Don't download/build/cache qt and its dependencies\n     NO_WALLET: Don't download/build/cache libs needed to enable the wallet\n@@ -64,7 +64,7 @@ options will be passed to bitcoin's configure. In this case, `--disable-wallet`.\n Additional targets:\n \n     download: run 'make download' to fetch all sources without building them\n-    download-osx: run 'make download-osx' to fetch all sources needed for osx builds\n+    download-osx: run 'make download-osx' to fetch all sources needed for macOS builds\n     download-win: run 'make download-win' to fetch all sources needed for win builds\n     download-linux: run 'make download-linux' to fetch all sources needed for linux builds\n "
      },
      {
        "sha": "9fc7093be4f35f7048580e7bc8ba19cc294bff95",
        "filename": "depends/description.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/depends/description.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/depends/description.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/description.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -7,7 +7,7 @@ In theory, binaries for any target OS/architecture can be created, from a\n builder running any OS/architecture. In practice, build-side tools must be\n specified when the defaults don't fit, and packages must be amended to work\n on new hosts. For now, a build architecture of x86_64 is assumed, either on\n-Linux or OSX.\n+Linux or macOS.\n \n ### No reliance on timestamps\n "
      },
      {
        "sha": "34b0fdc636c1aa48c9f047cfae5aa9d97b79dc0a",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,6 +1,6 @@\n PACKAGE=qt\n $(package)_version=5.7.1\n-$(package)_download_path=http://download.qt.io/official_releases/qt/5.7/$($(package)_version)/submodules\n+$(package)_download_path=https://download.qt.io/archive/qt/5.7/$($(package)_version)/submodules\n $(package)_suffix=opensource-src-$($(package)_version).tar.gz\n $(package)_file_name=qtbase-$($(package)_suffix)\n $(package)_sha256_hash=95f83e532d23b3ddbde7973f380ecae1bac13230340557276f75f2e37984e410"
      },
      {
        "sha": "45762b2374d076de2b4618561a0ce9df5775b8f4",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -22,7 +22,7 @@ Unpack the files into a directory and run:\n \n Unpack the files into a directory, and then run bitcoin-qt.exe.\n \n-### OS X\n+### macOS\n \n Drag Bitcoin-Core to your applications folder, and then run Bitcoin-Core.\n \n@@ -38,7 +38,7 @@ Building\n The following are developer notes on how to build Bitcoin on your native platform. They are not complete guides, but include notes on the necessary libraries, compile flags, etc.\n \n - [Dependencies](dependencies.md)\n-- [OS X Build Notes](build-osx.md)\n+- [macOS Build Notes](build-osx.md)\n - [Unix Build Notes](build-unix.md)\n - [Windows Build Notes](build-windows.md)\n - [OpenBSD Build Notes](build-openbsd.md)"
      },
      {
        "sha": "739e22d6341cd30bb9e28b396cf4438bc5feb5b9",
        "filename": "doc/README_osx.md",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/README_osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/README_osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_osx.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,12 +1,12 @@\n-Deterministic OS X DMG Notes.\n+Deterministic macOS DMG Notes.\n \n-Working OS X DMGs are created in Linux by combining a recent clang,\n+Working macOS DMGs are created in Linux by combining a recent clang,\n the Apple binutils (ld, ar, etc) and DMG authoring tools.\n \n Apple uses clang extensively for development and has upstreamed the necessary\n functionality so that a vanilla clang can take advantage. It supports the use\n of -F, -target, -mmacosx-version-min, and --sysroot, which are all necessary\n-when building for OS X.\n+when building for macOS.\n \n Apple's version of binutils (called cctools) contains lots of functionality\n missing in the FSF's binutils. In addition to extra linker options for\n@@ -38,7 +38,7 @@ Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.1\n Unfortunately, the usual linux tools (7zip, hpmount, loopback mount) are incapable of opening this file.\n To create a tarball suitable for Gitian input, there are two options:\n \n-Using Mac OS X, you can mount the dmg, and then create it with:\n+Using macOS, you can mount the dmg, and then create it with:\n ```\n   $ hdiutil attach Xcode_7.3.1.dmg\n   $ tar -C /Volumes/Xcode/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/ -czf MacOSX10.11.sdk.tar.gz MacOSX10.11.sdk\n@@ -81,7 +81,7 @@ Background images and other features can be added to DMG files by inserting a\n .DS_Store before creation. This is generated by the script\n contrib/macdeploy/custom_dsstore.py.\n \n-As of OS X Mavericks (10.9), using an Apple-blessed key to sign binaries is a\n+As of OS X 10.9 Mavericks, using an Apple-blessed key to sign binaries is a\n requirement in order to satisfy the new Gatekeeper requirements. Because this\n private key cannot be shared, we'll have to be a bit creative in order for the\n build process to remain somewhat deterministic. Here's how it works:"
      },
      {
        "sha": "272cf4de29b7127e09f37e3a90186ee593d2104c",
        "filename": "doc/bips.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,7 +15,7 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.16.0**):\n * [`BIP 35`](https://github.com/bitcoin/bips/blob/master/bip-0035.mediawiki): The 'mempool' protocol message (and the protocol version bump to 60002) has been implemented since **v0.7.0** ([PR #1641](https://github.com/bitcoin/bitcoin/pull/1641)).\n * [`BIP 37`](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): The bloom filtering for transaction relaying, partial merkle trees for blocks, and the protocol version bump to 70001 (enabling low-bandwidth SPV clients) has been implemented since **v0.8.0** ([PR #1795](https://github.com/bitcoin/bitcoin/pull/1795)).\n * [`BIP 42`](https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki): The bug that would have caused the subsidy schedule to resume after block 13440000 was fixed in **v0.9.2** ([PR #3842](https://github.com/bitcoin/bitcoin/pull/3842)).\n-* [`BIP 61`](https://github.com/bitcoin/bips/blob/master/bip-0061.mediawiki): The 'reject' protocol message (and the protocol version bump to 70002) was added in **v0.9.0** ([PR #3185](https://github.com/bitcoin/bitcoin/pull/3185)).\n+* [`BIP 61`](https://github.com/bitcoin/bips/blob/master/bip-0061.mediawiki): The 'reject' protocol message (and the protocol version bump to 70002) was added in **v0.9.0** ([PR #3185](https://github.com/bitcoin/bitcoin/pull/3185)). Starting *v0.17.0*, whether to send reject messages can be configured with the `-enablebip61` option.\n * [`BIP 65`](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki): The CHECKLOCKTIMEVERIFY softfork was merged in **v0.12.0** ([PR #6351](https://github.com/bitcoin/bitcoin/pull/6351)), and backported to **v0.11.2** and **v0.10.4**. Mempool-only CLTV was added in [PR #6124](https://github.com/bitcoin/bitcoin/pull/6124).\n * [`BIP 66`](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki): The strict DER rules and associated version 3 blocks have been implemented since **v0.10.0** ([PR #5713](https://github.com/bitcoin/bitcoin/pull/5713)).\n * [`BIP 68`](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki): Sequence locks have been implemented as of **v0.12.1**  ([PR #7184](https://github.com/bitcoin/bitcoin/pull/7184)), and have been activated since *block 419328*."
      },
      {
        "sha": "48746ce0c2ca444afd21a68ab0828cb09beade13",
        "filename": "doc/build-freebsd.md",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-freebsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-freebsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-freebsd.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,46 @@\n+FreeBSD build guide\n+======================\n+(updated for FreeBSD 11.1)\n+\n+This guide describes how to build bitcoind and command-line utilities on FreeBSD.\n+\n+This guide does not contain instructions for building the GUI.\n+\n+## Preparation\n+\n+You will need the following dependencies, which can be installed as root via pkg:\n+\n+```\n+pkg install autoconf automake boost-libs git gmake libevent libtool openssl pkgconf\n+```\n+\n+For the wallet (optional):\n+```\n+./contrib/install_db4.sh `pwd`\n+export BDB_PREFIX=\"$PWD/db4\"\n+```\n+\n+See [dependencies.md](dependencies.md) for a complete overview.\n+\n+Download the source code:\n+```\n+git clone https://github.com/bitcoin/bitcoin\n+```\n+\n+## Building Bitcoin Core\n+\n+**Important**: Use `gmake` (the non-GNU `make` will exit with an error).\n+\n+```\n+./autogen.sh\n+\n+./configure                  # to build with wallet OR\n+./configure --disable-wallet # to build without wallet\n+\n+gmake\n+```\n+\n+*Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n+It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and\n+use the versioned gdb command (e.g. `gdb7111`).\n+"
      },
      {
        "sha": "63288acf16108d1d69515152812cc58efbeb3d9b",
        "filename": "doc/build-openbsd.md",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-openbsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-openbsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-openbsd.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,6 +1,6 @@\n OpenBSD build guide\n ======================\n-(updated for OpenBSD 6.2)\n+(updated for OpenBSD 6.3)\n \n This guide describes how to build bitcoind and command-line utilities on OpenBSD.\n \n@@ -12,11 +12,10 @@ Preparation\n Run the following as root to install the base dependencies for building:\n \n ```bash\n-pkg_add git gmake libevent libtool\n+pkg_add git gmake libevent libtool boost\n pkg_add autoconf # (select highest version, e.g. 2.69)\n pkg_add automake # (select highest version, e.g. 1.15)\n pkg_add python # (select highest version, e.g. 3.6)\n-pkg_add boost\n \n git clone https://github.com/bitcoin/bitcoin.git\n ```\n@@ -55,8 +54,15 @@ export BDB_PREFIX=\"$PWD/db4\"\n \n Preparation:\n ```bash\n-export AUTOCONF_VERSION=2.69 # replace this with the autoconf version that you installed\n-export AUTOMAKE_VERSION=1.15 # replace this with the automake version that you installed\n+\n+# Replace this with the autoconf version that you installed. Include only\n+# the major and minor parts of the version: use \"2.69\" for \"autoconf-2.69p2\".\n+export AUTOCONF_VERSION=2.69\n+\n+# Replace this with the automake version that you installed. Include only\n+# the major and minor parts of the version: use \"1.15\" for \"automake-1.15.1\".\n+export AUTOMAKE_VERSION=1.15\n+\n ./autogen.sh\n ```\n Make sure `BDB_PREFIX` is set to the appropriate path from the above steps."
      },
      {
        "sha": "a07dbd1e1d8a59f56812e5f0d08db95b5d65afc7",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,11 +1,11 @@\n-Mac OS X Build Instructions and Notes\n+macOS Build Instructions and Notes\n ====================================\n The commands in this guide should be executed in a Terminal application.\n The built-in one is located in `/Applications/Utilities/Terminal.app`.\n \n Preparation\n -----------\n-Install the OS X command line tools:\n+Install the macOS command line tools:\n \n `xcode-select --install`\n \n@@ -24,8 +24,6 @@ If you want to build the disk image with `make deploy` (.dmg / optional), you ne\n \n     brew install librsvg\n \n-NOTE: Building with Qt4 is still supported, however, could result in a broken UI. Building with Qt5 is recommended.\n-\n Berkeley DB\n -----------\n It is recommended to use Berkeley DB 4.8. If you have to build it yourself,\n@@ -93,6 +91,6 @@ Other commands:\n Notes\n -----\n \n-* Tested on OS X 10.8 through 10.13 on 64-bit Intel processors only.\n+* Tested on OS X 10.8 Mountain Lion through macOS 10.13 High Sierra on 64-bit Intel processors only.\n \n * Building with downloaded Qt binaries is not officially supported. See the notes in [#7714](https://github.com/bitcoin/bitcoin/issues/7714)"
      },
      {
        "sha": "e884c0ab67a4a4a20071fdcd080ec20a31fec2d4",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 5,
        "deletions": 53,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,8 +2,7 @@ UNIX BUILD NOTES\n ====================\n Some notes on how to build Bitcoin Core in Unix.\n \n-(For BSD specific instructions, see [build-openbsd.md](build-openbsd.md) and/or\n-[build-netbsd.md](build-netbsd.md))\n+(For BSD specific instructions, see `build-*bsd.md` in this directory.)\n \n Note\n ---------------------\n@@ -71,19 +70,7 @@ tuned to conserve memory with additional CXXFLAGS:\n \n Build requirements:\n \n-    sudo apt-get install build-essential libtool autotools-dev automake pkg-config libssl-dev libevent-dev bsdmainutils python3\n-\n-Options when installing required Boost library files:\n-\n-1. On at least Ubuntu 14.04+ and Debian 7+ there are generic names for the\n-individual boost development packages, so the following can be used to only\n-install necessary parts of boost:\n-\n-        sudo apt-get install libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev\n-\n-2. If that doesn't work, you can install all boost development packages with:\n-\n-        sudo apt-get install libboost-all-dev\n+    sudo apt-get install build-essential libtool autotools-dev automake pkg-config libssl-dev libevent-dev bsdmainutils python3 libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev\n \n BerkeleyDB is required for the wallet.\n \n@@ -113,18 +100,13 @@ ZMQ dependencies (provides ZMQ API 4.x):\n #### Dependencies for the GUI\n \n If you want to build Bitcoin-Qt, make sure that the required packages for Qt development\n-are installed. Either Qt 5 or Qt 4 are necessary to build the GUI.\n-If both Qt 4 and Qt 5 are installed, Qt 5 will be used. Pass `--with-gui=qt4` to configure to choose Qt4.\n+are installed. Qt 5 is necessary to build the GUI.\n To build without GUI pass `--without-gui`.\n \n-To build with Qt 5 (recommended) you need the following:\n+To build with Qt 5 you need the following:\n \n     sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler\n \n-Alternatively, to build with Qt 4 you need the following:\n-\n-    sudo apt-get install libqt4-dev libprotobuf-dev protobuf-compiler\n-\n libqrencode (optional) can be installed with:\n \n     sudo apt-get install libqrencode-dev\n@@ -145,7 +127,7 @@ Optional:\n \n     sudo dnf install miniupnpc-devel\n \n-To build with Qt 5 (recommended) you need the following:\n+To build with Qt 5 you need the following:\n \n     sudo dnf install qt5-qttools-devel qt5-qtbase-devel protobuf-devel\n \n@@ -303,33 +285,3 @@ To build executables for ARM:\n \n For further documentation on the depends system see [README.md](../depends/README.md) in the depends directory.\n \n-Building on FreeBSD\n---------------------\n-\n-(Updated as of FreeBSD 11.0)\n-\n-Clang is installed by default as `cc` compiler, this makes it easier to get\n-started than on [OpenBSD](build-openbsd.md). Installing dependencies:\n-\n-    pkg install autoconf automake libtool pkgconf\n-    pkg install boost-libs openssl libevent\n-    pkg install gmake\n-\n-You need to use GNU make (`gmake`) instead of `make`.\n-(`libressl` instead of `openssl` will also work)\n-\n-For the wallet (optional):\n-\n-    ./contrib/install_db4.sh `pwd`\n-    setenv BDB_PREFIX $PWD/db4\n-\n-Then build using:\n-\n-    ./autogen.sh\n-    ./configure --disable-wallet # OR\n-    ./configure BDB_CFLAGS=\"-I${BDB_PREFIX}/include\" BDB_LIBS=\"-L${BDB_PREFIX}/lib -ldb_cxx\"\n-    gmake\n-\n-*Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n-It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and\n-use the versioned gdb command e.g. `gdb7111`."
      },
      {
        "sha": "935e29ce1cde09005b35196f61ce4a7a8b0ba485",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 7,
        "deletions": 34,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -5,7 +5,7 @@ Below are some notes on how to build Bitcoin Core for Windows.\n \n The options known to work for building Bitcoin Core on Windows are:\n \n-* On Linux using the [Mingw-w64](https://mingw-w64.org/doku.php) cross compiler tool chain. Ubuntu Trusty 14.04 is recommended\n+* On Linux using the [Mingw-w64](https://mingw-w64.org/doku.php) cross compiler tool chain. Ubuntu Bionic 18.04 is required\n and is the platform used to build the Bitcoin Core Windows release binaries.\n * On Windows using [Windows\n Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about) and the Mingw-w64 cross compiler tool chain.\n@@ -38,10 +38,10 @@ To install WSL on Windows 10 with Fall Creators Update installed (version >= 162\n   * Enable 'Windows Subsystem for Linux'\n   * Click 'OK' and restart if necessary\n 2. Install Ubuntu\n-  * Open Microsoft Store and search for Ubuntu or use [this link](https://www.microsoft.com/store/productId/9NBLGGH4MSV6)\n+  * Open Microsoft Store and search for \"Ubuntu 18.04\" or use [this link](https://www.microsoft.com/store/productId/9N9TNGVNDL3Q)\n   * Click Install\n 3. Complete Installation\n-  * Open a cmd prompt and type \"Ubuntu\"\n+  * Open a cmd prompt and type \"Ubuntu1804\"\n   * Create a new UNIX user account (this is a separate account from your Windows account)\n \n After the bash shell is active, you can follow the instructions below, starting\n@@ -51,11 +51,6 @@ recommended but it is possible to compile the 32-bit version.\n Cross-compilation for Ubuntu and Windows Subsystem for Linux\n ------------------------------------------------------------\n \n-At the time of writing the Windows Subsystem for Linux installs Ubuntu Xenial 16.04. The Mingw-w64 package\n-for Ubuntu Xenial does not produce working executables for some of the Bitcoin Core applications.\n-It is possible to build on Ubuntu Xenial by installing the cross compiler packages from Ubuntu Artful, see the steps below.\n-Building on Ubuntu Artful 17.10 has been verified to work.\n-\n The steps below can be performed on Ubuntu (including in a VM) or WSL. The depends system\n will also work on other Linux distributions, however the commands for\n installing the toolchain will be different.\n@@ -74,26 +69,11 @@ See also: [dependencies.md](dependencies.md).\n \n ## Building for 64-bit Windows\n \n-The first step is to install the mingw-w64 cross-compilation tool chain. Due to different Ubuntu\n-packages for each distribution and problems with the Xenial packages the steps for each are different.\n-\n-Common steps to install mingw32 cross compiler tool chain:\n+The first step is to install the mingw-w64 cross-compilation tool chain.\n \n     sudo apt install g++-mingw-w64-x86-64\n \n-Ubuntu Trusty 14.04:\n-\n-    No further steps required\n-\n-Ubuntu Xenial 16.04 and Windows Subsystem for Linux <sup>[1](#footnote1),[2](#footnote2)</sup>:\n-\n-    sudo apt install software-properties-common\n-    sudo add-apt-repository \"deb http://archive.ubuntu.com/ubuntu artful universe\"\n-    sudo apt update\n-    sudo apt upgrade\n-    sudo update-alternatives --config x86_64-w64-mingw32-g++ # Set the default mingw32 g++ compiler option to posix.\n-\n-Ubuntu Artful 17.10 <sup>[2](#footnote2)</sup>:\n+Ubuntu Bionic 18.04 <sup>[1](#footnote1)</sup>:\n \n     sudo update-alternatives --config x86_64-w64-mingw32-g++ # Set the default mingw32 g++ compiler option to posix.\n \n@@ -123,7 +103,7 @@ To build executables for Windows 32-bit, install the following dependencies:\n \n     sudo apt install g++-mingw-w64-i686 mingw-w64-i686-dev\n \n-For Ubuntu Xenial 16.04, Ubuntu Artful 17.10 and Windows Subsystem for Linux <sup>[2](#footnote2)</sup>:\n+For Ubuntu Bionic 18.04 and Windows Subsystem for Linux <sup>[1](#footnote1)</sup>:\n \n     sudo update-alternatives --config i686-w64-mingw32-g++  # Set the default mingw32 g++ compiler option to posix.\n \n@@ -162,14 +142,7 @@ way. This will install to `c:\\workspace\\bitcoin`, for example:\n Footnotes\n ---------\n \n-<a name=\"footnote1\">1</a>: There is currently a bug in the 64 bit Mingw-w64 cross compiler packaged for WSL/Ubuntu Xenial 16.04 that\n-causes two of the bitcoin executables to crash shortly after start up. The bug is related to the\n--fstack-protector-all g++ compiler flag which is used to mitigate buffer overflows.\n-Installing the Mingw-w64 packages from the Ubuntu 17.10 distribution solves the issue, however, this is not\n-an officially supported approach and it's only recommended if you are prepared to reinstall WSL/Ubuntu should\n-something break.\n-\n-<a name=\"footnote2\">2</a>: Starting from Ubuntu Xenial 16.04 both the 32 and 64 bit Mingw-w64 packages install two different\n+<a name=\"footnote1\">1</a>: Starting from Ubuntu Xenial 16.04 both the 32 and 64 bit Mingw-w64 packages install two different\n compiler options to allow a choice between either posix or win32 threads. The default option is win32 threads which is the more\n efficient since it will result in binary code that links directly with the Windows kernel32.lib. Unfortunately, the headers\n required to support win32 threads conflict with some of the classes in the C++11 standard library in particular std::mutex."
      },
      {
        "sha": "793c659419c0153b8a150250cebfa8cc708d3734",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -23,7 +23,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | protobuf | [2.6.3](https://github.com/google/protobuf/releases) |  | No |  |  |\n | Python (tests) |  | [3.4](https://www.python.org/downloads) |  |  |  |\n | qrencode | [3.4.4](https://fukuchi.org/works/qrencode) |  | No |  |  |\n-| Qt | [5.7.1](https://download.qt.io/official_releases/qt/) | 4.7+ | No |  |  |\n+| Qt | [5.7.1](https://download.qt.io/official_releases/qt/) | 5.x | No |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L94) (Linux only) |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L93) (Linux only) |\n | ZeroMQ | [4.2.3](https://github.com/zeromq/libzmq/releases) |  | No |  |  |"
      },
      {
        "sha": "2fa91ecb0299bf1d23d40ab1951d8b8a40a0d3af",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 39,
        "deletions": 5,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -499,7 +499,35 @@ Strings and formatting\n \n - Use `ParseInt32`, `ParseInt64`, `ParseUInt32`, `ParseUInt64`, `ParseDouble` from `utilstrencodings.h` for number parsing\n \n-  - *Rationale*: These functions do overflow checking, and avoid pesky locale issues\n+  - *Rationale*: These functions do overflow checking, and avoid pesky locale issues.\n+\n+- Avoid using locale dependent functions if possible. You can use the provided\n+  [`lint-locale-dependence.sh`](/contrib/devtools/lint-locale-dependence.sh)\n+  to check for accidental use of locale dependent functions.\n+\n+  - *Rationale*: Unnecessary locale dependence can cause bugs that are very tricky to isolate and fix.\n+\n+  - These functions are known to be locale dependent:\n+    `alphasort`, `asctime`, `asprintf`, `atof`, `atoi`, `atol`, `atoll`, `atoq`,\n+    `btowc`, `ctime`, `dprintf`, `fgetwc`, `fgetws`, `fprintf`, `fputwc`,\n+    `fputws`, `fscanf`, `fwprintf`, `getdate`, `getwc`, `getwchar`, `isalnum`,\n+    `isalpha`, `isblank`, `iscntrl`, `isdigit`, `isgraph`, `islower`, `isprint`,\n+    `ispunct`, `isspace`, `isupper`, `iswalnum`, `iswalpha`, `iswblank`,\n+    `iswcntrl`, `iswctype`, `iswdigit`, `iswgraph`, `iswlower`, `iswprint`,\n+    `iswpunct`, `iswspace`, `iswupper`, `iswxdigit`, `isxdigit`, `mblen`,\n+    `mbrlen`, `mbrtowc`, `mbsinit`, `mbsnrtowcs`, `mbsrtowcs`, `mbstowcs`,\n+    `mbtowc`, `mktime`, `putwc`, `putwchar`, `scanf`, `snprintf`, `sprintf`,\n+    `sscanf`, `stoi`, `stol`, `stoll`, `strcasecmp`, `strcasestr`, `strcoll`,\n+    `strfmon`, `strftime`, `strncasecmp`, `strptime`, `strtod`, `strtof`,\n+    `strtoimax`, `strtol`, `strtold`, `strtoll`, `strtoq`, `strtoul`,\n+    `strtoull`, `strtoumax`, `strtouq`, `strxfrm`, `swprintf`, `tolower`,\n+    `toupper`, `towctrans`, `towlower`, `towupper`, `ungetwc`, `vasprintf`,\n+    `vdprintf`, `versionsort`, `vfprintf`, `vfscanf`, `vfwprintf`, `vprintf`,\n+    `vscanf`, `vsnprintf`, `vsprintf`, `vsscanf`, `vswprintf`, `vwprintf`,\n+    `wcrtomb`, `wcscasecmp`, `wcscoll`, `wcsftime`, `wcsncasecmp`, `wcsnrtombs`,\n+    `wcsrtombs`, `wcstod`, `wcstof`, `wcstoimax`, `wcstol`, `wcstold`,\n+    `wcstoll`, `wcstombs`, `wcstoul`, `wcstoull`, `wcstoumax`, `wcswidth`,\n+    `wcsxfrm`, `wctob`, `wctomb`, `wctrans`, `wctype`, `wcwidth`, `wprintf`\n \n - For `strprintf`, `LogPrint`, `LogPrintf` formatting characters don't need size specifiers\n \n@@ -567,6 +595,12 @@ Source code organization\n \n   - *Rationale*: Shorter and simpler header files are easier to read, and reduce compile time\n \n+- Use only the lowercase alphanumerics (`a-z0-9`), underscore (`_`) and hyphen (`-`) in source code filenames.\n+\n+  - *Rationale*: `grep`:ing and auto-completing filenames is easier when using a consistent\n+    naming pattern. Potential problems when building on case-insensitive filesystems are\n+    avoided when using only lowercase characters in source code filenames.\n+\n - Every `.cpp` and `.h` file should `#include` every header file it directly uses classes, functions or other\n   definitions from, even if those headers are already included indirectly through other headers.\n \n@@ -594,8 +628,8 @@ namespace {\n \n   - *Rationale*: Avoids confusion about the namespace context\n \n-- Prefer `#include <primitives/transaction.h>` bracket syntax instead of\n-  `#include \"primitives/transactions.h\"` quote syntax when possible.\n+- Use `#include <primitives/transaction.h>` bracket syntax instead of\n+  `#include \"primitives/transactions.h\"` quote syntax.\n \n   - *Rationale*: Bracket syntax is less ambiguous because the preprocessor\n     searches a fixed list of include directories without taking location of the\n@@ -647,7 +681,7 @@ Others are external projects without a tight relationship with our project.  Cha\n be sent upstream but bugfixes may also be prudent to PR against Bitcoin Core so that they can be integrated\n quickly.  Cosmetic changes should be purely taken upstream.\n \n-There is a tool in contrib/devtools/git-subtree-check.sh to check a subtree directory for consistency with\n+There is a tool in `test/lint/git-subtree-check.sh` to check a subtree directory for consistency with\n its upstream repository.\n \n Current subtrees include:\n@@ -778,7 +812,7 @@ To create a scripted-diff:\n     - `-BEGIN VERIFY SCRIPT-`\n     - `-END VERIFY SCRIPT-`\n \n-The scripted-diff is verified by the tool `contrib/devtools/commit-script-check.sh`\n+The scripted-diff is verified by the tool `test/lint/commit-script-check.sh`\n \n Commit [`bb81e173`](https://github.com/bitcoin/bitcoin/commit/bb81e173) is an example of a scripted-diff.\n "
      },
      {
        "sha": "d04f7d186a362fcb28f818ad524e2a15d9c2722b",
        "filename": "doc/init.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/init.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/init.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/init.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,7 +15,7 @@ Service User\n \n All three Linux startup configurations assume the existence of a \"bitcoin\" user\n and group.  They must be created before attempting to use these scripts.\n-The OS X configuration assumes bitcoind will be set up for the current user.\n+The macOS configuration assumes bitcoind will be set up for the current user.\n \n Configuration\n ---------------------------------\n@@ -65,7 +65,7 @@ reasons to make the configuration file and data directory only readable by the\n bitcoin user and group.  Access to bitcoin-cli and other bitcoind rpc clients\n can then be controlled by group membership.\n \n-### Mac OS X\n+### macOS\n \n Binary:              `/usr/local/bin/bitcoind`  \n Configuration file:  `~/Library/Application Support/Bitcoin/bitcoin.conf`  \n@@ -111,7 +111,7 @@ Using this script, you can adjust the path and flags to the bitcoind program by\n setting the BITCOIND and FLAGS environment variables in the file\n /etc/sysconfig/bitcoind. You can also use the DAEMONOPTS environment variable here.\n \n-### Mac OS X\n+### macOS\n \n Copy org.bitcoin.bitcoind.plist into ~/Library/LaunchAgents. Load the launch agent by\n running `launchctl load ~/Library/LaunchAgents/org.bitcoin.bitcoind.plist`."
      },
      {
        "sha": "a2eb8cd83707ca5b27f5a0f98262d4785fa3becc",
        "filename": "doc/release-notes-pr10740.md",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes-pr10740.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes-pr10740.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr10740.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,8 +1,10 @@\n-Dynamic loading of wallets\n---------------------------\n+Dynamic loading and creation of wallets\n+---------------------------------------\n \n-Previously, wallets could only be loaded at startup, by specifying `-wallet` parameters on the command line or in the bitcoin.conf file. It is now possible to load wallets dynamically at runtime by calling the `loadwallet` RPC.\n+Previously, wallets could only be loaded or created at startup, by specifying `-wallet` parameters on the command line or in the bitcoin.conf file. It is now possible to load, create and unload wallets dynamically at runtime:\n \n-The wallet can be specified as file/directory basename (which must be located in the `walletdir` directory), or as an absolute path to a file/directory.\n+- Existing wallets can be loaded by calling the `loadwallet` RPC. The wallet can be specified as file/directory basename (which must be located in the `walletdir` directory), or as an absolute path to a file/directory.\n+- New wallets can be created (and loaded) by calling the `createwallet` RPC. The provided name must not match a wallet file in the `walletdir` directory or the name of a wallet that is currently loaded.\n+- Loaded wallets can be unloaded by calling the `unloadwallet` RPC.\n \n-This feature is currently only available through the RPC interface. Wallets loaded in this way will display in the bitcoin-qt GUI.\n+This feature is currently only available through the RPC interface."
      },
      {
        "sha": "f4a95bd40fa45846761bd6d385bd591ef99620c2",
        "filename": "doc/release-notes-pr12892.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes-pr12892.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes-pr12892.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr12892.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -18,7 +18,7 @@ Here are the changes to RPC methods:\n | Deprecated Method       | New Method            | Notes       |\n | :---------------------- | :-------------------- | :-----------|\n | `getaccount`            | `getaddressinfo`      | `getaddressinfo` returns a json object with address information instead of just the name of the account as a string. |\n-| `getaccountaddress`     | `getlabeladdress`     | `getlabeladdress` throws an error by default if the label does not already exist, but provides a `force` option for compatibility with existing applications. |\n+| `getaccountaddress`     | n/a                   | There is no replacement for `getaccountaddress` since labels do not have an associated receive address. |\n | `getaddressesbyaccount` | `getaddressesbylabel` | `getaddressesbylabel` returns a json object with the addresses as keys, instead of a list of strings. |\n | `getreceivedbyaccount`  | `getreceivedbylabel`  | _no change in behavior_ |\n | `listaccounts`          | `listlabels`          | `listlabels` does not return a balance or accept `minconf` and `watchonly` arguments. |"
      },
      {
        "sha": "e1bb84cca9e25ed41d512ece67ba2302dac825d8",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -56,6 +56,11 @@ frequently tested on them.\n Notable changes\n ===============\n \n+GUI changes\n+-----------\n+\n+- Block storage can be limited under Preferences, in the Main tab. Undoing this setting requires downloading the full blockchain again. This mode is incompatible with -txindex and -rescan.\n+\n RPC changes\n ------------\n "
      },
      {
        "sha": "d99361ae1d2863de53f549c7178375d542f3f168",
        "filename": "doc/release-notes/release-notes-0.16.1.md",
        "status": "added",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes/release-notes-0.16.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-notes/release-notes-0.16.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.16.1.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,145 @@\n+Bitcoin Core version 0.16.1 is now available from:\n+\n+  <https://bitcoincore.org/bin/bitcoin-core-0.16.1/>\n+\n+This is a new minor version release, with various bugfixes\n+as well as updated translations.\n+\n+Please report bugs using the issue tracker at GitHub:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+How to Upgrade\n+==============\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\n+or `bitcoind`/`bitcoin-qt` (on Linux).\n+\n+The first time you run version 0.15.0 or newer, your chainstate database will be converted to a\n+new format, which will take anywhere from a few minutes to half an hour,\n+depending on the speed of your machine.\n+\n+Note that the block database format also changed in version 0.8.0 and there is no\n+automatic upgrade code from before version 0.8 to version 0.15.0 or higher. Upgrading\n+directly from 0.7.x and earlier without re-downloading the blockchain is not supported.\n+However, as usual, old wallet versions are still supported.\n+\n+Downgrading warning\n+-------------------\n+\n+Wallets created in 0.16 and later are not compatible with versions prior to 0.16\n+and will not work if you try to use newly created wallets in older versions. Existing\n+wallets that were created with older versions are not affected by this.\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+Miner block size removed\n+------------------------\n+\n+The `-blockmaxsize` option for miners to limit their blocks' sizes was\n+deprecated in version 0.15.1, and has now been removed. Miners should use the\n+`-blockmaxweight` option if they want to limit the weight of their blocks'\n+weights.\n+\n+0.16.1 change log\n+------------------\n+\n+### Policy\n+- #11423 `d353dd1` [Policy] Several transaction standardness rules (jl2012)\n+\n+### Mining\n+- #12756 `e802c22` [config] Remove blockmaxsize option (jnewbery)\n+\n+### Block and transaction handling\n+- #13199 `c71e535` Bugfix: ensure consistency of m_failed_blocks after reconsiderblock (sdaftuar)\n+- #13023 `bb79aaf` Fix some concurrency issues in ActivateBestChain() (skeees)\n+\n+### P2P protocol and network code\n+- #12626 `f60e84d` Limit the number of IPs addrman learns from each DNS seeder (EthanHeilman)\n+\n+### Wallet\n+- #13265 `5d8de76` Exit SyncMetaData if there are no transactions to sync (laanwj)\n+- #13030 `5ff571e` Fix zapwallettxes/multiwallet interaction. (jnewbery)\n+\n+### GUI\n+- #12999 `1720eb3` Show the Window when double clicking the taskbar icon (ken2812221)\n+- #12650 `f118a7a` Fix issue: \"default port not shown correctly in settings dialog\" (251Labs)\n+- #13251 `ea487f9` Rephrase Bech32 checkbox texts, and enable it with legacy address default (fanquake)\n+\n+### Build system\n+- #12474 `b0f692f` Allow depends system to support armv7l (hkjn)\n+- #12585 `72a3290` depends: Switch to downloading expat from GitHub (fanquake)\n+- #12648 `46ca8f3` test: Update trusted git root (MarcoFalke)\n+- #11995 `686cb86` depends: Fix Qt build with Xcode 9 (fanquake)\n+- #12636 `845838c` backport: #11995 Fix Qt build with Xcode 9 (fanquake)\n+- #12946 `e055bc0` depends: Fix Qt build with XCode 9.3 (fanquake)\n+- #12998 `7847b92` Default to defining endian-conversion DECLs in compat w/o config (TheBlueMatt)\n+\n+### Tests and QA\n+- #12447 `01f931b` Add missing signal.h header (laanwj)\n+- #12545 `1286f3e` Use wait_until to ensure ping goes out (Empact)\n+- #12804 `4bdb0ce` Fix intermittent rpc_net.py failure. (jnewbery)\n+- #12553 `0e98f96` Prefer wait_until over polling with time.sleep (Empact)\n+- #12486 `cfebd40` Round target fee to 8 decimals in assert_fee_amount (kallewoof)\n+- #12843 `df38b13` Test starting bitcoind with -h and -version (jnewbery)\n+- #12475 `41c29f6` Fix python TypeError in script.py (MarcoFalke)\n+- #12638 `0a76ed2` Cache only chain and wallet for regtest datadir (MarcoFalke)\n+- #12902 `7460945` Handle potential cookie race when starting node (sdaftuar)\n+- #12904 `6c26df0` Ensure bitcoind processes are cleaned up when tests end (sdaftuar)\n+- #13049 `9ea62a3` Backports (MarcoFalke)\n+- #13201 `b8aacd6` Handle disconnect_node race (sdaftuar)\n+\n+### Miscellaneous\n+- #12518 `a17fecf` Bump leveldb subtree (MarcoFalke)\n+- #12442 `f3b8d85` devtools: Exclude patches from lint-whitespace (MarcoFalke)\n+- #12988 `acdf433` Hold cs_main while calling UpdatedBlockTip() signal (skeees)\n+- #12985 `0684cf9` Windows: Avoid launching as admin when NSIS installer ends. (JeremyRand)\n+\n+### Documentation\n+- #12637 `60086dd` backport: #12556 fix version typo in getpeerinfo RPC call help (fanquake)\n+- #13184 `4087dd0` RPC Docs: `gettxout*`: clarify bestblock and unspent counts (harding)\n+- #13246 `6de7543` Bump to Ubuntu Bionic 18.04 in build-windows.md (ken2812221)\n+- #12556 `e730b82` Fix version typo in getpeerinfo RPC call help (tamasblummer)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- 251\n+- Ben Woosley\n+- Chun Kuan Lee\n+- David A. Harding\n+- e0\n+- fanquake\n+- Henrik Jonsson\n+- JeremyRand\n+- Jesse Cohen\n+- John Newbery\n+- Johnson Lau\n+- Karl-Johan Alm\n+- Luke Dashjr\n+- MarcoFalke\n+- Matt Corallo\n+- Pieter Wuille\n+- Suhas Daftuar\n+- Tamas Blummer\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "912b62079461cff541b34e1ff75acb4e9a080883",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -89,7 +89,7 @@ Ensure gitian-builder is up-to-date:\n     wget -P inputs http://downloads.sourceforge.net/project/osslsigncode/osslsigncode/osslsigncode-1.7.1.tar.gz\n     popd\n \n-Create the OS X SDK tarball, see the [OS X readme](README_osx.md) for details, and copy it into the inputs directory.\n+Create the macOS SDK tarball, see the [macOS readme](README_osx.md) for details, and copy it into the inputs directory.\n \n ### Optional: Seed the Gitian sources cache and offline git repositories\n \n@@ -111,7 +111,7 @@ NOTE: Offline builds must use the --url flag to ensure Gitian fetches only from\n \n The gbuild invocations below <b>DO NOT DO THIS</b> by default.\n \n-### Build and sign Bitcoin Core for Linux, Windows, and OS X:\n+### Build and sign Bitcoin Core for Linux, Windows, and macOS:\n \n     pushd ./gitian-builder\n     ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n@@ -134,7 +134,7 @@ Build output expected:\n   1. source tarball (`bitcoin-${VERSION}.tar.gz`)\n   2. linux 32-bit and 64-bit dist tarballs (`bitcoin-${VERSION}-linux[32|64].tar.gz`)\n   3. windows 32-bit and 64-bit unsigned installers and dist zips (`bitcoin-${VERSION}-win[32|64]-setup-unsigned.exe`, `bitcoin-${VERSION}-win[32|64].zip`)\n-  4. OS X unsigned installer and dist tarball (`bitcoin-${VERSION}-osx-unsigned.dmg`, `bitcoin-${VERSION}-osx64.tar.gz`)\n+  4. macOS unsigned installer and dist tarball (`bitcoin-${VERSION}-osx-unsigned.dmg`, `bitcoin-${VERSION}-osx64.tar.gz`)\n   5. Gitian signatures (in `gitian.sigs/${VERSION}-<linux|{win,osx}-unsigned>/(your Gitian key)/`)\n \n ### Verify other gitian builders signatures to your own. (Optional)\n@@ -161,13 +161,13 @@ Commit your signature to gitian.sigs:\n     git push  # Assuming you can push to the gitian.sigs tree\n     popd\n \n-Codesigner only: Create Windows/OS X detached signatures:\n+Codesigner only: Create Windows/macOS detached signatures:\n - Only one person handles codesigning. Everyone else should skip to the next step.\n-- Only once the Windows/OS X builds each have 3 matching signatures may they be signed with their respective release keys.\n+- Only once the Windows/macOS builds each have 3 matching signatures may they be signed with their respective release keys.\n \n-Codesigner only: Sign the osx binary:\n+Codesigner only: Sign the macOS binary:\n \n-    transfer bitcoin-osx-unsigned.tar.gz to osx for signing\n+    transfer bitcoin-osx-unsigned.tar.gz to macOS for signing\n     tar xf bitcoin-osx-unsigned.tar.gz\n     ./detached-sig-create.sh -s \"Key ID\"\n     Enter the keychain password and authorize the signature\n@@ -192,12 +192,12 @@ Codesigner only: Commit the detached codesign payloads:\n     git tag -s v${VERSION} HEAD\n     git push the current branch and new tag\n \n-Non-codesigners: wait for Windows/OS X detached signatures:\n+Non-codesigners: wait for Windows/macOS detached signatures:\n \n-- Once the Windows/OS X builds each have 3 matching signatures, they will be signed with their respective release keys.\n+- Once the Windows/macOS builds each have 3 matching signatures, they will be signed with their respective release keys.\n - Detached signatures will then be committed to the [bitcoin-detached-sigs](https://github.com/bitcoin-core/bitcoin-detached-sigs) repository, which can be combined with the unsigned apps to create signed binaries.\n \n-Create (and optionally verify) the signed OS X binary:\n+Create (and optionally verify) the signed macOS binary:\n \n     pushd ./gitian-builder\n     ./bin/gbuild -i --commit signature=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n@@ -216,7 +216,7 @@ Create (and optionally verify) the signed Windows binaries:\n     mv build/out/bitcoin-*win32-setup.exe ../bitcoin-${VERSION}-win32-setup.exe\n     popd\n \n-Commit your signature for the signed OS X/Windows binaries:\n+Commit your signature for the signed macOS/Windows binaries:\n \n     pushd gitian.sigs\n     git add ${VERSION}-osx-signed/\"${SIGNER}\"\n@@ -276,14 +276,14 @@ bitcoin.org (see below for bitcoin.org update instructions).\n - Update bitcoin.org version\n \n   - First, check to see if the Bitcoin.org maintainers have prepared a\n-    release: https://github.com/bitcoin-dot-org/bitcoin.org/labels/Releases\n+    release: https://github.com/bitcoin-dot-org/bitcoin.org/labels/Core\n \n       - If they have, it will have previously failed their Travis CI\n         checks because the final release files weren't uploaded.\n         Trigger a Travis CI rebuild---if it passes, merge.\n \n   - If they have not prepared a release, follow the Bitcoin.org release\n-    instructions: https://github.com/bitcoin-dot-org/bitcoin.org#release-notes\n+    instructions: https://github.com/bitcoin-dot-org/bitcoin.org/blob/master/docs/adding-events-release-notes-and-alerts.md#release-notes\n \n   - After the pull request is merged, the website will automatically show the newest version within 15 minutes, as well\n     as update the OS download links. Ping @saivann/@harding (saivann/harding on Freenode) in case anything goes wrong"
      },
      {
        "sha": "022d7bb00b9039aa002def04ed260871346b5ee2",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -46,9 +46,7 @@ Visit the [Transifex Signup](https://www.transifex.com/signup/) page to create a\n You can find the Bitcoin translation project at [https://www.transifex.com/projects/p/bitcoin/](https://www.transifex.com/projects/p/bitcoin/).\n \n ### Installing the Transifex client command-line tool\n-The client it used to fetch updated translations. If you are having problems, or need more details, see [http://docs.transifex.com/developer/client/setup](http://docs.transifex.com/developer/client/setup)\n-\n-**For Linux and Mac**\n+The client is used to fetch updated translations. If you are having problems, or need more details, see [https://docs.transifex.com/client/installing-the-client](https://docs.transifex.com/client/installing-the-client)\n \n `pip install transifex-client`\n \n@@ -64,10 +62,6 @@ token =\n username = USERNAME\n ```\n \n-**For Windows**\n-\n-Please see [http://docs.transifex.com/developer/client/setup#windows](http://docs.transifex.com/developer/client/setup#windows) for details on installation.\n-\n The Transifex Bitcoin project config file is included as part of the repo. It can be found at `.tx/config`, however you shouldn\u2019t need change anything.\n \n ### Synchronising translations"
      },
      {
        "sha": "38c9ba176cf8535a66791f6121d349ad6f8c9af2",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n if [ $# -gt 1 ]; then\n     cd \"$2\" || exit 1\n fi"
      },
      {
        "sha": "e90807132114ed5ad31fd61a1852dc7e95a03760",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -63,7 +63,7 @@ def parse_po(text):\n \n messages = parse_po(out.decode('utf-8'))\n \n-f = open(OUT_CPP, 'w')\n+f = open(OUT_CPP, 'w', encoding=\"utf8\")\n f.write(\"\"\"\n \n #include <QtGlobal>"
      },
      {
        "sha": "a2599d33e1ac989ffc0982a70d8e5fd027e3a054",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 32,
        "deletions": 8,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -5,7 +5,7 @@\n DIST_SUBDIRS = secp256k1 univalue\n \n AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS) $(GPROF_LDFLAGS) $(SANITIZER_LDFLAGS)\n-AM_CXXFLAGS = $(DEBUG_CXXFLAGS) $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS) $(SANITIZER_CXXFLAGS)\n+AM_CXXFLAGS = $(DEBUG_CXXFLAGS) $(HARDENED_CXXFLAGS) $(WARN_CXXFLAGS) $(NOWARN_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS) $(SANITIZER_CXXFLAGS)\n AM_CPPFLAGS = $(DEBUG_CPPFLAGS) $(HARDENED_CPPFLAGS)\n AM_LIBTOOLFLAGS = --preserve-dup-deps\n EXTRA_LIBRARIES =\n@@ -29,7 +29,7 @@ LIBBITCOIN_COMMON=libbitcoin_common.a\n LIBBITCOIN_CONSENSUS=libbitcoin_consensus.a\n LIBBITCOIN_CLI=libbitcoin_cli.a\n LIBBITCOIN_UTIL=libbitcoin_util.a\n-LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n+LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n@@ -43,6 +43,16 @@ if ENABLE_WALLET\n LIBBITCOIN_WALLET=libbitcoin_wallet.a\n endif\n \n+LIBBITCOIN_CRYPTO= $(LIBBITCOIN_CRYPTO_BASE)\n+if ENABLE_SSE41\n+LIBBITCOIN_CRYPTO_SSE41 = crypto/libbitcoin_crypto_sse41.a\n+LIBBITCOIN_CRYPTO += $(LIBBITCOIN_CRYPTO_SSE41)\n+endif\n+if ENABLE_AVX2\n+LIBBITCOIN_CRYPTO_AVX2 = crypto/libbitcoin_crypto_avx2.a\n+LIBBITCOIN_CRYPTO += $(LIBBITCOIN_CRYPTO_AVX2)\n+endif\n+\n $(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n \n@@ -103,6 +113,7 @@ BITCOIN_CORE_H = \\\n   fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n+  index/base.h \\\n   index/txindex.h \\\n   indirectmap.h \\\n   init.h \\\n@@ -204,6 +215,7 @@ libbitcoin_server_a_SOURCES = \\\n   consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n+  index/base.cpp \\\n   index/txindex.cpp \\\n   init.cpp \\\n   dbwrapper.cpp \\\n@@ -223,6 +235,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/net.cpp \\\n   rpc/rawtransaction.cpp \\\n   rpc/server.cpp \\\n+  rpc/util.cpp \\\n   script/sigcache.cpp \\\n   timedata.cpp \\\n   torcontrol.cpp \\\n@@ -264,9 +277,9 @@ libbitcoin_wallet_a_SOURCES = \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library\n-crypto_libbitcoin_crypto_a_CPPFLAGS = $(AM_CPPFLAGS)\n-crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-crypto_libbitcoin_crypto_a_SOURCES = \\\n+crypto_libbitcoin_crypto_base_a_CPPFLAGS = $(AM_CPPFLAGS)\n+crypto_libbitcoin_crypto_base_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+crypto_libbitcoin_crypto_base_a_SOURCES = \\\n   crypto/aes.cpp \\\n   crypto/aes.h \\\n   crypto/chacha20.h \\\n@@ -286,9 +299,21 @@ crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/sha512.h\n \n if USE_ASM\n-crypto_libbitcoin_crypto_a_SOURCES += crypto/sha256_sse4.cpp\n+crypto_libbitcoin_crypto_base_a_SOURCES += crypto/sha256_sse4.cpp\n endif\n \n+crypto_libbitcoin_crypto_sse41_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+crypto_libbitcoin_crypto_sse41_a_CPPFLAGS = $(AM_CPPFLAGS)\n+crypto_libbitcoin_crypto_sse41_a_CXXFLAGS += $(SSE41_CXXFLAGS)\n+crypto_libbitcoin_crypto_sse41_a_CPPFLAGS += -DENABLE_SSE41\n+crypto_libbitcoin_crypto_sse41_a_SOURCES = crypto/sha256_sse41.cpp\n+\n+crypto_libbitcoin_crypto_avx2_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+crypto_libbitcoin_crypto_avx2_a_CPPFLAGS = $(AM_CPPFLAGS)\n+crypto_libbitcoin_crypto_avx2_a_CXXFLAGS += $(AVX2_CXXFLAGS)\n+crypto_libbitcoin_crypto_avx2_a_CPPFLAGS += -DENABLE_AVX2\n+crypto_libbitcoin_crypto_avx2_a_SOURCES = crypto/sha256_avx2.cpp\n+\n # consensus: shared between all executables that validate any consensus rules.\n libbitcoin_consensus_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_consensus_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -368,7 +393,6 @@ libbitcoin_util_a_SOURCES = \\\n   logging.cpp \\\n   random.cpp \\\n   rpc/protocol.cpp \\\n-  rpc/util.cpp \\\n   support/cleanse.cpp \\\n   sync.cpp \\\n   threadinterrupt.cpp \\\n@@ -461,7 +485,7 @@ bitcoin_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n # bitcoinconsensus library #\n if BUILD_BITCOIN_LIBS\n include_HEADERS = script/bitcoinconsensus.h\n-libbitcoinconsensus_la_SOURCES = $(crypto_libbitcoin_crypto_a_SOURCES) $(libbitcoin_consensus_a_SOURCES)\n+libbitcoinconsensus_la_SOURCES = $(crypto_libbitcoin_crypto_base_a_SOURCES) $(libbitcoin_consensus_a_SOURCES)\n \n if GLIBC_BACK_COMPAT\n   libbitcoinconsensus_la_SOURCES += compat/glibc_compat.cpp"
      },
      {
        "sha": "d70df3c9e8fc670163125cca41769cfb2606b69f",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,12 +15,14 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/bench_bitcoin.cpp \\\n   bench/bench.cpp \\\n   bench/bench.h \\\n+  bench/block_assemble.cpp \\\n   bench/checkblock.cpp \\\n   bench/checkqueue.cpp \\\n-  bench/Examples.cpp \\\n+  bench/examples.cpp \\\n   bench/rollingbloom.cpp \\\n   bench/crypto_hash.cpp \\\n   bench/ccoins_caching.cpp \\\n+  bench/merkle_root.cpp \\\n   bench/mempool_eviction.cpp \\\n   bench/verify_script.cpp \\\n   bench/base58.cpp \\"
      },
      {
        "sha": "a4d31795ec6385a612b5df4e8229e8ae9fa8e87f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -46,7 +46,7 @@ BITCOIN_TESTS =\\\n   test/compress_tests.cpp \\\n   test/crypto_tests.cpp \\\n   test/cuckoocache_tests.cpp \\\n-  test/DoS_tests.cpp \\\n+  test/denialofservice_tests.cpp \\\n   test/getarg_tests.cpp \\\n   test/hash_tests.cpp \\\n   test/key_io_tests.cpp \\\n@@ -71,7 +71,7 @@ BITCOIN_TESTS =\\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\\n-  test/script_P2SH_tests.cpp \\\n+  test/script_p2sh_tests.cpp \\\n   test/script_tests.cpp \\\n   test/script_standard_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n@@ -109,6 +109,7 @@ test_test_bitcoin_LDADD =\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n+\n test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -134,6 +135,8 @@ test_test_bitcoin_fuzzy_LDADD = \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBBITCOIN_CRYPTO_SSE41) \\\n+  $(LIBBITCOIN_CRYPTO_AVX2) \\\n   $(LIBSECP256K1)\n \n test_test_bitcoin_fuzzy_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n@@ -166,8 +169,8 @@ if EMBEDDED_UNIVALUE\n endif\n \n %.cpp.test: %.cpp\n-\t@echo Running tests: `cat $< | grep \"BOOST_FIXTURE_TEST_SUITE(\\|BOOST_AUTO_TEST_SUITE(\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1` from $<\n-\t$(AM_V_at)$(TEST_BINARY) -l test_suite -t \"`cat $< | grep \"BOOST_FIXTURE_TEST_SUITE(\\|BOOST_AUTO_TEST_SUITE(\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1`\" > $<.log 2>&1 || (cat $<.log && false)\n+\t@echo Running tests: `cat $< | grep -E \"(BOOST_FIXTURE_TEST_SUITE\\\\(|BOOST_AUTO_TEST_SUITE\\\\()\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1` from $<\n+\t$(AM_V_at)$(TEST_BINARY) -l test_suite -t \"`cat $< | grep -E \"(BOOST_FIXTURE_TEST_SUITE\\\\(|BOOST_AUTO_TEST_SUITE\\\\()\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1`\" > $<.log 2>&1 || (cat $<.log && false)\n \n %.json.h: %.json\n \t@$(MKDIR_P) $(@D)"
      },
      {
        "sha": "e4c7575e2d18dc8b19dc296b873243ba48307cd2",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -64,14 +64,6 @@ class base_uint\n \n     explicit base_uint(const std::string& str);\n \n-    bool operator!() const\n-    {\n-        for (int i = 0; i < WIDTH; i++)\n-            if (pn[i] != 0)\n-                return false;\n-        return true;\n-    }\n-\n     const base_uint operator~() const\n     {\n         base_uint ret;"
      },
      {
        "sha": "f3302bfe5adf5e1706f94679e5c73d345c955aa1",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 19,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,11 +6,10 @@\n \n #include <crypto/sha256.h>\n #include <key.h>\n-#include <validation.h>\n-#include <util.h>\n #include <random.h>\n-\n-#include <boost/lexical_cast.hpp>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <validation.h>\n \n #include <memory>\n \n@@ -24,27 +23,34 @@ static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n static void SetupBenchArgs()\n {\n-    gArgs.AddArg(\"-?\", _(\"Print this help message and exit\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-list\", _(\"List benchmarks without executing them. Can be combined with -scaling and -filter\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-evals=<n>\", strprintf(_(\"Number of measurement evaluations to perform. (default: %u)\"), DEFAULT_BENCH_EVALUATIONS), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-filter=<regex>\", strprintf(_(\"Regular expression filter to select benchmark by name (default: %s)\"), DEFAULT_BENCH_FILTER), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-scaling=<n>\", strprintf(_(\"Scaling factor for benchmark's runtime (default: %u)\"), DEFAULT_BENCH_SCALING), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-printer=(console|plot)\", strprintf(_(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\"), DEFAULT_BENCH_PRINTER), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(_(\"URL to use for plotly.js (default: %s)\"), DEFAULT_PLOT_PLOTLYURL), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-width=<x>\", strprintf(_(\"Plot width in pixel (default: %u)\"), DEFAULT_PLOT_WIDTH), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-height=<x>\", strprintf(_(\"Plot height in pixel (default: %u)\"), DEFAULT_PLOT_HEIGHT), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-?\", \"Print this help message and exit\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-evals=<n>\", strprintf(\"Number of measurement evaluations to perform. (default: %u)\", DEFAULT_BENCH_EVALUATIONS), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-scaling=<n>\", strprintf(\"Scaling factor for benchmark's runtime (default: %u)\", DEFAULT_BENCH_SCALING), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-printer=(console|plot)\", strprintf(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\", DEFAULT_BENCH_PRINTER), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(\"URL to use for plotly.js (default: %s)\", DEFAULT_PLOT_PLOTLYURL), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-width=<x>\", strprintf(\"Plot width in pixel (default: %u)\", DEFAULT_PLOT_WIDTH), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-height=<x>\", strprintf(\"Plot height in pixel (default: %u)\", DEFAULT_PLOT_HEIGHT), false, OptionsCategory::OPTIONS);\n+\n+    // Hidden\n+    gArgs.AddArg(\"-h\", \"\", false, OptionsCategory::HIDDEN);\n+    gArgs.AddArg(\"-help\", \"\", false, OptionsCategory::HIDDEN);\n }\n \n-int\n-main(int argc, char** argv)\n+int main(int argc, char** argv)\n {\n     SetupBenchArgs();\n-    gArgs.ParseParameters(argc, argv);\n+    std::string error;\n+    if (!gArgs.ParseParameters(argc, argv, error)) {\n+        fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n+        return EXIT_FAILURE;\n+    }\n \n     if (HelpRequested(gArgs)) {\n         std::cout << gArgs.GetHelpMessage();\n \n-        return 0;\n+        return EXIT_SUCCESS;\n     }\n \n     SHA256AutoDetect();\n@@ -57,8 +63,11 @@ main(int argc, char** argv)\n     std::string scaling_str = gArgs.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);\n     bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n \n-    double scaling_factor = boost::lexical_cast<double>(scaling_str);\n-\n+    double scaling_factor;\n+    if (!ParseDouble(scaling_str, &scaling_factor)) {\n+        fprintf(stderr, \"Error parsing scaling factor as double: %s\\n\", scaling_str.c_str());\n+        return EXIT_FAILURE;\n+    }\n \n     std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());\n     std::string printer_arg = gArgs.GetArg(\"-printer\", DEFAULT_BENCH_PRINTER);\n@@ -72,4 +81,6 @@ main(int argc, char** argv)\n     benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n \n     ECC_Stop();\n+\n+    return EXIT_SUCCESS;\n }"
      },
      {
        "sha": "36fa175a760220cc85923f1211fe0c1cccd897a5",
        "filename": "src/bench/block_assemble.cpp",
        "status": "added",
        "additions": 116,
        "deletions": 0,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2011-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <consensus/merkle.h>\n+#include <consensus/validation.h>\n+#include <miner.h>\n+#include <policy/policy.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <txdb.h>\n+#include <txmempool.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <boost/thread.hpp>\n+\n+#include <list>\n+#include <vector>\n+\n+static std::shared_ptr<CBlock> PrepareBlock(const CScript& coinbase_scriptPubKey)\n+{\n+    auto block = std::make_shared<CBlock>(\n+        BlockAssembler{Params()}\n+            .CreateNewBlock(coinbase_scriptPubKey, /* fMineWitnessTx */ true)\n+            ->block);\n+\n+    block->nTime = ::chainActive.Tip()->GetMedianTimePast() + 1;\n+    block->hashMerkleRoot = BlockMerkleRoot(*block);\n+\n+    return block;\n+}\n+\n+\n+static CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n+{\n+    auto block = PrepareBlock(coinbase_scriptPubKey);\n+\n+    while (!CheckProofOfWork(block->GetHash(), block->nBits, Params().GetConsensus())) {\n+        assert(++block->nNonce);\n+    }\n+\n+    bool processed{ProcessNewBlock(Params(), block, true, nullptr)};\n+    assert(processed);\n+\n+    return CTxIn{block->vtx[0]->GetHash(), 0};\n+}\n+\n+\n+static void AssembleBlock(benchmark::State& state)\n+{\n+    const std::vector<unsigned char> op_true{OP_TRUE};\n+    CScriptWitness witness;\n+    witness.stack.push_back(op_true);\n+\n+    uint256 witness_program;\n+    CSHA256().Write(&op_true[0], op_true.size()).Finalize(witness_program.begin());\n+\n+    const CScript SCRIPT_PUB{CScript(OP_0) << std::vector<unsigned char>{witness_program.begin(), witness_program.end()}};\n+\n+    // Switch to regtest so we can mine faster\n+    // Also segwit is active, so we can include witness transactions\n+    SelectParams(CBaseChainParams::REGTEST);\n+\n+    InitScriptExecutionCache();\n+\n+    boost::thread_group thread_group;\n+    CScheduler scheduler;\n+    {\n+        ::pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+        ::pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n+        ::pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+\n+        const CChainParams& chainparams = Params();\n+        thread_group.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n+        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+        LoadGenesisBlock(chainparams);\n+        CValidationState state;\n+        ActivateBestChain(state, chainparams);\n+        assert(::chainActive.Tip() != nullptr);\n+        const bool witness_enabled{IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())};\n+        assert(witness_enabled);\n+    }\n+\n+    // Collect some loose transactions that spend the coinbases of our mined blocks\n+    constexpr size_t NUM_BLOCKS{200};\n+    std::array<CTransactionRef, NUM_BLOCKS - COINBASE_MATURITY + 1> txs;\n+    for (size_t b{0}; b < NUM_BLOCKS; ++b) {\n+        CMutableTransaction tx;\n+        tx.vin.push_back(MineBlock(SCRIPT_PUB));\n+        tx.vin.back().scriptWitness = witness;\n+        tx.vout.emplace_back(1337, SCRIPT_PUB);\n+        if (NUM_BLOCKS - b >= COINBASE_MATURITY)\n+            txs.at(b) = MakeTransactionRef(tx);\n+    }\n+    for (const auto& txr : txs) {\n+        CValidationState state;\n+        bool ret{::AcceptToMemoryPool(::mempool, state, txr, nullptr /* pfMissingInputs */, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)};\n+        assert(ret);\n+    }\n+\n+    while (state.KeepRunning()) {\n+        PrepareBlock(SCRIPT_PUB);\n+    }\n+\n+    thread_group.interrupt_all();\n+    thread_group.join_all();\n+    GetMainSignals().FlushBackgroundCallbacks();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n+}\n+\n+BENCHMARK(AssembleBlock, 700);"
      },
      {
        "sha": "f3180809b5ee755e5486f1f7a5a6d8c7a7adc0c3",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -34,31 +34,25 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<CO\n static void CoinSelection(benchmark::State& state)\n {\n     const CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n-    std::vector<COutput> vCoins;\n     LOCK(wallet.cs_wallet);\n \n-    while (state.KeepRunning()) {\n-        // Add coins.\n-        for (int i = 0; i < 1000; i++)\n-            addCoin(1000 * COIN, wallet, vCoins);\n-        addCoin(3 * COIN, wallet, vCoins);\n+    // Add coins.\n+    std::vector<COutput> vCoins;\n+    for (int i = 0; i < 1000; ++i) {\n+        addCoin(1000 * COIN, wallet, vCoins);\n+    }\n+    addCoin(3 * COIN, wallet, vCoins);\n \n+    const CoinEligibilityFilter filter_standard(1, 6, 0);\n+    const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n+    while (state.KeepRunning()) {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n-        CoinEligibilityFilter filter_standard(1, 6, 0);\n-        CoinSelectionParams coin_selection_params(false, 34, 148, CFeeRate(0), 0);\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)\n-                       || wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n-\n-        // Empty wallet.\n-        for (COutput& output : vCoins) {\n-            delete output.tx;\n-        }\n-        vCoins.clear();\n     }\n }\n "
      },
      {
        "sha": "7d907eaf10bde8653a39e1f5fc1ab0c8fb186f6e",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -52,6 +52,14 @@ static void SHA256_32b(benchmark::State& state)\n     }\n }\n \n+static void SHA256D64_1024(benchmark::State& state)\n+{\n+    std::vector<uint8_t> in(64 * 1024, 0);\n+    while (state.KeepRunning()) {\n+        SHA256D64(in.data(), in.data(), 1024);\n+    }\n+}\n+\n static void SHA512(benchmark::State& state)\n {\n     uint8_t hash[CSHA512::OUTPUT_SIZE];\n@@ -94,5 +102,6 @@ BENCHMARK(SHA512, 330);\n \n BENCHMARK(SHA256_32b, 4700 * 1000);\n BENCHMARK(SipHash_32b, 40 * 1000 * 1000);\n+BENCHMARK(SHA256D64_1024, 7400);\n BENCHMARK(FastRandom_32bit, 110 * 1000 * 1000);\n BENCHMARK(FastRandom_1bit, 440 * 1000 * 1000);"
      },
      {
        "sha": "b68c9cd1564d3f00d8931e53e2a42801a672f961",
        "filename": "src/bench/examples.cpp",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "previous_filename": "src/bench/Examples.cpp"
      },
      {
        "sha": "fab12da311c5eb720149a63fe0f6b319490eeeea",
        "filename": "src/bench/merkle_root.cpp",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/merkle_root.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bench/merkle_root.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/merkle_root.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <uint256.h>\n+#include <random.h>\n+#include <consensus/merkle.h>\n+\n+static void MerkleRoot(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    std::vector<uint256> leaves;\n+    leaves.resize(9001);\n+    for (auto& item : leaves) {\n+        item = rng.rand256();\n+    }\n+    while (state.KeepRunning()) {\n+        bool mutation = false;\n+        uint256 hash = ComputeMerkleRoot(std::vector<uint256>(leaves), &mutation);\n+        leaves[mutation] = hash;\n+    }\n+}\n+\n+BENCHMARK(MerkleRoot, 800);"
      },
      {
        "sha": "b332b5e5814c6e06baa146efdbd121fba741121f",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 26,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -34,21 +34,38 @@ static void SetupCliArgs()\n     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n     const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n \n-    gArgs.AddArg(\"-?\", _(\"This help message\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-datadir=<dir>\", _(\"Specify data directory\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-getinfo\", _(\"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-?\", \"This help message\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-conf=<file>\", strprintf(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\", BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-datadir=<dir>\", \"Specify data directory\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-getinfo\", \"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\", false, OptionsCategory::OPTIONS);\n     SetupChainParamsBaseOptions();\n-    gArgs.AddArg(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcwait\", _(\"Wait for RPC server to start\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-stdinrpcpass\", strprintf(_(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\")), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-named\", strprintf(\"Pass named instead of positional arguments (default: %s)\", DEFAULT_NAMED), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcclienttimeout=<n>\", strprintf(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\", DEFAULT_HTTP_CLIENT_TIMEOUT), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcconnect=<ip>\", strprintf(\"Send commands to node running on <ip> (default: %s)\", DEFAULT_RPCCONNECT), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpccookiefile=<loc>\", _(\"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcpassword=<pw>\", \"Password for JSON-RPC connections\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcport=<port>\", strprintf(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcuser=<user>\", \"Username for JSON-RPC connections\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcwait\", \"Wait for RPC server to start\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcwallet=<walletname>\", \"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-stdin\", \"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-stdinrpcpass\", strprintf(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\"), false, OptionsCategory::OPTIONS);\n+\n+    // Hidden\n+    gArgs.AddArg(\"-h\", \"\", false, OptionsCategory::HIDDEN);\n+    gArgs.AddArg(\"-help\", \"\", false, OptionsCategory::HIDDEN);\n+}\n+\n+/** libevent event log callback */\n+static void libevent_log_cb(int severity, const char *msg)\n+{\n+#ifndef EVENT_LOG_ERR // EVENT_LOG_ERR was added in 2.0.19; but before then _EVENT_LOG_ERR existed.\n+# define EVENT_LOG_ERR _EVENT_LOG_ERR\n+#endif\n+    // Ignore everything other than errors\n+    if (severity >= EVENT_LOG_ERR) {\n+        throw std::runtime_error(strprintf(\"libevent error: %s\", msg));\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -80,15 +97,19 @@ static int AppInitRPC(int argc, char* argv[])\n     // Parameters\n     //\n     SetupCliArgs();\n-    gArgs.ParseParameters(argc, argv);\n+    std::string error;\n+    if (!gArgs.ParseParameters(argc, argv, error)) {\n+        fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n+        return EXIT_FAILURE;\n+    }\n     if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n-        std::string strUsage = strprintf(_(\"%s RPC client version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\";\n+        std::string strUsage = strprintf(\"%s RPC client version\", PACKAGE_NAME) + \" \" + FormatFullVersion() + \"\\n\";\n         if (!gArgs.IsArgSet(\"-version\")) {\n-            strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] <command> [params]  \" + strprintf(_(\"Send command to %s\"), _(PACKAGE_NAME)) + \"\\n\" +\n-                  \"  bitcoin-cli [options] -named <command> [name=value] ... \" + strprintf(_(\"Send command to %s (with named arguments)\"), _(PACKAGE_NAME)) + \"\\n\" +\n-                  \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+            strUsage += \"\\nUsage:\\n\"\n+                  \"  bitcoin-cli [options] <command> [params]  \" + strprintf(\"Send command to %s\", PACKAGE_NAME) + \"\\n\" +\n+                  \"  bitcoin-cli [options] -named <command> [name=value] ... \" + strprintf(\"Send command to %s (with named arguments)\", PACKAGE_NAME) + \"\\n\" +\n+                  \"  bitcoin-cli [options] help                List commands\\n\" +\n+                  \"  bitcoin-cli [options] help <command>      Get help for a command\\n\";\n \n             strUsage += \"\\n\" + gArgs.GetHelpMessage();\n         }\n@@ -104,10 +125,8 @@ static int AppInitRPC(int argc, char* argv[])\n         fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n         return EXIT_FAILURE;\n     }\n-    try {\n-        gArgs.ReadConfigFiles();\n-    } catch (const std::exception& e) {\n-        fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+    if (!gArgs.ReadConfigFiles(error, true)) {\n+        fprintf(stderr, \"Error reading configuration file: %s\\n\", error.c_str());\n         return EXIT_FAILURE;\n     }\n     // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n@@ -364,7 +383,7 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n     } else if (response.status == HTTP_UNAUTHORIZED) {\n         if (failedToGetAuthCookie) {\n             throw std::runtime_error(strprintf(\n-                _(\"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\"),\n+                \"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\",\n                 GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string().c_str()));\n         } else {\n             throw std::runtime_error(\"Authorization failed: Incorrect rpcuser or rpcpassword\");\n@@ -499,6 +518,7 @@ int main(int argc, char* argv[])\n         fprintf(stderr, \"Error: Initializing networking failed\\n\");\n         return EXIT_FAILURE;\n     }\n+    event_set_log_callback(&libevent_log_cb);\n \n     try {\n         int ret = AppInitRPC(argc, argv);"
      },
      {
        "sha": "e6eb723cf4aa1555850d01002a0e73e85d9a4f26",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 37,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -33,37 +33,41 @@ static const int CONTINUE_EXECUTION=-1;\n \n static void SetupBitcoinTxArgs()\n {\n-    gArgs.AddArg(\"-?\", _(\"This help message\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-create\", _(\"Create new, empty TX.\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-json\", _(\"Select JSON output\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-txid\", _(\"Output only the hex-encoded transaction id of the resultant transaction.\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-?\", \"This help message\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-create\", \"Create new, empty TX.\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-json\", \"Select JSON output\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-txid\", \"Output only the hex-encoded transaction id of the resultant transaction.\", false, OptionsCategory::OPTIONS);\n     SetupChainParamsBaseOptions();\n \n-    gArgs.AddArg(\"delin=N\", _(\"Delete input N from TX\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"delout=N\", _(\"Delete output N from TX\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"locktime=N\", _(\"Set TX lock time to N\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"nversion=N\", _(\"Set TX version to N\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"outdata=[VALUE:]DATA\", _(\"Add data-based output to TX\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\", _(\"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS\") + \". \" +\n-        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n-        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n-        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n-        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"outscript=VALUE:SCRIPT[:FLAGS]\", _(\"Add raw script output to TX\") + \". \" +\n-        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n-        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"), false, OptionsCategory::COMMANDS);\n-    gArgs.AddArg(\"sign=SIGHASH-FLAGS\", _(\"Add zero or more signatures to transaction\") + \". \" +\n-        _(\"This command requires JSON registers:\") +\n-        _(\"prevtxs=JSON object\") + \", \" +\n-        _(\"privatekeys=JSON object\") + \". \" +\n-        _(\"See signrawtransaction docs for format of sighash flags, JSON objects.\"), false, OptionsCategory::COMMANDS);\n-\n-    gArgs.AddArg(\"load=NAME:FILENAME\", _(\"Load JSON file FILENAME into register NAME\"), false, OptionsCategory::REGISTER_COMMANDS);\n-    gArgs.AddArg(\"set=NAME:JSON-STRING\", _(\"Set register NAME to given JSON-STRING\"), false, OptionsCategory::REGISTER_COMMANDS);\n+    gArgs.AddArg(\"delin=N\", \"Delete input N from TX\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"delout=N\", \"Delete output N from TX\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", \"Add input to TX\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"locktime=N\", \"Set TX lock time to N\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"nversion=N\", \"Set TX version to N\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outaddr=VALUE:ADDRESS\", \"Add address-based output to TX\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outdata=[VALUE:]DATA\", \"Add data-based output to TX\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\", \"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS. \"\n+        \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output. \"\n+        \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", \"Add pay-to-pubkey output to TX. \"\n+        \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output. \"\n+        \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outscript=VALUE:SCRIPT[:FLAGS]\", \"Add raw script output to TX. \"\n+        \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output. \"\n+        \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"replaceable(=N)\", \"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\", false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"sign=SIGHASH-FLAGS\", \"Add zero or more signatures to transaction. \"\n+        \"This command requires JSON registers:\"\n+        \"prevtxs=JSON object, \"\n+        \"privatekeys=JSON object. \"\n+        \"See signrawtransaction docs for format of sighash flags, JSON objects.\", false, OptionsCategory::COMMANDS);\n+\n+    gArgs.AddArg(\"load=NAME:FILENAME\", \"Load JSON file FILENAME into register NAME\", false, OptionsCategory::REGISTER_COMMANDS);\n+    gArgs.AddArg(\"set=NAME:JSON-STRING\", \"Set register NAME to given JSON-STRING\", false, OptionsCategory::REGISTER_COMMANDS);\n+\n+    // Hidden\n+    gArgs.AddArg(\"-h\", \"\", false, OptionsCategory::HIDDEN);\n+    gArgs.AddArg(\"-help\", \"\", false, OptionsCategory::HIDDEN);\n }\n \n //\n@@ -76,7 +80,11 @@ static int AppInitRawTx(int argc, char* argv[])\n     // Parameters\n     //\n     SetupBitcoinTxArgs();\n-    gArgs.ParseParameters(argc, argv);\n+    std::string error;\n+    if (!gArgs.ParseParameters(argc, argv, error)) {\n+        fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n+        return EXIT_FAILURE;\n+    }\n \n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n     try {\n@@ -90,10 +98,10 @@ static int AppInitRawTx(int argc, char* argv[])\n \n     if (argc < 2 || HelpRequested(gArgs)) {\n         // First part of help message is specific to this utility\n-        std::string strUsage = strprintf(_(\"%s bitcoin-tx utility version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-            _(\"Usage:\") + \"\\n\" +\n-              \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n+        std::string strUsage = strprintf(\"%s bitcoin-tx utility version\", PACKAGE_NAME) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+            \"Usage:\\n\"\n+              \"  bitcoin-tx [options] <hex-tx> [commands]  Update hex-encoded bitcoin transaction\\n\" +\n+              \"  bitcoin-tx [options] -create [commands]   Create hex-encoded bitcoin transaction\\n\" +\n               \"\\n\";\n         strUsage += gArgs.GetHelpMessage();\n \n@@ -583,7 +591,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (!prevOut.checkObject(types))\n                 throw std::runtime_error(\"prevtxs internal object typecheck fail\");\n \n-            uint256 txid = ParseHashUV(prevOut[\"txid\"], \"txid\");\n+            uint256 txid = ParseHashStr(prevOut[\"txid\"].get_str(), \"txid\");\n \n             int nOut = atoi(prevOut[\"vout\"].getValStr());\n             if (nOut < 0)\n@@ -629,7 +637,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n \n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n-        const CTxIn& txin = mergedTx.vin[i];\n+        CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n         if (coin.IsSpent()) {\n             continue;\n@@ -644,7 +652,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n \n         // ... and merge in other signatures:\n         sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n-        UpdateTransaction(mergedTx, i, sigdata);\n+        UpdateInput(txin, sigdata);\n     }\n \n     tx = mergedTx;"
      },
      {
        "sha": "4b9abb2a1ba88826dede21cffd2a9d902c91b641",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -62,23 +62,24 @@ static bool AppInit(int argc, char* argv[])\n     //\n     // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n     SetupServerArgs();\n-#if HAVE_DECL_DAEMON\n-    gArgs.AddArg(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"), false, OptionsCategory::OPTIONS);\n-#endif\n-    gArgs.ParseParameters(argc, argv);\n+    std::string error;\n+    if (!gArgs.ParseParameters(argc, argv, error)) {\n+        fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n+        return false;\n+    }\n \n     // Process help and version before taking care about datadir\n     if (HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n-        std::string strUsage = strprintf(_(\"%s Daemon\"), _(PACKAGE_NAME)) + \" \" + _(\"version\") + \" \" + FormatFullVersion() + \"\\n\";\n+        std::string strUsage = strprintf(\"%s Daemon\", PACKAGE_NAME) + \" version \" + FormatFullVersion() + \"\\n\";\n \n         if (gArgs.IsArgSet(\"-version\"))\n         {\n             strUsage += FormatParagraph(LicenseInfo());\n         }\n         else\n         {\n-            strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n+            strUsage += \"\\nUsage:\\n\"\n+                  \"  bitcoind [options]                     \" + strprintf(\"Start %s Daemon\", PACKAGE_NAME) + \"\\n\";\n \n             strUsage += \"\\n\" + gArgs.GetHelpMessage();\n         }\n@@ -94,11 +95,8 @@ static bool AppInit(int argc, char* argv[])\n             fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n             return false;\n         }\n-        try\n-        {\n-            gArgs.ReadConfigFiles();\n-        } catch (const std::exception& e) {\n-            fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+        if (!gArgs.ReadConfigFiles(error)) {\n+            fprintf(stderr, \"Error reading configuration file: %s\\n\", error.c_str());\n             return false;\n         }\n         // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)"
      },
      {
        "sha": "787d8d8f6aa3fff62b9929f96ac75762d2500891",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -18,7 +18,7 @@ void SetupChainParamsBaseOptions()\n {\n     gArgs.AddArg(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n                                    \"This is intended for regression testing tools and app development.\", true, OptionsCategory::CHAINPARAMS);\n-    gArgs.AddArg(\"-testnet\", _(\"Use the test chain\"), false, OptionsCategory::CHAINPARAMS);\n+    gArgs.AddArg(\"-testnet\", \"Use the test chain\", false, OptionsCategory::CHAINPARAMS);\n }\n \n static std::unique_ptr<CBaseChainParams> globalChainBaseParams;"
      },
      {
        "sha": "07cd109cc18bf95d1a4f20b253a14f116d520baf",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 117,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -42,118 +42,26 @@\n        root.\n */\n \n-/* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */\n-static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch) {\n-    if (pbranch) pbranch->clear();\n-    if (leaves.size() == 0) {\n-        if (pmutated) *pmutated = false;\n-        if (proot) *proot = uint256();\n-        return;\n-    }\n-    bool mutated = false;\n-    // count is the number of leaves processed so far.\n-    uint32_t count = 0;\n-    // inner is an array of eagerly computed subtree hashes, indexed by tree\n-    // level (0 being the leaves).\n-    // For example, when count is 25 (11001 in binary), inner[4] is the hash of\n-    // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to\n-    // the last leaf. The other inner entries are undefined.\n-    uint256 inner[32];\n-    // Which position in inner is a hash that depends on the matching leaf.\n-    int matchlevel = -1;\n-    // First process all leaves into 'inner' values.\n-    while (count < leaves.size()) {\n-        uint256 h = leaves[count];\n-        bool matchh = count == branchpos;\n-        count++;\n-        int level;\n-        // For each of the lower bits in count that are 0, do 1 step. Each\n-        // corresponds to an inner value that existed before processing the\n-        // current leaf, and each needs a hash to combine it.\n-        for (level = 0; !(count & (((uint32_t)1) << level)); level++) {\n-            if (pbranch) {\n-                if (matchh) {\n-                    pbranch->push_back(inner[level]);\n-                } else if (matchlevel == level) {\n-                    pbranch->push_back(h);\n-                    matchh = true;\n-                }\n+\n+uint256 ComputeMerkleRoot(std::vector<uint256> hashes, bool* mutated) {\n+    bool mutation = false;\n+    while (hashes.size() > 1) {\n+        if (mutated) {\n+            for (size_t pos = 0; pos + 1 < hashes.size(); pos += 2) {\n+                if (hashes[pos] == hashes[pos + 1]) mutation = true;\n             }\n-            mutated |= (inner[level] == h);\n-            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n         }\n-        // Store the resulting hash at inner position level.\n-        inner[level] = h;\n-        if (matchh) {\n-            matchlevel = level;\n+        if (hashes.size() & 1) {\n+            hashes.push_back(hashes.back());\n         }\n+        SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2);\n+        hashes.resize(hashes.size() / 2);\n     }\n-    // Do a final 'sweep' over the rightmost branch of the tree to process\n-    // odd levels, and reduce everything to a single top value.\n-    // Level is the level (counted from the bottom) up to which we've sweeped.\n-    int level = 0;\n-    // As long as bit number level in count is zero, skip it. It means there\n-    // is nothing left at this level.\n-    while (!(count & (((uint32_t)1) << level))) {\n-        level++;\n-    }\n-    uint256 h = inner[level];\n-    bool matchh = matchlevel == level;\n-    while (count != (((uint32_t)1) << level)) {\n-        // If we reach this point, h is an inner value that is not the top.\n-        // We combine it with itself (Bitcoin's special rule for odd levels in\n-        // the tree) to produce a higher level one.\n-        if (pbranch && matchh) {\n-            pbranch->push_back(h);\n-        }\n-        CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n-        // Increment count to the value it would have if two entries at this\n-        // level had existed.\n-        count += (((uint32_t)1) << level);\n-        level++;\n-        // And propagate the result upwards accordingly.\n-        while (!(count & (((uint32_t)1) << level))) {\n-            if (pbranch) {\n-                if (matchh) {\n-                    pbranch->push_back(inner[level]);\n-                } else if (matchlevel == level) {\n-                    pbranch->push_back(h);\n-                    matchh = true;\n-                }\n-            }\n-            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n-            level++;\n-        }\n-    }\n-    // Return result.\n-    if (pmutated) *pmutated = mutated;\n-    if (proot) *proot = h;\n+    if (mutated) *mutated = mutation;\n+    if (hashes.size() == 0) return uint256();\n+    return hashes[0];\n }\n \n-uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated) {\n-    uint256 hash;\n-    MerkleComputation(leaves, &hash, mutated, -1, nullptr);\n-    return hash;\n-}\n-\n-std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n-    std::vector<uint256> ret;\n-    MerkleComputation(leaves, nullptr, nullptr, position, &ret);\n-    return ret;\n-}\n-\n-uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& vMerkleBranch, uint32_t nIndex) {\n-    uint256 hash = leaf;\n-    for (std::vector<uint256>::const_iterator it = vMerkleBranch.begin(); it != vMerkleBranch.end(); ++it) {\n-        if (nIndex & 1) {\n-            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));\n-        } else {\n-            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));\n-        }\n-        nIndex >>= 1;\n-    }\n-    return hash;\n-}\n \n uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n {\n@@ -162,7 +70,7 @@ uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n     for (size_t s = 0; s < block.vtx.size(); s++) {\n         leaves[s] = block.vtx[s]->GetHash();\n     }\n-    return ComputeMerkleRoot(leaves, mutated);\n+    return ComputeMerkleRoot(std::move(leaves), mutated);\n }\n \n uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated)\n@@ -173,15 +81,6 @@ uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated)\n     for (size_t s = 1; s < block.vtx.size(); s++) {\n         leaves[s] = block.vtx[s]->GetWitnessHash();\n     }\n-    return ComputeMerkleRoot(leaves, mutated);\n+    return ComputeMerkleRoot(std::move(leaves), mutated);\n }\n \n-std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n-{\n-    std::vector<uint256> leaves;\n-    leaves.resize(block.vtx.size());\n-    for (size_t s = 0; s < block.vtx.size(); s++) {\n-        leaves[s] = block.vtx[s]->GetHash();\n-    }\n-    return ComputeMerkleBranch(leaves, position);\n-}"
      },
      {
        "sha": "01d75b132977428d94d36b1f87b074e3fc46b670",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -12,9 +12,7 @@\n #include <primitives/block.h>\n #include <uint256.h>\n \n-uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = nullptr);\n-std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n-uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t position);\n+uint256 ComputeMerkleRoot(std::vector<uint256> hashes, bool* mutated = nullptr);\n \n /*\n  * Compute the Merkle root of the transactions in a block.\n@@ -28,11 +26,4 @@ uint256 BlockMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n  */\n uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n \n-/*\n- * Compute the Merkle branch for the tree of transactions in a block, for a\n- * given position.\n- * This can be verified using ComputeMerkleRootFromBranch.\n- */\n-std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n-\n #endif // BITCOIN_CONSENSUS_MERKLE_H"
      },
      {
        "sha": "1d87d21d4087ee82b48ad587a81c3741845cc1a6",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -22,7 +22,6 @@ CScript ParseScript(const std::string& s);\n std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode = false);\n bool DecodeHexTx(CMutableTransaction& tx, const std::string& hex_tx, bool try_no_witness = false, bool try_witness = true);\n bool DecodeHexBlk(CBlock&, const std::string& strHexBlk);\n-uint256 ParseHashUV(const UniValue& v, const std::string& strName);\n uint256 ParseHashStr(const std::string&, const std::string& strName);\n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName);\n "
      },
      {
        "sha": "4d851610efb46e65110c94355dbf599b2024617b",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -160,14 +160,6 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n-uint256 ParseHashUV(const UniValue& v, const std::string& strName)\n-{\n-    std::string strHex;\n-    if (v.isStr())\n-        strHex = v.getValStr();\n-    return ParseHashStr(strHex, strName);  // Note: ParseHashStr(\"\") throws a runtime_error\n-}\n-\n uint256 ParseHashStr(const std::string& strHex, const std::string& strName)\n {\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false"
      },
      {
        "sha": "e62ddc125ec33a4bd4e257002ab7eac50bb9fb98",
        "filename": "src/crypto/sha256.cpp",
        "status": "modified",
        "additions": 518,
        "deletions": 99,
        "changes": 617,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -19,6 +19,16 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n #endif\n #endif\n \n+namespace sha256d64_sse41\n+{\n+void Transform_4way(unsigned char* out, const unsigned char* in);\n+}\n+\n+namespace sha256d64_avx2\n+{\n+void Transform_8way(unsigned char* out, const unsigned char* in);\n+}\n+\n // Internal implementation code.\n namespace\n {\n@@ -33,9 +43,9 @@ uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x <<\n uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n \n /** One round of SHA-256. */\n-void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k, uint32_t w)\n+void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k)\n {\n-    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n+    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k;\n     uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n     d += t1;\n     h = t1 + t2;\n@@ -61,73 +71,73 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n         uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n         uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n-        Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n-        Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n-        Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n-        Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n-        Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n-        Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n-        Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n-        Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n-        Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n-        Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n-        Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n-        Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n-        Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n-        Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n-        Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n-        Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n-\n-        Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));\n-        Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));\n-        Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));\n-        Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));\n-        Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));\n-        Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));\n-        Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));\n-        Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));\n-        Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));\n-        Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));\n-        Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));\n-        Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));\n-        Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n-        Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n-        Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n-        Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-        Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));\n-        Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));\n-        Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));\n-        Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));\n-        Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));\n-        Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));\n-        Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));\n-        Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));\n-        Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));\n-        Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));\n-        Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));\n-        Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));\n-        Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n-        Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n-        Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n-        Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-        Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));\n-        Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));\n-        Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));\n-        Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));\n-        Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));\n-        Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));\n-        Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));\n-        Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));\n-        Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));\n-        Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));\n-        Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));\n-        Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));\n-        Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n-        Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n-        Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n-        Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));\n+        Round(a, b, c, d, e, f, g, h, 0x428a2f98 + (w0 = ReadBE32(chunk + 0)));\n+        Round(h, a, b, c, d, e, f, g, 0x71374491 + (w1 = ReadBE32(chunk + 4)));\n+        Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf + (w2 = ReadBE32(chunk + 8)));\n+        Round(f, g, h, a, b, c, d, e, 0xe9b5dba5 + (w3 = ReadBE32(chunk + 12)));\n+        Round(e, f, g, h, a, b, c, d, 0x3956c25b + (w4 = ReadBE32(chunk + 16)));\n+        Round(d, e, f, g, h, a, b, c, 0x59f111f1 + (w5 = ReadBE32(chunk + 20)));\n+        Round(c, d, e, f, g, h, a, b, 0x923f82a4 + (w6 = ReadBE32(chunk + 24)));\n+        Round(b, c, d, e, f, g, h, a, 0xab1c5ed5 + (w7 = ReadBE32(chunk + 28)));\n+        Round(a, b, c, d, e, f, g, h, 0xd807aa98 + (w8 = ReadBE32(chunk + 32)));\n+        Round(h, a, b, c, d, e, f, g, 0x12835b01 + (w9 = ReadBE32(chunk + 36)));\n+        Round(g, h, a, b, c, d, e, f, 0x243185be + (w10 = ReadBE32(chunk + 40)));\n+        Round(f, g, h, a, b, c, d, e, 0x550c7dc3 + (w11 = ReadBE32(chunk + 44)));\n+        Round(e, f, g, h, a, b, c, d, 0x72be5d74 + (w12 = ReadBE32(chunk + 48)));\n+        Round(d, e, f, g, h, a, b, c, 0x80deb1fe + (w13 = ReadBE32(chunk + 52)));\n+        Round(c, d, e, f, g, h, a, b, 0x9bdc06a7 + (w14 = ReadBE32(chunk + 56)));\n+        Round(b, c, d, e, f, g, h, a, 0xc19bf174 + (w15 = ReadBE32(chunk + 60)));\n+\n+        Round(a, b, c, d, e, f, g, h, 0xe49b69c1 + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+        Round(h, a, b, c, d, e, f, g, 0xefbe4786 + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+        Round(g, h, a, b, c, d, e, f, 0x0fc19dc6 + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+        Round(f, g, h, a, b, c, d, e, 0x240ca1cc + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+        Round(e, f, g, h, a, b, c, d, 0x2de92c6f + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+        Round(d, e, f, g, h, a, b, c, 0x4a7484aa + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+        Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+        Round(b, c, d, e, f, g, h, a, 0x76f988da + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+        Round(a, b, c, d, e, f, g, h, 0x983e5152 + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+        Round(h, a, b, c, d, e, f, g, 0xa831c66d + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+        Round(g, h, a, b, c, d, e, f, 0xb00327c8 + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+        Round(f, g, h, a, b, c, d, e, 0xbf597fc7 + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+        Round(e, f, g, h, a, b, c, d, 0xc6e00bf3 + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+        Round(d, e, f, g, h, a, b, c, 0xd5a79147 + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+        Round(c, d, e, f, g, h, a, b, 0x06ca6351 + (w14 += sigma1(w12) + w7 + sigma0(w15)));\n+        Round(b, c, d, e, f, g, h, a, 0x14292967 + (w15 += sigma1(w13) + w8 + sigma0(w0)));\n+\n+        Round(a, b, c, d, e, f, g, h, 0x27b70a85 + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+        Round(h, a, b, c, d, e, f, g, 0x2e1b2138 + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+        Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+        Round(f, g, h, a, b, c, d, e, 0x53380d13 + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+        Round(e, f, g, h, a, b, c, d, 0x650a7354 + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+        Round(d, e, f, g, h, a, b, c, 0x766a0abb + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+        Round(c, d, e, f, g, h, a, b, 0x81c2c92e + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+        Round(b, c, d, e, f, g, h, a, 0x92722c85 + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+        Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1 + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+        Round(h, a, b, c, d, e, f, g, 0xa81a664b + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+        Round(g, h, a, b, c, d, e, f, 0xc24b8b70 + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+        Round(f, g, h, a, b, c, d, e, 0xc76c51a3 + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+        Round(e, f, g, h, a, b, c, d, 0xd192e819 + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+        Round(d, e, f, g, h, a, b, c, 0xd6990624 + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+        Round(c, d, e, f, g, h, a, b, 0xf40e3585 + (w14 += sigma1(w12) + w7 + sigma0(w15)));\n+        Round(b, c, d, e, f, g, h, a, 0x106aa070 + (w15 += sigma1(w13) + w8 + sigma0(w0)));\n+\n+        Round(a, b, c, d, e, f, g, h, 0x19a4c116 + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+        Round(h, a, b, c, d, e, f, g, 0x1e376c08 + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+        Round(g, h, a, b, c, d, e, f, 0x2748774c + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+        Round(f, g, h, a, b, c, d, e, 0x34b0bcb5 + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+        Round(e, f, g, h, a, b, c, d, 0x391c0cb3 + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+        Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+        Round(c, d, e, f, g, h, a, b, 0x5b9cca4f + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+        Round(b, c, d, e, f, g, h, a, 0x682e6ff3 + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+        Round(a, b, c, d, e, f, g, h, 0x748f82ee + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+        Round(h, a, b, c, d, e, f, g, 0x78a5636f + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+        Round(g, h, a, b, c, d, e, f, 0x84c87814 + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+        Round(f, g, h, a, b, c, d, e, 0x8cc70208 + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+        Round(e, f, g, h, a, b, c, d, 0x90befffa + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+        Round(d, e, f, g, h, a, b, c, 0xa4506ceb + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+        Round(c, d, e, f, g, h, a, b, 0xbef9a3f7 + (w14 + sigma1(w12) + w7 + sigma0(w15)));\n+        Round(b, c, d, e, f, g, h, a, 0xc67178f2 + (w15 + sigma1(w13) + w8 + sigma0(w0)));\n \n         s[0] += a;\n         s[1] += b;\n@@ -141,54 +151,437 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n     }\n }\n \n+void TransformD64(unsigned char* out, const unsigned char* in)\n+{\n+    // Transform 1\n+    uint32_t a = 0x6a09e667ul;\n+    uint32_t b = 0xbb67ae85ul;\n+    uint32_t c = 0x3c6ef372ul;\n+    uint32_t d = 0xa54ff53aul;\n+    uint32_t e = 0x510e527ful;\n+    uint32_t f = 0x9b05688cul;\n+    uint32_t g = 0x1f83d9abul;\n+    uint32_t h = 0x5be0cd19ul;\n+\n+    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98ul + (w0 = ReadBE32(in + 0)));\n+    Round(h, a, b, c, d, e, f, g, 0x71374491ul + (w1 = ReadBE32(in + 4)));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcful + (w2 = ReadBE32(in + 8)));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5ul + (w3 = ReadBE32(in + 12)));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25bul + (w4 = ReadBE32(in + 16)));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1ul + (w5 = ReadBE32(in + 20)));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4ul + (w6 = ReadBE32(in + 24)));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5ul + (w7 = ReadBE32(in + 28)));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98ul + (w8 = ReadBE32(in + 32)));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01ul + (w9 = ReadBE32(in + 36)));\n+    Round(g, h, a, b, c, d, e, f, 0x243185beul + (w10 = ReadBE32(in + 40)));\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3ul + (w11 = ReadBE32(in + 44)));\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74ul + (w12 = ReadBE32(in + 48)));\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1feul + (w13 = ReadBE32(in + 52)));\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7ul + (w14 = ReadBE32(in + 56)));\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf174ul + (w15 = ReadBE32(in + 60)));\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c1ul + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786ul + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6ul + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1ccul + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6ful + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aaul + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcul + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988daul + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152ul + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66dul + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c8ul + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7ul + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3ul + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147ul + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351ul + (w14 += sigma1(w12) + w7 + sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, 0x14292967ul + (w15 += sigma1(w13) + w8 + sigma0(w0)));\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a85ul + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b2138ul + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfcul + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d13ul + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x650a7354ul + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abbul + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92eul + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c85ul + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1ul + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664bul + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70ul + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a3ul + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819ul + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+    Round(d, e, f, g, h, a, b, c, 0xd6990624ul + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e3585ul + (w14 += sigma1(w12) + w7 + sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa070ul + (w15 += sigma1(w13) + w8 + sigma0(w0)));\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116ul + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c08ul + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774cul + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5ul + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3ul + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4aul + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4ful + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3ul + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82eeul + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636ful + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814ul + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc70208ul + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffaul + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506cebul + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7ul + (w14 + sigma1(w12) + w7 + sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2ul + (w15 + sigma1(w13) + w8 + sigma0(w0)));\n+\n+    a += 0x6a09e667ul;\n+    b += 0xbb67ae85ul;\n+    c += 0x3c6ef372ul;\n+    d += 0xa54ff53aul;\n+    e += 0x510e527ful;\n+    f += 0x9b05688cul;\n+    g += 0x1f83d9abul;\n+    h += 0x5be0cd19ul;\n+\n+    uint32_t t0 = a, t1 = b, t2 = c, t3 = d, t4 = e, t5 = f, t6 = g, t7 = h;\n+\n+    // Transform 2\n+    Round(a, b, c, d, e, f, g, h, 0xc28a2f98ul);\n+    Round(h, a, b, c, d, e, f, g, 0x71374491ul);\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcful);\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5ul);\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25bul);\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1ul);\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4ul);\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5ul);\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98ul);\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01ul);\n+    Round(g, h, a, b, c, d, e, f, 0x243185beul);\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3ul);\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74ul);\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1feul);\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7ul);\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf374ul);\n+    Round(a, b, c, d, e, f, g, h, 0x649b69c1ul);\n+    Round(h, a, b, c, d, e, f, g, 0xf0fe4786ul);\n+    Round(g, h, a, b, c, d, e, f, 0x0fe1edc6ul);\n+    Round(f, g, h, a, b, c, d, e, 0x240cf254ul);\n+    Round(e, f, g, h, a, b, c, d, 0x4fe9346ful);\n+    Round(d, e, f, g, h, a, b, c, 0x6cc984beul);\n+    Round(c, d, e, f, g, h, a, b, 0x61b9411eul);\n+    Round(b, c, d, e, f, g, h, a, 0x16f988faul);\n+    Round(a, b, c, d, e, f, g, h, 0xf2c65152ul);\n+    Round(h, a, b, c, d, e, f, g, 0xa88e5a6dul);\n+    Round(g, h, a, b, c, d, e, f, 0xb019fc65ul);\n+    Round(f, g, h, a, b, c, d, e, 0xb9d99ec7ul);\n+    Round(e, f, g, h, a, b, c, d, 0x9a1231c3ul);\n+    Round(d, e, f, g, h, a, b, c, 0xe70eeaa0ul);\n+    Round(c, d, e, f, g, h, a, b, 0xfdb1232bul);\n+    Round(b, c, d, e, f, g, h, a, 0xc7353eb0ul);\n+    Round(a, b, c, d, e, f, g, h, 0x3069bad5ul);\n+    Round(h, a, b, c, d, e, f, g, 0xcb976d5ful);\n+    Round(g, h, a, b, c, d, e, f, 0x5a0f118ful);\n+    Round(f, g, h, a, b, c, d, e, 0xdc1eeefdul);\n+    Round(e, f, g, h, a, b, c, d, 0x0a35b689ul);\n+    Round(d, e, f, g, h, a, b, c, 0xde0b7a04ul);\n+    Round(c, d, e, f, g, h, a, b, 0x58f4ca9dul);\n+    Round(b, c, d, e, f, g, h, a, 0xe15d5b16ul);\n+    Round(a, b, c, d, e, f, g, h, 0x007f3e86ul);\n+    Round(h, a, b, c, d, e, f, g, 0x37088980ul);\n+    Round(g, h, a, b, c, d, e, f, 0xa507ea32ul);\n+    Round(f, g, h, a, b, c, d, e, 0x6fab9537ul);\n+    Round(e, f, g, h, a, b, c, d, 0x17406110ul);\n+    Round(d, e, f, g, h, a, b, c, 0x0d8cd6f1ul);\n+    Round(c, d, e, f, g, h, a, b, 0xcdaa3b6dul);\n+    Round(b, c, d, e, f, g, h, a, 0xc0bbbe37ul);\n+    Round(a, b, c, d, e, f, g, h, 0x83613bdaul);\n+    Round(h, a, b, c, d, e, f, g, 0xdb48a363ul);\n+    Round(g, h, a, b, c, d, e, f, 0x0b02e931ul);\n+    Round(f, g, h, a, b, c, d, e, 0x6fd15ca7ul);\n+    Round(e, f, g, h, a, b, c, d, 0x521afacaul);\n+    Round(d, e, f, g, h, a, b, c, 0x31338431ul);\n+    Round(c, d, e, f, g, h, a, b, 0x6ed41a95ul);\n+    Round(b, c, d, e, f, g, h, a, 0x6d437890ul);\n+    Round(a, b, c, d, e, f, g, h, 0xc39c91f2ul);\n+    Round(h, a, b, c, d, e, f, g, 0x9eccabbdul);\n+    Round(g, h, a, b, c, d, e, f, 0xb5c9a0e6ul);\n+    Round(f, g, h, a, b, c, d, e, 0x532fb63cul);\n+    Round(e, f, g, h, a, b, c, d, 0xd2c741c6ul);\n+    Round(d, e, f, g, h, a, b, c, 0x07237ea3ul);\n+    Round(c, d, e, f, g, h, a, b, 0xa4954b68ul);\n+    Round(b, c, d, e, f, g, h, a, 0x4c191d76ul);\n+\n+    w0 = t0 + a;\n+    w1 = t1 + b;\n+    w2 = t2 + c;\n+    w3 = t3 + d;\n+    w4 = t4 + e;\n+    w5 = t5 + f;\n+    w6 = t6 + g;\n+    w7 = t7 + h;\n+\n+    // Transform 3\n+    a = 0x6a09e667ul;\n+    b = 0xbb67ae85ul;\n+    c = 0x3c6ef372ul;\n+    d = 0xa54ff53aul;\n+    e = 0x510e527ful;\n+    f = 0x9b05688cul;\n+    g = 0x1f83d9abul;\n+    h = 0x5be0cd19ul;\n+\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98ul + w0);\n+    Round(h, a, b, c, d, e, f, g, 0x71374491ul + w1);\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcful + w2);\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5ul + w3);\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25bul + w4);\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1ul + w5);\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4ul + w6);\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5ul + w7);\n+    Round(a, b, c, d, e, f, g, h, 0x5807aa98ul);\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01ul);\n+    Round(g, h, a, b, c, d, e, f, 0x243185beul);\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3ul);\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74ul);\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1feul);\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7ul);\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf274ul);\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c1ul + (w0 += sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786ul + (w1 += 0xa00000ul + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6ul + (w2 += sigma1(w0) + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1ccul + (w3 += sigma1(w1) + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6ful + (w4 += sigma1(w2) + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aaul + (w5 += sigma1(w3) + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcul + (w6 += sigma1(w4) + 0x100ul + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988daul + (w7 += sigma1(w5) + w0 + 0x11002000ul));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152ul + (w8 = 0x80000000ul + sigma1(w6) + w1));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66dul + (w9 = sigma1(w7) + w2));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c8ul + (w10 = sigma1(w8) + w3));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7ul + (w11 = sigma1(w9) + w4));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3ul + (w12 = sigma1(w10) + w5));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147ul + (w13 = sigma1(w11) + w6));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351ul + (w14 = sigma1(w12) + w7 + 0x400022ul));\n+    Round(b, c, d, e, f, g, h, a, 0x14292967ul + (w15 = 0x100ul + sigma1(w13) + w8 + sigma0(w0)));\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a85ul + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b2138ul + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfcul + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d13ul + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x650a7354ul + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abbul + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92eul + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c85ul + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1ul + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664bul + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70ul + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a3ul + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819ul + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+    Round(d, e, f, g, h, a, b, c, 0xd6990624ul + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e3585ul + (w14 += sigma1(w12) + w7 + sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa070ul + (w15 += sigma1(w13) + w8 + sigma0(w0)));\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116ul + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c08ul + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774cul + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5ul + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3ul + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4aul + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4ful + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3ul + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82eeul + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636ful + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814ul + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc70208ul + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffaul + (w12 += sigma1(w10) + w5 + sigma0(w13)));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506cebul + (w13 += sigma1(w11) + w6 + sigma0(w14)));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7ul + (w14 + sigma1(w12) + w7 + sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2ul + (w15 + sigma1(w13) + w8 + sigma0(w0)));\n+\n+    // Output\n+    WriteBE32(out + 0, a + 0x6a09e667ul);\n+    WriteBE32(out + 4, b + 0xbb67ae85ul);\n+    WriteBE32(out + 8, c + 0x3c6ef372ul);\n+    WriteBE32(out + 12, d + 0xa54ff53aul);\n+    WriteBE32(out + 16, e + 0x510e527ful);\n+    WriteBE32(out + 20, f + 0x9b05688cul);\n+    WriteBE32(out + 24, g + 0x1f83d9abul);\n+    WriteBE32(out + 28, h + 0x5be0cd19ul);\n+}\n+\n } // namespace sha256\n \n typedef void (*TransformType)(uint32_t*, const unsigned char*, size_t);\n+typedef void (*TransformD64Type)(unsigned char*, const unsigned char*);\n \n-bool SelfTest(TransformType tr) {\n-    static const unsigned char in1[65] = {0, 0x80};\n-    static const unsigned char in2[129] = {\n-        0,\n-        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, \n-        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, \n-        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0\n+template<TransformType tr>\n+void TransformD64Wrapper(unsigned char* out, const unsigned char* in)\n+{\n+    uint32_t s[8];\n+    static const unsigned char padding1[64] = {\n+        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0\n     };\n-    static const uint32_t init[8] = {0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul};\n-    static const uint32_t out1[8] = {0xe3b0c442ul, 0x98fc1c14ul, 0x9afbf4c8ul, 0x996fb924ul, 0x27ae41e4ul, 0x649b934cul, 0xa495991bul, 0x7852b855ul};\n-    static const uint32_t out2[8] = {0xce4153b0ul, 0x147c2a86ul, 0x3ed4298eul, 0xe0676bc8ul, 0x79fc77a1ul, 0x2abe1f49ul, 0xb2b055dful, 0x1069523eul};\n-    uint32_t buf[8];\n-    memcpy(buf, init, sizeof(buf));\n-    // Process nothing, and check we remain in the initial state.\n-    tr(buf, nullptr, 0);\n-    if (memcmp(buf, init, sizeof(buf))) return false;\n-    // Process the padded empty string (unaligned)\n-    tr(buf, in1 + 1, 1);\n-    if (memcmp(buf, out1, sizeof(buf))) return false;\n-    // Process 64 spaces (unaligned)\n-    memcpy(buf, init, sizeof(buf));\n-    tr(buf, in2 + 1, 2);\n-    if (memcmp(buf, out2, sizeof(buf))) return false;\n-    return true;\n+    unsigned char buffer2[64] = {\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0\n+    };\n+    sha256::Initialize(s);\n+    tr(s, in, 1);\n+    tr(s, padding1, 1);\n+    WriteBE32(buffer2 + 0, s[0]);\n+    WriteBE32(buffer2 + 4, s[1]);\n+    WriteBE32(buffer2 + 8, s[2]);\n+    WriteBE32(buffer2 + 12, s[3]);\n+    WriteBE32(buffer2 + 16, s[4]);\n+    WriteBE32(buffer2 + 20, s[5]);\n+    WriteBE32(buffer2 + 24, s[6]);\n+    WriteBE32(buffer2 + 28, s[7]);\n+    sha256::Initialize(s);\n+    tr(s, buffer2, 1);\n+    WriteBE32(out + 0, s[0]);\n+    WriteBE32(out + 4, s[1]);\n+    WriteBE32(out + 8, s[2]);\n+    WriteBE32(out + 12, s[3]);\n+    WriteBE32(out + 16, s[4]);\n+    WriteBE32(out + 20, s[5]);\n+    WriteBE32(out + 24, s[6]);\n+    WriteBE32(out + 28, s[7]);\n }\n \n TransformType Transform = sha256::Transform;\n+TransformD64Type TransformD64 = sha256::TransformD64;\n+TransformD64Type TransformD64_4way = nullptr;\n+TransformD64Type TransformD64_8way = nullptr;\n+\n+bool SelfTest() {\n+    // Input state (equal to the initial SHA256 state)\n+    static const uint32_t init[8] = {\n+        0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul\n+    };\n+    // Some random input data to test with\n+    static const unsigned char data[641] = \"-\" // Intentionally not aligned\n+        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do \"\n+        \"eiusmod tempor incididunt ut labore et dolore magna aliqua. Et m\"\n+        \"olestie ac feugiat sed lectus vestibulum mattis ullamcorper. Mor\"\n+        \"bi blandit cursus risus at ultrices mi tempus imperdiet nulla. N\"\n+        \"unc congue nisi vita suscipit tellus mauris. Imperdiet proin fer\"\n+        \"mentum leo vel orci. Massa tempor nec feugiat nisl pretium fusce\"\n+        \" id velit. Telus in metus vulputate eu scelerisque felis. Mi tem\"\n+        \"pus imperdiet nulla malesuada pellentesque. Tristique magna sit.\";\n+    // Expected output state for hashing the i*64 first input bytes above (excluding SHA256 padding).\n+    static const uint32_t result[9][8] = {\n+        {0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul},\n+        {0x91f8ec6bul, 0x4da10fe3ul, 0x1c9c292cul, 0x45e18185ul, 0x435cc111ul, 0x3ca26f09ul, 0xeb954caeul, 0x402a7069ul},\n+        {0xcabea5acul, 0x374fb97cul, 0x182ad996ul, 0x7bd69cbful, 0x450ff900ul, 0xc1d2be8aul, 0x6a41d505ul, 0xe6212dc3ul},\n+        {0xbcff09d6ul, 0x3e76f36eul, 0x3ecb2501ul, 0x78866e97ul, 0xe1c1e2fdul, 0x32f4eafful, 0x8aa6c4e5ul, 0xdfc024bcul},\n+        {0xa08c5d94ul, 0x0a862f93ul, 0x6b7f2f40ul, 0x8f9fae76ul, 0x6d40439ful, 0x79dcee0cul, 0x3e39ff3aul, 0xdc3bdbb1ul},\n+        {0x216a0895ul, 0x9f1a3662ul, 0xe99946f9ul, 0x87ba4364ul, 0x0fb5db2cul, 0x12bed3d3ul, 0x6689c0c7ul, 0x292f1b04ul},\n+        {0xca3067f8ul, 0xbc8c2656ul, 0x37cb7e0dul, 0x9b6b8b0ful, 0x46dc380bul, 0xf1287f57ul, 0xc42e4b23ul, 0x3fefe94dul},\n+        {0x3e4c4039ul, 0xbb6fca8cul, 0x6f27d2f7ul, 0x301e44a4ul, 0x8352ba14ul, 0x5769ce37ul, 0x48a1155ful, 0xc0e1c4c6ul},\n+        {0xfe2fa9ddul, 0x69d0862bul, 0x1ae0db23ul, 0x471f9244ul, 0xf55c0145ul, 0xc30f9c3bul, 0x40a84ea0ul, 0x5b8a266cul},\n+    };\n+    // Expected output for each of the individual 8 64-byte messages under full double SHA256 (including padding).\n+    static const unsigned char result_d64[256] = {\n+        0x09, 0x3a, 0xc4, 0xd0, 0x0f, 0xf7, 0x57, 0xe1, 0x72, 0x85, 0x79, 0x42, 0xfe, 0xe7, 0xe0, 0xa0,\n+        0xfc, 0x52, 0xd7, 0xdb, 0x07, 0x63, 0x45, 0xfb, 0x53, 0x14, 0x7d, 0x17, 0x22, 0x86, 0xf0, 0x52,\n+        0x48, 0xb6, 0x11, 0x9e, 0x6e, 0x48, 0x81, 0x6d, 0xcc, 0x57, 0x1f, 0xb2, 0x97, 0xa8, 0xd5, 0x25,\n+        0x9b, 0x82, 0xaa, 0x89, 0xe2, 0xfd, 0x2d, 0x56, 0xe8, 0x28, 0x83, 0x0b, 0xe2, 0xfa, 0x53, 0xb7,\n+        0xd6, 0x6b, 0x07, 0x85, 0x83, 0xb0, 0x10, 0xa2, 0xf5, 0x51, 0x3c, 0xf9, 0x60, 0x03, 0xab, 0x45,\n+        0x6c, 0x15, 0x6e, 0xef, 0xb5, 0xac, 0x3e, 0x6c, 0xdf, 0xb4, 0x92, 0x22, 0x2d, 0xce, 0xbf, 0x3e,\n+        0xe9, 0xe5, 0xf6, 0x29, 0x0e, 0x01, 0x4f, 0xd2, 0xd4, 0x45, 0x65, 0xb3, 0xbb, 0xf2, 0x4c, 0x16,\n+        0x37, 0x50, 0x3c, 0x6e, 0x49, 0x8c, 0x5a, 0x89, 0x2b, 0x1b, 0xab, 0xc4, 0x37, 0xd1, 0x46, 0xe9,\n+        0x3d, 0x0e, 0x85, 0xa2, 0x50, 0x73, 0xa1, 0x5e, 0x54, 0x37, 0xd7, 0x94, 0x17, 0x56, 0xc2, 0xd8,\n+        0xe5, 0x9f, 0xed, 0x4e, 0xae, 0x15, 0x42, 0x06, 0x0d, 0x74, 0x74, 0x5e, 0x24, 0x30, 0xce, 0xd1,\n+        0x9e, 0x50, 0xa3, 0x9a, 0xb8, 0xf0, 0x4a, 0x57, 0x69, 0x78, 0x67, 0x12, 0x84, 0x58, 0xbe, 0xc7,\n+        0x36, 0xaa, 0xee, 0x7c, 0x64, 0xa3, 0x76, 0xec, 0xff, 0x55, 0x41, 0x00, 0x2a, 0x44, 0x68, 0x4d,\n+        0xb6, 0x53, 0x9e, 0x1c, 0x95, 0xb7, 0xca, 0xdc, 0x7f, 0x7d, 0x74, 0x27, 0x5c, 0x8e, 0xa6, 0x84,\n+        0xb5, 0xac, 0x87, 0xa9, 0xf3, 0xff, 0x75, 0xf2, 0x34, 0xcd, 0x1a, 0x3b, 0x82, 0x2c, 0x2b, 0x4e,\n+        0x6a, 0x46, 0x30, 0xa6, 0x89, 0x86, 0x23, 0xac, 0xf8, 0xa5, 0x15, 0xe9, 0x0a, 0xaa, 0x1e, 0x9a,\n+        0xd7, 0x93, 0x6b, 0x28, 0xe4, 0x3b, 0xfd, 0x59, 0xc6, 0xed, 0x7c, 0x5f, 0xa5, 0x41, 0xcb, 0x51\n+    };\n \n+\n+    // Test Transform() for 0 through 8 transformations.\n+    for (size_t i = 0; i <= 8; ++i) {\n+        uint32_t state[8];\n+        std::copy(init, init + 8, state);\n+        Transform(state, data + 1, i);\n+        if (!std::equal(state, state + 8, result[i])) return false;\n+    }\n+\n+    // Test TransformD64\n+    unsigned char out[32];\n+    TransformD64(out, data + 1);\n+    if (!std::equal(out, out + 32, result_d64)) return false;\n+\n+    // Test TransformD64_4way, if available.\n+    if (TransformD64_4way) {\n+        unsigned char out[128];\n+        TransformD64_4way(out, data + 1);\n+        if (!std::equal(out, out + 128, result_d64)) return false;\n+    }\n+\n+    // Test TransformD64_8way, if available.\n+    if (TransformD64_8way) {\n+        unsigned char out[256];\n+        TransformD64_8way(out, data + 1);\n+        if (!std::equal(out, out + 256, result_d64)) return false;\n+    }\n+\n+    return true;\n+}\n+\n+\n+#if defined(USE_ASM) && (defined(__x86_64__) || defined(__amd64__) || defined(__i386__))\n+// We can't use cpuid.h's __get_cpuid as it does not support subleafs.\n+void inline cpuid(uint32_t leaf, uint32_t subleaf, uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d)\n+{\n+  __asm__ (\"cpuid\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(leaf), \"2\"(subleaf));\n+}\n+\n+/** Check whether the OS has enabled AVX registers. */\n+bool AVXEnabled()\n+{\n+    uint32_t a, d;\n+    __asm__(\"xgetbv\" : \"=a\"(a), \"=d\"(d) : \"c\"(0));\n+    return (a & 6) == 6;\n+}\n+#endif\n } // namespace\n \n+\n std::string SHA256AutoDetect()\n {\n-#if defined(USE_ASM) && (defined(__x86_64__) || defined(__amd64__))\n+    std::string ret = \"standard\";\n+#if defined(USE_ASM) && (defined(__x86_64__) || defined(__amd64__) || defined(__i386__))\n+    (void)AVXEnabled; // Silence unused warning (in case ENABLE_AVX2 is not defined)\n     uint32_t eax, ebx, ecx, edx;\n-    if (__get_cpuid(1, &eax, &ebx, &ecx, &edx) && (ecx >> 19) & 1) {\n+    cpuid(1, 0, eax, ebx, ecx, edx);\n+    if ((ecx >> 19) & 1) {\n+#if defined(__x86_64__) || defined(__amd64__)\n         Transform = sha256_sse4::Transform;\n-        assert(SelfTest(Transform));\n-        return \"sse4\";\n+        TransformD64 = TransformD64Wrapper<sha256_sse4::Transform>;\n+#endif\n+#if defined(ENABLE_SSE41) && !defined(BUILD_BITCOIN_INTERNAL)\n+        TransformD64_4way = sha256d64_sse41::Transform_4way;\n+        ret = \"sse4(1way+4way)\";\n+#if defined(ENABLE_AVX2) && !defined(BUILD_BITCOIN_INTERNAL)\n+        if (((ecx >> 27) & 1) && ((ecx >> 28) & 1)) { // XSAVE and AVX\n+            cpuid(7, 0, eax, ebx, ecx, edx);\n+            if ((ebx >> 5) & 1) { // AVX2 flag\n+                if (AVXEnabled()) { // OS has enabled AVX registers\n+                    TransformD64_8way = sha256d64_avx2::Transform_8way;\n+                    ret += \",avx2(8way)\";\n+                }\n+            }\n+        }\n+#endif\n+#else\n+        ret = \"sse4\";\n+#endif\n     }\n #endif\n \n-    assert(SelfTest(Transform));\n-    return \"standard\";\n+    assert(SelfTest());\n+    return ret;\n }\n \n ////// SHA-256\n@@ -247,3 +640,29 @@ CSHA256& CSHA256::Reset()\n     sha256::Initialize(s);\n     return *this;\n }\n+\n+void SHA256D64(unsigned char* out, const unsigned char* in, size_t blocks)\n+{\n+    if (TransformD64_8way) {\n+        while (blocks >= 8) {\n+            TransformD64_8way(out, in);\n+            out += 256;\n+            in += 512;\n+            blocks -= 8;\n+        }\n+    }\n+    if (TransformD64_4way) {\n+        while (blocks >= 4) {\n+            TransformD64_4way(out, in);\n+            out += 128;\n+            in += 256;\n+            blocks -= 4;\n+        }\n+    }\n+    while (blocks) {\n+        TransformD64(out, in);\n+        out += 32;\n+        in += 64;\n+        --blocks;\n+    }\n+}"
      },
      {
        "sha": "31b2b3b3df3ab6c020c713c5e89853c528fc3535",
        "filename": "src/crypto/sha256.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -31,4 +31,11 @@ class CSHA256\n  */\n std::string SHA256AutoDetect();\n \n+/** Compute multiple double-SHA256's of 64-byte blobs.\n+ *  output:  pointer to a blocks*32 byte output buffer\n+ *  input:   pointer to a blocks*64 byte input buffer\n+ *  blocks:  the number of hashes to compute.\n+ */\n+void SHA256D64(unsigned char* output, const unsigned char* input, size_t blocks);\n+\n #endif // BITCOIN_CRYPTO_SHA256_H"
      },
      {
        "sha": "b338b06927f0869d5d4bb37756d135390bf4d1a6",
        "filename": "src/crypto/sha256_avx2.cpp",
        "status": "added",
        "additions": 329,
        "deletions": 0,
        "changes": 329,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256_avx2.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256_avx2.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_avx2.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,329 @@\n+#ifdef ENABLE_AVX2\n+\n+#include <stdint.h>\n+#if defined(_MSC_VER)\n+#include <immintrin.h>\n+#elif defined(__GNUC__)\n+#include <x86intrin.h>\n+#endif\n+\n+#include <crypto/sha256.h>\n+#include <crypto/common.h>\n+\n+namespace sha256d64_avx2 {\n+namespace {\n+\n+__m256i inline K(uint32_t x) { return _mm256_set1_epi32(x); }\n+\n+__m256i inline Add(__m256i x, __m256i y) { return _mm256_add_epi32(x, y); }\n+__m256i inline Add(__m256i x, __m256i y, __m256i z) { return Add(Add(x, y), z); }\n+__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w) { return Add(Add(x, y), Add(z, w)); }\n+__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w, __m256i v) { return Add(Add(x, y, z), Add(w, v)); }\n+__m256i inline Inc(__m256i& x, __m256i y) { x = Add(x, y); return x; }\n+__m256i inline Inc(__m256i& x, __m256i y, __m256i z) { x = Add(x, y, z); return x; }\n+__m256i inline Inc(__m256i& x, __m256i y, __m256i z, __m256i w) { x = Add(x, y, z, w); return x; }\n+__m256i inline Xor(__m256i x, __m256i y) { return _mm256_xor_si256(x, y); }\n+__m256i inline Xor(__m256i x, __m256i y, __m256i z) { return Xor(Xor(x, y), z); }\n+__m256i inline Or(__m256i x, __m256i y) { return _mm256_or_si256(x, y); }\n+__m256i inline And(__m256i x, __m256i y) { return _mm256_and_si256(x, y); }\n+__m256i inline ShR(__m256i x, int n) { return _mm256_srli_epi32(x, n); }\n+__m256i inline ShL(__m256i x, int n) { return _mm256_slli_epi32(x, n); }\n+\n+__m256i inline Ch(__m256i x, __m256i y, __m256i z) { return Xor(z, And(x, Xor(y, z))); }\n+__m256i inline Maj(__m256i x, __m256i y, __m256i z) { return Or(And(x, y), And(z, Or(x, y))); }\n+__m256i inline Sigma0(__m256i x) { return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); }\n+__m256i inline Sigma1(__m256i x) { return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); }\n+__m256i inline sigma0(__m256i x) { return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); }\n+__m256i inline sigma1(__m256i x) { return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); }\n+\n+/** One round of SHA-256. */\n+void inline __attribute__((always_inline)) Round(__m256i a, __m256i b, __m256i c, __m256i& d, __m256i e, __m256i f, __m256i g, __m256i& h, __m256i k)\n+{\n+    __m256i t1 = Add(h, Sigma1(e), Ch(e, f, g), k);\n+    __m256i t2 = Add(Sigma0(a), Maj(a, b, c));\n+    d = Add(d, t1);\n+    h = Add(t1, t2);\n+}\n+\n+__m256i inline Read8(const unsigned char* chunk, int offset) {\n+    __m256i ret = _mm256_set_epi32(\n+        ReadLE32(chunk + 0 + offset),\n+        ReadLE32(chunk + 64 + offset),\n+        ReadLE32(chunk + 128 + offset),\n+        ReadLE32(chunk + 192 + offset),\n+        ReadLE32(chunk + 256 + offset),\n+        ReadLE32(chunk + 320 + offset),\n+        ReadLE32(chunk + 384 + offset),\n+        ReadLE32(chunk + 448 + offset)\n+    );\n+    return _mm256_shuffle_epi8(ret, _mm256_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL, 0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n+}\n+\n+void inline Write8(unsigned char* out, int offset, __m256i v) {\n+    v = _mm256_shuffle_epi8(v, _mm256_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL, 0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n+    WriteLE32(out + 0 + offset, _mm256_extract_epi32(v, 7));\n+    WriteLE32(out + 32 + offset, _mm256_extract_epi32(v, 6));\n+    WriteLE32(out + 64 + offset, _mm256_extract_epi32(v, 5));\n+    WriteLE32(out + 96 + offset, _mm256_extract_epi32(v, 4));\n+    WriteLE32(out + 128 + offset, _mm256_extract_epi32(v, 3));\n+    WriteLE32(out + 160 + offset, _mm256_extract_epi32(v, 2));\n+    WriteLE32(out + 192 + offset, _mm256_extract_epi32(v, 1));\n+    WriteLE32(out + 224 + offset, _mm256_extract_epi32(v, 0));\n+}\n+\n+}\n+\n+void Transform_8way(unsigned char* out, const unsigned char* in)\n+{\n+    // Transform 1\n+    __m256i a = K(0x6a09e667ul);\n+    __m256i b = K(0xbb67ae85ul);\n+    __m256i c = K(0x3c6ef372ul);\n+    __m256i d = K(0xa54ff53aul);\n+    __m256i e = K(0x510e527ful);\n+    __m256i f = K(0x9b05688cul);\n+    __m256i g = K(0x1f83d9abul);\n+    __m256i h = K(0x5be0cd19ul);\n+\n+    __m256i w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x428a2f98ul), w0 = Read8(in, 0)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x71374491ul), w1 = Read8(in, 4)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb5c0fbcful), w2 = Read8(in, 8)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xe9b5dba5ul), w3 = Read8(in, 12)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x3956c25bul), w4 = Read8(in, 16)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x59f111f1ul), w5 = Read8(in, 20)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x923f82a4ul), w6 = Read8(in, 24)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xab1c5ed5ul), w7 = Read8(in, 28)));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xd807aa98ul), w8 = Read8(in, 32)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x12835b01ul), w9 = Read8(in, 36)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x243185beul), w10 = Read8(in, 40)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x550c7dc3ul), w11 = Read8(in, 44)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x72be5d74ul), w12 = Read8(in, 48)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x80deb1feul), w13 = Read8(in, 52)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x9bdc06a7ul), w14 = Read8(in, 56)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc19bf174ul), w15 = Read8(in, 60)));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xe49b69c1ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xefbe4786ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x0fc19dc6ul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x240ca1ccul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x2de92c6ful), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4a7484aaul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5cb0a9dcul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x76f988daul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x983e5152ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa831c66dul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb00327c8ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xbf597fc7ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xc6e00bf3ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd5a79147ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x06ca6351ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x14292967ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x27b70a85ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x2e1b2138ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x4d2c6dfcul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x53380d13ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x650a7354ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x766a0abbul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x81c2c92eul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x92722c85ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xa2bfe8a1ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa81a664bul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xc24b8b70ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xc76c51a3ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xd192e819ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd6990624ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xf40e3585ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x106aa070ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x19a4c116ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x1e376c08ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x2748774cul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x34b0bcb5ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x391c0cb3ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4ed8aa4aul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5b9cca4ful), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x682e6ff3ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x748f82eeul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x78a5636ful), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x84c87814ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x8cc70208ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x90befffaul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xa4506cebul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xbef9a3f7ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc67178f2ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+\n+    a = Add(a, K(0x6a09e667ul));\n+    b = Add(b, K(0xbb67ae85ul));\n+    c = Add(c, K(0x3c6ef372ul));\n+    d = Add(d, K(0xa54ff53aul));\n+    e = Add(e, K(0x510e527ful));\n+    f = Add(f, K(0x9b05688cul));\n+    g = Add(g, K(0x1f83d9abul));\n+    h = Add(h, K(0x5be0cd19ul));\n+\n+    __m256i t0 = a, t1 = b, t2 = c, t3 = d, t4 = e, t5 = f, t6 = g, t7 = h;\n+\n+    // Transform 2\n+    Round(a, b, c, d, e, f, g, h, K(0xc28a2f98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x71374491ul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb5c0fbcful));\n+    Round(f, g, h, a, b, c, d, e, K(0xe9b5dba5ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x3956c25bul));\n+    Round(d, e, f, g, h, a, b, c, K(0x59f111f1ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x923f82a4ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xab1c5ed5ul));\n+    Round(a, b, c, d, e, f, g, h, K(0xd807aa98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x12835b01ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x243185beul));\n+    Round(f, g, h, a, b, c, d, e, K(0x550c7dc3ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x72be5d74ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x80deb1feul));\n+    Round(c, d, e, f, g, h, a, b, K(0x9bdc06a7ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc19bf374ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x649b69c1ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xf0fe4786ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x0fe1edc6ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x240cf254ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x4fe9346ful));\n+    Round(d, e, f, g, h, a, b, c, K(0x6cc984beul));\n+    Round(c, d, e, f, g, h, a, b, K(0x61b9411eul));\n+    Round(b, c, d, e, f, g, h, a, K(0x16f988faul));\n+    Round(a, b, c, d, e, f, g, h, K(0xf2c65152ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xa88e5a6dul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb019fc65ul));\n+    Round(f, g, h, a, b, c, d, e, K(0xb9d99ec7ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x9a1231c3ul));\n+    Round(d, e, f, g, h, a, b, c, K(0xe70eeaa0ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xfdb1232bul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc7353eb0ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x3069bad5ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xcb976d5ful));\n+    Round(g, h, a, b, c, d, e, f, K(0x5a0f118ful));\n+    Round(f, g, h, a, b, c, d, e, K(0xdc1eeefdul));\n+    Round(e, f, g, h, a, b, c, d, K(0x0a35b689ul));\n+    Round(d, e, f, g, h, a, b, c, K(0xde0b7a04ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x58f4ca9dul));\n+    Round(b, c, d, e, f, g, h, a, K(0xe15d5b16ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x007f3e86ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x37088980ul));\n+    Round(g, h, a, b, c, d, e, f, K(0xa507ea32ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x6fab9537ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x17406110ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x0d8cd6f1ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xcdaa3b6dul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc0bbbe37ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x83613bdaul));\n+    Round(h, a, b, c, d, e, f, g, K(0xdb48a363ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x0b02e931ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x6fd15ca7ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x521afacaul));\n+    Round(d, e, f, g, h, a, b, c, K(0x31338431ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x6ed41a95ul));\n+    Round(b, c, d, e, f, g, h, a, K(0x6d437890ul));\n+    Round(a, b, c, d, e, f, g, h, K(0xc39c91f2ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x9eccabbdul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb5c9a0e6ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x532fb63cul));\n+    Round(e, f, g, h, a, b, c, d, K(0xd2c741c6ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x07237ea3ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xa4954b68ul));\n+    Round(b, c, d, e, f, g, h, a, K(0x4c191d76ul));\n+\n+    w0 = Add(t0, a);\n+    w1 = Add(t1, b);\n+    w2 = Add(t2, c);\n+    w3 = Add(t3, d);\n+    w4 = Add(t4, e);\n+    w5 = Add(t5, f);\n+    w6 = Add(t6, g);\n+    w7 = Add(t7, h);\n+\n+    // Transform 3\n+    a = K(0x6a09e667ul);\n+    b = K(0xbb67ae85ul);\n+    c = K(0x3c6ef372ul);\n+    d = K(0xa54ff53aul);\n+    e = K(0x510e527ful);\n+    f = K(0x9b05688cul);\n+    g = K(0x1f83d9abul);\n+    h = K(0x5be0cd19ul);\n+\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x428a2f98ul), w0));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x71374491ul), w1));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb5c0fbcful), w2));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xe9b5dba5ul), w3));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x3956c25bul), w4));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x59f111f1ul), w5));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x923f82a4ul), w6));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xab1c5ed5ul), w7));\n+    Round(a, b, c, d, e, f, g, h, K(0x5807aa98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x12835b01ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x243185beul));\n+    Round(f, g, h, a, b, c, d, e, K(0x550c7dc3ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x72be5d74ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x80deb1feul));\n+    Round(c, d, e, f, g, h, a, b, K(0x9bdc06a7ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc19bf274ul));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xe49b69c1ul), Inc(w0, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xefbe4786ul), Inc(w1, K(0xa00000ul), sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x0fc19dc6ul), Inc(w2, sigma1(w0), sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x240ca1ccul), Inc(w3, sigma1(w1), sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x2de92c6ful), Inc(w4, sigma1(w2), sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4a7484aaul), Inc(w5, sigma1(w3), sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5cb0a9dcul), Inc(w6, sigma1(w4), K(0x100ul), sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x76f988daul), Inc(w7, sigma1(w5), w0, K(0x11002000ul))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x983e5152ul), w8 = Add(K(0x80000000ul), sigma1(w6), w1)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa831c66dul), w9 = Add(sigma1(w7), w2)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb00327c8ul), w10 = Add(sigma1(w8), w3)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xbf597fc7ul), w11 = Add(sigma1(w9), w4)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xc6e00bf3ul), w12 = Add(sigma1(w10), w5)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd5a79147ul), w13 = Add(sigma1(w11), w6)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x06ca6351ul), w14 = Add(sigma1(w12), w7, K(0x400022ul))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x14292967ul), w15 = Add(K(0x100ul), sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x27b70a85ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x2e1b2138ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x4d2c6dfcul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x53380d13ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x650a7354ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x766a0abbul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x81c2c92eul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x92722c85ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xa2bfe8a1ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa81a664bul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xc24b8b70ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xc76c51a3ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xd192e819ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd6990624ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xf40e3585ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x106aa070ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x19a4c116ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x1e376c08ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x2748774cul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x34b0bcb5ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x391c0cb3ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4ed8aa4aul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5b9cca4ful), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x682e6ff3ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x748f82eeul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x78a5636ful), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x84c87814ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x8cc70208ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x90befffaul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xa4506cebul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xbef9a3f7ul), w14, sigma1(w12), w7, sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc67178f2ul), w15, sigma1(w13), w8, sigma0(w0)));\n+\n+    // Output\n+    Write8(out, 0, Add(a, K(0x6a09e667ul)));\n+    Write8(out, 4, Add(b, K(0xbb67ae85ul)));\n+    Write8(out, 8, Add(c, K(0x3c6ef372ul)));\n+    Write8(out, 12, Add(d, K(0xa54ff53aul)));\n+    Write8(out, 16, Add(e, K(0x510e527ful)));\n+    Write8(out, 20, Add(f, K(0x9b05688cul)));\n+    Write8(out, 24, Add(g, K(0x1f83d9abul)));\n+    Write8(out, 28, Add(h, K(0x5be0cd19ul)));\n+}\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "be71dd8fb8e1271da773c6e4719e9dfcc885ed95",
        "filename": "src/crypto/sha256_sse41.cpp",
        "status": "added",
        "additions": 321,
        "deletions": 0,
        "changes": 321,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256_sse41.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/crypto/sha256_sse41.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_sse41.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,321 @@\n+#ifdef ENABLE_SSE41\n+\n+#include <stdint.h>\n+#if defined(_MSC_VER)\n+#include <immintrin.h>\n+#elif defined(__GNUC__)\n+#include <x86intrin.h>\n+#endif\n+\n+#include <crypto/sha256.h>\n+#include <crypto/common.h>\n+\n+namespace sha256d64_sse41 {\n+namespace {\n+\n+__m128i inline K(uint32_t x) { return _mm_set1_epi32(x); }\n+\n+__m128i inline Add(__m128i x, __m128i y) { return _mm_add_epi32(x, y); }\n+__m128i inline Add(__m128i x, __m128i y, __m128i z) { return Add(Add(x, y), z); }\n+__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w) { return Add(Add(x, y), Add(z, w)); }\n+__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w, __m128i v) { return Add(Add(x, y, z), Add(w, v)); }\n+__m128i inline Inc(__m128i& x, __m128i y) { x = Add(x, y); return x; }\n+__m128i inline Inc(__m128i& x, __m128i y, __m128i z) { x = Add(x, y, z); return x; }\n+__m128i inline Inc(__m128i& x, __m128i y, __m128i z, __m128i w) { x = Add(x, y, z, w); return x; }\n+__m128i inline Xor(__m128i x, __m128i y) { return _mm_xor_si128(x, y); }\n+__m128i inline Xor(__m128i x, __m128i y, __m128i z) { return Xor(Xor(x, y), z); }\n+__m128i inline Or(__m128i x, __m128i y) { return _mm_or_si128(x, y); }\n+__m128i inline And(__m128i x, __m128i y) { return _mm_and_si128(x, y); }\n+__m128i inline ShR(__m128i x, int n) { return _mm_srli_epi32(x, n); }\n+__m128i inline ShL(__m128i x, int n) { return _mm_slli_epi32(x, n); }\n+\n+__m128i inline Ch(__m128i x, __m128i y, __m128i z) { return Xor(z, And(x, Xor(y, z))); }\n+__m128i inline Maj(__m128i x, __m128i y, __m128i z) { return Or(And(x, y), And(z, Or(x, y))); }\n+__m128i inline Sigma0(__m128i x) { return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); }\n+__m128i inline Sigma1(__m128i x) { return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); }\n+__m128i inline sigma0(__m128i x) { return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); }\n+__m128i inline sigma1(__m128i x) { return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); }\n+\n+/** One round of SHA-256. */\n+void inline __attribute__((always_inline)) Round(__m128i a, __m128i b, __m128i c, __m128i& d, __m128i e, __m128i f, __m128i g, __m128i& h, __m128i k)\n+{\n+    __m128i t1 = Add(h, Sigma1(e), Ch(e, f, g), k);\n+    __m128i t2 = Add(Sigma0(a), Maj(a, b, c));\n+    d = Add(d, t1);\n+    h = Add(t1, t2);\n+}\n+\n+__m128i inline Read4(const unsigned char* chunk, int offset) {\n+    __m128i ret = _mm_set_epi32(\n+        ReadLE32(chunk + 0 + offset),\n+        ReadLE32(chunk + 64 + offset),\n+        ReadLE32(chunk + 128 + offset),\n+        ReadLE32(chunk + 192 + offset)\n+    );\n+    return _mm_shuffle_epi8(ret, _mm_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n+}\n+\n+void inline Write4(unsigned char* out, int offset, __m128i v) {\n+    v = _mm_shuffle_epi8(v, _mm_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n+    WriteLE32(out + 0 + offset, _mm_extract_epi32(v, 3));\n+    WriteLE32(out + 32 + offset, _mm_extract_epi32(v, 2));\n+    WriteLE32(out + 64 + offset, _mm_extract_epi32(v, 1));\n+    WriteLE32(out + 96 + offset, _mm_extract_epi32(v, 0));\n+}\n+\n+}\n+\n+void Transform_4way(unsigned char* out, const unsigned char* in)\n+{\n+    // Transform 1\n+    __m128i a = K(0x6a09e667ul);\n+    __m128i b = K(0xbb67ae85ul);\n+    __m128i c = K(0x3c6ef372ul);\n+    __m128i d = K(0xa54ff53aul);\n+    __m128i e = K(0x510e527ful);\n+    __m128i f = K(0x9b05688cul);\n+    __m128i g = K(0x1f83d9abul);\n+    __m128i h = K(0x5be0cd19ul);\n+\n+    __m128i w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x428a2f98ul), w0 = Read4(in, 0)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x71374491ul), w1 = Read4(in, 4)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb5c0fbcful), w2 = Read4(in, 8)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xe9b5dba5ul), w3 = Read4(in, 12)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x3956c25bul), w4 = Read4(in, 16)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x59f111f1ul), w5 = Read4(in, 20)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x923f82a4ul), w6 = Read4(in, 24)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xab1c5ed5ul), w7 = Read4(in, 28)));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xd807aa98ul), w8 = Read4(in, 32)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x12835b01ul), w9 = Read4(in, 36)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x243185beul), w10 = Read4(in, 40)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x550c7dc3ul), w11 = Read4(in, 44)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x72be5d74ul), w12 = Read4(in, 48)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x80deb1feul), w13 = Read4(in, 52)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x9bdc06a7ul), w14 = Read4(in, 56)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc19bf174ul), w15 = Read4(in, 60)));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xe49b69c1ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xefbe4786ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x0fc19dc6ul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x240ca1ccul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x2de92c6ful), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4a7484aaul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5cb0a9dcul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x76f988daul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x983e5152ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa831c66dul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb00327c8ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xbf597fc7ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xc6e00bf3ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd5a79147ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x06ca6351ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x14292967ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x27b70a85ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x2e1b2138ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x4d2c6dfcul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x53380d13ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x650a7354ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x766a0abbul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x81c2c92eul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x92722c85ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xa2bfe8a1ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa81a664bul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xc24b8b70ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xc76c51a3ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xd192e819ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd6990624ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xf40e3585ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x106aa070ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x19a4c116ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x1e376c08ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x2748774cul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x34b0bcb5ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x391c0cb3ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4ed8aa4aul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5b9cca4ful), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x682e6ff3ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x748f82eeul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x78a5636ful), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x84c87814ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x8cc70208ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x90befffaul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xa4506cebul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xbef9a3f7ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc67178f2ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+\n+    a = Add(a, K(0x6a09e667ul));\n+    b = Add(b, K(0xbb67ae85ul));\n+    c = Add(c, K(0x3c6ef372ul));\n+    d = Add(d, K(0xa54ff53aul));\n+    e = Add(e, K(0x510e527ful));\n+    f = Add(f, K(0x9b05688cul));\n+    g = Add(g, K(0x1f83d9abul));\n+    h = Add(h, K(0x5be0cd19ul));\n+\n+    __m128i t0 = a, t1 = b, t2 = c, t3 = d, t4 = e, t5 = f, t6 = g, t7 = h;\n+\n+    // Transform 2\n+    Round(a, b, c, d, e, f, g, h, K(0xc28a2f98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x71374491ul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb5c0fbcful));\n+    Round(f, g, h, a, b, c, d, e, K(0xe9b5dba5ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x3956c25bul));\n+    Round(d, e, f, g, h, a, b, c, K(0x59f111f1ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x923f82a4ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xab1c5ed5ul));\n+    Round(a, b, c, d, e, f, g, h, K(0xd807aa98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x12835b01ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x243185beul));\n+    Round(f, g, h, a, b, c, d, e, K(0x550c7dc3ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x72be5d74ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x80deb1feul));\n+    Round(c, d, e, f, g, h, a, b, K(0x9bdc06a7ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc19bf374ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x649b69c1ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xf0fe4786ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x0fe1edc6ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x240cf254ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x4fe9346ful));\n+    Round(d, e, f, g, h, a, b, c, K(0x6cc984beul));\n+    Round(c, d, e, f, g, h, a, b, K(0x61b9411eul));\n+    Round(b, c, d, e, f, g, h, a, K(0x16f988faul));\n+    Round(a, b, c, d, e, f, g, h, K(0xf2c65152ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xa88e5a6dul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb019fc65ul));\n+    Round(f, g, h, a, b, c, d, e, K(0xb9d99ec7ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x9a1231c3ul));\n+    Round(d, e, f, g, h, a, b, c, K(0xe70eeaa0ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xfdb1232bul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc7353eb0ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x3069bad5ul));\n+    Round(h, a, b, c, d, e, f, g, K(0xcb976d5ful));\n+    Round(g, h, a, b, c, d, e, f, K(0x5a0f118ful));\n+    Round(f, g, h, a, b, c, d, e, K(0xdc1eeefdul));\n+    Round(e, f, g, h, a, b, c, d, K(0x0a35b689ul));\n+    Round(d, e, f, g, h, a, b, c, K(0xde0b7a04ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x58f4ca9dul));\n+    Round(b, c, d, e, f, g, h, a, K(0xe15d5b16ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x007f3e86ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x37088980ul));\n+    Round(g, h, a, b, c, d, e, f, K(0xa507ea32ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x6fab9537ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x17406110ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x0d8cd6f1ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xcdaa3b6dul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc0bbbe37ul));\n+    Round(a, b, c, d, e, f, g, h, K(0x83613bdaul));\n+    Round(h, a, b, c, d, e, f, g, K(0xdb48a363ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x0b02e931ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x6fd15ca7ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x521afacaul));\n+    Round(d, e, f, g, h, a, b, c, K(0x31338431ul));\n+    Round(c, d, e, f, g, h, a, b, K(0x6ed41a95ul));\n+    Round(b, c, d, e, f, g, h, a, K(0x6d437890ul));\n+    Round(a, b, c, d, e, f, g, h, K(0xc39c91f2ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x9eccabbdul));\n+    Round(g, h, a, b, c, d, e, f, K(0xb5c9a0e6ul));\n+    Round(f, g, h, a, b, c, d, e, K(0x532fb63cul));\n+    Round(e, f, g, h, a, b, c, d, K(0xd2c741c6ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x07237ea3ul));\n+    Round(c, d, e, f, g, h, a, b, K(0xa4954b68ul));\n+    Round(b, c, d, e, f, g, h, a, K(0x4c191d76ul));\n+\n+    w0 = Add(t0, a);\n+    w1 = Add(t1, b);\n+    w2 = Add(t2, c);\n+    w3 = Add(t3, d);\n+    w4 = Add(t4, e);\n+    w5 = Add(t5, f);\n+    w6 = Add(t6, g);\n+    w7 = Add(t7, h);\n+\n+    // Transform 3\n+    a = K(0x6a09e667ul);\n+    b = K(0xbb67ae85ul);\n+    c = K(0x3c6ef372ul);\n+    d = K(0xa54ff53aul);\n+    e = K(0x510e527ful);\n+    f = K(0x9b05688cul);\n+    g = K(0x1f83d9abul);\n+    h = K(0x5be0cd19ul);\n+\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x428a2f98ul), w0));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x71374491ul), w1));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb5c0fbcful), w2));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xe9b5dba5ul), w3));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x3956c25bul), w4));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x59f111f1ul), w5));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x923f82a4ul), w6));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xab1c5ed5ul), w7));\n+    Round(a, b, c, d, e, f, g, h, K(0x5807aa98ul));\n+    Round(h, a, b, c, d, e, f, g, K(0x12835b01ul));\n+    Round(g, h, a, b, c, d, e, f, K(0x243185beul));\n+    Round(f, g, h, a, b, c, d, e, K(0x550c7dc3ul));\n+    Round(e, f, g, h, a, b, c, d, K(0x72be5d74ul));\n+    Round(d, e, f, g, h, a, b, c, K(0x80deb1feul));\n+    Round(c, d, e, f, g, h, a, b, K(0x9bdc06a7ul));\n+    Round(b, c, d, e, f, g, h, a, K(0xc19bf274ul));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xe49b69c1ul), Inc(w0, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xefbe4786ul), Inc(w1, K(0xa00000ul), sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x0fc19dc6ul), Inc(w2, sigma1(w0), sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x240ca1ccul), Inc(w3, sigma1(w1), sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x2de92c6ful), Inc(w4, sigma1(w2), sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4a7484aaul), Inc(w5, sigma1(w3), sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5cb0a9dcul), Inc(w6, sigma1(w4), K(0x100ul), sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x76f988daul), Inc(w7, sigma1(w5), w0, K(0x11002000ul))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x983e5152ul), w8 = Add(K(0x80000000ul), sigma1(w6), w1)));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa831c66dul), w9 = Add(sigma1(w7), w2)));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xb00327c8ul), w10 = Add(sigma1(w8), w3)));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xbf597fc7ul), w11 = Add(sigma1(w9), w4)));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xc6e00bf3ul), w12 = Add(sigma1(w10), w5)));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd5a79147ul), w13 = Add(sigma1(w11), w6)));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x06ca6351ul), w14 = Add(sigma1(w12), w7, K(0x400022ul))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x14292967ul), w15 = Add(K(0x100ul), sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x27b70a85ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x2e1b2138ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x4d2c6dfcul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x53380d13ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x650a7354ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x766a0abbul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x81c2c92eul), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x92722c85ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0xa2bfe8a1ul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0xa81a664bul), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0xc24b8b70ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0xc76c51a3ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0xd192e819ul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xd6990624ul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xf40e3585ul), Inc(w14, sigma1(w12), w7, sigma0(w15))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x106aa070ul), Inc(w15, sigma1(w13), w8, sigma0(w0))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x19a4c116ul), Inc(w0, sigma1(w14), w9, sigma0(w1))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x1e376c08ul), Inc(w1, sigma1(w15), w10, sigma0(w2))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x2748774cul), Inc(w2, sigma1(w0), w11, sigma0(w3))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x34b0bcb5ul), Inc(w3, sigma1(w1), w12, sigma0(w4))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x391c0cb3ul), Inc(w4, sigma1(w2), w13, sigma0(w5))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0x4ed8aa4aul), Inc(w5, sigma1(w3), w14, sigma0(w6))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0x5b9cca4ful), Inc(w6, sigma1(w4), w15, sigma0(w7))));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0x682e6ff3ul), Inc(w7, sigma1(w5), w0, sigma0(w8))));\n+    Round(a, b, c, d, e, f, g, h, Add(K(0x748f82eeul), Inc(w8, sigma1(w6), w1, sigma0(w9))));\n+    Round(h, a, b, c, d, e, f, g, Add(K(0x78a5636ful), Inc(w9, sigma1(w7), w2, sigma0(w10))));\n+    Round(g, h, a, b, c, d, e, f, Add(K(0x84c87814ul), Inc(w10, sigma1(w8), w3, sigma0(w11))));\n+    Round(f, g, h, a, b, c, d, e, Add(K(0x8cc70208ul), Inc(w11, sigma1(w9), w4, sigma0(w12))));\n+    Round(e, f, g, h, a, b, c, d, Add(K(0x90befffaul), Inc(w12, sigma1(w10), w5, sigma0(w13))));\n+    Round(d, e, f, g, h, a, b, c, Add(K(0xa4506cebul), Inc(w13, sigma1(w11), w6, sigma0(w14))));\n+    Round(c, d, e, f, g, h, a, b, Add(K(0xbef9a3f7ul), w14, sigma1(w12), w7, sigma0(w15)));\n+    Round(b, c, d, e, f, g, h, a, Add(K(0xc67178f2ul), w15, sigma1(w13), w8, sigma0(w0)));\n+\n+    // Output\n+    Write4(out, 0, Add(a, K(0x6a09e667ul)));\n+    Write4(out, 4, Add(b, K(0xbb67ae85ul)));\n+    Write4(out, 8, Add(c, K(0x3c6ef372ul)));\n+    Write4(out, 12, Add(d, K(0xa54ff53aul)));\n+    Write4(out, 16, Add(e, K(0x510e527ful)));\n+    Write4(out, 20, Add(f, K(0x9b05688cul)));\n+    Write4(out, 24, Add(g, K(0x1f83d9abul)));\n+    Write4(out, 28, Add(h, K(0x5be0cd19ul)));\n+}\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "738166dc94aafca2642736259cab32496c3cec2d",
        "filename": "src/index/base.cpp",
        "status": "added",
        "additions": 278,
        "deletions": 0,
        "changes": 278,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,278 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <index/base.h>\n+#include <init.h>\n+#include <tinyformat.h>\n+#include <ui_interface.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <warnings.h>\n+\n+constexpr char DB_BEST_BLOCK = 'B';\n+\n+constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n+constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n+\n+template<typename... Args>\n+static void FatalError(const char* fmt, const Args&... args)\n+{\n+    std::string strMessage = tfm::format(fmt, args...);\n+    SetMiscWarning(strMessage);\n+    LogPrintf(\"*** %s\\n\", strMessage);\n+    uiInterface.ThreadSafeMessageBox(\n+        \"Error: A fatal internal error occurred, see debug.log for details\",\n+        \"\", CClientUIInterface::MSG_ERROR);\n+    StartShutdown();\n+}\n+\n+BaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n+    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)\n+{}\n+\n+bool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const\n+{\n+    bool success = Read(DB_BEST_BLOCK, locator);\n+    if (!success) {\n+        locator.SetNull();\n+    }\n+    return success;\n+}\n+\n+bool BaseIndex::DB::WriteBestBlock(const CBlockLocator& locator)\n+{\n+    return Write(DB_BEST_BLOCK, locator);\n+}\n+\n+BaseIndex::~BaseIndex()\n+{\n+    Interrupt();\n+    Stop();\n+}\n+\n+bool BaseIndex::Init()\n+{\n+    CBlockLocator locator;\n+    if (!GetDB().ReadBestBlock(locator)) {\n+        locator.SetNull();\n+    }\n+\n+    LOCK(cs_main);\n+    m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n+    m_synced = m_best_block_index.load() == chainActive.Tip();\n+    return true;\n+}\n+\n+static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    if (!pindex_prev) {\n+        return chainActive.Genesis();\n+    }\n+\n+    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n+    if (pindex) {\n+        return pindex;\n+    }\n+\n+    return chainActive.Next(chainActive.FindFork(pindex_prev));\n+}\n+\n+void BaseIndex::ThreadSync()\n+{\n+    const CBlockIndex* pindex = m_best_block_index.load();\n+    if (!m_synced) {\n+        auto& consensus_params = Params().GetConsensus();\n+\n+        int64_t last_log_time = 0;\n+        int64_t last_locator_write_time = 0;\n+        while (true) {\n+            if (m_interrupt) {\n+                WriteBestBlock(pindex);\n+                return;\n+            }\n+\n+            {\n+                LOCK(cs_main);\n+                const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n+                if (!pindex_next) {\n+                    WriteBestBlock(pindex);\n+                    m_best_block_index = pindex;\n+                    m_synced = true;\n+                    break;\n+                }\n+                pindex = pindex_next;\n+            }\n+\n+            int64_t current_time = GetTime();\n+            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n+                LogPrintf(\"Syncing %s with block chain from height %d\\n\",\n+                          GetName(), pindex->nHeight);\n+                last_log_time = current_time;\n+            }\n+\n+            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n+                WriteBestBlock(pindex);\n+                last_locator_write_time = current_time;\n+            }\n+\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n+                FatalError(\"%s: Failed to read block %s from disk\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+            if (!WriteBlock(block, pindex)) {\n+                FatalError(\"%s: Failed to write block %s to index database\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+        }\n+    }\n+\n+    if (pindex) {\n+        LogPrintf(\"%s is enabled at height %d\\n\", GetName(), pindex->nHeight);\n+    } else {\n+        LogPrintf(\"%s is enabled\\n\", GetName());\n+    }\n+}\n+\n+bool BaseIndex::WriteBestBlock(const CBlockIndex* block_index)\n+{\n+    LOCK(cs_main);\n+    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) {\n+        return error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+    return true;\n+}\n+\n+void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                               const std::vector<CTransactionRef>& txn_conflicted)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (!best_block_index) {\n+        if (pindex->nHeight != 0) {\n+            FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n+                       __func__, pindex->nHeight);\n+            return;\n+        }\n+    } else {\n+        // Ensure block connects to an ancestor of the current best block. This should be the case\n+        // most of the time, but may not be immediately after the sync thread catches up and sets\n+        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n+        // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n+        // new chain tip. In this unlikely event, log a warning and let the queue clear.\n+        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n+            LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n+                      \"known best chain (tip=%s); not updating index\\n\",\n+                      __func__, pindex->GetBlockHash().ToString(),\n+                      best_block_index->GetBlockHash().ToString());\n+            return;\n+        }\n+    }\n+\n+    if (WriteBlock(*block, pindex)) {\n+        m_best_block_index = pindex;\n+    } else {\n+        FatalError(\"%s: Failed to write block %s to index\",\n+                   __func__, pindex->GetBlockHash().ToString());\n+        return;\n+    }\n+}\n+\n+void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const uint256& locator_tip_hash = locator.vHave.front();\n+    const CBlockIndex* locator_tip_index;\n+    {\n+        LOCK(cs_main);\n+        locator_tip_index = LookupBlockIndex(locator_tip_hash);\n+    }\n+\n+    if (!locator_tip_index) {\n+        FatalError(\"%s: First block (hash=%s) in locator was not found\",\n+                   __func__, locator_tip_hash.ToString());\n+        return;\n+    }\n+\n+    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n+    // immediately after the sync thread catches up and sets m_synced. Consider the case where\n+    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n+    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n+    // event, log a warning and let the queue clear.\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n+        LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n+                  \"chain (tip=%s); not writing index locator\\n\",\n+                  __func__, locator_tip_hash.ToString(),\n+                  best_block_index->GetBlockHash().ToString());\n+        return;\n+    }\n+\n+    if (!GetDB().WriteBestBlock(locator)) {\n+        error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+}\n+\n+bool BaseIndex::BlockUntilSyncedToCurrentChain()\n+{\n+    AssertLockNotHeld(cs_main);\n+\n+    if (!m_synced) {\n+        return false;\n+    }\n+\n+    {\n+        // Skip the queue-draining stuff if we know we're caught up with\n+        // chainActive.Tip().\n+        LOCK(cs_main);\n+        const CBlockIndex* chain_tip = chainActive.Tip();\n+        const CBlockIndex* best_block_index = m_best_block_index.load();\n+        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n+            return true;\n+        }\n+    }\n+\n+    LogPrintf(\"%s: %s is catching up on block notifications\\n\", __func__, GetName());\n+    SyncWithValidationInterfaceQueue();\n+    return true;\n+}\n+\n+void BaseIndex::Interrupt()\n+{\n+    m_interrupt();\n+}\n+\n+void BaseIndex::Start()\n+{\n+    // Need to register this ValidationInterface before running Init(), so that\n+    // callbacks are not missed if Init sets m_synced to true.\n+    RegisterValidationInterface(this);\n+    if (!Init()) {\n+        FatalError(\"%s: %s failed to initialize\", __func__, GetName());\n+        return;\n+    }\n+\n+    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, GetName(),\n+                                std::bind(&BaseIndex::ThreadSync, this));\n+}\n+\n+void BaseIndex::Stop()\n+{\n+    UnregisterValidationInterface(this);\n+\n+    if (m_thread_sync.joinable()) {\n+        m_thread_sync.join();\n+    }\n+}"
      },
      {
        "sha": "04ee6e6cc2dac672c342e40a0332932fb99b25dd",
        "filename": "src/index/base.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INDEX_BASE_H\n+#define BITCOIN_INDEX_BASE_H\n+\n+#include <dbwrapper.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <threadinterrupt.h>\n+#include <uint256.h>\n+#include <validationinterface.h>\n+\n+class CBlockIndex;\n+\n+/**\n+ * Base class for indices of blockchain data. This implements\n+ * CValidationInterface and ensures blocks are indexed sequentially according\n+ * to their position in the active chain.\n+ */\n+class BaseIndex : public CValidationInterface\n+{\n+protected:\n+    class DB : public CDBWrapper\n+    {\n+    public:\n+        DB(const fs::path& path, size_t n_cache_size,\n+           bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);\n+\n+        /// Read block locator of the chain that the txindex is in sync with.\n+        bool ReadBestBlock(CBlockLocator& locator) const;\n+\n+        /// Write block locator of the chain that the txindex is in sync with.\n+        bool WriteBestBlock(const CBlockLocator& locator);\n+    };\n+\n+private:\n+    /// Whether the index is in sync with the main chain. The flag is flipped\n+    /// from false to true once, after which point this starts processing\n+    /// ValidationInterface notifications to stay in sync.\n+    std::atomic<bool> m_synced{false};\n+\n+    /// The last block in the chain that the index is in sync with.\n+    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};\n+\n+    std::thread m_thread_sync;\n+    CThreadInterrupt m_interrupt;\n+\n+    /// Sync the index with the block index starting from the current best block.\n+    /// Intended to be run in its own thread, m_thread_sync, and can be\n+    /// interrupted with m_interrupt. Once the index gets in sync, the m_synced\n+    /// flag is set and the BlockConnected ValidationInterface callback takes\n+    /// over and the sync thread exits.\n+    void ThreadSync();\n+\n+    /// Write the current chain block locator to the DB.\n+    bool WriteBestBlock(const CBlockIndex* block_index);\n+\n+protected:\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                        const std::vector<CTransactionRef>& txn_conflicted) override;\n+\n+    void ChainStateFlushed(const CBlockLocator& locator) override;\n+\n+    /// Initialize internal state from the database and block index.\n+    virtual bool Init();\n+\n+    /// Write update index entries for a newly connected block.\n+    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n+\n+    virtual DB& GetDB() const = 0;\n+\n+    /// Get the name of the index for display in logs.\n+    virtual const char* GetName() const = 0;\n+\n+public:\n+    /// Destructor interrupts sync thread if running and blocks until it exits.\n+    virtual ~BaseIndex();\n+\n+    /// Blocks the current thread until the index is caught up to the current\n+    /// state of the block chain. This only blocks if the index has gotten in\n+    /// sync once and only needs to process blocks in the ValidationInterface\n+    /// queue. If the index is catching up from far behind, this method does\n+    /// not block and immediately returns false.\n+    bool BlockUntilSyncedToCurrentChain();\n+\n+    void Interrupt();\n+\n+    /// Start initializes the sync state and registers the instance as a\n+    /// ValidationInterface so that it stays in sync with blockchain updates.\n+    void Start();\n+\n+    /// Stops the instance from staying in sync with blockchain updates.\n+    void Stop();\n+};\n+\n+#endif // BITCOIN_INDEX_BASE_H"
      },
      {
        "sha": "e106b9b42095ab33f035d4ba199da9fbcb25a9f0",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 197,
        "deletions": 222,
        "changes": 419,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,258 +2,261 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <chainparams.h>\n #include <index/txindex.h>\n #include <init.h>\n-#include <tinyformat.h>\n #include <ui_interface.h>\n #include <util.h>\n #include <validation.h>\n-#include <warnings.h>\n \n-constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n-constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n+#include <boost/thread.hpp>\n+\n+constexpr char DB_BEST_BLOCK = 'B';\n+constexpr char DB_TXINDEX = 't';\n+constexpr char DB_TXINDEX_BLOCK = 'T';\n \n std::unique_ptr<TxIndex> g_txindex;\n \n-template<typename... Args>\n-static void FatalError(const char* fmt, const Args&... args)\n+struct CDiskTxPos : public CDiskBlockPos\n {\n-    std::string strMessage = tfm::format(fmt, args...);\n-    SetMiscWarning(strMessage);\n-    LogPrintf(\"*** %s\\n\", strMessage);\n-    uiInterface.ThreadSafeMessageBox(\n-        \"Error: A fatal internal error occurred, see debug.log for details\",\n-        \"\", CClientUIInterface::MSG_ERROR);\n-    StartShutdown();\n-}\n+    unsigned int nTxOffset; // after header\n \n-TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) :\n-    m_db(std::move(db)), m_synced(false), m_best_block_index(nullptr)\n-{}\n+    ADD_SERIALIZE_METHODS;\n \n-TxIndex::~TxIndex()\n-{\n-    Interrupt();\n-    Stop();\n-}\n-\n-bool TxIndex::Init()\n-{\n-    LOCK(cs_main);\n-\n-    // Attempt to migrate txindex from the old database to the new one. Even if\n-    // chain_tip is null, the node could be reindexing and we still want to\n-    // delete txindex records in the old database.\n-    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) {\n-        return false;\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITEAS(CDiskBlockPos, *this);\n+        READWRITE(VARINT(nTxOffset));\n     }\n \n-    CBlockLocator locator;\n-    if (!m_db->ReadBestBlock(locator)) {\n-        locator.SetNull();\n+    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n     }\n \n-    m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n-    m_synced = m_best_block_index.load() == chainActive.Tip();\n-    return true;\n-}\n-\n-static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n-{\n-    AssertLockHeld(cs_main);\n-\n-    if (!pindex_prev) {\n-        return chainActive.Genesis();\n+    CDiskTxPos() {\n+        SetNull();\n     }\n \n-    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n-    if (pindex) {\n-        return pindex;\n+    void SetNull() {\n+        CDiskBlockPos::SetNull();\n+        nTxOffset = 0;\n     }\n-\n-    return chainActive.Next(chainActive.FindFork(pindex_prev));\n-}\n-\n-void TxIndex::ThreadSync()\n+};\n+\n+/**\n+ * Access to the txindex database (indexes/txindex/)\n+ *\n+ * The database stores a block locator of the chain the database is synced to\n+ * so that the TxIndex can efficiently determine the point it last stopped at.\n+ * A locator is used instead of a simple hash of the chain tip because blocks\n+ * and block index entries may not be flushed to disk until after this database\n+ * is updated.\n+ */\n+class TxIndex::DB : public BaseIndex::DB\n {\n-    const CBlockIndex* pindex = m_best_block_index.load();\n-    if (!m_synced) {\n-        auto& consensus_params = Params().GetConsensus();\n-\n-        int64_t last_log_time = 0;\n-        int64_t last_locator_write_time = 0;\n-        while (true) {\n-            if (m_interrupt) {\n-                WriteBestBlock(pindex);\n-                return;\n-            }\n+public:\n+    explicit DB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n \n-            {\n-                LOCK(cs_main);\n-                const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n-                if (!pindex_next) {\n-                    WriteBestBlock(pindex);\n-                    m_best_block_index = pindex;\n-                    m_synced = true;\n-                    break;\n-                }\n-                pindex = pindex_next;\n-            }\n+    /// Read the disk location of the transaction data with the given hash. Returns false if the\n+    /// transaction hash is not indexed.\n+    bool ReadTxPos(const uint256& txid, CDiskTxPos& pos) const;\n \n-            int64_t current_time = GetTime();\n-            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n-                LogPrintf(\"Syncing txindex with block chain from height %d\\n\", pindex->nHeight);\n-                last_log_time = current_time;\n-            }\n+    /// Write a batch of transaction positions to the DB.\n+    bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n \n-            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n-                WriteBestBlock(pindex);\n-                last_locator_write_time = current_time;\n-            }\n+    /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n+    /// been upgraded yet to the new database.\n+    bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n+};\n \n-            CBlock block;\n-            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n-                FatalError(\"%s: Failed to read block %s from disk\",\n-                           __func__, pindex->GetBlockHash().ToString());\n-                return;\n-            }\n-            if (!WriteBlock(block, pindex)) {\n-                FatalError(\"%s: Failed to write block %s to tx index database\",\n-                           __func__, pindex->GetBlockHash().ToString());\n-                return;\n-            }\n-        }\n-    }\n+TxIndex::DB::DB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n+    BaseIndex::DB(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n+{}\n \n-    if (pindex) {\n-        LogPrintf(\"txindex is enabled at height %d\\n\", pindex->nHeight);\n-    } else {\n-        LogPrintf(\"txindex is enabled\\n\");\n-    }\n+bool TxIndex::DB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n+{\n+    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n }\n \n-bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+bool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos)\n {\n-    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n-    std::vector<std::pair<uint256, CDiskTxPos>> vPos;\n-    vPos.reserve(block.vtx.size());\n-    for (const auto& tx : block.vtx) {\n-        vPos.emplace_back(tx->GetHash(), pos);\n-        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);\n+    CDBBatch batch(*this);\n+    for (const auto& tuple : v_pos) {\n+        batch.Write(std::make_pair(DB_TXINDEX, tuple.first), tuple.second);\n     }\n-    return m_db->WriteTxs(vPos);\n+    return WriteBatch(batch);\n }\n \n-bool TxIndex::WriteBestBlock(const CBlockIndex* block_index)\n+/*\n+ * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n+ * range of keys updated. This is used internally by MigrateData.\n+ */\n+static void WriteTxIndexMigrationBatches(CDBWrapper& newdb, CDBWrapper& olddb,\n+                                         CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n+                                         const std::pair<unsigned char, uint256>& begin_key,\n+                                         const std::pair<unsigned char, uint256>& end_key)\n {\n-    LOCK(cs_main);\n-    if (!m_db->WriteBestBlock(chainActive.GetLocator(block_index))) {\n-        return error(\"%s: Failed to write locator to disk\", __func__);\n-    }\n-    return true;\n+    // Sync new DB changes to disk before deleting from old DB.\n+    newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n+    olddb.WriteBatch(batch_olddb);\n+    olddb.CompactRange(begin_key, end_key);\n+\n+    batch_newdb.Clear();\n+    batch_olddb.Clear();\n }\n \n-void TxIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n-                    const std::vector<CTransactionRef>& txn_conflicted)\n+bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n {\n-    if (!m_synced) {\n-        return;\n-    }\n-\n-    const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (!best_block_index) {\n-        if (pindex->nHeight != 0) {\n-            FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n-                       __func__, pindex->nHeight);\n-            return;\n+    // The prior implementation of txindex was always in sync with block index\n+    // and presence was indicated with a boolean DB flag. If the flag is set,\n+    // this means the txindex from a previous version is valid and in sync with\n+    // the chain tip. The first step of the migration is to unset the flag and\n+    // write the chain hash to a separate key, DB_TXINDEX_BLOCK. After that, the\n+    // index entries are copied over in batches to the new database. Finally,\n+    // DB_TXINDEX_BLOCK is erased from the old database and the block hash is\n+    // written to the new database.\n+    //\n+    // Unsetting the boolean flag ensures that if the node is downgraded to a\n+    // previous version, it will not see a corrupted, partially migrated index\n+    // -- it will see that the txindex is disabled. When the node is upgraded\n+    // again, the migration will pick up where it left off and sync to the block\n+    // with hash DB_TXINDEX_BLOCK.\n+    bool f_legacy_flag = false;\n+    block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n+    if (f_legacy_flag) {\n+        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n+            return error(\"%s: cannot write block indicator\", __func__);\n         }\n-    } else {\n-        // Ensure block connects to an ancestor of the current best block. This should be the case\n-        // most of the time, but may not be immediately after the the sync thread catches up and sets\n-        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n-        // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n-        // new chain tip. In this unlikely event, log a warning and let the queue clear.\n-        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n-            LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n-                      \"known best chain (tip=%s); not updating txindex\\n\",\n-                      __func__, pindex->GetBlockHash().ToString(),\n-                      best_block_index->GetBlockHash().ToString());\n-            return;\n+        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n+            return error(\"%s: cannot write block index db flag\", __func__);\n         }\n     }\n \n-    if (WriteBlock(*block, pindex)) {\n-        m_best_block_index = pindex;\n-    } else {\n-        FatalError(\"%s: Failed to write block %s to txindex\",\n-                   __func__, pindex->GetBlockHash().ToString());\n-        return;\n+    CBlockLocator locator;\n+    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n+        return true;\n     }\n-}\n \n-void TxIndex::ChainStateFlushed(const CBlockLocator& locator)\n-{\n-    if (!m_synced) {\n-        return;\n-    }\n+    int64_t count = 0;\n+    LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n+    uiInterface.ShowProgress(_(\"Upgrading txindex database\"), 0, true);\n+    int report_done = 0;\n+    const size_t batch_size = 1 << 24; // 16 MiB\n+\n+    CDBBatch batch_newdb(*this);\n+    CDBBatch batch_olddb(block_tree_db);\n+\n+    std::pair<unsigned char, uint256> key;\n+    std::pair<unsigned char, uint256> begin_key{DB_TXINDEX, uint256()};\n+    std::pair<unsigned char, uint256> prev_key = begin_key;\n+\n+    bool interrupted = false;\n+    std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n+    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n+        boost::this_thread::interruption_point();\n+        if (ShutdownRequested()) {\n+            interrupted = true;\n+            break;\n+        }\n \n-    const uint256& locator_tip_hash = locator.vHave.front();\n-    const CBlockIndex* locator_tip_index;\n-    {\n-        LOCK(cs_main);\n-        locator_tip_index = LookupBlockIndex(locator_tip_hash);\n-    }\n+        if (!cursor->GetKey(key)) {\n+            return error(\"%s: cannot get key from valid cursor\", __func__);\n+        }\n+        if (key.first != DB_TXINDEX) {\n+            break;\n+        }\n \n-    if (!locator_tip_index) {\n-        FatalError(\"%s: First block (hash=%s) in locator was not found\",\n-                   __func__, locator_tip_hash.ToString());\n-        return;\n+        // Log progress every 10%.\n+        if (++count % 256 == 0) {\n+            // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n+            // of the hash can be used to estimate the current progress.\n+            const uint256& txid = key.second;\n+            uint32_t high_nibble =\n+                (static_cast<uint32_t>(*(txid.begin() + 0)) << 8) +\n+                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\n+            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n+\n+            uiInterface.ShowProgress(_(\"Upgrading txindex database\"), percentage_done, true);\n+            if (report_done < percentage_done/10) {\n+                LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n+                report_done = percentage_done/10;\n+            }\n+        }\n+\n+        CDiskTxPos value;\n+        if (!cursor->GetValue(value)) {\n+            return error(\"%s: cannot parse txindex record\", __func__);\n+        }\n+        batch_newdb.Write(key, value);\n+        batch_olddb.Erase(key);\n+\n+        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n+            // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n+            // because LevelDB iterators are guaranteed to provide a consistent view of the\n+            // underlying data, like a lightweight snapshot.\n+            WriteTxIndexMigrationBatches(*this, block_tree_db,\n+                                         batch_newdb, batch_olddb,\n+                                         prev_key, key);\n+            prev_key = key;\n+        }\n     }\n \n-    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n-    // immediately after the the sync thread catches up and sets m_synced. Consider the case where\n-    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n-    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n-    // event, log a warning and let the queue clear.\n-    const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n-        LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n-                  \"chain (tip=%s); not writing txindex locator\\n\",\n-                  __func__, locator_tip_hash.ToString(),\n-                  best_block_index->GetBlockHash().ToString());\n-        return;\n+    // If these final DB batches complete the migration, write the best block\n+    // hash marker to the new database and delete from the old one. This signals\n+    // that the former is fully caught up to that point in the blockchain and\n+    // that all txindex entries have been removed from the latter.\n+    if (!interrupted) {\n+        batch_olddb.Erase(DB_TXINDEX_BLOCK);\n+        batch_newdb.Write(DB_BEST_BLOCK, locator);\n     }\n \n-    if (!m_db->WriteBestBlock(locator)) {\n-        error(\"%s: Failed to write locator to disk\", __func__);\n+    WriteTxIndexMigrationBatches(*this, block_tree_db,\n+                                 batch_newdb, batch_olddb,\n+                                 begin_key, key);\n+\n+    if (interrupted) {\n+        LogPrintf(\"[CANCELLED].\\n\");\n+        return false;\n     }\n+\n+    uiInterface.ShowProgress(\"\", 100, false);\n+\n+    LogPrintf(\"[DONE].\\n\");\n+    return true;\n }\n \n-bool TxIndex::BlockUntilSyncedToCurrentChain()\n+TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_db(MakeUnique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n+{}\n+\n+TxIndex::~TxIndex() {}\n+\n+bool TxIndex::Init()\n {\n-    AssertLockNotHeld(cs_main);\n+    LOCK(cs_main);\n \n-    if (!m_synced) {\n+    // Attempt to migrate txindex from the old database to the new one. Even if\n+    // chain_tip is null, the node could be reindexing and we still want to\n+    // delete txindex records in the old database.\n+    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) {\n         return false;\n     }\n \n-    {\n-        // Skip the queue-draining stuff if we know we're caught up with\n-        // chainActive.Tip().\n-        LOCK(cs_main);\n-        const CBlockIndex* chain_tip = chainActive.Tip();\n-        const CBlockIndex* best_block_index = m_best_block_index.load();\n-        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n-            return true;\n-        }\n-    }\n+    return BaseIndex::Init();\n+}\n \n-    LogPrintf(\"%s: txindex is catching up on block notifications\\n\", __func__);\n-    SyncWithValidationInterfaceQueue();\n-    return true;\n+bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n+    std::vector<std::pair<uint256, CDiskTxPos>> vPos;\n+    vPos.reserve(block.vtx.size());\n+    for (const auto& tx : block.vtx) {\n+        vPos.emplace_back(tx->GetHash(), pos);\n+        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);\n+    }\n+    return m_db->WriteTxs(vPos);\n }\n \n+BaseIndex::DB& TxIndex::GetDB() const { return *m_db; }\n+\n bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const\n {\n     CDiskTxPos postx;\n@@ -281,31 +284,3 @@ bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRe\n     block_hash = header.GetHash();\n     return true;\n }\n-\n-void TxIndex::Interrupt()\n-{\n-    m_interrupt();\n-}\n-\n-void TxIndex::Start()\n-{\n-    // Need to register this ValidationInterface before running Init(), so that\n-    // callbacks are not missed if Init sets m_synced to true.\n-    RegisterValidationInterface(this);\n-    if (!Init()) {\n-        FatalError(\"%s: txindex failed to initialize\", __func__);\n-        return;\n-    }\n-\n-    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, \"txindex\",\n-                                std::bind(&TxIndex::ThreadSync, this));\n-}\n-\n-void TxIndex::Stop()\n-{\n-    UnregisterValidationInterface(this);\n-\n-    if (m_thread_sync.joinable()) {\n-        m_thread_sync.join();\n-    }\n-}"
      },
      {
        "sha": "8202c3c951f1229ae2d5242372273323e4e8c3c5",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 17,
        "deletions": 57,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -5,70 +5,39 @@\n #ifndef BITCOIN_INDEX_TXINDEX_H\n #define BITCOIN_INDEX_TXINDEX_H\n \n-#include <primitives/block.h>\n-#include <primitives/transaction.h>\n-#include <threadinterrupt.h>\n+#include <chain.h>\n+#include <index/base.h>\n #include <txdb.h>\n-#include <uint256.h>\n-#include <validationinterface.h>\n-\n-class CBlockIndex;\n \n /**\n  * TxIndex is used to look up transactions included in the blockchain by hash.\n  * The index is written to a LevelDB database and records the filesystem\n  * location of each transaction by transaction hash.\n  */\n-class TxIndex final : public CValidationInterface\n+class TxIndex final : public BaseIndex\n {\n-private:\n-    const std::unique_ptr<TxIndexDB> m_db;\n-\n-    /// Whether the index is in sync with the main chain. The flag is flipped\n-    /// from false to true once, after which point this starts processing\n-    /// ValidationInterface notifications to stay in sync.\n-    std::atomic<bool> m_synced;\n-\n-    /// The last block in the chain that the TxIndex is in sync with.\n-    std::atomic<const CBlockIndex*> m_best_block_index;\n-\n-    std::thread m_thread_sync;\n-    CThreadInterrupt m_interrupt;\n-\n-    /// Initialize internal state from the database and block index.\n-    bool Init();\n+protected:\n+    class DB;\n \n-    /// Sync the tx index with the block index starting from the current best\n-    /// block. Intended to be run in its own thread, m_thread_sync, and can be\n-    /// interrupted with m_interrupt. Once the txindex gets in sync, the\n-    /// m_synced flag is set and the BlockConnected ValidationInterface callback\n-    /// takes over and the sync thread exits.\n-    void ThreadSync();\n+private:\n+    const std::unique_ptr<DB> m_db;\n \n-    /// Write update index entries for a newly connected block.\n-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex);\n+protected:\n+    /// Override base class init to migrate from old database.\n+    bool Init() override;\n \n-    /// Write the current chain block locator to the DB.\n-    bool WriteBestBlock(const CBlockIndex* block_index);\n+    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;\n \n-protected:\n-    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n-                        const std::vector<CTransactionRef>& txn_conflicted) override;\n+    BaseIndex::DB& GetDB() const override;\n \n-    void ChainStateFlushed(const CBlockLocator& locator) override;\n+    const char* GetName() const override { return \"txindex\"; }\n \n public:\n-    /// Constructs the TxIndex, which becomes available to be queried.\n-    explicit TxIndex(std::unique_ptr<TxIndexDB> db);\n-\n-    /// Destructor interrupts sync thread if running and blocks until it exits.\n-    ~TxIndex();\n+    /// Constructs the index, which becomes available to be queried.\n+    explicit TxIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n \n-    /// Blocks the current thread until the transaction index is caught up to\n-    /// the current state of the block chain. This only blocks if the index has gotten in sync once\n-    /// and only needs to process blocks in the ValidationInterface queue. If the index is catching\n-    /// up from far behind, this method does not block and immediately returns false.\n-    bool BlockUntilSyncedToCurrentChain();\n+    // Destructor is declared because this class contains a unique_ptr to an incomplete type.\n+    virtual ~TxIndex() override;\n \n     /// Look up a transaction by hash.\n     ///\n@@ -77,15 +46,6 @@ class TxIndex final : public CValidationInterface\n     /// @param[out]  tx  The transaction itself.\n     /// @return  true if transaction is found, false otherwise\n     bool FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const;\n-\n-    void Interrupt();\n-\n-    /// Start initializes the sync state and registers the instance as a\n-    /// ValidationInterface so that it stays in sync with blockchain updates.\n-    void Start();\n-\n-    /// Stops the instance from staying in sync with blockchain updates.\n-    void Stop();\n };\n \n /// The global transaction index, used in GetTransaction. May be null."
      },
      {
        "sha": "5e452779860bfad8ee3118fe9d9a90e2dfa820c1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 139,
        "deletions": 102,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -76,7 +76,7 @@ std::unique_ptr<PeerLogicValidation> peerLogic;\n class DummyWalletInit : public WalletInitInterface {\n public:\n \n-    void AddWalletOptions() const override {}\n+    void AddWalletOptions() const override;\n     bool ParameterInteraction() const override {return true;}\n     void RegisterRPC(CRPCTable &) const override {}\n     bool Verify() const override {return true;}\n@@ -87,6 +87,15 @@ class DummyWalletInit : public WalletInitInterface {\n     void Close() const override {}\n };\n \n+void DummyWalletInit::AddWalletOptions() const\n+{\n+    std::vector<std::string> opts = {\"-addresstype\", \"-changetype\", \"-disablewallet\", \"-discardfee=<amt>\", \"-fallbackfee=<amt>\",\n+        \"-keypool=<n>\", \"-mintxfee=<amt>\", \"-paytxfee=<amt>\", \"-rescan\", \"-salvagewallet\", \"-spendzeroconfchange\",  \"-txconfirmtarget=<n>\",\n+        \"-upgradewallet\", \"-wallet=<path>\", \"-walletbroadcast\", \"-walletdir=<dir>\", \"-walletnotify=<cmd>\", \"-walletrbf\", \"-zapwallettxes=<mode>\",\n+        \"-dblogsize=<n>\", \"-flushwallet\", \"-privdb\", \"-walletrejectlongchains\"};\n+    gArgs.AddHiddenArgs(opts);\n+}\n+\n const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();\n #endif\n \n@@ -348,95 +357,112 @@ void SetupServerArgs()\n     const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);\n     const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n \n+    // Hidden Options\n+    std::vector<std::string> hidden_args = {\"-rpcssl\", \"-benchmark\", \"-h\", \"-help\", \"-socks\", \"-tor\", \"-debugnet\", \"-whitelistalwaysrelay\",\n+        \"-prematurewitness\", \"-walletprematurewitness\", \"-promiscuousmempoolflags\", \"-blockminsize\", \"-dbcrashratio\", \"-forcecompactdb\", \"-usehd\",\n+        // GUI args. These will be overwritten by SetupUIArgs for the GUI\n+        \"-allowselfsignedrootcertificates\", \"-choosedatadir\", \"-lang=<lang>\", \"-min\", \"-resetguisettings\", \"-rootcertificates=<file>\", \"-splash\", \"-uiplatform\"};\n+\n     // Set all of the args and their help\n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n-    // Do not translate _(...) -help-debug options, Many technical terms, and only a very small audience, so is unnecessary stress to translators.\n-    gArgs.AddArg(\"-?\", _(\"Print this help message and exit\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-version\", _(\"Print version and exit\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-blocksdir=<dir>\", _(\"Specify blocks directory (default: <datadir>/blocks)\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY), true, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-datadir=<dir>\", _(\"Specify data directory\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-?\", \"Print this help message and exit\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-version\", \"Print version and exit\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-alertnotify=<cmd>\", \"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-assumevalid=<hex>\", strprintf(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\", defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocksdir=<dir>\", \"Specify blocks directory (default: <datadir>/blocks)\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocknotify=<cmd>\", \"Execute command when the best block changes (%s in cmd is replaced by block hash)\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to operate in a blocks only mode (default: %u)\", DEFAULT_BLOCKSONLY), true, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-conf=<file>\", strprintf(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\", BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-datadir=<dir>\", \"Specify data directory\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize), true, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-debuglogfile=<file>\", strprintf(_(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-dbcache=<n>\", strprintf(\"Set database cache size in megabytes (%d to %d, default: %d)\", nMinDbCache, nMaxDbCache, nDefaultDbCache), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-debuglogfile=<file>\", strprintf(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER), true, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-includeconf=<file>\", _(\"Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file on startup\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-includeconf=<file>\", \"Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-loadblock=<file>\", \"Imports blocks from external blk000??.dat file on startup\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-maxmempool=<n>\", strprintf(\"Keep the transaction memory pool below <n> megabytes (default: %u)\", DEFAULT_MAX_MEMPOOL_SIZE), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-maxorphantx=<n>\", strprintf(\"Keep at most <n> unconnectable transactions in memory (default: %u)\", DEFAULT_MAX_ORPHAN_TRANSACTIONS), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-mempoolexpiry=<n>\", strprintf(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\", DEFAULT_MEMPOOL_EXPIRY), false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-minimumchainwork=<hex>\", strprintf(\"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\", defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()), true, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n+    gArgs.AddArg(\"-par=<n>\", strprintf(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\",\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-persistmempool\", strprintf(\"Whether to save the mempool on shutdown and load on restart (default: %u)\", DEFAULT_PERSIST_MEMPOOL), false, OptionsCategory::OPTIONS);\n #ifndef WIN32\n-    gArgs.AddArg(\"-pid=<file>\", strprintf(_(\"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), BITCOIN_PID_FILENAME), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-pid=<file>\", strprintf(\"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\", BITCOIN_PID_FILENAME), false, OptionsCategory::OPTIONS);\n+#else\n+    hidden_args.emplace_back(\"-pid\");\n #endif\n-    gArgs.AddArg(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n+    gArgs.AddArg(\"-prune=<n>\", strprintf(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n             \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n-            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-reindex\", _(\"Rebuild chain state and block index from the blk*.dat files on disk\"), false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-reindex-chainstate\", _(\"Rebuild chain state from the currently indexed blocks\"), false, OptionsCategory::OPTIONS);\n+            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\", MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-reindex\", \"Rebuild chain state and block index from the blk*.dat files on disk\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-reindex-chainstate\", \"Rebuild chain state from the currently indexed blocks\", false, OptionsCategory::OPTIONS);\n #ifndef WIN32\n-    gArgs.AddArg(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-sysperms\", \"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\", false, OptionsCategory::OPTIONS);\n+#else\n+    hidden_args.emplace_back(\"-sysperms\");\n #endif\n-    gArgs.AddArg(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX), false, OptionsCategory::OPTIONS);\n-\n-    gArgs.AddArg(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), DEFAULT_MISBEHAVING_BANTIME), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-externalip=<ip>\", _(\"Specify your own public address\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXSENDBUFFER), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-maxtimeadjustment\", strprintf(_(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\"), DEFAULT_MAX_TIME_ADJUSTMENT), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-onion=<ip:port>\", strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-torpassword=<pass>\", _(\"Tor control port password (default: empty)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-txindex\", strprintf(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\", DEFAULT_TXINDEX), false, OptionsCategory::OPTIONS);\n+\n+    gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-banscore=<n>\", strprintf(\"Threshold for disconnecting misbehaving peers (default: %u)\", DEFAULT_BANSCORE_THRESHOLD), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-bantime=<n>\", strprintf(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\", DEFAULT_MISBEHAVING_BANTIME), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-bind=<addr>\", \"Bind to given address and always listen on it. Use [host]:port notation for IPv6\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-connect=<ip>\", \"Connect only to the specified node(s); -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-discover\", \"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-dns\", strprintf(\"Allow DNS lookups for -addnode, -seednode and -connect (default: %u)\", DEFAULT_NAME_LOOKUP), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-dnsseed\", \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-enablebip61\", strprintf(\"Send reject messages per BIP61 (default: %u)\", DEFAULT_ENABLE_BIP61), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-externalip=<ip>\", \"Specify your own public address\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-forcednsseed\", strprintf(\"Always query for peer addresses via DNS lookup (default: %u)\", DEFAULT_FORCEDNSSEED), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-listen\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-listenonion\", strprintf(\"Automatically create Tor hidden service (default: %d)\", DEFAULT_LISTEN_ONION), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxconnections=<n>\", strprintf(\"Maintain at most <n> connections to peers (default: %u)\", DEFAULT_MAX_PEER_CONNECTIONS), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxreceivebuffer=<n>\", strprintf(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\", DEFAULT_MAXRECEIVEBUFFER), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxsendbuffer=<n>\", strprintf(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\", DEFAULT_MAXSENDBUFFER), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-peerbloomfilters\", strprintf(\"Support filtering of blocks and transaction with bloom filters (default: %u)\", DEFAULT_PEERBLOOMFILTERS), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-permitbaremultisig\", strprintf(\"Relay non-P2SH multisig (default: %u)\", DEFAULT_PERMIT_BAREMULTISIG), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-port=<port>\", strprintf(\"Listen for connections on <port> (default: %u or testnet: %u)\", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-proxy=<ip:port>\", \"Connect through SOCKS5 proxy\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-proxyrandomize\", strprintf(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\", DEFAULT_PROXYRANDOMIZE), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-seednode=<ip>\", \"Connect to a node to retrieve peer addresses, and disconnect\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-timeout=<n>\", strprintf(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\", DEFAULT_CONNECT_TIMEOUT), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", false, OptionsCategory::CONNECTION);\n #ifdef USE_UPNP\n #if USE_UPNP\n-    gArgs.AddArg(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", false, OptionsCategory::CONNECTION);\n #else\n-    gArgs.AddArg(\"-upnp\", strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-upnp\", strprintf(\"Use UPnP to map the listening port (default: %u)\", 0), false, OptionsCategory::CONNECTION);\n #endif\n+#else\n+    hidden_args.emplace_back(\"-upnp\");\n #endif\n-    gArgs.AddArg(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"), false, OptionsCategory::CONNECTION);\n-    gArgs.AddArg(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n-        \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-whitebind=<addr>\", \"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-whitelist=<IP address or network>\", \"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\"\n+        \" Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\", false, OptionsCategory::CONNECTION);\n \n     g_wallet_init_interface.AddWalletOptions();\n \n #if ENABLE_ZMQ\n-    gArgs.AddArg(\"-zmqpubhashblock=<address>\", _(\"Enable publish hash block in <address>\"), false, OptionsCategory::ZMQ);\n-    gArgs.AddArg(\"-zmqpubhashtx=<address>\", _(\"Enable publish hash transaction in <address>\"), false, OptionsCategory::ZMQ);\n-    gArgs.AddArg(\"-zmqpubrawblock=<address>\", _(\"Enable publish raw block in <address>\"), false, OptionsCategory::ZMQ);\n-    gArgs.AddArg(\"-zmqpubrawtx=<address>\", _(\"Enable publish raw transaction in <address>\"), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubhashblock=<address>\", \"Enable publish hash block in <address>\", false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubhashtx=<address>\", \"Enable publish hash transaction in <address>\", false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawblock=<address>\", \"Enable publish raw block in <address>\", false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawtx=<address>\", \"Enable publish raw transaction in <address>\", false, OptionsCategory::ZMQ);\n+#else\n+    hidden_args.emplace_back(\"-zmqpubhashblock=<address>\");\n+    hidden_args.emplace_back(\"-zmqpubhashtx=<address>\");\n+    hidden_args.emplace_back(\"-zmqpubrawblock=<address>\");\n+    hidden_args.emplace_back(\"-zmqpubrawtx=<address>\");\n #endif\n \n-    gArgs.AddArg(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS), true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkblocks=<n>\", strprintf(\"How many blocks to check at startup (default: %u, 0 = all)\", DEFAULT_CHECKBLOCKS), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checklevel=<n>\", strprintf(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)\", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED), true, OptionsCategory::DEBUG_TEST);\n@@ -450,55 +476,64 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\", true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-addrmantest\", \"Allows to test address relay on localhost\", true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n-        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\", false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-debugexclude=<category>\", strprintf(_(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\")), false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"), false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS), false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-debug=<category>\", strprintf(\"Output debugging information (default: %u, supplying <category> is optional)\", 0) + \". \" +\n+        \"If <category> is not supplied or if <category> = 1, output all debugging information. <category> can be: \" + ListLogCategories() + \".\", false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-debugexclude=<category>\", strprintf(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\"), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-help-debug\", \"Show all debugging options (usage: --help -help-debug)\", false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-logips\", strprintf(\"Include IP addresses in debug output (default: %u)\", DEFAULT_LOGIPS), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-logtimestamps\", strprintf(\"Prepend debug output with timestamp (default: %u)\", DEFAULT_LOGTIMESTAMPS), false, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\", true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n+    gArgs.AddArg(\"-maxtxfee=<amt>\", strprintf(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\",\n         CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)), false, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-printpriority\", strprintf(\"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY), true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"), false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-shrinkdebugfile\", _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\"), false, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-uacomment=<cmt>\", _(\"Append comment to the user agent string\"), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-printtoconsole\", \"Send trace/debug info to console instead of debug.log file\", false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-shrinkdebugfile\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\", false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-uacomment=<cmt>\", \"Append comment to the user agent string\", false, OptionsCategory::DEBUG_TEST);\n \n     SetupChainParamsBaseOptions();\n \n     gArgs.AddArg(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()), true, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)), true, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)), true, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n+    gArgs.AddArg(\"-bytespersigop\", strprintf(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\", DEFAULT_BYTES_PER_SIGOP), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-datacarrier\", strprintf(\"Relay and mine data carrier transactions (default: %u)\", DEFAULT_ACCEPT_DATACARRIER), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-datacarriersize\", strprintf(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\", MAX_OP_RETURN_RELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-mempoolreplacement\", strprintf(\"Enable transaction replacement in the memory pool (default: %u)\", DEFAULT_ENABLE_REPLACEMENT), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-minrelaytxfee=<amt>\", strprintf(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\",\n         CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY), false, OptionsCategory::NODE_RELAY);\n-    gArgs.AddArg(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-whitelistforcerelay\", strprintf(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\", DEFAULT_WHITELISTFORCERELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-whitelistrelay\", strprintf(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\", DEFAULT_WHITELISTRELAY), false, OptionsCategory::NODE_RELAY);\n \n \n-    gArgs.AddArg(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT), false, OptionsCategory::BLOCK_CREATION);\n-    gArgs.AddArg(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)), false, OptionsCategory::BLOCK_CREATION);\n+    gArgs.AddArg(\"-blockmaxweight=<n>\", strprintf(\"Set maximum BIP141 block weight (default: %d)\", DEFAULT_BLOCK_MAX_WEIGHT), false, OptionsCategory::BLOCK_CREATION);\n+    gArgs.AddArg(\"-blockmintxfee=<amt>\", strprintf(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)), false, OptionsCategory::BLOCK_CREATION);\n     gArgs.AddArg(\"-blockversion=<n>\", \"Override block version to test forking scenarios\", true, OptionsCategory::BLOCK_CREATION);\n \n-    gArgs.AddArg(\"-rest\", strprintf(_(\"Accept public REST requests (default: %u)\"), DEFAULT_REST_ENABLE), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcbind=<addr>[:port]\", _(\"Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpccookiefile=<loc>\", _(\"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\"), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rest\", strprintf(\"Accept public REST requests (default: %u)\", DEFAULT_REST_ENABLE), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcallowip=<ip>\", \"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcauth=<userpw>\", \"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcbind=<addr>[:port]\", \"Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpccookiefile=<loc>\", \"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcpassword=<pw>\", \"Password for JSON-RPC connections\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcport=<port>\", strprintf(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcserialversion\", strprintf(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\", DEFAULT_RPC_SERIALIZE_VERSION), false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpcservertimeout=<n>\", strprintf(\"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_SERVER_TIMEOUT), true, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS), false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcthreads=<n>\", strprintf(\"Set the number of threads to service RPC calls (default: %d)\", DEFAULT_HTTP_THREADS), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcuser=<user>\", \"Username for JSON-RPC connections\", false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE), true, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-server\", _(\"Accept command line and JSON-RPC commands\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-server\", \"Accept command line and JSON-RPC commands\", false, OptionsCategory::RPC);\n+\n+#if HAVE_DECL_DAEMON\n+    gArgs.AddArg(\"-daemon\", \"Run in the background as a daemon and accept commands\", false, OptionsCategory::OPTIONS);\n+#else\n+    hidden_args.emplace_back(\"-daemon\");\n+#endif\n+\n+    // Add the hidden options\n+    gArgs.AddHiddenArgs(hidden_args);\n }\n \n std::string LicenseInfo()\n@@ -597,7 +632,7 @@ static void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    for (const std::pair<std::string, fs::path>& item : mapBlockFiles) {\n+    for (const std::pair<const std::string, fs::path>& item : mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -926,7 +961,8 @@ bool AppInitParameterInteraction()\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n     // Trim requested connection counts, to fit into system limitations\n-    nMaxConnections = std::max(std::min(nMaxConnections, FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS), 0);\n+    // <int> in std::min<int>(...) to work around FreeBSD compilation issue described in #2695\n+    nMaxConnections = std::max(std::min<int>(nMaxConnections, FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS), 0);\n     nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS);\n     if (nFD < MIN_CORE_FILEDESCRIPTORS)\n         return InitError(_(\"Not enough file descriptors available.\"));\n@@ -1099,6 +1135,8 @@ bool AppInitParameterInteraction()\n     if (gArgs.GetBoolArg(\"-peerbloomfilters\", DEFAULT_PEERBLOOMFILTERS))\n         nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM);\n \n+    g_enable_bip61 = gArgs.GetBoolArg(\"-enablebip61\", DEFAULT_ENABLE_BIP61);\n+\n     if (gArgs.GetArg(\"-rpcserialversion\", DEFAULT_RPC_SERIALIZE_VERSION) < 0)\n         return InitError(\"rpcserialversion must be non-negative.\");\n \n@@ -1587,8 +1625,7 @@ bool AppInitMain()\n \n     // ********************************************************* Step 8: start indexers\n     if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n-        auto txindex_db = MakeUnique<TxIndexDB>(nTxIndexCache, false, fReindex);\n-        g_txindex = MakeUnique<TxIndex>(std::move(txindex_db));\n+        g_txindex = MakeUnique<TxIndex>(nTxIndexCache, false, fReindex);\n         g_txindex->Start();\n     }\n "
      },
      {
        "sha": "4189ff7497c982b374be6606e95c9290404254fa",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -48,11 +48,11 @@ namespace {\n \n class NodeImpl : public Node\n {\n-    void parseParameters(int argc, const char* const argv[]) override\n+    bool parseParameters(int argc, const char* const argv[], std::string& error) override\n     {\n-        gArgs.ParseParameters(argc, argv);\n+        return gArgs.ParseParameters(argc, argv, error);\n     }\n-    void readConfigFiles() override { gArgs.ReadConfigFiles(); }\n+    bool readConfigFiles(std::string& error) override { return gArgs.ReadConfigFiles(error); }\n     bool softSetArg(const std::string& arg, const std::string& value) override { return gArgs.SoftSetArg(arg, value); }\n     bool softSetBoolArg(const std::string& arg, bool value) override { return gArgs.SoftSetBoolArg(arg, value); }\n     void selectParams(const std::string& network) override { SelectParams(network); }\n@@ -222,8 +222,8 @@ class NodeImpl : public Node\n     {\n #ifdef ENABLE_WALLET\n         std::vector<std::unique_ptr<Wallet>> wallets;\n-        for (CWallet* wallet : GetWallets()) {\n-            wallets.emplace_back(MakeWallet(*wallet));\n+        for (const std::shared_ptr<CWallet>& wallet : GetWallets()) {\n+            wallets.emplace_back(MakeWallet(wallet));\n         }\n         return wallets;\n #else\n@@ -249,7 +249,7 @@ class NodeImpl : public Node\n     std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) override\n     {\n         CHECK_WALLET(\n-            return MakeHandler(::uiInterface.LoadWallet.connect([fn](CWallet* wallet) { fn(MakeWallet(*wallet)); })));\n+            return MakeHandler(::uiInterface.LoadWallet.connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));\n     }\n     std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) override\n     {"
      },
      {
        "sha": "8185c015a9ab3ba5cdd9638da35bfbfff48810b9",
        "filename": "src/interfaces/node.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/node.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/node.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -38,7 +38,7 @@ class Node\n     virtual ~Node() {}\n \n     //! Set command line arguments.\n-    virtual void parseParameters(int argc, const char* const argv[]) = 0;\n+    virtual bool parseParameters(int argc, const char* const argv[], std::string& error) = 0;\n \n     //! Set a command line argument if it doesn't already have a value\n     virtual bool softSetArg(const std::string& arg, const std::string& value) = 0;\n@@ -47,7 +47,7 @@ class Node\n     virtual bool softSetBoolArg(const std::string& arg, bool value) = 0;\n \n     //! Load settings from configuration file.\n-    virtual void readConfigFiles() = 0;\n+    virtual bool readConfigFiles(std::string& error) = 0;\n \n     //! Choose network parameters.\n     virtual void selectParams(const std::string& network) = 0;"
      },
      {
        "sha": "e98acba0df16e90f3378ab1cf727e8d21f8e0787",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -118,7 +118,7 @@ WalletTxOut MakeWalletTxOut(CWallet& wallet, const CWalletTx& wtx, int n, int de\n class WalletImpl : public Wallet\n {\n public:\n-    WalletImpl(CWallet& wallet) : m_wallet(wallet) {}\n+    WalletImpl(const std::shared_ptr<CWallet>& wallet) : m_shared_wallet(wallet), m_wallet(*wallet.get()) {}\n \n     bool encryptWallet(const SecureString& wallet_passphrase) override\n     {\n@@ -429,6 +429,10 @@ class WalletImpl : public Wallet\n     bool hdEnabled() override { return m_wallet.IsHDEnabled(); }\n     OutputType getDefaultAddressType() override { return m_wallet.m_default_address_type; }\n     OutputType getDefaultChangeType() override { return m_wallet.m_default_change_type; }\n+    std::unique_ptr<Handler> handleUnload(UnloadFn fn) override\n+    {\n+        return MakeHandler(m_wallet.NotifyUnload.connect(fn));\n+    }\n     std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n     {\n         return MakeHandler(m_wallet.ShowProgress.connect(fn));\n@@ -453,11 +457,12 @@ class WalletImpl : public Wallet\n         return MakeHandler(m_wallet.NotifyWatchonlyChanged.connect(fn));\n     }\n \n+    std::shared_ptr<CWallet> m_shared_wallet;\n     CWallet& m_wallet;\n };\n \n } // namespace\n \n-std::unique_ptr<Wallet> MakeWallet(CWallet& wallet) { return MakeUnique<WalletImpl>(wallet); }\n+std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return MakeUnique<WalletImpl>(wallet); }\n \n } // namespace interfaces"
      },
      {
        "sha": "ce42e14eea8e7d8b52a878b554ef8d27fc0a2091",
        "filename": "src/interfaces/wallet.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -242,6 +242,10 @@ class Wallet\n     // Get default change type.\n     virtual OutputType getDefaultChangeType() = 0;\n \n+    //! Register handler for unload message.\n+    using UnloadFn = std::function<void()>;\n+    virtual std::unique_ptr<Handler> handleUnload(UnloadFn fn) = 0;\n+\n     //! Register handler for show progress messages.\n     using ShowProgressFn = std::function<void(const std::string& title, int progress)>;\n     virtual std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) = 0;\n@@ -363,7 +367,7 @@ struct WalletTxOut\n \n //! Return implementation of Wallet interface. This function will be undefined\n //! in builds where ENABLE_WALLET is false.\n-std::unique_ptr<Wallet> MakeWallet(CWallet& wallet);\n+std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet);\n \n } // namespace interfaces\n "
      },
      {
        "sha": "738ccad1b9caf0a4f02dc01b5e6c9b61d2105bd1",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -209,7 +209,7 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n //   segwit activation)\n bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n {\n-    for (const CTxMemPool::txiter it : package) {\n+    for (CTxMemPool::txiter it : package) {\n         if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n             return false;\n         if (!fIncludeWitness && it->GetTx().HasWitness())\n@@ -241,7 +241,7 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n         indexed_modified_transaction_set &mapModifiedTx)\n {\n     int nDescendantsUpdated = 0;\n-    for (const CTxMemPool::txiter it : alreadyAdded) {\n+    for (CTxMemPool::txiter it : alreadyAdded) {\n         CTxMemPool::setEntries descendants;\n         mempool.CalculateDescendants(it, descendants);\n         // Insert all descendants (not yet in block) into the modified set"
      },
      {
        "sha": "de456e87f41883370a9c6978d58ed53eb3e625a5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 10,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -37,6 +37,7 @@\n #endif\n \n std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of when we last received a block\n+bool g_enable_bip61 = DEFAULT_ENABLE_BIP61;\n \n struct IteratorComparator\n {\n@@ -560,7 +561,7 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n } // namespace\n \n // This function is used for testing the stale tip eviction logic, see\n-// DoS_tests.cpp\n+// denialofservice_tests.cpp\n void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n {\n     LOCK(cs_main);\n@@ -1591,7 +1592,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n+            if (g_enable_bip61) {\n+                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n+            }\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -1620,8 +1623,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!pfrom->fInbound && !pfrom->fFeeler && !pfrom->m_manual_connection && !HasAllDesirableServiceFlags(nServices))\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, GetDesirableServiceFlags(nServices));\n-            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n-                               strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices))));\n+            if (g_enable_bip61) {\n+                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+                                   strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices))));\n+            }\n             pfrom->fDisconnect = true;\n             return false;\n         }\n@@ -1641,8 +1646,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             // disconnect from peers older than this proto version\n             LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n-            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n-                               strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n+            if (g_enable_bip61) {\n+                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+                                   strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n+            }\n             pfrom->fDisconnect = true;\n             return false;\n         }\n@@ -2340,9 +2347,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n-            if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n+            if (g_enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n+            }\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n@@ -2915,8 +2923,10 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n     AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n-    for (const CBlockReject& reject : state.rejects) {\n-        connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+    if (g_enable_bip61) {\n+        for (const CBlockReject& reject : state.rejects) {\n+            connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+        }\n     }\n     state.rejects.clear();\n \n@@ -3023,7 +3033,9 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n     catch (const std::ios_base::failure& e)\n     {\n-        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        if (g_enable_bip61) {\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        }\n         if (strstr(e.what(), \"end of data\"))\n         {\n             // Allow exceptions from under-length message on vRecv"
      },
      {
        "sha": "3bdb4785a2a48149e6cd475d77dc40713d32e4f6",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -35,6 +35,11 @@ static constexpr int64_t EXTRA_PEER_CHECK_INTERVAL = 45;\n /** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */\n static constexpr int64_t MINIMUM_CONNECT_TIME = 30;\n \n+/** Default for BIP61 (sending reject messages) */\n+static constexpr bool DEFAULT_ENABLE_BIP61 = true;\n+/** Enable BIP61 (sending reject messages) */\n+extern bool g_enable_bip61;\n+\n class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* const connman;\n@@ -72,7 +77,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     * @param[in]   interrupt       Interrupt condition for processing threads\n     * @return                      True if there is more work to be done\n     */\n-    bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n     void ConsiderEviction(CNode *pto, int64_t time_in_seconds);"
      },
      {
        "sha": "db68e9240ae0f3dc151b19dffb7c5e42fc5e4b76",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -41,7 +41,11 @@ enum Network ParseNetwork(std::string net) {\n     boost::to_lower(net);\n     if (net == \"ipv4\") return NET_IPV4;\n     if (net == \"ipv6\") return NET_IPV6;\n-    if (net == \"tor\" || net == \"onion\")  return NET_TOR;\n+    if (net == \"onion\") return NET_TOR;\n+    if (net == \"tor\") {\n+        LogPrintf(\"Warning: net name 'tor' is deprecated and will be removed in the future. You should use 'onion' instead.\\n\");\n+        return NET_TOR;\n+    }\n     return NET_UNROUTABLE;\n }\n "
      },
      {
        "sha": "aac3fe5c14b9d8c04529ecc0070f3098bbaefb79",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -54,7 +54,7 @@ bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n     return (txout.nValue < GetDustThreshold(txout, dustRelayFeeIn));\n }\n \n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled)\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n {\n     std::vector<std::vector<unsigned char> > vSolutions;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n@@ -73,13 +73,10 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool w\n                (!fAcceptDatacarrier || scriptPubKey.size() > nMaxDatacarrierBytes))\n           return false;\n \n-    else if (!witnessEnabled && (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH))\n-        return false;\n-\n     return whichType != TX_NONSTANDARD && whichType != TX_WITNESS_UNKNOWN;\n }\n \n-bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled)\n+bool IsStandardTx(const CTransaction& tx, std::string& reason)\n {\n     if (tx.nVersion > CTransaction::MAX_STANDARD_VERSION || tx.nVersion < 1) {\n         reason = \"version\";\n@@ -118,7 +115,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n     unsigned int nDataOut = 0;\n     txnouttype whichType;\n     for (const CTxOut& txout : tx.vout) {\n-        if (!::IsStandard(txout.scriptPubKey, whichType, witnessEnabled)) {\n+        if (!::IsStandard(txout.scriptPubKey, whichType)) {\n             reason = \"scriptpubkey\";\n             return false;\n         }"
      },
      {
        "sha": "035627bd603c96baa4dc4fbc78acd81abcacc8a9",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -79,12 +79,12 @@ CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\n \n bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\n \n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n     /**\n      * Check for standard transaction types\n      * @return True if all outputs (scriptPubKeys) use only standard transaction forms\n      */\n-bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled = false);\n+bool IsStandardTx(const CTransaction& tx, std::string& reason);\n     /**\n      * Check for standard transaction types\n      * @param[in] mapInputs    Map of previous transactions that have outputs we're spending"
      },
      {
        "sha": "360615ec569a3e61713cfab065de02291d6f3160",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -388,11 +388,6 @@ struct CMutableTransaction\n      */\n     uint256 GetHash() const;\n \n-    friend bool operator==(const CMutableTransaction& a, const CMutableTransaction& b)\n-    {\n-        return a.GetHash() == b.GetHash();\n-    }\n-\n     bool HasWitness() const\n     {\n         for (size_t i = 0; i < vin.size(); i++) {"
      },
      {
        "sha": "bb254547c89d448ea3b8adf3942c16dc71b05594",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -33,10 +33,10 @@ class CPubKey\n     /**\n      * secp256k1:\n      */\n-    static const unsigned int PUBLIC_KEY_SIZE             = 65;\n-    static const unsigned int COMPRESSED_PUBLIC_KEY_SIZE  = 33;\n-    static const unsigned int SIGNATURE_SIZE              = 72;\n-    static const unsigned int COMPACT_SIGNATURE_SIZE      = 65;\n+    static constexpr unsigned int PUBLIC_KEY_SIZE             = 65;\n+    static constexpr unsigned int COMPRESSED_PUBLIC_KEY_SIZE  = 33;\n+    static constexpr unsigned int SIGNATURE_SIZE              = 72;\n+    static constexpr unsigned int COMPACT_SIGNATURE_SIZE      = 65;\n     /**\n      * see www.keylength.com\n      * script supports up to 75 for single byte push"
      },
      {
        "sha": "3ec538b4f43dd35f4829e798e311ad41b1b8eec9",
        "filename": "src/qt/README.md",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,10 +1,10 @@\n This directory contains the BitcoinQT graphical user interface (GUI). It uses the cross-platform framework [Qt](https://www1.qt.io/developers/).\n \n-The current precise version for Qt 5 is specified in [qt.mk](/depends/packages/qt.mk). Qt 4 is also supported (see [#8263](https://github.com/bitcoin/bitcoin/issues/8263)).\n+The current precise version for Qt 5 is specified in [qt.mk](/depends/packages/qt.mk).\n \n ## Compile and run\n \n-See build instructions ([OSX](/doc/build-osx.md), [Windows](/doc/build-windows.md), [Unix](/doc/build-unix.md), etc).\n+See build instructions ([macOS](/doc/build-osx.md), [Windows](/doc/build-windows.md), [Unix](/doc/build-unix.md), etc).\n \n To run:\n \n@@ -16,7 +16,7 @@ To run:\n \n ### forms\n \n-Contains [Designer UI](http://doc.qt.io/qt-5.9/designer-using-a-ui-file.html) files. They are created with [Qt Creator](#using-qt-creator-as-ide), but can be edited using any text editor.\n+Contains [Designer UI](https://doc.qt.io/qt-5.9/designer-using-a-ui-file.html) files. They are created with [Qt Creator](#using-qt-creator-as-ide), but can be edited using any text editor.\n \n ### locale\n \n@@ -36,7 +36,7 @@ Represents the main window of the Bitcoin UI.\n \n ### \\*model.(h/cpp)\n \n-The model. When it has a corresponding controller, it generally inherits from  [QAbstractTableModel](http://doc.qt.io/qt-5/qabstracttablemodel.html). Models that are used by controllers as helpers inherit from other Qt classes like [QValidator](http://doc.qt.io/qt-5/qvalidator.html).\n+The model. When it has a corresponding controller, it generally inherits from  [QAbstractTableModel](https://doc.qt.io/qt-5/qabstracttablemodel.html). Models that are used by controllers as helpers inherit from other Qt classes like [QValidator](https://doc.qt.io/qt-5/qvalidator.html).\n \n ClientModel is used by the main application `bitcoingui` and several models like `peertablemodel`.\n \n@@ -46,7 +46,7 @@ A controller. `:NAMEpage.cpp` generally includes `:NAMEmodel.h` and `forms/:NAME\n \n ### \\*dialog.(h/cpp)\n \n-Various dialogs, e.g. to open a URL. Inherit from [QDialog](http://doc.qt.io/qt-4.8/qdialog.html).\n+Various dialogs, e.g. to open a URL. Inherit from [QDialog](https://doc.qt.io/qt-5/qdialog.html).\n \n ### paymentserver.(h/cpp)\n \n@@ -65,7 +65,7 @@ Represents the view to a single wallet.\n * `guiconstants.h`: UI colors, app name, etc\n * `guiutil.h`: several helper functions\n * `macdockiconhandler.(h/cpp)`\n-* `macdockiconhandler.(h/cpp)`: display notifications in OSX\n+* `macdockiconhandler.(h/cpp)`: display notifications in macOS\n \n ## Contribute\n \n@@ -81,9 +81,9 @@ the UI layout.\n Download and install the community edition of [Qt Creator](https://www.qt.io/download/).\n Uncheck everything except Qt Creator during the installation process.\n \n-Instructions for OSX:\n+Instructions for macOS:\n \n-1. Make sure you installed everything through Homebrew mentioned in the [OSX build instructions](/doc/build-osx.md)\n+1. Make sure you installed everything through Homebrew mentioned in the [macOS build instructions](/doc/build-osx.md)\n 2. Use `./configure` with the `--enable-debug` flag\n 3. In Qt Creator do \"New Project\" -> Import Project -> Import Existing Project\n 4. Enter \"bitcoin-qt\" as project name, enter src/qt as location"
      },
      {
        "sha": "d51069d9220f91f61629d7355b8b9beed58c260c",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -160,13 +160,8 @@ void AddressBookPage::setModel(AddressTableModel *_model)\n     ui->tableView->sortByColumn(0, Qt::AscendingOrder);\n \n     // Set column widths\n-#if QT_VERSION < 0x050000\n-    ui->tableView->horizontalHeader()->setResizeMode(AddressTableModel::Label, QHeaderView::Stretch);\n-    ui->tableView->horizontalHeader()->setResizeMode(AddressTableModel::Address, QHeaderView::ResizeToContents);\n-#else\n     ui->tableView->horizontalHeader()->setSectionResizeMode(AddressTableModel::Label, QHeaderView::Stretch);\n     ui->tableView->horizontalHeader()->setSectionResizeMode(AddressTableModel::Address, QHeaderView::ResizeToContents);\n-#endif\n \n     connect(ui->tableView->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),\n         this, SLOT(selectionChanged()));"
      },
      {
        "sha": "aa0d4a31d3e589ea7e21095c089358da18b5d7ef",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -52,9 +52,7 @@ class BanTablePriv\n         node.getBanned(banMap);\n \n         cachedBanlist.clear();\n-#if QT_VERSION >= 0x040700\n         cachedBanlist.reserve(banMap.size());\n-#endif\n         for (const auto& entry : banMap)\n         {\n             CCombinedBan banEntry;"
      },
      {
        "sha": "e3d1c746b169d3f20fd2935d6f685bfc05f60957",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 55,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -55,13 +55,6 @@\n \n #if defined(QT_STATICPLUGIN)\n #include <QtPlugin>\n-#if QT_VERSION < 0x050000\n-Q_IMPORT_PLUGIN(qcncodecs)\n-Q_IMPORT_PLUGIN(qjpcodecs)\n-Q_IMPORT_PLUGIN(qtwcodecs)\n-Q_IMPORT_PLUGIN(qkrcodecs)\n-Q_IMPORT_PLUGIN(qtaccessiblewidgets)\n-#else\n #if QT_VERSION < 0x050400\n Q_IMPORT_PLUGIN(AccessibleFactory)\n #endif\n@@ -73,11 +66,6 @@ Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);\n Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin);\n #endif\n #endif\n-#endif\n-\n-#if QT_VERSION < 0x050000\n-#include <QTextCodec>\n-#endif\n \n // Declare meta types used for QMetaObject::invokeMethod\n Q_DECLARE_METATYPE(bool*)\n@@ -151,16 +139,6 @@ static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTrans\n }\n \n /* qDebug() message handler --> debug.log */\n-#if QT_VERSION < 0x050000\n-void DebugMessageHandler(QtMsgType type, const char *msg)\n-{\n-    if (type == QtDebugMsg) {\n-        LogPrint(BCLog::QT, \"GUI: %s\\n\", msg);\n-    } else {\n-        LogPrintf(\"GUI: %s\\n\", msg);\n-    }\n-}\n-#else\n void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, const QString &msg)\n {\n     Q_UNUSED(context);\n@@ -170,7 +148,6 @@ void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, cons\n         LogPrintf(\"GUI: %s\\n\", msg.toStdString());\n     }\n }\n-#endif\n \n /** Class encapsulating Bitcoin Core startup and shutdown.\n  * Allows running startup and shutdown in a different thread from the UI thread.\n@@ -229,12 +206,16 @@ class BitcoinApplication: public QApplication\n     /// Get window identifier of QMainWindow (BitcoinGUI)\n     WId getMainWinId() const;\n \n+    /// Setup platform style\n+    void setupPlatformStyle();\n+\n public Q_SLOTS:\n     void initializeResult(bool success);\n     void shutdownResult();\n     /// Handle runaway exceptions. Shows a message box with the problem and quits the program.\n     void handleRunawayException(const QString &message);\n     void addWallet(WalletModel* walletModel);\n+    void removeWallet();\n \n Q_SIGNALS:\n     void requestedInitialize();\n@@ -315,10 +296,14 @@ BitcoinApplication::BitcoinApplication(interfaces::Node& node, int &argc, char *\n     paymentServer(0),\n     m_wallet_models(),\n #endif\n-    returnValue(0)\n+    returnValue(0),\n+    platformStyle(0)\n {\n     setQuitOnLastWindowClosed(false);\n+}\n \n+void BitcoinApplication::setupPlatformStyle()\n+{\n     // UI per-platform customization\n     // This must be done inside the BitcoinApplication constructor, or after it, because\n     // PlatformStyle::instantiate requires a QApplication\n@@ -460,11 +445,22 @@ void BitcoinApplication::addWallet(WalletModel* walletModel)\n \n     connect(walletModel, SIGNAL(coinsSent(WalletModel*, SendCoinsRecipient, QByteArray)),\n         paymentServer, SLOT(fetchPaymentACK(WalletModel*, const SendCoinsRecipient&, QByteArray)));\n+    connect(walletModel, SIGNAL(unload()), this, SLOT(removeWallet()));\n \n     m_wallet_models.push_back(walletModel);\n #endif\n }\n \n+void BitcoinApplication::removeWallet()\n+{\n+#ifdef ENABLE_WALLET\n+    WalletModel* walletModel = static_cast<WalletModel*>(sender());\n+    m_wallet_models.erase(std::find(m_wallet_models.begin(), m_wallet_models.end(), walletModel));\n+    window->removeWallet(walletModel);\n+    walletModel->deleteLater();\n+#endif\n+}\n+\n void BitcoinApplication::initializeResult(bool success)\n {\n     qDebug() << __func__ << \": Initialization result: \" << success;\n@@ -484,8 +480,10 @@ void BitcoinApplication::initializeResult(bool success)\n \n #ifdef ENABLE_WALLET\n         m_handler_load_wallet = m_node.handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) {\n-            QMetaObject::invokeMethod(this, \"addWallet\", Qt::QueuedConnection,\n-                Q_ARG(WalletModel*, new WalletModel(std::move(wallet), m_node, platformStyle, optionsModel)));\n+            WalletModel* wallet_model = new WalletModel(std::move(wallet), m_node, platformStyle, optionsModel, nullptr);\n+            // Fix wallet model thread affinity.\n+            wallet_model->moveToThread(thread());\n+            QMetaObject::invokeMethod(this, \"addWallet\", Qt::QueuedConnection, Q_ARG(WalletModel*, wallet_model));\n         });\n \n         for (auto& wallet : m_node.getWallets()) {\n@@ -546,12 +544,12 @@ static void SetupUIArgs()\n #ifdef ENABLE_WALLET\n     gArgs.AddArg(\"-allowselfsignedrootcertificates\", strprintf(\"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS), true, OptionsCategory::GUI);\n #endif\n-    gArgs.AddArg(\"-choosedatadir\", strprintf(QObject::tr(\"Choose data directory on startup (default: %u)\").toStdString(), DEFAULT_CHOOSE_DATADIR), false, OptionsCategory::GUI);\n-    gArgs.AddArg(\"-lang=<lang>\", QObject::tr(\"Set language, for example \\\"de_DE\\\" (default: system locale)\").toStdString(), false, OptionsCategory::GUI);\n-    gArgs.AddArg(\"-min\", QObject::tr(\"Start minimized\").toStdString(), false, OptionsCategory::GUI);\n-    gArgs.AddArg(\"-resetguisettings\", QObject::tr(\"Reset all settings changed in the GUI\").toStdString(), false, OptionsCategory::GUI);\n-    gArgs.AddArg(\"-rootcertificates=<file>\", QObject::tr(\"Set SSL root certificates for payment request (default: -system-)\").toStdString(), false, OptionsCategory::GUI);\n-    gArgs.AddArg(\"-splash\", strprintf(QObject::tr(\"Show splash screen on startup (default: %u)\").toStdString(), DEFAULT_SPLASHSCREEN), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-choosedatadir\", strprintf(\"Choose data directory on startup (default: %u)\", DEFAULT_CHOOSE_DATADIR), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-lang=<lang>\", \"Set language, for example \\\"de_DE\\\" (default: system locale)\", false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-min\", \"Start minimized\", false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-resetguisettings\", \"Reset all settings changed in the GUI\", false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-rootcertificates=<file>\", \"Set SSL root certificates for payment request (default: -system-)\", false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-splash\", strprintf(\"Show splash screen on startup (default: %u)\", DEFAULT_SPLASHSCREEN), false, OptionsCategory::GUI);\n     gArgs.AddArg(\"-uiplatform\", strprintf(\"Select platform to customize UI for (one of windows, macosx, other; default: %s)\", BitcoinGUI::DEFAULT_UIPLATFORM), true, OptionsCategory::GUI);\n }\n \n@@ -562,21 +560,9 @@ int main(int argc, char *argv[])\n \n     std::unique_ptr<interfaces::Node> node = interfaces::MakeNode();\n \n-    /// 1. Parse command-line options. These take precedence over anything else.\n-    // Command-line options take precedence:\n-    node->setupServerArgs();\n-    SetupUIArgs();\n-    node->parseParameters(argc, argv);\n-\n     // Do not refer to data directory yet, this can be overridden by Intro::pickDataDirectory\n \n-    /// 2. Basic Qt initialization (not dependent on parameters or configuration)\n-#if QT_VERSION < 0x050000\n-    // Internal string conversion is all UTF-8\n-    QTextCodec::setCodecForTr(QTextCodec::codecForName(\"UTF-8\"));\n-    QTextCodec::setCodecForCStrings(QTextCodec::codecForTr());\n-#endif\n-\n+    /// 1. Basic Qt initialization (not dependent on parameters or configuration)\n     Q_INIT_RESOURCE(bitcoin);\n     Q_INIT_RESOURCE(bitcoin_locale);\n \n@@ -609,6 +595,20 @@ int main(int argc, char *argv[])\n     qRegisterMetaType<WalletModel*>(\"WalletModel*\");\n #endif\n \n+    /// 2. Parse command-line options. We do this after qt in order to show an error if there are problems parsing these\n+    // Command-line options take precedence:\n+    node->setupServerArgs();\n+    SetupUIArgs();\n+    std::string error;\n+    if (!node->parseParameters(argc, argv, error)) {\n+        QMessageBox::critical(0, QObject::tr(PACKAGE_NAME),\n+            QObject::tr(\"Error parsing command line arguments: %1.\").arg(QString::fromStdString(error)));\n+        return EXIT_FAILURE;\n+    }\n+\n+    // Now that the QApplication is setup and we have parsed our parameters, we can set the platform style\n+    app.setupPlatformStyle();\n+\n     /// 3. Application identification\n     // must be set before OptionsModel is initialized or translations are loaded,\n     // as it is used to locate QSettings\n@@ -644,11 +644,9 @@ int main(int argc, char *argv[])\n                               QObject::tr(\"Error: Specified data directory \\\"%1\\\" does not exist.\").arg(QString::fromStdString(gArgs.GetArg(\"-datadir\", \"\"))));\n         return EXIT_FAILURE;\n     }\n-    try {\n-        node->readConfigFiles();\n-    } catch (const std::exception& e) {\n+    if (!node->readConfigFiles(error)) {\n         QMessageBox::critical(0, QObject::tr(PACKAGE_NAME),\n-                              QObject::tr(\"Error: Cannot parse configuration file: %1. Only use key=value syntax.\").arg(e.what()));\n+            QObject::tr(\"Error: Cannot parse configuration file: %1.\").arg(QString::fromStdString(error)));\n         return EXIT_FAILURE;\n     }\n \n@@ -695,17 +693,12 @@ int main(int argc, char *argv[])\n     /// 9. Main GUI initialization\n     // Install global event filter that makes sure that long tooltips can be word-wrapped\n     app.installEventFilter(new GUIUtil::ToolTipToRichTextFilter(TOOLTIP_WRAP_THRESHOLD, &app));\n-#if QT_VERSION < 0x050000\n-    // Install qDebug() message handler to route to debug.log\n-    qInstallMsgHandler(DebugMessageHandler);\n-#else\n #if defined(Q_OS_WIN)\n     // Install global event filter for processing Windows session related Windows messages (WM_QUERYENDSESSION and WM_ENDSESSION)\n     qApp->installNativeEventFilter(new WinShutdownMonitor());\n #endif\n     // Install qDebug() message handler to route to debug.log\n     qInstallMessageHandler(DebugMessageHandler);\n-#endif\n     // Allow parameter interaction before we create the options model\n     app.parameterSetup();\n     // Load GUI settings from QSettings\n@@ -726,7 +719,7 @@ int main(int argc, char *argv[])\n         // so the GUI thread won't be held up.\n         if (node->baseInitialize()) {\n             app.requestInitialize();\n-#if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n+#if defined(Q_OS_WIN)\n             WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n #endif\n             app.exec();"
      },
      {
        "sha": "68a9dc4c27fce63df07a360802468492342e5735",
        "filename": "src/qt/bitcoinamountfield.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoinamountfield.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoinamountfield.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -197,7 +197,7 @@ BitcoinAmountField::BitcoinAmountField(QWidget *parent) :\n     amount = new AmountSpinBox(this);\n     amount->setLocale(QLocale::c());\n     amount->installEventFilter(this);\n-    amount->setMaximumWidth(170);\n+    amount->setMaximumWidth(240);\n \n     QHBoxLayout *layout = new QHBoxLayout(this);\n     layout->addWidget(amount);"
      },
      {
        "sha": "df78652376008a747d5908f37f13186cb5583b69",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 64,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -55,14 +55,8 @@\n #include <QStyle>\n #include <QTimer>\n #include <QToolBar>\n-#include <QVBoxLayout>\n-\n-#if QT_VERSION < 0x050000\n-#include <QTextDocument>\n-#include <QUrl>\n-#else\n #include <QUrlQuery>\n-#endif\n+#include <QVBoxLayout>\n \n const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n #if defined(Q_OS_MAC)\n@@ -76,50 +70,7 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n \n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n-    enableWallet(false),\n     m_node(node),\n-    clientModel(0),\n-    walletFrame(0),\n-    unitDisplayControl(0),\n-    labelWalletEncryptionIcon(0),\n-    labelWalletHDStatusIcon(0),\n-    labelProxyIcon(0),\n-    connectionsControl(0),\n-    labelBlocksIcon(0),\n-    progressBarLabel(0),\n-    progressBar(0),\n-    progressDialog(0),\n-    appMenuBar(0),\n-    appToolBar(0),\n-    overviewAction(0),\n-    historyAction(0),\n-    quitAction(0),\n-    sendCoinsAction(0),\n-    sendCoinsMenuAction(0),\n-    usedSendingAddressesAction(0),\n-    usedReceivingAddressesAction(0),\n-    signMessageAction(0),\n-    verifyMessageAction(0),\n-    aboutAction(0),\n-    receiveCoinsAction(0),\n-    receiveCoinsMenuAction(0),\n-    optionsAction(0),\n-    toggleHideAction(0),\n-    encryptWalletAction(0),\n-    backupWalletAction(0),\n-    changePassphraseAction(0),\n-    aboutQtAction(0),\n-    openRPCConsoleAction(0),\n-    openAction(0),\n-    showHelpMessageAction(0),\n-    trayIcon(0),\n-    trayIconMenu(0),\n-    notificator(0),\n-    rpcConsole(0),\n-    helpMessageDialog(0),\n-    modalOverlay(0),\n-    prevBlocks(0),\n-    spinnerFrame(0),\n     platformStyle(_platformStyle)\n {\n     QSettings settings;\n@@ -147,12 +98,6 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n #endif\n     setWindowTitle(windowTitle);\n \n-#if defined(Q_OS_MAC) && QT_VERSION < 0x050000\n-    // This property is not implemented in Qt 5. Setting it has no effect.\n-    // A replacement API (QtMacUnifiedToolBar) is available in QtMacExtras.\n-    setUnifiedTitleAndToolBarOnMac(true);\n-#endif\n-\n     rpcConsole = new RPCConsole(node, _platformStyle, 0);\n     helpMessageDialog = new HelpMessageDialog(node, this, false);\n #ifdef ENABLE_WALLET\n@@ -229,7 +174,7 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n \n     // Override style sheet for progress bar for styles that have a segmented progress bar,\n     // as they make the text unreadable (workaround for issue #1071)\n-    // See https://qt-project.org/doc/qt-4.8/gallery.html\n+    // See https://doc.qt.io/qt-5/gallery.html\n     QString curStyle = QApplication::style()->metaObject()->className();\n     if(curStyle == \"QWindowsStyle\" || curStyle == \"QWindowsXPStyle\")\n     {\n@@ -476,7 +421,17 @@ void BitcoinGUI::createToolBars()\n         toolbar->addWidget(spacer);\n \n         m_wallet_selector = new QComboBox();\n-        connect(m_wallet_selector, SIGNAL(currentIndexChanged(const QString&)), this, SLOT(setCurrentWallet(const QString&)));\n+        connect(m_wallet_selector, SIGNAL(currentIndexChanged(int)), this, SLOT(setCurrentWalletBySelectorIndex(int)));\n+\n+        m_wallet_selector_label = new QLabel();\n+        m_wallet_selector_label->setText(tr(\"Wallet:\") + \" \");\n+        m_wallet_selector_label->setBuddy(m_wallet_selector);\n+\n+        m_wallet_selector_label_action = appToolBar->addWidget(m_wallet_selector_label);\n+        m_wallet_selector_action = appToolBar->addWidget(m_wallet_selector);\n+\n+        m_wallet_selector_label_action->setVisible(false);\n+        m_wallet_selector_action->setVisible(false);\n #endif\n     }\n }\n@@ -552,26 +507,46 @@ bool BitcoinGUI::addWallet(WalletModel *walletModel)\n     if(!walletFrame)\n         return false;\n     const QString name = walletModel->getWalletName();\n+    QString display_name = name.isEmpty() ? \"[\"+tr(\"default wallet\")+\"]\" : name;\n     setWalletActionsEnabled(true);\n-    m_wallet_selector->addItem(name);\n+    m_wallet_selector->addItem(display_name, name);\n     if (m_wallet_selector->count() == 2) {\n-        m_wallet_selector_label = new QLabel();\n-        m_wallet_selector_label->setText(tr(\"Wallet:\") + \" \");\n-        m_wallet_selector_label->setBuddy(m_wallet_selector);\n-        appToolBar->addWidget(m_wallet_selector_label);\n-        appToolBar->addWidget(m_wallet_selector);\n+        m_wallet_selector_label_action->setVisible(true);\n+        m_wallet_selector_action->setVisible(true);\n     }\n     rpcConsole->addWallet(walletModel);\n     return walletFrame->addWallet(walletModel);\n }\n \n+bool BitcoinGUI::removeWallet(WalletModel* walletModel)\n+{\n+    if (!walletFrame) return false;\n+    QString name = walletModel->getWalletName();\n+    int index = m_wallet_selector->findData(name);\n+    m_wallet_selector->removeItem(index);\n+    if (m_wallet_selector->count() == 0) {\n+        setWalletActionsEnabled(false);\n+    } else if (m_wallet_selector->count() == 1) {\n+        m_wallet_selector_label_action->setVisible(false);\n+        m_wallet_selector_action->setVisible(false);\n+    }\n+    rpcConsole->removeWallet(walletModel);\n+    return walletFrame->removeWallet(name);\n+}\n+\n bool BitcoinGUI::setCurrentWallet(const QString& name)\n {\n     if(!walletFrame)\n         return false;\n     return walletFrame->setCurrentWallet(name);\n }\n \n+bool BitcoinGUI::setCurrentWalletBySelectorIndex(int index)\n+{\n+    QString internal_name = m_wallet_selector->itemData(index).toString();\n+    return setCurrentWallet(internal_name);\n+}\n+\n void BitcoinGUI::removeAllWallets()\n {\n     if(!walletFrame)"
      },
      {
        "sha": "964e04f84884b306afa44e1866a645b330e1c293",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 53,
        "deletions": 49,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -70,9 +70,10 @@ class BitcoinGUI : public QMainWindow\n         functionality.\n     */\n     bool addWallet(WalletModel *walletModel);\n+    bool removeWallet(WalletModel* walletModel);\n     void removeAllWallets();\n #endif // ENABLE_WALLET\n-    bool enableWallet;\n+    bool enableWallet = false;\n \n protected:\n     void changeEvent(QEvent *e);\n@@ -86,56 +87,58 @@ class BitcoinGUI : public QMainWindow\n     interfaces::Node& m_node;\n     std::unique_ptr<interfaces::Handler> m_handler_message_box;\n     std::unique_ptr<interfaces::Handler> m_handler_question;\n-    ClientModel *clientModel;\n-    WalletFrame *walletFrame;\n-\n-    UnitDisplayStatusBarControl *unitDisplayControl;\n-    QLabel *labelWalletEncryptionIcon;\n-    QLabel *labelWalletHDStatusIcon;\n-    QLabel *labelProxyIcon;\n-    QLabel *connectionsControl;\n-    QLabel *labelBlocksIcon;\n-    QLabel *progressBarLabel;\n-    QProgressBar *progressBar;\n-    QProgressDialog *progressDialog;\n-\n-    QMenuBar *appMenuBar;\n-    QToolBar *appToolBar;\n-    QAction *overviewAction;\n-    QAction *historyAction;\n-    QAction *quitAction;\n-    QAction *sendCoinsAction;\n-    QAction *sendCoinsMenuAction;\n-    QAction *usedSendingAddressesAction;\n-    QAction *usedReceivingAddressesAction;\n-    QAction *signMessageAction;\n-    QAction *verifyMessageAction;\n-    QAction *aboutAction;\n-    QAction *receiveCoinsAction;\n-    QAction *receiveCoinsMenuAction;\n-    QAction *optionsAction;\n-    QAction *toggleHideAction;\n-    QAction *encryptWalletAction;\n-    QAction *backupWalletAction;\n-    QAction *changePassphraseAction;\n-    QAction *aboutQtAction;\n-    QAction *openRPCConsoleAction;\n-    QAction *openAction;\n-    QAction *showHelpMessageAction;\n-\n-    QLabel *m_wallet_selector_label;\n-    QComboBox *m_wallet_selector;\n-\n-    QSystemTrayIcon *trayIcon;\n-    QMenu *trayIconMenu;\n-    Notificator *notificator;\n-    RPCConsole *rpcConsole;\n-    HelpMessageDialog *helpMessageDialog;\n-    ModalOverlay *modalOverlay;\n+    ClientModel* clientModel = nullptr;\n+    WalletFrame* walletFrame = nullptr;\n+\n+    UnitDisplayStatusBarControl* unitDisplayControl = nullptr;\n+    QLabel* labelWalletEncryptionIcon = nullptr;\n+    QLabel* labelWalletHDStatusIcon = nullptr;\n+    QLabel* labelProxyIcon = nullptr;\n+    QLabel* connectionsControl = nullptr;\n+    QLabel* labelBlocksIcon = nullptr;\n+    QLabel* progressBarLabel = nullptr;\n+    QProgressBar* progressBar = nullptr;\n+    QProgressDialog* progressDialog = nullptr;\n+\n+    QMenuBar* appMenuBar = nullptr;\n+    QToolBar* appToolBar = nullptr;\n+    QAction* overviewAction = nullptr;\n+    QAction* historyAction = nullptr;\n+    QAction* quitAction = nullptr;\n+    QAction* sendCoinsAction = nullptr;\n+    QAction* sendCoinsMenuAction = nullptr;\n+    QAction* usedSendingAddressesAction = nullptr;\n+    QAction* usedReceivingAddressesAction = nullptr;\n+    QAction* signMessageAction = nullptr;\n+    QAction* verifyMessageAction = nullptr;\n+    QAction* aboutAction = nullptr;\n+    QAction* receiveCoinsAction = nullptr;\n+    QAction* receiveCoinsMenuAction = nullptr;\n+    QAction* optionsAction = nullptr;\n+    QAction* toggleHideAction = nullptr;\n+    QAction* encryptWalletAction = nullptr;\n+    QAction* backupWalletAction = nullptr;\n+    QAction* changePassphraseAction = nullptr;\n+    QAction* aboutQtAction = nullptr;\n+    QAction* openRPCConsoleAction = nullptr;\n+    QAction* openAction = nullptr;\n+    QAction* showHelpMessageAction = nullptr;\n+    QAction* m_wallet_selector_label_action = nullptr;\n+    QAction* m_wallet_selector_action = nullptr;\n+\n+    QLabel *m_wallet_selector_label = nullptr;\n+    QComboBox* m_wallet_selector = nullptr;\n+\n+    QSystemTrayIcon* trayIcon = nullptr;\n+    QMenu* trayIconMenu = nullptr;\n+    Notificator* notificator = nullptr;\n+    RPCConsole* rpcConsole = nullptr;\n+    HelpMessageDialog* helpMessageDialog = nullptr;\n+    ModalOverlay* modalOverlay = nullptr;\n \n     /** Keep track of previous number of blocks, to detect progress */\n-    int prevBlocks;\n-    int spinnerFrame;\n+    int prevBlocks = 0;\n+    int spinnerFrame = 0;\n \n     const PlatformStyle *platformStyle;\n \n@@ -186,6 +189,7 @@ public Q_SLOTS:\n \n #ifdef ENABLE_WALLET\n     bool setCurrentWallet(const QString& name);\n+    bool setCurrentWalletBySelectorIndex(int index);\n     /** Set the UI status indicators based on the currently selected wallet.\n     */\n     void updateWalletStatus();"
      },
      {
        "sha": "9b6480a9150e8ac5dc973aa8cc864fa7480f22ce",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -109,11 +109,7 @@ CoinControlDialog::CoinControlDialog(const PlatformStyle *_platformStyle, QWidge\n     connect(ui->treeWidget, SIGNAL(itemChanged(QTreeWidgetItem*, int)), this, SLOT(viewItemChanged(QTreeWidgetItem*, int)));\n \n     // click on header\n-#if QT_VERSION < 0x050000\n-    ui->treeWidget->header()->setClickable(true);\n-#else\n     ui->treeWidget->header()->setSectionsClickable(true);\n-#endif\n     connect(ui->treeWidget->header(), SIGNAL(sectionClicked(int)), this, SLOT(headerSectionClicked(int)));\n \n     // ok button\n@@ -122,10 +118,6 @@ CoinControlDialog::CoinControlDialog(const PlatformStyle *_platformStyle, QWidge\n     // (un)select all\n     connect(ui->pushButtonSelectAll, SIGNAL(clicked()), this, SLOT(buttonSelectAllClicked()));\n \n-    // change coin control first column label due Qt4 bug.\n-    // see https://github.com/bitcoin/bitcoin/issues/5716\n-    ui->treeWidget->headerItem()->setText(COLUMN_CHECKBOX, QString());\n-\n     ui->treeWidget->setColumnWidth(COLUMN_CHECKBOX, 84);\n     ui->treeWidget->setColumnWidth(COLUMN_AMOUNT, 110);\n     ui->treeWidget->setColumnWidth(COLUMN_LABEL, 190);\n@@ -392,13 +384,11 @@ void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n \n     // TODO: Remove this temporary qt5 fix after Qt5.3 and Qt5.4 are no longer used.\n     //       Fixed in Qt5.5 and above: https://bugreports.qt.io/browse/QTBUG-43473\n-#if QT_VERSION >= 0x050000\n     else if (column == COLUMN_CHECKBOX && item->childCount() > 0)\n     {\n         if (item->checkState(COLUMN_CHECKBOX) == Qt::PartiallyChecked && item->child(0)->checkState(COLUMN_CHECKBOX) == Qt::PartiallyChecked)\n             item->setCheckState(COLUMN_CHECKBOX, Qt::Checked);\n     }\n-#endif\n }\n \n // shows count of locked unspent outputs"
      },
      {
        "sha": "8f34e6bc827ed0ae2c2ae5acf60792d63e3aaddf",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 65,
        "deletions": 2,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -37,6 +37,69 @@\n          </property>\n         </widget>\n        </item>\n+       <item>\n+        <spacer name=\"horizontalSpacer_0_Main\">\n+         <property name=\"orientation\">\n+          <enum>Qt::Horizontal</enum>\n+         </property>\n+         <property name=\"sizeHint\" stdset=\"0\">\n+          <size>\n+           <width>40</width>\n+           <height>5</height>\n+          </size>\n+         </property>\n+        </spacer>\n+       </item>\n+       <item>\n+       <layout class=\"QHBoxLayout\" name=\"horizontalLayout_Main_Prune\">\n+        <item>\n+         <widget class=\"QCheckBox\" name=\"prune\">\n+          <property name=\"toolTip\">\n+           <string>Disables some advanced features but all blocks will still be fully validated. Reverting this setting requires re-downloading the entire blockchain. Actual disk usage may be somewhat higher.</string>\n+          </property>\n+          <property name=\"text\">\n+           <string>Prune &amp;block storage to</string>\n+          </property>\n+         </widget>\n+        </item>\n+        <item>\n+         <widget class=\"QSpinBox\" name=\"pruneSize\"/>\n+        </item>\n+         <item>\n+          <widget class=\"QLabel\" name=\"pruneSizeUnitLabel\">\n+           <property name=\"text\">\n+            <string>GB</string>\n+           </property>\n+           <property name=\"textFormat\">\n+            <enum>Qt::PlainText</enum>\n+           </property>\n+          </widget>\n+         </item>\n+         <item>\n+          <spacer name=\"horizontalSpacer_Main_Prune\">\n+           <property name=\"orientation\">\n+            <enum>Qt::Horizontal</enum>\n+           </property>\n+           <property name=\"sizeHint\" stdset=\"0\">\n+            <size>\n+             <width>40</width>\n+             <height>20</height>\n+            </size>\n+           </property>\n+          </spacer>\n+         </item>\n+        </layout>\n+       </item>\n+       <item>\n+        <widget class=\"QLabel\" name=\"pruneWarning\">\n+         <property name=\"text\">\n+          <string>Reverting this setting requires re-downloading the entire blockchain.</string>\n+         </property>\n+         <property name=\"textFormat\">\n+          <enum>Qt::PlainText</enum>\n+         </property>\n+        </widget>\n+       </item>\n        <item>\n         <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2_Main\">\n          <item>\n@@ -81,7 +144,7 @@\n         </layout>\n        </item>\n        <item>\n-        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3_Main\">\n+        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_Main_VerifyLabel\">\n          <item>\n           <widget class=\"QLabel\" name=\"threadsScriptVerifLabel\">\n            <property name=\"text\">\n@@ -103,7 +166,7 @@\n           </widget>\n          </item>\n          <item>\n-          <spacer name=\"horizontalSpacer_3_Main\">\n+          <spacer name=\"horizontalSpacer_Main_Threads\">\n            <property name=\"orientation\">\n             <enum>Qt::Horizontal</enum>\n            </property>"
      },
      {
        "sha": "acd9f7b35cea11c184eb2532cc77e44a84a24eaa",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 31,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -53,13 +53,9 @@\n #include <QSettings>\n #include <QTextDocument> // for Qt::mightBeRichText\n #include <QThread>\n+#include <QUrlQuery>\n #include <QMouseEvent>\n \n-#if QT_VERSION < 0x050000\n-#include <QUrl>\n-#else\n-#include <QUrlQuery>\n-#endif\n \n #if QT_VERSION >= 0x50200\n #include <QFontDatabase>\n@@ -95,11 +91,7 @@ QFont fixedPitchFont()\n     return QFontDatabase::systemFont(QFontDatabase::FixedFont);\n #else\n     QFont font(\"Monospace\");\n-#if QT_VERSION >= 0x040800\n     font.setStyleHint(QFont::Monospace);\n-#else\n-    font.setStyleHint(QFont::TypeWriter);\n-#endif\n     return font;\n #endif\n }\n@@ -127,12 +119,10 @@ void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent)\n     parent->setFocusProxy(widget);\n \n     widget->setFont(fixedPitchFont());\n-#if QT_VERSION >= 0x040700\n     // We don't want translators to use own addresses in translations\n     // and this is the only place, where this address is supplied.\n     widget->setPlaceholderText(QObject::tr(\"Enter a Bitcoin address (e.g. %1)\").arg(\n         QString::fromStdString(DummyAddress(Params()))));\n-#endif\n     widget->setValidator(new BitcoinAddressEntryValidator(parent));\n     widget->setCheckValidator(new BitcoinAddressCheckValidator(parent));\n }\n@@ -151,12 +141,8 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n     }\n     rv.amount = 0;\n \n-#if QT_VERSION < 0x050000\n-    QList<QPair<QString, QString> > items = uri.queryItems();\n-#else\n     QUrlQuery uriQuery(uri);\n     QList<QPair<QString, QString> > items = uriQuery.queryItems();\n-#endif\n     for (QList<QPair<QString, QString> >::iterator i = items.begin(); i != items.end(); i++)\n     {\n         bool fShouldReturnFalse = false;\n@@ -242,11 +228,7 @@ bool isDust(interfaces::Node& node, const QString& address, const CAmount& amoun\n \n QString HtmlEscape(const QString& str, bool fMultiLine)\n {\n-#if QT_VERSION < 0x050000\n-    QString escaped = Qt::escape(str);\n-#else\n     QString escaped = str.toHtmlEscaped();\n-#endif\n     if(fMultiLine)\n     {\n         escaped = escaped.replace(\"\\n\", \"<br>\\n\");\n@@ -287,11 +269,7 @@ QString getSaveFileName(QWidget *parent, const QString &caption, const QString &\n     QString myDir;\n     if(dir.isEmpty()) // Default to user documents location\n     {\n-#if QT_VERSION < 0x050000\n-        myDir = QDesktopServices::storageLocation(QDesktopServices::DocumentsLocation);\n-#else\n         myDir = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);\n-#endif\n     }\n     else\n     {\n@@ -337,11 +315,7 @@ QString getOpenFileName(QWidget *parent, const QString &caption, const QString &\n     QString myDir;\n     if(dir.isEmpty()) // Default to user documents location\n     {\n-#if QT_VERSION < 0x050000\n-        myDir = QDesktopServices::storageLocation(QDesktopServices::DocumentsLocation);\n-#else\n         myDir = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);\n-#endif\n     }\n     else\n     {\n@@ -495,11 +469,7 @@ void TableViewLastColumnResizingFixer::disconnectViewHeadersSignals()\n // Refactored here for readability.\n void TableViewLastColumnResizingFixer::setViewHeaderResizeMode(int logicalIndex, QHeaderView::ResizeMode resizeMode)\n {\n-#if QT_VERSION < 0x050000\n-    tableView->horizontalHeader()->setResizeMode(logicalIndex, resizeMode);\n-#else\n     tableView->horizontalHeader()->setSectionResizeMode(logicalIndex, resizeMode);\n-#endif\n }\n \n void TableViewLastColumnResizingFixer::resizeColumn(int nColumnIndex, int width)"
      },
      {
        "sha": "e965a91d181fcf38c7d20e8f3129cbb93f3455e6",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -233,7 +233,7 @@ namespace GUIUtil\n         void mouseReleaseEvent(QMouseEvent *event);\n     };\n \n-#if defined(Q_OS_MAC) && QT_VERSION >= 0x050000\n+#if defined(Q_OS_MAC)\n     // workaround for Qt OSX Bug:\n     // https://bugreports.qt-project.org/browse/QTBUG-15631\n     // QProgressBar uses around 10% CPU even when app is in background"
      },
      {
        "sha": "a0b62ae00066e56f8e40efa7db3006d492c7b576",
        "filename": "src/qt/macdockiconhandler.mm",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/macdockiconhandler.mm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/macdockiconhandler.mm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.mm?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -14,10 +14,6 @@\n #include <objc/objc.h>\n #include <objc/message.h>\n \n-#if QT_VERSION < 0x050000\n-extern void qt_mac_set_dock_menu(QMenu *);\n-#endif\n-\n static MacDockIconHandler *s_instance = nullptr;\n \n bool dockClickHandler(id self,SEL _cmd,...) {\n@@ -54,9 +50,7 @@ void setupDockClickHandler() {\n     this->m_dummyWidget = new QWidget();\n     this->m_dockMenu = new QMenu(this->m_dummyWidget);\n     this->setMainWindow(nullptr);\n-#if QT_VERSION < 0x050000\n-    qt_mac_set_dock_menu(this->m_dockMenu);\n-#elif QT_VERSION >= 0x050200\n+#if QT_VERSION >= 0x050200\n     this->m_dockMenu->setAsDockMenu();\n #endif\n     [pool release];"
      },
      {
        "sha": "c4b732e3e00b346e31f04606deff11c13371f0c9",
        "filename": "src/qt/networkstyle.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/networkstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/networkstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/networkstyle.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -68,11 +68,7 @@ NetworkStyle::NetworkStyle(const QString &_appName, const int iconColorHueShift,\n         }\n \n         //convert back to QPixmap\n-#if QT_VERSION >= 0x040700\n         pixmap.convertFromImage(img);\n-#else\n-        pixmap = QPixmap::fromImage(img);\n-#endif\n     }\n \n     appIcon             = QIcon(pixmap);"
      },
      {
        "sha": "d211f908c801e89862f5f47db43e69698507eace",
        "filename": "src/qt/openuridialog.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/openuridialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/openuridialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/openuridialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,9 +15,7 @@ OpenURIDialog::OpenURIDialog(QWidget *parent) :\n     ui(new Ui::OpenURIDialog)\n {\n     ui->setupUi(this);\n-#if QT_VERSION >= 0x040700\n     ui->uriEdit->setPlaceholderText(\"bitcoin:\");\n-#endif\n }\n \n OpenURIDialog::~OpenURIDialog()"
      },
      {
        "sha": "3ff6f59c25c1350c26e7f646376c6ca0894d9ced",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 12,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -36,8 +36,17 @@ OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n     /* Main elements init */\n     ui->databaseCache->setMinimum(nMinDbCache);\n     ui->databaseCache->setMaximum(nMaxDbCache);\n+    static const uint64_t GiB = 1024 * 1024 * 1024;\n+    static const uint64_t nMinDiskSpace = MIN_DISK_SPACE_FOR_BLOCK_FILES / GiB +\n+                          (MIN_DISK_SPACE_FOR_BLOCK_FILES % GiB) ? 1 : 0;\n+    ui->pruneSize->setMinimum(nMinDiskSpace);\n     ui->threadsScriptVerif->setMinimum(-GetNumCores());\n     ui->threadsScriptVerif->setMaximum(MAX_SCRIPTCHECK_THREADS);\n+    ui->pruneWarning->setVisible(false);\n+    ui->pruneWarning->setStyleSheet(\"QLabel { color: red; }\");\n+\n+    ui->pruneSize->setEnabled(false);\n+    connect(ui->prune, SIGNAL(toggled(bool)), ui->pruneSize, SLOT(setEnabled(bool)));\n \n     /* Network elements init */\n #ifndef USE_UPNP\n@@ -88,28 +97,16 @@ OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n         /** check if the locale name consists of 2 parts (language_country) */\n         if(langStr.contains(\"_\"))\n         {\n-#if QT_VERSION >= 0x040800\n             /** display language strings as \"native language - native country (locale name)\", e.g. \"Deutsch - Deutschland (de)\" */\n             ui->lang->addItem(locale.nativeLanguageName() + QString(\" - \") + locale.nativeCountryName() + QString(\" (\") + langStr + QString(\")\"), QVariant(langStr));\n-#else\n-            /** display language strings as \"language - country (locale name)\", e.g. \"German - Germany (de)\" */\n-            ui->lang->addItem(QLocale::languageToString(locale.language()) + QString(\" - \") + QLocale::countryToString(locale.country()) + QString(\" (\") + langStr + QString(\")\"), QVariant(langStr));\n-#endif\n         }\n         else\n         {\n-#if QT_VERSION >= 0x040800\n             /** display language strings as \"native language (locale name)\", e.g. \"Deutsch (de)\" */\n             ui->lang->addItem(locale.nativeLanguageName() + QString(\" (\") + langStr + QString(\")\"), QVariant(langStr));\n-#else\n-            /** display language strings as \"language (locale name)\", e.g. \"German (de)\" */\n-            ui->lang->addItem(QLocale::languageToString(locale.language()) + QString(\" (\") + langStr + QString(\")\"), QVariant(langStr));\n-#endif\n         }\n     }\n-#if QT_VERSION >= 0x040700\n     ui->thirdPartyTxUrls->setPlaceholderText(\"https://example.com/tx/%s\");\n-#endif\n \n     ui->unit->setModel(new BitcoinUnits(this));\n \n@@ -157,6 +154,9 @@ void OptionsDialog::setModel(OptionsModel *_model)\n     /* warn when one of the following settings changes by user action (placed here so init via mapper doesn't trigger them) */\n \n     /* Main */\n+    connect(ui->prune, SIGNAL(clicked(bool)), this, SLOT(showRestartWarning()));\n+    connect(ui->prune, SIGNAL(clicked(bool)), this, SLOT(togglePruneWarning(bool)));\n+    connect(ui->pruneSize, SIGNAL(valueChanged(int)), this, SLOT(showRestartWarning()));\n     connect(ui->databaseCache, SIGNAL(valueChanged(int)), this, SLOT(showRestartWarning()));\n     connect(ui->threadsScriptVerif, SIGNAL(valueChanged(int)), this, SLOT(showRestartWarning()));\n     /* Wallet */\n@@ -176,6 +176,8 @@ void OptionsDialog::setMapper()\n     mapper->addMapping(ui->bitcoinAtStartup, OptionsModel::StartAtStartup);\n     mapper->addMapping(ui->threadsScriptVerif, OptionsModel::ThreadsScriptVerif);\n     mapper->addMapping(ui->databaseCache, OptionsModel::DatabaseCache);\n+    mapper->addMapping(ui->prune, OptionsModel::Prune);\n+    mapper->addMapping(ui->pruneSize, OptionsModel::PruneSize);\n \n     /* Wallet */\n     mapper->addMapping(ui->spendZeroConfChange, OptionsModel::SpendZeroConfChange);\n@@ -266,6 +268,11 @@ void OptionsDialog::on_hideTrayIcon_stateChanged(int fState)\n     }\n }\n \n+void OptionsDialog::togglePruneWarning(bool enabled)\n+{\n+    ui->pruneWarning->setVisible(!ui->pruneWarning->isVisible());\n+}\n+\n void OptionsDialog::showRestartWarning(bool fPersistent)\n {\n     ui->statusLabel->setStyleSheet(\"QLabel { color: red; }\");"
      },
      {
        "sha": "5aad484ce7751196bbf16b006eb5488d839d0b2e",
        "filename": "src/qt/optionsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -53,6 +53,7 @@ private Q_SLOTS:\n     \n     void on_hideTrayIcon_stateChanged(int fState);\n \n+    void togglePruneWarning(bool enabled);\n     void showRestartWarning(bool fPersistent = false);\n     void clearStatusLabel();\n     void updateProxyValidationState();"
      },
      {
        "sha": "31a85f4e235fb07f7a39d82362fdee9502544dd8",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -88,6 +88,16 @@ void OptionsModel::Init(bool resetSettings)\n     // by command-line and show this in the UI.\n \n     // Main\n+    if (!settings.contains(\"bPrune\"))\n+        settings.setValue(\"bPrune\", false);\n+    if (!settings.contains(\"nPruneSize\"))\n+        settings.setValue(\"nPruneSize\", 2);\n+    // Convert prune size to MB:\n+    const uint64_t nPruneSizeMB = settings.value(\"nPruneSize\").toInt() * 1000;\n+    if (!m_node.softSetArg(\"-prune\", settings.value(\"bPrune\").toBool() ? std::to_string(nPruneSizeMB) : \"0\")) {\n+      addOverriddenOption(\"-prune\");\n+    }\n+\n     if (!settings.contains(\"nDatabaseCache\"))\n         settings.setValue(\"nDatabaseCache\", (qint64)nDefaultDbCache);\n     if (!m_node.softSetArg(\"-dbcache\", settings.value(\"nDatabaseCache\").toString().toStdString()))\n@@ -281,6 +291,10 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n             return settings.value(\"language\");\n         case CoinControlFeatures:\n             return fCoinControlFeatures;\n+        case Prune:\n+            return settings.value(\"bPrune\");\n+        case PruneSize:\n+            return settings.value(\"nPruneSize\");\n         case DatabaseCache:\n             return settings.value(\"nDatabaseCache\");\n         case ThreadsScriptVerif:\n@@ -405,6 +419,18 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             settings.setValue(\"fCoinControlFeatures\", fCoinControlFeatures);\n             Q_EMIT coinControlFeaturesChanged(fCoinControlFeatures);\n             break;\n+        case Prune:\n+            if (settings.value(\"bPrune\") != value) {\n+                settings.setValue(\"bPrune\", value);\n+                setRestartRequired(true);\n+            }\n+            break;\n+        case PruneSize:\n+            if (settings.value(\"nPruneSize\") != value) {\n+                settings.setValue(\"nPruneSize\", value);\n+                setRestartRequired(true);\n+            }\n+            break;\n         case DatabaseCache:\n             if (settings.value(\"nDatabaseCache\") != value) {\n                 settings.setValue(\"nDatabaseCache\", value);"
      },
      {
        "sha": "2777cbeaf2cdcb07d476d991826ab441c31be916",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -50,6 +50,8 @@ class OptionsModel : public QAbstractListModel\n         Language,               // QString\n         CoinControlFeatures,    // bool\n         ThreadsScriptVerif,     // int\n+        Prune,                  // bool\n+        PruneSize,              // int\n         DatabaseCache,          // int\n         SpendZeroConfChange,    // bool\n         Listen,                 // bool"
      },
      {
        "sha": "dfeb70d6693ad05f31809efab4e5727e89b2fc5b",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -97,12 +97,10 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n             qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: certificate expired or not yet active: \" << qCert;\n             return false;\n         }\n-#if QT_VERSION >= 0x050000\n         if (qCert.isBlacklisted()) {\n             qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: certificate blacklisted: \" << qCert;\n             return false;\n         }\n-#endif\n         const unsigned char *data = (const unsigned char *)certChain.certificate(i).data();\n         X509 *cert = d2i_X509(nullptr, &data, certChain.certificate(i).size());\n         if (cert)"
      },
      {
        "sha": "e5e6430959bb763d02bf47781d6a91173c52e46a",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -41,12 +41,7 @@\n #include <QSslSocket>\n #include <QStringList>\n #include <QTextDocument>\n-\n-#if QT_VERSION < 0x050000\n-#include <QUrl>\n-#else\n #include <QUrlQuery>\n-#endif\n \n const int BITCOIN_IPC_CONNECT_TIMEOUT = 1000; // milliseconds\n const QString BITCOIN_IPC_PREFIX(\"bitcoin:\");\n@@ -100,11 +95,7 @@ static QList<QString> savedPaymentRequests;\n \n static void ReportInvalidCertificate(const QSslCertificate& cert)\n {\n-#if QT_VERSION < 0x050000\n-    qDebug() << QString(\"%1: Payment server found an invalid certificate: \").arg(__func__) << cert.serialNumber() << cert.subjectInfo(QSslCertificate::CommonName) << cert.subjectInfo(QSslCertificate::OrganizationalUnitName);\n-#else\n     qDebug() << QString(\"%1: Payment server found an invalid certificate: \").arg(__func__) << cert.serialNumber() << cert.subjectInfo(QSslCertificate::CommonName) << cert.subjectInfo(QSslCertificate::DistinguishedNameQualifier) << cert.subjectInfo(QSslCertificate::OrganizationalUnitName);\n-#endif\n }\n \n //\n@@ -157,13 +148,11 @@ void PaymentServer::LoadRootCAs(X509_STORE* _store)\n             continue;\n         }\n \n-#if QT_VERSION >= 0x050000\n         // Blacklisted certificate\n         if (cert.isBlacklisted()) {\n             ReportInvalidCertificate(cert);\n             continue;\n         }\n-#endif\n         QByteArray certData = cert.toDer();\n         const unsigned char *data = (const unsigned char *)certData.data();\n \n@@ -413,11 +402,7 @@ void PaymentServer::handleURIOrFile(const QString& s)\n     }\n     else if (s.startsWith(BITCOIN_IPC_PREFIX, Qt::CaseInsensitive)) // bitcoin: URI\n     {\n-#if QT_VERSION < 0x050000\n-        QUrl uri(s);\n-#else\n         QUrlQuery uri((QUrl(s)));\n-#endif\n         if (uri.hasQueryItem(\"r\")) // payment request URI\n         {\n             QByteArray temp;"
      },
      {
        "sha": "0ca9d48bf6046a20ee298f5a9ba9939a561d3b4a",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -64,9 +64,7 @@ class PeerTablePriv\n \n             interfaces::Node::NodesStats nodes_stats;\n             node.getNodesStats(nodes_stats);\n-#if QT_VERSION >= 0x040700\n             cachedNodeStats.reserve(nodes_stats.size());\n-#endif\n             for (auto& node_stats : nodes_stats)\n             {\n                 CNodeCombinedStats stats;"
      },
      {
        "sha": "a3a10aac187eefad6bf143d2d9fb17ab86583118",
        "filename": "src/qt/platformstyle.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/platformstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/platformstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -46,7 +46,7 @@ void MakeSingleColorImage(QImage& img, const QColor& colorbase)\n QIcon ColorizeIcon(const QIcon& ico, const QColor& colorbase)\n {\n     QIcon new_ico;\n-    for (const QSize sz : ico.availableSizes())\n+    for (const QSize& sz : ico.availableSizes())\n     {\n         QImage img(ico.pixmap(sz).toImage());\n         MakeSingleColorImage(img, colorbase);"
      },
      {
        "sha": "f9610f2d3b1def98729080b0245c2034d6e1bf97",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -16,9 +16,6 @@\n #include <QMimeData>\n #include <QMouseEvent>\n #include <QPixmap>\n-#if QT_VERSION < 0x050000\n-#include <QUrl>\n-#endif\n \n #if defined(HAVE_CONFIG_H)\n #include <config/bitcoin-config.h> /* for USE_QRCODE */"
      },
      {
        "sha": "76e36e4f3140e4eade09e31c0eaae98353fe43ec",
        "filename": "src/qt/res/movies/makespinner.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/res/movies/makespinner.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/res/movies/makespinner.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/movies/makespinner.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,6 +2,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n FRAMEDIR=$(dirname $0)\n for i in {0..35}\n do"
      },
      {
        "sha": "f222357f27d7f3925aebfef28860c2fa3e05c777",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 8,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -40,10 +40,6 @@\n #include <QTimer>\n #include <QStringList>\n \n-#if QT_VERSION < 0x050000\n-#include <QUrl>\n-#endif\n-\n // TODO: add a scrollback limit, as there is currently none\n // TODO: make it possible to filter out categories (esp debug messages when implemented)\n // TODO: receive errors and debug messages through ClientModel\n@@ -312,7 +308,7 @@ bool RPCConsole::RPCParseCommandLine(interfaces::Node* node, std::string &strRes\n                             std::string method = stack.back()[0];\n                             std::string uri;\n #ifdef ENABLE_WALLET\n-                            if (walletID && !walletID->empty()) {\n+                            if (walletID) {\n                                 QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(*walletID));\n                                 uri = \"/wallet/\"+std::string(encodedName.constData(), encodedName.length());\n                             }\n@@ -425,7 +421,7 @@ void RPCExecutor::request(const QString &command, const QString &walletID)\n             return;\n         }\n         std::string wallet_id = walletID.toStdString();\n-        if(!RPCConsole::RPCExecuteCommandLine(m_node, result, executableCommand, nullptr, &wallet_id))\n+        if (!RPCConsole::RPCExecuteCommandLine(m_node, result, executableCommand, nullptr, walletID.isNull() ? nullptr : &wallet_id))\n         {\n             Q_EMIT reply(RPCConsole::CMD_ERROR, QString(\"Parse error: unbalanced ' or \\\"\"));\n             return;\n@@ -702,7 +698,8 @@ void RPCConsole::addWallet(WalletModel * const walletModel)\n {\n     const QString name = walletModel->getWalletName();\n     // use name for text and internal data object (to allow to move to a wallet id later)\n-    ui->WalletSelector->addItem(name, name);\n+    QString display_name = name.isEmpty() ? \"[\"+tr(\"default wallet\")+\"]\" : name;\n+    ui->WalletSelector->addItem(display_name, name);\n     if (ui->WalletSelector->count() == 2 && !isVisible()) {\n         // First wallet added, set to default so long as the window isn't presently visible (and potentially in use)\n         ui->WalletSelector->setCurrentIndex(1);\n@@ -712,6 +709,16 @@ void RPCConsole::addWallet(WalletModel * const walletModel)\n         ui->WalletSelectorLabel->setVisible(true);\n     }\n }\n+\n+void RPCConsole::removeWallet(WalletModel * const walletModel)\n+{\n+    const QString name = walletModel->getWalletName();\n+    ui->WalletSelector->removeItem(ui->WalletSelector->findData(name));\n+    if (ui->WalletSelector->count() == 2) {\n+        ui->WalletSelector->setVisible(false);\n+        ui->WalletSelectorLabel->setVisible(false);\n+    }\n+}\n #endif\n \n static QString categoryClass(int category)\n@@ -909,7 +916,7 @@ void RPCConsole::on_lineEdit_returnPressed()\n         }\n \n         if (m_last_wallet_id != walletID) {\n-            if (walletID.isEmpty()) {\n+            if (walletID.isNull()) {\n                 message(CMD_REQUEST, tr(\"Executing command without any wallet\"));\n             } else {\n                 message(CMD_REQUEST, tr(\"Executing command using \\\"%1\\\" wallet\").arg(walletID));"
      },
      {
        "sha": "0a1a469934128decfad627942e92ead5f335b724",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -48,6 +48,7 @@ class RPCConsole: public QWidget\n \n     void setClientModel(ClientModel *model);\n     void addWallet(WalletModel * const walletModel);\n+    void removeWallet(WalletModel* const walletModel);\n \n     enum MessageClass {\n         MC_ERROR,"
      },
      {
        "sha": "e8c85bc2a18ff3fb39af13b66fe7a5790d887e8b",
        "filename": "src/qt/sendcoinsentry.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/sendcoinsentry.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/sendcoinsentry.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -32,9 +32,7 @@ SendCoinsEntry::SendCoinsEntry(const PlatformStyle *_platformStyle, QWidget *par\n \n     if (platformStyle->getUseExtraSpacing())\n         ui->payToLayout->setSpacing(4);\n-#if QT_VERSION >= 0x040700\n     ui->addAsLabel->setPlaceholderText(tr(\"Enter a label for this address to add it to your address book\"));\n-#endif\n \n     // normal bitcoin address field\n     GUIUtil::setupAddressWidget(ui->payTo, this);"
      },
      {
        "sha": "c8e694e658ca5b6fab572261adbc4828988145b1",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -37,9 +37,7 @@ SignVerifyMessageDialog::SignVerifyMessageDialog(const PlatformStyle *_platformS\n     ui->verifyMessageButton_VM->setIcon(platformStyle->SingleColorIcon(\":/icons/transaction_0\"));\n     ui->clearButton_VM->setIcon(platformStyle->SingleColorIcon(\":/icons/remove\"));\n \n-#if QT_VERSION >= 0x040700\n     ui->signatureOut_SM->setPlaceholderText(tr(\"Click \\\"Sign Message\\\" to generate signature\"));\n-#endif\n \n     GUIUtil::setupAddressWidget(ui->addressIn_SM, this);\n     GUIUtil::setupAddressWidget(ui->addressIn_VM, this);"
      },
      {
        "sha": "c3d33c76d42a229b2946addb68f2056ecb83b9b5",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -56,15 +56,15 @@ void EditAddressAndSubmit(\n void TestAddAddressesToSendBook()\n {\n     TestChain100Setup test;\n-    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n+    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"mock\", WalletDatabase::CreateMock());\n     bool firstRun;\n-    wallet.LoadWallet(firstRun);\n+    wallet->LoadWallet(firstRun);\n \n     auto build_address = [&wallet]() {\n         CKey key;\n         key.MakeNewKey(true);\n         CTxDestination dest(GetDestinationForKey(\n-            key.GetPubKey(), wallet.m_default_address_type));\n+            key.GetPubKey(), wallet->m_default_address_type));\n \n         return std::make_pair(dest, QString::fromStdString(EncodeDestination(dest)));\n     };\n@@ -87,13 +87,13 @@ void TestAddAddressesToSendBook()\n     std::tie(std::ignore, new_address) = build_address();\n \n     {\n-        LOCK(wallet.cs_wallet);\n-        wallet.SetAddressBook(r_key_dest, r_label.toStdString(), \"receive\");\n-        wallet.SetAddressBook(s_key_dest, s_label.toStdString(), \"send\");\n+        LOCK(wallet->cs_wallet);\n+        wallet->SetAddressBook(r_key_dest, r_label.toStdString(), \"receive\");\n+        wallet->SetAddressBook(s_key_dest, s_label.toStdString(), \"send\");\n     }\n \n     auto check_addbook_size = [&wallet](int expected_size) {\n-        QCOMPARE(static_cast<int>(wallet.mapAddressBook.size()), expected_size);\n+        QCOMPARE(static_cast<int>(wallet->mapAddressBook.size()), expected_size);\n     };\n \n     // We should start with the two addresses we added earlier and nothing else.\n@@ -103,9 +103,9 @@ void TestAddAddressesToSendBook()\n     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n     auto node = interfaces::MakeNode();\n     OptionsModel optionsModel(*node);\n-    AddWallet(&wallet);\n+    AddWallet(wallet);\n     WalletModel walletModel(std::move(node->getWallets()[0]), *node, platformStyle.get(), &optionsModel);\n-    RemoveWallet(&wallet);\n+    RemoveWallet(wallet);\n     EditAddressDialog editAddressDialog(EditAddressDialog::NewSendingAddress);\n     editAddressDialog.setModel(walletModel.getAddressTableModel());\n "
      },
      {
        "sha": "f0ac43a58c96d3f144b75489d1db9ccf007ec961",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -26,12 +26,6 @@\n \n #if defined(QT_STATICPLUGIN)\n #include <QtPlugin>\n-#if QT_VERSION < 0x050000\n-Q_IMPORT_PLUGIN(qcncodecs)\n-Q_IMPORT_PLUGIN(qjpcodecs)\n-Q_IMPORT_PLUGIN(qtwcodecs)\n-Q_IMPORT_PLUGIN(qkrcodecs)\n-#else\n #if defined(QT_QPA_PLATFORM_MINIMAL)\n Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin);\n #endif\n@@ -43,7 +37,6 @@ Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);\n Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin);\n #endif\n #endif\n-#endif\n \n extern void noui_connect();\n "
      },
      {
        "sha": "c314dadde449521a204e8aaa00d08c9626e154b6",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 24,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -87,17 +87,6 @@ QModelIndex FindTx(const QAbstractItemModel& model, const uint256& txid)\n     return {};\n }\n \n-//! Request context menu (call method that is public in qt5, but protected in qt4).\n-void RequestContextMenu(QWidget* widget)\n-{\n-    class Qt4Hack : public QWidget\n-    {\n-    public:\n-        using QWidget::customContextMenuRequested;\n-    };\n-    static_cast<Qt4Hack*>(widget)->customContextMenuRequested({});\n-}\n-\n //! Invoke bumpfee on txid and check results.\n void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, std::string expectError, bool cancel)\n {\n@@ -110,7 +99,7 @@ void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, st\n     QAction* action = view.findChild<QAction*>(\"bumpFeeAction\");\n     table->selectionModel()->select(index, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\n     action->setEnabled(expectDisabled);\n-    RequestContextMenu(table);\n+    table->customContextMenuRequested({});\n     QCOMPARE(action->isEnabled(), !expectDisabled);\n \n     action->setEnabled(true);\n@@ -144,39 +133,39 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n+    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"mock\", WalletDatabase::CreateMock());\n     bool firstRun;\n-    wallet.LoadWallet(firstRun);\n+    wallet->LoadWallet(firstRun);\n     {\n-        LOCK(wallet.cs_wallet);\n-        wallet.SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), wallet.m_default_address_type), \"\", \"receive\");\n-        wallet.AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n+        LOCK(wallet->cs_wallet);\n+        wallet->SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), wallet->m_default_address_type), \"\", \"receive\");\n+        wallet->AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n     }\n     {\n         LOCK(cs_main);\n-        WalletRescanReserver reserver(&wallet);\n+        WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        wallet.ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, true);\n+        wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, true);\n     }\n-    wallet.SetBroadcastTransactions(true);\n+    wallet->SetBroadcastTransactions(true);\n \n     // Create widgets for sending coins and listing transactions.\n     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n     SendCoinsDialog sendCoinsDialog(platformStyle.get());\n     TransactionView transactionView(platformStyle.get());\n     auto node = interfaces::MakeNode();\n     OptionsModel optionsModel(*node);\n-    AddWallet(&wallet);\n+    AddWallet(wallet);\n     WalletModel walletModel(std::move(node->getWallets().back()), *node, platformStyle.get(), &optionsModel);\n-    RemoveWallet(&wallet);\n+    RemoveWallet(wallet);\n     sendCoinsDialog.setModel(&walletModel);\n     transactionView.setModel(&walletModel);\n \n     // Send two transactions, and verify they are added to transaction list.\n     TransactionTableModel* transactionTableModel = walletModel.getTransactionTableModel();\n     QCOMPARE(transactionTableModel->rowCount({}), 105);\n-    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CKeyID(), 5 * COIN, false /* rbf */);\n-    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CKeyID(), 10 * COIN, true /* rbf */);\n+    uint256 txid1 = SendCoins(*wallet.get(), sendCoinsDialog, CKeyID(), 5 * COIN, false /* rbf */);\n+    uint256 txid2 = SendCoins(*wallet.get(), sendCoinsDialog, CKeyID(), 10 * COIN, true /* rbf */);\n     QCOMPARE(transactionTableModel->rowCount({}), 107);\n     QVERIFY(FindTx(*transactionTableModel, txid1).isValid());\n     QVERIFY(FindTx(*transactionTableModel, txid2).isValid());"
      },
      {
        "sha": "e60a387934f8f72e4b07f14705a5b59bd0187d73",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -95,15 +95,11 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     hlayout->addWidget(typeWidget);\n \n     search_widget = new QLineEdit(this);\n-#if QT_VERSION >= 0x040700\n     search_widget->setPlaceholderText(tr(\"Enter address, transaction id, or label to search\"));\n-#endif\n     hlayout->addWidget(search_widget);\n \n     amountWidget = new QLineEdit(this);\n-#if QT_VERSION >= 0x040700\n     amountWidget->setPlaceholderText(tr(\"Min amount\"));\n-#endif\n     if (platformStyle->getUseExtraSpacing()) {\n         amountWidget->setFixedWidth(97);\n     } else {"
      },
      {
        "sha": "1da25b076188b34a2fc3ef09d45f399d8adba22a",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -70,8 +70,8 @@ HelpMessageDialog::HelpMessageDialog(interfaces::Node& node, QWidget *parent, bo\n         ui->helpMessage->setVisible(false);\n     } else {\n         setWindowTitle(tr(\"Command-line options\"));\n-        QString header = tr(\"Usage:\") + \"\\n\" +\n-            \"  bitcoin-qt [\" + tr(\"command-line options\") + \"]                     \" + \"\\n\";\n+        QString header = \"Usage:\\n\"\n+            \"  bitcoin-qt [command-line options]                     \\n\";\n         QTextCursor cursor(ui->helpMessage->document());\n         cursor.insertText(version);\n         cursor.insertBlock();"
      },
      {
        "sha": "c5a13f61f4a25016dbf64200bce3b2c57e31d356",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -94,6 +94,7 @@ bool WalletFrame::removeWallet(const QString &name)\n \n     WalletView *walletView = mapWalletViews.take(name);\n     walletStack->removeWidget(walletView);\n+    delete walletView;\n     return true;\n }\n "
      },
      {
        "sha": "389acf0a95a9d7ce7addc414916484d4fe67d0fd",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -364,6 +364,12 @@ bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureStri\n }\n \n // Handlers for core signals\n+static void NotifyUnload(WalletModel* walletModel)\n+{\n+    qDebug() << \"NotifyUnload\";\n+    QMetaObject::invokeMethod(walletModel, \"unload\", Qt::QueuedConnection);\n+}\n+\n static void NotifyKeyStoreStatusChanged(WalletModel *walletmodel)\n {\n     qDebug() << \"NotifyKeyStoreStatusChanged\";\n@@ -411,6 +417,7 @@ static void NotifyWatchonlyChanged(WalletModel *walletmodel, bool fHaveWatchonly\n void WalletModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n+    m_handler_unload = m_wallet->handleUnload(boost::bind(&NotifyUnload, this));\n     m_handler_status_changed = m_wallet->handleStatusChanged(boost::bind(&NotifyKeyStoreStatusChanged, this));\n     m_handler_address_book_changed = m_wallet->handleAddressBookChanged(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5));\n     m_handler_transaction_changed = m_wallet->handleTransactionChanged(boost::bind(NotifyTransactionChanged, this, _1, _2));\n@@ -421,6 +428,7 @@ void WalletModel::subscribeToCoreSignals()\n void WalletModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n+    m_handler_unload->disconnect();\n     m_handler_status_changed->disconnect();\n     m_handler_address_book_changed->disconnect();\n     m_handler_transaction_changed->disconnect();"
      },
      {
        "sha": "35ededb12103c42fff226be7b08c9c5d968077d3",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -208,6 +208,7 @@ class WalletModel : public QObject\n     AddressTableModel* getAddressTableModel() const { return addressTableModel; }\n private:\n     std::unique_ptr<interfaces::Wallet> m_wallet;\n+    std::unique_ptr<interfaces::Handler> m_handler_unload;\n     std::unique_ptr<interfaces::Handler> m_handler_status_changed;\n     std::unique_ptr<interfaces::Handler> m_handler_address_book_changed;\n     std::unique_ptr<interfaces::Handler> m_handler_transaction_changed;\n@@ -261,6 +262,9 @@ class WalletModel : public QObject\n     // Watch-only address added\n     void notifyWatchonlyChanged(bool fHaveWatchonly);\n \n+    // Signal that wallet is about to be removed\n+    void unload();\n+\n public Q_SLOTS:\n     /* Wallet status might have changed */\n     void updateStatus();"
      },
      {
        "sha": "6190a74598757af0167940b4b9fe05563b083633",
        "filename": "src/qt/winshutdownmonitor.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/winshutdownmonitor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/winshutdownmonitor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <qt/winshutdownmonitor.h>\n \n-#if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n+#if defined(Q_OS_WIN)\n #include <init.h>\n #include <util.h>\n "
      },
      {
        "sha": "c8a523a538e0f390ac6e1822a55dd11ccddfdf40",
        "filename": "src/qt/winshutdownmonitor.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/winshutdownmonitor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/qt/winshutdownmonitor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -9,7 +9,6 @@\n #include <QByteArray>\n #include <QString>\n \n-#if QT_VERSION >= 0x050000\n #include <windef.h> // for HWND\n \n #include <QAbstractNativeEventFilter>\n@@ -24,6 +23,5 @@ class WinShutdownMonitor : public QAbstractNativeEventFilter\n     static void registerShutdownBlockReason(const QString& strReason, const HWND& mainWinId);\n };\n #endif\n-#endif\n \n #endif // BITCOIN_QT_WINSHUTDOWNMONITOR_H"
      },
      {
        "sha": "fee6c2d92aaa6f09787dfed97bc33547e7ce6d49",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -34,6 +34,7 @@\n #include <sys/random.h>\n #endif\n #ifdef HAVE_SYSCTL_ARND\n+#include <utilstrencodings.h> // for ARRAYLEN\n #include <sys/sysctl.h>\n #endif\n "
      },
      {
        "sha": "a5f164497da30aa6549cf3b61ba64a72503ecb01",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -217,7 +217,7 @@ static bool rest_block(HTTPRequest* req,\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n         }\n \n-        if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+        if (IsBlockPruned(pblockindex))\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n         if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))"
      },
      {
        "sha": "d9d803ac7dc9294a1f05e17d385e6f0553902ea8",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 17,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,7 +6,6 @@\n #include <rpc/blockchain.h>\n \n #include <amount.h>\n-#include <chain.h>\n #include <chainparams.h>\n #include <checkpoints.h>\n #include <coins.h>\n@@ -49,17 +48,13 @@ static std::mutex cs_blockchange;\n static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock;\n \n-/* Calculate the difficulty for a given block index,\n- * or the block index of the given chain.\n+/* Calculate the difficulty for a given block index.\n  */\n-double GetDifficulty(const CChain& chain, const CBlockIndex* blockindex)\n+double GetDifficulty(const CBlockIndex* blockindex)\n {\n     if (blockindex == nullptr)\n     {\n-        if (chain.Tip() == nullptr)\n-            return 1.0;\n-        else\n-            blockindex = chain.Tip();\n+        return 1.0;\n     }\n \n     int nShift = (blockindex->nBits >> 24) & 0xff;\n@@ -80,11 +75,6 @@ double GetDifficulty(const CChain& chain, const CBlockIndex* blockindex)\n     return dDiff;\n }\n \n-double GetDifficulty(const CBlockIndex* blockindex)\n-{\n-    return GetDifficulty(chainActive, blockindex);\n-}\n-\n UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n {\n     AssertLockHeld(cs_main);\n@@ -105,6 +95,7 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n     result.pushKV(\"bits\", strprintf(\"%08x\", blockindex->nBits));\n     result.pushKV(\"difficulty\", GetDifficulty(blockindex));\n     result.pushKV(\"chainwork\", blockindex->nChainWork.GetHex());\n+    result.pushKV(\"nTx\", (uint64_t)blockindex->nTx);\n \n     if (blockindex->pprev)\n         result.pushKV(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex());\n@@ -150,6 +141,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n     result.pushKV(\"bits\", strprintf(\"%08x\", block.nBits));\n     result.pushKV(\"difficulty\", GetDifficulty(blockindex));\n     result.pushKV(\"chainwork\", blockindex->nChainWork.GetHex());\n+    result.pushKV(\"nTx\", (uint64_t)blockindex->nTx);\n \n     if (blockindex->pprev)\n         result.pushKV(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex());\n@@ -354,7 +346,7 @@ static UniValue getdifficulty(const JSONRPCRequest& request)\n         );\n \n     LOCK(cs_main);\n-    return GetDifficulty();\n+    return GetDifficulty(chainActive.Tip());\n }\n \n static std::string EntryDescriptionString()\n@@ -704,6 +696,7 @@ static UniValue getblockheader(const JSONRPCRequest& request)\n             \"  \\\"bits\\\" : \\\"1d00ffff\\\", (string) The bits\\n\"\n             \"  \\\"difficulty\\\" : x.xxx,  (numeric) The difficulty\\n\"\n             \"  \\\"chainwork\\\" : \\\"0000...1f3\\\"     (string) Expected number of hashes required to produce the current chain (in hex)\\n\"\n+            \"  \\\"nTx\\\" : n,             (numeric) The number of transactions in the block.\\n\"\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\",      (string) The hash of the next block\\n\"\n             \"}\\n\"\n@@ -742,7 +735,7 @@ static UniValue getblockheader(const JSONRPCRequest& request)\n static CBlock GetBlockChecked(const CBlockIndex* pblockindex)\n {\n     CBlock block;\n-    if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0) {\n+    if (IsBlockPruned(pblockindex)) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not available (pruned data)\");\n     }\n \n@@ -792,6 +785,7 @@ static UniValue getblock(const JSONRPCRequest& request)\n             \"  \\\"bits\\\" : \\\"1d00ffff\\\", (string) The bits\\n\"\n             \"  \\\"difficulty\\\" : x.xxx,  (numeric) The difficulty\\n\"\n             \"  \\\"chainwork\\\" : \\\"xxxx\\\",  (string) Expected number of hashes required to produce the chain up to this block (in hex)\\n\"\n+            \"  \\\"nTx\\\" : n,             (numeric) The number of transactions in the block.\\n\"\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\"       (string) The hash of the next block\\n\"\n             \"}\\n\"\n@@ -859,7 +853,7 @@ static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash,\n     ss << hash;\n     ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase ? 1u : 0u);\n     stats.nTransactions++;\n-    for (const auto output : outputs) {\n+    for (const auto& output : outputs) {\n         ss << VARINT(output.first + 1);\n         ss << output.second.out.scriptPubKey;\n         ss << VARINT(output.second.out.nValue, VarIntMode::NONNEGATIVE_SIGNED);\n@@ -1240,7 +1234,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     obj.pushKV(\"blocks\",                (int)chainActive.Height());\n     obj.pushKV(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1);\n     obj.pushKV(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex());\n-    obj.pushKV(\"difficulty\",            (double)GetDifficulty());\n+    obj.pushKV(\"difficulty\",            (double)GetDifficulty(chainActive.Tip()));\n     obj.pushKV(\"mediantime\",            (int64_t)chainActive.Tip()->GetMedianTimePast());\n     obj.pushKV(\"verificationprogress\",  GuessVerificationProgress(Params().TxData(), chainActive.Tip()));\n     obj.pushKV(\"initialblockdownload\",  IsInitialBlockDownload());"
      },
      {
        "sha": "3aa8de2d2b899faa0a82b7c5a5780a463e5f0395",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -16,7 +16,7 @@ class UniValue;\n  * @return A floating point number that is a multiple of the main net minimum\n  * difficulty (4295032833 hashes).\n  */\n-double GetDifficulty(const CBlockIndex* blockindex = nullptr);\n+double GetDifficulty(const CBlockIndex* blockindex);\n \n /** Callback for when block tip changed. */\n void RPCNotifyBlockChange(bool ibd, const CBlockIndex *);\n@@ -34,4 +34,3 @@ UniValue mempoolToJSON(bool fVerbose = false);\n UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n \n #endif\n-"
      },
      {
        "sha": "0f35fd3770d0bbafbe2052814d5a4fcb2c846299",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -52,7 +52,6 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listreceivedbylabel\", 0, \"minconf\" },\n     { \"listreceivedbylabel\", 1, \"include_empty\" },\n     { \"listreceivedbylabel\", 2, \"include_watchonly\" },\n-    { \"getlabeladdress\", 1, \"force\" },\n     { \"getbalance\", 1, \"minconf\" },\n     { \"getbalance\", 2, \"include_watchonly\" },\n     { \"getblockhash\", 0, \"height\" },"
      },
      {
        "sha": "81c4fb040f42f754fc36c75fc37dc6353dde0fc5",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -214,7 +214,7 @@ static UniValue getmininginfo(const JSONRPCRequest& request)\n     obj.pushKV(\"blocks\",           (int)chainActive.Height());\n     obj.pushKV(\"currentblockweight\", (uint64_t)nLastBlockWeight);\n     obj.pushKV(\"currentblocktx\",   (uint64_t)nLastBlockTx);\n-    obj.pushKV(\"difficulty\",       (double)GetDifficulty());\n+    obj.pushKV(\"difficulty\",       (double)GetDifficulty(chainActive.Tip()));\n     obj.pushKV(\"networkhashps\",    getnetworkhashps(request));\n     obj.pushKV(\"pooledtx\",         (uint64_t)mempool.size());\n     obj.pushKV(\"chain\",            Params().NetworkIDString());\n@@ -725,7 +725,6 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     }\n \n     uint256 hash = block.GetHash();\n-    bool fBlockPresent = false;\n     {\n         LOCK(cs_main);\n         const CBlockIndex* pindex = LookupBlockIndex(hash);\n@@ -736,8 +735,6 @@ static UniValue submitblock(const JSONRPCRequest& request)\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 return \"duplicate-invalid\";\n             }\n-            // Otherwise, we might only have the header - process the block before returning\n-            fBlockPresent = true;\n         }\n     }\n \n@@ -749,13 +746,15 @@ static UniValue submitblock(const JSONRPCRequest& request)\n         }\n     }\n \n+    bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, nullptr);\n+    bool accepted = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n     UnregisterValidationInterface(&sc);\n-    if (fBlockPresent) {\n-        if (fAccepted && !sc.found) {\n-            return \"duplicate-inconclusive\";\n+    if (!new_block) {\n+        if (!accepted) {\n+            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?\n+            return \"invalid\";\n         }\n         return \"duplicate\";\n     }"
      },
      {
        "sha": "8fa56e933544eb4cef71401cd63eb10726af2b4a",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -475,7 +475,7 @@ static UniValue getnetworkinfo(const JSONRPCRequest& request)\n     UniValue localAddresses(UniValue::VARR);\n     {\n         LOCK(cs_mapLocalHost);\n-        for (const std::pair<CNetAddr, LocalServiceInfo> &item : mapLocalHost)\n+        for (const std::pair<const CNetAddr, LocalServiceInfo> &item : mapLocalHost)\n         {\n             UniValue rec(UniValue::VOBJ);\n             rec.pushKV(\"address\", item.first.ToString());"
      },
      {
        "sha": "3b3f43edea7a2efcff82825f9543e0528fefd7ef",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -748,7 +748,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n             }\n         }\n \n-        UpdateTransaction(mergedTx, i, sigdata);\n+        UpdateInput(txin, sigdata);\n     }\n \n     return EncodeHexTx(mergedTx);\n@@ -882,7 +882,7 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n         }\n         sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n \n-        UpdateTransaction(mtx, i, sigdata);\n+        UpdateInput(txin, sigdata);\n \n         ScriptError serror = SCRIPT_ERR_OK;\n         if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n@@ -988,7 +988,8 @@ static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n UniValue signrawtransaction(const JSONRPCRequest& request)\n {\n #ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n #endif\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)"
      },
      {
        "sha": "4b982d647d8aab9b378fda985e190661cc033369",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 13,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1089,17 +1089,19 @@ namespace {\n  * Wrapper that serializes like CTransaction, but with the modifications\n  *  required for the signature hash done in-place\n  */\n-class CTransactionSignatureSerializer {\n+template <class T>\n+class CTransactionSignatureSerializer\n+{\n private:\n-    const CTransaction& txTo;  //!< reference to the spending transaction (the one being serialized)\n+    const T& txTo;             //!< reference to the spending transaction (the one being serialized)\n     const CScript& scriptCode; //!< output script being consumed\n     const unsigned int nIn;    //!< input index of txTo being signed\n     const bool fAnyoneCanPay;  //!< whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n     const bool fHashSingle;    //!< whether the hashtype is SIGHASH_SINGLE\n     const bool fHashNone;      //!< whether the hashtype is SIGHASH_NONE\n \n public:\n-    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n+    CTransactionSignatureSerializer(const T& txToIn, const CScript& scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n         txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n         fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n         fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n@@ -1180,23 +1182,29 @@ class CTransactionSignatureSerializer {\n     }\n };\n \n-uint256 GetPrevoutHash(const CTransaction& txTo) {\n+template <class T>\n+uint256 GetPrevoutHash(const T& txTo)\n+{\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n     return ss.GetHash();\n }\n \n-uint256 GetSequenceHash(const CTransaction& txTo) {\n+template <class T>\n+uint256 GetSequenceHash(const T& txTo)\n+{\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n     return ss.GetHash();\n }\n \n-uint256 GetOutputsHash(const CTransaction& txTo) {\n+template <class T>\n+uint256 GetOutputsHash(const T& txTo)\n+{\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n@@ -1206,7 +1214,8 @@ uint256 GetOutputsHash(const CTransaction& txTo) {\n \n } // namespace\n \n-PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo)\n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n@@ -1217,7 +1226,12 @@ PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo)\n     }\n }\n \n-uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)\n+// explicit instantiation\n+template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n+template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n+\n+template <class T>\n+uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)\n {\n     assert(nIn < txTo.vin.size());\n \n@@ -1278,20 +1292,22 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n     }\n \n     // Wrapper to serialize only the necessary parts of the transaction being signed\n-    CTransactionSignatureSerializer txTmp(txTo, scriptCode, nIn, nHashType);\n+    CTransactionSignatureSerializer<T> txTmp(txTo, scriptCode, nIn, nHashType);\n \n     // Serialize and hash\n     CHashWriter ss(SER_GETHASH, 0);\n     ss << txTmp << nHashType;\n     return ss.GetHash();\n }\n \n-bool TransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n {\n     return pubkey.Verify(sighash, vchSig);\n }\n \n-bool TransactionSignatureChecker::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n@@ -1312,7 +1328,8 @@ bool TransactionSignatureChecker::CheckSig(const std::vector<unsigned char>& vch\n     return true;\n }\n \n-bool TransactionSignatureChecker::CheckLockTime(const CScriptNum& nLockTime) const\n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckLockTime(const CScriptNum& nLockTime) const\n {\n     // There are two kinds of nLockTime: lock-by-blockheight\n     // and lock-by-blocktime, distinguished by whether\n@@ -1348,7 +1365,8 @@ bool TransactionSignatureChecker::CheckLockTime(const CScriptNum& nLockTime) con\n     return true;\n }\n \n-bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) const\n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSequence) const\n {\n     // Relative lock times are supported by comparing the passed\n     // in operand to the sequence number of the input.\n@@ -1394,6 +1412,10 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n+// explicit instantiation\n+template class GenericTransactionSignatureChecker<CTransaction>;\n+template class GenericTransactionSignatureChecker<CMutableTransaction>;\n+\n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     std::vector<std::vector<unsigned char> > stack;"
      },
      {
        "sha": "2d21aa81df4c0135d6d848938819ab3cb529d633",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 11,
        "deletions": 14,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -124,7 +124,8 @@ struct PrecomputedTransactionData\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n \n-    explicit PrecomputedTransactionData(const CTransaction& tx);\n+    template <class T>\n+    explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n@@ -137,7 +138,8 @@ enum class SigVersion\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n \n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n+template <class T>\n+uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n class BaseSignatureChecker\n {\n@@ -160,10 +162,11 @@ class BaseSignatureChecker\n     virtual ~BaseSignatureChecker() {}\n };\n \n-class TransactionSignatureChecker : public BaseSignatureChecker\n+template <class T>\n+class GenericTransactionSignatureChecker : public BaseSignatureChecker\n {\n private:\n-    const CTransaction* txTo;\n+    const T* txTo;\n     unsigned int nIn;\n     const CAmount amount;\n     const PrecomputedTransactionData* txdata;\n@@ -172,21 +175,15 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n     virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n+    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n+    GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n-class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n-{\n-private:\n-    const CTransaction txTo;\n-\n-public:\n-    MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : TransactionSignatureChecker(&txTo, nInIn, amountIn), txTo(*txToIn) {}\n-};\n+using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n+using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);"
      },
      {
        "sha": "43dd9e582e8cd6fe523199a3ed9041ae6d99dadb",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 35,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -28,6 +28,19 @@ enum class IsMineSigVersion\n     WITNESS_V0 = 2  //! P2WSH witness script execution\n };\n \n+/**\n+ * This is an internal representation of isminetype + invalidity.\n+ * Its order is significant, as we return the max of all explored\n+ * possibilities.\n+ */\n+enum class IsMineResult\n+{\n+    NO = 0,          //! Not ours\n+    WATCH_ONLY = 1,  //! Included in watch-only balance\n+    SPENDABLE = 2,   //! Included in all balances\n+    INVALID = 3,     //! Not spendable by anyone\n+};\n+\n bool PermitsUncompressed(IsMineSigVersion sigversion)\n {\n     return sigversion == IsMineSigVersion::TOP || sigversion == IsMineSigVersion::P2SH;\n@@ -42,17 +55,13 @@ bool HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n     return true;\n }\n \n-isminetype IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, IsMineSigVersion sigversion)\n+IsMineResult IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion)\n {\n-    isInvalid = false;\n+    IsMineResult ret = IsMineResult::NO;\n \n     std::vector<valtype> vSolutions;\n     txnouttype whichType;\n-    if (!Solver(scriptPubKey, whichType, vSolutions)) {\n-        if (keystore.HaveWatchOnly(scriptPubKey))\n-            return ISMINE_WATCH_UNSOLVABLE;\n-        return ISMINE_NO;\n-    }\n+    Solver(scriptPubKey, whichType, vSolutions);\n \n     CKeyID keyID;\n     switch (whichType)\n@@ -64,50 +73,58 @@ isminetype IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, b\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n         if (!PermitsUncompressed(sigversion) && vSolutions[0].size() != 33) {\n-            isInvalid = true;\n-            return ISMINE_NO;\n+            return IsMineResult::INVALID;\n+        }\n+        if (keystore.HaveKey(keyID)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n         }\n-        if (keystore.HaveKey(keyID))\n-            return ISMINE_SPENDABLE;\n         break;\n     case TX_WITNESS_V0_KEYHASH:\n     {\n+        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n+            // P2WPKH inside P2WSH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n         if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n             // We do not support bare witness outputs unless the P2SH version of it would be\n             // acceptable as well. This protects against matching before segwit activates.\n             // This also applies to the P2WSH case.\n             break;\n         }\n-        isminetype ret = IsMineInner(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, IsMineSigVersion::WITNESS_V0);\n-        if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n-            return ret;\n+        ret = std::max(ret, IsMineInner(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), IsMineSigVersion::WITNESS_V0));\n         break;\n     }\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n         if (!PermitsUncompressed(sigversion)) {\n             CPubKey pubkey;\n             if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n-                isInvalid = true;\n-                return ISMINE_NO;\n+                return IsMineResult::INVALID;\n             }\n         }\n-        if (keystore.HaveKey(keyID))\n-            return ISMINE_SPENDABLE;\n+        if (keystore.HaveKey(keyID)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n+        }\n         break;\n     case TX_SCRIPTHASH:\n     {\n+        if (sigversion != IsMineSigVersion::TOP) {\n+            // P2SH inside P2WSH or P2SH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n         CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMineInner(keystore, subscript, isInvalid, IsMineSigVersion::P2SH);\n-            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n-                return ret;\n+            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::P2SH));\n         }\n         break;\n     }\n     case TX_WITNESS_V0_SCRIPTHASH:\n     {\n+        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n+            // P2WSH inside P2WSH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n         if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n             break;\n         }\n@@ -116,17 +133,17 @@ isminetype IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, b\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMineInner(keystore, subscript, isInvalid, IsMineSigVersion::WITNESS_V0);\n-            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n-                return ret;\n+            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::WITNESS_V0));\n         }\n         break;\n     }\n \n     case TX_MULTISIG:\n     {\n         // Never treat bare multisig outputs as ours (they can still be made watchonly-though)\n-        if (sigversion == IsMineSigVersion::TOP) break;\n+        if (sigversion == IsMineSigVersion::TOP) {\n+            break;\n+        }\n \n         // Only consider transactions \"mine\" if we own ALL the\n         // keys involved. Multi-signature transactions that are\n@@ -137,30 +154,39 @@ isminetype IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, b\n         if (!PermitsUncompressed(sigversion)) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {\n-                    isInvalid = true;\n-                    return ISMINE_NO;\n+                    return IsMineResult::INVALID;\n                 }\n             }\n         }\n-        if (HaveKeys(keys, keystore))\n-            return ISMINE_SPENDABLE;\n+        if (HaveKeys(keys, keystore)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n+        }\n         break;\n     }\n     }\n \n-    if (keystore.HaveWatchOnly(scriptPubKey)) {\n-        // TODO: This could be optimized some by doing some work after the above solver\n-        SignatureData sigs;\n-        return ProduceSignature(keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigs) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n+    if (ret == IsMineResult::NO && keystore.HaveWatchOnly(scriptPubKey)) {\n+        ret = std::max(ret, IsMineResult::WATCH_ONLY);\n     }\n-    return ISMINE_NO;\n+    return ret;\n }\n \n } // namespace\n \n isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid)\n {\n-    return IsMineInner(keystore, scriptPubKey, isInvalid, IsMineSigVersion::TOP);\n+    isInvalid = false;\n+    switch (IsMineInner(keystore, scriptPubKey, IsMineSigVersion::TOP)) {\n+    case IsMineResult::INVALID:\n+        isInvalid = true;\n+    case IsMineResult::NO:\n+        return ISMINE_NO;\n+    case IsMineResult::WATCH_ONLY:\n+        return ISMINE_WATCH_ONLY;\n+    case IsMineResult::SPENDABLE:\n+        return ISMINE_SPENDABLE;\n+    }\n+    assert(false);\n }\n \n isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey)"
      },
      {
        "sha": "a15768aecb839d59aad434e767d5c4b2be6a6545",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -17,12 +17,8 @@ class CScript;\n enum isminetype\n {\n     ISMINE_NO = 0,\n-    //! Indicates that we don't know how to create a scriptSig that would solve this if we were given the appropriate private keys\n-    ISMINE_WATCH_UNSOLVABLE = 1,\n-    //! Indicates that we know how to create a scriptSig that would solve this if we were given the appropriate private keys\n-    ISMINE_WATCH_SOLVABLE = 2,\n-    ISMINE_WATCH_ONLY = ISMINE_WATCH_SOLVABLE | ISMINE_WATCH_UNSOLVABLE,\n-    ISMINE_SPENDABLE = 4,\n+    ISMINE_WATCH_ONLY = 1,\n+    ISMINE_SPENDABLE = 2,\n     ISMINE_ALL = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE\n };\n /** used for bitflags of isminetype */"
      },
      {
        "sha": "c84c7b8ec117c4667901d51d866cddd98d92ef37",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -141,11 +141,6 @@ const char* GetOpName(opcodetype opcode)\n \n     case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n \n-    // Note:\n-    //  The template matching params OP_SMALLINTEGER/etc are defined in opcodetype enum\n-    //  as kind of implementation hack, they are *NOT* real opcodes.  If found in real\n-    //  Script, just let the default: case deal with them.\n-\n     default:\n         return \"OP_UNKNOWN\";\n     }"
      },
      {
        "sha": "a4f377dd9471eeed9b691b6df45d53b2be1ee338",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -181,13 +181,6 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n-\n-    // template matching params\n-    OP_SMALLINTEGER = 0xfa,\n-    OP_PUBKEYS = 0xfb,\n-    OP_PUBKEYHASH = 0xfd,\n-    OP_PUBKEY = 0xfe,\n-\n     OP_INVALIDOPCODE = 0xff,\n };\n "
      },
      {
        "sha": "6dbfbda029c81613254738e56274247e8ba64c89",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -14,9 +14,9 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-TransactionSignatureCreator::TransactionSignatureCreator(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n+MutableTransactionSignatureCreator::MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n-bool TransactionSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n+bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CKey key;\n     if (!provider.GetKey(address, key))\n@@ -199,22 +199,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data)\n     input.scriptWitness = data.scriptWitness;\n }\n \n-void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data)\n-{\n-    assert(tx.vin.size() > nIn);\n-    UpdateInput(tx.vin[nIn], data);\n-}\n-\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n \n-    CTransaction txToConst(txTo);\n-    TransactionSignatureCreator creator(&txToConst, nIn, amount, nHashType);\n+    MutableTransactionSignatureCreator creator(&txTo, nIn, amount, nHashType);\n \n     SignatureData sigdata;\n     bool ret = ProduceSignature(provider, creator, fromPubKey, sigdata);\n-    UpdateTransaction(txTo, nIn, sigdata);\n+    UpdateInput(txTo.vin.at(nIn), sigdata);\n     return ret;\n }\n "
      },
      {
        "sha": "8ef0306bfe0fb93c52b45e6da5e86bf8955a1439",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -37,26 +37,19 @@ class BaseSignatureCreator {\n };\n \n /** A signature creator for transactions. */\n-class TransactionSignatureCreator : public BaseSignatureCreator {\n-    const CTransaction* txTo;\n+class MutableTransactionSignatureCreator : public BaseSignatureCreator {\n+    const CMutableTransaction* txTo;\n     unsigned int nIn;\n     int nHashType;\n     CAmount amount;\n-    const TransactionSignatureChecker checker;\n+    const MutableTransactionSignatureChecker checker;\n \n public:\n-    TransactionSignatureCreator(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n+    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn = SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const override { return checker; }\n     bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n-class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n-    CTransaction tx;\n-\n-public:\n-    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(&tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n-};\n-\n /** A signature creator that just produces 72-byte empty signatures. */\n extern const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR;\n \n@@ -80,7 +73,6 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n \n /** Extract signature data from a transaction, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn);\n-void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data);\n void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we"
      },
      {
        "sha": "d9269d6147ad1b798126cccd5363b29bdd31e2e4",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 87,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -35,22 +35,54 @@ const char* GetTxnOutputType(txnouttype t)\n     return nullptr;\n }\n \n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n+static bool MatchPayToPubkey(const CScript& script, valtype& pubkey)\n {\n-    // Templates\n-    static std::multimap<txnouttype, CScript> mTemplates;\n-    if (mTemplates.empty())\n-    {\n-        // Standard tx, sender provides pubkey, receiver adds signature\n-        mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n+    if (script.size() == CPubKey::PUBLIC_KEY_SIZE + 2 && script[0] == CPubKey::PUBLIC_KEY_SIZE && script.back() == OP_CHECKSIG) {\n+        pubkey = valtype(script.begin() + 1, script.begin() + CPubKey::PUBLIC_KEY_SIZE + 1);\n+        return CPubKey::ValidSize(pubkey);\n+    }\n+    if (script.size() == CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 2 && script[0] == CPubKey::COMPRESSED_PUBLIC_KEY_SIZE && script.back() == OP_CHECKSIG) {\n+        pubkey = valtype(script.begin() + 1, script.begin() + CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1);\n+        return CPubKey::ValidSize(pubkey);\n+    }\n+    return false;\n+}\n \n-        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n+static bool MatchPayToPubkeyHash(const CScript& script, valtype& pubkeyhash)\n+{\n+    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160 && script[2] == 20 && script[23] == OP_EQUALVERIFY && script[24] == OP_CHECKSIG) {\n+        pubkeyhash = valtype(script.begin () + 3, script.begin() + 23);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Test for \"small positive integer\" script opcodes - OP_1 through OP_16. */\n+static constexpr bool IsSmallInteger(opcodetype opcode)\n+{\n+    return opcode >= OP_1 && opcode <= OP_16;\n+}\n \n-        // Sender provides N pubkeys, receivers provides M signatures\n-        mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+static bool MatchMultisig(const CScript& script, unsigned int& required, std::vector<valtype>& pubkeys)\n+{\n+    opcodetype opcode;\n+    valtype data;\n+    CScript::const_iterator it = script.begin();\n+    if (script.size() < 1 || script.back() != OP_CHECKMULTISIG) return false;\n+\n+    if (!script.GetOp(it, opcode, data) || !IsSmallInteger(opcode)) return false;\n+    required = CScript::DecodeOP_N(opcode);\n+    while (script.GetOp(it, opcode, data) && CPubKey::ValidSize(data)) {\n+        pubkeys.emplace_back(std::move(data));\n     }\n+    if (!IsSmallInteger(opcode)) return false;\n+    unsigned int keys = CScript::DecodeOP_N(opcode);\n+    if (pubkeys.size() != keys || keys < required) return false;\n+    return (it + 1 == script.end());\n+}\n \n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n+{\n     vSolutionsRet.clear();\n \n     // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n@@ -82,6 +114,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n             vSolutionsRet.push_back(std::move(witnessprogram));\n             return true;\n         }\n+        typeRet = TX_NONSTANDARD;\n         return false;\n     }\n \n@@ -95,84 +128,27 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n         return true;\n     }\n \n-    // Scan templates\n-    const CScript& script1 = scriptPubKey;\n-    for (const std::pair<txnouttype, CScript>& tplate : mTemplates)\n-    {\n-        const CScript& script2 = tplate.second;\n-        vSolutionsRet.clear();\n+    std::vector<unsigned char> data;\n+    if (MatchPayToPubkey(scriptPubKey, data)) {\n+        typeRet = TX_PUBKEY;\n+        vSolutionsRet.push_back(std::move(data));\n+        return true;\n+    }\n \n-        opcodetype opcode1, opcode2;\n-        std::vector<unsigned char> vch1, vch2;\n+    if (MatchPayToPubkeyHash(scriptPubKey, data)) {\n+        typeRet = TX_PUBKEYHASH;\n+        vSolutionsRet.push_back(std::move(data));\n+        return true;\n+    }\n \n-        // Compare\n-        CScript::const_iterator pc1 = script1.begin();\n-        CScript::const_iterator pc2 = script2.begin();\n-        while (true)\n-        {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n-                // Found a match\n-                typeRet = tplate.first;\n-                if (typeRet == TX_MULTISIG)\n-                {\n-                    // Additional checks for TX_MULTISIG:\n-                    unsigned char m = vSolutionsRet.front()[0];\n-                    unsigned char n = vSolutionsRet.back()[0];\n-                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n-                        return false;\n-                }\n-                return true;\n-            }\n-            if (!script1.GetOp(pc1, opcode1, vch1))\n-                break;\n-            if (!script2.GetOp(pc2, opcode2, vch2))\n-                break;\n-\n-            // Template matching opcodes:\n-            if (opcode2 == OP_PUBKEYS)\n-            {\n-                while (CPubKey::ValidSize(vch1))\n-                {\n-                    vSolutionsRet.push_back(vch1);\n-                    if (!script1.GetOp(pc1, opcode1, vch1))\n-                        break;\n-                }\n-                if (!script2.GetOp(pc2, opcode2, vch2))\n-                    break;\n-                // Normal situation is to fall through\n-                // to other if/else statements\n-            }\n-\n-            if (opcode2 == OP_PUBKEY)\n-            {\n-                if (!CPubKey::ValidSize(vch1))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_SMALLINTEGER)\n-            {   // Single-byte small integer pushed onto vSolutions\n-                if (opcode1 == OP_0 ||\n-                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n-                {\n-                    char n = (char)CScript::DecodeOP_N(opcode1);\n-                    vSolutionsRet.push_back(valtype(1, n));\n-                }\n-                else\n-                    break;\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n-                // Others must match exactly\n-                break;\n-            }\n-        }\n+    unsigned int required;\n+    std::vector<std::vector<unsigned char>> keys;\n+    if (MatchMultisig(scriptPubKey, required, keys)) {\n+        typeRet = TX_MULTISIG;\n+        vSolutionsRet.push_back({static_cast<unsigned char>(required)}); // safe as required is in range 1..16\n+        vSolutionsRet.insert(vSolutionsRet.end(), keys.begin(), keys.end());\n+        vSolutionsRet.push_back({static_cast<unsigned char>(keys.size())}); // safe as size is in range 1..16\n+        return true;\n     }\n \n     vSolutionsRet.clear();"
      },
      {
        "sha": "28a4e37e68d059eafce41d224dec63323b563071",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -75,7 +75,7 @@ struct LockData {\n     std::mutex dd_mutex;\n } static lockdata;\n \n-static thread_local std::unique_ptr<LockStack> lockstack;\n+static thread_local LockStack g_lockstack;\n \n static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)\n {\n@@ -105,21 +105,18 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n \n static void push_lock(void* c, const CLockLocation& locklocation)\n {\n-    if (!lockstack)\n-        lockstack.reset(new LockStack);\n-\n     std::lock_guard<std::mutex> lock(lockdata.dd_mutex);\n \n-    lockstack->push_back(std::make_pair(c, locklocation));\n+    g_lockstack.push_back(std::make_pair(c, locklocation));\n \n-    for (const std::pair<void*, CLockLocation> & i : (*lockstack)) {\n+    for (const std::pair<void*, CLockLocation>& i : g_lockstack) {\n         if (i.first == c)\n             break;\n \n         std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n         if (lockdata.lockorders.count(p1))\n             continue;\n-        lockdata.lockorders[p1] = (*lockstack);\n+        lockdata.lockorders[p1] = g_lockstack;\n \n         std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n         lockdata.invlockorders.insert(p2);\n@@ -130,7 +127,7 @@ static void push_lock(void* c, const CLockLocation& locklocation)\n \n static void pop_lock()\n {\n-    (*lockstack).pop_back();\n+    g_lockstack.pop_back();\n }\n \n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n@@ -146,14 +143,14 @@ void LeaveCritical()\n std::string LocksHeld()\n {\n     std::string result;\n-    for (const std::pair<void*, CLockLocation> & i : *lockstack)\n+    for (const std::pair<void*, CLockLocation>& i : g_lockstack)\n         result += i.second.ToString() + std::string(\"\\n\");\n     return result;\n }\n \n void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs)\n {\n-    for (const std::pair<void*, CLockLocation> & i : *lockstack)\n+    for (const std::pair<void*, CLockLocation>& i : g_lockstack)\n         if (i.first == cs)\n             return;\n     fprintf(stderr, \"Assertion failed: lock %s not held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld().c_str());\n@@ -162,7 +159,7 @@ void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine,\n \n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs)\n {\n-    for (const std::pair<void*, CLockLocation>& i : *lockstack) {\n+    for (const std::pair<void*, CLockLocation>& i : g_lockstack) {\n         if (i.first == cs) {\n             fprintf(stderr, \"Assertion failed: lock %s held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld().c_str());\n             abort();"
      },
      {
        "sha": "8644aea3719f80df422b0b185028000a985d3132",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -198,13 +198,6 @@ BOOST_AUTO_TEST_CASE( shifts ) { // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n \n BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n {\n-    BOOST_CHECK(!ZeroL);\n-    BOOST_CHECK(!(!OneL));\n-    for (unsigned int i = 0; i < 256; ++i)\n-        BOOST_CHECK(!(!(OneL<<i)));\n-    BOOST_CHECK(!(!R1L));\n-    BOOST_CHECK(!(!MaxL));\n-\n     BOOST_CHECK(~ZeroL == MaxL);\n \n     unsigned char TmpArray[32];"
      },
      {
        "sha": "7d8ae46fb80e861bb1ff67965090317dffd65ff7",
        "filename": "src/test/blockchain_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 53,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/blockchain_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/blockchain_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockchain_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,9 +1,9 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"stdlib.h\"\n+#include <stdlib.h>\n \n-#include \"rpc/blockchain.cpp\"\n-#include \"test/test_bitcoin.h\"\n+#include <rpc/blockchain.h>\n+#include <test/test_bitcoin.h>\n \n /* Equality between doubles is imprecise. Comparison should be done\n  * with a small threshold of tolerance, rather than exact equality.\n@@ -22,14 +22,6 @@ static CBlockIndex* CreateBlockIndexWithNbits(uint32_t nbits)\n     return block_index;\n }\n \n-static CChain CreateChainWithNbits(uint32_t nbits)\n-{\n-    CBlockIndex* block_index = CreateBlockIndexWithNbits(nbits);\n-    CChain chain;\n-    chain.SetTip(block_index);\n-    return chain;\n-}\n-\n static void RejectDifficultyMismatch(double difficulty, double expected_difficulty) {\n      BOOST_CHECK_MESSAGE(\n         DoubleEquals(difficulty, expected_difficulty, 0.00001),\n@@ -43,12 +35,7 @@ static void RejectDifficultyMismatch(double difficulty, double expected_difficul\n static void TestDifficulty(uint32_t nbits, double expected_difficulty)\n {\n     CBlockIndex* block_index = CreateBlockIndexWithNbits(nbits);\n-    /* Since we are passing in block index explicitly,\n-     * there is no need to set up anything within the chain itself.\n-     */\n-    CChain chain;\n-\n-    double difficulty = GetDifficulty(chain, block_index);\n+    double difficulty = GetDifficulty(block_index);\n     delete block_index;\n \n     RejectDifficultyMismatch(difficulty, expected_difficulty);\n@@ -84,43 +71,8 @@ BOOST_AUTO_TEST_CASE(get_difficulty_for_very_high_target)\n // Verify that difficulty is 1.0 for an empty chain.\n BOOST_AUTO_TEST_CASE(get_difficulty_for_null_tip)\n {\n-    CChain chain;\n-    double difficulty = GetDifficulty(chain, nullptr);\n+    double difficulty = GetDifficulty(nullptr);\n     RejectDifficultyMismatch(difficulty, 1.0);\n }\n \n-/* Verify that if difficulty is based upon the block index\n- * in the chain, if no block index is explicitly specified.\n- */\n-BOOST_AUTO_TEST_CASE(get_difficulty_for_null_block_index)\n-{\n-    CChain chain = CreateChainWithNbits(0x1df88f6f);\n-\n-    double difficulty = GetDifficulty(chain, nullptr);\n-    delete chain.Tip();\n-\n-    double expected_difficulty = 0.004023;\n-\n-    RejectDifficultyMismatch(difficulty, expected_difficulty);\n-}\n-\n-/* Verify that difficulty is based upon the explicitly specified\n- * block index rather than being taken from the provided chain,\n- * when both are present.\n- */\n-BOOST_AUTO_TEST_CASE(get_difficulty_for_block_index_overrides_tip)\n-{\n-    CChain chain = CreateChainWithNbits(0x1df88f6f);\n-    /* This block index's nbits should be used\n-     * instead of the chain's when calculating difficulty.\n-     */\n-    CBlockIndex* override_block_index = CreateBlockIndexWithNbits(0x12345678);\n-\n-    double difficulty = GetDifficulty(chain, override_block_index);\n-    delete chain.Tip();\n-    delete override_block_index;\n-\n-    RejectDifficultyMismatch(difficulty, 5913134931067755359633408.0);\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d701f3bc4e87b4f8bd50391ab44b43a81d81c133",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -546,4 +546,20 @@ BOOST_AUTO_TEST_CASE(countbits_tests)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(sha256d64)\n+{\n+    for (int i = 0; i <= 32; ++i) {\n+        unsigned char in[64 * 32];\n+        unsigned char out1[32 * 32], out2[32 * 32];\n+        for (int j = 0; j < 64 * i; ++j) {\n+            in[j] = InsecureRandBits(8);\n+        }\n+        for (int j = 0; j < i; ++j) {\n+            CHash256().Write(in + 64 * j, 64).Finalize(out1 + 32 * j);\n+        }\n+        SHA256D64(out2, in, i);\n+        BOOST_CHECK(memcmp(out1, out2, 32 * i) == 0);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2edc7c16d4730132b7ec4087502906c37a57ab39",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -114,7 +114,7 @@ static double normalize_hit_rate(double hits, double load)\n     return hits * std::max(load, 1.0);\n }\n \n-/** Check the hit rate on loads ranging from 0.1 to 2.0 */\n+/** Check the hit rate on loads ranging from 0.1 to 1.6 */\n BOOST_AUTO_TEST_CASE(cuckoocache_hit_rate_ok)\n {\n     /** Arbitrarily selected Hit Rate threshold that happens to work for this test"
      },
      {
        "sha": "bebbd6c46460c8447c531705d734036925813227",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "renamed",
        "additions": 55,
        "deletions": 23,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -42,7 +42,7 @@ static NodeId id = 0;\n \n void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n \n-BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n \n // Test eviction of an outbound peer whose chain never advances\n // Mock a node connection, and use mocktime to simulate a peer\n@@ -66,25 +66,40 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     dummyNode1.fSuccessfullyConnected = true;\n \n     // This test requires that we have a chain with non-zero work.\n-    LOCK(cs_main);\n-    BOOST_CHECK(chainActive.Tip() != nullptr);\n-    BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+    {\n+        LOCK(cs_main);\n+        BOOST_CHECK(chainActive.Tip() != nullptr);\n+        BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+    }\n \n     // Test starts here\n-    LOCK(dummyNode1.cs_sendProcessing);\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n-    LOCK(dummyNode1.cs_vSend);\n-    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n-    dummyNode1.vSendMsg.clear();\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    }\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        dummyNode1.vSendMsg.clear();\n+    }\n \n     int64_t nStartTime = GetTime();\n     // Wait 21 minutes\n     SetMockTime(nStartTime+21*60);\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n-    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    }\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    }\n     // Wait 3 more minutes\n     SetMockTime(nStartTime+24*60);\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in disconnect\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in disconnect\n+    }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n     SetMockTime(0);\n \n@@ -190,8 +205,10 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         LOCK(cs_main);\n         Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     }\n-    LOCK(dummyNode1.cs_sendProcessing);\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    }\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n@@ -205,15 +222,20 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         LOCK(cs_main);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n-    LOCK(dummyNode2.cs_sendProcessing);\n-    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    }\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     {\n         LOCK(cs_main);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n-    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    }\n     BOOST_CHECK(connman->IsBanned(addr2));\n \n     bool dummy;\n@@ -237,20 +259,28 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         LOCK(cs_main);\n         Misbehaving(dummyNode1.GetId(), 100);\n     }\n-    LOCK(dummyNode1.cs_sendProcessing);\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    }\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     {\n         LOCK(cs_main);\n         Misbehaving(dummyNode1.GetId(), 10);\n     }\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    }\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     {\n         LOCK(cs_main);\n         Misbehaving(dummyNode1.GetId(), 1);\n     }\n-    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode1, interruptDummy);\n+    }\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n \n@@ -277,8 +307,10 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         LOCK(cs_main);\n         Misbehaving(dummyNode.GetId(), 100);\n     }\n-    LOCK(dummyNode.cs_sendProcessing);\n-    peerLogic->SendMessages(&dummyNode, interruptDummy);\n+    {\n+        LOCK2(cs_main, dummyNode.cs_sendProcessing);\n+        peerLogic->SendMessages(&dummyNode, interruptDummy);\n+    }\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);",
        "previous_filename": "src/test/DoS_tests.cpp"
      },
      {
        "sha": "c065e2567698ab5b0f4c13d036ca7c66cf1e071f",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -27,11 +27,21 @@ static void ResetArgs(const std::string& strArg)\n     for (std::string& s : vecArg)\n         vecChar.push_back(s.c_str());\n \n-    gArgs.ParseParameters(vecChar.size(), vecChar.data());\n+    std::string error;\n+    gArgs.ParseParameters(vecChar.size(), vecChar.data(), error);\n+}\n+\n+static void SetupArgs(const std::vector<std::string>& args)\n+{\n+    gArgs.ClearArgs();\n+    for (const std::string& arg : args) {\n+        gArgs.AddArg(arg, \"\", false, OptionsCategory::OPTIONS);\n+    }\n }\n \n BOOST_AUTO_TEST_CASE(boolarg)\n {\n+    SetupArgs({\"-foo\"});\n     ResetArgs(\"-foo\");\n     BOOST_CHECK(gArgs.GetBoolArg(\"-foo\", false));\n     BOOST_CHECK(gArgs.GetBoolArg(\"-foo\", true));\n@@ -84,6 +94,7 @@ BOOST_AUTO_TEST_CASE(boolarg)\n \n BOOST_AUTO_TEST_CASE(stringarg)\n {\n+    SetupArgs({\"-foo\", \"-bar\"});\n     ResetArgs(\"\");\n     BOOST_CHECK_EQUAL(gArgs.GetArg(\"-foo\", \"\"), \"\");\n     BOOST_CHECK_EQUAL(gArgs.GetArg(\"-foo\", \"eleven\"), \"eleven\");\n@@ -108,6 +119,7 @@ BOOST_AUTO_TEST_CASE(stringarg)\n \n BOOST_AUTO_TEST_CASE(intarg)\n {\n+    SetupArgs({\"-foo\", \"-bar\"});\n     ResetArgs(\"\");\n     BOOST_CHECK_EQUAL(gArgs.GetArg(\"-foo\", 11), 11);\n     BOOST_CHECK_EQUAL(gArgs.GetArg(\"-foo\", 0), 0);\n@@ -127,6 +139,7 @@ BOOST_AUTO_TEST_CASE(intarg)\n \n BOOST_AUTO_TEST_CASE(doubledash)\n {\n+    SetupArgs({\"-foo\", \"-bar\"});\n     ResetArgs(\"--foo\");\n     BOOST_CHECK_EQUAL(gArgs.GetBoolArg(\"-foo\", false), true);\n \n@@ -137,6 +150,7 @@ BOOST_AUTO_TEST_CASE(doubledash)\n \n BOOST_AUTO_TEST_CASE(boolargno)\n {\n+    SetupArgs({\"-foo\", \"-bar\"});\n     ResetArgs(\"-nofoo\");\n     BOOST_CHECK(!gArgs.GetBoolArg(\"-foo\", true));\n     BOOST_CHECK(!gArgs.GetBoolArg(\"-foo\", false));"
      },
      {
        "sha": "0264d29455d80a700a18c046eb299207248cb6d4",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -571,4 +571,179 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     SetMockTime(0);\n }\n \n+inline CTransactionRef make_tx(std::vector<CAmount>&& output_values, std::vector<CTransactionRef>&& inputs=std::vector<CTransactionRef>(), std::vector<uint32_t>&& input_indices=std::vector<uint32_t>())\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = input_indices.size() > i ? input_indices[i] : 0;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(MempoolAncestryTests)\n+{\n+    size_t ancestors, descendants;\n+\n+    CTxMemPool pool;\n+    TestMemPoolEntryHelper entry;\n+\n+    /* Base transaction */\n+    //\n+    // [tx1]\n+    //\n+    CTransactionRef tx1 = make_tx(/* output_values */ {10 * COIN});\n+    pool.addUnchecked(tx1->GetHash(), entry.Fee(10000LL).FromTx(tx1));\n+\n+    // Ancestors / descendants should be 1 / 1 (itself / itself)\n+    pool.GetTransactionAncestry(tx1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 1ULL);\n+\n+    /* Child transaction */\n+    //\n+    // [tx1].0 <- [tx2]\n+    //\n+    CTransactionRef tx2 = make_tx(/* output_values */ {495 * CENT, 5 * COIN}, /* inputs */ {tx1});\n+    pool.addUnchecked(tx2->GetHash(), entry.Fee(10000LL).FromTx(tx2));\n+\n+    // Ancestors / descendants should be:\n+    // transaction  ancestors   descendants\n+    // ============ =========== ===========\n+    // tx1          1 (tx1)     2 (tx1,2)\n+    // tx2          2 (tx1,2)   2 (tx1,2)\n+    pool.GetTransactionAncestry(tx1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 2ULL);\n+    pool.GetTransactionAncestry(tx2->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 2ULL);\n+    BOOST_CHECK_EQUAL(descendants, 2ULL);\n+\n+    /* Grand-child 1 */\n+    //\n+    // [tx1].0 <- [tx2].0 <- [tx3]\n+    //\n+    CTransactionRef tx3 = make_tx(/* output_values */ {290 * CENT, 200 * CENT}, /* inputs */ {tx2});\n+    pool.addUnchecked(tx3->GetHash(), entry.Fee(10000LL).FromTx(tx3));\n+\n+    // Ancestors / descendants should be:\n+    // transaction  ancestors   descendants\n+    // ============ =========== ===========\n+    // tx1          1 (tx1)     3 (tx1,2,3)\n+    // tx2          2 (tx1,2)   3 (tx1,2,3)\n+    // tx3          3 (tx1,2,3) 3 (tx1,2,3)\n+    pool.GetTransactionAncestry(tx1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 3ULL);\n+    pool.GetTransactionAncestry(tx2->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 2ULL);\n+    BOOST_CHECK_EQUAL(descendants, 3ULL);\n+    pool.GetTransactionAncestry(tx3->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 3ULL);\n+\n+    /* Grand-child 2 */\n+    //\n+    // [tx1].0 <- [tx2].0 <- [tx3]\n+    //              |\n+    //              \\---1 <- [tx4]\n+    //\n+    CTransactionRef tx4 = make_tx(/* output_values */ {290 * CENT, 250 * CENT}, /* inputs */ {tx2}, /* input_indices */ {1});\n+    pool.addUnchecked(tx4->GetHash(), entry.Fee(10000LL).FromTx(tx4));\n+\n+    // Ancestors / descendants should be:\n+    // transaction  ancestors   descendants\n+    // ============ =========== ===========\n+    // tx1          1 (tx1)     4 (tx1,2,3,4)\n+    // tx2          2 (tx1,2)   4 (tx1,2,3,4)\n+    // tx3          3 (tx1,2,3) 4 (tx1,2,3,4)\n+    // tx4          3 (tx1,2,4) 4 (tx1,2,3,4)\n+    pool.GetTransactionAncestry(tx1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 4ULL);\n+    pool.GetTransactionAncestry(tx2->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 2ULL);\n+    BOOST_CHECK_EQUAL(descendants, 4ULL);\n+    pool.GetTransactionAncestry(tx3->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 4ULL);\n+    pool.GetTransactionAncestry(tx4->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 4ULL);\n+\n+    /* Make an alternate branch that is longer and connect it to tx3 */\n+    //\n+    // [ty1].0 <- [ty2].0 <- [ty3].0 <- [ty4].0 <- [ty5].0\n+    //                                              |\n+    // [tx1].0 <- [tx2].0 <- [tx3].0 <- [ty6] --->--/\n+    //              |\n+    //              \\---1 <- [tx4]\n+    //\n+    CTransactionRef ty1, ty2, ty3, ty4, ty5;\n+    CTransactionRef* ty[5] = {&ty1, &ty2, &ty3, &ty4, &ty5};\n+    CAmount v = 5 * COIN;\n+    for (uint64_t i = 0; i < 5; i++) {\n+        CTransactionRef& tyi = *ty[i];\n+        tyi = make_tx(/* output_values */ {v}, /* inputs */ i > 0 ? std::vector<CTransactionRef>{*ty[i - 1]} : std::vector<CTransactionRef>{});\n+        v -= 50 * CENT;\n+        pool.addUnchecked(tyi->GetHash(), entry.Fee(10000LL).FromTx(tyi));\n+        pool.GetTransactionAncestry(tyi->GetHash(), ancestors, descendants);\n+        BOOST_CHECK_EQUAL(ancestors, i+1);\n+        BOOST_CHECK_EQUAL(descendants, i+1);\n+    }\n+    CTransactionRef ty6 = make_tx(/* output_values */ {5 * COIN}, /* inputs */ {tx3, ty5});\n+    pool.addUnchecked(ty6->GetHash(), entry.Fee(10000LL).FromTx(ty6));\n+\n+    // Ancestors / descendants should be:\n+    // transaction  ancestors           descendants\n+    // ============ =================== ===========\n+    // tx1          1 (tx1)             5 (tx1,2,3,4, ty6)\n+    // tx2          2 (tx1,2)           5 (tx1,2,3,4, ty6)\n+    // tx3          3 (tx1,2,3)         5 (tx1,2,3,4, ty6)\n+    // tx4          3 (tx1,2,4)         5 (tx1,2,3,4, ty6)\n+    // ty1          1 (ty1)             6 (ty1,2,3,4,5,6)\n+    // ty2          2 (ty1,2)           6 (ty1,2,3,4,5,6)\n+    // ty3          3 (ty1,2,3)         6 (ty1,2,3,4,5,6)\n+    // ty4          4 (y1234)           6 (ty1,2,3,4,5,6)\n+    // ty5          5 (y12345)          6 (ty1,2,3,4,5,6)\n+    // ty6          9 (tx123, ty123456) 6 (ty1,2,3,4,5,6)\n+    pool.GetTransactionAncestry(tx1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 5ULL);\n+    pool.GetTransactionAncestry(tx2->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 2ULL);\n+    BOOST_CHECK_EQUAL(descendants, 5ULL);\n+    pool.GetTransactionAncestry(tx3->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 5ULL);\n+    pool.GetTransactionAncestry(tx4->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 5ULL);\n+    pool.GetTransactionAncestry(ty1->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 1ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+    pool.GetTransactionAncestry(ty2->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 2ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+    pool.GetTransactionAncestry(ty3->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 3ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+    pool.GetTransactionAncestry(ty4->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 4ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+    pool.GetTransactionAncestry(ty5->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 5ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+    pool.GetTransactionAncestry(ty6->GetHash(), ancestors, descendants);\n+    BOOST_CHECK_EQUAL(ancestors, 9ULL);\n+    BOOST_CHECK_EQUAL(descendants, 6ULL);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "259e45dacfcff6a7418c84567f9824b6523c2d4d",
        "filename": "src/test/merkle_tests.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 0,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -9,6 +9,123 @@\n \n BOOST_FIXTURE_TEST_SUITE(merkle_tests, TestingSetup)\n \n+static uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& vMerkleBranch, uint32_t nIndex) {\n+    uint256 hash = leaf;\n+    for (std::vector<uint256>::const_iterator it = vMerkleBranch.begin(); it != vMerkleBranch.end(); ++it) {\n+        if (nIndex & 1) {\n+            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));\n+        } else {\n+            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));\n+        }\n+        nIndex >>= 1;\n+    }\n+    return hash;\n+}\n+\n+/* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */\n+static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch) {\n+    if (pbranch) pbranch->clear();\n+    if (leaves.size() == 0) {\n+        if (pmutated) *pmutated = false;\n+        if (proot) *proot = uint256();\n+        return;\n+    }\n+    bool mutated = false;\n+    // count is the number of leaves processed so far.\n+    uint32_t count = 0;\n+    // inner is an array of eagerly computed subtree hashes, indexed by tree\n+    // level (0 being the leaves).\n+    // For example, when count is 25 (11001 in binary), inner[4] is the hash of\n+    // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to\n+    // the last leaf. The other inner entries are undefined.\n+    uint256 inner[32];\n+    // Which position in inner is a hash that depends on the matching leaf.\n+    int matchlevel = -1;\n+    // First process all leaves into 'inner' values.\n+    while (count < leaves.size()) {\n+        uint256 h = leaves[count];\n+        bool matchh = count == branchpos;\n+        count++;\n+        int level;\n+        // For each of the lower bits in count that are 0, do 1 step. Each\n+        // corresponds to an inner value that existed before processing the\n+        // current leaf, and each needs a hash to combine it.\n+        for (level = 0; !(count & (((uint32_t)1) << level)); level++) {\n+            if (pbranch) {\n+                if (matchh) {\n+                    pbranch->push_back(inner[level]);\n+                } else if (matchlevel == level) {\n+                    pbranch->push_back(h);\n+                    matchh = true;\n+                }\n+            }\n+            mutated |= (inner[level] == h);\n+            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+        }\n+        // Store the resulting hash at inner position level.\n+        inner[level] = h;\n+        if (matchh) {\n+            matchlevel = level;\n+        }\n+    }\n+    // Do a final 'sweep' over the rightmost branch of the tree to process\n+    // odd levels, and reduce everything to a single top value.\n+    // Level is the level (counted from the bottom) up to which we've sweeped.\n+    int level = 0;\n+    // As long as bit number level in count is zero, skip it. It means there\n+    // is nothing left at this level.\n+    while (!(count & (((uint32_t)1) << level))) {\n+        level++;\n+    }\n+    uint256 h = inner[level];\n+    bool matchh = matchlevel == level;\n+    while (count != (((uint32_t)1) << level)) {\n+        // If we reach this point, h is an inner value that is not the top.\n+        // We combine it with itself (Bitcoin's special rule for odd levels in\n+        // the tree) to produce a higher level one.\n+        if (pbranch && matchh) {\n+            pbranch->push_back(h);\n+        }\n+        CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+        // Increment count to the value it would have if two entries at this\n+        // level had existed.\n+        count += (((uint32_t)1) << level);\n+        level++;\n+        // And propagate the result upwards accordingly.\n+        while (!(count & (((uint32_t)1) << level))) {\n+            if (pbranch) {\n+                if (matchh) {\n+                    pbranch->push_back(inner[level]);\n+                } else if (matchlevel == level) {\n+                    pbranch->push_back(h);\n+                    matchh = true;\n+                }\n+            }\n+            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+            level++;\n+        }\n+    }\n+    // Return result.\n+    if (pmutated) *pmutated = mutated;\n+    if (proot) *proot = h;\n+}\n+\n+static std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n+    std::vector<uint256> ret;\n+    MerkleComputation(leaves, nullptr, nullptr, position, &ret);\n+    return ret;\n+}\n+\n+static std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n+{\n+    std::vector<uint256> leaves;\n+    leaves.resize(block.vtx.size());\n+    for (size_t s = 0; s < block.vtx.size(); s++) {\n+        leaves[s] = block.vtx[s]->GetHash();\n+    }\n+    return ComputeMerkleBranch(leaves, position);\n+}\n+\n // Older version of the merkle root computation code, for comparison.\n static uint256 BlockBuildMerkleTree(const CBlock& block, bool* fMutated, std::vector<uint256>& vMerkleTree)\n {"
      },
      {
        "sha": "803a673fabd3b88004212bcfd4267eadc2fe8b04",
        "filename": "src/test/script_p2sh_tests.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/script_p2sh_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/script_p2sh_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_p2sh_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -46,7 +46,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, Scri\n }\n \n \n-BOOST_FIXTURE_TEST_SUITE(script_P2SH_tests, BasicTestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(script_p2sh_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(sign)\n {",
        "previous_filename": "src/test/script_P2SH_tests.cpp"
      },
      {
        "sha": "7ab09782289b13b0f7d810b41db02779bee3fd79",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -726,6 +726,32 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK(!isInvalid);\n     }\n \n+    // witness unspendable\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_0 << ToByteVector(ParseHex(\"aabb\"));\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // witness unknown\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_16 << ToByteVector(ParseHex(\"aabb\"));\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n     // Nonstandard\n     {\n         CBasicKeyStore keystore;"
      },
      {
        "sha": "e1e77f7c92def60212cf84759d50ccfd9eb40029",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,11 +6,8 @@\n #include <support/allocators/zeroafterfree.h>\n #include <test/test_bitcoin.h>\n \n-#include <boost/assign/std/vector.hpp> // for 'operator+=()'\n #include <boost/test/unit_test.hpp>\n \n-using namespace boost::assign; // bring 'operator+=()' into scope\n-\n BOOST_FIXTURE_TEST_SUITE(streams_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(streams_vector_writer)\n@@ -80,22 +77,25 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n \n     // Degenerate case\n     \n-    key += '\\x00','\\x00';\n+    key.push_back('\\x00');\n+    key.push_back('\\x00');\n     ds.Xor(key);\n     BOOST_CHECK_EQUAL(\n             std::string(expected_xor.begin(), expected_xor.end()), \n             std::string(ds.begin(), ds.end()));\n \n-    in += '\\x0f','\\xf0';\n-    expected_xor += '\\xf0','\\x0f';\n+    in.push_back('\\x0f');\n+    in.push_back('\\xf0');\n+    expected_xor.push_back('\\xf0');\n+    expected_xor.push_back('\\x0f');\n     \n     // Single character key\n \n     ds.clear();\n     ds.insert(ds.begin(), in.begin(), in.end());\n     key.clear();\n \n-    key += '\\xff';\n+    key.push_back('\\xff');\n     ds.Xor(key);\n     BOOST_CHECK_EQUAL(\n             std::string(expected_xor.begin(), expected_xor.end()), \n@@ -105,14 +105,17 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n \n     in.clear();\n     expected_xor.clear();\n-    in += '\\xf0','\\x0f';\n-    expected_xor += '\\x0f','\\x00';\n+    in.push_back('\\xf0');\n+    in.push_back('\\x0f');\n+    expected_xor.push_back('\\x0f');\n+    expected_xor.push_back('\\x00');\n                         \n     ds.clear();\n     ds.insert(ds.begin(), in.begin(), in.end());\n \n     key.clear();\n-    key += '\\xff','\\x0f';\n+    key.push_back('\\xff');\n+    key.push_back('\\x0f');\n \n     ds.Xor(key);\n     BOOST_CHECK_EQUAL("
      },
      {
        "sha": "c7ceb2f1e9c076bd2d143c110b93120eda634931",
        "filename": "src/test/torcontrol_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/torcontrol_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/torcontrol_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/torcontrol_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,10 +3,18 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n #include <test/test_bitcoin.h>\n-#include <torcontrol.cpp>\n+#include <torcontrol.h>\n \n #include <boost/test/unit_test.hpp>\n \n+#include <map>\n+#include <string>\n+#include <utility>\n+\n+\n+std::pair<std::string, std::string> SplitTorReplyLine(const std::string& s);\n+std::map<std::string, std::string> ParseTorReplyMapping(const std::string& s);\n+\n \n BOOST_FIXTURE_TEST_SUITE(torcontrol_tests, BasicTestingSetup)\n "
      },
      {
        "sha": "65c5b8ea1d7ea4ad5a2eaf05f567a01155703520",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -629,7 +629,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n     CheckWithFlag(output2, input2, 0, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n     // P2SH 2-of-2 multisig\n@@ -640,7 +640,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -652,7 +652,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -664,7 +664,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n }"
      },
      {
        "sha": "be7ee2428b2725a80957f49375e93f05ba64bd4d",
        "filename": "src/test/txindex_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/txindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/txindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txindex_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,7 +15,7 @@ BOOST_AUTO_TEST_SUITE(txindex_tests)\n \n BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)\n {\n-    TxIndex txindex(MakeUnique<TxIndexDB>(1 << 20, true));\n+    TxIndex txindex(1 << 20, true);\n \n     CTransactionRef tx_disk;\n     uint256 block_hash;"
      },
      {
        "sha": "d32d4b267c0db73c187f9540742cd57aeb6c974a",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -102,7 +102,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n // should fail.\n // Capture this interaction with the upgraded_nop argument: set it when evaluating\n // any script flag that is implemented as an upgraded NOP code.\n-static void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache)\n+static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t failing_flags, bool add_to_cache)\n {\n     PrecomputedTransactionData txdata(tx);\n     // If we add many more flags, this loop can get too expensive, but we can\n@@ -315,7 +315,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // Sign\n         SignatureData sigdata;\n         ProduceSignature(keystore, MutableTransactionSignatureCreator(&valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n-        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n+        UpdateInput(valid_with_witness_tx.vin[0], sigdata);\n \n         // This should be valid under all script flags.\n         ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true);\n@@ -343,7 +343,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         for (int i=0; i<2; ++i) {\n             SignatureData sigdata;\n             ProduceSignature(keystore, MutableTransactionSignatureCreator(&tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n-            UpdateTransaction(tx, i, sigdata);\n+            UpdateInput(tx.vin[i], sigdata);\n         }\n \n         // This should be valid under all script flags"
      },
      {
        "sha": "611ccc9b77dff8ff9085ea24fa653b0a42f4eb0c",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 23,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -186,27 +186,37 @@ struct TestArgsManager : public ArgsManager\n             LOCK(cs_args);\n             m_config_args.clear();\n         }\n-        ReadConfigStream(streamConfig);\n+        std::string error;\n+        ReadConfigStream(streamConfig, error);\n     }\n     void SetNetworkOnlyArg(const std::string arg)\n     {\n         LOCK(cs_args);\n         m_network_only_args.insert(arg);\n     }\n+    void SetupArgs(int argv, const char* args[])\n+    {\n+        for (int i = 0; i < argv; ++i) {\n+            AddArg(args[i], \"\", false, OptionsCategory::OPTIONS);\n+        }\n+    }\n };\n \n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n {\n     TestArgsManager testArgs;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\"};\n     const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n \n-    testArgs.ParseParameters(0, (char**)argv_test);\n+    std::string error;\n+    testArgs.SetupArgs(4, avail_args);\n+    testArgs.ParseParameters(0, (char**)argv_test, error);\n     BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n \n-    testArgs.ParseParameters(1, (char**)argv_test);\n+    testArgs.ParseParameters(1, (char**)argv_test, error);\n     BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n \n-    testArgs.ParseParameters(7, (char**)argv_test);\n+    testArgs.ParseParameters(7, (char**)argv_test, error);\n     // expectation: -ignored is ignored (program name argument),\n     // -a, -b and -ccc end up in map, -d ignored because it is after\n     // a non-option argument (non-GNU option parsing)\n@@ -227,9 +237,12 @@ BOOST_AUTO_TEST_CASE(util_ParseParameters)\n BOOST_AUTO_TEST_CASE(util_GetBoolArg)\n {\n     TestArgsManager testArgs;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-c\", \"-d\", \"-e\", \"-f\"};\n     const char *argv_test[] = {\n         \"ignored\", \"-a\", \"-nob\", \"-c=0\", \"-d=1\", \"-e=false\", \"-f=true\"};\n-    testArgs.ParseParameters(7, (char**)argv_test);\n+    std::string error;\n+    testArgs.SetupArgs(6, avail_args);\n+    testArgs.ParseParameters(7, (char**)argv_test, error);\n \n     // Each letter should be set.\n     for (char opt : \"abcdef\")\n@@ -261,8 +274,11 @@ BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n     TestArgsManager testArgs;\n \n     // Params test\n+    const char* avail_args[] = {\"-foo\", \"-bar\"};\n     const char *argv_test[] = {\"ignored\", \"-nofoo\", \"-foo\", \"-nobar=0\"};\n-    testArgs.ParseParameters(4, (char**)argv_test);\n+    testArgs.SetupArgs(2, avail_args);\n+    std::string error;\n+    testArgs.ParseParameters(4, (char**)argv_test, error);\n \n     // This was passed twice, second one overrides the negative setting.\n     BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n@@ -274,7 +290,7 @@ BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n \n     // Config test\n     const char *conf_test = \"nofoo=1\\nfoo=1\\nnobar=0\\n\";\n-    testArgs.ParseParameters(1, (char**)argv_test);\n+    testArgs.ParseParameters(1, (char**)argv_test, error);\n     testArgs.ReadConfigString(conf_test);\n \n     // This was passed twice, second one overrides the negative setting,\n@@ -289,7 +305,7 @@ BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n     // Combined test\n     const char *combo_test_args[] = {\"ignored\", \"-nofoo\", \"-bar\"};\n     const char *combo_test_conf = \"foo=1\\nnobar=1\\n\";\n-    testArgs.ParseParameters(3, (char**)combo_test_args);\n+    testArgs.ParseParameters(3, (char**)combo_test_args, error);\n     testArgs.ReadConfigString(combo_test_conf);\n \n     // Command line overrides, but doesn't erase old setting\n@@ -329,6 +345,8 @@ BOOST_AUTO_TEST_CASE(util_ReadConfigStream)\n        \"iii=2\\n\";\n \n     TestArgsManager test_args;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\", \"-e\", \"-fff\", \"-ggg\", \"-h\", \"-i\", \"-iii\"};\n+    test_args.SetupArgs(10, avail_args);\n \n     test_args.ReadConfigString(str_config);\n     // expectation: a, b, ccc, d, fff, ggg, h, i end up in map\n@@ -526,6 +544,8 @@ BOOST_AUTO_TEST_CASE(util_GetArg)\n BOOST_AUTO_TEST_CASE(util_GetChainName)\n {\n     TestArgsManager test_args;\n+    const char* avail_args[] = {\"-testnet\", \"-regtest\"};\n+    test_args.SetupArgs(2, avail_args);\n \n     const char* argv_testnet[] = {\"cmd\", \"-testnet\"};\n     const char* argv_regtest[] = {\"cmd\", \"-regtest\"};\n@@ -535,63 +555,64 @@ BOOST_AUTO_TEST_CASE(util_GetChainName)\n     // equivalent to \"-testnet\"\n     // regtest in testnet section is ignored\n     const char* testnetconf = \"testnet=1\\nregtest=0\\n[test]\\nregtest=1\";\n+    std::string error;\n \n-    test_args.ParseParameters(0, (char**)argv_testnet);\n+    test_args.ParseParameters(0, (char**)argv_testnet, error);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"main\");\n \n-    test_args.ParseParameters(2, (char**)argv_testnet);\n+    test_args.ParseParameters(2, (char**)argv_testnet, error);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(2, (char**)argv_regtest);\n+    test_args.ParseParameters(2, (char**)argv_regtest, error);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"regtest\");\n \n-    test_args.ParseParameters(3, (char**)argv_test_no_reg);\n+    test_args.ParseParameters(3, (char**)argv_test_no_reg, error);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(3, (char**)argv_both);\n+    test_args.ParseParameters(3, (char**)argv_both, error);\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n \n-    test_args.ParseParameters(0, (char**)argv_testnet);\n+    test_args.ParseParameters(0, (char**)argv_testnet, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(2, (char**)argv_testnet);\n+    test_args.ParseParameters(2, (char**)argv_testnet, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(2, (char**)argv_regtest);\n+    test_args.ParseParameters(2, (char**)argv_regtest, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n \n-    test_args.ParseParameters(3, (char**)argv_test_no_reg);\n+    test_args.ParseParameters(3, (char**)argv_test_no_reg, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(3, (char**)argv_both);\n+    test_args.ParseParameters(3, (char**)argv_both, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n \n     // check setting the network to test (and thus making\n     // [test] regtest=1 potentially relevant) doesn't break things\n     test_args.SelectConfigNetwork(\"test\");\n \n-    test_args.ParseParameters(0, (char**)argv_testnet);\n+    test_args.ParseParameters(0, (char**)argv_testnet, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(2, (char**)argv_testnet);\n+    test_args.ParseParameters(2, (char**)argv_testnet, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(2, (char**)argv_regtest);\n+    test_args.ParseParameters(2, (char**)argv_regtest, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n \n-    test_args.ParseParameters(2, (char**)argv_test_no_reg);\n+    test_args.ParseParameters(2, (char**)argv_test_no_reg, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n \n-    test_args.ParseParameters(3, (char**)argv_both);\n+    test_args.ParseParameters(3, (char**)argv_both, error);\n     test_args.ReadConfigString(testnetconf);\n     BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n }"
      },
      {
        "sha": "1791bfd7f73f7a8e2f95f024b00d00524880f4c9",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -251,7 +251,7 @@ bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB&\n  * Grammar is implicitly defined in https://spec.torproject.org/control-spec by\n  * the server reply formats for PROTOCOLINFO (S3.21) and AUTHCHALLENGE (S3.24).\n  */\n-static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n {\n     size_t ptr=0;\n     std::string type;\n@@ -270,7 +270,7 @@ static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s\n  * the server reply formats for PROTOCOLINFO (S3.21), AUTHCHALLENGE (S3.24),\n  * and ADD_ONION (S3.27). See also sections 2.1 and 2.3.\n  */\n-static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n {\n     std::map<std::string,std::string> mapping;\n     size_t ptr=0;\n@@ -773,4 +773,3 @@ void StopTorControl()\n         gBase = nullptr;\n     }\n }\n-"
      },
      {
        "sha": "b1d5879c83329502d680399cbf4f2b4ae51633f5",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 183,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -21,8 +21,6 @@\n static const char DB_COIN = 'C';\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n-static const char DB_TXINDEX = 't';\n-static const char DB_TXINDEX_BLOCK = 'T';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n@@ -237,17 +235,6 @@ bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockF\n     return WriteBatch(batch, true);\n }\n \n-bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n-    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n-}\n-\n-bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n-    CDBBatch batch(*this);\n-    for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Write(std::make_pair(DB_TXINDEX, it->first), it->second);\n-    return WriteBatch(batch);\n-}\n-\n bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n     return Write(std::make_pair(DB_FLAG, name), fValue ? '1' : '0');\n }\n@@ -425,173 +412,3 @@ bool CCoinsViewDB::Upgrade() {\n     LogPrintf(\"[%s].\\n\", ShutdownRequested() ? \"CANCELLED\" : \"DONE\");\n     return !ShutdownRequested();\n }\n-\n-TxIndexDB::TxIndexDB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n-    CDBWrapper(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n-{}\n-\n-bool TxIndexDB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n-{\n-    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n-}\n-\n-bool TxIndexDB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos)\n-{\n-    CDBBatch batch(*this);\n-    for (const auto& tuple : v_pos) {\n-        batch.Write(std::make_pair(DB_TXINDEX, tuple.first), tuple.second);\n-    }\n-    return WriteBatch(batch);\n-}\n-\n-bool TxIndexDB::ReadBestBlock(CBlockLocator& locator) const\n-{\n-    bool success = Read(DB_BEST_BLOCK, locator);\n-    if (!success) {\n-        locator.SetNull();\n-    }\n-    return success;\n-}\n-\n-bool TxIndexDB::WriteBestBlock(const CBlockLocator& locator)\n-{\n-    return Write(DB_BEST_BLOCK, locator);\n-}\n-\n-/*\n- * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n- * range of keys updated. This is used internally by MigrateData.\n- */\n-static void WriteTxIndexMigrationBatches(TxIndexDB& newdb, CBlockTreeDB& olddb,\n-                                         CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n-                                         const std::pair<unsigned char, uint256>& begin_key,\n-                                         const std::pair<unsigned char, uint256>& end_key)\n-{\n-    // Sync new DB changes to disk before deleting from old DB.\n-    newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n-    olddb.WriteBatch(batch_olddb);\n-    olddb.CompactRange(begin_key, end_key);\n-\n-    batch_newdb.Clear();\n-    batch_olddb.Clear();\n-}\n-\n-bool TxIndexDB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n-{\n-    // The prior implementation of txindex was always in sync with block index\n-    // and presence was indicated with a boolean DB flag. If the flag is set,\n-    // this means the txindex from a previous version is valid and in sync with\n-    // the chain tip. The first step of the migration is to unset the flag and\n-    // write the chain hash to a separate key, DB_TXINDEX_BLOCK. After that, the\n-    // index entries are copied over in batches to the new database. Finally,\n-    // DB_TXINDEX_BLOCK is erased from the old database and the block hash is\n-    // written to the new database.\n-    //\n-    // Unsetting the boolean flag ensures that if the node is downgraded to a\n-    // previous version, it will not see a corrupted, partially migrated index\n-    // -- it will see that the txindex is disabled. When the node is upgraded\n-    // again, the migration will pick up where it left off and sync to the block\n-    // with hash DB_TXINDEX_BLOCK.\n-    bool f_legacy_flag = false;\n-    block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n-    if (f_legacy_flag) {\n-        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n-            return error(\"%s: cannot write block indicator\", __func__);\n-        }\n-        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n-            return error(\"%s: cannot write block index db flag\", __func__);\n-        }\n-    }\n-\n-    CBlockLocator locator;\n-    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n-        return true;\n-    }\n-\n-    int64_t count = 0;\n-    LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n-    uiInterface.ShowProgress(_(\"Upgrading txindex database\"), 0, true);\n-    int report_done = 0;\n-    const size_t batch_size = 1 << 24; // 16 MiB\n-\n-    CDBBatch batch_newdb(*this);\n-    CDBBatch batch_olddb(block_tree_db);\n-\n-    std::pair<unsigned char, uint256> key;\n-    std::pair<unsigned char, uint256> begin_key{DB_TXINDEX, uint256()};\n-    std::pair<unsigned char, uint256> prev_key = begin_key;\n-\n-    bool interrupted = false;\n-    std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n-    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n-        boost::this_thread::interruption_point();\n-        if (ShutdownRequested()) {\n-            interrupted = true;\n-            break;\n-        }\n-\n-        if (!cursor->GetKey(key)) {\n-            return error(\"%s: cannot get key from valid cursor\", __func__);\n-        }\n-        if (key.first != DB_TXINDEX) {\n-            break;\n-        }\n-\n-        // Log progress every 10%.\n-        if (++count % 256 == 0) {\n-            // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n-            // of the hash can be used to estimate the current progress.\n-            const uint256& txid = key.second;\n-            uint32_t high_nibble =\n-                (static_cast<uint32_t>(*(txid.begin() + 0)) << 8) +\n-                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\n-            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n-\n-            uiInterface.ShowProgress(_(\"Upgrading txindex database\"), percentage_done, true);\n-            if (report_done < percentage_done/10) {\n-                LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n-                report_done = percentage_done/10;\n-            }\n-        }\n-\n-        CDiskTxPos value;\n-        if (!cursor->GetValue(value)) {\n-            return error(\"%s: cannot parse txindex record\", __func__);\n-        }\n-        batch_newdb.Write(key, value);\n-        batch_olddb.Erase(key);\n-\n-        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n-            // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n-            // because LevelDB iterators are guaranteed to provide a consistent view of the\n-            // underlying data, like a lightweight snapshot.\n-            WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                         batch_newdb, batch_olddb,\n-                                         prev_key, key);\n-            prev_key = key;\n-        }\n-    }\n-\n-    // If these final DB batches complete the migration, write the best block\n-    // hash marker to the new database and delete from the old one. This signals\n-    // that the former is fully caught up to that point in the blockchain and\n-    // that all txindex entries have been removed from the latter.\n-    if (!interrupted) {\n-        batch_olddb.Erase(DB_TXINDEX_BLOCK);\n-        batch_newdb.Write(DB_BEST_BLOCK, locator);\n-    }\n-\n-    WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                 batch_newdb, batch_olddb,\n-                                 begin_key, key);\n-\n-    if (interrupted) {\n-        LogPrintf(\"[CANCELLED].\\n\");\n-        return false;\n-    }\n-\n-    uiInterface.ShowProgress(\"\", 100, false);\n-\n-    LogPrintf(\"[DONE].\\n\");\n-    return true;\n-}"
      },
      {
        "sha": "100adb428dac9f035bbc8116002757152fe73fdb",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 59,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -40,31 +40,6 @@ static const int64_t nMaxTxIndexCache = 1024;\n //! Max memory allocated to coin DB specific cache (MiB)\n static const int64_t nMaxCoinsDBCache = 8;\n \n-struct CDiskTxPos : public CDiskBlockPos\n-{\n-    unsigned int nTxOffset; // after header\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITEAS(CDiskBlockPos, *this);\n-        READWRITE(VARINT(nTxOffset));\n-    }\n-\n-    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n-    }\n-\n-    CDiskTxPos() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        CDiskBlockPos::SetNull();\n-        nTxOffset = 0;\n-    }\n-};\n-\n /** CCoinsView backed by the coin database (chainstate/) */\n class CCoinsViewDB final : public CCoinsView\n {\n@@ -118,43 +93,9 @@ class CBlockTreeDB : public CDBWrapper\n     bool ReadLastBlockFile(int &nFile);\n     bool WriteReindexing(bool fReindexing);\n     bool ReadReindexing(bool &fReindexing);\n-    bool ReadTxIndex(const uint256 &txid, CDiskTxPos &pos);\n-    bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &vect);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n-/**\n- * Access to the txindex database (indexes/txindex/)\n- *\n- * The database stores a block locator of the chain the database is synced to\n- * so that the TxIndex can efficiently determine the point it last stopped at.\n- * A locator is used instead of a simple hash of the chain tip because blocks\n- * and block index entries may not be flushed to disk until after this database\n- * is updated.\n- */\n-class TxIndexDB : public CDBWrapper\n-{\n-public:\n-    explicit TxIndexDB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n-\n-    /// Read the disk location of the transaction data with the given hash. Returns false if the\n-    /// transaction hash is not indexed.\n-    bool ReadTxPos(const uint256& txid, CDiskTxPos& pos) const;\n-\n-    /// Write a batch of transaction positions to the DB.\n-    bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n-\n-    /// Read block locator of the chain that the txindex is in sync with.\n-    bool ReadBestBlock(CBlockLocator& locator) const;\n-\n-    /// Write block locator of the chain that the txindex is in sync with.\n-    bool WriteBestBlock(const CBlockLocator& locator);\n-\n-    /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n-    /// been upgraded yet to the new database.\n-    bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n-};\n-\n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "8090172e3f2d9880952a2fbae78736936fe3946a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 8,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -69,12 +69,12 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n         setAllDescendants.insert(cit);\n         stageEntries.erase(cit);\n         const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (const txiter childEntry : setChildren) {\n+        for (txiter childEntry : setChildren) {\n             cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n             if (cacheIt != cachedDescendants.end()) {\n                 // We've already calculated this one, just add the entries for this set\n                 // but don't traverse again.\n-                for (const txiter cacheEntry : cacheIt->second) {\n+                for (txiter cacheEntry : cacheIt->second) {\n                     setAllDescendants.insert(cacheEntry);\n                 }\n             } else if (!setAllDescendants.count(childEntry)) {\n@@ -693,18 +693,18 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         // Check children against mapNextTx\n         CTxMemPool::setEntries setChildrenCheck;\n         auto iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n-        int64_t childSizes = 0;\n+        uint64_t child_sizes = 0;\n         for (; iter != mapNextTx.end() && iter->first->hash == it->GetTx().GetHash(); ++iter) {\n             txiter childit = mapTx.find(iter->second->GetHash());\n             assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions\n             if (setChildrenCheck.insert(childit).second) {\n-                childSizes += childit->GetTxSize();\n+                child_sizes += childit->GetTxSize();\n             }\n         }\n         assert(setChildrenCheck == GetMemPoolChildren(it));\n         // Also check to make sure size is greater than sum with immediate children.\n         // just a sanity check, not definitive that this calc is correct...\n-        assert(it->GetSizeWithDescendants() >= childSizes + it->GetTxSize());\n+        assert(it->GetSizeWithDescendants() >= child_sizes + it->GetTxSize());\n \n         if (fDependsWait)\n             waitingOnDependants.push_back(&(*it));\n@@ -1055,11 +1055,36 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n     }\n }\n \n-bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const {\n+uint64_t CTxMemPool::CalculateDescendantMaximum(txiter entry) const {\n+    // find parent with highest descendant count\n+    std::vector<txiter> candidates;\n+    setEntries counted;\n+    candidates.push_back(entry);\n+    uint64_t maximum = 0;\n+    while (candidates.size()) {\n+        txiter candidate = candidates.back();\n+        candidates.pop_back();\n+        if (!counted.insert(candidate).second) continue;\n+        const setEntries& parents = GetMemPoolParents(candidate);\n+        if (parents.size() == 0) {\n+            maximum = std::max(maximum, candidate->GetCountWithDescendants());\n+        } else {\n+            for (txiter i : parents) {\n+                candidates.push_back(i);\n+            }\n+        }\n+    }\n+    return maximum;\n+}\n+\n+void CTxMemPool::GetTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) const {\n     LOCK(cs);\n     auto it = mapTx.find(txid);\n-    return it == mapTx.end() || (it->GetCountWithAncestors() < chainLimit &&\n-       it->GetCountWithDescendants() < chainLimit);\n+    ancestors = descendants = 0;\n+    if (it != mapTx.end()) {\n+        ancestors = it->GetCountWithAncestors();\n+        descendants = CalculateDescendantMaximum(it);\n+    }\n }\n \n SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}"
      },
      {
        "sha": "ebfcf36e118b488cc8d9f7ba058984f53eb01d73",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -486,7 +486,7 @@ class CTxMemPool\n     mutable CCriticalSection cs;\n     indexed_transaction_set mapTx GUARDED_BY(cs);\n \n-    typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n+    using txiter = indexed_transaction_set::nth_index<0>::type::const_iterator;\n     std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx witness hashes/entries in mapTx, in random order\n \n     struct CompareIteratorByHash {\n@@ -498,6 +498,7 @@ class CTxMemPool\n \n     const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n \n@@ -619,8 +620,11 @@ class CTxMemPool\n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n     int Expire(int64_t time);\n \n-    /** Returns false if the transaction is in the mempool and not within the chain limit specified. */\n-    bool TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const;\n+    /**\n+     * Calculate the ancestor and descendant count for the given transaction.\n+     * The counts include the transaction itself.\n+     */\n+    void GetTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) const;\n \n     unsigned long size()\n     {"
      },
      {
        "sha": "3add369df0a63938f9b839681863a3c6e7c1cfdb",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_UI_INTERFACE_H\n #define BITCOIN_UI_INTERFACE_H\n \n+#include <memory>\n #include <stdint.h>\n #include <string>\n \n@@ -92,7 +93,7 @@ class CClientUIInterface\n     boost::signals2::signal<void ()> NotifyAlertChanged;\n \n     /** A wallet has been loaded. */\n-    boost::signals2::signal<void (CWallet* wallet)> LoadWallet;\n+    boost::signals2::signal<void (std::shared_ptr<CWallet> wallet)> LoadWallet;\n \n     /**\n      * Show progress e.g. for verifychain."
      },
      {
        "sha": "ab262b40632c27997e63f87b86527dc077944c13",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 133,
        "deletions": 47,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -412,7 +412,7 @@ void ArgsManager::SelectConfigNetwork(const std::string& network)\n     m_network = network;\n }\n \n-void ArgsManager::ParseParameters(int argc, const char* const argv[])\n+bool ArgsManager::ParseParameters(int argc, const char* const argv[], std::string& error)\n {\n     LOCK(cs_args);\n     m_override_args.clear();\n@@ -444,18 +444,43 @@ void ArgsManager::ParseParameters(int argc, const char* const argv[])\n         } else {\n             m_override_args[key].push_back(val);\n         }\n+\n+        // Check that the arg is known\n+        if (!(IsSwitchChar(key[0]) && key.size() == 1)) {\n+            if (!IsArgKnown(key, error)) {\n+                error = strprintf(\"Invalid parameter %s\", key.c_str());\n+                return false;\n+            }\n+        }\n     }\n \n     // we do not allow -includeconf from command line, so we clear it here\n     auto it = m_override_args.find(\"-includeconf\");\n     if (it != m_override_args.end()) {\n         if (it->second.size() > 0) {\n             for (const auto& ic : it->second) {\n-                fprintf(stderr, \"warning: -includeconf cannot be used from commandline; ignoring -includeconf=%s\\n\", ic.c_str());\n+                error += \"-includeconf cannot be used from commandline; -includeconf=\" + ic + \"\\n\";\n             }\n-            m_override_args.erase(it);\n+            return false;\n         }\n     }\n+    return true;\n+}\n+\n+bool ArgsManager::IsArgKnown(const std::string& key, std::string& error)\n+{\n+    size_t option_index = key.find('.');\n+    std::string arg_no_net;\n+    if (option_index == std::string::npos) {\n+        arg_no_net = key;\n+    } else {\n+        arg_no_net = std::string(\"-\") + key.substr(option_index + 1, std::string::npos);\n+    }\n+\n+    for (const auto& arg_map : m_available_args) {\n+        if (arg_map.second.count(arg_no_net)) return true;\n+    }\n+    return false;\n }\n \n std::vector<std::string> ArgsManager::GetArgs(const std::string& strArg) const\n@@ -549,48 +574,87 @@ void ArgsManager::ForceSetArg(const std::string& strArg, const std::string& strV\n \n void ArgsManager::AddArg(const std::string& name, const std::string& help, const bool debug_only, const OptionsCategory& cat)\n {\n-    std::pair<OptionsCategory, std::string> key(cat, name);\n-    assert(m_available_args.count(key) == 0);\n-    m_available_args.emplace(key, std::pair<std::string, bool>(help, debug_only));\n+    // Split arg name from its help param\n+    size_t eq_index = name.find('=');\n+    if (eq_index == std::string::npos) {\n+        eq_index = name.size();\n+    }\n+\n+    std::map<std::string, Arg>& arg_map = m_available_args[cat];\n+    auto ret = arg_map.emplace(name.substr(0, eq_index), Arg(name.substr(eq_index, name.size() - eq_index), help, debug_only));\n+    assert(ret.second); // Make sure an insertion actually happened\n+}\n+\n+void ArgsManager::AddHiddenArgs(const std::vector<std::string>& names)\n+{\n+    for (const std::string& name : names) {\n+        AddArg(name, \"\", false, OptionsCategory::HIDDEN);\n+    }\n }\n \n std::string ArgsManager::GetHelpMessage()\n {\n     const bool show_debug = gArgs.GetBoolArg(\"-help-debug\", false);\n \n-    std::string usage = HelpMessageGroup(_(\"Options:\"));\n-\n-    OptionsCategory last_cat = OptionsCategory::OPTIONS;\n-    for (auto& arg : m_available_args) {\n-        if (arg.first.first != last_cat) {\n-            last_cat = arg.first.first;\n-            if (last_cat == OptionsCategory::CONNECTION)\n-                usage += HelpMessageGroup(_(\"Connection options:\"));\n-            else if (last_cat == OptionsCategory::ZMQ)\n-                usage += HelpMessageGroup(_(\"ZeroMQ notification options:\"));\n-            else if (last_cat == OptionsCategory::DEBUG_TEST)\n-                usage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n-            else if (last_cat == OptionsCategory::NODE_RELAY)\n-                usage += HelpMessageGroup(_(\"Node relay options:\"));\n-            else if (last_cat == OptionsCategory::BLOCK_CREATION)\n-                usage += HelpMessageGroup(_(\"Block creation options:\"));\n-            else if (last_cat == OptionsCategory::RPC)\n-                usage += HelpMessageGroup(_(\"RPC server options:\"));\n-            else if (last_cat == OptionsCategory::WALLET)\n-                usage += HelpMessageGroup(_(\"Wallet options:\"));\n-            else if (last_cat == OptionsCategory::WALLET_DEBUG_TEST && show_debug)\n-                usage += HelpMessageGroup(_(\"Wallet debugging/testing options:\"));\n-            else if (last_cat == OptionsCategory::CHAINPARAMS)\n-                usage += HelpMessageGroup(_(\"Chain selection options:\"));\n-            else if (last_cat == OptionsCategory::GUI)\n-                usage += HelpMessageGroup(_(\"UI Options:\"));\n-            else if (last_cat == OptionsCategory::COMMANDS)\n-                usage += HelpMessageGroup(_(\"Commands:\"));\n-            else if (last_cat == OptionsCategory::REGISTER_COMMANDS)\n-                usage += HelpMessageGroup(_(\"Register Commands:\"));\n+    std::string usage = \"\";\n+    for (const auto& arg_map : m_available_args) {\n+        switch(arg_map.first) {\n+            case OptionsCategory::OPTIONS:\n+                usage += HelpMessageGroup(\"Options:\");\n+                break;\n+            case OptionsCategory::CONNECTION:\n+                usage += HelpMessageGroup(\"Connection options:\");\n+                break;\n+            case OptionsCategory::ZMQ:\n+                usage += HelpMessageGroup(\"ZeroMQ notification options:\");\n+                break;\n+            case OptionsCategory::DEBUG_TEST:\n+                usage += HelpMessageGroup(\"Debugging/Testing options:\");\n+                break;\n+            case OptionsCategory::NODE_RELAY:\n+                usage += HelpMessageGroup(\"Node relay options:\");\n+                break;\n+            case OptionsCategory::BLOCK_CREATION:\n+                usage += HelpMessageGroup(\"Block creation options:\");\n+                break;\n+            case OptionsCategory::RPC:\n+                usage += HelpMessageGroup(\"RPC server options:\");\n+                break;\n+            case OptionsCategory::WALLET:\n+                usage += HelpMessageGroup(\"Wallet options:\");\n+                break;\n+            case OptionsCategory::WALLET_DEBUG_TEST:\n+                if (show_debug) usage += HelpMessageGroup(\"Wallet debugging/testing options:\");\n+                break;\n+            case OptionsCategory::CHAINPARAMS:\n+                usage += HelpMessageGroup(\"Chain selection options:\");\n+                break;\n+            case OptionsCategory::GUI:\n+                usage += HelpMessageGroup(\"UI Options:\");\n+                break;\n+            case OptionsCategory::COMMANDS:\n+                usage += HelpMessageGroup(\"Commands:\");\n+                break;\n+            case OptionsCategory::REGISTER_COMMANDS:\n+                usage += HelpMessageGroup(\"Register Commands:\");\n+                break;\n+            default:\n+                break;\n         }\n-        if (show_debug || !arg.second.second) {\n-            usage += HelpMessageOpt(arg.first.second, arg.second.first);\n+\n+        // When we get to the hidden options, stop\n+        if (arg_map.first == OptionsCategory::HIDDEN) break;\n+\n+        for (const auto& arg : arg_map.second) {\n+            if (show_debug || !arg.second.m_debug_only) {\n+                std::string name;\n+                if (arg.second.m_help_param.empty()) {\n+                    name = arg.first;\n+                } else {\n+                    name = arg.first + arg.second.m_help_param;\n+                }\n+                usage += HelpMessageOpt(name, arg.second.m_help_text);\n+            }\n         }\n     }\n     return usage;\n@@ -747,7 +811,7 @@ fs::path GetConfigFile(const std::string& confPath)\n     return AbsPathForConfigVal(fs::path(confPath), false);\n }\n \n-void ArgsManager::ReadConfigStream(std::istream& stream)\n+bool ArgsManager::ReadConfigStream(std::istream& stream, std::string& error, bool ignore_invalid_keys)\n {\n     LOCK(cs_args);\n \n@@ -758,15 +822,23 @@ void ArgsManager::ReadConfigStream(std::istream& stream)\n     {\n         std::string strKey = std::string(\"-\") + it->string_key;\n         std::string strValue = it->value[0];\n+\n         if (InterpretNegatedOption(strKey, strValue)) {\n             m_config_args[strKey].clear();\n         } else {\n             m_config_args[strKey].push_back(strValue);\n         }\n+\n+        // Check that the arg is known\n+        if (!IsArgKnown(strKey, error) && !ignore_invalid_keys) {\n+            error = strprintf(\"Invalid configuration value %s\", it->string_key.c_str());\n+            return false;\n+        }\n     }\n+    return true;\n }\n \n-void ArgsManager::ReadConfigFiles()\n+bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)\n {\n     {\n         LOCK(cs_args);\n@@ -778,15 +850,18 @@ void ArgsManager::ReadConfigFiles()\n \n     // ok to not have a config file\n     if (stream.good()) {\n-        ReadConfigStream(stream);\n+        if (!ReadConfigStream(stream, error, ignore_invalid_keys)) {\n+            return false;\n+        }\n         // if there is an -includeconf in the override args, but it is empty, that means the user\n         // passed '-noincludeconf' on the command line, in which case we should not include anything\n         if (m_override_args.count(\"-includeconf\") == 0) {\n+            std::string chain_id = GetChainName();\n             std::vector<std::string> includeconf(GetArgs(\"-includeconf\"));\n             {\n                 // We haven't set m_network yet (that happens in SelectParams()), so manually check\n                 // for network.includeconf args.\n-                std::vector<std::string> includeconf_net(GetArgs(std::string(\"-\") + GetChainName() + \".includeconf\"));\n+                std::vector<std::string> includeconf_net(GetArgs(std::string(\"-\") + chain_id + \".includeconf\"));\n                 includeconf.insert(includeconf.end(), includeconf_net.begin(), includeconf_net.end());\n             }\n \n@@ -795,24 +870,33 @@ void ArgsManager::ReadConfigFiles()\n             {\n                 LOCK(cs_args);\n                 m_config_args.erase(\"-includeconf\");\n-                m_config_args.erase(std::string(\"-\") + GetChainName() + \".includeconf\");\n+                m_config_args.erase(std::string(\"-\") + chain_id + \".includeconf\");\n             }\n \n             for (const std::string& to_include : includeconf) {\n                 fs::ifstream include_config(GetConfigFile(to_include));\n                 if (include_config.good()) {\n-                    ReadConfigStream(include_config);\n+                    if (!ReadConfigStream(include_config, error, ignore_invalid_keys)) {\n+                        return false;\n+                    }\n                     LogPrintf(\"Included configuration file %s\\n\", to_include.c_str());\n                 } else {\n-                    fprintf(stderr, \"Failed to include configuration file %s\\n\", to_include.c_str());\n+                    error = \"Failed to include configuration file \" + to_include;\n+                    return false;\n                 }\n             }\n \n             // Warn about recursive -includeconf\n             includeconf = GetArgs(\"-includeconf\");\n             {\n-                std::vector<std::string> includeconf_net(GetArgs(std::string(\"-\") + GetChainName() + \".includeconf\"));\n+                std::vector<std::string> includeconf_net(GetArgs(std::string(\"-\") + chain_id + \".includeconf\"));\n                 includeconf.insert(includeconf.end(), includeconf_net.begin(), includeconf_net.end());\n+                std::string chain_id_final = GetChainName();\n+                if (chain_id_final != chain_id) {\n+                    // Also warn about recursive includeconf for the chain that was specified in one of the includeconfs\n+                    includeconf_net = GetArgs(std::string(\"-\") + chain_id_final + \".includeconf\");\n+                    includeconf.insert(includeconf.end(), includeconf_net.begin(), includeconf_net.end());\n+                }\n             }\n             for (const std::string& to_include : includeconf) {\n                 fprintf(stderr, \"warning: -includeconf cannot be used from included files; ignoring -includeconf=%s\\n\", to_include.c_str());\n@@ -823,8 +907,10 @@ void ArgsManager::ReadConfigFiles()\n     // If datadir is changed in .conf file:\n     ClearDatadirCache();\n     if (!fs::is_directory(GetDataDir(false))) {\n-        throw std::runtime_error(strprintf(\"specified data directory \\\"%s\\\" does not exist.\", gArgs.GetArg(\"-datadir\", \"\").c_str()));\n+        error = strprintf(\"specified data directory \\\"%s\\\" does not exist.\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n+        return false;\n     }\n+    return true;\n }\n \n std::string ArgsManager::GetChainName() const"
      },
      {
        "sha": "8094d72d6b92b73dab7e57c7353e21264ab9d203",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 33,
        "deletions": 8,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -118,8 +118,7 @@ inline bool IsSwitchChar(char c)\n #endif\n }\n \n-enum class OptionsCategory\n-{\n+enum class OptionsCategory {\n     OPTIONS,\n     CONNECTION,\n     WALLET,\n@@ -132,22 +131,33 @@ enum class OptionsCategory\n     RPC,\n     GUI,\n     COMMANDS,\n-    REGISTER_COMMANDS\n+    REGISTER_COMMANDS,\n+\n+    HIDDEN // Always the last option to avoid printing these in the help\n };\n \n class ArgsManager\n {\n protected:\n     friend class ArgsManagerHelper;\n \n+    struct Arg\n+    {\n+        std::string m_help_param;\n+        std::string m_help_text;\n+        bool m_debug_only;\n+\n+        Arg(const std::string& help_param, const std::string& help_text, bool debug_only) : m_help_param(help_param), m_help_text(help_text), m_debug_only(debug_only) {};\n+    };\n+\n     mutable CCriticalSection cs_args;\n     std::map<std::string, std::vector<std::string>> m_override_args;\n     std::map<std::string, std::vector<std::string>> m_config_args;\n     std::string m_network;\n     std::set<std::string> m_network_only_args;\n-    std::map<std::pair<OptionsCategory, std::string>, std::pair<std::string, bool>> m_available_args;\n+    std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args;\n \n-    void ReadConfigStream(std::istream& stream);\n+    bool ReadConfigStream(std::istream& stream, std::string& error, bool ignore_invalid_keys = false);\n \n public:\n     ArgsManager();\n@@ -157,8 +167,8 @@ class ArgsManager\n      */\n     void SelectConfigNetwork(const std::string& network);\n \n-    void ParseParameters(int argc, const char*const argv[]);\n-    void ReadConfigFiles();\n+    bool ParseParameters(int argc, const char* const argv[], std::string& error);\n+    bool ReadConfigFiles(std::string& error, bool ignore_invalid_keys = false);\n \n     /**\n      * Log warnings for options in m_section_only_args when\n@@ -253,10 +263,25 @@ class ArgsManager\n      */\n     void AddArg(const std::string& name, const std::string& help, const bool debug_only, const OptionsCategory& cat);\n \n+    /**\n+     * Add many hidden arguments\n+     */\n+    void AddHiddenArgs(const std::vector<std::string>& args);\n+\n+    /**\n+     * Clear available arguments\n+     */\n+    void ClearArgs() { m_available_args.clear(); }\n+\n     /**\n      * Get the help string\n      */\n     std::string GetHelpMessage();\n+\n+    /**\n+     * Check whether we know of this arg\n+     */\n+    bool IsArgKnown(const std::string& key, std::string& error);\n };\n \n extern ArgsManager gArgs;\n@@ -333,7 +358,7 @@ std::unique_ptr<T> MakeUnique(Args&&... args)\n  * CPU-intensive and non-interactive. See SCHED_BATCH in sched(7) for details.\n  *\n  * @return The return value of sched_setschedule(), or 1 on systems without\n- * sched_setchedule().\n+ * sched_setschedule().\n  */\n int ScheduleBatchPriority(void);\n "
      },
      {
        "sha": "3b8118b0363fc0ac91bfa97769eac1b369c89cd6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 22,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -205,7 +205,7 @@ class CChainState {\n \n     void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state);\n     CBlockIndex* FindMostWorkChain();\n-    bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n+    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n \n \n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params);\n@@ -577,15 +577,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n     if (tx.IsCoinBase())\n         return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n \n-    // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n-    bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n-    if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n-    }\n-\n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n-    if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n+    if (fRequireStandard && !IsStandardTx(tx, reason))\n         return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n \n     // Do not work on transactions that are too small.\n@@ -657,7 +651,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         view.SetBackend(viewMemPool);\n \n         // do all inputs exist?\n-        for (const CTxIn txin : tx.vin) {\n+        for (const CTxIn& txin : tx.vin) {\n             if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n                 coins_to_uncache.push_back(txin.prevout);\n             }\n@@ -963,7 +957,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         // Remove conflicting transactions from the mempool\n-        for (const CTxMemPool::txiter it : allConflicting)\n+        for (CTxMemPool::txiter it : allConflicting)\n         {\n             LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n                     it->GetTx().GetHash().ToString(),\n@@ -2704,6 +2698,9 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n             // Block until the validation queue drains. This should largely\n             // never happen in normal operation, however may happen during\n             // reindex, causing memory blowup if we run too far ahead.\n+            // Note that if a validationinterface callback ends up calling\n+            // ActivateBestChain this may lead to a deadlock! We should\n+            // probably have a DEBUG_LOCKORDER test for this in the future.\n             SyncWithValidationInterfaceQueue();\n         }\n \n@@ -2956,7 +2953,7 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n }\n \n /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */\n-bool CChainState::ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams)\n+void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams)\n {\n     pindexNew->nTx = block.vtx.size();\n     pindexNew->nChainTx = 0;\n@@ -3000,8 +2997,6 @@ bool CChainState::ReceivedBlockTransactions(const CBlock &block, CValidationStat\n             mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n         }\n     }\n-\n-    return true;\n }\n \n static bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n@@ -3513,7 +3508,6 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n         // request; don't process these.\n         if (pindex->nChainWork < nMinimumChainWork) return true;\n     }\n-    if (fNewBlock) *fNewBlock = true;\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n@@ -3530,14 +3524,14 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n         GetMainSignals().NewPoWValidBlock(pindex, pblock);\n \n     // Write block to history file\n+    if (fNewBlock) *fNewBlock = true;\n     try {\n         CDiskBlockPos blockPos = SaveBlockToDisk(block, pindex->nHeight, chainparams, dbp);\n         if (blockPos.IsNull()) {\n             state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n             return false;\n         }\n-        if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n-            return error(\"AcceptBlock(): ReceivedBlockTransactions failed\");\n+        ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n     } catch (const std::runtime_error& e) {\n         return AbortNode(state, std::string(\"System error: \") + e.what());\n     }\n@@ -3840,7 +3834,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n-    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n@@ -3907,7 +3901,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n@@ -4006,7 +4000,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n             reportDone = percentageDone/10;\n         }\n         uiInterface.ShowProgress(_(\"Verifying blocks...\"), percentageDone, false);\n-        if (pindex->nHeight < chainActive.Height()-nCheckDepth)\n+        if (pindex->nHeight <= chainActive.Height()-nCheckDepth)\n             break;\n         if (fPruneMode && !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n             // If pruning, only go back as far as we have data.\n@@ -4346,9 +4340,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n         CBlockIndex *pindex = AddToBlockIndex(block);\n-        CValidationState state;\n-        if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n-            return error(\"%s: genesis block not accepted (%s)\", __func__, FormatStateMessage(state));\n+        ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n     } catch (const std::runtime_error& e) {\n         return error(\"%s: failed to write genesis block: %s\", __func__, e.what());\n     }"
      },
      {
        "sha": "b9c2f6c0239701c4f1418165787ef3e93f3e7957",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 21,
        "deletions": 4,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -233,7 +233,8 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * Note that we guarantee that either the proof-of-work is valid on pblock, or\n  * (and possibly also) BlockChecked will have been called.\n  * \n- * Call without cs_main held.\n+ * May not be called with cs_main held. May not be called in a\n+ * validationinterface callback.\n  *\n  * @param[in]   pblock  The block we want to process.\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n@@ -245,7 +246,8 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n /**\n  * Process incoming block headers.\n  *\n- * Call without cs_main held.\n+ * May not be called with cs_main held. May not be called in a\n+ * validationinterface callback.\n  *\n  * @param[in]  block The block headers themselves\n  * @param[out] state This may be set to an Error state if any error occurred processing them\n@@ -278,7 +280,12 @@ void ThreadScriptCheck();\n bool IsInitialBlockDownload();\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256& hash, CTransactionRef& tx, const Consensus::Params& params, uint256& hashBlock, bool fAllowSlow = false, CBlockIndex* blockIndex = nullptr);\n-/** Find the best known block, and make it the tip of the block chain */\n+/**\n+ * Find the best known block, and make it the tip of the block chain\n+ *\n+ * May not be called with cs_main held. May not be called in a\n+ * validationinterface callback.\n+ */\n bool ActivateBestChain(CValidationState& state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock = std::shared_ptr<const CBlock>());\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n \n@@ -445,7 +452,11 @@ inline CBlockIndex* LookupBlockIndex(const uint256& hash)\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n \n-/** Mark a block as precious and reorganize. */\n+/** Mark a block as precious and reorganize.\n+ *\n+ * May not be called with cs_main held. May not be called in a\n+ * validationinterface callback.\n+ */\n bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex);\n \n /** Mark a block as invalid. */\n@@ -497,4 +508,10 @@ bool DumpMempool();\n /** Load the mempool from disk. */\n bool LoadMempool();\n \n+//! Check whether the block associated with this index entry is pruned or not.\n+inline bool IsBlockPruned(const CBlockIndex* pblockindex)\n+{\n+    return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);\n+}\n+\n #endif // BITCOIN_VALIDATION_H"
      },
      {
        "sha": "98b4298507f1f49cfc9e964e619e0c2054da0920",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -22,7 +22,7 @@ class CCoinControl\n     boost::optional<OutputType> m_change_type;\n     //! If false, allows unselected inputs, but requires all selected inputs be used\n     bool fAllowOtherInputs;\n-    //! Includes watch only addresses which match the ISMINE_WATCH_SOLVABLE criteria\n+    //! Includes watch only addresses which are solvable\n     bool fAllowWatchOnly;\n     //! Override automatic min/max checks on fee, m_feerate must be set if true\n     bool fOverrideFeeRate;"
      },
      {
        "sha": "01b8eacccb80fb22b9f61a215e99b857489daa58",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -694,8 +694,10 @@ void BerkeleyEnvironment::Flush(bool fShutdown)\n             if (mapFileUseCount.empty()) {\n                 dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n                 Close();\n-                if (!fMockDb)\n+                if (!fMockDb) {\n                     fs::remove_all(fs::path(strPath) / \"database\");\n+                }\n+                g_dbenvs.erase(strPath);\n             }\n         }\n     }\n@@ -794,5 +796,6 @@ void BerkeleyDatabase::Flush(bool shutdown)\n {\n     if (!IsDummy()) {\n         env->Flush(shutdown);\n+        if (shutdown) env = nullptr;\n     }\n }"
      },
      {
        "sha": "74312b7124e82e5154bec1df01dc5a112a443fc9",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 27,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -54,34 +54,34 @@ void WalletInit::AddWalletOptions() const\n {\n     gArgs.AddArg(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)), false, OptionsCategory::WALLET);\n     gArgs.AddArg(\"-changetype\", \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)\", false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-discardfee=<amt>\", strprintf(_(\"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n-                                                                \"Note: An output is discarded if it is dust at this rate, but we will always discard up to the dust relay fee and a discard fee above that is limited by the fee estimate for the longest target\"),\n+    gArgs.AddArg(\"-disablewallet\", \"Do not load the wallet and disable wallet RPC calls\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-discardfee=<amt>\", strprintf(\"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n+                                                                \"Note: An output is discarded if it is dust at this rate, but we will always discard up to the dust relay fee and a discard fee above that is limited by the fee estimate for the longest target\",\n                                                               CURRENCY_UNIT, FormatMoney(DEFAULT_DISCARD_FEE)), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-fallbackfee=<amt>\", strprintf(_(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\"),\n+    gArgs.AddArg(\"-fallbackfee=<amt>\", strprintf(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\",\n                                                                CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-mintxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)\"),\n+    gArgs.AddArg(\"-keypool=<n>\", strprintf(\"Set key pool size to <n> (default: %u)\", DEFAULT_KEYPOOL_SIZE), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-mintxfee=<amt>\", strprintf(\"Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)\",\n                                                             CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MINFEE)), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in %s/kB) to add to transactions you send (default: %s)\"),\n+    gArgs.AddArg(\"-paytxfee=<amt>\", strprintf(\"Fee (in %s/kB) to add to transactions you send (default: %s)\",\n                                                             CURRENCY_UNIT, FormatMoney(CFeeRate{DEFAULT_PAY_TX_FEE}.GetFeePerK())), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions on startup\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet on startup\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), DEFAULT_SPEND_ZEROCONF_CHANGE), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-upgradewallet\", _(\"Upgrade wallet to latest format on startup\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-wallet=<path>\", _(\"Specify wallet database path. Can be specified multiple times to load multiple wallets. Path is interpreted relative to <walletdir> if it is not absolute, and will be created if it does not exist (as a directory containing a wallet.dat file and log files). For backwards compatibility this will also accept names of existing data files in <walletdir>.)\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_WALLETBROADCAST), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-walletdir=<dir>\", _(\"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-walletrbf\", strprintf(_(\"Send transactions with full-RBF opt-in enabled (RPC only, default: %u)\"), DEFAULT_WALLET_RBF), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n-                               \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-rescan\", \"Rescan the block chain for missing wallet transactions on startup\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-salvagewallet\", \"Attempt to recover private keys from a corrupt wallet on startup\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-spendzeroconfchange\", strprintf(\"Spend unconfirmed change when sending transactions (default: %u)\", DEFAULT_SPEND_ZEROCONF_CHANGE), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-txconfirmtarget=<n>\", strprintf(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\", DEFAULT_TX_CONFIRM_TARGET), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-upgradewallet\", \"Upgrade wallet to latest format on startup\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-wallet=<path>\", \"Specify wallet database path. Can be specified multiple times to load multiple wallets. Path is interpreted relative to <walletdir> if it is not absolute, and will be created if it does not exist (as a directory containing a wallet.dat file and log files). For backwards compatibility this will also accept names of existing data files in <walletdir>.)\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-walletbroadcast\",  strprintf(\"Make the wallet broadcast transactions (default: %u)\", DEFAULT_WALLETBROADCAST), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-walletdir=<dir>\", \"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-walletnotify=<cmd>\", \"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\", false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-walletrbf\", strprintf(\"Send transactions with full-RBF opt-in enabled (RPC only, default: %u)\", DEFAULT_WALLET_RBF), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-zapwallettxes=<mode>\", \"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\"\n+                               \" (1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\", false, OptionsCategory::WALLET);\n \n     gArgs.AddArg(\"-dblogsize=<n>\", strprintf(\"Flush wallet database activity from memory to disk log every <n> megabytes (default: %u)\", DEFAULT_WALLET_DBLOGSIZE), true, OptionsCategory::WALLET_DEBUG_TEST);\n     gArgs.AddArg(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", DEFAULT_FLUSHWALLET), true, OptionsCategory::WALLET_DEBUG_TEST);\n     gArgs.AddArg(\"-privdb\", strprintf(\"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\", DEFAULT_WALLET_PRIVDB), true, OptionsCategory::WALLET_DEBUG_TEST);\n-    gArgs.AddArg(\"-walletrejectlongchains\", strprintf(_(\"Wallet will not create transactions that violate mempool chain limits (default: %u)\"), DEFAULT_WALLET_REJECT_LONG_CHAINS), true, OptionsCategory::WALLET_DEBUG_TEST);\n+    gArgs.AddArg(\"-walletrejectlongchains\", strprintf(\"Wallet will not create transactions that violate mempool chain limits (default: %u)\", DEFAULT_WALLET_REJECT_LONG_CHAINS), true, OptionsCategory::WALLET_DEBUG_TEST);\n }\n \n bool WalletInit::ParameterInteraction() const\n@@ -200,7 +200,7 @@ bool WalletInit::Verify() const\n     // Keep track of each wallet absolute path to detect duplicates.\n     std::set<fs::path> wallet_paths;\n \n-    for (const auto wallet_file : wallet_files) {\n+    for (const auto& wallet_file : wallet_files) {\n         fs::path wallet_path = fs::absolute(wallet_file, GetWalletDir());\n \n         if (!wallet_paths.insert(wallet_path).second) {\n@@ -226,7 +226,7 @@ bool WalletInit::Open() const\n     }\n \n     for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n-        CWallet * const pwallet = CWallet::CreateWalletFromFile(walletFile, fs::absolute(walletFile, GetWalletDir()));\n+        std::shared_ptr<CWallet> pwallet = CWallet::CreateWalletFromFile(walletFile, fs::absolute(walletFile, GetWalletDir()));\n         if (!pwallet) {\n             return false;\n         }\n@@ -238,7 +238,7 @@ bool WalletInit::Open() const\n \n void WalletInit::Start(CScheduler& scheduler) const\n {\n-    for (CWallet* pwallet : GetWallets()) {\n+    for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->postInitProcess();\n     }\n \n@@ -248,22 +248,21 @@ void WalletInit::Start(CScheduler& scheduler) const\n \n void WalletInit::Flush() const\n {\n-    for (CWallet* pwallet : GetWallets()) {\n+    for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->Flush(false);\n     }\n }\n \n void WalletInit::Stop() const\n {\n-    for (CWallet* pwallet : GetWallets()) {\n+    for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->Flush(true);\n     }\n }\n \n void WalletInit::Close() const\n {\n-    for (CWallet* pwallet : GetWallets()) {\n+    for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         RemoveWallet(pwallet);\n-        delete pwallet;\n     }\n }"
      },
      {
        "sha": "882ddbbe4e9c49949ad06abfbe6003b0f6d45aa7",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 13,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -56,7 +56,7 @@ static std::string DecodeDumpString(const std::string &str) {\n     for (unsigned int pos = 0; pos < str.length(); pos++) {\n         unsigned char c = str[pos];\n         if (c == '%' && pos+2 < str.length()) {\n-            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n+            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) |\n                 ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n             pos += 2;\n         }\n@@ -89,7 +89,8 @@ static bool GetWalletAddressesForKey(CWallet * const pwallet, const CKeyID &keyi\n \n UniValue importprivkey(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -185,7 +186,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n \n UniValue abortrescan(const JSONRPCRequest& request)\n {\n-    CWallet* const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -246,7 +248,8 @@ static void ImportAddress(CWallet* const pwallet, const CTxDestination& dest, co\n \n UniValue importaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -330,7 +333,8 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n UniValue importprunedfunds(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -392,7 +396,8 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n \n UniValue removeprunedfunds(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -430,12 +435,13 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n \n UniValue importpubkey(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n         throw std::runtime_error(\n             \"importpubkey \\\"pubkey\\\" ( \\\"label\\\" rescan )\\n\"\n             \"\\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\\n\"\n@@ -506,7 +512,8 @@ UniValue importpubkey(const JSONRPCRequest& request)\n \n UniValue importwallet(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -552,7 +559,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n         file.seekg(0, file.beg);\n \n         // Use uiInterface.ShowProgress instead of pwallet.ShowProgress because pwallet.ShowProgress has a cancel button tied to AbortRescan which\n-        // we don't want for this progress bar shoing the import progress. uiInterface.ShowProgress does not have a cancel button.\n+        // we don't want for this progress bar showing the import progress. uiInterface.ShowProgress does not have a cancel button.\n         uiInterface.ShowProgress(_(\"Importing...\"), 0, false); // show progress dialog in GUI\n         while (file.good()) {\n             uiInterface.ShowProgress(\"\", std::max(1, std::min(99, (int)(((double)file.tellg() / (double)nFilesize) * 100))), false);\n@@ -640,7 +647,8 @@ UniValue importwallet(const JSONRPCRequest& request)\n \n UniValue dumpprivkey(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -683,7 +691,8 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n \n UniValue dumpwallet(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1127,7 +1136,8 @@ static int64_t GetImportTimestamp(const UniValue& data, int64_t now)\n \n UniValue importmulti(const JSONRPCRequest& mainRequest)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(mainRequest);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(mainRequest);\n+    CWallet* const pwallet = wallet.get();\n     if (!EnsureWalletIsAvailable(pwallet, mainRequest.fHelp)) {\n         return NullUniValue;\n     }"
      },
      {
        "sha": "bc381d3cdacdf3e4ef81012142c138b394c68a79",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 312,
        "deletions": 124,
        "changes": 436,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -40,17 +40,26 @@\n \n static const std::string WALLET_ENDPOINT_BASE = \"/wallet/\";\n \n-CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request)\n+bool GetWalletNameFromJSONRPCRequest(const JSONRPCRequest& request, std::string& wallet_name)\n {\n     if (request.URI.substr(0, WALLET_ENDPOINT_BASE.size()) == WALLET_ENDPOINT_BASE) {\n         // wallet endpoint was used\n-        std::string requestedWallet = urlDecode(request.URI.substr(WALLET_ENDPOINT_BASE.size()));\n-        CWallet* pwallet = GetWallet(requestedWallet);\n+        wallet_name = urlDecode(request.URI.substr(WALLET_ENDPOINT_BASE.size()));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request)\n+{\n+    std::string wallet_name;\n+    if (GetWalletNameFromJSONRPCRequest(request, wallet_name)) {\n+        std::shared_ptr<CWallet> pwallet = GetWallet(wallet_name);\n         if (!pwallet) throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Requested wallet does not exist or is not loaded\");\n         return pwallet;\n     }\n \n-    std::vector<CWallet*> wallets = GetWallets();\n+    std::vector<std::shared_ptr<CWallet>> wallets = GetWallets();\n     return wallets.size() == 1 || (request.fHelp && wallets.size() > 0) ? wallets[0] : nullptr;\n }\n \n@@ -66,11 +75,6 @@ bool EnsureWalletIsAvailable(CWallet * const pwallet, bool avoidException)\n     if (pwallet) return true;\n     if (avoidException) return false;\n     if (!HasWallets()) {\n-        // Note: It isn't currently possible to trigger this error because\n-        // wallet RPC methods aren't registered unless a wallet is loaded. But\n-        // this error is being kept as a precaution, because it's possible in\n-        // the future that wallet RPC methods might get or remain registered\n-        // when no wallets are loaded.\n         throw JSONRPCError(\n             RPC_METHOD_NOT_FOUND, \"Method not found (wallet method is disabled because no wallet is loaded)\");\n     }\n@@ -120,7 +124,7 @@ static void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     }\n     entry.pushKV(\"bip125-replaceable\", rbfStatus);\n \n-    for (const std::pair<std::string, std::string>& item : wtx.mapValue)\n+    for (const std::pair<const std::string, std::string>& item : wtx.mapValue)\n         entry.pushKV(item.first, item.second);\n }\n \n@@ -134,7 +138,9 @@ static std::string LabelFromValue(const UniValue& value)\n \n static UniValue getnewaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -196,67 +202,54 @@ CTxDestination GetLabelDestination(CWallet* const pwallet, const std::string& la\n     return dest;\n }\n \n-static UniValue getlabeladdress(const JSONRPCRequest& request)\n+static UniValue getaccountaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n \n-    if (!IsDeprecatedRPCEnabled(\"accounts\") && request.strMethod == \"getaccountaddress\") {\n+    if (!IsDeprecatedRPCEnabled(\"accounts\")) {\n         if (request.fHelp) {\n             throw std::runtime_error(\"getaccountaddress (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)\");\n         }\n         throw JSONRPCError(RPC_METHOD_DEPRECATED, \"getaccountaddress is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.\");\n     }\n \n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+    if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"getlabeladdress \\\"label\\\" ( force ) \\n\"\n-            \"\\nReturns the default receiving address for this label. This will reset to a fresh address once there's a transaction that spends to it.\\n\"\n+            \"getaccountaddress \\\"account\\\"\\n\"\n+            \"\\n\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"label\\\"         (string, required) The label for the address. It can also be set to the empty string \\\"\\\" to represent the default label.\\n\"\n-            \"2. \\\"force\\\"         (bool, optional) Whether the label should be created if it does not yet exist. If False, the RPC will return an error if called with a label that doesn't exist.\\n\"\n-            \"                                    Defaults to false (unless the getaccountaddress method alias is being called, in which case defaults to true for backwards compatibility).\\n\"\n+            \"1. \\\"account\\\"       (string, required) The account for the address. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\\n\"\n             \"\\nResult:\\n\"\n-            \"\\\"address\\\"          (string) The current receiving address for the label.\\n\"\n+            \"\\\"address\\\"          (string) The account bitcoin address\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getlabeladdress\", \"\")\n-            + HelpExampleCli(\"getlabeladdress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n-            + HelpExampleRpc(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n+            + HelpExampleCli(\"getaccountaddress\", \"\")\n+            + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\")\n+            + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n+            + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    // Parse the label first so we don't generate a key if there's an error\n-    std::string label = LabelFromValue(request.params[0]);\n-    bool force = request.strMethod == \"getaccountaddress\";\n-    if (!request.params[1].isNull()) {\n-        force = request.params[1].get_bool();\n-    }\n-\n-    bool label_found = false;\n-    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n-        if (item.second.name == label) {\n-            label_found = true;\n-            break;\n-        }\n-    }\n-    if (!force && !label_found) {\n-        throw JSONRPCError(RPC_WALLET_INVALID_LABEL_NAME, std::string(\"No addresses with label \" + label));\n-    }\n+    // Parse the account first so we don't generate a key if there's an error\n+    std::string account = LabelFromValue(request.params[0]);\n \n     UniValue ret(UniValue::VSTR);\n \n-    ret = EncodeDestination(GetLabelDestination(pwallet, label));\n+    ret = EncodeDestination(GetLabelDestination(pwallet, account));\n     return ret;\n }\n \n \n static UniValue getrawchangeaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -304,7 +297,9 @@ static UniValue getrawchangeaddress(const JSONRPCRequest& request)\n \n static UniValue setlabel(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -335,30 +330,42 @@ static UniValue setlabel(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     }\n \n+    std::string old_label = pwallet->mapAddressBook[dest].name;\n     std::string label = LabelFromValue(request.params[1]);\n \n     if (IsMine(*pwallet, dest)) {\n-        // Detect when changing the label of an address that is the receiving address of another label:\n-        // If so, delete the account record for it. Labels, unlike addresses, can be deleted,\n-        // and if we wouldn't do this, the record would stick around forever.\n-        if (pwallet->mapAddressBook.count(dest)) {\n-            std::string old_label = pwallet->mapAddressBook[dest].name;\n-            if (old_label != label && dest == GetLabelDestination(pwallet, old_label)) {\n-                pwallet->DeleteLabel(old_label);\n-            }\n-        }\n         pwallet->SetAddressBook(dest, label, \"receive\");\n+        if (request.strMethod == \"setaccount\" && old_label != label && dest == GetLabelDestination(pwallet, old_label)) {\n+            // for setaccount, call GetLabelDestination so a new receive address is created for the old account\n+            GetLabelDestination(pwallet, old_label, true);\n+        }\n     } else {\n         pwallet->SetAddressBook(dest, label, \"send\");\n     }\n \n+    // Detect when there are no addresses using this label.\n+    // If so, delete the account record for it. Labels, unlike addresses, can be deleted,\n+    // and if we wouldn't do this, the record would stick around forever.\n+    bool found_address = false;\n+    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n+        if (item.second.name == label) {\n+            found_address = true;\n+            break;\n+        }\n+    }\n+    if (!found_address) {\n+        pwallet->DeleteLabel(old_label);\n+    }\n+\n     return NullUniValue;\n }\n \n \n static UniValue getaccount(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -401,7 +408,9 @@ static UniValue getaccount(const JSONRPCRequest& request)\n \n static UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -435,7 +444,7 @@ static UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n-    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n+    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n         const CTxDestination& dest = item.first;\n         const std::string& strName = item.second.name;\n         if (strName == strAccount) {\n@@ -487,7 +496,9 @@ static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &\n \n static UniValue sendtoaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -574,7 +585,9 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n \n static UniValue listaddressgroupings(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -631,7 +644,9 @@ static UniValue listaddressgroupings(const JSONRPCRequest& request)\n \n static UniValue signmessage(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -692,7 +707,9 @@ static UniValue signmessage(const JSONRPCRequest& request)\n \n static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -740,7 +757,7 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n             continue;\n@@ -757,7 +774,9 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -806,7 +825,7 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n             continue;\n@@ -827,7 +846,9 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n \n static UniValue getbalance(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -910,7 +931,9 @@ static UniValue getbalance(const JSONRPCRequest& request)\n \n static UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -932,7 +955,9 @@ static UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n \n static UniValue movecmd(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -989,11 +1014,21 @@ static UniValue movecmd(const JSONRPCRequest& request)\n \n static UniValue sendfrom(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n \n+    if (!IsDeprecatedRPCEnabled(\"accounts\")) {\n+        if (request.fHelp) {\n+            throw std::runtime_error(\"sendfrom (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)\");\n+        }\n+        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"sendfrom is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.\");\n+    }\n+\n+\n     if (request.fHelp || request.params.size() < 3 || request.params.size() > 6)\n         throw std::runtime_error(\n             \"sendfrom \\\"fromaccount\\\" \\\"toaddress\\\" amount ( minconf \\\"comment\\\" \\\"comment_to\\\" )\\n\"\n@@ -1062,7 +1097,9 @@ static UniValue sendfrom(const JSONRPCRequest& request)\n \n static UniValue sendmany(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1230,9 +1267,11 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked(pwallet);\n \n     // Check funds\n-    CAmount nBalance = pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount);\n-    if (totalAmount > nBalance)\n+    if (IsDeprecatedRPCEnabled(\"accounts\") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount)) {\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n+    } else if (!IsDeprecatedRPCEnabled(\"accounts\") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, nullptr)) {\n+        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Wallet has insufficient funds\");\n+    }\n \n     // Shuffle recipient list\n     std::shuffle(vecSend.begin(), vecSend.end(), FastRandomContext());\n@@ -1257,7 +1296,9 @@ static UniValue sendmany(const JSONRPCRequest& request)\n \n static UniValue addmultisigaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1392,7 +1433,9 @@ class Witnessifier : public boost::static_visitor<bool>\n \n static UniValue addwitnessaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1421,13 +1464,6 @@ static UniValue addwitnessaddress(const JSONRPCRequest& request)\n             \"Projects should transition to using the address_type argument of getnewaddress, or option -addresstype=[bech32|p2sh-segwit] instead.\\n\");\n     }\n \n-    {\n-        LOCK(cs_main);\n-        if (!IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()) && !gArgs.GetBoolArg(\"-walletprematurewitness\", false)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Segregated witness not enabled on network\");\n-        }\n-    }\n-\n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n     if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -1505,7 +1541,7 @@ static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bo\n \n     // Tally\n     std::map<CTxDestination, tallyitem> mapTally;\n-    for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n@@ -1624,7 +1660,9 @@ static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bo\n \n static UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1673,7 +1711,9 @@ static UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n \n static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -1838,7 +1878,9 @@ static void AcentryToJSON(const CAccountingEntry& acentry, const std::string& st\n \n UniValue listtransactions(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2026,7 +2068,9 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n static UniValue listaccounts(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2076,13 +2120,13 @@ static UniValue listaccounts(const JSONRPCRequest& request)\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n     std::map<std::string, CAmount> mapAccountBalances;\n-    for (const std::pair<CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {\n+    for (const std::pair<const CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {\n         if (IsMine(*pwallet, entry.first) & includeWatchonly) {  // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n         }\n     }\n \n-    for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n         CAmount nFee;\n         std::string strSentAccount;\n@@ -2111,15 +2155,17 @@ static UniValue listaccounts(const JSONRPCRequest& request)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     UniValue ret(UniValue::VOBJ);\n-    for (const std::pair<std::string, CAmount>& accountBalance : mapAccountBalances) {\n+    for (const std::pair<const std::string, CAmount>& accountBalance : mapAccountBalances) {\n         ret.pushKV(accountBalance.first, ValueFromAmount(accountBalance.second));\n     }\n     return ret;\n }\n \n static UniValue listsinceblock(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2218,7 +2264,7 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n \n     UniValue transactions(UniValue::VARR);\n \n-    for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         CWalletTx tx = pairWtx.second;\n \n         if (depth == -1 || tx.GetDepthInMainChain() < depth) {\n@@ -2258,7 +2304,9 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n \n static UniValue gettransaction(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2352,7 +2400,9 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n \n static UniValue abandontransaction(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2396,7 +2446,9 @@ static UniValue abandontransaction(const JSONRPCRequest& request)\n \n static UniValue backupwallet(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2429,7 +2481,9 @@ static UniValue backupwallet(const JSONRPCRequest& request)\n \n static UniValue keypoolrefill(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2476,7 +2530,9 @@ static void LockWallet(CWallet* pWallet)\n \n static UniValue walletpassphrase(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2549,7 +2605,9 @@ static UniValue walletpassphrase(const JSONRPCRequest& request)\n \n static UniValue walletpassphrasechange(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2598,7 +2656,9 @@ static UniValue walletpassphrasechange(const JSONRPCRequest& request)\n \n static UniValue walletlock(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2636,7 +2696,9 @@ static UniValue walletlock(const JSONRPCRequest& request)\n \n static UniValue encryptwallet(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2696,7 +2758,9 @@ static UniValue encryptwallet(const JSONRPCRequest& request)\n \n static UniValue lockunspent(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2823,7 +2887,9 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n \n static UniValue listlockunspent(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2874,7 +2940,9 @@ static UniValue listlockunspent(const JSONRPCRequest& request)\n \n static UniValue settxfee(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2903,7 +2971,9 @@ static UniValue settxfee(const JSONRPCRequest& request)\n \n static UniValue getwalletinfo(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -2984,20 +3054,20 @@ static UniValue listwallets(const JSONRPCRequest& request)\n \n     UniValue obj(UniValue::VARR);\n \n-    for (CWallet* pwallet : GetWallets()) {\n-        if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+    for (const std::shared_ptr<CWallet>& wallet : GetWallets()) {\n+        if (!EnsureWalletIsAvailable(wallet.get(), request.fHelp)) {\n             return NullUniValue;\n         }\n \n-        LOCK(pwallet->cs_wallet);\n+        LOCK(wallet->cs_wallet);\n \n-        obj.push_back(pwallet->GetName());\n+        obj.push_back(wallet->GetName());\n     }\n \n     return obj;\n }\n \n-UniValue loadwallet(const JSONRPCRequest& request)\n+static UniValue loadwallet(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -3029,7 +3099,7 @@ UniValue loadwallet(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet file verification failed: \" + error);\n     }\n \n-    CWallet * const wallet = CWallet::CreateWalletFromFile(wallet_file, fs::absolute(wallet_file, GetWalletDir()));\n+    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(wallet_file, fs::absolute(wallet_file, GetWalletDir()));\n     if (!wallet) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet loading failed.\");\n     }\n@@ -3044,9 +3114,107 @@ UniValue loadwallet(const JSONRPCRequest& request)\n     return obj;\n }\n \n+static UniValue createwallet(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1) {\n+        throw std::runtime_error(\n+            \"createwallet \\\"wallet_name\\\"\\n\"\n+            \"\\nCreates and loads a new wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"wallet_name\\\"    (string, required) The name for the new wallet. If this is a path, the wallet will be created at the path location.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"name\\\" :    <wallet_name>,        (string) The wallet name if created successfully. If the wallet was created using a full path, the wallet_name will be the full path.\\n\"\n+            \"  \\\"warning\\\" : <warning>,            (string) Warning message if wallet was not loaded cleanly.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"createwallet\", \"\\\"testwallet\\\"\")\n+            + HelpExampleRpc(\"createwallet\", \"\\\"testwallet\\\"\")\n+        );\n+    }\n+    std::string wallet_name = request.params[0].get_str();\n+    std::string error;\n+    std::string warning;\n+\n+    fs::path wallet_path = fs::absolute(wallet_name, GetWalletDir());\n+    if (fs::symlink_status(wallet_path).type() != fs::file_not_found) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet \" + wallet_name + \" already exists.\");\n+    }\n+\n+    // Wallet::Verify will check if we're trying to create a wallet with a duplication name.\n+    if (!CWallet::Verify(wallet_name, false, error, warning)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet file verification failed: \" + error);\n+    }\n+\n+    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(wallet_name, fs::absolute(wallet_name, GetWalletDir()));\n+    if (!wallet) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet creation failed.\");\n+    }\n+    AddWallet(wallet);\n+\n+    wallet->postInitProcess();\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.pushKV(\"name\", wallet->GetName());\n+    obj.pushKV(\"warning\", warning);\n+\n+    return obj;\n+}\n+\n+static UniValue unloadwallet(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"unloadwallet ( \\\"wallet_name\\\" )\\n\"\n+            \"Unloads the wallet referenced by the request endpoint otherwise unloads the wallet specified in the argument.\\n\"\n+            \"Specifying the wallet name on a wallet endpoint is invalid.\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"wallet_name\\\"    (string, optional) The name of the wallet to unload.\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"unloadwallet\", \"wallet_name\")\n+            + HelpExampleRpc(\"unloadwallet\", \"wallet_name\")\n+        );\n+    }\n+\n+    std::string wallet_name;\n+    if (GetWalletNameFromJSONRPCRequest(request, wallet_name)) {\n+        if (!request.params[0].isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot unload the requested wallet\");\n+        }\n+    } else {\n+        wallet_name = request.params[0].get_str();\n+    }\n+\n+    std::shared_ptr<CWallet> wallet = GetWallet(wallet_name);\n+    if (!wallet) {\n+        throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Requested wallet does not exist or is not loaded\");\n+    }\n+\n+    // Release the \"main\" shared pointer and prevent further notifications.\n+    // Note that any attempt to load the same wallet would fail until the wallet\n+    // is destroyed (see CheckUniqueFileid).\n+    if (!RemoveWallet(wallet)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Requested wallet already unloaded\");\n+    }\n+    UnregisterValidationInterface(wallet.get());\n+\n+    // The wallet can be in use so it's not possible to explicitly unload here.\n+    // Just notify the unload intent so that all shared pointers are released.\n+    // The wallet will be destroyed once the last shared pointer is released.\n+    wallet->NotifyUnload();\n+\n+    // There's no point in waiting for the wallet to unload.\n+    // At this point this method should never fail. The unloading could only\n+    // fail due to an unexpected error which would cause a process termination.\n+\n+    return NullUniValue;\n+}\n+\n static UniValue resendwallettransactions(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -3081,7 +3249,9 @@ static UniValue resendwallettransactions(const JSONRPCRequest& request)\n \n static UniValue listunspent(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -3252,7 +3422,9 @@ static UniValue listunspent(const JSONRPCRequest& request)\n \n static UniValue fundrawtransaction(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -3452,7 +3624,9 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n \n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -3521,7 +3695,9 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n \n static UniValue bumpfee(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n \n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp))\n         return NullUniValue;\n@@ -3670,7 +3846,9 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n \n UniValue generate(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n \n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n@@ -3715,7 +3893,9 @@ UniValue generate(const JSONRPCRequest& request)\n \n UniValue rescanblockchain(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -3920,7 +4100,9 @@ static UniValue AddressBookDataToJSON(const CAddressBookData& data, const bool v\n \n UniValue getaddressinfo(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -4038,7 +4220,9 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n \n static UniValue getaddressesbylabel(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -4066,7 +4250,7 @@ static UniValue getaddressesbylabel(const JSONRPCRequest& request)\n \n     // Find all addresses that have the given label\n     UniValue ret(UniValue::VOBJ);\n-    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n+    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n         if (item.second.name == label) {\n             ret.pushKV(EncodeDestination(item.first), AddressBookDataToJSON(item.second, false));\n         }\n@@ -4081,7 +4265,9 @@ static UniValue getaddressesbylabel(const JSONRPCRequest& request)\n \n static UniValue listlabels(const JSONRPCRequest& request)\n {\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n     }\n@@ -4117,7 +4303,7 @@ static UniValue listlabels(const JSONRPCRequest& request)\n \n     // Add to a set to sort by label name, then insert into Univalue array\n     std::set<std::string> label_set;\n-    for (const std::pair<CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {\n+    for (const std::pair<const CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {\n         if (purpose.empty() || entry.second.purpose == purpose) {\n             label_set.insert(entry.second.name);\n         }\n@@ -4133,7 +4319,8 @@ static UniValue listlabels(const JSONRPCRequest& request)\n \n UniValue sethdseed(const JSONRPCRequest& request)\n {\n-    CWallet* const pwallet = GetWalletForJSONRPCRequest(request);\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n \n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n         return NullUniValue;\n@@ -4224,6 +4411,7 @@ static const CRPCCommand commands[] =\n     { \"hidden\",             \"addwitnessaddress\",                &addwitnessaddress,             {\"address\",\"p2sh\"} },\n     { \"wallet\",             \"backupwallet\",                     &backupwallet,                  {\"destination\"} },\n     { \"wallet\",             \"bumpfee\",                          &bumpfee,                       {\"txid\", \"options\"} },\n+    { \"wallet\",             \"createwallet\",                     &createwallet,                  {\"wallet_name\"} },\n     { \"wallet\",             \"dumpprivkey\",                      &dumpprivkey,                   {\"address\"}  },\n     { \"wallet\",             \"dumpwallet\",                       &dumpwallet,                    {\"filename\"} },\n     { \"wallet\",             \"encryptwallet\",                    &encryptwallet,                 {\"passphrase\"} },\n@@ -4251,12 +4439,12 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listwallets\",                      &listwallets,                   {} },\n     { \"wallet\",             \"loadwallet\",                       &loadwallet,                    {\"filename\"} },\n     { \"wallet\",             \"lockunspent\",                      &lockunspent,                   {\"unlock\",\"transactions\"} },\n-    { \"wallet\",             \"sendfrom\",                         &sendfrom,                      {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },\n     { \"wallet\",             \"sendmany\",                         &sendmany,                      {\"fromaccount|dummy\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n     { \"wallet\",             \"sendtoaddress\",                    &sendtoaddress,                 {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n     { \"wallet\",             \"settxfee\",                         &settxfee,                      {\"amount\"} },\n     { \"wallet\",             \"signmessage\",                      &signmessage,                   {\"address\",\"message\"} },\n     { \"wallet\",             \"signrawtransactionwithwallet\",     &signrawtransactionwithwallet,  {\"hexstring\",\"prevtxs\",\"sighashtype\"} },\n+    { \"wallet\",             \"unloadwallet\",                     &unloadwallet,                  {\"wallet_name\"} },\n     { \"wallet\",             \"walletlock\",                       &walletlock,                    {} },\n     { \"wallet\",             \"walletpassphrasechange\",           &walletpassphrasechange,        {\"oldpassphrase\",\"newpassphrase\"} },\n     { \"wallet\",             \"walletpassphrase\",                 &walletpassphrase,              {\"passphrase\",\"timeout\"} },\n@@ -4265,17 +4453,17 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"sethdseed\",                        &sethdseed,                     {\"newkeypool\",\"seed\"} },\n \n     /** Account functions (deprecated) */\n-    { \"wallet\",             \"getaccountaddress\",                &getlabeladdress,               {\"account\"} },\n+    { \"wallet\",             \"getaccountaddress\",                &getaccountaddress,             {\"account\"} },\n     { \"wallet\",             \"getaccount\",                       &getaccount,                    {\"address\"} },\n     { \"wallet\",             \"getaddressesbyaccount\",            &getaddressesbyaccount,         {\"account\"} },\n     { \"wallet\",             \"getreceivedbyaccount\",             &getreceivedbylabel,            {\"account\",\"minconf\"} },\n     { \"wallet\",             \"listaccounts\",                     &listaccounts,                  {\"minconf\",\"include_watchonly\"} },\n     { \"wallet\",             \"listreceivedbyaccount\",            &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"setaccount\",                       &setlabel,                      {\"address\",\"account\"} },\n+    { \"wallet\",             \"sendfrom\",                         &sendfrom,                      {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },\n     { \"wallet\",             \"move\",                             &movecmd,                       {\"fromaccount\",\"toaccount\",\"amount\",\"minconf\",\"comment\"} },\n \n     /** Label functions (to replace non-balance account functions) */\n-    { \"wallet\",             \"getlabeladdress\",                  &getlabeladdress,               {\"label\",\"force\"} },\n     { \"wallet\",             \"getaddressesbylabel\",              &getaddressesbylabel,           {\"label\"} },\n     { \"wallet\",             \"getreceivedbylabel\",               &getreceivedbylabel,            {\"label\",\"minconf\"} },\n     { \"wallet\",             \"listlabels\",                       &listlabels,                    {\"purpose\"} },"
      },
      {
        "sha": "b841f3e424e201ec20a4b258cf535a4d42815ce5",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -20,7 +20,7 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  * @param[in] request JSONRPCRequest that wishes to access a wallet\n  * @return nullptr if no wallet should be used, or a pointer to the CWallet\n  */\n-CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n+std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n std::string HelpRequiringPassphrase(CWallet *);\n void EnsureWalletIsUnlocked(CWallet *);"
      },
      {
        "sha": "d90be33000f46ccc54033a790d24c581e3d349e7",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -2,14 +2,14 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"wallet/wallet.h\"\n-#include \"wallet/coinselection.h\"\n-#include \"wallet/coincontrol.h\"\n-#include \"amount.h\"\n-#include \"primitives/transaction.h\"\n-#include \"random.h\"\n-#include \"test/test_bitcoin.h\"\n-#include \"wallet/test/wallet_test_fixture.h\"\n+#include <wallet/wallet.h>\n+#include <wallet/coinselection.h>\n+#include <wallet/coincontrol.h>\n+#include <amount.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <test/test_bitcoin.h>\n+#include <wallet/test/wallet_test_fixture.h>\n \n #include <boost/test/unit_test.hpp>\n #include <random>"
      },
      {
        "sha": "03754154fc913baa87b2cc32b8cb0fabfa4dd206",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -73,8 +73,8 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // before the missing block, and success for a key whose creation time is\n     // after.\n     {\n-        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n-        AddWallet(&wallet);\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+        AddWallet(wallet);\n         UniValue keys;\n         keys.setArray();\n         UniValue key;\n@@ -105,7 +105,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n                               0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n-        RemoveWallet(&wallet);\n+        RemoveWallet(wallet);\n     }\n }\n \n@@ -132,36 +132,36 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n \n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n-        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n-        LOCK(wallet.cs_wallet);\n-        wallet.mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n-        wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+        LOCK(wallet->cs_wallet);\n+        wallet->mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n+        wallet->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back((pathTemp / \"wallet.backup\").string());\n-        AddWallet(&wallet);\n+        AddWallet(wallet);\n         ::dumpwallet(request);\n-        RemoveWallet(&wallet);\n+        RemoveWallet(wallet);\n     }\n \n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n     // were scanned, and no prior blocks were scanned.\n     {\n-        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back((pathTemp / \"wallet.backup\").string());\n-        AddWallet(&wallet);\n+        AddWallet(wallet);\n         ::importwallet(request);\n-        RemoveWallet(&wallet);\n+        RemoveWallet(wallet);\n \n-        LOCK(wallet.cs_wallet);\n-        BOOST_CHECK_EQUAL(wallet.mapWallet.size(), 3U);\n+        LOCK(wallet->cs_wallet);\n+        BOOST_CHECK_EQUAL(wallet->mapWallet.size(), 3U);\n         BOOST_CHECK_EQUAL(m_coinbase_txns.size(), 103U);\n         for (size_t i = 0; i < m_coinbase_txns.size(); ++i) {\n-            bool found = wallet.GetWalletTx(m_coinbase_txns[i]->GetHash());\n+            bool found = wallet->GetWalletTx(m_coinbase_txns[i]->GetHash());\n             bool expected = i >= 100;\n             BOOST_CHECK_EQUAL(found, expected);\n         }"
      },
      {
        "sha": "842516bb0e303a35422fa86aa60a43b1b953b651",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 56,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -36,23 +36,23 @@\n #include <boost/algorithm/string/replace.hpp>\n \n static CCriticalSection cs_wallets;\n-static std::vector<CWallet*> vpwallets GUARDED_BY(cs_wallets);\n+static std::vector<std::shared_ptr<CWallet>> vpwallets GUARDED_BY(cs_wallets);\n \n-bool AddWallet(CWallet* wallet)\n+bool AddWallet(const std::shared_ptr<CWallet>& wallet)\n {\n     LOCK(cs_wallets);\n     assert(wallet);\n-    std::vector<CWallet*>::const_iterator i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n+    std::vector<std::shared_ptr<CWallet>>::const_iterator i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n     if (i != vpwallets.end()) return false;\n     vpwallets.push_back(wallet);\n     return true;\n }\n \n-bool RemoveWallet(CWallet* wallet)\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet)\n {\n     LOCK(cs_wallets);\n     assert(wallet);\n-    std::vector<CWallet*>::iterator i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n+    std::vector<std::shared_ptr<CWallet>>::iterator i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n     if (i == vpwallets.end()) return false;\n     vpwallets.erase(i);\n     return true;\n@@ -64,21 +64,30 @@ bool HasWallets()\n     return !vpwallets.empty();\n }\n \n-std::vector<CWallet*> GetWallets()\n+std::vector<std::shared_ptr<CWallet>> GetWallets()\n {\n     LOCK(cs_wallets);\n     return vpwallets;\n }\n \n-CWallet* GetWallet(const std::string& name)\n+std::shared_ptr<CWallet> GetWallet(const std::string& name)\n {\n     LOCK(cs_wallets);\n-    for (CWallet* wallet : vpwallets) {\n+    for (const std::shared_ptr<CWallet>& wallet : vpwallets) {\n         if (wallet->GetName() == name) return wallet;\n     }\n     return nullptr;\n }\n \n+// Custom deleter for shared_ptr<CWallet>.\n+static void ReleaseWallet(CWallet* wallet)\n+{\n+    LogPrintf(\"Releasing wallet %s\\n\", wallet->GetName());\n+    wallet->BlockUntilSyncedToCurrentChain();\n+    wallet->Flush();\n+    delete wallet;\n+}\n+\n const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n \n const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n@@ -600,6 +609,8 @@ void CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n {\n     mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n \n+    setLockedCoins.erase(outpoint);\n+\n     std::pair<TxSpends::iterator, TxSpends::iterator> range;\n     range = mapTxSpends.equal_range(outpoint);\n     SyncMetaData(range);\n@@ -923,11 +934,10 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n     CWalletTx& wtx = (*ret.first).second;\n     wtx.BindWallet(this);\n     bool fInsertedNew = ret.second;\n-    if (fInsertedNew)\n-    {\n+    if (fInsertedNew) {\n         wtx.nTimeReceived = GetAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&batch);\n-        wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n+        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n         wtx.nTimeSmart = ComputeTimeSmart(wtx);\n         AddToSpends(hash);\n     }\n@@ -998,9 +1008,12 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n {\n     uint256 hash = wtxIn.GetHash();\n-    CWalletTx& wtx = mapWallet.emplace(hash, wtxIn).first->second;\n+    const auto& ins = mapWallet.emplace(hash, wtxIn);\n+    CWalletTx& wtx = ins.first->second;\n     wtx.BindWallet(this);\n-    wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n+    if (/* insertion took place */ ins.second) {\n+        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n+    }\n     AddToSpends(hash);\n     for (const CTxIn& txin : wtx.tx->vin) {\n         auto it = mapWallet.find(txin.prevout.hash);\n@@ -1294,7 +1307,7 @@ void CWallet::BlockUntilSyncedToCurrentChain() {\n         LOCK(cs_main);\n         const CBlockIndex* initialChainTip = chainActive.Tip();\n \n-        if (m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n+        if (m_last_block_processed && m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n             return;\n         }\n     }\n@@ -2376,10 +2389,10 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n                 continue;\n             }\n \n-            bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n-            bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n+            bool solvable = IsSolvable(*this, pcoin->tx->vout[i].scriptPubKey);\n+            bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n \n-            vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n+            vCoins.push_back(COutput(pcoin, i, nDepth, spendable, solvable, safeTx));\n \n             // Checks the sum amount of all UTXO's.\n             if (nMinimumSumAmount != MAX_MONEY) {\n@@ -2469,8 +2482,11 @@ bool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibi\n     if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? eligibility_filter.conf_mine : eligibility_filter.conf_theirs))\n         return false;\n \n-    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), eligibility_filter.max_ancestors))\n+    size_t ancestors, descendants;\n+    mempool.GetTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+    if (ancestors > eligibility_filter.max_ancestors || descendants > eligibility_filter.max_descendants) {\n         return false;\n+    }\n \n     return true;\n }\n@@ -2582,16 +2598,17 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             ++it;\n     }\n \n-    size_t nMaxChainLength = std::min(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT), gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT));\n+    size_t max_ancestors = (size_t)std::max<int64_t>(1, gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT));\n+    size_t max_descendants = (size_t)std::max<int64_t>(1, gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT));\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n         SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n         SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n         (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n         (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n@@ -2608,20 +2625,19 @@ bool CWallet::SignTransaction(CMutableTransaction &tx)\n     AssertLockHeld(cs_wallet); // mapWallet\n \n     // sign the new tx\n-    CTransaction txNewConst(tx);\n     int nIn = 0;\n-    for (const auto& input : tx.vin) {\n+    for (auto& input : tx.vin) {\n         std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n         if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n             return false;\n         }\n         const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n         const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n         SignatureData sigdata;\n-        if (!ProduceSignature(*this, TransactionSignatureCreator(&txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n+        if (!ProduceSignature(*this, MutableTransactionSignatureCreator(&tx, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n             return false;\n         }\n-        UpdateTransaction(tx, nIn, sigdata);\n+        UpdateInput(input, sigdata);\n         nIn++;\n     }\n     return true;\n@@ -3040,19 +3056,18 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n \n         if (sign)\n         {\n-            CTransaction txNewConst(txNew);\n             int nIn = 0;\n             for (const auto& coin : selected_coins)\n             {\n                 const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;\n \n-                if (!ProduceSignature(*this, TransactionSignatureCreator(&txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n+                if (!ProduceSignature(*this, MutableTransactionSignatureCreator(&txNew, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                 {\n                     strFailReason = _(\"Signing transaction failed\");\n                     return false;\n                 } else {\n-                    UpdateTransaction(txNew, nIn, sigdata);\n+                    UpdateInput(txNew.vin.at(nIn), sigdata);\n                 }\n \n                 nIn++;\n@@ -3201,17 +3216,18 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     if (nLoadWalletRet != DBErrors::LOAD_OK)\n         return nLoadWalletRet;\n \n-    uiInterface.LoadWallet(this);\n-\n     return DBErrors::LOAD_OK;\n }\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n     AssertLockHeld(cs_wallet); // mapWallet\n     DBErrors nZapSelectTxRet = WalletBatch(*database,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n-    for (uint256 hash : vHashOut)\n-        mapWallet.erase(hash);\n+    for (uint256 hash : vHashOut) {\n+        const auto& it = mapWallet.find(hash);\n+        wtxOrdered.erase(it->second.m_it_wtxOrdered);\n+        mapWallet.erase(it);\n+    }\n \n     if (nZapSelectTxRet == DBErrors::NEED_REWRITE)\n     {\n@@ -3284,7 +3300,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n \n         // Delete destdata tuples associated with address\n         std::string strAddress = EncodeDestination(address);\n-        for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n+        for (const std::pair<const std::string, std::string> &item : mapAddressBook[address].destdata)\n         {\n             WalletBatch(*database).EraseDestData(strAddress, item.first);\n         }\n@@ -3429,7 +3445,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n     return true;\n }\n \n-void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n+bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n {\n     nIndex = -1;\n     keypool.vchPubKey = CPubKey();\n@@ -3440,11 +3456,13 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n             TopUpKeyPool();\n \n         bool fReturningInternal = IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT) && fRequestedInternal;\n-        std::set<int64_t>& setKeyPool = set_pre_split_keypool.empty() ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;\n+        bool use_split_keypool = set_pre_split_keypool.empty();\n+        std::set<int64_t>& setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;\n \n         // Get the oldest key\n-        if(setKeyPool.empty())\n-            return;\n+        if (setKeyPool.empty()) {\n+            return false;\n+        }\n \n         WalletBatch batch(*database);\n \n@@ -3458,14 +3476,17 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n             throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n         }\n         // If the key was pre-split keypool, we don't care about what type it is\n-        if (set_pre_split_keypool.size() == 0 && keypool.fInternal != fReturningInternal) {\n+        if (use_split_keypool && keypool.fInternal != fReturningInternal) {\n             throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n         }\n+        if (!keypool.vchPubKey.IsValid()) {\n+            throw std::runtime_error(std::string(__func__) + \": keypool entry invalid\");\n+        }\n \n-        assert(keypool.vchPubKey.IsValid());\n         m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n         LogPrintf(\"keypool reserve %d\\n\", nIndex);\n     }\n+    return true;\n }\n \n void CWallet::KeepKey(int64_t nIndex)\n@@ -3498,10 +3519,8 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n     CKeyPool keypool;\n     {\n         LOCK(cs_wallet);\n-        int64_t nIndex = 0;\n-        ReserveKeyFromKeyPool(nIndex, keypool, internal);\n-        if (nIndex == -1)\n-        {\n+        int64_t nIndex;\n+        if (!ReserveKeyFromKeyPool(nIndex, keypool, internal)) {\n             if (IsLocked()) return false;\n             WalletBatch batch(*database);\n             result = GenerateNewKey(batch, internal);\n@@ -3682,7 +3701,7 @@ std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) co\n {\n     LOCK(cs_wallet);\n     std::set<CTxDestination> result;\n-    for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n+    for (const std::pair<const CTxDestination, CAddressBookData>& item : mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n         const std::string& strName = item.second.name;\n@@ -3703,12 +3722,10 @@ bool CReserveKey::GetReservedKey(CPubKey& pubkey, bool internal)\n     if (nIndex == -1)\n     {\n         CKeyPool keypool;\n-        pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal);\n-        if (nIndex != -1)\n-            vchPubKey = keypool.vchPubKey;\n-        else {\n+        if (!pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal)) {\n             return false;\n         }\n+        vchPubKey = keypool.vchPubKey;\n         fInternal = keypool.fInternal;\n     }\n     assert(vchPubKey.IsValid());\n@@ -4038,7 +4055,7 @@ bool CWallet::Verify(std::string wallet_file, bool salvage_wallet, std::string&\n     return WalletBatch::VerifyDatabaseFile(wallet_path, warning_string, error_string);\n }\n \n-CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path)\n+std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path)\n {\n     const std::string& walletFile = name;\n \n@@ -4060,10 +4077,9 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n \n     int64_t nStart = GetTimeMillis();\n     bool fFirstRun = true;\n-    // Make a temporary wallet unique pointer so memory doesn't get leaked if\n-    // wallet creation fails.\n-    auto temp_wallet = MakeUnique<CWallet>(name, WalletDatabase::Create(path));\n-    CWallet* walletInstance = temp_wallet.get();\n+    // TODO: Can't use std::make_shared because we need a custom deleter but\n+    // should be possible to use std::allocate_shared.\n+    std::shared_ptr<CWallet> walletInstance(new CWallet(name, WalletDatabase::Create(path)), ReleaseWallet);\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n     if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n@@ -4304,7 +4320,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n \n         nStart = GetTimeMillis();\n         {\n-            WalletRescanReserver reserver(walletInstance);\n+            WalletRescanReserver reserver(walletInstance.get());\n             if (!reserver.reserve()) {\n                 InitError(_(\"Failed to rescan the wallet during initialization\"));\n                 return nullptr;\n@@ -4341,8 +4357,10 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n         }\n     }\n \n+    uiInterface.LoadWallet(walletInstance);\n+\n     // Register with the validation interface. It's ok to do this after rescan since we're still holding cs_main.\n-    RegisterValidationInterface(temp_wallet.release());\n+    RegisterValidationInterface(walletInstance.get());\n \n     walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n "
      },
      {
        "sha": "b8293948472baec04a40aaeffd1eb280c5a4c277",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 28,
        "deletions": 7,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -32,11 +32,11 @@\n #include <utility>\n #include <vector>\n \n-bool AddWallet(CWallet* wallet);\n-bool RemoveWallet(CWallet* wallet);\n+bool AddWallet(const std::shared_ptr<CWallet>& wallet);\n+bool RemoveWallet(const std::shared_ptr<CWallet>& wallet);\n bool HasWallets();\n-std::vector<CWallet*> GetWallets();\n-CWallet* GetWallet(const std::string& name);\n+std::vector<std::shared_ptr<CWallet>> GetWallets();\n+std::shared_ptr<CWallet> GetWallet(const std::string& name);\n \n //! Default for -keypool\n static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n@@ -339,6 +339,7 @@ class CWalletTx : public CMerkleTx\n     char fFromMe;\n     std::string strFromAccount;\n     int64_t nOrderPos; //!< position in ordered transaction list\n+    std::multimap<int64_t, std::pair<CWalletTx*, CAccountingEntry*>>::const_iterator m_it_wtxOrdered;\n \n     // memory only\n     mutable bool fDebitCached;\n@@ -662,8 +663,10 @@ struct CoinEligibilityFilter\n     const int conf_mine;\n     const int conf_theirs;\n     const uint64_t max_ancestors;\n+    const uint64_t max_descendants;\n \n-    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors) {}\n+    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_ancestors) {}\n+    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants) {}\n };\n \n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n@@ -999,7 +1002,22 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool NewKeyPool();\n     size_t KeypoolCountExternalKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool TopUpKeyPool(unsigned int kpSize = 0);\n-    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal);\n+\n+    /**\n+     * Reserves a key from the keypool and sets nIndex to its index\n+     *\n+     * @param[out] nIndex the index of the key in keypool\n+     * @param[out] keypool the keypool the key was drawn from, which could be the\n+     *     the pre-split pool if present, or the internal or external pool\n+     * @param fRequestedInternal true if the caller would like the key drawn\n+     *     from the internal keypool, false if external is preferred\n+     *\n+     * @return true if succeeded, false if failed due to empty keypool\n+     * @throws std::runtime_error if keypool read failed, key was invalid,\n+     *     was not found in the wallet, or was misclassified in the internal\n+     *     or external keypool\n+     */\n+    bool ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal);\n     void KeepKey(int64_t nIndex);\n     void ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey);\n     bool GetKeyFromPool(CPubKey &key, bool internal = false);\n@@ -1082,6 +1100,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     //! Flush wallet (bitdb flush)\n     void Flush(bool shutdown=false);\n \n+    /** Wallet is about to be unloaded */\n+    boost::signals2::signal<void ()> NotifyUnload;\n+\n     /**\n      * Address book entry changed.\n      * @note called with lock cs_wallet held.\n@@ -1122,7 +1143,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     static bool Verify(std::string wallet_file, bool salvage_wallet, std::string& error_string, std::string& warning_string);\n \n     /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */\n-    static CWallet* CreateWalletFromFile(const std::string& name, const fs::path& path);\n+    static std::shared_ptr<CWallet> CreateWalletFromFile(const std::string& name, const fs::path& path);\n \n     /**\n      * Wallet post-init setup"
      },
      {
        "sha": "4b4460a794fca343304748172cfecab395217549",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -756,7 +756,7 @@ void MaybeCompactWalletDB()\n         return;\n     }\n \n-    for (CWallet* pwallet : GetWallets()) {\n+    for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         WalletDatabase& dbh = pwallet->GetDBHandle();\n \n         unsigned int nUpdateCounter = dbh.nUpdateCounter;"
      },
      {
        "sha": "e6365222ffe6183e598728b07f5444a3dedb236b",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -20,6 +20,8 @@ don't have test cases for.\n - Where possible, try to adhere to [PEP-8 guidelines](https://www.python.org/dev/peps/pep-0008/)\n - Use a python linter like flake8 before submitting PRs to catch common style\n   nits (eg trailing whitespace, unused imports, etc)\n+- See [the python lint script](/test/lint/lint-python.sh) that checks for violations that\n+  could lead to bugs and issues in the test code.\n - Avoid wildcard imports where possible\n - Use a module-level docstring to describe what the test is testing, and how it\n   is testing it.\n@@ -74,18 +76,14 @@ over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n wrappers for them, `msg_block`, `msg_tx`, etc).\n \n - P2P tests have two threads. One thread handles all network communication\n-with the bitcoind(s) being tested (using python's asyncore package); the other\n+with the bitcoind(s) being tested in a callback-based event loop; the other\n implements the test logic.\n \n - `P2PConnection` is the class used to connect to a bitcoind.  `P2PInterface`\n contains the higher level logic for processing P2P payloads and connecting to\n the Bitcoin Core node application logic. For custom behaviour, subclass the\n P2PInterface object and override the callback methods.\n \n-- Call `network_thread_start()` after all `P2PInterface` objects are created to\n-start the networking thread.  (Continue with the test logic in your existing\n-thread.)\n-\n - Can be used to write tests where specific P2P protocol behavior is tested.\n Examples tests are `p2p_unrequested_blocks.py`, `p2p_compactblocks.py`.\n "
      },
      {
        "sha": "91b6415a7cdfcd4f6e529de600bcff0897dcdd2a",
        "filename": "test/functional/combine_logs.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/combine_logs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/combine_logs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combine_logs.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -63,7 +63,7 @@ def get_log_events(source, logfile):\n     Log events may be split over multiple lines. We use the timestamp\n     regex match as the marker for a new log event.\"\"\"\n     try:\n-        with open(logfile, 'r') as infile:\n+        with open(logfile, 'r', encoding='utf-8') as infile:\n             event = ''\n             timestamp = ''\n             for line in infile:"
      },
      {
        "sha": "e2f1cc05b3e080989cc698eb6ea7f5579325fee0",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -21,8 +21,6 @@\n     mininode_lock,\n     msg_block,\n     msg_getdata,\n-    network_thread_join,\n-    network_thread_start,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -135,9 +133,6 @@ def run_test(self):\n         # Create P2P connections to two of the nodes\n         self.nodes[0].add_p2p_connection(BaseNode())\n \n-        # Start up network handling in another thread. This needs to be called\n-        # after the P2P connections have been created.\n-        network_thread_start()\n         # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n \n@@ -189,14 +184,9 @@ def run_test(self):\n         connect_nodes(self.nodes[1], 2)\n \n         self.log.info(\"Add P2P connection to node2\")\n-        # We can't add additional P2P connections once the network thread has started. Disconnect the connection\n-        # to node0, wait for the network thread to terminate, then connect to node2. This is specific to\n-        # the current implementation of the network thread and may be improved in future.\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n \n         self.nodes[2].add_p2p_connection(BaseNode())\n-        network_thread_start()\n         self.nodes[2].p2p.wait_for_verack()\n \n         self.log.info(\"Wait for node2 reach current tip. Test that it has propagated all the blocks to us\")"
      },
      {
        "sha": "933a4740dd9bec23cfb07da9b960817ba6806757",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 12,
        "deletions": 18,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -33,16 +33,16 @@\n \n from test_framework.blocktools import (create_block, create_coinbase)\n from test_framework.key import CECKey\n-from test_framework.mininode import (CBlockHeader,\n-                                     COutPoint,\n-                                     CTransaction,\n-                                     CTxIn,\n-                                     CTxOut,\n-                                     network_thread_join,\n-                                     network_thread_start,\n-                                     P2PInterface,\n-                                     msg_block,\n-                                     msg_headers)\n+from test_framework.messages import (\n+    CBlockHeader,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+    msg_block,\n+    msg_headers\n+)\n+from test_framework.mininode import P2PInterface\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -68,12 +68,12 @@ def setup_network(self):\n     def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if p2p_conn.state != \"connected\":\n+            if not p2p_conn.is_connected:\n                 break\n             try:\n                 p2p_conn.send_message(msg_block(self.blocks[i]))\n             except IOError as e:\n-                assert str(e) == 'Not connected, no pushbuf'\n+                assert not p2p_conn.is_connected\n                 break\n \n     def assert_blockchain_height(self, node, height):\n@@ -98,8 +98,6 @@ def run_test(self):\n \n         # Connect to node0\n         p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         # Build the blockchain\n@@ -160,9 +158,7 @@ def run_test(self):\n             self.block_time += 1\n             height += 1\n \n-        # We're adding new connections so terminate the network thread\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.start_node(1, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n@@ -172,8 +168,6 @@ def run_test(self):\n         p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n         p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n \n-        network_thread_start()\n-\n         p2p0.wait_for_verack()\n         p2p1.wait_for_verack()\n         p2p2.wait_for_verack()"
      },
      {
        "sha": "62c0582381a81ac844bf65c481b6c8d882ebeeda",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -20,7 +20,7 @@\n     uint256_from_compact,\n     uint256_from_str,\n )\n-from test_framework.mininode import P2PDataStore, network_thread_start, network_thread_join\n+from test_framework.mininode import P2PDataStore\n from test_framework.script import (\n     CScript,\n     MAX_SCRIPT_ELEMENT_SIZE,\n@@ -1299,7 +1299,6 @@ def bootstrap_p2p(self):\n \n         Helper to connect and wait for version handshake.\"\"\"\n         self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         # We need to wait for the initial getheaders from the peer before we\n         # start populating our blockstore. If we don't, then we may run ahead\n         # to the next subtest before we receive the getheaders. We'd then send\n@@ -1314,7 +1313,6 @@ def reconnect_p2p(self):\n         The node gets disconnected several times in this test. This helper\n         method reconnects the p2p and restarts the network thread.\"\"\"\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         self.bootstrap_p2p()\n \n     def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True, reconnect=False, timeout=60):"
      },
      {
        "sha": "b484bffe0dca85ddd7d46179628a77ea8e76fc8d",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -67,10 +67,6 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n-\n-        # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)"
      },
      {
        "sha": "2499214fbd2b7ef4fcea2d37adab75974bdeb24c",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -49,7 +49,7 @@\n \n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.messages import ToHex, CTransaction\n-from test_framework.mininode import network_thread_start, P2PDataStore\n+from test_framework.mininode import P2PDataStore\n from test_framework.script import (\n     CScript,\n     OP_CHECKSEQUENCEVERIFY,\n@@ -183,7 +183,6 @@ def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")"
      },
      {
        "sha": "13224466d32e1d968d6c30315e35309d9375e29a",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -56,8 +56,6 @@ def set_test_params(self):\n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        network_thread_start()\n-\n         # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n "
      },
      {
        "sha": "d38275a9ca6e0846e9f5ee5cf18fa5d16fb7f465",
        "filename": "test/functional/feature_help.py",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_help.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_help.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_help.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -36,6 +36,17 @@ def run_test(self):\n         output = self.nodes[0].process.stdout.read()\n         assert b'version' in output\n         self.log.info(\"Version text received: {} (...)\".format(output[0:60]))\n+\n+        # Test that arguments not in the help results in an error\n+        self.log.info(\"Start bitcoind with -fakearg to make sure it does not start\")\n+        self.nodes[0].start(extra_args=['-fakearg'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n+        # Node should exit immediately and output an error to stderr\n+        ret_code = self.nodes[0].process.wait(timeout=1)\n+        assert_equal(ret_code, 1)\n+        output = self.nodes[0].process.stderr.read()\n+        assert b'Error parsing command line arguments' in output\n+        self.log.info(\"Error message received: {} (...)\".format(output[0:60]))\n+\n         # Clean up TestNode state\n         self.nodes[0].running = False\n         self.nodes[0].process = None"
      },
      {
        "sha": "9a7a0ca1031c4e278823082eb74cbf452d1770d4",
        "filename": "test/functional/feature_includeconf.py",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_includeconf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_includeconf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_includeconf.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -41,14 +41,9 @@ def run_test(self):\n         subversion = self.nodes[0].getnetworkinfo()[\"subversion\"]\n         assert subversion.endswith(\"main; relative)/\")\n \n-        self.log.info(\"-includeconf cannot be used as command-line arg. subversion should still end with 'main; relative)/'\")\n+        self.log.info(\"-includeconf cannot be used as command-line arg\")\n         self.stop_node(0)\n-\n-        self.start_node(0, extra_args=[\"-includeconf=relative2.conf\"])\n-\n-        subversion = self.nodes[0].getnetworkinfo()[\"subversion\"]\n-        assert subversion.endswith(\"main; relative)/\")\n-        self.stop_node(0, expected_stderr=\"warning: -includeconf cannot be used from commandline; ignoring -includeconf=relative2.conf\")\n+        self.nodes[0].assert_start_raises_init_error(extra_args=[\"-includeconf=relative2.conf\"], expected_msg=\"Error parsing command line arguments: -includeconf cannot be used from commandline; -includeconf=relative2.conf\")\n \n         self.log.info(\"-includeconf cannot be used recursively. subversion should end with 'main; relative)/'\")\n         with open(os.path.join(self.options.tmpdir, \"node0\", \"relative.conf\"), \"a\", encoding=\"utf8\") as f:\n@@ -59,8 +54,18 @@ def run_test(self):\n         assert subversion.endswith(\"main; relative)/\")\n         self.stop_node(0, expected_stderr=\"warning: -includeconf cannot be used from included files; ignoring -includeconf=relative2.conf\")\n \n+        self.log.info(\"-includeconf cannot contain invalid arg\")\n+        with open(os.path.join(self.options.tmpdir, \"node0\", \"relative.conf\"), \"w\", encoding=\"utf8\") as f:\n+            f.write(\"foo=bar\\n\")\n+        self.nodes[0].assert_start_raises_init_error(expected_msg=\"Error reading configuration file: Invalid configuration value foo\")\n+\n+        self.log.info(\"-includeconf cannot be invalid path\")\n+        os.remove(os.path.join(self.options.tmpdir, \"node0\", \"relative.conf\"))\n+        self.nodes[0].assert_start_raises_init_error(expected_msg=\"Error reading configuration file: Failed to include configuration file relative.conf\")\n+\n         self.log.info(\"multiple -includeconf args can be used from the base config file. subversion should end with 'main; relative; relative2)/'\")\n         with open(os.path.join(self.options.tmpdir, \"node0\", \"relative.conf\"), \"w\", encoding=\"utf8\") as f:\n+            # Restore initial file contents\n             f.write(\"uacomment=relative\\n\")\n \n         with open(os.path.join(self.options.tmpdir, \"node0\", \"bitcoin.conf\"), \"a\", encoding='utf8') as f:"
      },
      {
        "sha": "c413ecf70517de721be60243d539b1472780ef54",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -57,7 +57,6 @@ def run_test(self):\n         for _ in range(3):\n             p2p_conns.append(self.nodes[0].add_p2p_connection(TestP2PConn()))\n \n-        network_thread_start()\n         for p2pc in p2p_conns:\n             p2pc.wait_for_verack()\n \n@@ -148,8 +147,6 @@ def run_test(self):\n \n         # Reconnect to self.nodes[0]\n         self.nodes[0].add_p2p_connection(TestP2PConn())\n-\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit"
      },
      {
        "sha": "6d51f31e350bd390e53cbe2c00cc09cd1c3e5df0",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -36,7 +36,7 @@ def run_test(self):\n         wait_until(lambda: os.path.isfile(self.block_filename) and os.stat(self.block_filename).st_size >= (block_count * 65), timeout=10)\n \n         # file content should equal the generated blocks hashes\n-        with open(self.block_filename, 'r') as f:\n+        with open(self.block_filename, 'r', encoding=\"utf-8\") as f:\n             assert_equal(sorted(blocks), sorted(l.strip() for l in f.read().splitlines()))\n \n         self.log.info(\"test -walletnotify\")\n@@ -45,7 +45,7 @@ def run_test(self):\n \n         # file content should equal the generated transaction hashes\n         txids_rpc = list(map(lambda t: t['txid'], self.nodes[1].listtransactions(\"*\", block_count)))\n-        with open(self.tx_filename, 'r') as f:\n+        with open(self.tx_filename, 'r', encoding=\"ascii\") as f:\n             assert_equal(sorted(txids_rpc), sorted(l.strip() for l in f.read().splitlines()))\n         os.remove(self.tx_filename)\n \n@@ -58,7 +58,7 @@ def run_test(self):\n \n         # file content should equal the generated transaction hashes\n         txids_rpc = list(map(lambda t: t['txid'], self.nodes[1].listtransactions(\"*\", block_count)))\n-        with open(self.tx_filename, 'r') as f:\n+        with open(self.tx_filename, 'r', encoding=\"ascii\") as f:\n             assert_equal(sorted(txids_rpc), sorted(l.strip() for l in f.read().splitlines()))\n \n         # Mine another 41 up-version blocks. -alertnotify should trigger on the 51st."
      },
      {
        "sha": "24659eac77d7f313a95f9b8a0a4252bf14d950ad",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -15,7 +15,7 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import CTransaction, network_thread_start\n+from test_framework.messages import CTransaction\n from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n from test_framework.script import CScript\n from io import BytesIO\n@@ -42,15 +42,14 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         # This script tests NULLDUMMY activation, which is part of the 'segwit' deployment, so we go through\n         # normal segwit activation here (and don't use the default always-on behaviour).\n-        self.extra_args = [['-whitelist=127.0.0.1', '-walletprematurewitness', '-vbparams=segwit:0:999999999999', '-addresstype=legacy', \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy', \"-deprecatedrpc=addwitnessaddress\"]]\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()\n         self.ms_address = self.nodes[0].addmultisigaddress(1,[self.address])['address']\n         self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n         self.wit_ms_address = self.nodes[0].addmultisigaddress(1, [self.address], '', 'p2sh-segwit')['address']\n \n-        network_thread_start()\n         self.coinbase_blocks = self.nodes[0].generate(2) # Block 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:"
      },
      {
        "sha": "d400507a66bb411d7ebfd670b7322709f8ebc9f7",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -260,10 +260,17 @@ def has_block(index):\n         # should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n         assert_raises_rpc_error(-1, \"Blockchain is too short for pruning\", node.pruneblockchain, height(500))\n \n+        # Save block transaction count before pruning, assert value\n+        block1_details = node.getblock(node.getblockhash(1))\n+        assert_equal(block1_details[\"nTx\"], len(block1_details[\"tx\"]))\n+\n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n         node.generate(6)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n+        # Pruned block should still know the number of transactions\n+        assert_equal(node.getblockheader(node.getblockhash(1))[\"nTx\"], block1_details[\"nTx\"])\n+\n         # negative heights should raise an exception\n         assert_raises_rpc_error(-8, \"Negative\", node.pruneblockchain, -10)\n "
      },
      {
        "sha": "b10306b283fb1e2726adf442fdf3f22fd9908b75",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 13,
        "deletions": 18,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -42,9 +42,9 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n         # This test tests SegWit both pre and post-activation, so use the normal BIP9 activation.\n-        self.extra_args = [[\"-walletprematurewitness\", \"-rpcserialversion=0\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"],\n-                           [\"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-rpcserialversion=1\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"],\n-                           [\"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-rpcserialversion=0\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"],\n+                           [\"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-rpcserialversion=1\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"],\n+                           [\"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-vbparams=segwit:0:999999999999\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"]]\n \n     def setup_network(self):\n         super().setup_network()\n@@ -129,21 +129,6 @@ def run_test(self):\n         self.nodes[0].generate(260) #block 423\n         sync_blocks(self.nodes)\n \n-        self.log.info(\"Verify default node can't accept any witness format txs before fork\")\n-        # unsigned, no scriptsig\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V0][0], False)\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V1][0], False)\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False)\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False)\n-        # unsigned with redeem script\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False, witness_script(False, self.pubkey[0]))\n-        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n-        # signed\n-        self.fail_accept(self.nodes[0], \"no-witness-yet\", wit_ids[NODE_0][WIT_V0][0], True)\n-        self.fail_accept(self.nodes[0], \"no-witness-yet\", wit_ids[NODE_0][WIT_V1][0], True)\n-        self.fail_accept(self.nodes[0], \"no-witness-yet\", p2sh_ids[NODE_0][WIT_V0][0], True)\n-        self.fail_accept(self.nodes[0], \"no-witness-yet\", p2sh_ids[NODE_0][WIT_V1][0], True)\n-\n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n         self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n         self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True) #block 425\n@@ -164,6 +149,16 @@ def run_test(self):\n         segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n         assert_equal(len(segwit_tx_list), 5)\n \n+        self.log.info(\"Verify default node can't accept txs with missing witness\")\n+        # unsigned, no scriptsig\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V1][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False)\n+        # unsigned with redeem script\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False, witness_script(False, self.pubkey[0]))\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n+\n         self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n         assert(self.nodes[2].getblock(block[0], False) !=  self.nodes[0].getblock(block[0], False))\n         assert(self.nodes[1].getblock(block[0], False) ==  self.nodes[2].getblock(block[0], False))"
      },
      {
        "sha": "a03c20b088b55c6af91dfdd0e019790f44a967d3",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -12,7 +12,7 @@\n \n from test_framework.blocktools import create_block, create_coinbase\n from test_framework.messages import msg_block\n-from test_framework.mininode import P2PInterface, network_thread_start, mininode_lock\n+from test_framework.mininode import P2PInterface, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import wait_until\n \n@@ -65,7 +65,6 @@ def run_test(self):\n         # Handy alias\n         node = self.nodes[0]\n         node.add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         # Mine one period worth of blocks"
      },
      {
        "sha": "17aacd815228ceda729fe5f7c9abe24c982a81cf",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -87,7 +87,7 @@ def send_await_disconnect(self, message, timeout=30):\n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: self.state != \"connected\", timeout=timeout, lock=mininode_lock)\n+        wait_until(lambda: not self.is_connected, timeout=timeout, lock=mininode_lock)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -788,13 +788,11 @@ def announce_cmpct_block(node, peer):\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n         self.segwit_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n         self.old_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n \n-        network_thread_start()\n-\n         self.test_node.wait_for_verack()\n \n         # We will need UTXOs to construct transactions in later tests."
      },
      {
        "sha": "5b3fa0186a9f73fd1c64d4298983531b025f7de1",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -47,9 +47,8 @@ def run_test(self):\n         node1.generate(1)\n         sync_blocks(self.nodes)\n \n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         self.nodes[0].add_p2p_connection(TestP2PConn())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         # Test that invs are received for all txs at feerate of 20 sat/byte"
      },
      {
        "sha": "61f9ec014b8288ef784d7b6dd17684088ef1a952",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -18,7 +18,6 @@\n     msg_block,\n     msg_getdata,\n     msg_getheaders,\n-    network_thread_start,\n     wait_until,\n )\n from test_framework.test_framework import BitcoinTestFramework\n@@ -76,8 +75,6 @@ def last_header_equals(self, expected_hash, node):\n     # last month but that have over a month's worth of work are also withheld.\n     def run_test(self):\n         node0 = self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n         node0.wait_for_verack()\n \n         # Set node time to 60 days ago"
      },
      {
        "sha": "c9819680264b7e0c374640d353a2154802d5eb03",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -14,7 +14,7 @@\n \n from test_framework.blocktools import create_block, create_coinbase, create_transaction\n from test_framework.messages import COIN\n-from test_framework.mininode import network_thread_start, P2PDataStore\n+from test_framework.mininode import P2PDataStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n@@ -28,8 +28,6 @@ def run_test(self):\n         # Add p2p connection to node0\n         node = self.nodes[0]  # convenience reference to the node\n         node.add_p2p_connection(P2PDataStore())\n-\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         best_block = node.getblock(node.getbestblockhash())"
      },
      {
        "sha": "a7a86f89fdb3b20cd13ed81726e9a76765cf9f4f",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -13,7 +13,7 @@\n     CTxIn,\n     CTxOut,\n )\n-from test_framework.mininode import network_thread_start, P2PDataStore, network_thread_join\n+from test_framework.mininode import P2PDataStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -32,7 +32,6 @@ def bootstrap_p2p(self, *, num_connections=1):\n         Helper to connect and wait for version handshake.\"\"\"\n         for _ in range(num_connections):\n             self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n     def reconnect_p2p(self, **kwargs):\n@@ -41,7 +40,6 @@ def reconnect_p2p(self, **kwargs):\n         The node gets disconnected several times in this test. This helper\n         method reconnects the p2p and restarts the network thread.\"\"\"\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         self.bootstrap_p2p(**kwargs)\n \n     def run_test(self):\n@@ -79,7 +77,7 @@ def run_test(self):\n         self.reconnect_p2p(num_connections=2)\n \n         self.log.info('Test orphan transaction handling ... ')\n-        # Create a root transaction that we withold until all dependend transactions\n+        # Create a root transaction that we withhold until all dependend transactions\n         # are sent out and in the orphan cache\n         SCRIPT_PUB_KEY_OP_TRUE = b'\\x51\\x75' * 15 + b'\\x51'\n         tx_withhold = CTransaction()\n@@ -137,6 +135,13 @@ def run_test(self):\n         wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))\n \n+        # restart node with sending BIP61 messages disabled, check that it disconnects without sending the reject message\n+        self.log.info('Test a transaction that is rejected, with BIP61 disabled')\n+        self.restart_node(0, ['-enablebip61=0','-persistmempool=0'])\n+        self.reconnect_p2p(num_connections=1)\n+        node.p2p.send_txs_and_test([tx1], node, success=False, expect_disconnect=True)\n+        # send_txs_and_test will have waited for disconnect, so we can safely check that no reject has been received\n+        assert_equal(node.p2p.reject_code_received, None)\n \n if __name__ == '__main__':\n     InvalidTxRequestTest().main()"
      },
      {
        "sha": "ecb9a56fe13b4901512f635cb50ad3e8a927e04c",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -103,8 +103,6 @@ def run_test(self):\n         unsupported_service_bit5_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n         unsupported_service_bit7_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n-        network_thread_start()\n-\n         wait_until(lambda: no_version_bannode.ever_connected, timeout=10, lock=mininode_lock)\n         wait_until(lambda: no_version_idlenode.ever_connected, timeout=10, lock=mininode_lock)\n         wait_until(lambda: no_verack_idlenode.version_received, timeout=10, lock=mininode_lock)\n@@ -118,17 +116,16 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert no_version_bannode.state != \"connected\"\n+        assert not no_version_bannode.is_connected\n \n         # These nodes should have been disconnected\n-        assert unsupported_service_bit5_node.state != \"connected\"\n-        assert unsupported_service_bit7_node.state != \"connected\"\n+        assert not unsupported_service_bit5_node.is_connected\n+        assert not unsupported_service_bit7_node.is_connected\n \n         self.nodes[0].disconnect_p2ps()\n \n-        # Wait until all connections are closed and the network thread has terminated\n+        # Wait until all connections are closed\n         wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n-        network_thread_join()\n \n         # Make sure no unexpected messages came in\n         assert(no_version_bannode.unexpected_msg == False)\n@@ -143,11 +140,9 @@ def run_test(self):\n         allowed_service_bit5_node = self.nodes[0].add_p2p_connection(P2PInterface(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n         allowed_service_bit7_node = self.nodes[0].add_p2p_connection(P2PInterface(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n-        # Network thread stopped when all previous P2PInterfaces disconnected. Restart it\n-        network_thread_start()\n-\n         wait_until(lambda: allowed_service_bit5_node.message_count[\"verack\"], lock=mininode_lock)\n         wait_until(lambda: allowed_service_bit7_node.message_count[\"verack\"], lock=mininode_lock)\n \n+\n if __name__ == '__main__':\n     P2PLeakTest().main()"
      },
      {
        "sha": "5a1fb60fb5c241c78adf9b39b39789a46d68df41",
        "filename": "test/functional/p2p_mempool.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_mempool.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -21,7 +21,6 @@ def set_test_params(self):\n     def run_test(self):\n         # Add a p2p connection\n         self.nodes[0].add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         #request mempool"
      },
      {
        "sha": "4a24e24dafeb1c05c09171c774684841dfa7227f",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -9,7 +9,7 @@\n     - send a block within 288 + 2 of the tip\n     - disconnect peers who request blocks older than that.\"\"\"\n from test_framework.messages import CInv, msg_getdata, msg_verack\n-from test_framework.mininode import NODE_BLOOM, NODE_NETWORK_LIMITED, NODE_WITNESS, P2PInterface, wait_until, mininode_lock, network_thread_start, network_thread_join\n+from test_framework.mininode import NODE_BLOOM, NODE_NETWORK_LIMITED, NODE_WITNESS, P2PInterface, wait_until, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, disconnect_nodes, connect_nodes_bi, sync_blocks\n \n@@ -48,7 +48,6 @@ def setup_network(self):\n \n     def run_test(self):\n         node = self.nodes[0].add_p2p_connection(P2PIgnoreInv())\n-        network_thread_start()\n         node.wait_for_verack()\n \n         expected_services = NODE_BLOOM | NODE_WITNESS | NODE_NETWORK_LIMITED\n@@ -74,9 +73,7 @@ def run_test(self):\n \n         self.log.info(\"Check local address relay, do a fresh connection.\")\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         node1 = self.nodes[0].add_p2p_connection(P2PIgnoreInv())\n-        network_thread_start()\n         node1.wait_for_verack()\n         node1.send_message(msg_verack())\n "
      },
      {
        "sha": "a2b86ff82db4c3678f40d5828dbc47917b1d9174",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 86,
        "deletions": 79,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -230,55 +230,9 @@ def test_unnecessary_witness_before_segwit_activation(self):\n \n         sync_blocks(self.nodes)\n \n-        # Create a p2sh output -- this is so we can pass the standardness\n-        # rules (an anyone-can-spend OP_TRUE would be rejected, if not wrapped\n-        # in P2SH).\n-        p2sh_program = CScript([OP_TRUE])\n-        p2sh_pubkey = hash160(p2sh_program)\n-        scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n-\n-        # Now check that unnecessary witnesses can't be used to blind a node\n-        # to a transaction, eg by violating standardness checks.\n-        tx2 = CTransaction()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n-        tx2.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, False, True)\n-        self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n-\n-        # We'll add an unnecessary witness to this transaction that would cause\n-        # it to be non-standard, to test that violating policy with a witness before\n-        # segwit activation doesn't blind a node to a transaction.  Transactions\n-        # rejected for having a witness before segwit activation shouldn't be added\n-        # to the rejection cache.\n-        tx3 = CTransaction()\n-        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), CScript([p2sh_program])))\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, scriptPubKey))\n-        tx3.wit.vtxinwit.append(CTxInWitness())\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [b'a'*400000]\n-        tx3.rehash()\n-        # Note that this should be rejected for the premature witness reason,\n-        # rather than a policy check, since segwit hasn't activated yet.\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'no-witness-yet')\n-\n-        # If we send without witness, it should be accepted.\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, False, True)\n-\n-        # Now create a new anyone-can-spend utxo for the next test.\n-        tx4 = CTransaction()\n-        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), CScript([p2sh_program])))\n-        tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n-        tx4.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, False, True)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, False, True)\n-\n-        self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n-\n         # Update our utxo list; we spent the first entry.\n         self.utxo.pop(0)\n-        self.utxo.append(UTXO(tx4.sha256, 0, tx4.vout[0].nValue))\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n     # ~6 months after segwit activation, the SCRIPT_VERIFY_WITNESS flag was\n     # backdated so that it applies to all blocks, going back to the genesis\n@@ -1119,7 +1073,7 @@ def test_block_relay(self, segwit_activated):\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n \n-    # V0 segwit outputs should be standard after activation, but not before.\n+    # V0 segwit outputs and inputs are always standard. V0 segwit inputs may only be mined after activation, but not before.\n     def test_standardness_v0(self, segwit_activated):\n         self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n         assert(len(self.utxo))\n@@ -1148,45 +1102,46 @@ def test_standardness_v0(self, segwit_activated):\n         tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n         tx.vout = [CTxOut(p2sh_tx.vout[0].nValue-10000, scriptPubKey)]\n         tx.vout.append(CTxOut(8000, scriptPubKey)) # Might burn this later\n+        tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n         tx.rehash()\n \n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=segwit_activated)\n+        # This is always accepted, since the mempool policy is to consider segwit as always active\n+        # and thus allow segwit outputs\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=True)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n         scriptPubKey = CScript([OP_0, hash160(witness_hash)])\n         tx2 = CTransaction()\n-        if segwit_activated:\n-            # if tx was accepted, then we spend the second output.\n-            tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n-            tx2.vout = [CTxOut(7000, scriptPubKey)]\n-            tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n-        else:\n-            # if tx wasn't accepted, we just re-spend the p2sh output we started with.\n-            tx2.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n-            tx2.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, scriptPubKey)]\n+        # tx was accepted, so we spend the second output.\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n+        tx2.vout = [CTxOut(7000, scriptPubKey)]\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx2.rehash()\n \n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=True)\n \n         # Now update self.utxo for later tests.\n         tx3 = CTransaction()\n-        if segwit_activated:\n-            # tx and tx2 were both accepted.  Don't bother trying to reclaim the\n-            # P2PKH output; just send tx's first output back to an anyone-can-spend.\n-            sync_mempools([self.nodes[0], self.nodes[1]])\n-            tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n-            tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n-            tx3.wit.vtxinwit.append(CTxInWitness())\n-            tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n-            tx3.rehash()\n-            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n-        else:\n-            # tx and tx2 didn't go anywhere; just clean up the p2sh_tx output.\n-            tx3.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n-            tx3.vout = [CTxOut(p2sh_tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n+        # tx and tx2 were both accepted.  Don't bother trying to reclaim the\n+        # P2PKH output; just send tx's first output back to an anyone-can-spend.\n+        sync_mempools([self.nodes[0], self.nodes[1]])\n+        tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n+        tx3.wit.vtxinwit.append(CTxInWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.rehash()\n+        if not segwit_activated:\n+            # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n+            # in blocks and the tx is impossible to mine right now.\n+            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+            # Create the same output as tx3, but by replacing tx\n+            tx3_out = tx3.vout[0]\n+            tx3 = tx\n+            tx3.vout = [tx3_out]\n             tx3.rehash()\n-            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n+            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1855,6 +1810,60 @@ def test_uncompressed_pubkey(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n+    def test_non_standard_witness_blinding(self):\n+        self.log.info(\"Testing behavior of unnecessary witnesses in transactions does not blind the node for the transaction\")\n+        assert (len(self.utxo) > 0)\n+\n+        # Create a p2sh output -- this is so we can pass the standardness\n+        # rules (an anyone-can-spend OP_TRUE would be rejected, if not wrapped\n+        # in P2SH).\n+        p2sh_program = CScript([OP_TRUE])\n+        p2sh_pubkey = hash160(p2sh_program)\n+        scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+\n+        # Now check that unnecessary witnesses can't be used to blind a node\n+        # to a transaction, eg by violating standardness checks.\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, scriptPubKey))\n+        tx.rehash()\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, False, True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # We'll add an unnecessary witness to this transaction that would cause\n+        # it to be non-standard, to test that violating policy with a witness\n+        # doesn't blind a node to a transaction.  Transactions\n+        # rejected for having a witness shouldn't be added\n+        # to the rejection cache.\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), CScript([p2sh_program])))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, scriptPubKey))\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * 400]\n+        tx2.rehash()\n+        # This will be rejected due to a policy check:\n+        # No witness is allowed, since it is not a witness program but a p2sh program\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, True, False, b'bad-witness-nonstandard')\n+\n+        # If we send without witness, it should be accepted.\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, False, True)\n+\n+        # Now create a new anyone-can-spend utxo for the next test.\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), CScript([p2sh_program])))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n+        tx3.rehash()\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, False, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, False, True)\n+\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n     def test_non_standard_witness(self):\n         self.log.info(\"Testing detection of non-standard P2WSH witness\")\n         pad = chr(1).encode('latin-1')\n@@ -1955,18 +1964,15 @@ def test_non_standard_witness(self):\n \n         self.utxo.pop(0)\n \n-\n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n         self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n         self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n         # self.std_node is for testing node1 (fRequireStandard=true)\n         self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n \n-        network_thread_start()\n-\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n \n@@ -2023,6 +2029,7 @@ def run_test(self):\n         self.test_premature_coinbase_witness_spend()\n         self.test_uncompressed_pubkey()\n         self.test_signature_version_1()\n+        self.test_non_standard_witness_blinding()\n         self.test_non_standard_witness()\n         sync_blocks(self.nodes)\n         self.test_upgrade_after_activation(node_id=2)"
      },
      {
        "sha": "d40b6af2ee6a41fc83d55695b8678ca168f19fcc",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -90,7 +90,6 @@\n     CBlockHeader,\n     CInv,\n     NODE_WITNESS,\n-    network_thread_start,\n     P2PInterface,\n     mininode_lock,\n     msg_block,\n@@ -238,15 +237,11 @@ def mine_reorg(self, length):\n         return [int(x, 16) for x in all_hashes]\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         inv_node = self.nodes[0].add_p2p_connection(BaseNode())\n         # Make sure NODE_NETWORK is not set for test_node, so no block download\n         # will occur outside of direct fetching\n         test_node = self.nodes[0].add_p2p_connection(BaseNode(), services=NODE_WITNESS)\n-\n-        network_thread_start()\n-\n-        # Test logic begins here\n         inv_node.wait_for_verack()\n         test_node.wait_for_verack()\n \n@@ -288,6 +283,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         # 1. Mine a block; expect inv announcements each time\n         self.log.info(\"Part 1: headers don't start before sendheaders message...\")\n         for i in range(4):\n+            self.log.debug(\"Part 1.{}: starting...\".format(i))\n             old_tip = tip\n             tip = self.mine_blocks(1)\n             inv_node.check_last_inv_announcement(inv=[tip])\n@@ -335,11 +331,13 @@ def test_nonnull_locators(self, test_node, inv_node):\n         height = self.nodes[0].getblockcount() + 1\n         block_time += 10  # Advance far enough ahead\n         for i in range(10):\n+            self.log.debug(\"Part 2.{}: starting...\".format(i))\n             # Mine i blocks, and alternate announcing either via\n             # inv (of tip) or via headers. After each, new blocks\n             # mined by the node should successfully be announced\n             # with block header, even though the blocks are never requested\n             for j in range(2):\n+                self.log.debug(\"Part 2.{}.{}: starting...\".format(i, j))\n                 blocks = []\n                 for b in range(i + 1):\n                     blocks.append(create_block(tip, create_coinbase(height), block_time))\n@@ -386,6 +384,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         # PART 3.  Headers announcements can stop after large reorg, and resume after\n         # getheaders or inv from peer.\n         for j in range(2):\n+            self.log.debug(\"Part 3.{}: starting...\".format(j))\n             # First try mining a reorg that can propagate with header announcement\n             new_block_hashes = self.mine_reorg(length=7)\n             tip = new_block_hashes[-1]\n@@ -412,23 +411,28 @@ def test_nonnull_locators(self, test_node, inv_node):\n             test_node.wait_for_block(new_block_hashes[-1])\n \n             for i in range(3):\n+                self.log.debug(\"Part 3.{}.{}: starting...\".format(j, i))\n+\n                 # Mine another block, still should get only an inv\n                 tip = self.mine_blocks(1)\n                 inv_node.check_last_inv_announcement(inv=[tip])\n                 test_node.check_last_inv_announcement(inv=[tip])\n                 if i == 0:\n-                    self.log.debug(\"Just get the data -- shouldn't cause headers announcements to resume\")\n+                    # Just get the data -- shouldn't cause headers announcements to resume\n                     test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n                 elif i == 1:\n-                    self.log.debug(\"Send a getheaders message that shouldn't trigger headers announcements to resume (best header sent will be too old)\")\n+                    # Send a getheaders message that shouldn't trigger headers announcements\n+                    # to resume (best header sent will be too old)\n                     test_node.send_get_headers(locator=[fork_point], hashstop=new_block_hashes[1])\n                     test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n                 elif i == 2:\n+                    # This time, try sending either a getheaders to trigger resumption\n+                    # of headers announcements, or mine a new block and inv it, also\n+                    # triggering resumption of headers announcements.\n                     test_node.send_get_data([tip])\n                     test_node.wait_for_block(tip)\n-                    self.log.debug(\"This time, try sending either a getheaders to trigger resumption of headers announcements, or mine a new block and inv it, also triggering resumption of headers announcements.\")\n                     if j == 0:\n                         test_node.send_get_headers(locator=[tip], hashstop=0)\n                         test_node.sync_with_ping()\n@@ -532,6 +536,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         # First we test that receipt of an unconnecting header doesn't prevent\n         # chain sync.\n         for i in range(10):\n+            self.log.debug(\"Part 5.{}: starting...\".format(i))\n             test_node.last_message.pop(\"getdata\", None)\n             blocks = []\n             # Create two more blocks."
      },
      {
        "sha": "7a4ef1c05cc4ae0bcd4c5976b3f574ec8d081afe",
        "filename": "test/functional/p2p_timeouts.py",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_timeouts.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -38,18 +38,16 @@ def set_test_params(self):\n         self.num_nodes = 1\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         no_verack_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n         no_version_node = self.nodes[0].add_p2p_connection(TestP2PConn(), send_version=False)\n         no_send_node = self.nodes[0].add_p2p_connection(TestP2PConn(), send_version=False)\n \n-        network_thread_start()\n-\n         sleep(1)\n \n-        assert no_verack_node.connected\n-        assert no_version_node.connected\n-        assert no_send_node.connected\n+        assert no_verack_node.is_connected\n+        assert no_version_node.is_connected\n+        assert no_send_node.is_connected\n \n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n@@ -58,18 +56,18 @@ def run_test(self):\n \n         assert \"version\" in no_verack_node.last_message\n \n-        assert no_verack_node.connected\n-        assert no_version_node.connected\n-        assert no_send_node.connected\n+        assert no_verack_node.is_connected\n+        assert no_version_node.is_connected\n+        assert no_send_node.is_connected\n \n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n \n         sleep(31)\n \n-        assert not no_verack_node.connected\n-        assert not no_version_node.connected\n-        assert not no_send_node.connected\n+        assert not no_verack_node.is_connected\n+        assert not no_version_node.is_connected\n+        assert not no_send_node.is_connected\n \n if __name__ == '__main__':\n     TimeoutsTest().main()"
      },
      {
        "sha": "5f2d65c3f53ac6d9d28ac6cd1e8ef36e28417576",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -73,15 +73,11 @@ def setup_network(self):\n         self.setup_nodes()\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         # test_node connects to node0 (not whitelisted)\n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n         # min_work_node connects to node1 (whitelisted)\n         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n-\n-        # Test logic begins here\n         test_node.wait_for_verack()\n         min_work_node.wait_for_verack()\n \n@@ -204,10 +200,8 @@ def run_test(self):\n \n         self.nodes[0].disconnect_p2ps()\n         self.nodes[1].disconnect_p2ps()\n-        network_thread_join()\n \n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         test_node.wait_for_verack()\n \n         test_node.send_message(msg_block(block_h1f))\n@@ -293,8 +287,6 @@ def run_test(self):\n \n             self.nodes[0].disconnect_p2ps()\n             test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-            network_thread_start()\n             test_node.wait_for_verack()\n \n         # We should have failed reorg and switched back to 290 (but have block 291)"
      },
      {
        "sha": "155d30317a3576f675de6e4a961371d49c1ffa79",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -41,7 +41,6 @@\n )\n from test_framework.mininode import (\n     P2PInterface,\n-    network_thread_start,\n )\n \n \n@@ -217,6 +216,7 @@ def _test_getblockheader(self):\n         assert_equal(header['confirmations'], 1)\n         assert_equal(header['previousblockhash'], secondbesthash)\n         assert_is_hex_string(header['chainwork'])\n+        assert_equal(header['nTx'], 1)\n         assert_is_hash_string(header['hash'])\n         assert_is_hash_string(header['previousblockhash'])\n         assert_is_hash_string(header['merkleroot'])\n@@ -261,7 +261,6 @@ def _test_waitforblockheight(self):\n \n         # Start a P2P connection since we'll need to create some blocks.\n         node.add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         current_height = node.getblock(node.getbestblockhash())['height']"
      },
      {
        "sha": "bc27c183b126c2c3bec7fbba2ee2a024733a9500",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -40,7 +40,6 @@ def run_test(self):\n         #\n         # The following 'label' RPC methods are usable both with and without the\n         # -deprecatedrpc=accounts switch enabled.\n-        # - getlabeladdress\n         # - getaddressesbylabel\n         # - getreceivedbylabel\n         # - listlabels\n@@ -69,10 +68,6 @@ def run_test(self):\n         assert_raises_rpc_error(-32, \"getaccountaddress is deprecated\", self.nodes[0].getaccountaddress, \"label0\")\n         self.nodes[1].getaccountaddress(\"label1\")\n \n-        self.log.info(\"- getlabeladdress\")\n-        self.nodes[0].getlabeladdress(\"label0\")\n-        self.nodes[1].getlabeladdress(\"label1\")\n-\n         self.log.info(\"- getaddressesbyaccount\")\n         assert_raises_rpc_error(-32, \"getaddressesbyaccount is deprecated\", self.nodes[0].getaddressesbyaccount, \"label0\")\n         self.nodes[1].getaddressesbyaccount(\"label1\")"
      },
      {
        "sha": "f573faaf177b8a26b5b65cfd1eb21606bd870eac",
        "filename": "test/functional/rpc_getblockstats.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_getblockstats.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/rpc_getblockstats.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockstats.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -81,11 +81,11 @@ def generate_test_data(self, filename):\n             'mocktime': int(mocktime),\n             'stats': self.expected_stats,\n         }\n-        with open(filename, 'w') as f:\n+        with open(filename, 'w', encoding=\"utf8\") as f:\n             json.dump(to_dump, f, sort_keys=True, indent=2)\n \n     def load_test_data(self, filename):\n-        with open(filename, 'r') as f:\n+        with open(filename, 'r', encoding=\"utf8\") as f:\n             d = json.load(f)\n             blocks = d['blocks']\n             mocktime = d['mocktime']"
      },
      {
        "sha": "29bf33fa5bec20c45c576aa1a96ab280bd23db83",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 72,
        "deletions": 128,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -13,11 +13,10 @@\n P2PInterface: A high-level interface object for communicating to a node over P2P\n P2PDataStore: A p2p interface class that keeps a store of transactions and blocks\n               and can respond correctly to getdata and getheaders messages\"\"\"\n-import asyncore\n+import asyncio\n from collections import defaultdict\n from io import BytesIO\n import logging\n-import socket\n import struct\n import sys\n import threading\n@@ -57,7 +56,8 @@\n     \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n }\n \n-class P2PConnection(asyncore.dispatcher):\n+\n+class P2PConnection(asyncio.Protocol):\n     \"\"\"A low-level connection object to a node's P2P interface.\n \n     This class is responsible for:\n@@ -71,68 +71,59 @@ class P2PConnection(asyncore.dispatcher):\n     sub-classed and the on_message() callback overridden.\"\"\"\n \n     def __init__(self):\n-        # All P2PConnections must be created before starting the NetworkThread.\n-        # assert that the network thread is not running.\n-        assert not network_thread_running()\n+        # The underlying transport of the connection.\n+        # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n+        self._transport = None\n \n-        super().__init__(map=mininode_socket_map)\n+    @property\n+    def is_connected(self):\n+        return self._transport is not None\n \n     def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n+        assert not self.is_connected\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n-        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n-        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n-        self.sendbuf = b\"\"\n+        # The initial message to send after the connection was made:\n+        self.on_connection_send_msg = None\n         self.recvbuf = b\"\"\n-        self.state = \"connecting\"\n         self.network = net\n-        self.disconnect = False\n-\n         logger.debug('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n-        try:\n-            self.connect((dstaddr, dstport))\n-        except:\n-            self.handle_close()\n+        loop = NetworkThread.network_event_loop\n+        conn_gen_unsafe = loop.create_connection(lambda: self, host=self.dstaddr, port=self.dstport)\n+        conn_gen = lambda: loop.call_soon_threadsafe(loop.create_task, conn_gen_unsafe)\n+        return conn_gen\n \n     def peer_disconnect(self):\n         # Connection could have already been closed by other end.\n-        if self.state == \"connected\":\n-            self.disconnect_node()\n+        NetworkThread.network_event_loop.call_soon_threadsafe(lambda: self._transport and self._transport.abort())\n \n     # Connection and disconnection methods\n \n-    def handle_connect(self):\n-        \"\"\"asyncore callback when a connection is opened.\"\"\"\n-        if self.state != \"connected\":\n-            logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n-            self.state = \"connected\"\n-            self.on_open()\n-\n-    def handle_close(self):\n-        \"\"\"asyncore callback when a connection is closed.\"\"\"\n-        logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n-        self.state = \"closed\"\n+    def connection_made(self, transport):\n+        \"\"\"asyncio callback when a connection is opened.\"\"\"\n+        assert not self._transport\n+        logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n+        self._transport = transport\n+        if self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None  # Never used again\n+        self.on_open()\n+\n+    def connection_lost(self, exc):\n+        \"\"\"asyncio callback when a connection is closed.\"\"\"\n+        if exc:\n+            logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n+        else:\n+            logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n+        self._transport = None\n         self.recvbuf = b\"\"\n-        self.sendbuf = b\"\"\n-        try:\n-            self.close()\n-        except:\n-            pass\n         self.on_close()\n \n-    def disconnect_node(self):\n-        \"\"\"Disconnect the p2p connection.\n-\n-        Called by the test logic thread. Causes the p2p connection\n-        to be disconnected on the next iteration of the asyncore loop.\"\"\"\n-        self.disconnect = True\n-\n     # Socket read methods\n \n-    def handle_read(self):\n-        \"\"\"asyncore callback when data is read from the socket.\"\"\"\n-        t = self.recv(8192)\n+    def data_received(self, t):\n+        \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n             self._on_data()\n@@ -179,39 +170,21 @@ def on_message(self, message):\n \n     # Socket write methods\n \n-    def writable(self):\n-        \"\"\"asyncore method to determine whether the handle_write() callback should be called on the next loop.\"\"\"\n-        with mininode_lock:\n-            pre_connection = self.state == \"connecting\"\n-            length = len(self.sendbuf)\n-        return (length > 0 or pre_connection)\n-\n-    def handle_write(self):\n-        \"\"\"asyncore callback when data should be written to the socket.\"\"\"\n-        with mininode_lock:\n-            # asyncore does not expose socket connection, only the first read/write\n-            # event, thus we must check connection manually here to know when we\n-            # actually connect\n-            if self.state == \"connecting\":\n-                self.handle_connect()\n-            if not self.writable():\n-                return\n-\n-            try:\n-                sent = self.send(self.sendbuf)\n-            except:\n-                self.handle_close()\n-                return\n-            self.sendbuf = self.sendbuf[sent:]\n-\n-    def send_message(self, message, pushbuf=False):\n+    def send_message(self, message):\n         \"\"\"Send a P2P message over the socket.\n \n         This method takes a P2P payload, builds the P2P header and adds\n         the message to the send buffer to be sent over the socket.\"\"\"\n-        if self.state != \"connected\" and not pushbuf:\n-            raise IOError('Not connected, no pushbuf')\n+        if not self.is_connected:\n+            raise IOError('Not connected')\n         self._log_message(\"send\", message)\n+        tmsg = self._build_message(message)\n+        NetworkThread.network_event_loop.call_soon_threadsafe(lambda: self._transport and self._transport.write(tmsg))\n+\n+    # Class utility methods\n+\n+    def _build_message(self, message):\n+        \"\"\"Build a serialized P2P message\"\"\"\n         command = message.command\n         data = message.serialize()\n         tmsg = MAGIC_BYTES[self.network]\n@@ -222,17 +195,7 @@ def send_message(self, message, pushbuf=False):\n         h = sha256(th)\n         tmsg += h[:4]\n         tmsg += data\n-        with mininode_lock:\n-            if (len(self.sendbuf) == 0 and not pushbuf):\n-                try:\n-                    sent = self.send(tmsg)\n-                    self.sendbuf = tmsg[sent:]\n-                except BlockingIOError:\n-                    self.sendbuf = tmsg\n-            else:\n-                self.sendbuf += tmsg\n-\n-    # Class utility methods\n+        return tmsg\n \n     def _log_message(self, direction, msg):\n         \"\"\"Logs a message being sent or received over the connection.\"\"\"\n@@ -270,7 +233,7 @@ def __init__(self):\n         self.nServices = 0\n \n     def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=True, **kwargs):\n-        super().peer_connect(*args, **kwargs)\n+        create_conn = super().peer_connect(*args, **kwargs)\n \n         if send_version:\n             # Send a version msg\n@@ -280,7 +243,9 @@ def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=T\n             vt.addrTo.port = self.dstport\n             vt.addrFrom.ip = \"0.0.0.0\"\n             vt.addrFrom.port = 0\n-            self.send_message(vt, True)\n+            self.on_connection_send_msg = vt  # Will be sent soon after connection_made\n+\n+        return create_conn\n \n     # Message receiving methods\n \n@@ -348,7 +313,7 @@ def on_version(self, message):\n     # Connection helper methods\n \n     def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: self.state != \"connected\"\n+        test_function = lambda: not self.is_connected\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message receiving helper methods\n@@ -404,56 +369,35 @@ def sync_with_ping(self, timeout=60):\n         self.ping_counter += 1\n \n \n-# Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to work around an issue with closing an asyncore socket when\n-# using select)\n-mininode_socket_map = dict()\n-\n-# One lock for synchronizing all data access between the networking thread (see\n+# One lock for synchronizing all data access between the network event loop (see\n # NetworkThread below) and the thread running the test logic.  For simplicity,\n-# P2PConnection acquires this lock whenever delivering a message to a P2PInterface,\n-# and whenever adding anything to the send buffer (in send_message()).  This\n-# lock should be acquired in the thread running the test logic to synchronize\n+# P2PConnection acquires this lock whenever delivering a message to a P2PInterface.\n+# This lock should be acquired in the thread running the test logic to synchronize\n # access to any data shared with the P2PInterface or P2PConnection.\n mininode_lock = threading.RLock()\n \n+\n class NetworkThread(threading.Thread):\n+    network_event_loop = None\n+\n     def __init__(self):\n         super().__init__(name=\"NetworkThread\")\n+        # There is only one event loop and no more than one thread must be created\n+        assert not self.network_event_loop\n+\n+        NetworkThread.network_event_loop = asyncio.new_event_loop()\n \n     def run(self):\n-        while mininode_socket_map:\n-            # We check for whether to disconnect outside of the asyncore\n-            # loop to work around the behavior of asyncore when using\n-            # select\n-            disconnected = []\n-            for fd, obj in mininode_socket_map.items():\n-                if obj.disconnect:\n-                    disconnected.append(obj)\n-            [obj.handle_close() for obj in disconnected]\n-            asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n-        logger.debug(\"Network thread closing\")\n-\n-def network_thread_start():\n-    \"\"\"Start the network thread.\"\"\"\n-    # Only one network thread may run at a time\n-    assert not network_thread_running()\n-\n-    NetworkThread().start()\n-\n-def network_thread_running():\n-    \"\"\"Return whether the network thread is running.\"\"\"\n-    return any([thread.name == \"NetworkThread\" for thread in threading.enumerate()])\n-\n-def network_thread_join(timeout=10):\n-    \"\"\"Wait timeout seconds for the network thread to terminate.\n-\n-    Throw if the network thread doesn't terminate in timeout seconds.\"\"\"\n-    network_threads = [thread for thread in threading.enumerate() if thread.name == \"NetworkThread\"]\n-    assert len(network_threads) <= 1\n-    for thread in network_threads:\n-        thread.join(timeout)\n-        assert not thread.is_alive()\n+        \"\"\"Start the network thread.\"\"\"\n+        self.network_event_loop.run_forever()\n+\n+    def close(self, timeout=10):\n+        \"\"\"Close the connections and network event loop.\"\"\"\n+        self.network_event_loop.call_soon_threadsafe(self.network_event_loop.stop)\n+        wait_until(lambda: not self.network_event_loop.is_running(), timeout=timeout)\n+        self.network_event_loop.close()\n+        self.join(timeout)\n+\n \n class P2PDataStore(P2PInterface):\n     \"\"\"A P2P data store class."
      },
      {
        "sha": "abe8d12e59613d5cc6c5e006fc01aea9355dc220",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -18,6 +18,7 @@\n from .authproxy import JSONRPCException\n from . import coverage\n from .test_node import TestNode\n+from .mininode import NetworkThread\n from .util import (\n     MAX_NODES,\n     PortSeed,\n@@ -83,6 +84,7 @@ def __init__(self):\n         \"\"\"Sets test framework defaults. Do not override this method. Instead, override the set_test_params() method\"\"\"\n         self.setup_clean_chain = False\n         self.nodes = []\n+        self.network_thread = None\n         self.mocktime = 0\n         self.supports_cli = False\n         self.bind_to_localhost_only = True\n@@ -130,9 +132,11 @@ def main(self):\n         self.options.bitcoind = os.getenv(\"BITCOIND\", default=config[\"environment\"][\"BUILDDIR\"] + '/src/bitcoind' + config[\"environment\"][\"EXEEXT\"])\n         self.options.bitcoincli = os.getenv(\"BITCOINCLI\", default=config[\"environment\"][\"BUILDDIR\"] + '/src/bitcoin-cli' + config[\"environment\"][\"EXEEXT\"])\n \n-        os.environ['PATH'] = config['environment']['BUILDDIR'] + os.pathsep + \\\n-                             config['environment']['BUILDDIR'] + os.path.sep + \"qt\" + os.pathsep + \\\n-                             os.environ['PATH']\n+        os.environ['PATH'] = os.pathsep.join([\n+            os.path.join(config['environment']['BUILDDIR'], 'src'),\n+            os.path.join(config['environment']['BUILDDIR'], 'src', 'qt'),\n+            os.environ['PATH']\n+        ])\n \n         # Set up temp directory and start logging\n         if self.options.tmpdir:\n@@ -142,6 +146,10 @@ def main(self):\n             self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")\n         self._start_logging()\n \n+        self.log.debug('Setting up network thread')\n+        self.network_thread = NetworkThread()\n+        self.network_thread.start()\n+\n         success = TestStatus.FAILED\n \n         try:\n@@ -169,6 +177,8 @@ def main(self):\n             print(\"Testcase failed. Attaching python debugger. Enter ? for help\")\n             pdb.set_trace()\n \n+        self.log.debug('Closing down network thread')\n+        self.network_thread.close()\n         if not self.options.noshutdown:\n             self.log.info(\"Stopping nodes\")\n             if self.nodes:\n@@ -357,7 +367,7 @@ def _start_logging(self):\n         self.log = logging.getLogger('TestFramework')\n         self.log.setLevel(logging.DEBUG)\n         # Create file handler to log all messages\n-        fh = logging.FileHandler(self.options.tmpdir + '/test_framework.log')\n+        fh = logging.FileHandler(self.options.tmpdir + '/test_framework.log', encoding='utf-8')\n         fh.setLevel(logging.DEBUG)\n         # Create console handler to log messages to stderr. By default this logs only error messages, but can be configured with --loglevel.\n         ch = logging.StreamHandler(sys.stdout)"
      },
      {
        "sha": "287dc0e53e0b9918e159c2e76377d1fdbd8ebef5",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -289,7 +289,7 @@ def add_p2p_connection(self, p2p_conn, *args, **kwargs):\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n-        p2p_conn.peer_connect(*args, **kwargs)\n+        p2p_conn.peer_connect(*args, **kwargs)()\n         self.p2ps.append(p2p_conn)\n \n         return p2p_conn\n@@ -343,10 +343,10 @@ def __getattr__(self, command):\n     def batch(self, requests):\n         results = []\n         for request in requests:\n-           try:\n-               results.append(dict(result=request()))\n-           except JSONRPCException as e:\n-               results.append(dict(error=e))\n+            try:\n+                results.append(dict(result=request()))\n+            except JSONRPCException as e:\n+                results.append(dict(error=e))\n         return results\n \n     def send_cli(self, command=None, *args, **kwargs):"
      },
      {
        "sha": "5e0b61b5e7861faaf29d308dc2908af3af761806",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -327,7 +327,7 @@ def get_auth_cookie(datadir):\n                     assert password is None  # Ensure that there is only one rpcpassword line\n                     password = line.split(\"=\")[1].strip(\"\\n\")\n     if os.path.isfile(os.path.join(datadir, \"regtest\", \".cookie\")):\n-        with open(os.path.join(datadir, \"regtest\", \".cookie\"), 'r') as f:\n+        with open(os.path.join(datadir, \"regtest\", \".cookie\"), 'r', encoding=\"ascii\") as f:\n             userpass = f.read()\n             split_userpass = userpass.split(':')\n             user = split_userpass[0]"
      },
      {
        "sha": "36101d9f573861d23a26d6b298e26b5998114787",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -213,7 +213,7 @@ def main():\n     # Read config generated by configure.\n     config = configparser.ConfigParser()\n     configfile = os.path.abspath(os.path.dirname(__file__)) + \"/../config.ini\"\n-    config.read_file(open(configfile))\n+    config.read_file(open(configfile, encoding=\"utf8\"))\n \n     passon_args.append(\"--configfile=%s\" % configfile)\n \n@@ -419,18 +419,14 @@ def __init__(self, num_tests_parallel, tests_dir, tmpdir, test_list=None, flags=\n         self.test_list = test_list\n         self.flags = flags\n         self.num_running = 0\n-        # In case there is a graveyard of zombie bitcoinds, we can apply a\n-        # pseudorandom offset to hopefully jump over them.\n-        # (625 is PORT_RANGE/MAX_NODES)\n-        self.portseed_offset = int(time.time() * 1000) % 625\n         self.jobs = []\n \n     def get_next(self):\n         while self.num_running < self.num_jobs and self.test_list:\n             # Add tests\n             self.num_running += 1\n             test = self.test_list.pop(0)\n-            portseed = len(self.test_list) + self.portseed_offset\n+            portseed = len(self.test_list)\n             portseed_arg = [\"--portseed={}\".format(portseed)]\n             log_stdout = tempfile.SpooledTemporaryFile(max_size=2**16)\n             log_stderr = tempfile.SpooledTemporaryFile(max_size=2**16)\n@@ -594,7 +590,7 @@ def _get_uncovered_rpc_commands(self):\n         if not os.path.isfile(coverage_ref_filename):\n             raise RuntimeError(\"No coverage reference found\")\n \n-        with open(coverage_ref_filename, 'r') as coverage_ref_file:\n+        with open(coverage_ref_filename, 'r', encoding=\"utf8\") as coverage_ref_file:\n             all_cmds.update([line.strip() for line in coverage_ref_file.readlines()])\n \n         for root, dirs, files in os.walk(self.dir):\n@@ -603,7 +599,7 @@ def _get_uncovered_rpc_commands(self):\n                     coverage_filenames.add(os.path.join(root, filename))\n \n         for filename in coverage_filenames:\n-            with open(filename, 'r') as coverage_file:\n+            with open(filename, 'r', encoding=\"utf8\") as coverage_file:\n                 covered_cmds.update([line.strip() for line in coverage_file.readlines()])\n \n         return all_cmds - covered_cmds"
      },
      {
        "sha": "0353905142b636090216520f6fd7f42f5473f6d0",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -129,6 +129,15 @@ def run_test(self):\n                                 self.nodes[2].lockunspent, False,\n                                 [{\"txid\": unspent_0[\"txid\"], \"vout\": 999}])\n \n+        # An output should be unlocked when spent\n+        unspent_0 = self.nodes[1].listunspent()[0]\n+        self.nodes[1].lockunspent(False, [unspent_0])\n+        tx = self.nodes[1].createrawtransaction([unspent_0], { self.nodes[1].getnewaddress() : 1 })\n+        tx = self.nodes[1].fundrawtransaction(tx)['hex']\n+        tx = self.nodes[1].signrawtransactionwithwallet(tx)[\"hex\"]\n+        self.nodes[1].sendrawtransaction(tx)\n+        assert_equal(len(self.nodes[1].listlockunspent()), 0)\n+\n         # Have node1 generate 100 blocks (so node0 can recover the fee)\n         self.nodes[1].generate(100)\n         self.sync_all([self.nodes[0:3]])\n@@ -230,8 +239,8 @@ def run_test(self):\n         # 2. hex-changed one output to 0.0\n         # 3. sign and send\n         # 4. check if recipient (node0) can list the zero value tx\n-        usp = self.nodes[1].listunspent()\n-        inputs = [{\"txid\": usp[0]['txid'], \"vout\": usp[0]['vout']}]\n+        usp = self.nodes[1].listunspent(query_options={'minimumAmount': '49.998'})[0]\n+        inputs = [{\"txid\": usp['txid'], \"vout\": usp['vout']}]\n         outputs = {self.nodes[1].getnewaddress(): 49.998, self.nodes[0].getnewaddress(): 11.11}\n \n         raw_tx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\")  # replace 11.11 with 0.0 (int32)"
      },
      {
        "sha": "f07041706a475a69ccc91cd9114633fb844e8a8d",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -31,7 +31,7 @@ class BumpFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n-        self.extra_args = [[\"-prematurewitness\", \"-walletprematurewitness\", \"-deprecatedrpc=addwitnessaddress\", \"-walletrbf={}\".format(i)]\n+        self.extra_args = [[\"-deprecatedrpc=addwitnessaddress\", \"-walletrbf={}\".format(i)]\n                            for i in range(self.num_nodes)]\n \n     def run_test(self):"
      },
      {
        "sha": "cc0a5175d54be15a274c5a7ac4d65ce6eee6c493",
        "filename": "test/functional/wallet_fallbackfee.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_fallbackfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_fallbackfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_fallbackfee.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -21,7 +21,6 @@ def run_test(self):\n         self.restart_node(0, extra_args=[\"-fallbackfee=0\"])\n         assert_raises_rpc_error(-4, \"Fee estimation failed\", lambda: self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1))\n         assert_raises_rpc_error(-4, \"Fee estimation failed\", lambda: self.nodes[0].fundrawtransaction(self.nodes[0].createrawtransaction([], {self.nodes[0].getnewaddress(): 1})))\n-        assert_raises_rpc_error(-4, \"Fee estimation failed\", lambda: self.nodes[0].sendfrom(\"\", self.nodes[0].getnewaddress(), 1))\n         assert_raises_rpc_error(-6, \"Fee estimation failed\", lambda: self.nodes[0].sendmany(\"\", {self.nodes[0].getnewaddress(): 1}))\n \n if __name__ == '__main__':"
      },
      {
        "sha": "8d961fb34aeb0e0267b9774c8953fee95e77e034",
        "filename": "test/functional/wallet_labels.py",
        "status": "modified",
        "additions": 55,
        "deletions": 32,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_labels.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_labels.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_labels.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test label RPCs.\n \n RPCs tested are:\n-    - getlabeladdress\n+    - getaccountaddress\n     - getaddressesbyaccount/getaddressesbylabel\n     - listaddressgroupings\n     - setlabel\n@@ -85,24 +85,32 @@ def _run_subtest(self, accounts_api, node):\n         # we want to reset so that the \"\" label has what's expected.\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n-        node.sendfrom(\"\", common_address, fee)\n+        if accounts_api:\n+            node.sendfrom(\"\", common_address, fee)\n         amount_to_send = 1.0\n \n         # Create labels and make sure subsequent label API calls\n         # recognize the label/address associations.\n         labels = [Label(name, accounts_api) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n         for label in labels:\n-            label.add_receive_address(node.getlabeladdress(label=label.name, force=True))\n+            if accounts_api:\n+                address = node.getaccountaddress(label.name)\n+            else:\n+                address = node.getnewaddress(label.name)\n+            label.add_receive_address(address)\n             label.verify(node)\n \n         # Check all labels are returned by listlabels.\n         assert_equal(node.listlabels(), [label.name for label in labels])\n \n         # Send a transaction to each label, and make sure this forces\n-        # getlabeladdress to generate a new receiving address.\n+        # getaccountaddress to generate a new receiving address.\n         for label in labels:\n-            node.sendtoaddress(label.receive_address, amount_to_send)\n-            label.add_receive_address(node.getlabeladdress(label.name))\n+            if accounts_api:\n+                node.sendtoaddress(label.receive_address, amount_to_send)\n+                label.add_receive_address(node.getaccountaddress(label.name))\n+            else:\n+                node.sendtoaddress(label.addresses[0], amount_to_send)\n             label.verify(node)\n \n         # Check the amounts received.\n@@ -115,10 +123,17 @@ def _run_subtest(self, accounts_api, node):\n         # Check that sendfrom label reduces listaccounts balances.\n         for i, label in enumerate(labels):\n             to_label = labels[(i + 1) % len(labels)]\n-            node.sendfrom(label.name, to_label.receive_address, amount_to_send)\n+            if accounts_api:\n+                node.sendfrom(label.name, to_label.receive_address, amount_to_send)\n+            else:\n+                node.sendtoaddress(to_label.addresses[0], amount_to_send)\n         node.generate(1)\n         for label in labels:\n-            label.add_receive_address(node.getlabeladdress(label.name))\n+            if accounts_api:\n+                address = node.getaccountaddress(label.name)\n+            else:\n+                address = node.getnewaddress(label.name)\n+            label.add_receive_address(address)\n             label.verify(node)\n             assert_equal(node.getreceivedbylabel(label.name), 2)\n             if accounts_api:\n@@ -134,12 +149,12 @@ def _run_subtest(self, accounts_api, node):\n \n         # Check that setlabel can assign a label to a new unused address.\n         for label in labels:\n-            address = node.getlabeladdress(label=\"\", force=True)\n+            address = node.getnewaddress()\n             node.setlabel(address, label.name)\n             label.add_address(address)\n             label.verify(node)\n             if accounts_api:\n-                assert(address not in node.getaddressesbyaccount(\"\"))\n+                assert address not in node.getaddressesbyaccount(\"\")\n             else:\n                 assert_raises_rpc_error(-11, \"No addresses with label\", node.getaddressesbylabel, \"\")\n \n@@ -152,27 +167,29 @@ def _run_subtest(self, accounts_api, node):\n             label.add_address(multisig_address)\n             label.purpose[multisig_address] = \"send\"\n             label.verify(node)\n-            node.sendfrom(\"\", multisig_address, 50)\n+            if accounts_api:\n+                node.sendfrom(\"\", multisig_address, 50)\n         node.generate(101)\n         if accounts_api:\n             for label in labels:\n                 assert_equal(node.getbalance(label.name), 50)\n \n         # Check that setlabel can change the label of an address from a\n         # different label.\n-        change_label(node, labels[0].addresses[0], labels[0], labels[1])\n-\n-        # Check that setlabel can change the label of an address which\n-        # is the receiving address of a different label.\n-        change_label(node, labels[0].receive_address, labels[0], labels[1])\n+        change_label(node, labels[0].addresses[0], labels[0], labels[1], accounts_api)\n \n         # Check that setlabel can set the label of an address already\n         # in the label. This is a no-op.\n-        change_label(node, labels[2].addresses[0], labels[2], labels[2])\n+        change_label(node, labels[2].addresses[0], labels[2], labels[2], accounts_api)\n \n-        # Check that setlabel can set the label of an address which is\n-        # already the receiving address of the label. This is a no-op.\n-        change_label(node, labels[2].receive_address, labels[2], labels[2])\n+        if accounts_api:\n+            # Check that setaccount can change the label of an address which\n+            # is the receiving address of a different label.\n+            change_label(node, labels[0].receive_address, labels[0], labels[1], accounts_api)\n+\n+            # Check that setaccount can set the label of an address which is\n+            # already the receiving address of the label. This is a no-op.\n+            change_label(node, labels[2].receive_address, labels[2], labels[2], accounts_api)\n \n class Label:\n     def __init__(self, name, accounts_api):\n@@ -192,12 +209,14 @@ def add_address(self, address):\n \n     def add_receive_address(self, address):\n         self.add_address(address)\n-        self.receive_address = address\n+        if self.accounts_api:\n+            self.receive_address = address\n \n     def verify(self, node):\n         if self.receive_address is not None:\n             assert self.receive_address in self.addresses\n-            assert_equal(node.getlabeladdress(self.name), self.receive_address)\n+            if self.accounts_api:\n+                assert_equal(node.getaccountaddress(self.name), self.receive_address)\n \n         for address in self.addresses:\n             assert_equal(\n@@ -216,22 +235,26 @@ def verify(self, node):\n             assert_equal(set(node.getaddressesbyaccount(self.name)), set(self.addresses))\n \n \n-def change_label(node, address, old_label, new_label):\n+def change_label(node, address, old_label, new_label, accounts_api):\n     assert_equal(address in old_label.addresses, True)\n-    node.setlabel(address, new_label.name)\n+    if accounts_api:\n+        node.setaccount(address, new_label.name)\n+    else:\n+        node.setlabel(address, new_label.name)\n \n     old_label.addresses.remove(address)\n     new_label.add_address(address)\n \n-    # Calling setlabel on an address which was previously the receiving\n-    # address of a different label should reset the receiving address of\n-    # the old label, causing getlabeladdress to return a brand new\n+    # Calling setaccount on an address which was previously the receiving\n+    # address of a different account should reset the receiving address of\n+    # the old account, causing getaccountaddress to return a brand new\n     # address.\n-    if old_label.name != new_label.name and address == old_label.receive_address:\n-        new_address = node.getlabeladdress(old_label.name)\n-        assert_equal(new_address not in old_label.addresses, True)\n-        assert_equal(new_address not in new_label.addresses, True)\n-        old_label.add_receive_address(new_address)\n+    if accounts_api:\n+        if old_label.name != new_label.name and address == old_label.receive_address:\n+            new_address = node.getaccountaddress(old_label.name)\n+            assert_equal(new_address not in old_label.addresses, True)\n+            assert_equal(new_address not in new_label.addresses, True)\n+            old_label.add_receive_address(new_address)\n \n     old_label.verify(node)\n     new_label.verify(node)"
      },
      {
        "sha": "e9912f994e7fa61cb8940e9a918ff13907e1ff02",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,10 +6,13 @@\n from decimal import Decimal\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_array_result,\n-                                 assert_equal,\n-                                 assert_raises_rpc_error,\n-                                 )\n+from test_framework.util import (\n+    assert_array_result,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+    sync_blocks,\n+)\n+\n \n class ReceivedByTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -18,6 +21,7 @@ def set_test_params(self):\n     def run_test(self):\n         # Generate block to get out of IBD\n         self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n \n         self.log.info(\"listreceivedbyaddress Test\")\n "
      },
      {
        "sha": "3cefd83459dd97937c8b6cd47514da545390b7a7",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 51,
        "deletions": 1,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -88,7 +88,7 @@ def run_test(self):\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=bad'], 'Error: Specified -walletdir \"bad\" does not exist')\n         # should not initialize if the specified walletdir is not a directory\n         not_a_dir = wallet_dir('notadir')\n-        open(not_a_dir, 'a').close()\n+        open(not_a_dir, 'a', encoding=\"utf8\").close()\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=' + not_a_dir], 'Error: Specified -walletdir \"' + not_a_dir + '\" is not a directory')\n \n         self.log.info(\"Do not allow -zapwallettxes with multiwallet\")\n@@ -211,5 +211,55 @@ def run_test(self):\n         # Fail to load if wallet file is a symlink\n         assert_raises_rpc_error(-4, \"Wallet file verification failed: Invalid -wallet path 'w8_symlink'\", self.nodes[0].loadwallet, 'w8_symlink')\n \n+        self.log.info(\"Test dynamic wallet creation.\")\n+\n+        # Fail to create a wallet if it already exists.\n+        assert_raises_rpc_error(-4, \"Wallet w2 already exists.\", self.nodes[0].createwallet, 'w2')\n+\n+        # Successfully create a wallet with a new name\n+        loadwallet_name = self.nodes[0].createwallet('w9')\n+        assert_equal(loadwallet_name['name'], 'w9')\n+        w9 = node.get_wallet_rpc('w9')\n+        assert_equal(w9.getwalletinfo()['walletname'], 'w9')\n+\n+        assert 'w9' in self.nodes[0].listwallets()\n+\n+        # Successfully create a wallet using a full path\n+        new_wallet_dir = os.path.join(self.options.tmpdir, 'new_walletdir')\n+        new_wallet_name = os.path.join(new_wallet_dir, 'w10')\n+        loadwallet_name = self.nodes[0].createwallet(new_wallet_name)\n+        assert_equal(loadwallet_name['name'], new_wallet_name)\n+        w10 = node.get_wallet_rpc(new_wallet_name)\n+        assert_equal(w10.getwalletinfo()['walletname'], new_wallet_name)\n+\n+        assert new_wallet_name in self.nodes[0].listwallets()\n+\n+        self.log.info(\"Test dynamic wallet unloading\")\n+\n+        # Test `unloadwallet` errors\n+        assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].unloadwallet)\n+        assert_raises_rpc_error(-18, \"Requested wallet does not exist or is not loaded\", self.nodes[0].unloadwallet, \"dummy\")\n+        assert_raises_rpc_error(-18, \"Requested wallet does not exist or is not loaded\", node.get_wallet_rpc(\"dummy\").unloadwallet)\n+        assert_raises_rpc_error(-8, \"Cannot unload the requested wallet\", w1.unloadwallet, \"w2\"),\n+\n+        # Successfully unload the specified wallet name\n+        self.nodes[0].unloadwallet(\"w1\")\n+        assert 'w1' not in self.nodes[0].listwallets()\n+\n+        # Successfully unload the wallet referenced by the request endpoint\n+        w2.unloadwallet()\n+        assert 'w2' not in self.nodes[0].listwallets()\n+\n+        # Successfully unload all wallets\n+        for wallet_name in self.nodes[0].listwallets():\n+            self.nodes[0].unloadwallet(wallet_name)\n+        assert_equal(self.nodes[0].listwallets(), [])\n+        assert_raises_rpc_error(-32601, \"Method not found (wallet method is disabled because no wallet is loaded)\", self.nodes[0].getwalletinfo)\n+\n+        # Successfully load a previously unloaded wallet\n+        self.nodes[0].loadwallet('w1')\n+        assert_equal(self.nodes[0].listwallets(), ['w1'])\n+        assert_equal(w1.getwalletinfo()['walletname'], 'w1')\n+\n if __name__ == '__main__':\n     MultiWalletTest().main()"
      },
      {
        "sha": "15974a3598209ce8d1e72d33056d5750e2653483",
        "filename": "test/lint/README.md",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/README.md?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,29 @@\n+This folder contains lint scripts.\n+\n+check-doc.py\n+============\n+Check for missing documentation of command line options.\n+\n+commit-script-check.sh\n+======================\n+Verification of [scripted diffs](/doc/developer-notes.md#scripted-diffs).\n+\n+git-subtree-check.sh\n+====================\n+Run this script from the root of the repository to verify that a subtree matches the contents of\n+the commit it claims to have been updated to.\n+\n+To use, make sure that you have fetched the upstream repository branch in which the subtree is\n+maintained:\n+* for `src/secp256k1`: https://github.com/bitcoin-core/secp256k1.git (branch master)\n+* for `src/leveldb`: https://github.com/bitcoin-core/leveldb.git (branch bitcoin-fork)\n+* for `src/univalue`: https://github.com/bitcoin-core/univalue.git (branch master)\n+* for `src/crypto/ctaes`: https://github.com/bitcoin-core/ctaes.git (branch master)\n+\n+Usage: `git-subtree-check.sh DIR (COMMIT)`\n+\n+`COMMIT` may be omitted, in which case `HEAD` is used.\n+\n+lint-all.sh\n+===========\n+Calls other scripts with the `lint-` prefix."
      },
      {
        "sha": "89776b2a6b93b9ff495475bd55ff5ff5fbf399a7",
        "filename": "test/lint/check-doc.py",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/check-doc.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -22,7 +22,7 @@\n CMD_GREP_ARGS = r\"git grep --perl-regexp '{}' -- {} ':(exclude){}'\".format(REGEX_ARG, CMD_ROOT_DIR, FOLDER_TEST)\n CMD_GREP_DOCS = r\"git grep --perl-regexp '{}' {}\".format(REGEX_DOC, CMD_ROOT_DIR)\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio', '-forcecompactdb', '-usehd'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio', '-forcecompactdb', '-usehd'])\n \n \n def main():",
        "previous_filename": "contrib/devtools/check-doc.py"
      },
      {
        "sha": "c3cdeef5801db23491b127aaa720a1eaf76ea948",
        "filename": "test/lint/check-rpc-mappings.py",
        "status": "renamed",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/check-rpc-mappings.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/check-rpc-mappings.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/check-rpc-mappings.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -44,7 +44,7 @@ def process_commands(fname):\n     \"\"\"Find and parse dispatch table in implementation file `fname`.\"\"\"\n     cmds = []\n     in_rpcs = False\n-    with open(fname, \"r\") as f:\n+    with open(fname, \"r\", encoding=\"utf8\") as f:\n         for line in f:\n             line = line.rstrip()\n             if not in_rpcs:\n@@ -70,7 +70,7 @@ def process_mapping(fname):\n     \"\"\"Find and parse conversion table in implementation file `fname`.\"\"\"\n     cmds = []\n     in_rpcs = False\n-    with open(fname, \"r\") as f:\n+    with open(fname, \"r\", encoding=\"utf8\") as f:\n         for line in f:\n             line = line.rstrip()\n             if not in_rpcs:",
        "previous_filename": "contrib/devtools/check-rpc-mappings.py"
      },
      {
        "sha": "f1327469f3d8188eebe56f02d599aaf6086c5f63",
        "filename": "test/lint/commit-script-check.sh",
        "status": "renamed",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/commit-script-check.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -11,6 +11,7 @@\n # The resulting script should exactly transform the previous commit into the current\n # one. Any remaining diff signals an error.\n \n+export LC_ALL=C\n if test \"x$1\" = \"x\"; then\n     echo \"Usage: $0 <commit>...\"\n     exit 1",
        "previous_filename": "contrib/devtools/commit-script-check.sh"
      },
      {
        "sha": "85e8b841b6b5d2aa2e6771b7fdddbd533b641d2a",
        "filename": "test/lint/git-subtree-check.sh",
        "status": "renamed",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/git-subtree-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/git-subtree-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/git-subtree-check.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -3,6 +3,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+export LC_ALL=C\n DIR=\"$1\"\n COMMIT=\"$2\"\n if [ -z \"$COMMIT\" ]; then",
        "previous_filename": "contrib/devtools/git-subtree-check.sh"
      },
      {
        "sha": "7c4f96cb3b02c9efba32dbb32dc549e4a9cf98b5",
        "filename": "test/lint/lint-all.sh",
        "status": "renamed",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-all.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-all.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-all.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n@@ -7,6 +7,10 @@\n # This script runs all contrib/devtools/lint-*.sh files, and fails if any exit\n # with a non-zero status code.\n \n+# This script is intentionally locale dependent by not setting \"export LC_ALL=C\"\n+# in order to allow for the executed lint scripts to opt in or opt out of locale\n+# dependence themselves.\n+\n set -u\n \n SCRIPTDIR=$(dirname \"${BASH_SOURCE[0]}\")",
        "previous_filename": "contrib/devtools/lint-all.sh"
      },
      {
        "sha": "5391e43d919018d48794d00bdb4ad06592f6c762",
        "filename": "test/lint/lint-filenames.sh",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-filenames.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-filenames.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-filenames.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,24 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Make sure only lowercase alphanumerics (a-z0-9), underscores (_),\n+# hyphens (-) and dots (.) are used in source code filenames.\n+\n+export LC_ALL=C\n+\n+EXIT_CODE=0\n+OUTPUT=$(git ls-files --full-name -- \"*.[cC][pP][pP]\" \"*.[hH]\" \"*.[pP][yY]\" \"*.[sS][hH]\" | \\\n+    grep -vE '^[a-z0-9_./-]+$' | \\\n+    grep -vE '^src/(secp256k1|univalue)/')\n+\n+if [[ ${OUTPUT} != \"\" ]]; then\n+    echo \"Use only lowercase alphanumerics (a-z0-9), underscores (_), hyphens (-) and dots (.)\"\n+    echo \"in source code filenames:\"\n+    echo\n+    echo \"${OUTPUT}\"\n+    EXIT_CODE=1\n+fi\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "464969794b690e435ca2cdb7f73f000f276357d5",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,11 +1,12 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n # Check include guards.\n \n+export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n ",
        "previous_filename": "contrib/devtools/lint-include-guards.sh"
      },
      {
        "sha": "40d28ed3e079d54e1855f5a8c56a35215652e1d0",
        "filename": "test/lint/lint-includes.sh",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-includes.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,119 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check for duplicate includes.\n+# Guard against accidental introduction of new Boost dependencies.\n+# Check includes: Check for duplicate includes. Enforce bracket syntax includes.\n+\n+export LC_ALL=C\n+IGNORE_REGEXP=\"/(leveldb|secp256k1|univalue)/\"\n+\n+filter_suffix() {\n+    git ls-files | grep -E \"^src/.*\\.${1}\"'$' | grep -Ev \"${IGNORE_REGEXP}\"\n+}\n+\n+EXIT_CODE=0\n+\n+for HEADER_FILE in $(filter_suffix h); do\n+    DUPLICATE_INCLUDES_IN_HEADER_FILE=$(grep -E \"^#include \" < \"${HEADER_FILE}\" | sort | uniq -d)\n+    if [[ ${DUPLICATE_INCLUDES_IN_HEADER_FILE} != \"\" ]]; then\n+        echo \"Duplicate include(s) in ${HEADER_FILE}:\"\n+        echo \"${DUPLICATE_INCLUDES_IN_HEADER_FILE}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+\n+for CPP_FILE in $(filter_suffix cpp); do\n+    DUPLICATE_INCLUDES_IN_CPP_FILE=$(grep -E \"^#include \" < \"${CPP_FILE}\" | sort | uniq -d)\n+    if [[ ${DUPLICATE_INCLUDES_IN_CPP_FILE} != \"\" ]]; then\n+        echo \"Duplicate include(s) in ${CPP_FILE}:\"\n+        echo \"${DUPLICATE_INCLUDES_IN_CPP_FILE}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+\n+INCLUDED_CPP_FILES=$(git grep -E \"^#include [<\\\"][^>\\\"]+\\.cpp[>\\\"]\" -- \"*.cpp\" \"*.h\")\n+if [[ ${INCLUDED_CPP_FILES} != \"\" ]]; then\n+    echo \"The following files #include .cpp files:\"\n+    echo \"${INCLUDED_CPP_FILES}\"\n+    echo\n+    EXIT_CODE=1\n+fi\n+\n+EXPECTED_BOOST_INCLUDES=(\n+    boost/algorithm/string.hpp\n+    boost/algorithm/string/case_conv.hpp\n+    boost/algorithm/string/classification.hpp\n+    boost/algorithm/string/join.hpp\n+    boost/algorithm/string/predicate.hpp\n+    boost/algorithm/string/replace.hpp\n+    boost/algorithm/string/split.hpp\n+    boost/bind.hpp\n+    boost/chrono/chrono.hpp\n+    boost/date_time/posix_time/posix_time.hpp\n+    boost/filesystem.hpp\n+    boost/filesystem/detail/utf8_codecvt_facet.hpp\n+    boost/filesystem/fstream.hpp\n+    boost/interprocess/sync/file_lock.hpp\n+    boost/multi_index/hashed_index.hpp\n+    boost/multi_index/ordered_index.hpp\n+    boost/multi_index/sequenced_index.hpp\n+    boost/multi_index_container.hpp\n+    boost/optional.hpp\n+    boost/preprocessor/cat.hpp\n+    boost/preprocessor/stringize.hpp\n+    boost/program_options/detail/config_file.hpp\n+    boost/scoped_array.hpp\n+    boost/signals2/connection.hpp\n+    boost/signals2/last_value.hpp\n+    boost/signals2/signal.hpp\n+    boost/test/unit_test.hpp\n+    boost/thread.hpp\n+    boost/thread/condition_variable.hpp\n+    boost/thread/mutex.hpp\n+    boost/thread/thread.hpp\n+    boost/variant.hpp\n+    boost/variant/apply_visitor.hpp\n+    boost/variant/static_visitor.hpp\n+)\n+\n+for BOOST_INCLUDE in $(git grep '^#include <boost/' -- \"*.cpp\" \"*.h\" | cut -f2 -d: | cut -f2 -d'<' | cut -f1 -d'>' | sort -u); do\n+    IS_EXPECTED_INCLUDE=0\n+    for EXPECTED_BOOST_INCLUDE in \"${EXPECTED_BOOST_INCLUDES[@]}\"; do\n+        if [[ \"${BOOST_INCLUDE}\" == \"${EXPECTED_BOOST_INCLUDE}\" ]]; then\n+            IS_EXPECTED_INCLUDE=1\n+            break\n+        fi\n+    done\n+    if [[ ${IS_EXPECTED_INCLUDE} == 0 ]]; then\n+        EXIT_CODE=1\n+        echo \"A new Boost dependency in the form of \\\"${BOOST_INCLUDE}\\\" appears to have been introduced:\"\n+        git grep \"${BOOST_INCLUDE}\" -- \"*.cpp\" \"*.h\"\n+        echo\n+    fi\n+done\n+\n+for EXPECTED_BOOST_INCLUDE in \"${EXPECTED_BOOST_INCLUDES[@]}\"; do\n+    if ! git grep -q \"^#include <${EXPECTED_BOOST_INCLUDE}>\" -- \"*.cpp\" \"*.h\"; then\n+        echo \"Good job! The Boost dependency \\\"${EXPECTED_BOOST_INCLUDE}\\\" is no longer used.\"\n+        echo \"Please remove it from EXPECTED_BOOST_INCLUDES in $0\"\n+        echo \"to make sure this dependency is not accidentally reintroduced.\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+\n+QUOTE_SYNTAX_INCLUDES=$(git grep '^#include \"' -- \"*.cpp\" \"*.h\" | grep -Ev \"${IGNORE_REGEXP}\")\n+if [[ ${QUOTE_SYNTAX_INCLUDES} != \"\" ]]; then\n+    echo \"Please use bracket syntax includes (\\\"#include <foo.h>\\\") instead of quote syntax includes:\"\n+    echo \"${QUOTE_SYNTAX_INCLUDES}\"\n+    echo\n+    EXIT_CODE=1\n+fi\n+\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "cbe1143bd0fecbc350cade21b264f226695763d0",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "added",
        "additions": 230,
        "deletions": 0,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,230 @@\n+#!/usr/bin/env bash\n+\n+export LC_ALL=C\n+KNOWN_VIOLATIONS=(\n+    \"src/base58.cpp:.*isspace\"\n+    \"src/bitcoin-tx.cpp.*stoul\"\n+    \"src/bitcoin-tx.cpp.*trim_right\"\n+    \"src/bitcoin-tx.cpp:.*atoi\"\n+    \"src/core_read.cpp.*is_digit\"\n+    \"src/dbwrapper.cpp.*stoul\"\n+    \"src/dbwrapper.cpp:.*vsnprintf\"\n+    \"src/httprpc.cpp.*trim\"\n+    \"src/init.cpp:.*atoi\"\n+    \"src/netbase.cpp.*to_lower\"\n+    \"src/qt/rpcconsole.cpp:.*atoi\"\n+    \"src/qt/rpcconsole.cpp:.*isdigit\"\n+    \"src/rest.cpp:.*strtol\"\n+    \"src/rpc/server.cpp.*to_upper\"\n+    \"src/test/dbwrapper_tests.cpp:.*snprintf\"\n+    \"src/test/getarg_tests.cpp.*split\"\n+    \"src/torcontrol.cpp:.*atoi\"\n+    \"src/torcontrol.cpp:.*strtol\"\n+    \"src/uint256.cpp:.*isspace\"\n+    \"src/uint256.cpp:.*tolower\"\n+    \"src/util.cpp:.*atoi\"\n+    \"src/util.cpp:.*fprintf\"\n+    \"src/util.cpp:.*tolower\"\n+    \"src/utilmoneystr.cpp:.*isdigit\"\n+    \"src/utilmoneystr.cpp:.*isspace\"\n+    \"src/utilstrencodings.cpp:.*atoi\"\n+    \"src/utilstrencodings.cpp:.*isspace\"\n+    \"src/utilstrencodings.cpp:.*strtol\"\n+    \"src/utilstrencodings.cpp:.*strtoll\"\n+    \"src/utilstrencodings.cpp:.*strtoul\"\n+    \"src/utilstrencodings.cpp:.*strtoull\"\n+    \"src/utilstrencodings.h:.*atoi\"\n+)\n+\n+REGEXP_IGNORE_EXTERNAL_DEPENDENCIES=\"^src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+\n+LOCALE_DEPENDENT_FUNCTIONS=(\n+    alphasort    # LC_COLLATE (via strcoll)\n+    asctime      # LC_TIME (directly)\n+    asprintf     # (via vasprintf)\n+    atof         # LC_NUMERIC (via strtod)\n+    atoi         # LC_NUMERIC (via strtol)\n+    atol         # LC_NUMERIC (via strtol)\n+    atoll        # (via strtoll)\n+    atoq\n+    btowc        # LC_CTYPE (directly)\n+    ctime        # (via asctime or localtime)\n+    dprintf      # (via vdprintf)\n+    fgetwc\n+    fgetws\n+    fold_case    # boost::locale::fold_case\n+    fprintf      # (via vfprintf)\n+    fputwc\n+    fputws\n+    fscanf       # (via __vfscanf)\n+    fwprintf     # (via __vfwprintf)\n+    getdate      # via __getdate_r => isspace // __localtime_r\n+    getwc\n+    getwchar\n+    is_digit     # boost::algorithm::is_digit\n+    is_space     # boost::algorithm::is_space\n+    isalnum      # LC_CTYPE\n+    isalpha      # LC_CTYPE\n+    isblank      # LC_CTYPE\n+    iscntrl      # LC_CTYPE\n+    isctype      # LC_CTYPE\n+    isdigit      # LC_CTYPE\n+    isgraph      # LC_CTYPE\n+    islower      # LC_CTYPE\n+    isprint      # LC_CTYPE\n+    ispunct      # LC_CTYPE\n+    isspace      # LC_CTYPE\n+    isupper      # LC_CTYPE\n+    iswalnum     # LC_CTYPE\n+    iswalpha     # LC_CTYPE\n+    iswblank     # LC_CTYPE\n+    iswcntrl     # LC_CTYPE\n+    iswctype     # LC_CTYPE\n+    iswdigit     # LC_CTYPE\n+    iswgraph     # LC_CTYPE\n+    iswlower     # LC_CTYPE\n+    iswprint     # LC_CTYPE\n+    iswpunct     # LC_CTYPE\n+    iswspace     # LC_CTYPE\n+    iswupper     # LC_CTYPE\n+    iswxdigit    # LC_CTYPE\n+    isxdigit     # LC_CTYPE\n+    localeconv   # LC_NUMERIC + LC_MONETARY\n+    mblen        # LC_CTYPE\n+    mbrlen\n+    mbrtowc\n+    mbsinit\n+    mbsnrtowcs\n+    mbsrtowcs\n+    mbstowcs     # LC_CTYPE\n+    mbtowc       # LC_CTYPE\n+    mktime\n+    normalize    # boost::locale::normalize\n+#   printf       # LC_NUMERIC\n+    putwc\n+    putwchar\n+    scanf        # LC_NUMERIC\n+    setlocale\n+    snprintf\n+    sprintf\n+    sscanf\n+    stod\n+    stof\n+    stoi\n+    stol\n+    stold\n+    stoll\n+    stoul\n+    stoull\n+    strcasecmp\n+    strcasestr\n+    strcoll      # LC_COLLATE\n+#   strerror\n+    strfmon\n+    strftime     # LC_TIME\n+    strncasecmp\n+    strptime\n+    strtod       # LC_NUMERIC\n+    strtof\n+    strtoimax\n+    strtol       # LC_NUMERIC\n+    strtold\n+    strtoll\n+    strtoq\n+    strtoul      # LC_NUMERIC\n+    strtoull\n+    strtoumax\n+    strtouq\n+    strxfrm      # LC_COLLATE\n+    swprintf\n+    to_lower     # boost::locale::to_lower\n+    to_title     # boost::locale::to_title\n+    to_upper     # boost::locale::to_upper\n+    tolower      # LC_CTYPE\n+    toupper      # LC_CTYPE\n+    towctrans\n+    towlower     # LC_CTYPE\n+    towupper     # LC_CTYPE\n+    trim         # boost::algorithm::trim\n+    trim_left    # boost::algorithm::trim_left\n+    trim_right   # boost::algorithm::trim_right\n+    ungetwc\n+    vasprintf\n+    vdprintf\n+    versionsort\n+    vfprintf\n+    vfscanf\n+    vfwprintf\n+    vprintf\n+    vscanf\n+    vsnprintf\n+    vsprintf\n+    vsscanf\n+    vswprintf\n+    vwprintf\n+    wcrtomb\n+    wcscasecmp\n+    wcscoll      # LC_COLLATE\n+    wcsftime     # LC_TIME\n+    wcsncasecmp\n+    wcsnrtombs\n+    wcsrtombs\n+    wcstod       # LC_NUMERIC\n+    wcstof\n+    wcstoimax\n+    wcstol       # LC_NUMERIC\n+    wcstold\n+    wcstoll\n+    wcstombs     # LC_CTYPE\n+    wcstoul      # LC_NUMERIC\n+    wcstoull\n+    wcstoumax\n+    wcswidth\n+    wcsxfrm      # LC_COLLATE\n+    wctob\n+    wctomb       # LC_CTYPE\n+    wctrans\n+    wctype\n+    wcwidth\n+    wprintf\n+)\n+\n+function join_array {\n+    local IFS=\"$1\"\n+    shift\n+    echo \"$*\"\n+}\n+\n+REGEXP_IGNORE_KNOWN_VIOLATIONS=$(join_array \"|\" \"${KNOWN_VIOLATIONS[@]}\")\n+\n+# Invoke \"git grep\" only once in order to minimize run-time\n+REGEXP_LOCALE_DEPENDENT_FUNCTIONS=$(join_array \"|\" \"${LOCALE_DEPENDENT_FUNCTIONS[@]}\")\n+GIT_GREP_OUTPUT=$(git grep -E \"[^a-zA-Z0-9_\\`'\\\"<>](${REGEXP_LOCALE_DEPENDENT_FUNCTIONS}(|_r|_s))[^a-zA-Z0-9_\\`'\\\"<>]\" -- \"*.cpp\" \"*.h\")\n+\n+EXIT_CODE=0\n+for LOCALE_DEPENDENT_FUNCTION in \"${LOCALE_DEPENDENT_FUNCTIONS[@]}\"; do\n+    MATCHES=$(grep -E \"[^a-zA-Z0-9_\\`'\\\"<>]${LOCALE_DEPENDENT_FUNCTION}(|_r|_s)[^a-zA-Z0-9_\\`'\\\"<>]\" <<< \"${GIT_GREP_OUTPUT}\" | \\\n+        grep -vE \"\\.(c|cpp|h):\\s*(//|\\*|/\\*|\\\").*${LOCALE_DEPENDENT_FUNCTION}\" | \\\n+        grep -vE 'fprintf\\(.*(stdout|stderr)')\n+    if [[ ${REGEXP_IGNORE_EXTERNAL_DEPENDENCIES} != \"\" ]]; then\n+        MATCHES=$(grep -vE \"${REGEXP_IGNORE_EXTERNAL_DEPENDENCIES}\" <<< \"${MATCHES}\")\n+    fi\n+    if [[ ${REGEXP_IGNORE_KNOWN_VIOLATIONS} != \"\" ]]; then\n+        MATCHES=$(grep -vE \"${REGEXP_IGNORE_KNOWN_VIOLATIONS}\" <<< \"${MATCHES}\")\n+    fi\n+    if [[ ${MATCHES} != \"\" ]]; then\n+        echo \"The locale dependent function ${LOCALE_DEPENDENT_FUNCTION}(...) appears to be used:\"\n+        echo \"${MATCHES}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+if [[ ${EXIT_CODE} != 0 ]]; then\n+    echo \"Unnecessary locale dependence can cause bugs that are very\"\n+    echo \"tricky to isolate and fix. Please avoid using locale dependent\"\n+    echo \"functions if possible.\"\n+    echo\n+    echo \"Advice not applicable in this specific case? Add an exception\"\n+    echo \"by updating the ignore list in $0\"\n+fi\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "1afd4cfc1acf56544d486d3150bbe0c3b1cfbeb1",
        "filename": "test/lint/lint-logs.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-logs.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-logs.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-logs.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n@@ -12,7 +12,7 @@\n # There are some instances of LogPrintf() in comments. Those can be\n # ignored\n \n-\n+export LC_ALL=C\n UNTERMINATED_LOGS=$(git grep --extended-regexp \"LogPrintf?\\(\" -- \"*.cpp\" | \\\n     grep -v '\\\\n\"' | \\\n     grep -v \"/\\* Continued \\*/\" | \\",
        "previous_filename": "contrib/devtools/lint-logs.sh"
      },
      {
        "sha": "4ff87f0bf741ccdbd6bd7fb893e76813453ebcb5",
        "filename": "test/lint/lint-python-shebang.sh",
        "status": "renamed",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python-shebang.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python-shebang.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-shebang.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,5 +1,7 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Shebang must use python3 (not python or python2)\n+\n+export LC_ALL=C\n EXIT_CODE=0\n for PYTHON_FILE in $(git ls-files -- \"*.py\"); do\n     if [[ $(head -c 2 \"${PYTHON_FILE}\") == \"#!\" &&",
        "previous_filename": "contrib/devtools/lint-python-shebang.sh"
      },
      {
        "sha": "14183a5ccfb19bb882c768123fefbda16a32cf64",
        "filename": "test/lint/lint-python-utf8-encoding.sh",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python-utf8-encoding.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python-utf8-encoding.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-utf8-encoding.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,20 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Make sure we explicitly open all text files using UTF-8 (or ASCII) encoding to\n+# avoid potential issues on the BSDs where the locale is not always set.\n+\n+export LC_ALL=C\n+EXIT_CODE=0\n+OUTPUT=$(git grep \" open(\" -- \"*.py\" | grep -vE \"encoding=.(ascii|utf8|utf-8).\" | grep -vE \"open\\([^,]*, ['\\\"][^'\\\"]*b[^'\\\"]*['\\\"]\")\n+if [[ ${OUTPUT} != \"\" ]]; then\n+    echo \"Python's open(...) seems to be used to open text files without explicitly\"\n+    echo \"specifying encoding=\\\"utf8\\\":\"\n+    echo\n+    echo \"${OUTPUT}\"\n+    EXIT_CODE=1\n+fi\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "d9d46d86d5a8e35380ebc7befa68b02c87650ccb",
        "filename": "test/lint/lint-python.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-python.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -6,6 +6,8 @@\n #\n # Check for specified flake8 warnings in python files.\n \n+export LC_ALL=C\n+\n # E101 indentation contains mixed spaces and tabs\n # E112 expected an indented block\n # E113 unexpected indentation",
        "previous_filename": "contrib/devtools/lint-python.sh"
      },
      {
        "sha": "242b27c76363d327e44cfe3b0196510bd9f303c1",
        "filename": "test/lint/lint-shell-locale.sh",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-shell-locale.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-shell-locale.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shell-locale.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -0,0 +1,24 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Make sure all shell scripts:\n+# a.) explicitly opt out of locale dependence using \"export LC_ALL=C\", or\n+# b.) explicitly opt in to locale dependence using the annotation below.\n+\n+export LC_ALL=C\n+\n+EXIT_CODE=0\n+for SHELL_SCRIPT in $(git ls-files -- \"*.sh\" | grep -vE \"src/(secp256k1|univalue)/\"); do\n+    if grep -q \"# This script is intentionally locale dependent by not setting \\\"export LC_ALL=C\\\"\" \"${SHELL_SCRIPT}\"; then\n+        continue\n+    fi\n+    FIRST_NON_COMMENT_LINE=$(grep -vE '^(#.*|)$' \"${SHELL_SCRIPT}\" | head -1)\n+    if [[ ${FIRST_NON_COMMENT_LINE} != \"export LC_ALL=C\" ]]; then\n+        echo \"Missing \\\"export LC_ALL=C\\\" (to avoid locale dependence) as first non-comment non-empty line in ${SHELL_SCRIPT}\"\n+        EXIT_CODE=1\n+    fi\n+done\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "e2ccdb5165ea794012d2d4830983ceee9e9252df",
        "filename": "test/lint/lint-shell.sh",
        "status": "renamed",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-shell.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-shell.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shell.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,11 +1,15 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n # Check for shellcheck warnings in shell scripts.\n \n+# This script is intentionally locale dependent by not setting \"export LC_ALL=C\"\n+# to allow running certain versions of shellcheck that core dump when LC_ALL=C\n+# is set.\n+\n # Disabled warnings:\n # SC2001: See if you can use ${variable//search/replace} instead.\n # SC2004: $/${} is unnecessary on arithmetic variables.",
        "previous_filename": "contrib/devtools/lint-shell.sh"
      },
      {
        "sha": "35d11023eb512dbc51a6c83a5d462b6f43fa3849",
        "filename": "test/lint/lint-tests.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-tests.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,11 +1,12 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n # Check the test suite naming conventions\n \n+export LC_ALL=C\n EXIT_CODE=0\n \n NAMING_INCONSISTENCIES=$(git grep -E '^BOOST_FIXTURE_TEST_SUITE\\(' -- \\",
        "previous_filename": "contrib/devtools/lint-tests.sh"
      },
      {
        "sha": "beb7ec42f43622a10cc80c45917c0b91a098aeb3",
        "filename": "test/lint/lint-whitespace.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-whitespace.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/lint/lint-whitespace.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-whitespace.sh?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n@@ -8,6 +8,7 @@\n \n # We can't run this check unless we know the commit range for the PR.\n \n+export LC_ALL=C\n while getopts \"?\" opt; do\n   case $opt in\n     ?)",
        "previous_filename": "contrib/devtools/lint-whitespace.sh"
      },
      {
        "sha": "16371a6234afd4feefbab8c564a042aafa120394",
        "filename": "test/util/bitcoin-util-test.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/util/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/util/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/bitcoin-util-test.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -28,7 +28,7 @@\n def main():\n     config = configparser.ConfigParser()\n     config.optionxform = str\n-    config.readfp(open(os.path.join(os.path.dirname(__file__), \"../config.ini\")))\n+    config.readfp(open(os.path.join(os.path.dirname(__file__), \"../config.ini\"), encoding=\"utf8\"))\n     env_conf = dict(config.items('environment'))\n \n     parser = argparse.ArgumentParser(description=__doc__)\n@@ -49,7 +49,7 @@ def main():\n def bctester(testDir, input_basename, buildenv):\n     \"\"\" Loads and parses the input file, runs all tests and reports results\"\"\"\n     input_filename = os.path.join(testDir, input_basename)\n-    raw_data = open(input_filename).read()\n+    raw_data = open(input_filename, encoding=\"utf8\").read()\n     input_data = json.loads(raw_data)\n \n     failed_testcases = []\n@@ -86,7 +86,7 @@ def bctest(testDir, testObj, buildenv):\n     inputData = None\n     if \"input\" in testObj:\n         filename = os.path.join(testDir, testObj[\"input\"])\n-        inputData = open(filename).read()\n+        inputData = open(filename, encoding=\"utf8\").read()\n         stdinCfg = subprocess.PIPE\n \n     # Read the expected output data (if there is any)\n@@ -97,7 +97,7 @@ def bctest(testDir, testObj, buildenv):\n         outputFn = testObj['output_cmp']\n         outputType = os.path.splitext(outputFn)[1][1:]  # output type from file extension (determines how to compare)\n         try:\n-            outputData = open(os.path.join(testDir, outputFn)).read()\n+            outputData = open(os.path.join(testDir, outputFn), encoding=\"utf8\").read()\n         except:\n             logging.error(\"Output file \" + outputFn + \" can not be opened\")\n             raise"
      },
      {
        "sha": "46e9fbc7398f0de61bd0fc338639f8c889a1c7ca",
        "filename": "test/util/rpcauth-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43dd7dabf153afe6113fb533a31052cff8f25061/test/util/rpcauth-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43dd7dabf153afe6113fb533a31052cff8f25061/test/util/rpcauth-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/rpcauth-test.py?ref=43dd7dabf153afe6113fb533a31052cff8f25061",
        "patch": "@@ -18,7 +18,7 @@ def setUp(self):\n         config_path = os.path.abspath(\n             os.path.join(os.sep, os.path.abspath(os.path.dirname(__file__)),\n             \"../config.ini\"))\n-        with open(config_path) as config_file:\n+        with open(config_path, encoding=\"utf8\") as config_file:\n             config.read_file(config_file)\n         sys.path.insert(0, os.path.dirname(config['environment']['RPCAUTH']))\n         self.rpcauth = importlib.import_module('rpcauth')"
      }
    ]
  },
  {
    "sha": "187688553eac479fba9a3e21334ac8674a047d61",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxODc2ODg1NTNlYWM0NzlmYmE5YTNlMjEzMzRhYzg2NzRhMDQ3ZDYx",
    "commit": {
      "author": {
        "name": "alex",
        "email": "dsoftware@protonmail.com",
        "date": "2018-06-30T14:59:53Z"
      },
      "committer": {
        "name": "alex",
        "email": "dsoftware@protonmail.com",
        "date": "2018-06-30T14:59:53Z"
      },
      "message": "configurable ZMQ HWM",
      "tree": {
        "sha": "827521bcc48be6c508dd8f2f9d4a965906f004ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/827521bcc48be6c508dd8f2f9d4a965906f004ee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/187688553eac479fba9a3e21334ac8674a047d61",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/187688553eac479fba9a3e21334ac8674a047d61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/187688553eac479fba9a3e21334ac8674a047d61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/187688553eac479fba9a3e21334ac8674a047d61/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "43dd7dabf153afe6113fb533a31052cff8f25061",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43dd7dabf153afe6113fb533a31052cff8f25061",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43dd7dabf153afe6113fb533a31052cff8f25061"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 8,
      "deletions": 3
    },
    "files": [
      {
        "sha": "af95360833e6be96c8bb1fcc274548cbc9804ed8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/187688553eac479fba9a3e21334ac8674a047d61/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/187688553eac479fba9a3e21334ac8674a047d61/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=187688553eac479fba9a3e21334ac8674a047d61",
        "patch": "@@ -454,6 +454,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-zmqpubhashtx=<address>\", \"Enable publish hash transaction in <address>\", false, OptionsCategory::ZMQ);\n     gArgs.AddArg(\"-zmqpubrawblock=<address>\", \"Enable publish raw block in <address>\", false, OptionsCategory::ZMQ);\n     gArgs.AddArg(\"-zmqpubrawtx=<address>\", \"Enable publish raw transaction in <address>\", false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqhwm=<n>\", \"Set HWM limit <n> (default: 10000)\", false, OptionsCategory::ZMQ);\n #else\n     hidden_args.emplace_back(\"-zmqpubhashblock=<address>\");\n     hidden_args.emplace_back(\"-zmqpubhashtx=<address>\");"
      },
      {
        "sha": "480d3fe1907b2e28cdf58d9d643c7473efb29e00",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/187688553eac479fba9a3e21334ac8674a047d61/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/187688553eac479fba9a3e21334ac8674a047d61/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=187688553eac479fba9a3e21334ac8674a047d61",
        "patch": "@@ -75,9 +75,13 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n             zmqError(\"Failed to create socket\");\n             return false;\n         }\n-        \n-        int HWMlimit = 0;\n-        zmq_setsockopt(psocket, ZMQ_SNDHWM, &HWMlimit, sizeof(HWMlimit));\n+\n+        int hwm = gArgs.GetArg(\"-zmqhwm\", 10000);\n+        zmq_setsockopt(psocket, ZMQ_SNDHWM, &hwm, sizeof(hwm));\n+        int sndhwm;\n+        size_t sndhwm_size = sizeof(sndhwm);\n+        zmq_getsockopt (psocket, ZMQ_SNDHWM, &sndhwm, &sndhwm_size);\n+        LogPrintf(\"ZMQ SNDHWM: %d\\n\", sndhwm);\n \n         int rc = zmq_bind(psocket, address.c_str());\n         if (rc!=0)"
      }
    ]
  }
]