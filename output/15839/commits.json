[
  {
    "sha": "8602d8b2138a06d5db7e5b86b839f400b0a905a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NjAyZDhiMjEzOGEwNmQ1ZGI3ZTViODZiODM5ZjQwMGIwYTkwNWE0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-04-17T16:46:45Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-04-17T16:46:45Z"
      },
      "message": "Revert \"Change in transaction pull scheduling to prevent InvBlock-related attacks\"\n\nThis reverts commit 1cff3d6cb017aea87d16cbda0768bbab256d16da.",
      "tree": {
        "sha": "edfc8001b6fbb172c2409f4bbcf9435fc0129922",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/edfc8001b6fbb172c2409f4bbcf9435fc0129922"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8602d8b2138a06d5db7e5b86b839f400b0a905a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8602d8b2138a06d5db7e5b86b839f400b0a905a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8602d8b2138a06d5db7e5b86b839f400b0a905a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8602d8b2138a06d5db7e5b86b839f400b0a905a4/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e57462c6ba6023e0ed5417067364dcea2f88b36d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e57462c6ba6023e0ed5417067364dcea2f88b36d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e57462c6ba6023e0ed5417067364dcea2f88b36d"
      }
    ],
    "stats": {
      "total": 249,
      "additions": 81,
      "deletions": 168
    },
    "files": [
      {
        "sha": "67c6a5c79854a81867a94c423217de65909238b7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -85,6 +85,8 @@ std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n static bool vfLimited[NET_MAX] GUARDED_BY(cs_mapLocalHost) = {};\n std::string strSubVersion;\n \n+limitedmap<uint256, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n+\n void CConnman::AddOneShot(const std::string& strDest)\n {\n     LOCK(cs_vOneShots);\n@@ -2648,6 +2650,40 @@ CNode::~CNode()\n     CloseSocket(hSocket);\n }\n \n+void CNode::AskFor(const CInv& inv)\n+{\n+    if (mapAskFor.size() > MAPASKFOR_MAX_SZ || setAskFor.size() > SETASKFOR_MAX_SZ)\n+        return;\n+    // a peer may not have multiple non-responded queue positions for a single inv item\n+    if (!setAskFor.insert(inv.hash).second)\n+        return;\n+\n+    // We're using mapAskFor as a priority queue,\n+    // the key is the earliest time the request can be sent\n+    int64_t nRequestTime;\n+    limitedmap<uint256, int64_t>::const_iterator it = mapAlreadyAskedFor.find(inv.hash);\n+    if (it != mapAlreadyAskedFor.end())\n+        nRequestTime = it->second;\n+    else\n+        nRequestTime = 0;\n+    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, FormatISO8601Time(nRequestTime/1000000), id);\n+\n+    // Make sure not to reuse time indexes to keep things in the same order\n+    int64_t nNow = GetTimeMicros() - 1000000;\n+    static int64_t nLastTime;\n+    ++nLastTime;\n+    nNow = std::max(nNow, nLastTime);\n+    nLastTime = nNow;\n+\n+    // Each retry is 2 minutes after the last\n+    nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n+    if (it != mapAlreadyAskedFor.end())\n+        mapAlreadyAskedFor.update(it, nRequestTime);\n+    else\n+        mapAlreadyAskedFor.insert(std::make_pair(inv.hash, nRequestTime));\n+    mapAskFor.insert(std::make_pair(nRequestTime, inv));\n+}\n+\n bool CConnman::NodeFullyConnected(const CNode* pnode)\n {\n     return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;"
      },
      {
        "sha": "db44ec63339d0ac6764d2564c062bf13b55c7831",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -67,6 +67,10 @@ static const bool DEFAULT_UPNP = USE_UPNP;\n #else\n static const bool DEFAULT_UPNP = false;\n #endif\n+/** The maximum number of entries in mapAskFor */\n+static const size_t MAPASKFOR_MAX_SZ = MAX_INV_SZ;\n+/** The maximum number of entries in setAskFor (larger due to getdata latency)*/\n+static const size_t SETASKFOR_MAX_SZ = 2 * MAX_INV_SZ;\n /** The maximum number of peer connections to maintain. */\n static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125;\n /** The default for -maxuploadtarget. 0 = Unlimited */\n@@ -521,6 +525,8 @@ extern bool fDiscover;\n extern bool fListen;\n extern bool fRelayTxes;\n \n+extern limitedmap<uint256, int64_t> mapAlreadyAskedFor;\n+\n /** Subversion as sent to the P2P network in `version` messages */\n extern std::string strSubVersion;\n \n@@ -709,6 +715,8 @@ class CNode\n     // and in the order requested.\n     std::vector<uint256> vInventoryBlockToSend GUARDED_BY(cs_inventory);\n     CCriticalSection cs_inventory;\n+    std::set<uint256> setAskFor;\n+    std::multimap<int64_t, CInv> mapAskFor;\n     int64_t nNextInvSend{0};\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n@@ -857,6 +865,8 @@ class CNode\n         vBlockHashesToAnnounce.push_back(hash);\n     }\n \n+    void AskFor(const CInv& inv);\n+\n     void CloseSocketDisconnect();\n \n     void copyStats(CNodeStats &stats);"
      },
      {
        "sha": "d524d626c39161196be03263023eac47dec11dad",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 168,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -64,21 +64,6 @@ static constexpr int STALE_RELAY_AGE_LIMIT = 30 * 24 * 60 * 60;\n /// Age after which a block is considered historical for purposes of rate\n /// limiting block relay. Set to one week, denominated in seconds.\n static constexpr int HISTORICAL_BLOCK_AGE = 7 * 24 * 60 * 60;\n-/** Maximum number of in-flight transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n-/** How many microseconds to delay requesting transactions from inbound peers */\n-static constexpr int64_t INBOUND_PEER_TX_DELAY = 2 * 1000000;\n-/** How long to wait (in microseconds) before downloading a transaction from an additional peer */\n-static constexpr int64_t GETDATA_TX_INTERVAL = 60 * 1000000;\n-/** Maximum delay (in microseconds) for transaction requests to avoid biasing some peers over others. */\n-static constexpr int64_t MAX_GETDATA_RANDOM_DELAY = 2 * 1000000;\n-static_assert(INBOUND_PEER_TX_DELAY >= MAX_GETDATA_RANDOM_DELAY,\n-\"To preserve security, MAX_GETDATA_RANDOM_DELAY should not exceed INBOUND_PEER_DELAY\");\n-/** Limit to avoid sending big packets. Not used in processing incoming GETDATA for compatibility */\n-static const unsigned int MAX_GETDATA_SZ = 1000;\n-\n \n struct COrphanTx {\n     // When modifying, adapt the copy of this definition in tests/DoS_tests.\n@@ -292,66 +277,6 @@ struct CNodeState {\n     //! Time of last new block announcement\n     int64_t m_last_block_announcement;\n \n-    /*\n-     * State associated with transaction download.\n-     *\n-     * Tx download algorithm:\n-     *\n-     *   When inv comes in, queue up (process_time, txid) inside the peer's\n-     *   CNodeState (m_tx_process_time) as long as m_tx_announced for the peer\n-     *   isn't too big (MAX_PEER_TX_ANNOUNCEMENTS).\n-     *\n-     *   The process_time for a transaction is set to nNow for outbound peers,\n-     *   nNow + 2 seconds for inbound peers. This is the time at which we'll\n-     *   consider trying to request the transaction from the peer in\n-     *   SendMessages(). The delay for inbound peers is to allow outbound peers\n-     *   a chance to announce before we request from inbound peers, to prevent\n-     *   an adversary from using inbound connections to blind us to a\n-     *   transaction (InvBlock).\n-     *\n-     *   When we call SendMessages() for a given peer,\n-     *   we will loop over the transactions in m_tx_process_time, looking\n-     *   at the transactions whose process_time <= nNow. We'll request each\n-     *   such transaction that we don't have already and that hasn't been\n-     *   requested from another peer recently, up until we hit the\n-     *   MAX_PEER_TX_IN_FLIGHT limit for the peer. Then we'll update\n-     *   g_already_asked_for for each requested txid, storing the time of the\n-     *   GETDATA request. We use g_already_asked_for to coordinate transaction\n-     *   requests amongst our peers.\n-     *\n-     *   For transactions that we still need but we have already recently\n-     *   requested from some other peer, we'll reinsert (process_time, txid)\n-     *   back into the peer's m_tx_process_time at the point in the future at\n-     *   which the most recent GETDATA request would time out (ie\n-     *   GETDATA_TX_INTERVAL + the request time stored in g_already_asked_for).\n-     *   We add an additional delay for inbound peers, again to prefer\n-     *   attempting download from outbound peers first.\n-     *   We also add an extra small random delay up to 2 seconds\n-     *   to avoid biasing some peers over others. (e.g., due to fixed ordering\n-     *   of peer processing in ThreadMessageHandler).\n-     *\n-     *   When we receive a transaction from a peer, we remove the txid from the\n-     *   peer's m_tx_in_flight set and from their recently announced set\n-     *   (m_tx_announced).  We also clear g_already_asked_for for that entry, so\n-     *   that if somehow the transaction is not accepted but also not added to\n-     *   the reject filter, then we will eventually redownload from other\n-     *   peers.\n-     */\n-    struct TxDownloadState {\n-        /* Track when to attempt download of announced transactions (process\n-         * time in micros -> txid)\n-         */\n-        std::multimap<int64_t, uint256> m_tx_process_time;\n-\n-        //! Store all the transactions a peer has recently announced\n-        std::set<uint256> m_tx_announced;\n-\n-        //! Store transactions which were requested by us\n-        std::set<uint256> m_tx_in_flight;\n-    };\n-\n-    TxDownloadState m_tx_download;\n-\n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n@@ -379,9 +304,6 @@ struct CNodeState {\n     }\n };\n \n-// Keeps track of the time (in microseconds) when transactions were requested last time\n-limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n-\n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n@@ -672,58 +594,6 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(txid);\n-}\n-\n-int64_t GetTxRequestTime(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(txid);\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return 0;\n-}\n-\n-void UpdateTxRequestTime(const uint256& txid, int64_t request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(txid);\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(txid, request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-\n-void RequestTx(CNodeState* state, const uint256& txid, int64_t nNow) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS || peer_download_state.m_tx_announced.count(txid)) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n-        return;\n-    }\n-    peer_download_state.m_tx_announced.insert(txid);\n-\n-    int64_t process_time;\n-    int64_t last_request_time = GetTxRequestTime(txid);\n-    // First time requesting this tx\n-    if (last_request_time == 0) {\n-        process_time = nNow;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRand(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from non-preferred (eg inbound) peers\n-    if (!state->fPreferredDownload) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, txid);\n-}\n-\n } // namespace\n \n // This function is used for testing the stale tip eviction logic, see\n@@ -2150,7 +2020,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n \n         uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-        int64_t nNow = GetTimeMicros();\n \n         for (CInv &inv : vInv)\n         {\n@@ -2182,7 +2051,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom->GetId()), inv.hash, nNow);\n+                    pfrom->AskFor(inv);\n                 }\n             }\n         }\n@@ -2415,10 +2284,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool fMissingInputs = false;\n         CValidationState state;\n \n-        CNodeState* nodestate = State(pfrom->GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        pfrom->setAskFor.erase(inv.hash);\n+        mapAlreadyAskedFor.erase(inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n@@ -2456,12 +2323,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             if (!fRejectedParents) {\n                 uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                int64_t nNow = GetTimeMicros();\n-\n                 for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv)) RequestTx(State(pfrom->GetId()), _inv.hash, nNow);\n+                    if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n                 }\n                 AddOrphanTx(ptx, pfrom->GetId());\n \n@@ -3899,39 +3764,24 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= nNow && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const uint256& txid = tx_process_time.begin()->second;\n-            CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n-            if (!AlreadyHave(inv)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                int64_t last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= nNow - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, nNow);\n-                    state.m_tx_download.m_tx_in_flight.insert(inv.hash);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    RequestTx(&state, txid, nNow);\n+        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+        {\n+            const CInv& inv = (*pto->mapAskFor.begin()).second;\n+            if (!AlreadyHave(inv))\n+            {\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= 1000)\n+                {\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    vGetData.clear();\n                 }\n             } else {\n-                // We have already seen this transaction, no need to download.\n-                state.m_tx_download.m_tx_announced.erase(inv.hash);\n-                state.m_tx_download.m_tx_in_flight.erase(inv.hash);\n+                //If we're not going to ask, don't expect a response.\n+                pto->setAskFor.erase(inv.hash);\n             }\n-            tx_process_time.erase(tx_process_time.begin());\n+            pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n-\n-\n         if (!vGetData.empty())\n             connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n "
      },
      {
        "sha": "71b6ec7425fd94b25526ee4899548ee70016f1b5",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -169,6 +169,11 @@ BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)\n     BOOST_CHECK_EQUAL(FormatISO8601Date(1317425777), \"2011-09-30\");\n }\n \n+BOOST_AUTO_TEST_CASE(util_FormatISO8601Time)\n+{\n+    BOOST_CHECK_EQUAL(FormatISO8601Time(1317425777), \"23:36:17Z\");\n+}\n+\n struct TestArgsManager : public ArgsManager\n {\n     TestArgsManager() { m_network_only_args.clear(); }"
      },
      {
        "sha": "83a7937d8f61b918cff249153107ebf2990b2b65",
        "filename": "src/util/time.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/util/time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/util/time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.cpp?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -97,3 +97,14 @@ std::string FormatISO8601Date(int64_t nTime) {\n #endif\n     return strprintf(\"%04i-%02i-%02i\", ts.tm_year + 1900, ts.tm_mon + 1, ts.tm_mday);\n }\n+\n+std::string FormatISO8601Time(int64_t nTime) {\n+    struct tm ts;\n+    time_t time_val = nTime;\n+#ifdef _MSC_VER\n+    gmtime_s(&ts, &time_val);\n+#else\n+    gmtime_r(&time_val, &ts);\n+#endif\n+    return strprintf(\"%02i:%02i:%02iZ\", ts.tm_hour, ts.tm_min, ts.tm_sec);\n+}"
      },
      {
        "sha": "f2e27474342b0cf840f13839de0f041a5372e542",
        "filename": "src/util/time.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/util/time.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8602d8b2138a06d5db7e5b86b839f400b0a905a4/src/util/time.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.h?ref=8602d8b2138a06d5db7e5b86b839f400b0a905a4",
        "patch": "@@ -33,5 +33,6 @@ void MilliSleep(int64_t n);\n  */\n std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n+std::string FormatISO8601Time(int64_t nTime);\n \n #endif // BITCOIN_UTIL_TIME_H"
      }
    ]
  }
]