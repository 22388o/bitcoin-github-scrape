[
  {
    "sha": "69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OWE1ZjhiZTBhYmRhMWU0NjJmOGVmNDRhY2FkZDJjYmZhYTg1MGZi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-04-24T17:14:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-30T14:58:29Z"
      },
      "message": "Rolling bloom filter class\n\nFor when you need to keep track of the last N items\nyou've seen, and can tolerate some false-positives.\n\nRebased-by: Pieter Wuille <pieter.wuille@gmail.com>",
      "tree": {
        "sha": "0369fcb002ab0d63aba1522b151ff89248c44818",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0369fcb002ab0d63aba1522b151ff89248c44818"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8a10000222cb49eb253b41802ecf312adaf79439",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a10000222cb49eb253b41802ecf312adaf79439",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8a10000222cb49eb253b41802ecf312adaf79439"
      }
    ],
    "stats": {
      "total": 189,
      "additions": 173,
      "deletions": 16
    },
    "files": [
      {
        "sha": "36cba491c4eb6e4709c28da444c61c82fb3c4797",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 16,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
        "patch": "@@ -21,22 +21,33 @@\n using namespace std;\n \n CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n-/**\n- * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n- * - nElements * log(fp rate) / ln(2)^2\n- * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n- */\n-vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n-/**\n- * The ideal number of hash functions is filter size * ln(2) / number of elements\n- * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n- * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n- */\n-isFull(false),\n-isEmpty(false),\n-nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n-nTweak(nTweakIn),\n-nFlags(nFlagsIn)\n+    /**\n+     * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n+     * - nElements * log(fp rate) / ln(2)^2\n+     * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n+     */\n+    vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    /**\n+     * The ideal number of hash functions is filter size * ln(2) / number of elements\n+     * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n+     * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n+     */\n+    isFull(false),\n+    isEmpty(false),\n+    nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+    nTweak(nTweakIn),\n+    nFlags(nFlagsIn)\n+{\n+}\n+\n+// Private constructor used by CRollingBloomFilter\n+CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+    vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n+    isFull(false),\n+    isEmpty(true),\n+    nHashFuncs((unsigned int)(vData.size() * 8 / nElements * LN2)),\n+    nTweak(nTweakIn),\n+    nFlags(BLOOM_UPDATE_NONE)\n {\n }\n \n@@ -197,3 +208,43 @@ void CBloomFilter::UpdateEmptyFull()\n     isFull = full;\n     isEmpty = empty;\n }\n+\n+CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate, unsigned int nTweak) :\n+    b1(nElements * 2, fpRate, nTweak), b2(nElements * 2, fpRate, nTweak)\n+{\n+    // Implemented using two bloom filters of 2 * nElements each.\n+    // We fill them up, and clear them, staggered, every nElements\n+    // inserted, so at least one always contains the last nElements\n+    // inserted.\n+    nBloomSize = nElements * 2;\n+    nInsertions = 0;\n+}\n+\n+void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n+{\n+    if (nInsertions == 0) {\n+        b1.clear();\n+    } else if (nInsertions == nBloomSize / 2) {\n+        b2.clear();\n+    }\n+    b1.insert(vKey);\n+    b2.insert(vKey);\n+    if (++nInsertions == nBloomSize) {\n+        nInsertions = 0;\n+    }\n+}\n+\n+bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n+{\n+    if (nInsertions < nBloomSize / 2) {\n+        return b2.contains(vKey);\n+    }\n+    return b1.contains(vKey);\n+}\n+\n+void CRollingBloomFilter::clear()\n+{\n+    b1.clear();\n+    b2.clear();\n+    nInsertions = 0;\n+}"
      },
      {
        "sha": "7bab379a39ce722da31ead7f755eda4ebc57b4d9",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
        "patch": "@@ -53,6 +53,10 @@ class CBloomFilter\n \n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n+    // Private constructor for CRollingBloomFilter, no restrictions on size\n+    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    friend class CRollingBloomFilter;\n+\n public:\n     /**\n      * Creates a new bloom filter which will provide the given fp rate when filled with the given number of elements\n@@ -97,4 +101,28 @@ class CBloomFilter\n     void UpdateEmptyFull();\n };\n \n+/**\n+ * RollingBloomFilter is a probabilistic \"keep track of most recently inserted\" set.\n+ * Construct it with the number of items to keep track of, and a false-positive rate.\n+ *\n+ * contains(item) will always return true if item was one of the last N things\n+ * insert()'ed ... but may also return true for items that were not inserted.\n+ */\n+class CRollingBloomFilter\n+{\n+public:\n+    CRollingBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+\n+    void insert(const std::vector<unsigned char>& vKey);\n+    bool contains(const std::vector<unsigned char>& vKey) const;\n+\n+    void clear();\n+\n+private:\n+    unsigned int nBloomSize;\n+    unsigned int nInsertions;\n+    CBloomFilter b1, b2;\n+};\n+\n+\n #endif // BITCOIN_BLOOM_H"
      },
      {
        "sha": "1bda8a7ea161bac063a9a500672dfcb7d5da5f26",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
        "patch": "@@ -8,6 +8,7 @@\n #include \"clientversion.h\"\n #include \"key.h\"\n #include \"merkleblock.h\"\n+#include \"random.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"uint256.h\"\n@@ -459,4 +460,81 @@ BOOST_AUTO_TEST_CASE(merkle_block_4_test_update_none)\n     BOOST_CHECK(!filter.contains(COutPoint(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"), 0)));\n }\n \n+static std::vector<unsigned char> RandomData()\n+{\n+    uint256 r = GetRandHash();\n+    return std::vector<unsigned char>(r.begin(), r.end());\n+}\n+\n+BOOST_AUTO_TEST_CASE(rolling_bloom)\n+{\n+    // last-100-entry, 1% false positive:\n+    CRollingBloomFilter rb1(100, 0.01, 0);\n+\n+    // Overfill:\n+    static const int DATASIZE=399;\n+    std::vector<unsigned char> data[DATASIZE];\n+    for (int i = 0; i < DATASIZE; i++) {\n+        data[i] = RandomData();\n+        rb1.insert(data[i]);\n+    }\n+    // Last 100 guaranteed to be remembered:\n+    for (int i = 299; i < DATASIZE; i++) {\n+        BOOST_CHECK(rb1.contains(data[i]));\n+    }\n+\n+    // false positive rate is 1%, so we should get about 100 hits if\n+    // testing 10,000 random keys. We get worst-case false positive\n+    // behavior when the filter is as full as possible, which is\n+    // when we've inserted one minus an integer multiple of nElement*2.\n+    unsigned int nHits = 0;\n+    for (int i = 0; i < 10000; i++) {\n+        if (rb1.contains(RandomData()))\n+            ++nHits;\n+    }\n+    // Run test_bitcoin with --log_level=message to see BOOST_TEST_MESSAGEs:\n+    BOOST_TEST_MESSAGE(\"RollingBloomFilter got \" << nHits << \" false positives (~100 expected)\");\n+\n+    // Insanely unlikely to get a fp count outside this range:\n+    BOOST_CHECK(nHits > 25);\n+    BOOST_CHECK(nHits < 175);\n+\n+    BOOST_CHECK(rb1.contains(data[DATASIZE-1]));\n+    rb1.clear();\n+    BOOST_CHECK(!rb1.contains(data[DATASIZE-1]));\n+\n+    // Now roll through data, make sure last 100 entries\n+    // are always remembered:\n+    for (int i = 0; i < DATASIZE; i++) {\n+        if (i >= 100)\n+            BOOST_CHECK(rb1.contains(data[i-100]));\n+        rb1.insert(data[i]);\n+    }\n+\n+    // Insert 999 more random entries:\n+    for (int i = 0; i < 999; i++) {\n+        rb1.insert(RandomData());\n+    }\n+    // Sanity check to make sure the filter isn't just filling up:\n+    nHits = 0;\n+    for (int i = 0; i < DATASIZE; i++) {\n+        if (rb1.contains(data[i]))\n+            ++nHits;\n+    }\n+    // Expect about 5 false positives, more than 100 means\n+    // something is definitely broken.\n+    BOOST_TEST_MESSAGE(\"RollingBloomFilter got \" << nHits << \" false positives (~5 expected)\");\n+    BOOST_CHECK(nHits < 100);\n+\n+    // last-1000-entry, 0.01% false positive:\n+    CRollingBloomFilter rb2(1000, 0.001, 0);\n+    for (int i = 0; i < DATASIZE; i++) {\n+        rb2.insert(data[i]);\n+    }\n+    // ... room for all of them:\n+    for (int i = 0; i < DATASIZE; i++) {\n+        BOOST_CHECK(rb2.contains(data[i]));\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "d81cff32e50fe5f686f985d0af2e74219f328ed0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODFjZmYzMmU1MGZlNWY2ODZmOTg1ZDBhZjJlNzQyMTlmMzI4ZWQw",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-04-25T20:25:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-30T15:16:20Z"
      },
      "message": "Replace mruset setAddrKnown with CRollingBloomFilter addrKnown\n\nUse a probabilistic bloom filter to keep track of which addresses\nwe think we have given our peers, instead of a list.\n\nThis uses much less memory, at the cost of sometimes failing to\nrelay an address to a peer-- worst case if the bloom filter happens\nto be as full as it gets, 1-in-1,000.\n\nMeasured memory usage of a full mruset setAddrKnown: 650Kbytes\nConstant memory usage of CRollingBloomFilter addrKnown: 37Kbytes.\n\nThis will also help heap fragmentation, because the 37K of storage\nis allocated when a CNode is created (when a connection to a peer\nis established) and then there is no per-item-remembered memory\nallocation.\n\nI plan on testing by restarting a full node with an empty peers.dat,\nrunning a while with -debug=addrman and -debug=net, and making sure\nthat the 'addr' message traffic out is reasonable.\n(suggestions for better tests welcome)",
      "tree": {
        "sha": "4ed441d73f9e62a1d17c69c721e4cae1bd88e1de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ed441d73f9e62a1d17c69c721e4cae1bd88e1de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d81cff32e50fe5f686f985d0af2e74219f328ed0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d81cff32e50fe5f686f985d0af2e74219f328ed0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d81cff32e50fe5f686f985d0af2e74219f328ed0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d81cff32e50fe5f686f985d0af2e74219f328ed0/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/69a5f8be0abda1e462f8ef44acadd2cbfaa850fb"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 9,
      "deletions": 9
    },
    "files": [
      {
        "sha": "a6b717d57f6af622ed17e897d889e8fa320672c3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d81cff32e50fe5f686f985d0af2e74219f328ed0",
        "patch": "@@ -3995,7 +3995,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 {\n                     LOCK(cs_vNodes);\n                     // Use deterministic randomness to send to the same nodes for 24 hours\n-                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n+                    // at a time so the addrKnowns of the chosen nodes prevent repeats\n                     static uint256 hashSalt;\n                     if (hashSalt.IsNull())\n                         hashSalt = GetRandHash();\n@@ -4779,9 +4779,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n             {\n-                // Periodically clear setAddrKnown to allow refresh broadcasts\n+                // Periodically clear addrKnown to allow refresh broadcasts\n                 if (nLastRebroadcast)\n-                    pnode->setAddrKnown.clear();\n+                    pnode->addrKnown.clear();\n \n                 // Rebroadcast our address\n                 AdvertizeLocal(pnode);\n@@ -4799,9 +4799,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             vAddr.reserve(pto->vAddrToSend.size());\n             BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n             {\n-                // returns true if wasn't already contained in the set\n-                if (pto->setAddrKnown.insert(addr).second)\n+                if (!pto->addrKnown.contains(addr.GetKey()))\n                 {\n+                    pto->addrKnown.insert(addr.GetKey());\n                     vAddr.push_back(addr);\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)"
      },
      {
        "sha": "4648dae11eff947ba3e160aa699a8abb617f9cd4",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d81cff32e50fe5f686f985d0af2e74219f328ed0",
        "patch": "@@ -1905,7 +1905,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n \n-CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), setAddrKnown(5000)\n+CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), addrKnown(5000, 0.001, insecure_rand())\n {\n     nServices = 0;\n     hSocket = hSocketIn;"
      },
      {
        "sha": "24e927c9f6d542f1e846cef5d276d5fde2a545e6",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d81cff32e50fe5f686f985d0af2e74219f328ed0/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d81cff32e50fe5f686f985d0af2e74219f328ed0",
        "patch": "@@ -300,7 +300,7 @@ class CNode\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;\n-    mruset<CAddress> setAddrKnown;\n+    CRollingBloomFilter addrKnown;\n     bool fGetAddr;\n     std::set<uint256> setKnown;\n \n@@ -380,15 +380,15 @@ class CNode\n \n     void AddAddressKnown(const CAddress& addr)\n     {\n-        setAddrKnown.insert(addr);\n+        addrKnown.insert(addr.GetKey());\n     }\n \n     void PushAddress(const CAddress& addr)\n     {\n         // Known checking here is only to save space from duplicates.\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n-        if (addr.IsValid() && !setAddrKnown.count(addr)) {\n+        if (addr.IsValid() && !addrKnown.contains(addr.GetKey())) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n                 vAddrToSend[insecure_rand() % vAddrToSend.size()] = addr;\n             } else {"
      }
    ]
  },
  {
    "sha": "d4d5022cfc6f1b826e4c644539a2c756a7499198",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNGQ1MDIyY2ZjNmYxYjgyNmU0YzY0NDUzOWEyYzc1NmE3NDk5MTk4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-25T15:19:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-30T15:16:30Z"
      },
      "message": "Use ring buffer of set iterators instead of deque of copies in mruset",
      "tree": {
        "sha": "0695cf6b9460dba508e2212153140e73f2689bbd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0695cf6b9460dba508e2212153140e73f2689bbd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d4d5022cfc6f1b826e4c644539a2c756a7499198",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4d5022cfc6f1b826e4c644539a2c756a7499198",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d4d5022cfc6f1b826e4c644539a2c756a7499198",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4d5022cfc6f1b826e4c644539a2c756a7499198/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d81cff32e50fe5f686f985d0af2e74219f328ed0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d81cff32e50fe5f686f985d0af2e74219f328ed0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d81cff32e50fe5f686f985d0af2e74219f328ed0"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 21,
      "deletions": 23
    },
    "files": [
      {
        "sha": "398aa173bf1e3c788e35a388116becc16d7ba201",
        "filename": "src/mruset.h",
        "status": "modified",
        "additions": 16,
        "deletions": 20,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/mruset.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/mruset.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mruset.h?ref=d4d5022cfc6f1b826e4c644539a2c756a7499198",
        "patch": "@@ -1,12 +1,12 @@\n-// Copyright (c) 2012 The Bitcoin Core developers\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_MRUSET_H\n #define BITCOIN_MRUSET_H\n \n-#include <deque>\n #include <set>\n+#include <vector>\n #include <utility>\n \n /** STL-like set container that only keeps the most recent N elements. */\n@@ -22,11 +22,13 @@ class mruset\n \n protected:\n     std::set<T> set;\n-    std::deque<T> queue;\n-    size_type nMaxSize;\n+    std::vector<iterator> order;\n+    size_type first_used;\n+    size_type first_unused;\n+    const size_type nMaxSize;\n \n public:\n-    mruset(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }\n+    mruset(size_type nMaxSizeIn = 1) : nMaxSize(nMaxSizeIn) { clear(); }\n     iterator begin() const { return set.begin(); }\n     iterator end() const { return set.end(); }\n     size_type size() const { return set.size(); }\n@@ -36,7 +38,9 @@ class mruset\n     void clear()\n     {\n         set.clear();\n-        queue.clear();\n+        order.assign(nMaxSize, set.end());\n+        first_used = 0;\n+        first_unused = 0;\n     }\n     bool inline friend operator==(const mruset<T>& a, const mruset<T>& b) { return a.set == b.set; }\n     bool inline friend operator==(const mruset<T>& a, const std::set<T>& b) { return a.set == b; }\n@@ -45,25 +49,17 @@ class mruset\n     {\n         std::pair<iterator, bool> ret = set.insert(x);\n         if (ret.second) {\n-            if (nMaxSize && queue.size() == nMaxSize) {\n-                set.erase(queue.front());\n-                queue.pop_front();\n+            if (set.size() == nMaxSize + 1) {\n+                set.erase(order[first_used]);\n+                order[first_used] = set.end();\n+                if (++first_used == nMaxSize) first_used = 0;\n             }\n-            queue.push_back(x);\n+            order[first_unused] = ret.first;\n+            if (++first_unused == nMaxSize) first_unused = 0;\n         }\n         return ret;\n     }\n     size_type max_size() const { return nMaxSize; }\n-    size_type max_size(size_type s)\n-    {\n-        if (s)\n-            while (queue.size() > s) {\n-                set.erase(queue.front());\n-                queue.pop_front();\n-            }\n-        nMaxSize = s;\n-        return nMaxSize;\n-    }\n };\n \n #endif // BITCOIN_MRUSET_H"
      },
      {
        "sha": "2de04fc5745e70ccb31e5a662516faf986158acd",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d4d5022cfc6f1b826e4c644539a2c756a7499198",
        "patch": "@@ -1905,7 +1905,10 @@ bool CAddrDB::Read(CAddrMan& addr)\n unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n \n-CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), addrKnown(5000, 0.001, insecure_rand())\n+CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) :\n+    ssSend(SER_NETWORK, INIT_PROTO_VERSION),\n+    addrKnown(5000, 0.001, insecure_rand()),\n+    setInventoryKnown(SendBufferSize() / 1000)\n {\n     nServices = 0;\n     hSocket = hSocketIn;\n@@ -1934,7 +1937,6 @@ CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fIn\n     nStartingHeight = -1;\n     fGetAddr = false;\n     fRelayTxes = false;\n-    setInventoryKnown.max_size(SendBufferSize() / 1000);\n     pfilter = new CBloomFilter();\n     nPingNonceSent = 0;\n     nPingUsecStart = 0;"
      },
      {
        "sha": "9a9763e27aeacd6707c3da15a17e4b74a3740c20",
        "filename": "src/test/mruset_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/test/mruset_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4d5022cfc6f1b826e4c644539a2c756a7499198/src/test/mruset_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mruset_tests.cpp?ref=d4d5022cfc6f1b826e4c644539a2c756a7499198",
        "patch": "@@ -24,7 +24,7 @@ class mrutester\n     std::set<int> set;\n \n public:\n-    mrutester() { mru.max_size(MAX_SIZE); }\n+    mrutester() : mru(MAX_SIZE) {}\n     int size() const { return set.size(); }\n \n     void insert(int n)"
      }
    ]
  },
  {
    "sha": "f46a680f423ed1de5316d176e2292edefd916a95",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDZhNjgwZjQyM2VkMWRlNTMxNmQxNzZlMjI5MmVkZWZkOTE2YTk1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-25T21:45:46Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-30T15:16:30Z"
      },
      "message": "Better mruset unit test",
      "tree": {
        "sha": "1e02d1aa11957b3f40361a9994feaa567c970404",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e02d1aa11957b3f40361a9994feaa567c970404"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f46a680f423ed1de5316d176e2292edefd916a95",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f46a680f423ed1de5316d176e2292edefd916a95",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f46a680f423ed1de5316d176e2292edefd916a95",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f46a680f423ed1de5316d176e2292edefd916a95/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d4d5022cfc6f1b826e4c644539a2c756a7499198",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4d5022cfc6f1b826e4c644539a2c756a7499198",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d4d5022cfc6f1b826e4c644539a2c756a7499198"
      }
    ],
    "stats": {
      "total": 126,
      "additions": 54,
      "deletions": 72
    },
    "files": [
      {
        "sha": "2b68f8899eea83a3eee676deaf7a62e549aeb290",
        "filename": "src/test/mruset_tests.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 72,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f46a680f423ed1de5316d176e2292edefd916a95/src/test/mruset_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f46a680f423ed1de5316d176e2292edefd916a95/src/test/mruset_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mruset_tests.cpp?ref=f46a680f423ed1de5316d176e2292edefd916a95",
        "patch": "@@ -17,83 +17,65 @@\n \n using namespace std;\n \n-class mrutester\n-{\n-private:\n-    mruset<int> mru;\n-    std::set<int> set;\n-\n-public:\n-    mrutester() : mru(MAX_SIZE) {}\n-    int size() const { return set.size(); }\n-\n-    void insert(int n)\n-    {\n-        mru.insert(n);\n-        set.insert(n);\n-        BOOST_CHECK(mru == set);\n-    }\n-};\n-\n BOOST_FIXTURE_TEST_SUITE(mruset_tests, BasicTestingSetup)\n \n-// Test that an mruset behaves like a set, as long as no more than MAX_SIZE elements are in it\n-BOOST_AUTO_TEST_CASE(mruset_like_set)\n-{\n-\n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n-    {\n-        mrutester tester;\n-        while (tester.size() < MAX_SIZE)\n-            tester.insert(GetRandInt(2 * MAX_SIZE));\n-    }\n-\n-}\n-\n-// Test that an mruset's size never exceeds its max_size\n-BOOST_AUTO_TEST_CASE(mruset_limited_size)\n+BOOST_AUTO_TEST_CASE(mruset_test)\n {\n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n-    {\n-        mruset<int> mru(MAX_SIZE);\n-        for (int nAction=0; nAction<3*MAX_SIZE; nAction++)\n-        {\n-            int n = GetRandInt(2 * MAX_SIZE);\n-            mru.insert(n);\n-            BOOST_CHECK(mru.size() <= MAX_SIZE);\n+    // The mruset being tested.\n+    mruset<int> mru(5000);\n+\n+    // Run the test 10 times.\n+    for (int test = 0; test < 10; test++) {\n+        // Reset mru.\n+        mru.clear();\n+\n+        // A deque + set to simulate the mruset.\n+        std::deque<int> rep;\n+        std::set<int> all;\n+\n+        // Insert 10000 random integers below 15000.\n+        for (int j=0; j<10000; j++) {\n+            int add = GetRandInt(15000);\n+            mru.insert(add);\n+\n+            // Add the number to rep/all as well.\n+            if (all.count(add) == 0) {\n+               all.insert(add);\n+               rep.push_back(add);\n+               if (all.size() == 5001) {\n+                   all.erase(rep.front());\n+                   rep.pop_front();\n+               }\n+            }\n+\n+            // Do a full comparison between mru and the simulated mru every 1000 and every 5001 elements.\n+            if (j % 1000 == 0 || j % 5001 == 0) {\n+                mruset<int> mru2 = mru; // Also try making a copy\n+\n+                // Check that all elements that should be in there, are in there.\n+                BOOST_FOREACH(int x, rep) {\n+                    BOOST_CHECK(mru.count(x));\n+                    BOOST_CHECK(mru2.count(x));\n+                }\n+\n+                // Check that all elements that are in there, should be in there.\n+                BOOST_FOREACH(int x, mru) {\n+                    BOOST_CHECK(all.count(x));\n+                }\n+\n+                // Check that all elements that are in there, should be in there.\n+                BOOST_FOREACH(int x, mru2) {\n+                    BOOST_CHECK(all.count(x));\n+                }\n+\n+                for (int t = 0; t < 10; t++) {\n+                    int r = GetRandInt(15000);\n+                    BOOST_CHECK(all.count(r) == mru.count(r));\n+                    BOOST_CHECK(all.count(r) == mru2.count(r));\n+                }\n+            }\n         }\n     }\n }\n \n-// 16-bit permutation function\n-int static permute(int n)\n-{\n-    // hexadecimals of pi; verified to be linearly independent\n-    static const int table[16] = {0x243F, 0x6A88, 0x85A3, 0x08D3, 0x1319, 0x8A2E, 0x0370, 0x7344,\n-                                  0xA409, 0x3822, 0x299F, 0x31D0, 0x082E, 0xFA98, 0xEC4E, 0x6C89};\n-\n-    int ret = 0;\n-    for (int bit=0; bit<16; bit++)\n-         if (n & (1<<bit))\n-             ret ^= table[bit];\n-\n-    return ret;\n-}\n-\n-// Test that an mruset acts like a moving window, if no duplicate elements are added\n-BOOST_AUTO_TEST_CASE(mruset_window)\n-{\n-    mruset<int> mru(MAX_SIZE);\n-    for (int n=0; n<10*MAX_SIZE; n++)\n-    {\n-        mru.insert(permute(n));\n-\n-        set<int> tester;\n-        for (int m=max(0,n-MAX_SIZE+1); m<=n; m++)\n-            tester.insert(permute(m));\n-\n-        BOOST_CHECK(mru == tester);\n-    }\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]