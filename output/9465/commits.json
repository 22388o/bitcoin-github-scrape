[
  {
    "sha": "b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiM2Q3YjFjYmU3YWZkYzZhNjNiYmNiZTkzOGU4NjM5ZGVlZGIwNGEx",
    "commit": {
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2017-01-04T08:51:14Z"
      },
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2017-01-05T18:15:01Z"
      },
      "message": "Wallet: Do not perform ECDSA in the fee calculation inner loop.\n\nPerforming signing in the inner loop has terrible performance\n when many passes through are needed to complete the selection.\n\nSigning before the algorithm is complete also gets in the way\n of correctly setting the fee (e.g. preventing over-payment when\n the fee required goes down on the final selection.)\n\nUse of the dummy might overpay on the signatures by a couple bytes\n in uncommon cases where the signatures' DER encoding is smaller\n than the dummy: Who cares?",
      "tree": {
        "sha": "6810829764a49ea735bd03584906dcd06f339d6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6810829764a49ea735bd03584906dcd06f339d6f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1/comments",
    "author": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "649cf5fe894b3f2db93d99392239c1405921c02e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/649cf5fe894b3f2db93d99392239c1405921c02e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/649cf5fe894b3f2db93d99392239c1405921c02e"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 46,
      "deletions": 31
    },
    "files": [
      {
        "sha": "185c4590cd3bcae22f93faea056a48387887ccbb",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 31,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b3d7b1cbe7afdc6a63bbcbe938e8639deedb04a1",
        "patch": "@@ -2245,7 +2245,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n     CAmount nValue = 0;\n     int nChangePosRequest = nChangePosInOut;\n     unsigned int nSubtractFeeFromAmount = 0;\n-    BOOST_FOREACH (const CRecipient& recipient, vecSend)\n+    for (const auto& recipient : vecSend)\n     {\n         if (nValue < 0 || recipient.nAmount < 0)\n         {\n@@ -2300,6 +2300,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n \n     {\n+        set<pair<const CWalletTx*,unsigned int> > setCoins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n@@ -2320,7 +2321,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                     nValueToSelect += nFeeRet;\n                 double dPriority = 0;\n                 // vouts to the payees\n-                BOOST_FOREACH (const CRecipient& recipient, vecSend)\n+                for (const auto& recipient : vecSend)\n                 {\n                     CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n@@ -2352,14 +2353,14 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 }\n \n                 // Choose coins to use\n-                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                 CAmount nValueIn = 0;\n+                setCoins.clear();\n                 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl))\n                 {\n                     strFailReason = _(\"Insufficient funds\");\n                     return false;\n                 }\n-                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n+                for (const auto& pcoin : setCoins)\n                 {\n                     CAmount nCredit = pcoin.first->tx->vout[pcoin.second].nValue;\n                     //The coin age after the next block (depth+1) is used instead of the current,\n@@ -2470,24 +2471,18 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 // to avoid conflicting with other possible uses of nSequence,\n                 // and in the spirit of \"smallest posible change from prior\n                 // behavior.\"\n-                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n+                for (const auto& coin : setCoins)\n                     txNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second,CScript(),\n                                               std::numeric_limits<unsigned int>::max() - (fWalletRbf ? 2 : 1)));\n \n-                // Sign\n+                // Fill in dummy signatures for fee calculation.\n                 int nIn = 0;\n-                CTransaction txNewConst(txNew);\n-                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n+                for (const auto& coin : setCoins)\n                 {\n-                    bool signSuccess;\n                     const CScript& scriptPubKey = coin.first->tx->vout[coin.second].scriptPubKey;\n                     SignatureData sigdata;\n-                    if (sign)\n-                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.first->tx->vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata);\n-                    else\n-                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata);\n \n-                    if (!signSuccess)\n+                    if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n                     {\n                         strFailReason = _(\"Signing transaction failed\");\n                         return false;\n@@ -2500,26 +2495,15 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n \n                 unsigned int nBytes = GetVirtualTransactionSize(txNew);\n \n-                // Remove scriptSigs if we used dummy signatures for fee calculation\n-                if (!sign) {\n-                    BOOST_FOREACH (CTxIn& vin, txNew.vin) {\n-                        vin.scriptSig = CScript();\n-                        vin.scriptWitness.SetNull();\n-                    }\n-                }\n-\n-                // Embed the constructed transaction data in wtxNew.\n-                wtxNew.SetTx(MakeTransactionRef(std::move(txNew)));\n+                CTransaction txNewConst(txNew);\n+                dPriority = txNewConst.ComputePriority(dPriority, nBytes);\n \n-                // Limit size\n-                if (GetTransactionWeight(wtxNew) >= MAX_STANDARD_TX_WEIGHT)\n-                {\n-                    strFailReason = _(\"Transaction too large\");\n-                    return false;\n+                // Remove scriptSigs to eliminate the fee calculation dummy signatures\n+                for (auto& vin : txNew.vin) {\n+                    vin.scriptSig = CScript();\n+                    vin.scriptWitness.SetNull();\n                 }\n \n-                dPriority = wtxNew.tx->ComputePriority(dPriority, nBytes);\n-\n                 // Allow to override the default confirmation target over the CoinControl instance\n                 int currentConfirmationTarget = nTxConfirmTarget;\n                 if (coinControl && coinControl->nConfirmTarget > 0)\n@@ -2558,6 +2542,37 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 continue;\n             }\n         }\n+\n+        if (sign)\n+        {\n+            CTransaction txNewConst(txNew);\n+            int nIn = 0;\n+            for (const auto& coin : setCoins)\n+            {\n+                const CScript& scriptPubKey = coin.first->tx->vout[coin.second].scriptPubKey;\n+                SignatureData sigdata;\n+\n+                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.first->tx->vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n+                {\n+                    strFailReason = _(\"Signing transaction failed\");\n+                    return false;\n+                } else {\n+                    UpdateTransaction(txNew, nIn, sigdata);\n+                }\n+\n+                nIn++;\n+            }\n+        }\n+\n+        // Embed the constructed transaction data in wtxNew.\n+        wtxNew.SetTx(MakeTransactionRef(std::move(txNew)));\n+\n+        // Limit size\n+        if (GetTransactionWeight(wtxNew) >= MAX_STANDARD_TX_WEIGHT)\n+        {\n+            strFailReason = _(\"Transaction too large\");\n+            return false;\n+        }\n     }\n \n     if (GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {"
      }
    ]
  }
]