[
  {
    "sha": "545404e7e1c72985557ccffe865cea269143e5dd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDU0MDRlN2UxYzcyOTg1NTU3Y2NmZmU4NjVjZWEyNjkxNDNlNWRk",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-04-28T06:35:46Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-04-28T06:34:20Z"
      },
      "message": "fuzz: Add RPC interface fuzzing. Increase fuzzing coverage from 65% to 70%.",
      "tree": {
        "sha": "bb70ffa49570a295317a642f0eff9c28104b6e14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb70ffa49570a295317a642f0eff9c28104b6e14"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/545404e7e1c72985557ccffe865cea269143e5dd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/545404e7e1c72985557ccffe865cea269143e5dd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/545404e7e1c72985557ccffe865cea269143e5dd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/545404e7e1c72985557ccffe865cea269143e5dd/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6d6bc8abb721be68a3d2cdba11ceb5e9814c9b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6d6bc8abb721be68a3d2cdba11ceb5e9814c9b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6d6bc8abb721be68a3d2cdba11ceb5e9814c9b1"
      }
    ],
    "stats": {
      "total": 379,
      "additions": 379,
      "deletions": 0
    },
    "files": [
      {
        "sha": "efddc5e8c42173b67952ec58c622fb60e3faa64d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/545404e7e1c72985557ccffe865cea269143e5dd/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/545404e7e1c72985557ccffe865cea269143e5dd/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=545404e7e1c72985557ccffe865cea269143e5dd",
        "patch": "@@ -274,6 +274,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/random.cpp \\\n  test/fuzz/rbf.cpp \\\n  test/fuzz/rolling_bloom_filter.cpp \\\n+ test/fuzz/rpc.cpp \\\n  test/fuzz/script.cpp \\\n  test/fuzz/script_assets_test_minimizer.cpp \\\n  test/fuzz/script_bitcoin_consensus.cpp \\"
      },
      {
        "sha": "dae6f6b6a76946b0c034454c1b60093ac607d6c5",
        "filename": "src/test/fuzz/rpc.cpp",
        "status": "added",
        "additions": 378,
        "deletions": 0,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/545404e7e1c72985557ccffe865cea269143e5dd/src/test/fuzz/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/545404e7e1c72985557ccffe865cea269143e5dd/src/test/fuzz/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rpc.cpp?ref=545404e7e1c72985557ccffe865cea269143e5dd",
        "patch": "@@ -0,0 +1,378 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <base58.h>\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <interfaces/chain.h>\n+#include <key.h>\n+#include <key_io.h>\n+#include <node/context.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <psbt.h>\n+#include <rpc/blockchain.h>\n+#include <rpc/client.h>\n+#include <rpc/request.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <tinyformat.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/time.h>\n+\n+#include <cstdint>\n+#include <iostream>\n+#include <memory>\n+#include <optional>\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+struct RPCFuzzTestingSetup : public TestingSetup {\n+    RPCFuzzTestingSetup(const std::string& chain_name, const std::vector<const char*>& extra_args) : TestingSetup{chain_name, extra_args}\n+    {\n+    }\n+\n+    UniValue CallRPC(const std::string& rpc_method, const std::vector<std::string>& arguments)\n+    {\n+        JSONRPCRequest request;\n+        request.context = &m_node;\n+        request.strMethod = rpc_method;\n+        request.params = RPCConvertValues(rpc_method, arguments);\n+        return tableRPC.execute(request);\n+    }\n+\n+    std::vector<std::string> GetRPCCommands() const\n+    {\n+        return tableRPC.listCommands();\n+    }\n+};\n+\n+RPCFuzzTestingSetup* rpc_testing_setup = nullptr;\n+std::string g_limit_to_rpc_command;\n+\n+// RPC commands which are not appropriate for fuzzing: such as RPC commands\n+// reading or writing to a filename passed as an RPC parameter, RPC commands\n+// resulting in network activity, etc.\n+const std::vector<std::string> RPC_COMMANDS_NOT_SAFE_FOR_FUZZING{\n+    \"addconnection\",  // avoid DNS lookups\n+    \"addnode\",        // avoid DNS lookups\n+    \"addpeeraddress\", // avoid DNS lookups\n+    \"analyzepsbt\",    // avoid signed integer overflow in CFeeRate::GetFee(unsigned long) (https://github.com/bitcoin/bitcoin/issues/20607)\n+    \"dumptxoutset\",   // avoid writing to disk\n+#ifdef ENABLE_WALLET\n+    \"dumpwallet\", // avoid writing to disk\n+#endif\n+    \"echoipc\",           // avoid assertion failure (Assertion `\"EnsureAnyNodeContext(request.context).init\" && check' failed.)\n+    \"generatetoaddress\", // avoid timeout\n+    \"gettxoutproof\",     // avoid slow execution\n+#ifdef ENABLE_WALLET\n+    \"importwallet\", // avoid reading from disk\n+    \"loadwallet\",   // avoid reading from disk\n+#endif\n+    \"mockscheduler\",         // avoid assertion failure (Assertion `delta_seconds.count() > 0 && delta_seconds < std::chrono::hours{1}' failed.)\n+    \"prioritisetransaction\", // avoid signed integer overflow in CTxMemPool::PrioritiseTransaction(uint256 const&, long const&) (https://github.com/bitcoin/bitcoin/issues/20626)\n+    \"setban\",                // avoid DNS lookups\n+    \"stop\",                  // avoid shutdown state\n+};\n+\n+// RPC commands which are safe for fuzzing.\n+const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{\n+    \"clearbanned\",\n+    \"combinepsbt\",\n+    \"combinerawtransaction\",\n+    \"converttopsbt\",\n+    \"createmultisig\",\n+    \"createpsbt\",\n+    \"createrawtransaction\",\n+    \"decodepsbt\",\n+    \"decoderawtransaction\",\n+    \"decodescript\",\n+    \"deriveaddresses\",\n+    \"disconnectnode\",\n+    \"echo\",\n+    \"echojson\",\n+    \"estimaterawfee\",\n+    \"estimatesmartfee\",\n+    \"finalizepsbt\",\n+    \"generate\",\n+    \"generateblock\",\n+    \"generatetodescriptor\",\n+    \"getaddednodeinfo\",\n+    \"getbestblockhash\",\n+    \"getblock\",\n+    \"getblockchaininfo\",\n+    \"getblockcount\",\n+    \"getblockfilter\",\n+    \"getblockhash\",\n+    \"getblockheader\",\n+    \"getblockstats\",\n+    \"getblocktemplate\",\n+    \"getchaintips\",\n+    \"getchaintxstats\",\n+    \"getconnectioncount\",\n+    \"getdescriptorinfo\",\n+    \"getdifficulty\",\n+    \"getindexinfo\",\n+    \"getmemoryinfo\",\n+    \"getmempoolancestors\",\n+    \"getmempooldescendants\",\n+    \"getmempoolentry\",\n+    \"getmempoolinfo\",\n+    \"getmininginfo\",\n+    \"getnettotals\",\n+    \"getnetworkhashps\",\n+    \"getnetworkinfo\",\n+    \"getnodeaddresses\",\n+    \"getpeerinfo\",\n+    \"getrawmempool\",\n+    \"getrawtransaction\",\n+    \"getrpcinfo\",\n+    \"gettxout\",\n+    \"gettxoutsetinfo\",\n+    \"help\",\n+    \"invalidateblock\",\n+    \"joinpsbts\",\n+    \"listbanned\",\n+    \"logging\",\n+    \"ping\",\n+    \"preciousblock\",\n+    \"pruneblockchain\",\n+    \"reconsiderblock\",\n+    \"savemempool\",\n+    \"scantxoutset\",\n+    \"sendrawtransaction\",\n+    \"setmocktime\",\n+    \"setnetworkactive\",\n+    \"signmessagewithprivkey\",\n+    \"signrawtransactionwithkey\",\n+    \"submitblock\",\n+    \"submitheader\",\n+    \"syncwithvalidationinterfacequeue\",\n+    \"testmempoolaccept\",\n+    \"uptime\",\n+    \"utxoupdatepsbt\",\n+    \"validateaddress\",\n+    \"verifychain\",\n+    \"verifymessage\",\n+    \"verifytxoutproof\",\n+    \"waitforblock\",\n+    \"waitforblockheight\",\n+    \"waitfornewblock\",\n+};\n+\n+std::string ConsumeScalarRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    const size_t max_string_length = 4096;\n+    std::string r;\n+    CallOneOf(\n+        fuzzed_data_provider,\n+        [&] {\n+            // string argument\n+            r = fuzzed_data_provider.ConsumeRandomLengthString(max_string_length);\n+        },\n+        [&] {\n+            // base64 argument\n+            r = EncodeBase64(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // hex argument\n+            r = HexStr(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // bool argument\n+            r = fuzzed_data_provider.ConsumeBool() ? \"true\" : \"false\";\n+        },\n+        [&] {\n+            // range argument\n+            r = \"[\" + ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>()) + \",\" + ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>()) + \"]\";\n+        },\n+        [&] {\n+            // integral argument (int64_t)\n+            r = ToString(fuzzed_data_provider.ConsumeIntegral<int64_t>());\n+        },\n+        [&] {\n+            // integral argument (uint64_t)\n+            r = ToString(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+        },\n+        [&] {\n+            // floating point argument\n+            r = strprintf(\"%f\", fuzzed_data_provider.ConsumeFloatingPoint<double>());\n+        },\n+        [&] {\n+            // tx destination argument\n+            r = EncodeDestination(ConsumeTxDestination(fuzzed_data_provider));\n+        },\n+        [&] {\n+            // uint160 argument\n+            r = ConsumeUInt160(fuzzed_data_provider).ToString();\n+        },\n+        [&] {\n+            // uint256 argument\n+            r = ConsumeUInt256(fuzzed_data_provider).ToString();\n+        },\n+        [&] {\n+            // base32 argument\n+            r = EncodeBase32(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length));\n+        },\n+        [&] {\n+            // base58 argument\n+            r = EncodeBase58(MakeUCharSpan(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length)));\n+        },\n+        [&] {\n+            // base58 argument with checksum\n+            r = EncodeBase58Check(MakeUCharSpan(fuzzed_data_provider.ConsumeRandomLengthString(max_string_length)));\n+        },\n+        [&] {\n+            // hex encoded block\n+            std::optional<CBlock> opt_block = ConsumeDeserializable<CBlock>(fuzzed_data_provider);\n+            if (!opt_block) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_block;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // hex encoded block header\n+            std::optional<CBlockHeader> opt_block_header = ConsumeDeserializable<CBlockHeader>(fuzzed_data_provider);\n+            if (!opt_block_header) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_block_header;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // hex encoded tx\n+            std::optional<CMutableTransaction> opt_tx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (!opt_tx) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, fuzzed_data_provider.ConsumeBool() ? PROTOCOL_VERSION : (PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)};\n+            data_stream << *opt_tx;\n+            r = HexStr(data_stream);\n+        },\n+        [&] {\n+            // base64 encoded psbt\n+            std::optional<PartiallySignedTransaction> opt_psbt = ConsumeDeserializable<PartiallySignedTransaction>(fuzzed_data_provider);\n+            if (!opt_psbt) {\n+                return;\n+            }\n+            CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n+            data_stream << *opt_psbt;\n+            r = EncodeBase64({data_stream.begin(), data_stream.end()});\n+        },\n+        [&] {\n+            // base58 encoded key\n+            const std::vector<uint8_t> random_bytes = fuzzed_data_provider.ConsumeBytes<uint8_t>(32);\n+            CKey key;\n+            key.Set(random_bytes.begin(), random_bytes.end(), fuzzed_data_provider.ConsumeBool());\n+            if (!key.IsValid()) {\n+                return;\n+            }\n+            r = EncodeSecret(key);\n+        },\n+        [&] {\n+            // hex encoded pubkey\n+            const std::vector<uint8_t> random_bytes = fuzzed_data_provider.ConsumeBytes<uint8_t>(32);\n+            CKey key;\n+            key.Set(random_bytes.begin(), random_bytes.end(), fuzzed_data_provider.ConsumeBool());\n+            if (!key.IsValid()) {\n+                return;\n+            }\n+            r = HexStr(key.GetPubKey());\n+        });\n+    return r;\n+}\n+\n+std::string ConsumeArrayRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    std::vector<std::string> scalar_arguments;\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        scalar_arguments.push_back(ConsumeScalarRPCArgument(fuzzed_data_provider));\n+    }\n+    return \"[\\\"\" + Join(scalar_arguments, \"\\\",\\\"\") + \"\\\"]\";\n+}\n+\n+std::string ConsumeRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    return fuzzed_data_provider.ConsumeBool() ? ConsumeScalarRPCArgument(fuzzed_data_provider) : ConsumeArrayRPCArgument(fuzzed_data_provider);\n+}\n+\n+RPCFuzzTestingSetup* InitializeRPCFuzzTestingSetup()\n+{\n+    static const auto setup = MakeNoLogFileContext<RPCFuzzTestingSetup>();\n+    SetRPCWarmupFinished();\n+    return setup.get();\n+}\n+}; // namespace\n+\n+void initialize_rpc()\n+{\n+    rpc_testing_setup = InitializeRPCFuzzTestingSetup();\n+    const std::vector<std::string> supported_rpc_commands = rpc_testing_setup->GetRPCCommands();\n+    for (const std::string& rpc_command : supported_rpc_commands) {\n+        const bool safe_for_fuzzing = std::find(RPC_COMMANDS_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_SAFE_FOR_FUZZING.end();\n+        const bool not_safe_for_fuzzing = std::find(RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_NOT_SAFE_FOR_FUZZING.end();\n+        if (!(safe_for_fuzzing || not_safe_for_fuzzing)) {\n+            std::cerr << \"Error: RPC command \\\"\" << rpc_command << \"\\\" not found in RPC_COMMANDS_SAFE_FOR_FUZZING or RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+        if (safe_for_fuzzing && not_safe_for_fuzzing) {\n+            std::cerr << \"Error: RPC command \\\"\" << rpc_command << \"\\\" found in *both* RPC_COMMANDS_SAFE_FOR_FUZZING and RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    for (const std::string& rpc_command : RPC_COMMANDS_SAFE_FOR_FUZZING) {\n+        const bool supported_rpc_command = std::find(supported_rpc_commands.begin(), supported_rpc_commands.end(), rpc_command) != supported_rpc_commands.end();\n+        if (!supported_rpc_command) {\n+            std::cerr << \"Error: Unknown RPC command \\\"\" << rpc_command << \"\\\" found in RPC_COMMANDS_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    for (const std::string& rpc_command : RPC_COMMANDS_NOT_SAFE_FOR_FUZZING) {\n+        const bool supported_rpc_command = std::find(supported_rpc_commands.begin(), supported_rpc_commands.end(), rpc_command) != supported_rpc_commands.end();\n+        if (!supported_rpc_command) {\n+            std::cerr << \"Error: Unknown RPC command \\\"\" << rpc_command << \"\\\" found in RPC_COMMANDS_NOT_SAFE_FOR_FUZZING. Please update \" << __FILE__ << \".\\n\";\n+            std::terminate();\n+        }\n+    }\n+    const char* limit_to_rpc_command_env = std::getenv(\"LIMIT_TO_RPC_COMMAND\");\n+    if (limit_to_rpc_command_env != nullptr) {\n+        g_limit_to_rpc_command = std::string{limit_to_rpc_command_env};\n+    }\n+}\n+\n+FUZZ_TARGET_INIT(rpc, initialize_rpc)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    const std::string rpc_command = fuzzed_data_provider.ConsumeRandomLengthString(64);\n+    if (!g_limit_to_rpc_command.empty() && rpc_command != g_limit_to_rpc_command) {\n+        return;\n+    }\n+    const bool safe_for_fuzzing = std::find(RPC_COMMANDS_SAFE_FOR_FUZZING.begin(), RPC_COMMANDS_SAFE_FOR_FUZZING.end(), rpc_command) != RPC_COMMANDS_SAFE_FOR_FUZZING.end();\n+    if (!safe_for_fuzzing) {\n+        return;\n+    }\n+    std::vector<std::string> arguments;\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        arguments.push_back(ConsumeRPCArgument(fuzzed_data_provider));\n+    }\n+    try {\n+        rpc_testing_setup->CallRPC(rpc_command, arguments);\n+    } catch (const UniValue&) {\n+    } catch (const std::runtime_error&) {\n+    }\n+}"
      }
    ]
  }
]