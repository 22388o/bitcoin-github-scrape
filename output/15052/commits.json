[
  {
    "sha": "e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzJkOGQ3ZGEwZDQ5ZWEyYzFkNzY5YzhiOWFkMmM5MDI3ZDk0N2Vj",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-28T17:33:29Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-28T17:33:29Z"
      },
      "message": "Tests: Contract testing for the procedure AddTimeData and related fixes",
      "tree": {
        "sha": "9fd531cbf4ef556bf4065c6a6703468d3dc37927",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9fd531cbf4ef556bf4065c6a6703468d3dc37927"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86e0a33f5c382513d5179e3fdf158baf952d7e2f"
      }
    ],
    "stats": {
      "total": 310,
      "additions": 274,
      "deletions": 36
    },
    "files": [
      {
        "sha": "d14c58adf6f7147267b3a3abd673321eebece5f3",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "patch": "@@ -291,12 +291,12 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) == 0);\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) < 0);\n }\n \n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const"
      },
      {
        "sha": "2b7aff4db658240b8f125cfe709674e7d8f392e4",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 197,
        "deletions": 1,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "patch": "@@ -2,8 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n-#include <timedata.h>\n+#include <netaddress.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -34,4 +35,199 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+CNetAddr UtilBuildAddress(const std::string& address)\n+{\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in));\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+void UtilPreconditionIsAtLeastFiveEntriesRequired(const std::string& baseip, int basevalue)\n+{\n+    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        int val = basevalue + i;\n+        std::stringstream stream;\n+        stream << baseip << val;\n+        std::string ip = stream.str();\n+        AddTimeData(UtilBuildAddress(ip), val);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(UtilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(UtilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(UtilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(UtilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.3.\", 50); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 60);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 61);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0325c26d780f73817334e5b2eb7242c7e3d89083",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 24,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "patch": "@@ -44,20 +44,36 @@ static int64_t abs64(int64_t n)\n \n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n+\n+static std::set<CNetAddr> setKnown;\n+\n+static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n+\n+int CountOffsetSamples()\n+{\n+    LOCK(cs_nTimeOffset);\n+    return vTimeOffsets.size();\n+}\n+\n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n+\n+    AddTimeDataAlgorithm(ip, nOffsetSample, setKnown, vTimeOffsets, nTimeOffset);\n+}\n+\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset)\n+{\n     // Ignore duplicates\n-    static std::set<CNetAddr> setKnown;\n-    if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n+\n+    if (knownSet.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n-    if (!setKnown.insert(ip).second)\n+    if (!knownSet.insert(ip).second)\n         return;\n \n     // Add data\n-    static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n-    vTimeOffsets.input(nOffsetSample);\n-    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    offsetFilter.input(nOffsetSample);\n+    LogPrint(BCLog::NET, \"added time data, samples %d, offset %+d (%+d minutes)\\n\", offsetFilter.size(), nOffsetSample, nOffsetSample / 60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -76,31 +92,25 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // So we should hold off on fixing this and clean it up as part of\n     // a timing cleanup that strengthens it in a number of other ways.\n     //\n-    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n-        int64_t nMedian = vTimeOffsets.median();\n-        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n+    if (offsetFilter.size() >= 5 && offsetFilter.size() % 2 == 1) {\n+        int64_t nMedian = offsetFilter.median();\n+        std::vector<int64_t> vSorted = offsetFilter.sorted();\n         // Only let other nodes change our time by so much\n-        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT)))\n-        {\n-            nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n-            nTimeOffset = 0;\n+        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT))) {\n+            offset = nMedian;\n+        } else {\n+            offset = 0;\n \n-            static bool fDone;\n-            if (!fDone)\n-            {\n+            static bool gDone;\n+            if (!gDone) {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n                 for (const int64_t nOffset : vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n-                if (!fMatch)\n-                {\n-                    fDone = true;\n+                if (!fMatch) {\n+                    gDone = true;\n                     std::string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n                     SetMiscWarning(strMessage);\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n@@ -114,7 +124,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n             }\n             LogPrint(BCLog::NET, \"|  \"); /* Continued */\n \n-            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", offset, offset / 60);\n         }\n     }\n }"
      },
      {
        "sha": "0206445ddf100387ed48924594e369f4665e0e6a",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <set>\n #include <stdint.h>\n #include <vector>\n \n@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to isolate the contract in AddTimeData */\n+int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);\n+\n #endif // BITCOIN_TIMEDATA_H"
      },
      {
        "sha": "e53be1f83c38fe82e344972b32b3f37d6878a783",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 9,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "patch": "@@ -12,12 +12,13 @@\n \n #include <consensus/validation.h>\n #include <interfaces/chain.h>\n+#include <policy/policy.h>\n #include <rpc/server.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/test/wallet_test_fixture.h>\n-#include <policy/policy.h>\n \n #include <boost/test/unit_test.hpp>\n #include <univalue.h>\n@@ -258,11 +259,10 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50*COIN);\n }\n \n-static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n+static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t blockTime)\n {\n     CMutableTransaction tx;\n     tx.nLockTime = lockTime;\n-    SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         auto locked_chain = wallet.chain().lock();\n@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which suports mocking)\n+    // and the time offset, which is not necessarily zero (and does not support mocking)\n+    //\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a statefull data structure)\n+    int64_t blockTime = clockTime + 5;\n+\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, blockTime), clockTime); // clocktime shall be used\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n+    SetMockTime(20);\n+    int64_t newBlockTime = GetAdjustedTime() + 10;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not changed from the preceeding transaction\n+\n \n     // New transaction should use clock time if there's no block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, 300, 0), 300);\n+    SetMockTime(30);\n+    clockTime = GetAdjustedTime();\n+    blockTime = 0;                                               // block time is not set\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, blockTime), clockTime); // clocktime used, because blocktime was not set (zero)\n \n     // New transaction should use block time if lower than clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, 420, 400), 400);\n+    SetMockTime(40);\n+    clockTime = GetAdjustedTime();\n+    blockTime = clockTime - 2;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, blockTime), blockTime); // blocktime shall be used\n \n     // New transaction should use latest entry time if higher than\n     // min(block time, clock time).\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, 500, 390), 400);\n+    SetMockTime(5);\n+    newBlockTime = blockTime - 5;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, newBlockTime), blockTime); // using the blocktime of the preceeding transaction\n+\n \n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, 50, 600), 300);\n+    SetMockTime(1);\n+    clockTime = GetAdjustedTime();\n+    newBlockTime = clockTime + 1000;                                // this is way too far in the future\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, newBlockTime), blockTime); // the newest entry was the last one\n \n     // Reset mock time for other tests.\n     SetMockTime(0);"
      }
    ]
  },
  {
    "sha": "a92d201a5db95bac243b1b86ef36580015735d8d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOTJkMjAxYTVkYjk1YmFjMjQzYjFiODZlZjM2NTgwMDE1NzM1ZDhk",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-28T20:31:10Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-28T20:31:10Z"
      },
      "message": "Windows 0x0501 does not support inet_pton.",
      "tree": {
        "sha": "141e39c8e693537ec4205edc3e6985a7a6a18b82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/141e39c8e693537ec4205edc3e6985a7a6a18b82"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a92d201a5db95bac243b1b86ef36580015735d8d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a92d201a5db95bac243b1b86ef36580015735d8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a92d201a5db95bac243b1b86ef36580015735d8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a92d201a5db95bac243b1b86ef36580015735d8d/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e72d8d7da0d49ea2c1d769c8b9ad2c9027d947ec"
      }
    ],
    "stats": {
      "total": 194,
      "additions": 109,
      "deletions": 85
    },
    "files": [
      {
        "sha": "926a3ff9e292fdd3bd0d8b4cbb11515234539799",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 85,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a92d201a5db95bac243b1b86ef36580015735d8d/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a92d201a5db95bac243b1b86ef36580015735d8d/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=a92d201a5db95bac243b1b86ef36580015735d8d",
        "patch": "@@ -50,184 +50,208 @@ BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n     BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n }\n \n-CNetAddr UtilBuildAddress(const std::string& address)\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n {\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n     struct sockaddr_in sa;\n-    memset(&sa, 0, sizeof(sockaddr_in));\n-    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n     CNetAddr addr = CNetAddr(sa.sin_addr);\n     return addr;\n }\n \n-void UtilPreconditionIsAtLeastFiveEntriesRequired(const std::string& baseip, int basevalue)\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n {\n-    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n-        int val = basevalue + i;\n-        std::stringstream stream;\n-        stream << baseip << val;\n-        std::string ip = stream.str();\n-        AddTimeData(UtilBuildAddress(ip), val);\n-    }\n-}\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n-{\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n \n+    bool eq = (cn1 == cn2);\n \n-    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n-        AddTimeData(UtilBuildAddress(\"1.1.1.210\"), 210);\n-    }\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n \n-    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+    bool neq = !(cn1 == cn3);\n \n+    BOOST_CHECK(neq);\n \n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.1.211\"), 211);\n+    neq = !(cn2 == cn3);\n \n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n-    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+    BOOST_CHECK(neq);\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n \n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n \n-    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n-        AddTimeData(UtilBuildAddress(\"1.1.1.110\"), 110);\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n \n-    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n \n \n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.1.111\"), 111);\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n \n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.3.\", 50); // precondition 1: at least 5 entries required to compute any offset\n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n \n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n \n-    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 60);\n+    assert(offsetFilter.size() == 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n \n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 61);\n \n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset == offset);                    // ...but new offset was not computed\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWithMedianWithinBounds)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init samplee: 0\n \n \n-    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200 , offsetSample = 200\n \n     BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmOffsetFlipsToZeroIfMedianIsOutsideBounds)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n+\n+    for (int sample = 1; sample < 4; sample++) {                                                     // precondition: 4 samples, all outside bounds\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);                               // 1.1.1.[1,2,3]\n+        AddTimeDataAlgorithm(addr, 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // offsetSample  = 2 * DEFAULT_MAX_TIME_ADJUSTMENT (out of bounds)\n \n-    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << 1 + sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n     } // sorted filter: 0 x x x  -- x is outside the boundaries\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n     // offset is computed only when number of entries is uneven\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x005), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x006), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n-    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x007), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                                        // flip to 1\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x008), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n     BOOST_CHECK_EQUAL(offset, 1);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n-    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x009), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                                        // flip back to zero\n \n     BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n }\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x001), 1, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x002), 2, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x003), 3, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x004), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n     BOOST_CHECK_EQUAL(offset, 2);\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSamplesBeyondInternalCapacity)\n {\n-    int limit = 10;\n+    int capacity = 10; // internal capacity\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n \n \n-    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    for (int sample = 1; sample < capacity; sample++) { // precondition: fill filter up to the capacity\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset);\n     }\n \n-    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), capacity);\n \n     int64_t pre = offset;\n     int size = offsetFilter.size();\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n \n     BOOST_CHECK_EQUAL(offset, pre);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n }\n \n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSampleWithDuplicateIp)\n+{\n+    int capacity = 10; // internal capacity\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n+\n+    int samples = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // new sample was accepted\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 201, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 201\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // sample with duplicate ip was ignored\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "1c5c81ba82a61e742a67501fb5c129b9287a775d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYzVjODFiYTgyYTYxZTc0MmE2NzUwMWZiNWMxMjliOTI4N2E3NzVk",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-28T17:33:29Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-30T16:25:15Z"
      },
      "message": "Tests: Contract testing for the procedure AddTimeData and related fixes",
      "tree": {
        "sha": "387c6e30c3900f65595d52c63060fea73a506464",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/387c6e30c3900f65595d52c63060fea73a506464"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1c5c81ba82a61e742a67501fb5c129b9287a775d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c5c81ba82a61e742a67501fb5c129b9287a775d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1c5c81ba82a61e742a67501fb5c129b9287a775d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c5c81ba82a61e742a67501fb5c129b9287a775d/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86e0a33f5c382513d5179e3fdf158baf952d7e2f"
      }
    ],
    "stats": {
      "total": 322,
      "additions": 286,
      "deletions": 36
    },
    "files": [
      {
        "sha": "d14c58adf6f7147267b3a3abd673321eebece5f3",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "patch": "@@ -291,12 +291,12 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) == 0);\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) < 0);\n }\n \n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const"
      },
      {
        "sha": "578efa6f2c6bbfb927e4c8e6768f0a6e36c7546c",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 209,
        "deletions": 1,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "patch": "@@ -2,8 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n-#include <timedata.h>\n+#include <netaddress.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -34,4 +35,211 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+    bool eq = (cn1 == cn2);\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+    bool neq = !(cn1 == cn3);\n+    BOOST_CHECK(neq);\n+    neq = !(cn2 == cn3);\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    unsigned int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, (unsigned char)sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+    BOOST_CHECK_EQUAL(offsetFilter.size(),10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n+{\n+    unsigned int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, (unsigned char)sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset == offset);                    // ...but new offset was not computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWithMedianWithinBounds)\n+{\n+    unsigned int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n+\n+    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, (unsigned char)sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    int64_t oldOffset = offset;\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200 , offsetSample = 200\n+    BOOST_CHECK(offset != oldOffset);\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmOffsetFlipsToZeroIfMedianIsOutsideBounds)\n+{\n+    unsigned int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n+\n+    for (unsigned int sample = 1; sample < 4; sample++) {                                                     // precondition: 4 samples, all outside bounds\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, (unsigned char)sample);                               // 1.1.1.[1,2,3]\n+        AddTimeDataAlgorithm(addr, 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // offsetSample  = 2 * DEFAULT_MAX_TIME_ADJUSTMENT (out of bounds)\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x005), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x006), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x007), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                                        // flip to 1\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x008), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x009), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                                        // flip back to zero\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    unsigned int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x001), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x002), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x003), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x004), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSamplesBeyondInternalCapacity)\n+{\n+    unsigned int capacity = 10; // internal capacity\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n+\n+    for (unsigned int sample = 1; sample < capacity; sample++) { // precondition: fill filter up to the capacity\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, (unsigned char)sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), capacity);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSampleWithDuplicateIp)\n+{\n+    unsigned int capacity = 10; // internal capacity\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n+\n+    int samples = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // new sample was accepted\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 201, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 201\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // sample with duplicate ip was ignored\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0325c26d780f73817334e5b2eb7242c7e3d89083",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 24,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "patch": "@@ -44,20 +44,36 @@ static int64_t abs64(int64_t n)\n \n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n+\n+static std::set<CNetAddr> setKnown;\n+\n+static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n+\n+int CountOffsetSamples()\n+{\n+    LOCK(cs_nTimeOffset);\n+    return vTimeOffsets.size();\n+}\n+\n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n+\n+    AddTimeDataAlgorithm(ip, nOffsetSample, setKnown, vTimeOffsets, nTimeOffset);\n+}\n+\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset)\n+{\n     // Ignore duplicates\n-    static std::set<CNetAddr> setKnown;\n-    if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n+\n+    if (knownSet.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n-    if (!setKnown.insert(ip).second)\n+    if (!knownSet.insert(ip).second)\n         return;\n \n     // Add data\n-    static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n-    vTimeOffsets.input(nOffsetSample);\n-    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    offsetFilter.input(nOffsetSample);\n+    LogPrint(BCLog::NET, \"added time data, samples %d, offset %+d (%+d minutes)\\n\", offsetFilter.size(), nOffsetSample, nOffsetSample / 60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -76,31 +92,25 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // So we should hold off on fixing this and clean it up as part of\n     // a timing cleanup that strengthens it in a number of other ways.\n     //\n-    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n-        int64_t nMedian = vTimeOffsets.median();\n-        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n+    if (offsetFilter.size() >= 5 && offsetFilter.size() % 2 == 1) {\n+        int64_t nMedian = offsetFilter.median();\n+        std::vector<int64_t> vSorted = offsetFilter.sorted();\n         // Only let other nodes change our time by so much\n-        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT)))\n-        {\n-            nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n-            nTimeOffset = 0;\n+        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT))) {\n+            offset = nMedian;\n+        } else {\n+            offset = 0;\n \n-            static bool fDone;\n-            if (!fDone)\n-            {\n+            static bool gDone;\n+            if (!gDone) {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n                 for (const int64_t nOffset : vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n-                if (!fMatch)\n-                {\n-                    fDone = true;\n+                if (!fMatch) {\n+                    gDone = true;\n                     std::string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n                     SetMiscWarning(strMessage);\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n@@ -114,7 +124,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n             }\n             LogPrint(BCLog::NET, \"|  \"); /* Continued */\n \n-            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", offset, offset / 60);\n         }\n     }\n }"
      },
      {
        "sha": "0206445ddf100387ed48924594e369f4665e0e6a",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <set>\n #include <stdint.h>\n #include <vector>\n \n@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to isolate the contract in AddTimeData */\n+int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);\n+\n #endif // BITCOIN_TIMEDATA_H"
      },
      {
        "sha": "8335af4cb1c3bb25c86a87ed07a2e7f336487cf4",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 9,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c5c81ba82a61e742a67501fb5c129b9287a775d/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "patch": "@@ -12,12 +12,13 @@\n \n #include <consensus/validation.h>\n #include <interfaces/chain.h>\n+#include <policy/policy.h>\n #include <rpc/server.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/test/wallet_test_fixture.h>\n-#include <policy/policy.h>\n \n #include <boost/test/unit_test.hpp>\n #include <univalue.h>\n@@ -258,11 +259,10 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50*COIN);\n }\n \n-static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n+static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t blockTime)\n {\n     CMutableTransaction tx;\n     tx.nLockTime = lockTime;\n-    SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         auto locked_chain = wallet.chain().lock();\n@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which supports mocking)\n+    // and the time offset, which is not necessarily zero (and does not support mocking)\n+    //\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a stateful data structure)\n+    int64_t blockTime = clockTime + 5;\n+\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, blockTime), clockTime); // clocktime shall be used\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n+    SetMockTime(20);\n+    int64_t newBlockTime = GetAdjustedTime() + 10;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not changed from the preceding transaction\n+\n \n     // New transaction should use clock time if there's no block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, 300, 0), 300);\n+    SetMockTime(30);\n+    clockTime = GetAdjustedTime();\n+    blockTime = 0;                                               // block time is not set\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, blockTime), clockTime); // clocktime used, because blocktime was not set (zero)\n \n     // New transaction should use block time if lower than clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, 420, 400), 400);\n+    SetMockTime(40);\n+    clockTime = GetAdjustedTime();\n+    blockTime = clockTime - 2;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, blockTime), blockTime); // blocktime shall be used\n \n     // New transaction should use latest entry time if higher than\n     // min(block time, clock time).\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, 500, 390), 400);\n+    SetMockTime(5);\n+    newBlockTime = blockTime - 5;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, newBlockTime), blockTime); // using the blocktime of the preceding transaction\n+\n \n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, 50, 600), 300);\n+    SetMockTime(1);\n+    clockTime = GetAdjustedTime();\n+    newBlockTime = clockTime + 1000;                                // this is way too far in the future\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, newBlockTime), blockTime); // the newest entry was the last one\n \n     // Reset mock time for other tests.\n     SetMockTime(0);"
      }
    ]
  },
  {
    "sha": "477db9e4dd61159eabfec47e3804454cc3e43a7b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NzdkYjllNGRkNjExNTllYWJmZWM0N2UzODA0NDU0Y2MzZTQzYTdi",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-30T16:43:51Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-30T16:43:51Z"
      },
      "message": "resolved merge conflicts",
      "tree": {
        "sha": "e70c44bf04ad5bebc03991a084304a0244033cf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e70c44bf04ad5bebc03991a084304a0244033cf8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/477db9e4dd61159eabfec47e3804454cc3e43a7b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/477db9e4dd61159eabfec47e3804454cc3e43a7b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/477db9e4dd61159eabfec47e3804454cc3e43a7b/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c5c81ba82a61e742a67501fb5c129b9287a775d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c5c81ba82a61e742a67501fb5c129b9287a775d"
      },
      {
        "sha": "a92d201a5db95bac243b1b86ef36580015735d8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a92d201a5db95bac243b1b86ef36580015735d8d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a92d201a5db95bac243b1b86ef36580015735d8d"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 0,
      "deletions": 3
    },
    "files": [
      {
        "sha": "d46c857a689072b90ccadfa2b81e48ce66e26763",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/477db9e4dd61159eabfec47e3804454cc3e43a7b/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/477db9e4dd61159eabfec47e3804454cc3e43a7b/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=477db9e4dd61159eabfec47e3804454cc3e43a7b",
        "patch": "@@ -297,7 +297,6 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n     //\n     // Tests have to be executed in order, because the individual cases are stateful\n \n-\n     // New transaction should use clock time if lower than block time.\n     SetMockTime(10);\n     int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a stateful data structure)\n@@ -310,7 +309,6 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n     int64_t newBlockTime = GetAdjustedTime() + 10;\n     BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not changed from the preceding transaction\n \n-\n     // New transaction should use clock time if there's no block time.\n     SetMockTime(30);\n     clockTime = GetAdjustedTime();\n@@ -329,7 +327,6 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n     newBlockTime = blockTime - 5;\n     BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, newBlockTime), blockTime); // using the blocktime of the preceding transaction\n \n-\n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n     SetMockTime(1);"
      }
    ]
  }
]