[
  {
    "sha": "78c312c983255e15fc274de2368a2ec13ce81cbf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OGMzMTJjOTgzMjU1ZTE1ZmMyNzRkZTIzNjhhMmVjMTNjZTgxY2Jm",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-06-13T07:37:27Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-06-13T10:24:18Z"
      },
      "message": "Replace current benchmarking framework with nanobench\n\nThis replaces the current benchmarking framework with nanobench [1], an\nMIT licensed single-header benchmarking library, of which I am the\nautor. This has in my opinion several advantages, especially on Linux:\n\n* fast: Running all benchmarks takes ~6 seconds instead of 4m13s on\n  an Intel i7-8700 CPU @ 3.20GHz.\n\n* accurate: I ran e.g. the benchmark for SipHash_32b 10 times and\n  calculate standard deviation / mean = coefficient of variation:\n\n  * 0.57% CV for old benchmarking framework\n  * 0.20% CV for nanobench\n\n  So the benchmark results with nanobench seem to vary less than with\n  the old framework.\n\n* It automatically determines runtime based on clock precision, no need\n  to specify number of evaluations.\n\n* measure instructions, cycles, branches, instructions per cycle,\n  branch misses (only Linux, when performance counters are available)\n\n* output in markdown table format.\n\n* Warn about unstable environment (frequency scaling, turbo, ...)\n\n* For better profiling, it is possible to set the environment variable\n  NANOBENCH_ENDLESS to force endless running of a particular benchmark\n  without the need to recompile. This makes it to e.g. run \"perf top\"\n  and look at hotspots.\n\nHere is an example copy & pasted from the terminal output:\n\n|             ns/byte |              byte/s |    err% |        ins/byte |        cyc/byte |    IPC |       bra/byte |   miss% |     total | benchmark\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\n|                2.52 |      396,529,415.94 |    0.6% |           25.42 |            8.02 |  3.169 |           0.06 |    0.0% |      0.03 | `bench/crypto_hash.cpp RIPEMD160`\n|                1.87 |      535,161,444.83 |    0.3% |           21.36 |            5.95 |  3.589 |           0.06 |    0.0% |      0.02 | `bench/crypto_hash.cpp SHA1`\n|                3.22 |      310,344,174.79 |    1.1% |           36.80 |           10.22 |  3.601 |           0.09 |    0.0% |      0.04 | `bench/crypto_hash.cpp SHA256`\n|                2.01 |      496,375,796.23 |    0.0% |           18.72 |            6.43 |  2.911 |           0.01 |    1.0% |      0.00 | `bench/crypto_hash.cpp SHA256D64_1024`\n|                7.23 |      138,263,519.35 |    0.1% |           82.66 |           23.11 |  3.577 |           1.63 |    0.1% |      0.00 | `bench/crypto_hash.cpp SHA256_32b`\n|                3.04 |      328,780,166.40 |    0.3% |           35.82 |            9.69 |  3.696 |           0.03 |    0.0% |      0.03 | `bench/crypto_hash.cpp SHA512`\n\n[1] https://github.com/martinus/nanobench\n\n* Adds support for asymptotes\n\n  This adds support to calculate asymptotic complexity of a benchmark.\n  This is similar to #17375, but currently only one asymptote is\n  supported, and I have added support in the benchmark `ComplexMemPool`\n  as an example.\n\n  Usage is e.g. like this:\n\n  ```\n  ./bench_bitcoin -filter=ComplexMemPool -asymptote=25,50,100,200,400,600,800\n  ```\n\n  This runs the benchmark `ComplexMemPool` several times but with\n  different complexityN settings. The benchmark can extract that number\n  and use it accordingly. Here, it's used for `childTxs`. The output is\n  this:\n\n  | complexityN |               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\n  |------------:|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\n  |          25 |        1,064,241.00 |              939.64 |    1.4% |    3,960,279.00 |    2,829,708.00 |  1.400 |      0.01 | `ComplexMemPool`\n  |          50 |        1,579,530.00 |              633.10 |    1.0% |    6,231,810.00 |    4,412,674.00 |  1.412 |      0.02 | `ComplexMemPool`\n  |         100 |        4,022,774.00 |              248.58 |    0.6% |   16,544,406.00 |   11,889,535.00 |  1.392 |      0.04 | `ComplexMemPool`\n  |         200 |       15,390,986.00 |               64.97 |    0.2% |   63,904,254.00 |   47,731,705.00 |  1.339 |      0.17 | `ComplexMemPool`\n  |         400 |       69,394,711.00 |               14.41 |    0.1% |  272,602,461.00 |  219,014,691.00 |  1.245 |      0.76 | `ComplexMemPool`\n  |         600 |      168,977,165.00 |                5.92 |    0.1% |  639,108,082.00 |  535,316,887.00 |  1.194 |      1.86 | `ComplexMemPool`\n  |         800 |      310,109,077.00 |                3.22 |    0.1% |1,149,134,246.00 |  984,620,812.00 |  1.167 |      3.41 | `ComplexMemPool`\n\n  |   coefficient |   err% | complexity\n  |--------------:|-------:|------------\n  |   4.78486e-07 |   4.5% | O(n^2)\n  |   6.38557e-10 |  21.7% | O(n^3)\n  |   3.42338e-05 |  38.0% | O(n log n)\n  |   0.000313914 |  46.9% | O(n)\n  |     0.0129823 | 114.4% | O(log n)\n  |     0.0815055 | 133.8% | O(1)\n\n  The best fitting curve is O(n^2), so the algorithm seems to scale\n  quadratic with `childTxs` in the range 25 to 800.",
      "tree": {
        "sha": "09c5cec9b0b3f7ef2aa9364057858861c134cf45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/09c5cec9b0b3f7ef2aa9364057858861c134cf45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78c312c983255e15fc274de2368a2ec13ce81cbf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78c312c983255e15fc274de2368a2ec13ce81cbf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/78c312c983255e15fc274de2368a2ec13ce81cbf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78c312c983255e15fc274de2368a2ec13ce81cbf/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "19e919217e6d62e3640525e4149de1a4ae04e74f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19e919217e6d62e3640525e4149de1a4ae04e74f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/19e919217e6d62e3640525e4149de1a4ae04e74f"
      }
    ],
    "stats": {
      "total": 4217,
      "additions": 3644,
      "deletions": 573
    },
    "files": [
      {
        "sha": "287c8a7f5620e0e206512985ac32aaae9bdb9cfd",
        "filename": ".appveyor.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -75,7 +75,7 @@ after_build:\n #- 7z a bitcoin-%APPVEYOR_BUILD_VERSION%.zip %APPVEYOR_BUILD_FOLDER%\\build_msvc\\%platform%\\%configuration%\\*.exe\n test_script:\n - cmd: src\\test_bitcoin.exe -l test_suite\n-- cmd: src\\bench_bitcoin.exe -evals=1 -scaling=0 > NUL\n+- cmd: src\\bench_bitcoin.exe > NUL\n - ps:  python test\\util\\bitcoin-util-test.py\n - cmd: python test\\util\\rpcauth-test.py\n # Fee estimation test failing on appveyor with: WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted."
      },
      {
        "sha": "9a555c70bb490add4f055da0f58e9100a396584f",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -22,6 +22,7 @@\n     'src/reverse_iterator.h',\n     'src/test/fuzz/FuzzedDataProvider.h',\n     'src/tinyformat.h',\n+    'src/bench/nanobench.h',\n     'test/functional/test_framework/bignum.py',\n     # python init:\n     '*__init__.py',"
      },
      {
        "sha": "b6cd86eafe6e7df2f81da7e0835239a40c476a24",
        "filename": "doc/benchmarking.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/doc/benchmarking.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/doc/benchmarking.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/benchmarking.md?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -19,8 +19,10 @@ After compiling bitcoin-core, the benchmarks can be run with:\n \n The output will look similar to:\n ```\n-# Benchmark, evals, iterations, total, min, max, median\n-AssembleBlock, 5, 700, 1.79954, 0.000510913, 0.000517018, 0.000514497\n+|             ns/byte |              byte/s | error % | benchmark\n+|--------------------:|--------------------:|--------:|:----------------------------------------------\n+|               64.13 |       15,592,356.01 |    0.1% | `Base58CheckEncode`\n+|               24.56 |       40,722,672.68 |    0.2% | `Base58Decode`\n ...\n ```\n "
      },
      {
        "sha": "c224ca7bf6507271c33c560799b6f53b425b1e9a",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -33,6 +33,8 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/merkle_root.cpp \\\n   bench/mempool_eviction.cpp \\\n   bench/mempool_stress.cpp \\\n+  bench/nanobench.h \\\n+  bench/nanobench.cpp \\\n   bench/rpc_blockchain.cpp \\\n   bench/rpc_mempool.cpp \\\n   bench/util_time.cpp \\"
      },
      {
        "sha": "75b1a14e366bd8fec45a8748efc8746e67a56f3c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -1151,8 +1151,8 @@ endif\n if TARGET_WINDOWS\n else\n if ENABLE_BENCH\n-\t@echo \"Running bench/bench_bitcoin -evals=1 -scaling=0...\"\n-\t$(BENCH_BINARY) -evals=1 -scaling=0 > /dev/null\n+\t@echo \"Running bench/bench_bitcoin ...\"\n+\t$(BENCH_BINARY) > /dev/null\n endif\n endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check"
      },
      {
        "sha": "26d9340768290b8116bc327ec1547e9ca7e42097",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -67,52 +67,52 @@ static void FillAddrMan(CAddrMan& addrman)\n \n /* Benchmarks */\n \n-static void AddrManAdd(benchmark::State& state)\n+static void AddrManAdd(benchmark::Bench& bench)\n {\n     CreateAddresses();\n \n     CAddrMan addrman;\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         AddAddressesToAddrMan(addrman);\n         addrman.Clear();\n-    }\n+    });\n }\n \n-static void AddrManSelect(benchmark::State& state)\n+static void AddrManSelect(benchmark::Bench& bench)\n {\n     CAddrMan addrman;\n \n     FillAddrMan(addrman);\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         const auto& address = addrman.Select();\n         assert(address.GetPort() > 0);\n-    }\n+    });\n }\n \n-static void AddrManGetAddr(benchmark::State& state)\n+static void AddrManGetAddr(benchmark::Bench& bench)\n {\n     CAddrMan addrman;\n \n     FillAddrMan(addrman);\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         const auto& addresses = addrman.GetAddr();\n         assert(addresses.size() > 0);\n-    }\n+    });\n }\n \n-static void AddrManGood(benchmark::State& state)\n+static void AddrManGood(benchmark::Bench& bench)\n {\n     /* Create many CAddrMan objects - one to be modified at each loop iteration.\n      * This is necessary because the CAddrMan::Good() method modifies the\n      * object, affecting the timing of subsequent calls to the same method and\n      * we want to do the same amount of work in every loop iteration. */\n \n-    const uint64_t numLoops = state.m_num_iters * state.m_num_evals;\n+    bench.epochs(5).epochIterations(1);\n \n-    std::vector<CAddrMan> addrmans(numLoops);\n+    std::vector<CAddrMan> addrmans(bench.epochs() * bench.epochIterations());\n     for (auto& addrman : addrmans) {\n         FillAddrMan(addrman);\n     }\n@@ -128,13 +128,13 @@ static void AddrManGood(benchmark::State& state)\n     };\n \n     uint64_t i = 0;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         markSomeAsGood(addrmans.at(i));\n         ++i;\n-    }\n+    });\n }\n \n-BENCHMARK(AddrManAdd, 5);\n-BENCHMARK(AddrManSelect, 1000000);\n-BENCHMARK(AddrManGetAddr, 500);\n-BENCHMARK(AddrManGood, 2);\n+BENCHMARK(AddrManAdd);\n+BENCHMARK(AddrManSelect);\n+BENCHMARK(AddrManGetAddr);\n+BENCHMARK(AddrManGood);"
      },
      {
        "sha": "00544cba315a3f6269e2851ec54845569caa0ea7",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -10,7 +10,7 @@\n #include <vector>\n \n \n-static void Base58Encode(benchmark::State& state)\n+static void Base58Encode(benchmark::Bench& bench)\n {\n     static const std::array<unsigned char, 32> buff = {\n         {\n@@ -19,13 +19,13 @@ static void Base58Encode(benchmark::State& state)\n             200, 24\n         }\n     };\n-    while (state.KeepRunning()) {\n+    bench.batch(buff.size()).unit(\"byte\").run([&] {\n         EncodeBase58(buff.data(), buff.data() + buff.size());\n-    }\n+    });\n }\n \n \n-static void Base58CheckEncode(benchmark::State& state)\n+static void Base58CheckEncode(benchmark::Bench& bench)\n {\n     static const std::array<unsigned char, 32> buff = {\n         {\n@@ -36,22 +36,22 @@ static void Base58CheckEncode(benchmark::State& state)\n     };\n     std::vector<unsigned char> vch;\n     vch.assign(buff.begin(), buff.end());\n-    while (state.KeepRunning()) {\n+    bench.batch(buff.size()).unit(\"byte\").run([&] {\n         EncodeBase58Check(vch);\n-    }\n+    });\n }\n \n \n-static void Base58Decode(benchmark::State& state)\n+static void Base58Decode(benchmark::Bench& bench)\n {\n     const char* addr = \"17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem\";\n     std::vector<unsigned char> vch;\n-    while (state.KeepRunning()) {\n+    bench.batch(strlen(addr)).unit(\"byte\").run([&] {\n         (void) DecodeBase58(addr, vch, 64);\n-    }\n+    });\n }\n \n \n-BENCHMARK(Base58Encode, 470 * 1000);\n-BENCHMARK(Base58CheckEncode, 320 * 1000);\n-BENCHMARK(Base58Decode, 800 * 1000);\n+BENCHMARK(Base58Encode);\n+BENCHMARK(Base58CheckEncode);\n+BENCHMARK(Base58Decode);"
      },
      {
        "sha": "c74d8d51b3fa42f2b2c2f0ef4a6f4278f59fdcb5",
        "filename": "src/bench/bech32.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bech32.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n+#include <bench/nanobench.h>\n \n #include <bech32.h>\n #include <util/strencodings.h>\n@@ -11,26 +12,26 @@\n #include <vector>\n \n \n-static void Bech32Encode(benchmark::State& state)\n+static void Bech32Encode(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> v = ParseHex(\"c97f5a67ec381b760aeaf67573bc164845ff39a3bb26a1cee401ac67243b48db\");\n     std::vector<unsigned char> tmp = {0};\n     tmp.reserve(1 + 32 * 8 / 5);\n     ConvertBits<8, 5, true>([&](unsigned char c) { tmp.push_back(c); }, v.begin(), v.end());\n-    while (state.KeepRunning()) {\n+    bench.batch(v.size()).unit(\"byte\").run([&] {\n         bech32::Encode(\"bc\", tmp);\n-    }\n+    });\n }\n \n \n-static void Bech32Decode(benchmark::State& state)\n+static void Bech32Decode(benchmark::Bench& bench)\n {\n     std::string addr = \"bc1qkallence7tjawwvy0dwt4twc62qjgaw8f4vlhyd006d99f09\";\n-    while (state.KeepRunning()) {\n+    bench.batch(addr.size()).unit(\"byte\").run([&] {\n         bech32::Decode(addr);\n-    }\n+    });\n }\n \n \n-BENCHMARK(Bech32Encode, 800 * 1000);\n-BENCHMARK(Bech32Decode, 800 * 1000);\n+BENCHMARK(Bech32Encode);\n+BENCHMARK(Bech32Decode);"
      },
      {
        "sha": "01466d0b6f34a2b761115cb5b908cb920d31a335",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 104,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -8,141 +8,73 @@\n #include <test/util/setup_common.h>\n #include <validation.h>\n \n-#include <algorithm>\n-#include <assert.h>\n-#include <iomanip>\n-#include <iostream>\n-#include <numeric>\n #include <regex>\n \n const std::function<void(const std::string&)> G_TEST_LOG_FUN{};\n \n-void benchmark::ConsolePrinter::header()\n-{\n-    std::cout << \"# Benchmark, evals, iterations, total, min, max, median\" << std::endl;\n-}\n+namespace {\n \n-void benchmark::ConsolePrinter::result(const State& state)\n+void GenerateTemplateResults(const std::vector<ankerl::nanobench::Result>& benchmarkResults, const std::string& filename, const char* tpl)\n {\n-    auto results = state.m_elapsed_results;\n-    std::sort(results.begin(), results.end());\n-\n-    double total = state.m_num_iters * std::accumulate(results.begin(), results.end(), 0.0);\n-\n-    double front = 0;\n-    double back = 0;\n-    double median = 0;\n-\n-    if (!results.empty()) {\n-        front = results.front();\n-        back = results.back();\n-\n-        size_t mid = results.size() / 2;\n-        median = results[mid];\n-        if (0 == results.size() % 2) {\n-            median = (results[mid] + results[mid + 1]) / 2;\n-        }\n+    if (benchmarkResults.empty() || filename.empty()) {\n+        // nothing to write, bail out\n+        return;\n     }\n-\n-    std::cout << std::setprecision(6);\n-    std::cout << state.m_name << \", \" << state.m_num_evals << \", \" << state.m_num_iters << \", \" << total << \", \" << front << \", \" << back << \", \" << median << std::endl;\n-}\n-\n-void benchmark::ConsolePrinter::footer() {}\n-benchmark::PlotlyPrinter::PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height)\n-    : m_plotly_url(plotly_url), m_width(width), m_height(height)\n-{\n-}\n-\n-void benchmark::PlotlyPrinter::header()\n-{\n-    std::cout << \"<html><head>\"\n-              << \"<script src=\\\"\" << m_plotly_url << \"\\\"></script>\"\n-              << \"</head><body><div id=\\\"myDiv\\\" style=\\\"width:\" << m_width << \"px; height:\" << m_height << \"px\\\"></div>\"\n-              << \"<script> var data = [\"\n-              << std::endl;\n-}\n-\n-void benchmark::PlotlyPrinter::result(const State& state)\n-{\n-    std::cout << \"{ \" << std::endl\n-              << \"  name: '\" << state.m_name << \"', \" << std::endl\n-              << \"  y: [\";\n-\n-    const char* prefix = \"\";\n-    for (const auto& e : state.m_elapsed_results) {\n-        std::cout << prefix << std::setprecision(6) << e;\n-        prefix = \", \";\n+    std::ofstream fout(filename);\n+    if (fout.is_open()) {\n+        ankerl::nanobench::render(tpl, benchmarkResults, fout);\n+    } else {\n+        std::cout << \"Could write to file '\" << filename << \"'\" << std::endl;\n     }\n-    std::cout << \"],\" << std::endl\n-              << \"  boxpoints: 'all', jitter: 0.3, pointpos: 0, type: 'box',\"\n-              << std::endl\n-              << \"},\" << std::endl;\n-}\n \n-void benchmark::PlotlyPrinter::footer()\n-{\n-    std::cout << \"]; var layout = { showlegend: false, yaxis: { rangemode: 'tozero', autorange: true } };\"\n-              << \"Plotly.newPlot('myDiv', data, layout);\"\n-              << \"</script></body></html>\";\n+    std::cout << \"Created '\" << filename << \"'\" << std::endl;\n }\n \n+} // namespace\n \n benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n {\n-    static std::map<std::string, Bench> benchmarks_map;\n+    static std::map<std::string, BenchFunction> benchmarks_map;\n     return benchmarks_map;\n }\n \n-benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func, uint64_t num_iters_for_one_second)\n+benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func)\n {\n-    benchmarks().insert(std::make_pair(name, Bench{func, num_iters_for_one_second}));\n+    benchmarks().insert(std::make_pair(name, func));\n }\n \n-void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n+void benchmark::BenchRunner::RunAll(const Args& args)\n {\n-    if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n-        std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n-    }\n-#ifdef DEBUG\n-    std::cerr << \"WARNING: This is a debug build - may result in slower benchmarks.\\n\";\n-#endif\n-\n-    std::regex reFilter(filter);\n+    std::regex reFilter(args.regex_filter);\n     std::smatch baseMatch;\n \n-    printer.header();\n-\n+    std::vector<ankerl::nanobench::Result> benchmarkResults;\n     for (const auto& p : benchmarks()) {\n         if (!std::regex_match(p.first, baseMatch, reFilter)) {\n             continue;\n         }\n \n-        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n-            num_iters = 1;\n-        }\n-        State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n-            p.second.func(state);\n+        if (args.is_list_only) {\n+            std::cout << p.first << std::endl;\n+            continue;\n         }\n-        printer.result(state);\n-    }\n-\n-    printer.footer();\n-}\n-\n-bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n-{\n-    if (m_start_time != time_point()) {\n-        std::chrono::duration<double> diff = current_time - m_start_time;\n-        m_elapsed_results.push_back(diff.count() / m_num_iters);\n \n-        if (m_elapsed_results.size() == m_num_evals) {\n-            return false;\n+        Bench bench;\n+        bench.name(p.first);\n+        if (args.asymptote.empty()) {\n+            p.second(bench);\n+        } else {\n+            for (auto n : args.asymptote) {\n+                bench.complexityN(n);\n+                p.second(bench);\n+            }\n+            std::cout << bench.complexityBigO() << std::endl;\n         }\n+        benchmarkResults.push_back(bench.results().back());\n     }\n \n-    m_num_iters_left = m_num_iters - 1;\n-    return true;\n+    GenerateTemplateResults(benchmarkResults, args.output_csv, \"# Benchmark, evals, iterations, total, min, max, median\\n\"\n+                                                               \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n+                                                               \"{{/result}}\");\n+    GenerateTemplateResults(benchmarkResults, args.output_json, ankerl::nanobench::templates::json());\n }"
      },
      {
        "sha": "bafc7f8716a12bef749ce155e894dc67c7224c16",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 19,
        "deletions": 97,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -11,131 +11,53 @@\n #include <string>\n #include <vector>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using ankerl::nanobench::Bench;\n \n-    State(std::string name, uint64_t num_evals, double num_iters, Printer& printer) : m_name(name), m_num_iters_left(0), m_num_iters(num_iters), m_num_evals(num_evals)\n-    {\n-    }\n+typedef std::function<void(Bench&)> BenchFunction;\n \n-    inline bool KeepRunning()\n-    {\n-        if (m_num_iters_left--) {\n-            return true;\n-        }\n-\n-        bool result = UpdateTimer(clock::now());\n-        // measure again so runtime of UpdateTimer is not included\n-        m_start_time = clock::now();\n-        return result;\n-    }\n+struct Args {\n+    std::string regex_filter;\n+    bool is_list_only;\n+    std::vector<double> asymptote;\n+    std::string output_csv;\n+    std::string output_json;\n };\n \n-typedef std::function<void(State&)> BenchFunction;\n-\n class BenchRunner\n {\n-    struct Bench {\n-        BenchFunction func;\n-        uint64_t num_iters_for_one_second;\n-    };\n-    typedef std::map<std::string, Bench> BenchmarkMap;\n+    typedef std::map<std::string, BenchFunction> BenchmarkMap;\n     static BenchmarkMap& benchmarks();\n \n public:\n-    BenchRunner(std::string name, BenchFunction func, uint64_t num_iters_for_one_second);\n-\n-    static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only);\n-};\n+    BenchRunner(std::string name, BenchFunction func);\n \n-// interface to output benchmark results.\n-class Printer\n-{\n-public:\n-    virtual ~Printer() {}\n-    virtual void header() = 0;\n-    virtual void result(const State& state) = 0;\n-    virtual void footer() = 0;\n-};\n-\n-// default printer to console, shows min, max, median.\n-class ConsolePrinter : public Printer\n-{\n-public:\n-    void header() override;\n-    void result(const State& state) override;\n-    void footer() override;\n-};\n-\n-// creates box plot with plotly.js\n-class PlotlyPrinter : public Printer\n-{\n-public:\n-    PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height);\n-    void header() override;\n-    void result(const State& state) override;\n-    void footer() override;\n-\n-private:\n-    std::string m_plotly_url;\n-    int64_t m_width;\n-    int64_t m_height;\n+    static void RunAll(const Args& args);\n };\n }\n-\n-\n-// BENCHMARK(foo, num_iters_for_one_second) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", num_iterations);\n-// Choose a num_iters_for_one_second that takes roughly 1 second. The goal is that all benchmarks should take approximately\n-// the same time, and scaling factor can be used that the total time is appropriate for your system.\n-#define BENCHMARK(n, num_iters_for_one_second) \\\n-    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n, (num_iters_for_one_second));\n+// BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\");\n+#define BENCHMARK(n) \\\n+    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n);\n \n #endif // BITCOIN_BENCH_BENCH_H"
      },
      {
        "sha": "981800c68e657bac66b92c77f1f0332a935506a2",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 40,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -9,26 +9,30 @@\n \n #include <memory>\n \n-static const int64_t DEFAULT_BENCH_EVALUATIONS = 5;\n static const char* DEFAULT_BENCH_FILTER = \".*\";\n-static const char* DEFAULT_BENCH_SCALING = \"1.0\";\n-static const char* DEFAULT_BENCH_PRINTER = \"console\";\n-static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.min.js\";\n-static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n-static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n static void SetupBenchArgs(ArgsManager& argsman)\n {\n     SetupHelpOptions(argsman);\n \n-    argsman.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-evals=<n>\", strprintf(\"Number of measurement evaluations to perform. (default: %u)\", DEFAULT_BENCH_EVALUATIONS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-list\", \"List benchmarks without executing them\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-scaling=<n>\", strprintf(\"Scaling factor for benchmark's runtime (default: %u)\", DEFAULT_BENCH_SCALING), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-printer=(console|plot)\", strprintf(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\", DEFAULT_BENCH_PRINTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(\"URL to use for plotly.js (default: %s)\", DEFAULT_PLOT_PLOTLYURL), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-plot-width=<x>\", strprintf(\"Plot width in pixel (default: %u)\", DEFAULT_PLOT_WIDTH), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    argsman.AddArg(\"-plot-height=<x>\", strprintf(\"Plot height in pixel (default: %u)\", DEFAULT_PLOT_HEIGHT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-asymptote=n1,n2,n3,...\", strprintf(\"Test asymptotic growth of the runtime of an algorithm, if supported by the benchmark\"), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-output_csv=<output.csv>\", \"Generate CSV file with the most important benchmark results.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-output_json=<output.json>\", \"Generate JSON file with all benchmark results.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+}\n+\n+// parses a comma separated list like \"10,20,30,50\"\n+static std::vector<double> parseAsymptote(const std::string& str) {\n+    std::stringstream ss(str);\n+    std::vector<double> numbers;\n+    double d;\n+    char c;\n+    while (ss >> d) {\n+        numbers.push_back(d);\n+        ss >> c;\n+    }\n+    return numbers;\n }\n \n int main(int argc, char** argv)\n@@ -47,34 +51,14 @@ int main(int argc, char** argv)\n         return EXIT_SUCCESS;\n     }\n \n-    int64_t evaluations = argsman.GetArg(\"-evals\", DEFAULT_BENCH_EVALUATIONS);\n-    std::string regex_filter = argsman.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n-    std::string scaling_str = argsman.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);\n-    bool is_list_only = argsman.GetBoolArg(\"-list\", false);\n-\n-    if (evaluations == 0) {\n-        return EXIT_SUCCESS;\n-    } else if (evaluations < 0) {\n-        tfm::format(std::cerr, \"Error parsing evaluations argument: %d\\n\", evaluations);\n-        return EXIT_FAILURE;\n-    }\n-\n-    double scaling_factor;\n-    if (!ParseDouble(scaling_str, &scaling_factor)) {\n-        tfm::format(std::cerr, \"Error parsing scaling factor as double: %s\\n\", scaling_str);\n-        return EXIT_FAILURE;\n-    }\n-\n-    std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();\n-    std::string printer_arg = argsman.GetArg(\"-printer\", DEFAULT_BENCH_PRINTER);\n-    if (\"plot\" == printer_arg) {\n-        printer.reset(new benchmark::PlotlyPrinter(\n-            argsman.GetArg(\"-plot-plotlyurl\", DEFAULT_PLOT_PLOTLYURL),\n-            argsman.GetArg(\"-plot-width\", DEFAULT_PLOT_WIDTH),\n-            argsman.GetArg(\"-plot-height\", DEFAULT_PLOT_HEIGHT)));\n-    }\n+    benchmark::Args args;\n+    args.regex_filter = argsman.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n+    args.is_list_only = argsman.GetBoolArg(\"-list\", false);\n+    args.asymptote = parseAsymptote(argsman.GetArg(\"-asymptote\", \"\"));\n+    args.output_csv = argsman.GetArg(\"-output_csv\", \"\");\n+    args.output_json = argsman.GetArg(\"-output_json\", \"\");\n \n-    benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n+    benchmark::BenchRunner::RunAll(args);\n \n     return EXIT_SUCCESS;\n }"
      },
      {
        "sha": "3f15f3f856940524461f13c834705e6697ce0be3",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -14,7 +14,7 @@\n \n #include <vector>\n \n-static void AssembleBlock(benchmark::State& state)\n+static void AssembleBlock(benchmark::Bench& bench)\n {\n     TestingSetup test_setup{\n         CBaseChainParams::REGTEST,\n@@ -54,9 +54,9 @@ static void AssembleBlock(benchmark::State& state)\n         }\n     }\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         PrepareBlock(test_setup.m_node, SCRIPT_PUB);\n-    }\n+    });\n }\n \n-BENCHMARK(AssembleBlock, 700);\n+BENCHMARK(AssembleBlock);"
      },
      {
        "sha": "116de98b149d4eeb189dd0c09a95d7127a7fda1a",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -16,7 +16,7 @@\n // characteristics than e.g. reindex timings. But that's not a requirement of\n // every benchmark.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n-static void CCoinsCaching(benchmark::State& state)\n+static void CCoinsCaching(benchmark::Bench& bench)\n {\n     const ECCVerifyHandle verify_handle;\n     ECC_Start();\n@@ -44,11 +44,11 @@ static void CCoinsCaching(benchmark::State& state)\n \n     // Benchmark.\n     const CTransaction tx_1(t1);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         bool success = AreInputsStandard(tx_1, coins);\n         assert(success);\n-    }\n+    });\n     ECC_Stop();\n }\n \n-BENCHMARK(CCoinsCaching, 170 * 1000);\n+BENCHMARK(CCoinsCaching);"
      },
      {
        "sha": "913e0f8d575a96cb62b96596812141919bb7d2a2",
        "filename": "src/bench/chacha20.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha20.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -11,34 +11,34 @@ static const uint64_t BUFFER_SIZE_TINY  = 64;\n static const uint64_t BUFFER_SIZE_SMALL = 256;\n static const uint64_t BUFFER_SIZE_LARGE = 1024*1024;\n \n-static void CHACHA20(benchmark::State& state, size_t buffersize)\n+static void CHACHA20(benchmark::Bench& bench, size_t buffersize)\n {\n     std::vector<uint8_t> key(32,0);\n     ChaCha20 ctx(key.data(), key.size());\n     ctx.SetIV(0);\n     ctx.Seek(0);\n     std::vector<uint8_t> in(buffersize,0);\n     std::vector<uint8_t> out(buffersize,0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         ctx.Crypt(in.data(), out.data(), in.size());\n-    }\n+    });\n }\n \n-static void CHACHA20_64BYTES(benchmark::State& state)\n+static void CHACHA20_64BYTES(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_TINY);\n+    CHACHA20(bench, BUFFER_SIZE_TINY);\n }\n \n-static void CHACHA20_256BYTES(benchmark::State& state)\n+static void CHACHA20_256BYTES(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_SMALL);\n+    CHACHA20(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void CHACHA20_1MB(benchmark::State& state)\n+static void CHACHA20_1MB(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_LARGE);\n+    CHACHA20(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(CHACHA20_64BYTES, 500000);\n-BENCHMARK(CHACHA20_256BYTES, 250000);\n-BENCHMARK(CHACHA20_1MB, 340);\n+BENCHMARK(CHACHA20_64BYTES);\n+BENCHMARK(CHACHA20_256BYTES);\n+BENCHMARK(CHACHA20_1MB);"
      },
      {
        "sha": "30d7851b7f6b3860e08ff4d8911ef83bec250d71",
        "filename": "src/bench/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 32,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha_poly_aead.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -21,15 +21,15 @@ static const unsigned char k2[32] = {0};\n \n static ChaCha20Poly1305AEAD aead(k1, 32, k2, 32);\n \n-static void CHACHA20_POLY1305_AEAD(benchmark::State& state, size_t buffersize, bool include_decryption)\n+static void CHACHA20_POLY1305_AEAD(benchmark::Bench& bench, size_t buffersize, bool include_decryption)\n {\n     std::vector<unsigned char> in(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> out(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     uint64_t seqnr_payload = 0;\n     uint64_t seqnr_aad = 0;\n     int aad_pos = 0;\n     uint32_t len = 0;\n-    while (state.KeepRunning()) {\n+    bench.batch(buffersize).unit(\"byte\").run([&] {\n         // encrypt or decrypt the buffer with a static key\n         assert(aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true));\n \n@@ -53,70 +53,71 @@ static void CHACHA20_POLY1305_AEAD(benchmark::State& state, size_t buffersize, b\n             seqnr_aad = 0;\n             aad_pos = 0;\n         }\n-    }\n+    });\n }\n \n-static void CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_TINY, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_TINY, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_SMALL, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_SMALL, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_LARGE, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_LARGE, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_TINY, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_TINY, true);\n }\n \n-static void CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_SMALL, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_SMALL, true);\n }\n \n-static void CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_LARGE, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_LARGE, true);\n }\n \n // Add Hash() (dbl-sha256) bench for comparison\n \n-static void HASH(benchmark::State& state, size_t buffersize)\n+static void HASH(benchmark::Bench& bench, size_t buffersize)\n {\n     uint8_t hash[CHash256::OUTPUT_SIZE];\n     std::vector<uint8_t> in(buffersize,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CHash256().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void HASH_64BYTES(benchmark::State& state)\n+static void HASH_64BYTES(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_TINY);\n+    HASH(bench, BUFFER_SIZE_TINY);\n }\n \n-static void HASH_256BYTES(benchmark::State& state)\n+static void HASH_256BYTES(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_SMALL);\n+    HASH(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void HASH_1MB(benchmark::State& state)\n+static void HASH_1MB(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_LARGE);\n+    HASH(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT, 500000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT, 250000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT, 340);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT, 500000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT, 250000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT, 340);\n-BENCHMARK(HASH_64BYTES, 500000);\n-BENCHMARK(HASH_256BYTES, 250000);\n-BENCHMARK(HASH_1MB, 340);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT);\n+BENCHMARK(HASH_64BYTES);\n+BENCHMARK(HASH_256BYTES);\n+BENCHMARK(HASH_1MB);"
      },
      {
        "sha": "dc0aa4031c9b9de484edea232b852f33420e4cd2",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -14,29 +14,29 @@\n // a block off the wire, but before we can relay the block on to peers using\n // compact block relay.\n \n-static void DeserializeBlockTest(benchmark::State& state)\n+static void DeserializeBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"block\").run([&] {\n         CBlock block;\n         stream >> block;\n         bool rewound = stream.Rewind(benchmark::data::block413567.size());\n         assert(rewound);\n-    }\n+    });\n }\n \n-static void DeserializeAndCheckBlockTest(benchmark::State& state)\n+static void DeserializeAndCheckBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"block\").run([&] {\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         bool rewound = stream.Rewind(benchmark::data::block413567.size());\n@@ -45,8 +45,8 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n         BlockValidationState validationState;\n         bool checked = CheckBlock(block, validationState, chainParams->GetConsensus());\n         assert(checked);\n-    }\n+    });\n }\n \n-BENCHMARK(DeserializeBlockTest, 130);\n-BENCHMARK(DeserializeAndCheckBlockTest, 160);\n+BENCHMARK(DeserializeBlockTest);\n+BENCHMARK(DeserializeAndCheckBlockTest);"
      },
      {
        "sha": "19d7bc0dbc9cf5da783888105eff3535eee50165",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -24,7 +24,7 @@ static const unsigned int QUEUE_BATCH_SIZE = 128;\n // This Benchmark tests the CheckQueue with a slightly realistic workload,\n // where checks all contain a prevector that is indirect 50% of the time\n // and there is a little bit of work done between calls to Add.\n-static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n+static void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)\n {\n     const ECCVerifyHandle verify_handle;\n     ECC_Start();\n@@ -47,23 +47,28 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) {\n        tg.create_thread([&]{queue.Thread();});\n     }\n-    while (state.KeepRunning()) {\n+\n+    // create all the data once, then submit copies in the benchmark.\n+    FastRandomContext insecure_rand(true);\n+    std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n+    for (auto& vChecks : vBatches) {\n+        vChecks.reserve(BATCH_SIZE);\n+        for (size_t x = 0; x < BATCH_SIZE; ++x)\n+            vChecks.emplace_back(insecure_rand);\n+    }\n+\n+    bench.minEpochIterations(10).batch(BATCH_SIZE * BATCHES).unit(\"job\").run([&] {\n         // Make insecure_rand here so that each iteration is identical.\n-        FastRandomContext insecure_rand(true);\n         CCheckQueueControl<PrevectorJob> control(&queue);\n-        std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n-            vChecks.reserve(BATCH_SIZE);\n-            for (size_t x = 0; x < BATCH_SIZE; ++x)\n-                vChecks.emplace_back(insecure_rand);\n+        for (auto vChecks : vBatches) {\n             control.Add(vChecks);\n         }\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity\n         control.Wait();\n-    }\n+    });\n     tg.interrupt_all();\n     tg.join_all();\n     ECC_Stop();\n }\n-BENCHMARK(CCheckQueueSpeedPrevectorJob, 1400);\n+BENCHMARK(CCheckQueueSpeedPrevectorJob);"
      },
      {
        "sha": "6106b7977cb26fe6ae9d5026c79d70eb920848da",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -27,7 +27,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n // same one over and over isn't too useful. Generating random isn't useful\n // either for measurements.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n-static void CoinSelection(benchmark::State& state)\n+static void CoinSelection(benchmark::Bench& bench)\n {\n     NodeContext node;\n     auto chain = interfaces::MakeChain(node);\n@@ -51,15 +51,15 @@ static void CoinSelection(benchmark::State& state)\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n     const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n-    }\n+    });\n }\n \n typedef std::set<CInputCoin> CoinSet;\n@@ -91,7 +91,7 @@ static CAmount make_hard_case(int utxos, std::vector<OutputGroup>& utxo_pool)\n     return target;\n }\n \n-static void BnBExhaustion(benchmark::State& state)\n+static void BnBExhaustion(benchmark::Bench& bench)\n {\n     // Setup\n     testWallet.SetupLegacyScriptPubKeyMan();\n@@ -100,16 +100,16 @@ static void BnBExhaustion(benchmark::State& state)\n     CAmount value_ret = 0;\n     CAmount not_input_fees = 0;\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         // Benchmark\n         CAmount target = make_hard_case(17, utxo_pool);\n         SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n \n         // Cleanup\n         utxo_pool.clear();\n         selection.clear();\n-    }\n+    });\n }\n \n-BENCHMARK(CoinSelection, 650);\n-BENCHMARK(BnBExhaustion, 650);\n+BENCHMARK(CoinSelection);\n+BENCHMARK(BnBExhaustion);"
      },
      {
        "sha": "36be86bcc82edcc6dfd56ae9f77a0ee9546dc40b",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 32,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -16,88 +16,92 @@\n /* Number of bytes to hash per iteration */\n static const uint64_t BUFFER_SIZE = 1000*1000;\n \n-static void RIPEMD160(benchmark::State& state)\n+static void RIPEMD160(benchmark::Bench& bench)\n {\n     uint8_t hash[CRIPEMD160::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CRIPEMD160().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA1(benchmark::State& state)\n+static void SHA1(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA1::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA1().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA256(benchmark::State& state)\n+static void SHA256(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA256::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA256().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA256_32b(benchmark::State& state)\n+static void SHA256_32b(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> in(32,0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA256()\n             .Write(in.data(), in.size())\n             .Finalize(in.data());\n-    }\n+    });\n }\n \n-static void SHA256D64_1024(benchmark::State& state)\n+static void SHA256D64_1024(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> in(64 * 1024, 0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         SHA256D64(in.data(), in.data(), 1024);\n-    }\n+    });\n }\n \n-static void SHA512(benchmark::State& state)\n+static void SHA512(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA512::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA512().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SipHash_32b(benchmark::State& state)\n+static void SipHash_32b(benchmark::Bench& bench)\n {\n     uint256 x;\n     uint64_t k1 = 0;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         *((uint64_t*)x.begin()) = SipHashUint256(0, ++k1, x);\n-    }\n+    });\n }\n \n-static void FastRandom_32bit(benchmark::State& state)\n+static void FastRandom_32bit(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         rng.rand32();\n-    }\n+    });\n }\n \n-static void FastRandom_1bit(benchmark::State& state)\n+static void FastRandom_1bit(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         rng.randbool();\n-    }\n+    });\n }\n \n-BENCHMARK(RIPEMD160, 440);\n-BENCHMARK(SHA1, 570);\n-BENCHMARK(SHA256, 340);\n-BENCHMARK(SHA512, 330);\n+BENCHMARK(RIPEMD160);\n+BENCHMARK(SHA1);\n+BENCHMARK(SHA256);\n+BENCHMARK(SHA512);\n \n-BENCHMARK(SHA256_32b, 4700 * 1000);\n-BENCHMARK(SipHash_32b, 40 * 1000 * 1000);\n-BENCHMARK(SHA256D64_1024, 7400);\n-BENCHMARK(FastRandom_32bit, 110 * 1000 * 1000);\n-BENCHMARK(FastRandom_1bit, 440 * 1000 * 1000);\n+BENCHMARK(SHA256_32b);\n+BENCHMARK(SipHash_32b);\n+BENCHMARK(SHA256D64_1024);\n+BENCHMARK(FastRandom_32bit);\n+BENCHMARK(FastRandom_1bit);"
      },
      {
        "sha": "5745e4276c5aee52129036e752f272a507c31485",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -12,7 +12,7 @@\n #include <validation.h>\n \n \n-static void DuplicateInputs(benchmark::State& state)\n+static void DuplicateInputs(benchmark::Bench& bench)\n {\n     TestingSetup test_setup{\n         CBaseChainParams::REGTEST,\n@@ -61,11 +61,11 @@ static void DuplicateInputs(benchmark::State& state)\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         BlockValidationState cvstate{};\n         assert(!CheckBlock(block, cvstate, chainparams.GetConsensus(), false, false));\n         assert(cvstate.GetRejectReason() == \"bad-txns-inputs-duplicate\");\n-    }\n+    });\n }\n \n-BENCHMARK(DuplicateInputs, 10);\n+BENCHMARK(DuplicateInputs);"
      },
      {
        "sha": "dcd615b9da26987df65b37f60a9adba9ef6a0487",
        "filename": "src/bench/examples.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 16,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -3,31 +3,19 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n-#include <util/time.h>\n-\n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n-        UninterruptibleSleep(std::chrono::milliseconds{100});\n-    }\n-}\n-\n-BENCHMARK(Sleep100ms, 10);\n \n // Extremely fast-running benchmark:\n #include <math.h>\n \n volatile double sum = 0.0; // volatile, global so not optimized away\n \n-static void Trig(benchmark::State& state)\n+static void Trig(benchmark::Bench& bench)\n {\n     double d = 0.01;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         sum += sin(d);\n         d += 0.000001;\n-    }\n+    });\n }\n \n-BENCHMARK(Trig, 12 * 1000 * 1000);\n+BENCHMARK(Trig);"
      },
      {
        "sha": "ef83242e416694e0e2c6a2277ca4fef8948a3e63",
        "filename": "src/bench/gcs_filter.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/gcs_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/gcs_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/gcs_filter.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -5,7 +5,7 @@\n #include <bench/bench.h>\n #include <blockfilter.h>\n \n-static void ConstructGCSFilter(benchmark::State& state)\n+static void ConstructGCSFilter(benchmark::Bench& bench)\n {\n     GCSFilter::ElementSet elements;\n     for (int i = 0; i < 10000; ++i) {\n@@ -16,14 +16,14 @@ static void ConstructGCSFilter(benchmark::State& state)\n     }\n \n     uint64_t siphash_k0 = 0;\n-    while (state.KeepRunning()) {\n+    bench.batch(elements.size()).unit(\"elem\").run([&] {\n         GCSFilter filter({siphash_k0, 0, 20, 1 << 20}, elements);\n \n         siphash_k0++;\n-    }\n+    });\n }\n \n-static void MatchGCSFilter(benchmark::State& state)\n+static void MatchGCSFilter(benchmark::Bench& bench)\n {\n     GCSFilter::ElementSet elements;\n     for (int i = 0; i < 10000; ++i) {\n@@ -34,10 +34,10 @@ static void MatchGCSFilter(benchmark::State& state)\n     }\n     GCSFilter filter({0, 0, 20, 1 << 20}, elements);\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"elem\").run([&] {\n         filter.Match(GCSFilter::Element());\n-    }\n+    });\n }\n \n-BENCHMARK(ConstructGCSFilter, 1000);\n-BENCHMARK(MatchGCSFilter, 50 * 1000);\n+BENCHMARK(ConstructGCSFilter);\n+BENCHMARK(MatchGCSFilter);"
      },
      {
        "sha": "309cae3723b77df62c6cab669e0c7f55ba87ade8",
        "filename": "src/bench/hashpadding.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/hashpadding.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/hashpadding.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/hashpadding.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -8,7 +8,7 @@\n #include <uint256.h>\n \n \n-static void PrePadded(benchmark::State& state)\n+static void PrePadded(benchmark::Bench& bench)\n {\n \n     CSHA256 hasher;\n@@ -18,30 +18,30 @@ static void PrePadded(benchmark::State& state)\n     hasher.Write(nonce.begin(), 32);\n     hasher.Write(nonce.begin(), 32);\n     uint256 data = GetRandHash();\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         unsigned char out[32];\n         CSHA256 h = hasher;\n         h.Write(data.begin(), 32);\n         h.Finalize(out);\n-    }\n+    });\n }\n \n-BENCHMARK(PrePadded, 10000);\n+BENCHMARK(PrePadded);\n \n-static void RegularPadded(benchmark::State& state)\n+static void RegularPadded(benchmark::Bench& bench)\n {\n     CSHA256 hasher;\n \n     // Setup the salted hasher\n     uint256 nonce = GetRandHash();\n     uint256 data = GetRandHash();\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         unsigned char out[32];\n         CSHA256 h = hasher;\n         h.Write(nonce.begin(), 32);\n         h.Write(data.begin(), 32);\n         h.Finalize(out);\n-    }\n+    });\n }\n \n-BENCHMARK(RegularPadded, 10000);\n+BENCHMARK(RegularPadded);"
      },
      {
        "sha": "32b060a15a350fb814c7d87af4ca102e2259af08",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 17,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -9,10 +9,9 @@\n #include <vector>\n \n #define ASIZE 2048\n-#define BITER 5000\n #define MSIZE 2048\n \n-static void BenchLockedPool(benchmark::State& state)\n+static void BenchLockedPool(benchmark::Bench& bench)\n {\n     void *synth_base = reinterpret_cast<void*>(0x08000000);\n     const size_t synth_size = 1024*1024;\n@@ -22,24 +21,22 @@ static void BenchLockedPool(benchmark::State& state)\n     for (int x=0; x<ASIZE; ++x)\n         addr.push_back(nullptr);\n     uint32_t s = 0x12345678;\n-    while (state.KeepRunning()) {\n-        for (int x=0; x<BITER; ++x) {\n-            int idx = s & (addr.size()-1);\n-            if (s & 0x80000000) {\n-                b.free(addr[idx]);\n-                addr[idx] = nullptr;\n-            } else if(!addr[idx]) {\n-                addr[idx] = b.alloc((s >> 16) & (MSIZE-1));\n-            }\n-            bool lsb = s & 1;\n-            s >>= 1;\n-            if (lsb)\n-                s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n+    bench.run([&] {\n+        int idx = s & (addr.size() - 1);\n+        if (s & 0x80000000) {\n+            b.free(addr[idx]);\n+            addr[idx] = nullptr;\n+        } else if (!addr[idx]) {\n+            addr[idx] = b.alloc((s >> 16) & (MSIZE - 1));\n         }\n-    }\n+        bool lsb = s & 1;\n+        s >>= 1;\n+        if (lsb)\n+            s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n+    });\n     for (void *ptr: addr)\n         b.free(ptr);\n     addr.clear();\n }\n \n-BENCHMARK(BenchLockedPool, 1300);\n+BENCHMARK(BenchLockedPool);"
      },
      {
        "sha": "1b9e428c9d329e21e464e14b61bf4790f7ae9795",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -23,7 +23,7 @@ static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& po\n // Right now this is only testing eviction performance in an extremely small\n // mempool. Code needs to be written to generate a much wider variety of\n // unique transactions for a more meaningful performance measurement.\n-static void MempoolEviction(benchmark::State& state)\n+static void MempoolEviction(benchmark::Bench& bench)\n {\n     TestingSetup test_setup{\n         CBaseChainParams::REGTEST,\n@@ -125,7 +125,7 @@ static void MempoolEviction(benchmark::State& state)\n     const CTransactionRef tx6_r{MakeTransactionRef(tx6)};\n     const CTransactionRef tx7_r{MakeTransactionRef(tx7)};\n \n-    while (state.KeepRunning()) {\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n         AddTx(tx1_r, 10000LL, pool);\n         AddTx(tx2_r, 5000LL, pool);\n         AddTx(tx3_r, 20000LL, pool);\n@@ -135,7 +135,7 @@ static void MempoolEviction(benchmark::State& state)\n         AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(*tx1_r));\n-    }\n+    });\n }\n \n-BENCHMARK(MempoolEviction, 41000);\n+BENCHMARK(MempoolEviction);"
      },
      {
        "sha": "89233e390ca10dca4bd74f237f36d4bab4b9bb05",
        "filename": "src/bench/mempool_stress.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/mempool_stress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/mempool_stress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_stress.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -26,8 +26,13 @@ struct Available {\n     Available(CTransactionRef& ref, size_t tx_count) : ref(ref), tx_count(tx_count){}\n };\n \n-static void ComplexMemPool(benchmark::State& state)\n+static void ComplexMemPool(benchmark::Bench& bench)\n {\n+    int childTxs = 800;\n+    if (bench.complexityN() > 1) {\n+        childTxs = static_cast<int>(bench.complexityN());\n+    }\n+\n     FastRandomContext det_rand{true};\n     std::vector<Available> available_coins;\n     std::vector<CTransactionRef> ordered_coins;\n@@ -46,7 +51,7 @@ static void ComplexMemPool(benchmark::State& state)\n         ordered_coins.emplace_back(MakeTransactionRef(tx));\n         available_coins.emplace_back(ordered_coins.back(), tx_counter++);\n     }\n-    for (auto x = 0; x < 800 && !available_coins.empty(); ++x) {\n+    for (auto x = 0; x < childTxs && !available_coins.empty(); ++x) {\n         CMutableTransaction tx = CMutableTransaction();\n         size_t n_ancestors = det_rand.randrange(10)+1;\n         for (size_t ancestor = 0; ancestor < n_ancestors && !available_coins.empty(); ++ancestor){\n@@ -77,13 +82,13 @@ static void ComplexMemPool(benchmark::State& state)\n     TestingSetup test_setup;\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n-    while (state.KeepRunning()) {\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n         for (auto& tx : ordered_coins) {\n             AddTx(tx, pool);\n         }\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(*ordered_coins.front()));\n-    }\n+    });\n }\n \n-BENCHMARK(ComplexMemPool, 1);\n+BENCHMARK(ComplexMemPool);"
      },
      {
        "sha": "ba6629b9f0a598bb3aeb0a302a318fd797f6e072",
        "filename": "src/bench/merkle_root.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/merkle_root.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/merkle_root.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/merkle_root.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -8,19 +8,19 @@\n #include <random.h>\n #include <uint256.h>\n \n-static void MerkleRoot(benchmark::State& state)\n+static void MerkleRoot(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n     std::vector<uint256> leaves;\n     leaves.resize(9001);\n     for (auto& item : leaves) {\n         item = rng.rand256();\n     }\n-    while (state.KeepRunning()) {\n+    bench.batch(leaves.size()).unit(\"leaf\").run([&] {\n         bool mutation = false;\n         uint256 hash = ComputeMerkleRoot(std::vector<uint256>(leaves), &mutation);\n         leaves[mutation] = hash;\n-    }\n+    });\n }\n \n-BENCHMARK(MerkleRoot, 800);\n+BENCHMARK(MerkleRoot);"
      },
      {
        "sha": "fcdd86495a6a84d3cf4ccdd87fb8031d69460167",
        "filename": "src/bench/nanobench.cpp",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/nanobench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/nanobench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -0,0 +1,6 @@\n+// Copyright (c) 2019-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define ANKERL_NANOBENCH_IMPLEMENT\n+#include <bench/nanobench.h>"
      },
      {
        "sha": "c5379e7fd4e3419e9f42aadf25b307d54a2ea4fd",
        "filename": "src/bench/nanobench.h",
        "status": "added",
        "additions": 3225,
        "deletions": 0,
        "changes": 3225,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/nanobench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/nanobench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.h?ref=78c312c983255e15fc274de2368a2ec13ce81cbf"
      },
      {
        "sha": "d8db99e7d4d7f1cd5b8c08310d839333e8115ae4",
        "filename": "src/bench/poly1305.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/poly1305.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/poly1305.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/poly1305.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -11,30 +11,31 @@ static constexpr uint64_t BUFFER_SIZE_TINY  = 64;\n static constexpr uint64_t BUFFER_SIZE_SMALL = 256;\n static constexpr uint64_t BUFFER_SIZE_LARGE = 1024*1024;\n \n-static void POLY1305(benchmark::State& state, size_t buffersize)\n+static void POLY1305(benchmark::Bench& bench, size_t buffersize)\n {\n     std::vector<unsigned char> tag(POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> key(POLY1305_KEYLEN, 0);\n     std::vector<unsigned char> in(buffersize, 0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         poly1305_auth(tag.data(), in.data(), in.size(), key.data());\n+    });\n }\n \n-static void POLY1305_64BYTES(benchmark::State& state)\n+static void POLY1305_64BYTES(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_TINY);\n+    POLY1305(bench, BUFFER_SIZE_TINY);\n }\n \n-static void POLY1305_256BYTES(benchmark::State& state)\n+static void POLY1305_256BYTES(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_SMALL);\n+    POLY1305(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void POLY1305_1MB(benchmark::State& state)\n+static void POLY1305_1MB(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_LARGE);\n+    POLY1305(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(POLY1305_64BYTES, 500000);\n-BENCHMARK(POLY1305_256BYTES, 250000);\n-BENCHMARK(POLY1305_1MB, 340);\n+BENCHMARK(POLY1305_64BYTES);\n+BENCHMARK(POLY1305_256BYTES);\n+BENCHMARK(POLY1305_1MB);"
      },
      {
        "sha": "a2dbefa54a6f524739156ab3ef368d1a2b85e129",
        "filename": "src/bench/prevector.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 48,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -30,51 +30,44 @@ static_assert(IS_TRIVIALLY_CONSTRUCTIBLE<trivial_t>::value,\n               \"expected trivial_t to be trivially constructible\");\n \n template <typename T>\n-static void PrevectorDestructor(benchmark::State& state)\n+static void PrevectorDestructor(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, T> t0;\n-            prevector<28, T> t1;\n-            t0.resize(28);\n-            t1.resize(29);\n-        }\n-    }\n+    bench.batch(2).run([&] {\n+        prevector<28, T> t0;\n+        prevector<28, T> t1;\n+        t0.resize(28);\n+        t1.resize(29);\n+    });\n }\n \n template <typename T>\n-static void PrevectorClear(benchmark::State& state)\n+static void PrevectorClear(benchmark::Bench& bench)\n {\n-\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, T> t0;\n-            prevector<28, T> t1;\n-            t0.resize(28);\n-            t0.clear();\n-            t1.resize(29);\n-            t1.clear();\n-        }\n-    }\n+    prevector<28, T> t0;\n+    prevector<28, T> t1;\n+    bench.batch(2).run([&] {\n+        t0.resize(28);\n+        t0.clear();\n+        t1.resize(29);\n+        t1.clear();\n+    });\n }\n \n template <typename T>\n-static void PrevectorResize(benchmark::State& state)\n+static void PrevectorResize(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n-        prevector<28, T> t0;\n-        prevector<28, T> t1;\n-        for (auto x = 0; x < 1000; ++x) {\n-            t0.resize(28);\n-            t0.resize(0);\n-            t1.resize(29);\n-            t1.resize(0);\n-        }\n-    }\n+    prevector<28, T> t0;\n+    prevector<28, T> t1;\n+    bench.batch(4).run([&] {\n+        t0.resize(28);\n+        t0.resize(0);\n+        t1.resize(29);\n+        t1.resize(0);\n+    });\n }\n \n template <typename T>\n-static void PrevectorDeserialize(benchmark::State& state)\n+static void PrevectorDeserialize(benchmark::Bench& bench)\n {\n     CDataStream s0(SER_NETWORK, 0);\n     prevector<28, T> t0;\n@@ -86,26 +79,28 @@ static void PrevectorDeserialize(benchmark::State& state)\n     for (auto x = 0; x < 101; ++x) {\n         s0 << t0;\n     }\n-    while (state.KeepRunning()) {\n+    bench.batch(1000).run([&] {\n         prevector<28, T> t1;\n         for (auto x = 0; x < 1000; ++x) {\n             s0 >> t1;\n         }\n         s0.Init(SER_NETWORK, 0);\n-    }\n+    });\n }\n \n-#define PREVECTOR_TEST(name, nontrivops, trivops)                       \\\n-    static void Prevector ## name ## Nontrivial(benchmark::State& state) { \\\n-        Prevector ## name<nontrivial_t>(state);                         \\\n-    }                                                                   \\\n-    BENCHMARK(Prevector ## name ## Nontrivial, nontrivops);             \\\n-    static void Prevector ## name ## Trivial(benchmark::State& state) { \\\n-        Prevector ## name<trivial_t>(state);                            \\\n-    }                                                                   \\\n-    BENCHMARK(Prevector ## name ## Trivial, trivops);\n+#define PREVECTOR_TEST(name)                                         \\\n+    static void Prevector##name##Nontrivial(benchmark::Bench& bench) \\\n+    {                                                                \\\n+        Prevector##name<nontrivial_t>(bench);                        \\\n+    }                                                                \\\n+    BENCHMARK(Prevector##name##Nontrivial);                          \\\n+    static void Prevector##name##Trivial(benchmark::Bench& bench)    \\\n+    {                                                                \\\n+        Prevector##name<trivial_t>(bench);                           \\\n+    }                                                                \\\n+    BENCHMARK(Prevector##name##Trivial);\n \n-PREVECTOR_TEST(Clear, 28300, 88600)\n-PREVECTOR_TEST(Destructor, 28800, 88900)\n-PREVECTOR_TEST(Resize, 28900, 90300)\n-PREVECTOR_TEST(Deserialize, 6800, 52000)\n+PREVECTOR_TEST(Clear)\n+PREVECTOR_TEST(Destructor)\n+PREVECTOR_TEST(Resize)\n+PREVECTOR_TEST(Deserialize)"
      },
      {
        "sha": "9b43951e6e2046737a2012475261ce1ce2cc057e",
        "filename": "src/bench/rollingbloom.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rollingbloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rollingbloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rollingbloom.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -6,12 +6,12 @@\n #include <bench/bench.h>\n #include <bloom.h>\n \n-static void RollingBloom(benchmark::State& state)\n+static void RollingBloom(benchmark::Bench& bench)\n {\n     CRollingBloomFilter filter(120000, 0.000001);\n     std::vector<unsigned char> data(32);\n     uint32_t count = 0;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         count++;\n         data[0] = count;\n         data[1] = count >> 8;\n@@ -24,16 +24,16 @@ static void RollingBloom(benchmark::State& state)\n         data[2] = count >> 8;\n         data[3] = count;\n         filter.contains(data);\n-    }\n+    });\n }\n \n-static void RollingBloomReset(benchmark::State& state)\n+static void RollingBloomReset(benchmark::Bench& bench)\n {\n     CRollingBloomFilter filter(120000, 0.000001);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         filter.reset();\n-    }\n+    });\n }\n \n-BENCHMARK(RollingBloom, 1500 * 1000);\n-BENCHMARK(RollingBloomReset, 20000);\n+BENCHMARK(RollingBloom);\n+BENCHMARK(RollingBloomReset);"
      },
      {
        "sha": "4b45264a3cf1a239de2eaeb97bac9e9437748060",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -11,7 +11,8 @@\n \n #include <univalue.h>\n \n-static void BlockToJsonVerbose(benchmark::State& state) {\n+static void BlockToJsonVerbose(benchmark::Bench& bench)\n+{\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n@@ -24,9 +25,9 @@ static void BlockToJsonVerbose(benchmark::State& state) {\n     blockindex.phashBlock = &blockHash;\n     blockindex.nBits = 403014710;\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)blockToJSON(block, &blockindex, &blockindex, /*verbose*/ true);\n-    }\n+    });\n }\n \n-BENCHMARK(BlockToJsonVerbose, 10);\n+BENCHMARK(BlockToJsonVerbose);"
      },
      {
        "sha": "1ff41765cfa0c4e1e30f3cbf834c6c40c091d92b",
        "filename": "src/bench/rpc_mempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rpc_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/rpc_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_mempool.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -15,7 +15,7 @@ static void AddTx(const CTransactionRef& tx, const CAmount& fee, CTxMemPool& poo\n     pool.addUnchecked(CTxMemPoolEntry(tx, fee, /* time */ 0, /* height */ 1, /* spendsCoinbase */ false, /* sigOpCost */ 4, lp));\n }\n \n-static void RpcMempool(benchmark::State& state)\n+static void RpcMempool(benchmark::Bench& bench)\n {\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n@@ -32,9 +32,9 @@ static void RpcMempool(benchmark::State& state)\n         AddTx(tx_r, /* fee */ i, pool);\n     }\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)MempoolToJSON(pool, /*verbose*/ true);\n-    }\n+    });\n }\n \n-BENCHMARK(RpcMempool, 40);\n+BENCHMARK(RpcMempool);"
      },
      {
        "sha": "fad179eb8770bfcbaf4e4ac2ff70203d38ea4577",
        "filename": "src/bench/util_time.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/util_time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/util_time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/util_time.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -6,37 +6,37 @@\n \n #include <util/time.h>\n \n-static void BenchTimeDeprecated(benchmark::State& state)\n+static void BenchTimeDeprecated(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime();\n-    }\n+    });\n }\n \n-static void BenchTimeMock(benchmark::State& state)\n+static void BenchTimeMock(benchmark::Bench& bench)\n {\n     SetMockTime(111);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime<std::chrono::seconds>();\n-    }\n+    });\n     SetMockTime(0);\n }\n \n-static void BenchTimeMillis(benchmark::State& state)\n+static void BenchTimeMillis(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime<std::chrono::milliseconds>();\n-    }\n+    });\n }\n \n-static void BenchTimeMillisSys(benchmark::State& state)\n+static void BenchTimeMillisSys(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTimeMillis();\n-    }\n+    });\n }\n \n-BENCHMARK(BenchTimeDeprecated, 100000000);\n-BENCHMARK(BenchTimeMillis, 6000000);\n-BENCHMARK(BenchTimeMillisSys, 6000000);\n-BENCHMARK(BenchTimeMock, 300000000);\n+BENCHMARK(BenchTimeDeprecated);\n+BENCHMARK(BenchTimeMillis);\n+BENCHMARK(BenchTimeMillisSys);\n+BENCHMARK(BenchTimeMock);"
      },
      {
        "sha": "c489bae4f6abc76c9664fb39d26f24f4f419022d",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -16,7 +16,7 @@\n \n // Microbenchmark for verification of a basic P2WPKH script. Can be easily\n // modified to measure performance of other types of scripts.\n-static void VerifyScriptBench(benchmark::State& state)\n+static void VerifyScriptBench(benchmark::Bench& bench)\n {\n     const ECCVerifyHandle verify_handle;\n     ECC_Start();\n@@ -49,7 +49,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     witness.stack.push_back(ToByteVector(pubkey));\n \n     // Benchmark.\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         ScriptError err;\n         bool success = VerifyScript(\n             txSpend.vin[0].scriptSig,\n@@ -71,11 +71,12 @@ static void VerifyScriptBench(benchmark::State& state)\n             (const unsigned char*)stream.data(), stream.size(), 0, flags, nullptr);\n         assert(csuccess == 1);\n #endif\n-    }\n+    });\n     ECC_Stop();\n }\n \n-static void VerifyNestedIfScript(benchmark::State& state) {\n+static void VerifyNestedIfScript(benchmark::Bench& bench)\n+{\n     std::vector<std::vector<unsigned char>> stack;\n     CScript script;\n     for (int i = 0; i < 100; ++i) {\n@@ -87,15 +88,13 @@ static void VerifyNestedIfScript(benchmark::State& state) {\n     for (int i = 0; i < 100; ++i) {\n         script << OP_ENDIF;\n     }\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         auto stack_copy = stack;\n         ScriptError error;\n         bool ret = EvalScript(stack_copy, script, 0, BaseSignatureChecker(), SigVersion::BASE, &error);\n         assert(ret);\n-    }\n+    });\n }\n \n-\n-BENCHMARK(VerifyScriptBench, 6300);\n-\n-BENCHMARK(VerifyNestedIfScript, 100);\n+BENCHMARK(VerifyScriptBench);\n+BENCHMARK(VerifyNestedIfScript);"
      },
      {
        "sha": "d55d5359f004ebc5b25e595cd2936ad1915d93e1",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -12,7 +12,7 @@\n #include <validationinterface.h>\n #include <wallet/wallet.h>\n \n-static void WalletBalance(benchmark::State& state, const bool set_dirty, const bool add_watchonly, const bool add_mine)\n+static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const bool add_watchonly, const bool add_mine)\n {\n     TestingSetup test_setup{\n         CBaseChainParams::REGTEST,\n@@ -45,20 +45,20 @@ static void WalletBalance(benchmark::State& state, const bool set_dirty, const b\n \n     auto bal = wallet.GetBalance(); // Cache\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         if (set_dirty) wallet.MarkDirty();\n         bal = wallet.GetBalance();\n         if (add_mine) assert(bal.m_mine_trusted > 0);\n         if (add_watchonly) assert(bal.m_watchonly_trusted > 0);\n-    }\n+    });\n }\n \n-static void WalletBalanceDirty(benchmark::State& state) { WalletBalance(state, /* set_dirty */ true, /* add_watchonly */ true, /* add_mine */ true); }\n-static void WalletBalanceClean(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ true); }\n-static void WalletBalanceMine(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ false, /* add_mine */ true); }\n-static void WalletBalanceWatch(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ false); }\n+static void WalletBalanceDirty(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ true, /* add_watchonly */ true, /* add_mine */ true); }\n+static void WalletBalanceClean(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ true); }\n+static void WalletBalanceMine(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ false, /* add_mine */ true); }\n+static void WalletBalanceWatch(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ false); }\n \n-BENCHMARK(WalletBalanceDirty, 2500);\n-BENCHMARK(WalletBalanceClean, 8000);\n-BENCHMARK(WalletBalanceMine, 16000);\n-BENCHMARK(WalletBalanceWatch, 8000);\n+BENCHMARK(WalletBalanceDirty);\n+BENCHMARK(WalletBalanceClean);\n+BENCHMARK(WalletBalanceMine);\n+BENCHMARK(WalletBalanceWatch);"
      },
      {
        "sha": "5d5a150db877147a9aef858237d722de66d30877",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78c312c983255e15fc274de2368a2ec13ce81cbf/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78c312c983255e15fc274de2368a2ec13ce81cbf/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=78c312c983255e15fc274de2368a2ec13ce81cbf",
        "patch": "@@ -10,7 +10,7 @@ export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n \n-REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|univalue/)\"\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|bench/nanobench.h|univalue/)\"\n \n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")"
      }
    ]
  }
]