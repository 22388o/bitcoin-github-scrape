[
  {
    "sha": "fa0b916971e5bc23ad6396831940a2899ca05402",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTBiOTE2OTcxZTViYzIzYWQ2Mzk2ODMxOTQwYTI4OTljYTA1NDAy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-08-19T15:10:24Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-09-02T08:34:35Z"
      },
      "message": "scripted-diff: Use generate* from TestFramework\n\n-BEGIN VERIFY SCRIPT-\n sed --regexp-extended -i \\\n     's/((self\\.)?(nodes\\[[^]]+\\]|[a-z_]*(wallet|node)[0-9a-z_]*))\\.(generate(|toaddress|block|todescriptor)(\\(|, ))/self.\\5\\1, /g' \\\n     $(git grep -l generate ./test | grep -v 'test_framework/' | grep -v 'feature_rbf')\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "45514e79001bb9e1a3d4f05bdc822e8d18d4012d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45514e79001bb9e1a3d4f05bdc822e8d18d4012d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0b916971e5bc23ad6396831940a2899ca05402",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhdwgwAtIUruHcTJF6ruAHj5X6PK7hlZm5wsC+IRGkG3KpNKFwh1M4VhpS8TQTy\n8Kywmu6zgfeIchaPBqWly7+3la+z1mWdz19i7Zrm0CC4pFixBdtFnJLrL5seIgFd\nQJfnJmPWSKePggbvDj9xbN+4oHwF3Ciz3yTYVQTVsp+BigCEMu9FBPRuPifPbQPa\nCsLE4dNd/u5Rab4j5xbKhYYd6ewksnirz8oYf+VW7qUN6v+stGHt8mFt/Y7S3abX\n+orX29ydTt+LvkKTIBJVzVvndbz92GN4bApKQgzmBHvwsxSRcatL3ZORKVc1VQIi\nqo8gsjwrrNYT/saLEZ3/Z8PS0J6K65fYPdid0G0wL3/E8E01DNa3SrAxotY2I2l4\nd5RNCIlrlYwfE3QKsyNf43gsN7hsCverZgL3nutKFa+KGnia6O1E6YTvJQr41wjh\nY9k0RLejl7nbFnAiZk/eZ//shJmiq8HugCim5PfsNR9qmYFB4bzEQhFWWvtrL0Vz\nbha+v7d4\n=pyMe\n-----END PGP SIGNATURE-----",
        "payload": "tree 45514e79001bb9e1a3d4f05bdc822e8d18d4012d\nparent 245462b66ce35dfc5b191d245b3b18b7d035dc92\nauthor MarcoFalke <falke.marco@gmail.com> 1629385824 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1630571675 +0200\n\nscripted-diff: Use generate* from TestFramework\n\n-BEGIN VERIFY SCRIPT-\n sed --regexp-extended -i \\\n     's/((self\\.)?(nodes\\[[^]]+\\]|[a-z_]*(wallet|node)[0-9a-z_]*))\\.(generate(|toaddress|block|todescriptor)(\\(|, ))/self.\\5\\1, /g' \\\n     $(git grep -l generate ./test | grep -v 'test_framework/' | grep -v 'feature_rbf')\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0b916971e5bc23ad6396831940a2899ca05402",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0b916971e5bc23ad6396831940a2899ca05402",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0b916971e5bc23ad6396831940a2899ca05402/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "245462b66ce35dfc5b191d245b3b18b7d035dc92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/245462b66ce35dfc5b191d245b3b18b7d035dc92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/245462b66ce35dfc5b191d245b3b18b7d035dc92"
      }
    ],
    "stats": {
      "total": 936,
      "additions": 468,
      "deletions": 468
    },
    "files": [
      {
        "sha": "d6fc2d580f71bbb79ea812a0ca0bc3520159a645",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -141,7 +141,7 @@ def run_test(self):\n         peer_messaging = self.nodes[0].add_p2p_connection(BaseNode())\n \n         # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        blocks = [int(self.generate(self.nodes[0], nblocks=1)[0], 16)]\n         self.sync_all(self.nodes[0:2])\n \n         # Notice above how we called an RPC by calling a method with the same"
      },
      {
        "sha": "e3cb7725bd716eb6824a0cc9c4aa8181fd928463",
        "filename": "test/functional/feature_abortnode.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_abortnode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_abortnode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_abortnode.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -26,18 +26,18 @@ def setup_network(self):\n         # We'll connect the nodes later\n \n     def run_test(self):\n-        self.nodes[0].generate(3)\n+        self.generate(self.nodes[0], 3)\n         datadir = get_datadir_path(self.options.tmpdir, 0)\n \n         # Deleting the undo file will result in reorg failure\n         os.unlink(os.path.join(datadir, self.chain, 'blocks', 'rev00000.dat'))\n \n         # Connecting to a node with a more work chain will trigger a reorg\n         # attempt.\n-        self.nodes[1].generate(3)\n+        self.generate(self.nodes[1], 3)\n         with self.nodes[0].assert_debug_log([\"Failed to disconnect block\"]):\n             self.connect_nodes(0, 1)\n-            self.nodes[1].generate(1)\n+            self.generate(self.nodes[1], 1)\n \n             # Check that node0 aborted\n             self.log.info(\"Waiting for crash\")"
      },
      {
        "sha": "e65525a0237ca7ec5cad0d2d191d19365bebe18e",
        "filename": "test/functional/feature_backwards_compatibility.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_backwards_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_backwards_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_backwards_compatibility.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -64,7 +64,7 @@ def setup_nodes(self):\n         self.import_deterministic_coinbase_privkeys()\n \n     def run_test(self):\n-        self.nodes[0].generatetoaddress(COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n \n         self.sync_blocks()\n \n@@ -92,15 +92,15 @@ def run_test(self):\n         address = wallet.getnewaddress()\n         self.nodes[0].sendtoaddress(address, 10)\n         self.sync_mempools()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         # Create a conflicting transaction using RBF\n         return_address = self.nodes[0].getnewaddress()\n         tx1_id = self.nodes[1].sendtoaddress(return_address, 1)\n         tx2_id = self.nodes[1].bumpfee(tx1_id)[\"txid\"]\n         # Confirm the transaction\n         self.sync_mempools()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         # Create another conflicting transaction using RBF\n         tx3_id = self.nodes[1].sendtoaddress(return_address, 1)"
      },
      {
        "sha": "85522164d242372194f301c1180a1db18b34713c",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -55,7 +55,7 @@ def run_test(self):\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n \n         # Generate some coins\n-        self.nodes[0].generate(110)\n+        self.generate(self.nodes[0], 110)\n \n         self.log.info(\"Running test disable flag\")\n         self.test_disable_flag()\n@@ -143,7 +143,7 @@ def test_sequence_lock_confirmed_inputs(self):\n             for i in range(num_outputs):\n                 outputs[addresses[i]] = random.randint(1, 20)*0.01\n             self.nodes[0].sendmany(\"\", outputs)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         utxos = self.nodes[0].listunspent()\n \n@@ -273,7 +273,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         cur_time = int(time.time())\n         for _ in range(10):\n             self.nodes[0].setmocktime(cur_time + 600)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             cur_time += 600\n \n         assert tx2.hash in self.nodes[0].getrawmempool()\n@@ -288,15 +288,15 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         self.nodes[0].setmocktime(cur_time+600)\n         # Save block template now to use for the reorg later\n         tmpl = self.nodes[0].getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert tx2.hash not in self.nodes[0].getrawmempool()\n \n         # Now that tx2 is not in the mempool, a sequence locked spend should\n         # succeed\n         tx3 = test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n         assert tx3.hash in self.nodes[0].getrawmempool()\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert tx3.hash not in self.nodes[0].getrawmempool()\n \n         # One more test, this time using height locks\n@@ -349,7 +349,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # Reset the chain and get rid of the mocktimed-blocks\n         self.nodes[0].setmocktime(0)\n         self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n \n     # Make sure that BIP68 isn't being used to validate blocks prior to\n     # activation height.  If more blocks are mined prior to this test\n@@ -403,9 +403,9 @@ def activateCSV(self):\n         min_activation_height = 432\n         height = self.nodes[0].getblockcount()\n         assert_greater_than(min_activation_height - height, 2)\n-        self.nodes[0].generate(min_activation_height - height - 2)\n+        self.generate(self.nodes[0], min_activation_height - height - 2)\n         assert not softfork_active(self.nodes[0], 'csv')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert softfork_active(self.nodes[0], 'csv')\n         self.sync_blocks()\n "
      },
      {
        "sha": "b740f2cc27ee60f46bb7cdaf0e7fbb91da239ce3",
        "filename": "test/functional/feature_blockfilterindex_prune.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_blockfilterindex_prune.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_blockfilterindex_prune.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blockfilterindex_prune.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -25,9 +25,9 @@ def run_test(self):\n         self.sync_index(height=200)\n         assert_greater_than(len(self.nodes[0].getblockfilter(self.nodes[0].getbestblockhash())['filter']), 0)\n         # Mine two batches of blocks to avoid hitting NODE_NETWORK_LIMITED_MIN_BLOCKS disconnection\n-        self.nodes[0].generate(250)\n+        self.generate(self.nodes[0], 250)\n         self.sync_all()\n-        self.nodes[0].generate(250)\n+        self.generate(self.nodes[0], 250)\n         self.sync_all()\n         self.sync_index(height=700)\n \n@@ -46,7 +46,7 @@ def run_test(self):\n \n         self.log.info(\"make sure accessing the blockfilters throws an error\")\n         assert_raises_rpc_error(-1, \"Index is not enabled for filtertype basic\", self.nodes[0].getblockfilter, self.nodes[0].getblockhash(2))\n-        self.nodes[0].generate(1000)\n+        self.generate(self.nodes[0], 1000)\n \n         self.log.info(\"prune below the blockfilterindexes best block while blockfilters are disabled\")\n         pruneheight_new = self.nodes[0].pruneblockchain(1000)"
      },
      {
        "sha": "28e6d6cdf92af59d3877c129df41c8d253a316a8",
        "filename": "test/functional/feature_blocksdir.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_blocksdir.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_blocksdir.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blocksdir.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -29,7 +29,7 @@ def run_test(self):\n         self.log.info(\"Starting with existing blocksdir ...\")\n         self.start_node(0, [f\"-blocksdir={blocksdir_path}\"])\n         self.log.info(\"mining blocks..\")\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n         assert os.path.isfile(os.path.join(blocksdir_path, self.chain, \"blocks\", \"blk00000.dat\"))\n         assert os.path.isdir(os.path.join(self.nodes[0].datadir, self.chain, \"blocks\", \"index\"))\n "
      },
      {
        "sha": "2c3ef9b88b7769146770e23d806d91dc79d751fd",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -102,8 +102,8 @@ def run_test(self):\n         self.test_cltv_info(is_active=False)\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)\n-        wallet.generate(10)\n-        self.nodes[0].generate(CLTV_HEIGHT - 2 - 10)\n+        self.generate(wallet, 10)\n+        self.generate(self.nodes[0], CLTV_HEIGHT - 2 - 10)\n         assert_equal(self.nodes[0].getblockcount(), CLTV_HEIGHT - 2)\n \n         self.log.info(\"Test that invalid-according-to-CLTV transactions can still appear in a block\")"
      },
      {
        "sha": "146e776b07e50c1396fdbdb2d1ce8da3f7f68cae",
        "filename": "test/functional/feature_coinstatsindex.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_coinstatsindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_coinstatsindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_coinstatsindex.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -67,10 +67,10 @@ def _test_coin_stats_index(self):\n         index_hash_options = ['none', 'muhash']\n \n         # Generate a normal transaction and mine it\n-        node.generate(COINBASE_MATURITY + 1)\n+        self.generate(node, COINBASE_MATURITY + 1)\n         address = self.nodes[0].get_deterministic_priv_key().address\n         node.sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n-        node.generate(1)\n+        self.generate(node, 1)\n \n         self.sync_blocks(timeout=120)\n \n@@ -92,7 +92,7 @@ def _test_coin_stats_index(self):\n         self.log.info(\"Test that gettxoutsetinfo() can get fetch data on specific heights with index\")\n \n         # Generate a new tip\n-        node.generate(5)\n+        self.generate(node, 5)\n \n         for hash_option in index_hash_options:\n             # Fetch old stats by height\n@@ -169,7 +169,7 @@ def _test_coin_stats_index(self):\n         self.nodes[0].sendrawtransaction(tx2_hex)\n \n         # Include both txs in a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         for hash_option in index_hash_options:\n@@ -228,7 +228,7 @@ def _test_coin_stats_index(self):\n         res9 = index_node.gettxoutsetinfo('muhash')\n         assert_equal(res8, res9)\n \n-        index_node.generate(1)\n+        self.generate(index_node, 1)\n         res10 = index_node.gettxoutsetinfo('muhash')\n         assert(res8['txouts'] < res10['txouts'])\n \n@@ -247,14 +247,14 @@ def _test_reorg_index(self):\n \n         # Generate two block, let the index catch up, then invalidate the blocks\n         index_node = self.nodes[1]\n-        reorg_blocks = index_node.generatetoaddress(2, index_node.getnewaddress())\n+        reorg_blocks = self.generatetoaddress(index_node, 2, index_node.getnewaddress())\n         reorg_block = reorg_blocks[1]\n         res_invalid = index_node.gettxoutsetinfo('muhash')\n         index_node.invalidateblock(reorg_blocks[0])\n         assert_equal(index_node.gettxoutsetinfo('muhash')['height'], 110)\n \n         # Add two new blocks\n-        block = index_node.generate(2)[1]\n+        block = self.generate(index_node, 2)[1]\n         res = index_node.gettxoutsetinfo(hash_type='muhash', hash_or_height=None, use_index=False)\n \n         # Test that the result of the reorged block is not returned for its old block height\n@@ -270,7 +270,7 @@ def _test_reorg_index(self):\n \n         # Add another block, so we don't depend on reconsiderblock remembering which\n         # blocks were touched by invalidateblock\n-        index_node.generate(1)\n+        self.generate(index_node, 1)\n         self.sync_all()\n \n         # Ensure that removing and re-adding blocks yields consistent results"
      },
      {
        "sha": "eca2acef1c2a9206d0360684619d589479839195",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -189,7 +189,7 @@ def run_test(self):\n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = self.miniwallet.generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n+        self.coinbase_blocks = self.generate(self.miniwallet, COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n         self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n         self.tipheight = COINBASE_BLOCK_COUNT  # height of the next block to build\n         self.last_block_time = long_past_time\n@@ -235,7 +235,7 @@ def run_test(self):\n         bip113input = self.send_generic_input_tx(self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n-        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 431\n+        inputblockhash = self.generate(self.nodes[0], 1)[0]  # 1 block generated for inputs to be in chain at height 431\n         self.nodes[0].setmocktime(0)\n         self.tip = int(inputblockhash, 16)\n         self.tipheight += 1"
      },
      {
        "sha": "595d26611aafcd8649c54fe94f3681d3c19f178f",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -72,7 +72,7 @@ def run_test(self):\n         self.test_dersig_info(is_active=False)\n \n         self.log.info(\"Mining %d blocks\", DERSIG_HEIGHT - 2)\n-        self.coinbase_txids = [self.nodes[0].getblock(b)['tx'][0] for b in self.miniwallet.generate(DERSIG_HEIGHT - 2)]\n+        self.coinbase_txids = [self.nodes[0].getblock(b)['tx'][0] for b in self.generate(self.miniwallet, DERSIG_HEIGHT - 2)]\n \n         self.log.info(\"Test that a transaction with non-DER signature can still appear in a block\")\n "
      },
      {
        "sha": "c4610f98bd7e5f0cf3e1259cae2c60b155282476",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -197,7 +197,7 @@ def transact_and_mine(self, numblocks, mining_node):\n                 tx_kbytes = (len(txhex) // 2) / 1000.0\n                 self.fees_per_kb.append(float(fee) / tx_kbytes)\n             self.sync_mempools(wait=.1)\n-            mined = mining_node.getblock(mining_node.generate(1)[0], True)[\"tx\"]\n+            mined = mining_node.getblock(self.generate(mining_node, 1)[0], True)[\"tx\"]\n             self.sync_blocks(wait=.1)\n             # update which txouts are confirmed\n             newmem = []\n@@ -221,7 +221,7 @@ def run_test(self):\n \n         # Mine\n         while len(self.nodes[0].getrawmempool()) > 0:\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         # Repeatedly split those 2 outputs, doubling twice for each rep\n         # Use txouts to monitor the available utxo, since these won't be tracked in wallet\n@@ -231,12 +231,12 @@ def run_test(self):\n             while len(self.txouts) > 0:\n                 split_inputs(self.nodes[0], self.txouts, self.txouts2)\n             while len(self.nodes[0].getrawmempool()) > 0:\n-                self.nodes[0].generate(1)\n+                self.generate(self.nodes[0], 1)\n             # Double txouts2 to txouts\n             while len(self.txouts2) > 0:\n                 split_inputs(self.nodes[0], self.txouts2, self.txouts)\n             while len(self.nodes[0].getrawmempool()) > 0:\n-                self.nodes[0].generate(1)\n+                self.generate(self.nodes[0], 1)\n             reps += 1\n         self.log.info(\"Finished splitting\")\n \n@@ -269,7 +269,7 @@ def run_test(self):\n \n         # Finish by mining a normal-sized block:\n         while len(self.nodes[1].getrawmempool()) > 0:\n-            self.nodes[1].generate(1)\n+            self.generate(self.nodes[1], 1)\n \n         self.sync_blocks(self.nodes[0:3], wait=.1)\n         self.log.info(\"Final estimates after emptying mempools\")"
      },
      {
        "sha": "13e6a8d6d72b42533b2faf3caaee009373327809",
        "filename": "test/functional/feature_loadblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_loadblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_loadblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_loadblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -29,7 +29,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.nodes[1].setnetworkactive(state=False)\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n \n         # Parsing the url of our node to get settings for config file\n         data_dir = self.nodes[0].datadir"
      },
      {
        "sha": "12bcc2ffc51d55a7276f2348fba555921dfcc2e8",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -56,7 +56,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(old_time)\n \n         # Generate some old blocks\n-        self.nodes[0].generate(130)\n+        self.generate(self.nodes[0], 130)\n \n         # p2p_conns[0] will only request old blocks\n         # p2p_conns[1] will only request new blocks"
      },
      {
        "sha": "11cb4aa3cbc3fbb4585a08b6f2406f090c93b140",
        "filename": "test/functional/feature_minchainwork.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_minchainwork.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n \n         num_blocks_to_generate = int((self.node_min_work[1] - starting_chain_work) / REGTEST_WORK_PER_BLOCK)\n         self.log.info(f\"Generating {num_blocks_to_generate} blocks on node0\")\n-        hashes = self.nodes[0].generatetoaddress(num_blocks_to_generate,\n+        hashes = self.generatetoaddress(self.nodes[0], num_blocks_to_generate,\n                                                  self.nodes[0].get_deterministic_priv_key().address)\n \n         self.log.info(f\"Node0 current chain work: {self.nodes[0].getblockheader(hashes[-1])['chainwork']}\")\n@@ -73,7 +73,7 @@ def run_test(self):\n         assert_equal(self.nodes[2].getblockcount(), starting_blockcount)\n \n         self.log.info(\"Generating one more block\")\n-        self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)\n \n         self.log.info(\"Verifying nodes are all synced\")\n "
      },
      {
        "sha": "5ef3860867368461153e5ecb4ff173bc659643f5",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -76,7 +76,7 @@ def run_test(self):\n \n         self.log.info(\"test -blocknotify\")\n         block_count = 10\n-        blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n+        blocks = self.generatetoaddress(self.nodes[1], block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n \n         # wait at most 10 seconds for expected number of files before reading the content\n         self.wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n@@ -110,7 +110,7 @@ def run_test(self):\n             # triggered by node 1\n             self.log.info(\"test -walletnotify with conflicting transactions\")\n             self.nodes[0].rescanblockchain()\n-            self.nodes[0].generatetoaddress(100, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 100, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_blocks()\n \n             # Generate transaction on node 0, sync mempools, and check for\n@@ -131,7 +131,7 @@ def run_test(self):\n \n             # Add bump1 transaction to new block, checking for a notification\n             # and the correct number of confirmations.\n-            blockhash1 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockhash1 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             blockheight1 = self.nodes[0].getblockcount()\n             self.sync_blocks()\n             self.expect_wallet_notify([(bump1, blockheight1, blockhash1)])\n@@ -148,7 +148,7 @@ def run_test(self):\n             # about newly confirmed bump2 and newly conflicted tx2.\n             self.disconnect_nodes(0, 1)\n             bump2 = self.nodes[0].bumpfee(tx2)[\"txid\"]\n-            blockhash2 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockhash2 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             blockheight2 = self.nodes[0].getblockcount()\n             assert_equal(self.nodes[0].gettransaction(bump2)[\"confirmations\"], 1)\n             assert_equal(tx2 in self.nodes[1].getrawmempool(), True)"
      },
      {
        "sha": "96984e1e645e854563d836bbf79222ac48fc7823",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -74,11 +74,11 @@ def run_test(self):\n             wmulti.importaddress(self.ms_address)\n             wmulti.importaddress(self.wit_ms_address)\n \n-        self.coinbase_blocks = self.nodes[0].generate(2)  # block height = 2\n+        self.coinbase_blocks = self.generate(self.nodes[0], 2)  # block height = 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:\n             coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n-        self.nodes[0].generate(COINBASE_MATURITY)  # block height = COINBASE_MATURITY + 2\n+        self.generate(self.nodes[0], COINBASE_MATURITY)  # block height = COINBASE_MATURITY + 2\n         self.lastblockhash = self.nodes[0].getbestblockhash()\n         self.lastblockheight = COINBASE_MATURITY + 2\n         self.lastblocktime = int(time.time()) + self.lastblockheight"
      },
      {
        "sha": "f20c519082802a672a4fe900144df34764efb5f8",
        "filename": "test/functional/feature_presegwit_node_upgrade.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_presegwit_node_upgrade.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_presegwit_node_upgrade.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_presegwit_node_upgrade.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -28,7 +28,7 @@ def run_test(self):\n         assert not softfork_active(node, \"segwit\")\n \n         # Generate 8 blocks without witness data\n-        node.generate(8)\n+        self.generate(node, 8)\n         assert_equal(node.getblockcount(), 8)\n \n         self.stop_node(0)"
      },
      {
        "sha": "c2463d0bccd260b49c6e834f42625ff3bdf85557",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -118,9 +118,9 @@ def setup_nodes(self):\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n-        self.nodes[1].generate(200)\n+        self.generate(self.nodes[1], 200)\n         self.sync_blocks(self.nodes[0:2])\n-        self.nodes[0].generate(150)\n+        self.generate(self.nodes[0], 150)\n \n         # Then mine enough full blocks to create more than 550MiB of data\n         mine_large_blocks(self.nodes[0], 645)\n@@ -211,7 +211,7 @@ def reorg_test(self):\n         self.disconnect_nodes(1, 2)\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n-        self.nodes[1].generate(300)\n+        self.generate(self.nodes[1], 300)\n \n         self.log.info(\"Reconnect nodes\")\n         self.connect_nodes(0, 1)\n@@ -263,7 +263,7 @@ def reorg_back(self):\n             self.nodes[0].invalidateblock(curchainhash)\n             assert_equal(self.nodes[0].getblockcount(), self.mainchainheight)\n             assert_equal(self.nodes[0].getbestblockhash(), self.mainchainhash2)\n-            goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n+            goalbesthash = self.generate(self.nodes[0], blocks_to_mine)[-1]\n             goalbestheight = first_reorg_height + 1\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n@@ -306,7 +306,7 @@ def has_block(index):\n         assert_equal(block1_details[\"nTx\"], len(block1_details[\"tx\"]))\n \n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n-        node.generate(6)\n+        self.generate(node, 6)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n         # Pruned block should still know the number of transactions\n@@ -337,7 +337,7 @@ def has_block(index):\n         assert has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n \n         # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n-        node.generate(288)\n+        self.generate(node, 288)\n         prune(1000)\n         assert not has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n         assert not has_block(3), \"blk00003.dat is still there, should be pruned by now\""
      },
      {
        "sha": "f0435b21b28acf3fda13b6ef21301b3206e2590a",
        "filename": "test/functional/feature_reindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_reindex.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -19,7 +19,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n \n     def reindex(self, justchainstate=False):\n-        self.nodes[0].generatetoaddress(3, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 3, self.nodes[0].get_deterministic_priv_key().address)\n         blockcount = self.nodes[0].getblockcount()\n         self.stop_nodes()\n         extra_args = [[\"-reindex-chainstate\" if justchainstate else \"-reindex\"]]"
      },
      {
        "sha": "2b79b3284c6f9958d8fa05ab59d21371342044f1",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -105,21 +105,21 @@ def setup_network(self):\n \n     def success_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n+        block = self.generate(node, 1)\n         assert_equal(len(node.getblock(block[0])[\"tx\"]), 2)\n         self.sync_blocks()\n \n     def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n+        block = self.generate(node, 1)\n         assert_equal(len(node.getblock(block[0])[\"tx\"]), 1)\n         self.sync_blocks()\n \n     def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n         assert_raises_rpc_error(-26, error_msg, send_to_witness, use_p2wsh=1, node=node, utxo=getutxo(txid), pubkey=self.pubkey[0], encode_p2sh=False, amount=Decimal(\"49.998\"), sign=sign, insert_redeem_script=redeem_script)\n \n     def run_test(self):\n-        self.nodes[0].generate(161)  # block 161\n+        self.generate(self.nodes[0], 161)  # block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -130,7 +130,7 @@ def run_test(self):\n         assert tmpl['transactions'][0]['hash'] == txid\n         assert tmpl['transactions'][0]['sigops'] == 2\n         assert '!segwit' not in tmpl['rules']\n-        self.nodes[0].generate(1)  # block 162\n+        self.generate(self.nodes[0], 1)  # block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n@@ -156,15 +156,15 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1)  # block 163\n+        self.generate(self.nodes[0], 1)  # block 163\n         self.sync_blocks()\n \n         # Make sure all nodes recognize the transactions as theirs\n         assert_equal(self.nodes[0].getbalance(), balance_presetup - 60 * 50 + 20 * Decimal(\"49.999\") + 50)\n         assert_equal(self.nodes[1].getbalance(), 20 * Decimal(\"49.999\"))\n         assert_equal(self.nodes[2].getbalance(), 20 * Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260)  # block 423\n+        self.generate(self.nodes[0], 260)  # block 423\n         self.sync_blocks()\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n@@ -177,11 +177,11 @@ def run_test(self):\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\", p2sh_ids[NODE_2][P2WPKH][1], sign=False)\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\", p2sh_ids[NODE_2][P2WSH][1], sign=False)\n \n-        self.nodes[2].generate(4)  # blocks 428-431\n+        self.generate(self.nodes[2], 4)  # blocks 428-431\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        blockhash = self.nodes[2].generate(1)[0]  # block 432 (first block with new rules; 432 = 144 * 3)\n+        blockhash = self.generate(self.nodes[2], 1)[0]  # block 432 (first block with new rules; 432 = 144 * 3)\n         self.sync_blocks()\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(blockhash)[\"tx\"]\n@@ -239,7 +239,7 @@ def run_test(self):\n         assert tmpl['transactions'][0]['sigops'] == 8\n         assert '!segwit' in tmpl['rules']\n \n-        self.nodes[0].generate(1)  # Mine a block to clear the gbt cache\n+        self.generate(self.nodes[0], 1)  # Mine a block to clear the gbt cache\n \n         self.log.info(\"Non-segwit miners are able to use GBT response after activation.\")\n         # Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->\n@@ -302,7 +302,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getmempoolentry(txid3)[\"weight\"], tx.get_weight())\n \n         # Mine a block to clear the gbt cache again.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"Verify behaviour of importaddress and listunspent\")\n \n@@ -592,7 +592,7 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         txid = self.nodes[0].sendrawtransaction(hexstring=signresults, maxfeerate=0)\n-        txs_mined[txid] = self.nodes[0].generate(1)[0]\n+        txs_mined[txid] = self.generate(self.nodes[0], 1)[0]\n         self.sync_blocks()\n         watchcount = 0\n         spendcount = 0\n@@ -642,7 +642,7 @@ def create_and_mine_tx_from_txids(self, txids, success=True):\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         self.nodes[0].sendrawtransaction(hexstring=signresults, maxfeerate=0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n "
      },
      {
        "sha": "94138b0e6d23e027a45e143a1300470310ca6bf1",
        "filename": "test/functional/feature_signet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_signet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_signet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_signet.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         assert_equal(mining_info['networkhashps'], Decimal('0'))\n         assert_equal(mining_info['pooledtx'], 0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"pregenerated signet blocks check\")\n "
      },
      {
        "sha": "c44a48f15fcf858af6cbee8c2f84e46eeaa91aae",
        "filename": "test/functional/feature_taproot.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -1461,7 +1461,7 @@ def test_spenders(self, node, spenders, input_counts):\n     def run_test(self):\n         # Post-taproot activation tests go first (pre-taproot tests' blocks are invalid post-taproot).\n         self.log.info(\"Post-activation tests...\")\n-        self.nodes[1].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[1], COINBASE_MATURITY + 1)\n         self.test_spenders(self.nodes[1], spenders_taproot_active(), input_counts=[1, 2, 2, 2, 2, 3])\n \n         # Re-connect nodes in case they have been disconnected"
      },
      {
        "sha": "b1b4703d37a88be41d6a2ab4c8ba238194c6bf1b",
        "filename": "test/functional/feature_utxo_set_hash.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_utxo_set_hash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_utxo_set_hash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_utxo_set_hash.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -31,13 +31,13 @@ def test_muhash_implementation(self):\n \n         # Generate 100 blocks and remove the first since we plan to spend its\n         # coinbase\n-        block_hashes = wallet.generate(1) + node.generate(99)\n+        block_hashes = self.generate(wallet, 1) + self.generate(node, 99)\n         blocks = list(map(lambda block: from_hex(CBlock(), node.getblock(block, False)), block_hashes))\n         blocks.pop(0)\n \n         # Create a spending transaction and mine a block which includes it\n         txid = wallet.send_self_transfer(from_node=node)['txid']\n-        tx_block = node.generateblock(output=wallet.get_address(), transactions=[txid])\n+        tx_block = self.generateblock(node, output=wallet.get_address(), transactions=[txid])\n         blocks.append(from_hex(CBlock(), node.getblock(tx_block['hash'], False)))\n \n         # Serialize the outputs that should be in the UTXO set and add them to"
      },
      {
        "sha": "311d871d495526749cf9b943aeba4303624e607d",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -65,34 +65,34 @@ def run_test(self):\n \n         node_deterministic_address = node.get_deterministic_priv_key().address\n         # Mine one period worth of blocks\n-        node.generatetoaddress(VB_PERIOD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD, node_deterministic_address)\n \n         self.log.info(\"Check that there is no warning if previous VB_BLOCKS have <VB_THRESHOLD blocks with unknown versionbits version.\")\n         # Build one period of blocks with < VB_THRESHOLD blocks signaling some unknown bit\n         self.send_blocks_with_version(peer, VB_THRESHOLD - 1, VB_UNKNOWN_VERSION)\n-        node.generatetoaddress(VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n \n         # Check that we're not getting any versionbit-related errors in get*info()\n         assert not VB_PATTERN.match(node.getmininginfo()[\"warnings\"])\n         assert not VB_PATTERN.match(node.getnetworkinfo()[\"warnings\"])\n \n         # Build one period of blocks with VB_THRESHOLD blocks signaling some unknown bit\n         self.send_blocks_with_version(peer, VB_THRESHOLD, VB_UNKNOWN_VERSION)\n-        node.generatetoaddress(VB_PERIOD - VB_THRESHOLD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD - VB_THRESHOLD, node_deterministic_address)\n \n         self.log.info(\"Check that there is a warning if previous VB_BLOCKS have >=VB_THRESHOLD blocks with unknown versionbits version.\")\n         # Mine a period worth of expected blocks so the generic block-version warning\n         # is cleared. This will move the versionbit state to ACTIVE.\n-        node.generatetoaddress(VB_PERIOD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD, node_deterministic_address)\n \n         # Stop-start the node. This is required because bitcoind will only warn once about unknown versions or unknown rules activating.\n         self.restart_node(0)\n \n         # Generating one block guarantees that we'll get out of IBD\n-        node.generatetoaddress(1, node_deterministic_address)\n+        self.generatetoaddress(node, 1, node_deterministic_address)\n         self.wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'])\n         # Generating one more block will be enough to generate an error.\n-        node.generatetoaddress(1, node_deterministic_address)\n+        self.generatetoaddress(node, 1, node_deterministic_address)\n         # Check that get*info() shows the versionbits unknown rules warning\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"]\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"]"
      },
      {
        "sha": "89503adda36fd8d854d9eb0a984ed721bf7f921d",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -77,7 +77,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         \"\"\"Main test logic\"\"\"\n-        self.nodes[0].generate(BLOCKS)\n+        self.generate(self.nodes[0], BLOCKS)\n \n         self.log.info(\"Compare responses from getblockchaininfo RPC and `bitcoin-cli getblockchaininfo`\")\n         cli_response = self.nodes[0].cli.getblockchaininfo()\n@@ -158,7 +158,7 @@ def run_test(self):\n             w1.sendtoaddress(w3.getnewaddress(), amounts[2])\n \n             # Mine a block to confirm; adds a block reward (50 BTC) to the default wallet.\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n             self.log.info(\"Test -getinfo with multiple wallets and -rpcwallet returns specified wallet balance\")\n             for i in range(len(wallets)):\n@@ -291,7 +291,7 @@ def run_test(self):\n             assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate', 1, 2, 3).echo)\n         else:\n             self.log.info(\"*** Wallet not compiled; cli getwalletinfo and -getinfo wallet tests skipped\")\n-            self.nodes[0].generate(25)  # maintain block parity with the wallet_compiled conditional branch\n+            self.generate(self.nodes[0], 25)  # maintain block parity with the wallet_compiled conditional branch\n \n         self.log.info(\"Test -version with node stopped\")\n         self.stop_node(0)"
      },
      {
        "sha": "e0716fc54a37560043719bf2680d4401b48486c6",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -80,9 +80,9 @@ def run_test(self):\n         # Random address so node1's balance doesn't increase\n         not_related_address = \"2MxqoHEdNQTyYeX1mHcbrrpzgojbosTpCvJ\"\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n-        self.nodes[1].generatetoaddress(100, not_related_address)\n+        self.generatetoaddress(self.nodes[1], 100, not_related_address)\n         self.sync_all()\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -107,7 +107,7 @@ def run_test(self):\n \n         self.log.info(\"Query an unspent TXO using the /getutxos URI\")\n \n-        self.nodes[1].generatetoaddress(1, not_related_address)\n+        self.generatetoaddress(self.nodes[1], 1, not_related_address)\n         self.sync_all()\n         bb_hash = self.nodes[0].getbestblockhash()\n \n@@ -182,7 +182,7 @@ def run_test(self):\n         json_obj = self.test_rest_request(f\"/getutxos/checkmempool/{spent[0]}-{spent[1]}\")\n         assert_equal(len(json_obj['utxos']), 0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         json_obj = self.test_rest_request(f\"/getutxos/{spending[0]}-{spending[1]}\")\n@@ -203,7 +203,7 @@ def run_test(self):\n         long_uri = '/'.join([f'{txid}-{n_}' for n_ in range(15)])\n         self.test_rest_request(f\"/getutxos/checkmempool/{long_uri}\", http_method='POST', status=200)\n \n-        self.nodes[0].generate(1)  # generate block to not affect upcoming tests\n+        self.generate(self.nodes[0], 1)  # generate block to not affect upcoming tests\n         self.sync_all()\n \n         self.log.info(\"Test the /block, /blockhashbyheight and /headers URIs\")\n@@ -274,7 +274,7 @@ def run_test(self):\n             assert_equal(json_obj[0][key], rpc_block_json[key])\n \n         # See if we can get 5 headers in one response\n-        self.nodes[1].generate(5)\n+        self.generate(self.nodes[1], 5)\n         self.sync_all()\n         json_obj = self.test_rest_request(f\"/headers/5/{bb_hash}\")\n         assert_equal(len(json_obj), 5)  # now we should have 5 header objects\n@@ -302,7 +302,7 @@ def run_test(self):\n             assert_equal(json_obj[tx]['depends'], txs[i - 1:i])\n \n         # Now mine the transactions\n-        newblockhash = self.nodes[1].generate(1)\n+        newblockhash = self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         # Check if the 3 tx show up in the new block"
      },
      {
        "sha": "1b2a7c20d12d0e9b3170519fce3d70c500a27eb0",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -185,7 +185,7 @@ def test_basic(self):\n \n         num_blocks = 5\n         self.log.info(f\"Generate {num_blocks} blocks (and {num_blocks} coinbase txes)\")\n-        genhashes = self.nodes[0].generatetoaddress(num_blocks, ADDRESS_BCRT1_UNSPENDABLE)\n+        genhashes = self.generatetoaddress(self.nodes[0], num_blocks, ADDRESS_BCRT1_UNSPENDABLE)\n \n         self.sync_all()\n \n@@ -226,7 +226,7 @@ def test_basic(self):\n \n             # Mining the block with this tx should result in second notification\n             # after coinbase tx notification\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             hashtx.receive()\n             txid = hashtx.receive()\n             assert_equal(payment_txid, txid.hex())\n@@ -257,14 +257,14 @@ def test_reorg(self):\n \n         # Generate 1 block in nodes[0] with 1 mempool tx and receive all notifications\n         payment_txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-        disconnect_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        disconnect_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n         disconnect_cb = self.nodes[0].getblock(disconnect_block)[\"tx\"][0]\n         assert_equal(self.nodes[0].getbestblockhash(), hashblock.receive().hex())\n         assert_equal(hashtx.receive().hex(), payment_txid)\n         assert_equal(hashtx.receive().hex(), disconnect_cb)\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure split\n-        connect_blocks = self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        connect_blocks = self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -308,13 +308,13 @@ def test_sequence(self):\n         seq_num = 1\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        dc_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        dc_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n \n         # Note: We are not notified of any block transactions, coinbase or mined\n         assert_equal((self.nodes[0].getbestblockhash(), \"C\", None), seq.receive_sequence())\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure a chain split\n-        self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -349,7 +349,7 @@ def test_sequence(self):\n             # though the mempool sequence number does go up by the number of transactions\n             # removed from the mempool by the block mining it.\n             mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             self.sync_all()\n             # Make sure the number of mined transactions matches the number of txs out of mempool\n             mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n@@ -389,7 +389,7 @@ def test_sequence(self):\n \n             # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n             self.nodes[0].reconsiderblock(best_hash)\n-            self.nodes[1].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_all()\n \n             self.log.info(\"Evict mempool transaction by block conflict\")\n@@ -441,7 +441,7 @@ def test_sequence(self):\n             # Last tx\n             assert_equal((orig_txid_2, \"A\", mempool_seq), seq.receive_sequence())\n             mempool_seq += 1\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_all()  # want to make sure we didn't break \"consensus\" for other tests\n \n     def test_mempool_sync(self):\n@@ -493,7 +493,7 @@ def test_mempool_sync(self):\n             txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n         self.nodes[0].bumpfee(txids[-1])\n         self.sync_all()\n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n         final_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True)\n \n         # 3) Consume ZMQ backlog until we get to \"now\" for the mempool snapshot\n@@ -549,7 +549,7 @@ def test_mempool_sync(self):\n \n         # 5) If you miss a zmq/mempool sequence number, go back to step (2)\n \n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n \n     def test_multiple_interfaces(self):\n         # Set up two subscribers with different addresses\n@@ -562,7 +562,7 @@ def test_multiple_interfaces(self):\n         ], sync_blocks=False)\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n \n         # Should receive the same block hash on both subscribers\n         assert_equal(self.nodes[0].getbestblockhash(), subscribers[0].receive().hex())"
      },
      {
        "sha": "2ee440bcb79cd67482f4cb155791384c8d32c676",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -78,7 +78,7 @@ def run_test(self):\n             outputs=[{node.getnewaddress(): 0.3}, {node.getnewaddress(): 49}],\n         ))['hex']\n         txid_in_block = node.sendrawtransaction(hexstring=raw_tx_in_block, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n         self.mempool_size = 0\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': 'txn-already-known'}],\n@@ -172,7 +172,7 @@ def run_test(self):\n             outputs=[{node.getnewaddress(): 0.1}]\n         ))['hex']\n         txid_spend_both = node.sendrawtransaction(hexstring=raw_tx_spend_both, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n         self.mempool_size = 0\n         # Now see if we can add the coins back to the utxo set by sending the exact txs again\n         self.check_mempool_result("
      },
      {
        "sha": "4767d6db22c669de3c143f54c601205665231ebf",
        "filename": "test/functional/mempool_accept_wtxid.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_accept_wtxid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_accept_wtxid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept_wtxid.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -44,7 +44,7 @@ def run_test(self):\n \n         self.log.info('Start with empty mempool and 101 blocks')\n         # The last 100 coinbase transactions are premature\n-        blockhash = node.generate(101)[0]\n+        blockhash = self.generate(node, 101)[0]\n         txid = node.getblock(blockhash=blockhash, verbosity=2)[\"tx\"][0][\"txid\"]\n         assert_equal(node.getmempoolinfo()['size'], 0)\n \n@@ -62,7 +62,7 @@ def run_test(self):\n         privkeys = [node.get_deterministic_priv_key().key]\n         raw_parent = node.signrawtransactionwithkey(hexstring=parent.serialize().hex(), privkeys=privkeys)['hex']\n         parent_txid = node.sendrawtransaction(hexstring=raw_parent, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n \n         peer_wtxid_relay = node.add_p2p_connection(P2PTxInvStore())\n "
      },
      {
        "sha": "a9f09b1cf81aee33ebf88cbee4e7e6b39e1de74d",
        "filename": "test/functional/mempool_compatibility.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_compatibility.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -38,8 +38,8 @@ def run_test(self):\n \n         old_node, new_node = self.nodes\n         new_wallet = MiniWallet(new_node)\n-        new_wallet.generate(1)\n-        new_node.generate(COINBASE_MATURITY)\n+        self.generate(new_wallet, 1)\n+        self.generate(new_node, COINBASE_MATURITY)\n         # Sync the nodes to ensure old_node has the block that contains the coinbase that new_wallet will spend.\n         # Otherwise, because coinbases are only valid in a block and not as loose txns, if the nodes aren't synced\n         # unbroadcasted_tx won't pass old_node's `MemPoolAccept::PreChecks`."
      },
      {
        "sha": "942f79e8b0ad0f3cfb6018cf63aa28dffb5b8863",
        "filename": "test/functional/mempool_expiry.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_expiry.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_expiry.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_expiry.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -36,8 +36,8 @@ def test_transaction_expiry(self, timeout):\n         self.wallet = MiniWallet(node)\n \n         # Add enough mature utxos to the wallet so that all txs spend confirmed coins.\n-        self.wallet.generate(4)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(self.wallet, 4)\n+        self.generate(node, COINBASE_MATURITY)\n \n         # Send a parent transaction that will expire.\n         parent_txid = self.wallet.send_self_transfer(from_node=node)['txid']"
      },
      {
        "sha": "c149f41a492588f39fb576bc2a8729476477a027",
        "filename": "test/functional/mempool_package_limits.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_package_limits.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_package_limits.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_limits.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -40,7 +40,7 @@ def run_test(self):\n         self.address = node.get_deterministic_priv_key().address\n         self.coins = []\n         # The last 100 coinbase transactions are premature\n-        for b in node.generatetoaddress(200, self.address)[:100]:\n+        for b in self.generatetoaddress(node, 200, self.address)[:100]:\n             coinbase = node.getblock(blockhash=b, verbosity=2)[\"tx\"][0]\n             self.coins.append({\n                 \"txid\": coinbase[\"txid\"],\n@@ -83,7 +83,7 @@ def test_chain_limits_helper(self, mempool_count, package_count):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=chain_hex)])\n \n     def test_chain_limits(self):\n@@ -174,7 +174,7 @@ def test_desc_count_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n     def test_anc_count_limits(self):\n@@ -230,7 +230,7 @@ def test_anc_count_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n     def test_anc_count_limits_2(self):\n@@ -288,7 +288,7 @@ def test_anc_count_limits_2(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=[pc_hex, pd_hex])])\n \n     def test_anc_count_limits_bushy(self):\n@@ -338,7 +338,7 @@ def test_anc_count_limits_bushy(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n     def test_anc_size_limits(self):\n@@ -397,7 +397,7 @@ def test_anc_size_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=[pc_hex, pd_hex])])\n \n     def test_desc_size_limits(self):\n@@ -468,7 +468,7 @@ def test_desc_size_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n if __name__ == \"__main__\":"
      },
      {
        "sha": "69c21f32bc9441c5b4477d1ac2e7a7cf976e4b44",
        "filename": "test/functional/mempool_package_onemore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_package_onemore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_package_onemore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_onemore.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -30,7 +30,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         # Mine some blocks and have them mature.\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         utxo = self.nodes[0].listunspent(10)\n         txid = utxo[0]['txid']\n         vout = utxo[0]['vout']"
      },
      {
        "sha": "b9344ad6da1a6ee1570e9bbaaf4014c59e074d75",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -46,7 +46,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         # Mine some blocks and have them mature.\n         peer_inv_store = self.nodes[0].add_p2p_connection(P2PTxInvStore()) # keep track of invs\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         utxo = self.nodes[0].listunspent(10)\n         txid = utxo[0]['txid']\n         vout = utxo[0]['vout']\n@@ -179,7 +179,7 @@ def run_test(self):\n \n         # Check that prioritising a tx before it's added to the mempool works\n         # First clear the mempool by mining a block.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         # Prioritise a transaction that has been mined, then add it back to the\n@@ -270,7 +270,7 @@ def run_test(self):\n \n         # Test reorg handling\n         # First, the basics:\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.nodes[1].invalidateblock(self.nodes[0].getbestblockhash())\n         self.nodes[1].reconsiderblock(self.nodes[0].getbestblockhash())\n@@ -317,7 +317,7 @@ def run_test(self):\n             value = sent_value\n \n         # Mine these in a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Now generate tx8, with a big fee"
      },
      {
        "sha": "56f7cbe6a53099a5f4e47c7299a640df520c4cc5",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -160,7 +160,7 @@ def test_persist_unbroadcast(self):\n         self.start_node(0)\n \n         # clear out mempool\n-        node0.generate(1)\n+        self.generate(node0, 1)\n \n         # ensure node0 doesn't have any connections\n         # make a transaction that will remain in the unbroadcast set"
      },
      {
        "sha": "0ee6af62f61ae344344c0472c99e9c29ed069d29",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -65,7 +65,7 @@ def run_test(self):\n         wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_2['hex'])\n         wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_3['hex'])\n         self.log.info(\"Generate a block\")\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.log.info(\"Check that time-locked transaction is still too immature to spend\")\n         assert_raises_rpc_error(-26, 'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n \n@@ -78,7 +78,7 @@ def run_test(self):\n         self.log.info(\"Broadcast and mine spend_3_1\")\n         spend_3_1_id = self.nodes[0].sendrawtransaction(spend_3_1['hex'])\n         self.log.info(\"Generate a block\")\n-        last_block = self.nodes[0].generate(1)\n+        last_block = self.generate(self.nodes[0], 1)\n         # Sync blocks, so that peer 1 gets the block before timelock_tx\n         # Otherwise, peer 1 would put the timelock_tx in m_recent_rejects\n         self.sync_all()"
      },
      {
        "sha": "4fce07dad3d7dd2badbdd5e556fbb2870cea2fc9",
        "filename": "test/functional/mempool_resurrect.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_resurrect.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_resurrect.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -20,8 +20,8 @@ def run_test(self):\n         wallet = MiniWallet(node)\n \n         # Add enough mature utxos to the wallet so that all txs spend confirmed coins\n-        wallet.generate(3)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(wallet, 3)\n+        self.generate(node, COINBASE_MATURITY)\n \n         # Spend block 1/2/3's coinbase transactions\n         # Mine a block\n@@ -34,9 +34,9 @@ def run_test(self):\n         # ... make sure all the transactions are confirmed again\n         blocks = []\n         spends1_ids = [wallet.send_self_transfer(from_node=node)['txid'] for _ in range(3)]\n-        blocks.extend(node.generate(1))\n+        blocks.extend(self.generate(node, 1))\n         spends2_ids = [wallet.send_self_transfer(from_node=node)['txid'] for _ in range(3)]\n-        blocks.extend(node.generate(1))\n+        blocks.extend(self.generate(node, 1))\n \n         spends_ids = set(spends1_ids + spends2_ids)\n \n@@ -53,7 +53,7 @@ def run_test(self):\n         assert_equal(set(node.getrawmempool()), spends_ids)\n \n         # Generate another block, they should all get mined\n-        blocks = node.generate(1)\n+        blocks = self.generate(node, 1)\n         # mempool should be empty, all txns confirmed\n         assert_equal(set(node.getrawmempool()), set())\n         confirmed_txns = set(node.getblock(blocks[0])['tx'])"
      },
      {
        "sha": "e97595ed867ab8379b8863890f112d8eca189713",
        "filename": "test/functional/mempool_spend_coinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_spend_coinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_spend_coinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spend_coinbase.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -49,7 +49,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getrawmempool(), [spend_mature_id])\n \n         # mine a block, mature one should get confirmed\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n \n         # ... and now previously immature can be spent:"
      },
      {
        "sha": "4d6379fe8644ff5dc325c59fe1765fd7afed7d52",
        "filename": "test/functional/mempool_unbroadcast.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_unbroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_unbroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_unbroadcast.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -109,7 +109,7 @@ def test_txn_removal(self):\n         # a block\n         removal_reason = \"Removed {} from set of unbroadcast txns before confirmation that txn was sent out\".format(txhsh)\n         with node.assert_debug_log([removal_reason]):\n-            node.generate(1)\n+            self.generate(node, 1)\n \n if __name__ == \"__main__\":\n     MempoolUnbroadcastTest().main()"
      },
      {
        "sha": "22f136d1a5c33007ea908b9cefcc6400a30a7dfa",
        "filename": "test/functional/mempool_updatefromblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_updatefromblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mempool_updatefromblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_updatefromblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -91,7 +91,7 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n             if tx_count in n_tx_to_mine:\n                 # The created transactions are mined into blocks by batches.\n                 self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n+                block_hash = self.generate(self.nodes[0], 1)[0]\n                 if not first_block_hash:\n                     first_block_hash = block_hash\n                 assert_equal(len(self.nodes[0].getrawmempool()), 0)"
      },
      {
        "sha": "f141d201ebc74d64dfc9690d481f7c199ff68c50",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -58,7 +58,7 @@ def mine_chain(self):\n         self.log.info('Create some old blocks')\n         for t in range(TIME_GENESIS_BLOCK, TIME_GENESIS_BLOCK + 200 * 600, 600):\n             self.nodes[0].setmocktime(t)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n         mining_info = self.nodes[0].getmininginfo()\n         assert_equal(mining_info['blocks'], 200)\n         assert_equal(mining_info['currentblocktx'], 0)\n@@ -109,7 +109,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert_equal(witness_commitment, script.hex())\n \n         # Mine a block to leave initial block download and clear the mempool\n-        node.generatetoaddress(1, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 1, node.get_deterministic_priv_key().address)\n         tmpl = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n         self.log.info(\"getblocktemplate: Test capability advertised\")\n         assert 'proposal' in tmpl['capabilities']\n@@ -271,7 +271,7 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n         assert chain_tip(block.hash, status='active', branchlen=0) in node.getchaintips()\n \n         # Building a few blocks should give the same results\n-        node.generatetoaddress(10, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 10, node.get_deterministic_priv_key().address)\n         assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=CBlockHeader(bad_block_time).serialize().hex()))\n         assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=CBlockHeader(bad_block2).serialize().hex()))\n         node.submitheader(hexdata=CBlockHeader(block).serialize().hex())"
      },
      {
        "sha": "0879fb9f2df1e47beaaa4988092a8c0636c53402",
        "filename": "test/functional/mining_getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_getblocktemplate_longpoll.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -35,7 +35,7 @@ def set_test_params(self):\n     def run_test(self):\n         self.log.info(\"Warning: this test will take about 70 seconds in the best case. Be patient.\")\n         self.log.info(\"Test that longpollid doesn't change between successive getblocktemplate() invocations if nothing else happens\")\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n         template = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         longpollid = template['longpollid']\n         template2 = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n@@ -63,7 +63,7 @@ def run_test(self):\n         assert not thr.is_alive()\n \n         # Add enough mature utxos to the wallets, so that all txs spend confirmed coins\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n         self.sync_blocks()\n \n         self.log.info(\"Test that introducing a new transaction into the mempool will terminate the longpoll\")"
      },
      {
        "sha": "da85ee54be055f6a39d1a0ed186d5f3e6ec73ee4",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -75,7 +75,7 @@ def run_test(self):\n         # also check that a different entry in the cheapest bucket is NOT mined\n         self.nodes[0].prioritisetransaction(txid=txids[0][0], fee_delta=int(3*base_fee*COIN))\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         mempool = self.nodes[0].getrawmempool()\n         self.log.info(\"Assert that prioritised transaction was mined\")\n@@ -105,7 +105,7 @@ def run_test(self):\n         # the other high fee transactions. Keep mining until our mempool has\n         # decreased by all the high fee size that we calculated above.\n         while (self.nodes[0].getmempoolinfo()['bytes'] > sizes[0] + sizes[1]):\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         # High fee transaction should not have been mined, but other high fee rate\n         # transactions should have been."
      },
      {
        "sha": "3a4fcc4549192e5a26d8a96993829bcb84b5ed98",
        "filename": "test/functional/p2p_blockfilters.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_blockfilters.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_blockfilters.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blockfilters.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -56,17 +56,17 @@ def run_test(self):\n         peer_1 = self.nodes[1].add_p2p_connection(FiltersClient())\n \n         # Nodes 0 & 1 share the same first 999 blocks in the chain.\n-        self.nodes[0].generate(999)\n+        self.generate(self.nodes[0], 999)\n         self.sync_blocks(timeout=600)\n \n         # Stale blocks by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        stale_block_hash = self.nodes[0].generate(1)[0]\n+        stale_block_hash = self.generate(self.nodes[0], 1)[0]\n         self.nodes[0].syncwithvalidationinterfacequeue()\n         assert_equal(self.nodes[0].getblockcount(), 1000)\n \n-        self.nodes[1].generate(1001)\n+        self.generate(self.nodes[1], 1001)\n         assert_equal(self.nodes[1].getblockcount(), 2000)\n \n         # Check that nodes have signalled NODE_COMPACT_FILTERS correctly."
      },
      {
        "sha": "480bff361d1381aa6a1c5373ecfdc0bf8fed912b",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -23,8 +23,8 @@ def set_test_params(self):\n     def run_test(self):\n         self.miniwallet = MiniWallet(self.nodes[0])\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        self.miniwallet.generate(2)\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(self.miniwallet, 2)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n \n         self.blocksonly_mode_tests()\n         self.blocks_relay_conn_tests()\n@@ -73,7 +73,7 @@ def blocksonly_mode_tests(self):\n         self.log.info(\"Relay-permission peer's transaction is accepted and relayed\")\n \n         self.nodes[0].disconnect_p2ps()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     def blocks_relay_conn_tests(self):\n         self.log.info('Tests with node in normal mode with block-relay-only connections')"
      },
      {
        "sha": "3f01d552b29137251cc2a3b6aec312f0f72bb73b",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -165,7 +165,7 @@ def make_utxos(self):\n         block = self.build_block_on_tip(self.nodes[0])\n         self.segwit_node.send_and_ping(msg_no_witness_block(block))\n         assert int(self.nodes[0].getbestblockhash(), 16) == block.sha256\n-        self.nodes[0].generatetoaddress(COINBASE_MATURITY, self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY, self.nodes[0].getnewaddress(address_type=\"bech32\"))\n \n         total_value = block.vtx[0].vout[0].nValue\n         out_value = total_value // 10\n@@ -212,7 +212,7 @@ def received_sendcmpct():\n \n         def check_announcement_of_new_block(node, peer, predicate):\n             peer.clear_block_announcement()\n-            block_hash = int(node.generate(1)[0], 16)\n+            block_hash = int(self.generate(node, 1)[0], 16)\n             peer.wait_for_block_announcement(block_hash, timeout=30)\n             assert peer.block_announced\n \n@@ -276,7 +276,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         block = self.build_block_on_tip(self.nodes[0])\n \n         cmpct_block = P2PHeaderAndShortIDs()\n@@ -294,7 +294,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         version = test_node.cmpct_version\n         node = self.nodes[0]\n         # Generate a bunch of transactions.\n-        node.generate(COINBASE_MATURITY + 1)\n+        self.generate(node, COINBASE_MATURITY + 1)\n         num_transactions = 25\n         address = node.getnewaddress()\n \n@@ -318,7 +318,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n \n         # Now mine a block, and look at the resulting compact block.\n         test_node.clear_block_announcement()\n-        block_hash = int(node.generate(1)[0], 16)\n+        block_hash = int(self.generate(node, 1)[0], 16)\n \n         # Store the raw block in our internal format.\n         block = from_hex(CBlock(), node.getblock(\"%064x\" % block_hash, False))\n@@ -660,15 +660,15 @@ def test_compactblocks_not_at_tip(self, test_node):\n         new_blocks = []\n         for _ in range(MAX_CMPCTBLOCK_DEPTH + 1):\n             test_node.clear_block_announcement()\n-            new_blocks.append(node.generate(1)[0])\n+            new_blocks.append(self.generate(node, 1)[0])\n             test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n         test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         test_node.clear_block_announcement()\n-        node.generate(1)\n+        self.generate(node, 1)\n         test_node.wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with p2p_lock:\n@@ -844,7 +844,7 @@ def assert_highbandwidth_states(node, hb_to, hb_from):\n \n     def run_test(self):\n         # Get the nodes out of IBD\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Setup the p2p connections\n         self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))"
      },
      {
        "sha": "72b3897b4f81c151701251e956064d4ae5791a56",
        "filename": "test/functional/p2p_compactblocks_hb.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_compactblocks_hb.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_compactblocks_hb.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks_hb.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -30,7 +30,7 @@ def setup_network(self):\n     def relay_block_through(self, peer):\n         \"\"\"Relay a new block through peer peer, and return HB status between 1 and [2,3,4,5].\"\"\"\n         self.connect_nodes(peer, 0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.disconnect_nodes(peer, 0)\n         status_to = [self.peer_info(1, i)['bip152_hb_to'] for i in range(2, 6)]\n@@ -44,7 +44,7 @@ def run_test(self):\n         # Connect everyone to node 0, and mine some blocks to get all nodes out of IBD.\n         for i in range(1, 6):\n             self.connect_nodes(i, 0)\n-        self.nodes[0].generate(2)\n+        self.generate(self.nodes[0], 2)\n         self.sync_blocks()\n         for i in range(1, 6):\n             self.disconnect_nodes(i, 0)"
      },
      {
        "sha": "4ccc94216427dffba515d9c71cdb5d24cba26d0d",
        "filename": "test/functional/p2p_eviction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_eviction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_eviction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_eviction.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -53,7 +53,7 @@ def run_test(self):\n         protected_peers = set()  # peers that we expect to be protected from eviction\n         current_peer = -1\n         node = self.nodes[0]\n-        node.generatetoaddress(COINBASE_MATURITY + 1, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, COINBASE_MATURITY + 1, node.get_deterministic_priv_key().address)\n \n         self.log.info(\"Create 4 peers and protect them from eviction by sending us a block\")\n         for _ in range(4):"
      },
      {
        "sha": "60adc2c7fa15ccdf5a09ca42887ee9fbc89f2571",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -81,8 +81,8 @@ def test_feefilter(self):\n         node0 = self.nodes[0]\n         miniwallet = MiniWallet(node1)\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        miniwallet.generate(5)\n-        node1.generate(COINBASE_MATURITY)\n+        self.generate(miniwallet, 5)\n+        self.generate(node1, COINBASE_MATURITY)\n \n         conn = self.nodes[0].add_p2p_connection(TestP2PConn())\n "
      },
      {
        "sha": "a040665fbac5bf0593dfae0f95ae64fd9a4a4764",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -149,7 +149,7 @@ def test_frelay_false(self, filter_peer):\n         assert not filter_peer.tx_received\n \n         # Clear the mempool so that this transaction does not impact subsequent tests\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     def test_filter(self, filter_peer):\n         # Set the bloomfilter using filterload\n@@ -159,14 +159,14 @@ def test_filter(self, filter_peer):\n         filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['address']\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n-        block_hash = self.nodes[0].generatetoaddress(1, filter_address)[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, filter_address)[0]\n         txid = self.nodes[0].getblock(block_hash)['tx'][0]\n         filter_peer.wait_for_merkleblock(block_hash)\n         filter_peer.wait_for_tx(txid)\n \n         self.log.info('Check that we only receive a merkleblock if the filter does not match a tx in a block')\n         filter_peer.tx_received = False\n-        block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, self.nodes[0].getnewaddress())[0]\n         filter_peer.wait_for_merkleblock(block_hash)\n         assert not filter_peer.tx_received\n \n@@ -194,7 +194,7 @@ def test_filter(self, filter_peer):\n         filter_peer.merkleblock_received = False\n         filter_peer.tx_received = False\n         with self.nodes[0].assert_debug_log(expected_msgs=['received getdata']):\n-            block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n+            block_hash = self.generatetoaddress(self.nodes[0], 1, self.nodes[0].getnewaddress())[0]\n             filter_peer.wait_for_inv([CInv(MSG_BLOCK, int(block_hash, 16))])\n             filter_peer.sync_with_ping()\n             assert not filter_peer.merkleblock_received"
      },
      {
        "sha": "2962dc8085526b1450d676de7c16a521463fb463",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -69,7 +69,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(int(time.time()) - 60 * 24 * 60 * 60)\n \n         # Generating a chain of 10 blocks\n-        block_hashes = self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        block_hashes = self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n \n         # Create longer chain starting 2 blocks before current tip\n         height = len(block_hashes) - 2\n@@ -98,7 +98,7 @@ def run_test(self):\n \n         # Longest chain is extended so stale is much older than chain tip\n         self.nodes[0].setmocktime(0)\n-        block_hash = int(self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)[-1], 16)\n+        block_hash = int(self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)[-1], 16)\n         assert_equal(self.nodes[0].getblockcount(), 14)\n         node0.wait_for_block(block_hash, timeout=3)\n "
      },
      {
        "sha": "c35053d9d4571a70d34185c84958c980da789eb0",
        "filename": "test/functional/p2p_ibd_txrelay.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_ibd_txrelay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_ibd_txrelay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_ibd_txrelay.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -29,7 +29,7 @@ def run_test(self):\n             self.wait_until(lambda: all(peer['minfeefilter'] == MAX_FEE_FILTER for peer in node.getpeerinfo()))\n \n         # Come out of IBD by generating a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         self.log.info(\"Check that nodes reset minfilter after coming out of IBD\")"
      },
      {
        "sha": "875ab52db42b14f04e942df86cb8ba13992b1e25",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         peer.send_blocks_and_test([block1], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n-        node.generatetoaddress(100, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 100, node.get_deterministic_priv_key().address)\n \n         best_block = node.getblock(node.getbestblockhash())\n         tip = int(node.getbestblockhash(), 16)"
      },
      {
        "sha": "a586b48d4c00bec10137a53959510eae05631384",
        "filename": "test/functional/p2p_invalid_locator.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_locator.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_locator.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_locator.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -16,7 +16,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         node = self.nodes[0]  # convenience reference to the node\n-        node.generatetoaddress(1, node.get_deterministic_priv_key().address)  # Get node out of IBD\n+        self.generatetoaddress(node, 1, node.get_deterministic_priv_key().address)  # Get node out of IBD\n \n         self.log.info('Test max locator size')\n         block_count = node.getblockcount()"
      },
      {
        "sha": "0a3ae23f5857c872e3b02c91487e5126f4a3ff5d",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -64,7 +64,7 @@ def run_test(self):\n         node.p2ps[0].send_blocks_and_test([block], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n-        self.nodes[0].generatetoaddress(100, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 100, self.nodes[0].get_deterministic_priv_key().address)\n \n         # Iterate through a list of known invalid transaction types, ensuring each is\n         # rejected. Some are consensus invalid and some just violate policy."
      },
      {
        "sha": "de58e07aad554b22e79f2e5e6ab6e9a1cfb3d244",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -133,7 +133,7 @@ def run_test(self):\n         pre_wtxidrelay_peer.wait_until(lambda: pre_wtxidrelay_peer.version_received)\n \n         # Mine a block and make sure that it's not sent to the connected peers\n-        self.nodes[0].generate(nblocks=1)\n+        self.generate(self.nodes[0], nblocks=1)\n \n         # Give the node enough time to possibly leak out a message\n         time.sleep(PEER_TIMEOUT + 2)"
      },
      {
        "sha": "9b80e1b87752e6755c8a46c3291c908dc76f740b",
        "filename": "test/functional/p2p_leak_tx.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_leak_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_leak_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak_tx.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -27,8 +27,8 @@ def run_test(self):\n         gen_node = self.nodes[0]  # The block and tx generating node\n         miniwallet = MiniWallet(gen_node)\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        miniwallet.generate(1)\n-        gen_node.generate(COINBASE_MATURITY)\n+        self.generate(miniwallet, 1)\n+        self.generate(gen_node, COINBASE_MATURITY)\n \n         inbound_peer = self.nodes[0].add_p2p_connection(P2PNode())  # An \"attacking\" inbound peer\n "
      },
      {
        "sha": "e491fe7e07324505119a79ead3881958c782becd",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -59,7 +59,7 @@ def run_test(self):\n \n         self.log.info(\"Mine enough blocks to reach the NODE_NETWORK_LIMITED range.\")\n         self.connect_nodes(0, 1)\n-        blocks = self.nodes[1].generatetoaddress(292, self.nodes[1].get_deterministic_priv_key().address)\n+        blocks = self.generatetoaddress(self.nodes[1], 292, self.nodes[1].get_deterministic_priv_key().address)\n         self.sync_blocks([self.nodes[0], self.nodes[1]])\n \n         self.log.info(\"Make sure we can max retrieve block at tip-288.\")\n@@ -101,7 +101,7 @@ def run_test(self):\n         self.disconnect_all()\n \n         # mine 10 blocks on node 0 (pruned node)\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n \n         # connect node1 (non pruned) with node0 (pruned) and check if the can sync\n         self.connect_nodes(0, 1)"
      },
      {
        "sha": "32f2ea14e19455746a34e34e3eec008358437ea1",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -93,7 +93,7 @@ def run_test(self):\n         self.nodes[1].assert_start_raises_init_error([\"-whitebind=noban@127.0.0.1/10\"], \"Cannot resolve -whitebind address\", match=ErrorMatch.PARTIAL_REGEX)\n \n     def check_tx_relay(self):\n-        block_op_true = self.nodes[0].getblock(self.nodes[0].generatetoaddress(100, ADDRESS_BCRT1_P2WSH_OP_TRUE)[0])\n+        block_op_true = self.nodes[0].getblock(self.generatetoaddress(self.nodes[0], 100, ADDRESS_BCRT1_P2WSH_OP_TRUE)[0])\n         self.sync_all()\n \n         self.log.debug(\"Create a connection from a forcerelay peer that rebroadcasts raw txs\")"
      },
      {
        "sha": "a71f736bd6063eacdcdbfe57b84e1c9b37d4a202",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -303,7 +303,7 @@ def test_non_witness_transaction(self):\n         self.test_node.send_and_ping(msg_no_witness_block(block))  # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n-        self.nodes[0].generate(99)  # let the block mature\n+        self.generate(self.nodes[0], 99)  # let the block mature\n \n         # Create a transaction that spends the coinbase\n         tx = CTransaction()\n@@ -319,7 +319,7 @@ def test_non_witness_transaction(self):\n         assert tx.hash in self.nodes[0].getrawmempool()\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     @subtest  # type: ignore\n     def test_unnecessary_witness_before_segwit_activation(self):\n@@ -555,7 +555,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Cleanup: mine the first transaction and update utxo\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n@@ -580,7 +580,7 @@ def test_standardness_v0(self):\n \n         # Mine it on test_node to create the confirmed output.\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_tx, with_witness=True, accepted=True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Now test standardness of v0 P2WSH outputs.\n@@ -653,7 +653,7 @@ def test_standardness_v0(self):\n             )\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n@@ -664,9 +664,9 @@ def advance_to_segwit_active(self):\n         \"\"\"Mine enough blocks to activate segwit.\"\"\"\n         assert not softfork_active(self.nodes[0], 'segwit')\n         height = self.nodes[0].getblockcount()\n-        self.nodes[0].generate(SEGWIT_HEIGHT - height - 2)\n+        self.generate(self.nodes[0], SEGWIT_HEIGHT - height - 2)\n         assert not softfork_active(self.nodes[0], 'segwit')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert softfork_active(self.nodes[0], 'segwit')\n         self.segwit_active = True\n \n@@ -1298,7 +1298,7 @@ def test_tx_relay_after_segwit_activation(self):\n         assert vsize != raw_tx[\"size\"]\n \n         # Cleanup: mine the transactions and update utxo for next test\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n@@ -1348,7 +1348,7 @@ def test_segwit_versions(self):\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n-        self.nodes[0].generate(1)  # Mine all the transactions\n+        self.generate(self.nodes[0], 1)  # Mine all the transactions\n         self.sync_blocks()\n         assert len(self.nodes[0].getrawmempool()) == 0\n \n@@ -1419,14 +1419,14 @@ def test_premature_coinbase_witness_spend(self):\n         spend_tx.rehash()\n \n         # Now test a premature spend.\n-        self.nodes[0].generate(98)\n+        self.generate(self.nodes[0], 98)\n         self.sync_blocks()\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n         test_witness_block(self.nodes[0], self.test_node, block2, accepted=False)\n \n         # Advancing one more block should allow the spend.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n         test_witness_block(self.nodes[0], self.test_node, block2, accepted=True)\n@@ -1733,7 +1733,7 @@ def test_non_standard_witness_blinding(self):\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, False, True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # We'll add an unnecessary witness to this transaction that would cause\n@@ -1762,7 +1762,7 @@ def test_non_standard_witness_blinding(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, False, True)\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, False, True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Update our utxo list; we spent the first entry.\n@@ -1797,7 +1797,7 @@ def test_non_standard_witness(self):\n         txid = tx.sha256\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Creating transactions for tests\n@@ -1860,7 +1860,7 @@ def test_non_standard_witness(self):\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n-        self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n+        self.generate(self.nodes[0], 1)  # Mine and clean up the mempool of non-standard node\n         # Valid but non-standard transactions in a block should be accepted by standard node\n         self.sync_blocks()\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n@@ -1998,7 +1998,7 @@ def serialize(self):\n                 return serialize_with_bogus_witness(self.tx)\n \n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(address_type='bech32'), 5)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         unspent = next(u for u in self.nodes[0].listunspent() if u['spendable'] and u['address'].startswith('bcrt'))\n \n         raw = self.nodes[0].createrawtransaction([{\"txid\": unspent['txid'], \"vout\": unspent['vout']}], {self.nodes[0].getnewaddress(): 1})"
      },
      {
        "sha": "7bf1803780d8aecb8648fc6b7ab9547a367e2295",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -205,7 +205,7 @@ def mine_blocks(self, count):\n \n         # Clear out block announcements from each p2p listener\n         [x.clear_block_announcements() for x in self.nodes[0].p2ps]\n-        self.nodes[0].generatetoaddress(count, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], count, self.nodes[0].get_deterministic_priv_key().address)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n     def mine_reorg(self, length):\n@@ -216,7 +216,7 @@ def mine_reorg(self, length):\n         return the list of block hashes newly mined.\"\"\"\n \n         # make sure all invalidated blocks are node0's\n-        self.nodes[0].generatetoaddress(length, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], length, self.nodes[0].get_deterministic_priv_key().address)\n         self.sync_blocks(self.nodes, wait=0.1)\n         for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n@@ -225,7 +225,7 @@ def mine_reorg(self, length):\n         tip_height = self.nodes[1].getblockcount()\n         hash_to_invalidate = self.nodes[1].getblockhash(tip_height - (length - 1))\n         self.nodes[1].invalidateblock(hash_to_invalidate)\n-        all_hashes = self.nodes[1].generatetoaddress(length + 1, self.nodes[1].get_deterministic_priv_key().address)  # Must be longer than the orig chain\n+        all_hashes = self.generatetoaddress(self.nodes[1], length + 1, self.nodes[1].get_deterministic_priv_key().address)  # Must be longer than the orig chain\n         self.sync_blocks(self.nodes, wait=0.1)\n         return [int(x, 16) for x in all_hashes]\n \n@@ -240,7 +240,7 @@ def run_test(self):\n         self.test_nonnull_locators(test_node, inv_node)\n \n     def test_null_locators(self, test_node, inv_node):\n-        tip = self.nodes[0].getblockheader(self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)[0])\n+        tip = self.nodes[0].getblockheader(self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)[0])\n         tip_hash = int(tip[\"hash\"], 16)\n \n         inv_node.check_last_inv_announcement(inv=[tip_hash])"
      },
      {
        "sha": "e566fb0aa7a512d5c67edd4b2da2557bb7dbad3e",
        "filename": "test/functional/rpc_addresses_deprecation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_addresses_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_addresses_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_addresses_deprecation.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -40,7 +40,7 @@ def test_addresses_deprecation(self):\n         txid = node.sendrawtransaction(hexstring=tx_signed, maxfeerate=0)\n \n         self.log.info(\"Test RPCResult scriptPubKey no longer returns the fields addresses or reqSigs by default\")\n-        hash = node.generateblock(output=node.getnewaddress(), transactions=[txid])['hash']\n+        hash = self.generateblock(node, output=node.getnewaddress(), transactions=[txid])['hash']\n         # Ensure both nodes have the newly generated block on disk.\n         self.sync_blocks()\n         script_pub_key = node.getblock(blockhash=hash, verbose=2)['tx'][-1]['vout'][0]['scriptPubKey']"
      },
      {
        "sha": "e13de4395b63786521b2b3c2cd6cea7febe90a43",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -84,7 +84,7 @@ def mine_chain(self):\n         self.log.info(f\"Generate {HEIGHT} blocks after the genesis block in ten-minute steps\")\n         for t in range(TIME_GENESIS_BLOCK, TIME_RANGE_END, TIME_RANGE_STEP):\n             self.nodes[0].setmocktime(t)\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         assert_equal(self.nodes[0].getblockchaininfo()['blocks'], HEIGHT)\n \n     def _test_getblockchaininfo(self):\n@@ -351,12 +351,12 @@ def _test_getnetworkhashps(self):\n     def _test_stopatheight(self):\n         self.log.info(\"Test stopping at height\")\n         assert_equal(self.nodes[0].getblockcount(), HEIGHT)\n-        self.nodes[0].generatetoaddress(6, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        self.generatetoaddress(self.nodes[0], 6, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         assert_equal(self.nodes[0].getblockcount(), HEIGHT + 6)\n         self.log.debug('Node should not stop at this height')\n         assert_raises(subprocess.TimeoutExpired, lambda: self.nodes[0].process.wait(timeout=3))\n         try:\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')\n@@ -412,7 +412,7 @@ def _test_getblock(self):\n         fee_per_kb = 1000 * fee_per_byte\n \n         miniwallet.send_self_transfer(fee_rate=fee_per_kb, from_node=node)\n-        blockhash = node.generate(1)[0]\n+        blockhash = self.generate(node, 1)[0]\n \n         self.log.info(\"Test getblock with verbosity 1 doesn't include fee\")\n         block = node.getblock(blockhash, 1)"
      },
      {
        "sha": "696438ccfe3691c31e9f569d15af872208e681c2",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -45,7 +45,7 @@ def run_test(self):\n         self.check_addmultisigaddress_errors()\n \n         self.log.info('Generating blocks ...')\n-        node0.generate(149)\n+        self.generate(node0, 149)\n         self.sync_all()\n \n         self.moved = 0\n@@ -116,7 +116,7 @@ def check_addmultisigaddress_errors(self):\n \n     def checkbalances(self):\n         node0, node1, node2 = self.nodes\n-        node0.generate(COINBASE_MATURITY)\n+        self.generate(node0, COINBASE_MATURITY)\n         self.sync_all()\n \n         bal0 = node0.getbalance()\n@@ -179,7 +179,7 @@ def do_multisig(self):\n         value = tx[\"vout\"][vout][\"value\"]\n         prevtxs = [{\"txid\": txid, \"vout\": vout, \"scriptPubKey\": scriptPubKey, \"redeemScript\": mredeem, \"amount\": value}]\n \n-        node0.generate(1)\n+        self.generate(node0, 1)\n \n         outval = value - decimal.Decimal(\"0.00001000\")\n         rawtx = node2.createrawtransaction([{\"txid\": txid, \"vout\": vout}], [{self.final: outval}])\n@@ -215,7 +215,7 @@ def do_multisig(self):\n \n         self.moved += outval\n         tx = node0.sendrawtransaction(rawtx3[\"hex\"], 0)\n-        blk = node0.generate(1)[0]\n+        blk = self.generate(node0, 1)[0]\n         assert tx in node0.getblock(blk)[\"tx\"]\n \n         txinfo = node0.getrawtransaction(tx, True, blk)"
      },
      {
        "sha": "fdaed918a16e9e9cdca668a1dc5471ed4abed383",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -21,7 +21,7 @@ def run_test(self):\n         # In run_test:\n         # self.log.info(\"Test generate RPC\")\n         # assert_raises_rpc_error(-32, 'The wallet generate rpc method is deprecated', self.nodes[0].rpc.generate, 1)\n-        # self.nodes[1].generate(1)\n+        # self.generate(self.nodes[1], 1)\n \n         self.log.info(\"No tested deprecated RPC methods\")\n "
      },
      {
        "sha": "89388df5553c2f8761808f97e2798a5e7217c678",
        "filename": "test/functional/rpc_dumptxoutset.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_dumptxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_dumptxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_dumptxoutset.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -23,7 +23,7 @@ def run_test(self):\n         node = self.nodes[0]\n         mocktime = node.getblockheader(node.getblockhash(0))['time'] + 1\n         node.setmocktime(mocktime)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(node, COINBASE_MATURITY)\n \n         FILENAME = 'txoutset.dat'\n         out = node.dumptxoutset(FILENAME)"
      },
      {
        "sha": "56312dc6e56c4b1ae942fb4888f1b8a9af1d7e4e",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -63,9 +63,9 @@ def run_test(self):\n         #            = 2 bytes * minRelayTxFeePerByte\n         self.fee_tolerance = 2 * self.min_relay_tx_fee / 1000\n \n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all()\n-        self.nodes[0].generate(121)\n+        self.generate(self.nodes[0], 121)\n         self.sync_all()\n \n         self.test_change_position()\n@@ -126,7 +126,7 @@ def test_change_position(self):\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 5.0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         wwatch.unloadwallet()\n@@ -500,7 +500,7 @@ def test_spend_2of2(self):\n \n         # Send 1.2 BTC to msig addr.\n         self.nodes[0].sendtoaddress(mSigObj, 1.2)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         oldBalance = self.nodes[1].getbalance()\n@@ -511,7 +511,7 @@ def test_spend_2of2(self):\n         signed_psbt = w2.walletprocesspsbt(funded_psbt)\n         final_psbt = w2.finalizepsbt(signed_psbt['psbt'])\n         self.nodes[2].sendrawtransaction(final_psbt['hex'])\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all()\n \n         # Make sure funds are received at node1.\n@@ -572,7 +572,7 @@ def test_locked_wallet(self):\n         self.nodes[1].walletpassphrase(\"test\", 600)\n         signedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])\n         self.nodes[1].sendrawtransaction(signedTx['hex'])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         # Make sure funds are received at node1.\n@@ -584,12 +584,12 @@ def test_many_inputs_fee(self):\n \n         # Empty node1, send some small coins from node0 to node1.\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         for _ in range(20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Fund a tx with ~20 small inputs.\n@@ -612,12 +612,12 @@ def test_many_inputs_send(self):\n \n         # Again, empty node1, send some small coins from node0 to node1.\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         for _ in range(20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Fund a tx with ~20 small inputs.\n@@ -629,7 +629,7 @@ def test_many_inputs_send(self):\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n         fundedAndSignedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])\n         self.nodes[1].sendrawtransaction(fundedAndSignedTx['hex'])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n         assert_equal(oldBalance+Decimal('50.19000000'), self.nodes[0].getbalance()) #0.19+block reward\n \n@@ -707,7 +707,7 @@ def test_all_watched_funds(self):\n         signedtx = self.nodes[0].signrawtransactionwithwallet(signedtx[\"hex\"])\n         assert signedtx[\"complete\"]\n         self.nodes[0].sendrawtransaction(signedtx[\"hex\"])\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         wwatch.unloadwallet()\n@@ -933,7 +933,7 @@ def test_transaction_too_large(self):\n         for _ in range(1500):\n             outputs[recipient.getnewaddress()] = 0.1\n         wallet.sendmany(\"\", outputs)\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n         assert_raises_rpc_error(-4, \"Transaction too large\", recipient.fundrawtransaction, rawtx)\n \n     def test_include_unsafe(self):\n@@ -962,7 +962,7 @@ def test_include_unsafe(self):\n         wallet.sendrawtransaction(signedtx['hex'])\n \n         # And we can also use them once they're confirmed.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         rawtx = wallet.createrawtransaction([], [{self.nodes[2].getnewaddress(): 3}])\n         fundedtx = wallet.fundrawtransaction(rawtx, {\"include_unsafe\": True})\n         tx_dec = wallet.decoderawtransaction(fundedtx['hex'])\n@@ -993,7 +993,7 @@ def test_22670(self):\n         # than any single input available, and require more than 1 input. So we make 3 outputs\n         for i in range(0, 3):\n             funds.sendtoaddress(tester.getnewaddress(address_type=\"bech32\"), 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Create transactions in order to calculate fees for the target bounds that can trigger this bug\n         change_tx = tester.fundrawtransaction(tester.createrawtransaction([], [{funds.getnewaddress(): 1.5}]))"
      },
      {
        "sha": "3c6b3fb12562d79fede7abd6cd9f38d7145ae530",
        "filename": "test/functional/rpc_generateblock.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_generateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_generateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_generateblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -24,43 +24,43 @@ def run_test(self):\n \n         self.log.info('Generate an empty block to address')\n         address = node.getnewaddress()\n-        hash = node.generateblock(output=address, transactions=[])['hash']\n+        hash = self.generateblock(node, output=address, transactions=[])['hash']\n         block = node.getblock(blockhash=hash, verbose=2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a descriptor')\n-        hash = node.generateblock('addr(' + address + ')', [])['hash']\n+        hash = self.generateblock(node, 'addr(' + address + ')', [])['hash']\n         block = node.getblock(blockhash=hash, verbosity=2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a combo descriptor with compressed pubkey')\n         combo_key = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'\n         combo_address = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kygt080'\n-        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        hash = self.generateblock(node, 'combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         self.log.info('Generate an empty block to a combo descriptor with uncompressed pubkey')\n         combo_key = '0408ef68c46d20596cc3f6ddf7c8794f71913add807f1dc55949fa805d764d191c0b7ce6894c126fce0babc6663042f3dde9b0cf76467ea315514e5a6731149c67'\n         combo_address = 'mkc9STceoCcjoXEXe6cm66iJbmjM6zR9B2'\n-        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        hash = self.generateblock(node, 'combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         # Generate 110 blocks to spend\n-        node.generatetoaddress(110, address)\n+        self.generatetoaddress(node, 110, address)\n \n         # Generate some extra mempool transactions to verify they don't get mined\n         for _ in range(10):\n             node.sendtoaddress(address, 0.001)\n \n         self.log.info('Generate block with txid')\n         txid = node.sendtoaddress(address, 1)\n-        hash = node.generateblock(address, [txid])['hash']\n+        hash = self.generateblock(node, address, [txid])['hash']\n         block = node.getblock(hash, 1)\n         assert_equal(len(block['tx']), 2)\n         assert_equal(block['tx'][1], txid)\n@@ -69,7 +69,7 @@ def run_test(self):\n         utxos = node.listunspent(addresses=[address])\n         raw = node.createrawtransaction([{'txid':utxos[0]['txid'], 'vout':utxos[0]['vout']}],[{address:1}])\n         signed_raw = node.signrawtransactionwithwallet(raw)['hex']\n-        hash = node.generateblock(address, [signed_raw])['hash']\n+        hash = self.generateblock(node, address, [signed_raw])['hash']\n         block = node.getblock(hash, 1)\n         assert_equal(len(block['tx']), 2)\n         txid = block['tx'][1]\n@@ -81,26 +81,26 @@ def run_test(self):\n         txid1 = node.sendrawtransaction(signed_raw1)\n         raw2 = node.createrawtransaction([{'txid':txid1, 'vout':0}],[{address:0.999}])\n         signed_raw2 = node.signrawtransactionwithwallet(raw2)['hex']\n-        assert_raises_rpc_error(-25, 'TestBlockValidity failed: bad-txns-inputs-missingorspent', node.generateblock, address, [signed_raw2, txid1])\n+        assert_raises_rpc_error(-25, 'TestBlockValidity failed: bad-txns-inputs-missingorspent', self.generateblock, node, address, [signed_raw2, txid1])\n \n         self.log.info('Fail to generate block with txid not in mempool')\n         missing_txid = '0000000000000000000000000000000000000000000000000000000000000000'\n-        assert_raises_rpc_error(-5, 'Transaction ' + missing_txid + ' not in mempool.', node.generateblock, address, [missing_txid])\n+        assert_raises_rpc_error(-5, 'Transaction ' + missing_txid + ' not in mempool.', self.generateblock, node, address, [missing_txid])\n \n         self.log.info('Fail to generate block with invalid raw tx')\n         invalid_raw_tx = '0000'\n-        assert_raises_rpc_error(-22, 'Transaction decode failed for ' + invalid_raw_tx, node.generateblock, address, [invalid_raw_tx])\n+        assert_raises_rpc_error(-22, 'Transaction decode failed for ' + invalid_raw_tx, self.generateblock, node, address, [invalid_raw_tx])\n \n         self.log.info('Fail to generate block with invalid address/descriptor')\n-        assert_raises_rpc_error(-5, 'Invalid address or descriptor', node.generateblock, '1234', [])\n+        assert_raises_rpc_error(-5, 'Invalid address or descriptor', self.generateblock, node, '1234', [])\n \n         self.log.info('Fail to generate block with a ranged descriptor')\n         ranged_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0/*)'\n-        assert_raises_rpc_error(-8, 'Ranged descriptor not accepted. Maybe pass through deriveaddresses first?', node.generateblock, ranged_descriptor, [])\n+        assert_raises_rpc_error(-8, 'Ranged descriptor not accepted. Maybe pass through deriveaddresses first?', self.generateblock, node, ranged_descriptor, [])\n \n         self.log.info('Fail to generate block with a descriptor missing a private key')\n         child_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0\\'/0)'\n-        assert_raises_rpc_error(-5, 'Cannot derive script without private keys', node.generateblock, child_descriptor, [])\n+        assert_raises_rpc_error(-5, 'Cannot derive script without private keys', self.generateblock, node, child_descriptor, [])\n \n if __name__ == '__main__':\n     GenerateBlockTest().main()"
      },
      {
        "sha": "4d860d0f36c33bbc52f80b9d9430efed5534636f",
        "filename": "test/functional/rpc_getblockfilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getblockfilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getblockfilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockfilter.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -21,8 +21,8 @@ def run_test(self):\n         # Create two chains by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        self.nodes[0].generate(3)\n-        self.nodes[1].generate(4)\n+        self.generate(self.nodes[0], 3)\n+        self.generate(self.nodes[1], 4)\n \n         assert_equal(self.nodes[0].getblockcount(), 3)\n         chain0_hashes = [self.nodes[0].getblockhash(block_height) for block_height in range(4)]"
      },
      {
        "sha": "456e2cb0ad5ec6bea3cfa3f2cb16b8bcf988c85f",
        "filename": "test/functional/rpc_getblockstats.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getblockstats.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getblockstats.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockstats.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -43,19 +43,19 @@ def get_stats(self):\n     def generate_test_data(self, filename):\n         mocktime = 1525107225\n         self.nodes[0].setmocktime(mocktime)\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         address = self.nodes[0].get_deterministic_priv_key().address\n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=False)\n         self.nodes[0].settxfee(amount=0.003)\n         self.nodes[0].sendtoaddress(address=address, amount=1, subtractfeefromamount=True)\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.expected_stats = self.get_stats()\n "
      },
      {
        "sha": "ab0ee9142d64a1d0b5e74140174d1a38c63fa909",
        "filename": "test/functional/rpc_getchaintips.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getchaintips.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -26,8 +26,8 @@ def run_test(self):\n \n         # Split the network and build two chains of different lengths.\n         self.split_network()\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n-        self.nodes[2].generatetoaddress(20, self.nodes[2].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[2], 20, self.nodes[2].get_deterministic_priv_key().address)\n         self.sync_all(self.nodes[:2])\n         self.sync_all(self.nodes[2:])\n "
      },
      {
        "sha": "a91ce85855df4ed91f9f812267ff151724f63cc6",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -22,12 +22,12 @@ def setup_network(self):\n     def run_test(self):\n         self.log.info(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n         self.log.info(\"Mine 4 blocks on Node 0\")\n-        self.nodes[0].generatetoaddress(4, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 4, self.nodes[0].get_deterministic_priv_key().address)\n         assert_equal(self.nodes[0].getblockcount(), 4)\n         besthash_n0 = self.nodes[0].getbestblockhash()\n \n         self.log.info(\"Mine competing 6 blocks on Node 1\")\n-        self.nodes[1].generatetoaddress(6, self.nodes[1].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[1], 6, self.nodes[1].get_deterministic_priv_key().address)\n         assert_equal(self.nodes[1].getblockcount(), 6)\n \n         self.log.info(\"Connect nodes to force a reorg\")\n@@ -53,14 +53,14 @@ def run_test(self):\n         self.nodes[2].invalidateblock(self.nodes[2].getblockhash(3))\n         assert_equal(self.nodes[2].getblockcount(), 2)\n         self.log.info(\"..and then mine a block\")\n-        self.nodes[2].generatetoaddress(1, self.nodes[2].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[2], 1, self.nodes[2].get_deterministic_priv_key().address)\n         self.log.info(\"Verify all nodes are at the right height\")\n         self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n         self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n         self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n \n         self.log.info(\"Verify that we reconsider all ancestors as well\")\n-        blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-1])\n@@ -72,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n         self.log.info(\"Verify that we reconsider all descendants\")\n-        blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-2])"
      },
      {
        "sha": "aa53e354a33b7c3510dbacb0fed64b90fab82591",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -52,9 +52,9 @@ def set_test_params(self):\n     def run_test(self):\n         # We need miniwallet to make a transaction\n         self.wallet = MiniWallet(self.nodes[0])\n-        self.wallet.generate(1)\n+        self.generate(self.wallet, 1)\n         # Get out of IBD for the minfeefilter and getpeerinfo tests.\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         # By default, the test framework sets up an addnode connection from\n         # node 1 --> node0. By connecting node0 --> node 1, we're left with\n@@ -81,7 +81,7 @@ def test_getpeerinfo(self):\n         self.log.info(\"Test getpeerinfo\")\n         # Create a few getpeerinfo last_block/last_transaction values.\n         self.wallet.send_self_transfer(from_node=self.nodes[0]) # Make a transaction so we can see it in the getpeerinfo results\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n         time_now = int(time.time())\n         peer_info = [x.getpeerinfo() for x in self.nodes]"
      },
      {
        "sha": "63533affd0397fdb048db3ebbf9eb9800441c5d2",
        "filename": "test/functional/rpc_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         self.address = node.get_deterministic_priv_key().address\n         self.coins = []\n         # The last 100 coinbase transactions are premature\n-        for b in node.generatetoaddress(200, self.address)[:100]:\n+        for b in self.generatetoaddress(node, 200, self.address)[:100]:\n             coinbase = node.getblock(blockhash=b, verbosity=2)[\"tx\"][0]\n             self.coins.append({\n                 \"txid\": coinbase[\"txid\"],\n@@ -151,7 +151,7 @@ def test_chain(self):\n         assert_equal(testres_single, testres_multiple)\n \n         # Clean up by clearing the mempool\n-        node.generate(1)\n+        self.generate(node, 1)\n \n     def test_multiple_children(self):\n         node = self.nodes[0]"
      },
      {
        "sha": "3a00992ddc3ed4d2c0b251249e3d4fe6a6f5e23a",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -43,18 +43,18 @@ def setup_network(self):\n     def run_test(self):\n         self.log.info(\"Ensure submitblock can in principle reorg to a competing chain\")\n         gen_address = lambda i: self.nodes[i].get_deterministic_priv_key().address  # A non-wallet address to mine to\n-        self.nodes[0].generatetoaddress(1, gen_address(0))\n+        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n         assert_equal(self.nodes[0].getblockcount(), 1)\n-        hashZ = self.nodes[1].generatetoaddress(2, gen_address(1))[-1]\n+        hashZ = self.generatetoaddress(self.nodes[1], 2, gen_address(1))[-1]\n         assert_equal(self.nodes[1].getblockcount(), 2)\n         node_sync_via_rpc(self.nodes[0:3])\n         assert_equal(self.nodes[0].getbestblockhash(), hashZ)\n \n         self.log.info(\"Mine blocks A-B-C on Node 0\")\n-        hashC = self.nodes[0].generatetoaddress(3, gen_address(0))[-1]\n+        hashC = self.generatetoaddress(self.nodes[0], 3, gen_address(0))[-1]\n         assert_equal(self.nodes[0].getblockcount(), 5)\n         self.log.info(\"Mine competing blocks E-F-G on Node 1\")\n-        hashG = self.nodes[1].generatetoaddress(3, gen_address(1))[-1]\n+        hashG = self.generatetoaddress(self.nodes[1], 3, gen_address(1))[-1]\n         assert_equal(self.nodes[1].getblockcount(), 5)\n         assert hashC != hashG\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n@@ -83,7 +83,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         self.log.info(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n-        self.nodes[0].generatetoaddress(1, gen_address(0))\n+        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n         assert_equal(self.nodes[0].getblockcount(), 6)\n         self.sync_blocks(self.nodes[0:2])\n         hashH = self.nodes[0].getbestblockhash()\n@@ -92,7 +92,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         self.log.info(\"Mine competing blocks I-J-K-L on Node 2\")\n-        self.nodes[2].generatetoaddress(4, gen_address(2))\n+        self.generatetoaddress(self.nodes[2], 4, gen_address(2))\n         assert_equal(self.nodes[2].getblockcount(), 6)\n         hashL = self.nodes[2].getbestblockhash()\n         self.log.info(\"Connect nodes and check no reorg occurs\")"
      },
      {
        "sha": "2b1892c121408d2796980dd990f715e1e1f39469",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -57,7 +57,7 @@ def test_utxo_conversion(self):\n         online_addr = w2.getnewaddress(address_type=\"p2sh-segwit\")\n         wonline.importaddress(offline_addr, \"\", False)\n         mining_node.sendtoaddress(address=offline_addr, amount=1.0)\n-        mining_node.generate(nblocks=1)\n+        self.generate(mining_node, nblocks=1)\n         self.sync_blocks([mining_node, online_node])\n \n         # Construct an unsigned PSBT on the online node (who doesn't know the output is Segwit, so will include a non-witness UTXO)\n@@ -72,7 +72,7 @@ def test_utxo_conversion(self):\n \n         # Make sure we can mine the resulting transaction\n         txid = mining_node.sendrawtransaction(mining_node.finalizepsbt(signed_psbt)[\"hex\"])\n-        mining_node.generate(1)\n+        self.generate(mining_node, 1)\n         self.sync_blocks([mining_node, online_node])\n         assert_equal(online_node.gettxout(txid,0)[\"confirmations\"], 1)\n \n@@ -148,7 +148,7 @@ def run_test(self):\n         rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n         signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n         txid = self.nodes[0].sendrawtransaction(signed_tx)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n \n         # Find the output pos\n@@ -307,7 +307,7 @@ def run_test(self):\n         node2_addr = self.nodes[2].getnewaddress()\n         txid1 = self.nodes[0].sendtoaddress(node1_addr, 13)\n         txid2 = self.nodes[0].sendtoaddress(node2_addr, 13)\n-        blockhash = self.nodes[0].generate(6)[0]\n+        blockhash = self.generate(self.nodes[0], 6)[0]\n         self.sync_all()\n         vout1 = find_output(self.nodes[1], txid1, 13, blockhash=blockhash)\n         vout2 = find_output(self.nodes[2], txid2, 13, blockhash=blockhash)\n@@ -335,7 +335,7 @@ def run_test(self):\n         combined = self.nodes[0].combinepsbt([psbt1, psbt2])\n         finalized = self.nodes[0].finalizepsbt(combined)['hex']\n         self.nodes[0].sendrawtransaction(finalized)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n \n         # Test additional args in walletcreatepsbt\n@@ -530,7 +530,7 @@ def test_psbt_input_keys(psbt_input, keys):\n         addr4 = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n         txid4 = self.nodes[0].sendtoaddress(addr4, 5)\n         vout4 = find_output(self.nodes[0], txid4, 5)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n         psbt2 = self.nodes[1].createpsbt([{\"txid\":txid4, \"vout\":vout4}], {self.nodes[0].getnewaddress():Decimal('4.999')})\n         psbt2 = self.nodes[1].walletprocesspsbt(psbt2)['psbt']\n@@ -554,7 +554,7 @@ def test_psbt_input_keys(psbt_input, keys):\n         addr = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n         txid = self.nodes[0].sendtoaddress(addr, 7)\n         addrinfo = self.nodes[1].getaddressinfo(addr)\n-        blockhash = self.nodes[0].generate(6)[0]\n+        blockhash = self.generate(self.nodes[0], 6)[0]\n         self.sync_all()\n         vout = find_output(self.nodes[0], txid, 7, blockhash=blockhash)\n         psbt = self.nodes[1].createpsbt([{\"txid\":txid, \"vout\":vout}], {self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\"):Decimal('6.999')})"
      },
      {
        "sha": "fc812340fa8ecd91dff7831411ee3b6808749c4b",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -74,14 +74,14 @@ def setup_network(self):\n \n     def run_test(self):\n         self.log.info(\"Prepare some coins for multiple *rawtransaction commands\")\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all()\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         self.sync_all()\n         for amount in [1.5, 1.0, 5.0]:\n             self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), amount)\n         self.sync_all()\n-        self.nodes[0].generate(5)\n+        self.generate(self.nodes[0], 5)\n         self.sync_all()\n \n         self.getrawtransaction_tests()\n@@ -97,13 +97,13 @@ def run_test(self):\n     def getrawtransaction_tests(self):\n         addr = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(addr, 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         vout = find_vout_for_address(self.nodes[1], txid, addr)\n         rawTx = self.nodes[1].createrawtransaction([{'txid': txid, 'vout': vout}], {self.nodes[1].getnewaddress(): 9.999})\n         rawTxSigned = self.nodes[1].signrawtransactionwithwallet(rawTx)\n         txId = self.nodes[1].sendrawtransaction(rawTxSigned['hex'])\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         for n in [0, 3]:\n@@ -136,7 +136,7 @@ def getrawtransaction_tests(self):\n \n         # Make a tx by sending, then generate 2 blocks; block1 has the tx in it\n         tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n-        block1, block2 = self.nodes[2].generate(2)\n+        block1, block2 = self.generate(self.nodes[2], 2)\n         self.sync_all()\n         for n in [0, 3]:\n             self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex, with blockhash\")\n@@ -368,7 +368,7 @@ def sendrawtransaction_testmempoolaccept_tests(self):\n         self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n \n         self.log.info(\"Test sendrawtransaction/testmempoolaccept with tx already in the chain\")\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_blocks()\n         for node in self.nodes:\n             testres = node.testmempoolaccept([rawTxSigned['hex']])[0]\n@@ -442,7 +442,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         # send 1.2 BTC to msig adr\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         # node2 has both keys of the 2of2 ms addr, tx should affect the balance\n         assert_equal(self.nodes[2].getbalance(), bal + Decimal('1.20000000'))\n@@ -464,7 +464,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         decTx = self.nodes[0].gettransaction(txId)\n         rawTx = self.nodes[0].decoderawtransaction(decTx['hex'])\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # THIS IS AN INCOMPLETE FEATURE\n@@ -487,7 +487,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n         rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         assert_equal(self.nodes[0].getbalance(), bal + Decimal('50.00000000') + Decimal('2.19000000'))  # block reward + tx\n \n@@ -507,7 +507,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         decTx = self.nodes[0].gettransaction(txId)\n         rawTx2 = self.nodes[0].decoderawtransaction(decTx['hex'])\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         assert_equal(self.nodes[2].getbalance(), bal)  # the funds of a 2of2 multisig tx should not be marked as spendable\n@@ -532,7 +532,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         self.nodes[2].sendrawtransaction(rawTxComb)\n         rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         assert_equal(self.nodes[0].getbalance(), bal + Decimal('50.00000000') + Decimal('2.19000000'))  # block reward + tx\n "
      },
      {
        "sha": "ec8205acd591c2c499cfb98b2184f9f5b576d823",
        "filename": "test/functional/rpc_scantxoutset.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_scantxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_scantxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_scantxoutset.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -23,7 +23,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n-        self.nodes[0].generate(110)\n+        self.generate(self.nodes[0], 110)\n \n         addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n         pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n@@ -50,14 +50,14 @@ def run_test(self):\n         self.nodes[0].sendtoaddress(\"mpQ8rokAhp1TAtJQR6F6TaUmjAWkAWYYBq\", 16.384) # (m/1/1/1500)\n \n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n         self.stop_node(0)\n         shutil.rmtree(os.path.join(self.nodes[0].datadir, self.chain, 'wallets'))\n         self.start_node(0, ['-nowallet'])\n         self.import_deterministic_coinbase_privkeys()\n-        self.nodes[0].generate(110)\n+        self.generate(self.nodes[0], 110)\n \n         scan = self.nodes[0].scantxoutset(\"start\", [])\n         info = self.nodes[0].gettxoutsetinfo()"
      },
      {
        "sha": "8f17b29ff4bcb41ad1fbc0c0985eab71a59915f8",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -183,7 +183,7 @@ def script_verification_error_test(self):\n     def test_fully_signed_tx(self):\n         self.log.info(\"Test signing a fully signed transaction does nothing\")\n         self.nodes[0].walletpassphrase(\"password\", 9999)\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         rawtx = self.nodes[0].createrawtransaction([], [{self.nodes[0].getnewaddress(): 10}])\n         fundedtx = self.nodes[0].fundrawtransaction(rawtx)\n         signedtx = self.nodes[0].signrawtransactionwithwallet(fundedtx[\"hex\"])\n@@ -202,9 +202,9 @@ def witness_script_test(self):\n         embedded_pubkey = eckey.get_pubkey().get_bytes().hex()\n         p2sh_p2wsh_address = self.nodes[1].createmultisig(1, [embedded_pubkey], \"p2sh-segwit\")\n         # send transaction to P2SH-P2WSH 1-of-1 multisig address\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         self.nodes[0].sendtoaddress(p2sh_p2wsh_address[\"address\"], 49.999)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         # Get the UTXO info from scantxoutset\n         unspent_output = self.nodes[1].scantxoutset('start', [p2sh_p2wsh_address['descriptor']])['unspents'][0]\n@@ -239,7 +239,7 @@ def verify_txn_with_witness_script(self, tx_type):\n         # Fund that address\n         txid = self.nodes[0].sendtoaddress(addr, 10)\n         vout = find_vout_for_address(self.nodes[0], txid, addr)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         # Now create and sign a transaction spending that output on node[0], which doesn't know the scripts or keys\n         spending_tx = self.nodes[0].createrawtransaction([{'txid': txid, 'vout': vout}], {self.nodes[1].getnewaddress(): Decimal(\"9.999\")})\n         spending_tx_signed = self.nodes[0].signrawtransactionwithkey(spending_tx, [embedded_privkey], [{'txid': txid, 'vout': vout, 'scriptPubKey': script_pub_key, 'redeemScript': redeem_script, 'witnessScript': witness_script, 'amount': 10}])\n@@ -283,7 +283,7 @@ def test_signing_with_csv(self):\n         # Fund that address and make the spend\n         txid = self.nodes[0].sendtoaddress(address, 1)\n         vout = find_vout_for_address(self.nodes[0], txid, address)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         utxo = self.nodes[0].listunspent()[0]\n         amt = Decimal(1) + utxo[\"amount\"] - Decimal(0.00001)\n         tx = self.nodes[0].createrawtransaction(\n@@ -318,7 +318,7 @@ def test_signing_with_cltv(self):\n         # Fund that address and make the spend\n         txid = self.nodes[0].sendtoaddress(address, 1)\n         vout = find_vout_for_address(self.nodes[0], txid, address)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         utxo = self.nodes[0].listunspent()[0]\n         amt = Decimal(1) + utxo[\"amount\"] - Decimal(0.00001)\n         tx = self.nodes[0].createrawtransaction("
      },
      {
        "sha": "a45694328a603a9313db36bc232c5da86b0e6573",
        "filename": "test/functional/rpc_txoutproof.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_txoutproof.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/rpc_txoutproof.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_txoutproof.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -29,8 +29,8 @@ def set_test_params(self):\n     def run_test(self):\n         miniwallet = MiniWallet(self.nodes[0])\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        miniwallet.generate(5)\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(miniwallet, 5)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n@@ -41,7 +41,7 @@ def run_test(self):\n         # This will raise an exception because the transaction is not yet in a block\n         assert_raises_rpc_error(-5, \"Transaction not yet in block\", self.nodes[0].gettxoutproof, [txid1])\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         blockhash = self.nodes[0].getblockhash(chain_height + 1)\n         self.sync_all()\n \n@@ -57,7 +57,7 @@ def run_test(self):\n         txin_spent = miniwallet.get_utxo()  # Get the change from txid2\n         tx3 = miniwallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=txin_spent)\n         txid3 = tx3['txid']\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         txid_spent = txin_spent[\"txid\"]"
      },
      {
        "sha": "78737509cb749e090e8cf415e1ff850a60448b93",
        "filename": "test/functional/test-shell.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/test-shell.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/test-shell.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test-shell.md?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -94,7 +94,7 @@ rewards to a wallet address owned by the mining node.\n \n ```\n >>> address = test.nodes[0].getnewaddress()\n->>> test.nodes[0].generatetoaddress(101, address)\n+>>> test.self.generatetoaddress(nodes[0], 101, address)\n ['2b98dd0044aae6f1cca7f88a0acf366a4bfe053c7f7b00da3c0d115f03d67efb', ...\n ```\n Since the two nodes are both initialized by default to establish an outbound"
      },
      {
        "sha": "a826fb0575531a495e5f10ed2462feb2f621e9a4",
        "filename": "test/functional/tool_wallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/tool_wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/tool_wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/tool_wallet.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -242,7 +242,7 @@ def test_tool_wallet_info_after_transaction(self):\n         \"\"\"\n         self.start_node(0)\n         self.log.info('Generating transaction to mutate wallet')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.stop_node(0)\n \n         self.log.info('Calling wallet tool info after generating a transaction, testing output')"
      },
      {
        "sha": "63658400418464d74583e47c70f4b9399e737a54",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -29,14 +29,14 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.sync_blocks()\n         balance = self.nodes[0].getbalance()\n         txA = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n         txB = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n         txC = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n         self.sync_mempools()\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n \n         # Can not abandon non-wallet transaction\n         assert_raises_rpc_error(-5, 'Invalid or non-wallet transaction id', lambda: self.nodes[0].abandontransaction(txid='ff' * 32))\n@@ -158,7 +158,7 @@ def run_test(self):\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n         signed = self.nodes[0].signrawtransactionwithwallet(tx)\n         self.nodes[1].sendrawtransaction(signed[\"hex\"])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n \n         self.connect_nodes(0, 1)\n         self.sync_blocks()"
      },
      {
        "sha": "bdee22e62b1398b38597798acc94c19a45552ea9",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -221,7 +221,7 @@ def test_change_output_type(self, node_sender, destinations, expected_type):\n     def run_test(self):\n         # Mine 101 blocks on node5 to bring nodes out of IBD and make sure that\n         # no coinbases are maturing for the nodes-under-test during the test\n-        self.nodes[5].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[5], COINBASE_MATURITY + 1)\n         self.sync_blocks()\n \n         uncompressed_1 = \"0496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858ee\"\n@@ -306,7 +306,7 @@ def run_test(self):\n                 assert_equal(unconf_balances[to_node], to_send * 10 * (2 + n))\n \n             # node5 collects fee and block subsidy to keep accounting simple\n-            self.nodes[5].generate(1)\n+            self.generate(self.nodes[5], 1)\n             self.sync_blocks()\n \n             # Verify that the receiving wallet contains a UTXO with the expected address, and expected descriptor\n@@ -336,7 +336,7 @@ def run_test(self):\n \n         # Fund node 4:\n         self.nodes[5].sendtoaddress(self.nodes[4].getnewaddress(), Decimal(\"1\"))\n-        self.nodes[5].generate(1)\n+        self.generate(self.nodes[5], 1)\n         self.sync_blocks()\n         assert_equal(self.nodes[4].getbalance(), 1)\n "
      },
      {
        "sha": "12357e2d63abb239c2be5a0e38c5ef3dc838d874",
        "filename": "test/functional/wallet_avoidreuse.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_avoidreuse.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_avoidreuse.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_avoidreuse.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -79,7 +79,7 @@ def run_test(self):\n         self.test_persistence()\n         self.test_immutable()\n \n-        self.nodes[0].generate(110)\n+        self.generate(self.nodes[0], 110)\n         self.sync_all()\n         self.test_change_remains_change(self.nodes[1])\n         reset_balance(self.nodes[1], self.nodes[0].getnewaddress())\n@@ -174,7 +174,7 @@ def test_sending_from_reused_address_without_avoid_reuse(self):\n         retaddr = self.nodes[0].getnewaddress()\n \n         self.nodes[0].sendtoaddress(fundaddr, 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # listunspent should show 1 single, unused 10 btc output\n@@ -185,7 +185,7 @@ def test_sending_from_reused_address_without_avoid_reuse(self):\n         assert(\"used\" not in self.nodes[0].getbalances()[\"mine\"])\n \n         self.nodes[1].sendtoaddress(retaddr, 5)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # listunspent should show 1 single, unused 5 btc output\n@@ -194,7 +194,7 @@ def test_sending_from_reused_address_without_avoid_reuse(self):\n         assert_balances(self.nodes[1], mine={\"used\": 0, \"trusted\": 5})\n \n         self.nodes[0].sendtoaddress(fundaddr, 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # listunspent should show 2 total outputs (5, 10 btc), one unused (5), one reused (10)\n@@ -228,7 +228,7 @@ def test_sending_from_reused_address_fails(self, second_addr_type):\n         retaddr = self.nodes[0].getnewaddress()\n \n         self.nodes[0].sendtoaddress(fundaddr, 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # listunspent should show 1 single, unused 10 btc output\n@@ -237,7 +237,7 @@ def test_sending_from_reused_address_fails(self, second_addr_type):\n         assert_balances(self.nodes[1], mine={\"used\": 0, \"trusted\": 10})\n \n         self.nodes[1].sendtoaddress(retaddr, 5)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # listunspent should show 1 single, unused 5 btc output\n@@ -259,7 +259,7 @@ def test_sending_from_reused_address_fails(self, second_addr_type):\n                 assert_equal(second_addr_type, \"legacy\")\n \n             self.nodes[0].sendtoaddress(new_fundaddr, 10)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_all()\n \n             # listunspent should show 2 total outputs (5, 10 btc), one unused (5), one reused (10)\n@@ -302,7 +302,7 @@ def test_getbalances_used(self):\n         for _ in range(101):\n             self.nodes[0].sendtoaddress(new_addr, 1)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # send transaction that should not use all the available outputs\n@@ -334,7 +334,7 @@ def test_full_destination_group_is_preferred(self):\n         for _ in range(101):\n             self.nodes[0].sendtoaddress(new_addr, 1)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Sending a transaction that is smaller than each one of the\n@@ -363,7 +363,7 @@ def test_all_destination_groups_are_used(self):\n         for _ in range(202):\n             self.nodes[0].sendtoaddress(new_addr, 1)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Sending a transaction that needs to use the full groups"
      },
      {
        "sha": "bc6d6206e5bc6b4d38118a94b32f93f141b7ca9f",
        "filename": "test/functional/wallet_backup.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_backup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_backup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_backup.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -88,7 +88,7 @@ def do_one_round(self):\n         # Have the miner (node3) mine a block.\n         # Must sync mempools before mining.\n         self.sync_mempools()\n-        self.nodes[3].generate(1)\n+        self.generate(self.nodes[3], 1)\n         self.sync_blocks()\n \n     # As above, this mirrors the original bash test.\n@@ -130,13 +130,13 @@ def init_three(self):\n \n     def run_test(self):\n         self.log.info(\"Generating initial blockchain\")\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_blocks()\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_blocks()\n-        self.nodes[3].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[3], COINBASE_MATURITY)\n         self.sync_blocks()\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -165,7 +165,7 @@ def run_test(self):\n             self.do_one_round()\n \n         # Generate 101 more blocks, so any fees paid mature\n-        self.nodes[3].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[3], COINBASE_MATURITY + 1)\n         self.sync_all()\n \n         balance0 = self.nodes[0].getbalance()"
      },
      {
        "sha": "2abac7bb92f26b7122026e091a0ebe9628550e3a",
        "filename": "test/functional/wallet_balance.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_balance.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_balance.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_balance.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -70,10 +70,10 @@ def run_test(self):\n             assert 'watchonly' not in self.nodes[1].getbalances()\n \n         self.log.info(\"Mining blocks ...\")\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n-        self.nodes[1].generate(1)\n-        self.nodes[1].generatetoaddress(COINBASE_MATURITY + 1, ADDRESS_WATCHONLY)\n+        self.generate(self.nodes[1], 1)\n+        self.generatetoaddress(self.nodes[1], COINBASE_MATURITY + 1, ADDRESS_WATCHONLY)\n         self.sync_all()\n \n         if not self.options.descriptors:\n@@ -196,7 +196,7 @@ def test_balances(*, fee_node_1=0):\n         self.log.info(\"Test getbalance and getbalances.mine.untrusted_pending with conflicted unconfirmed inputs\")\n         test_balances(fee_node_1=Decimal('0.02'))\n \n-        self.nodes[1].generatetoaddress(1, ADDRESS_WATCHONLY)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_WATCHONLY)\n         self.sync_all()\n \n         # balances are correct after the transactions are confirmed\n@@ -210,7 +210,7 @@ def test_balances(*, fee_node_1=0):\n         # Send total balance away from node 1\n         txs = create_transactions(self.nodes[1], self.nodes[0].getnewaddress(), Decimal('29.97'), [Decimal('0.01')])\n         self.nodes[1].sendrawtransaction(txs[0]['hex'])\n-        self.nodes[1].generatetoaddress(2, ADDRESS_WATCHONLY)\n+        self.generatetoaddress(self.nodes[1], 2, ADDRESS_WATCHONLY)\n         self.sync_all()\n \n         # getbalance with a minconf incorrectly excludes coins that have been spent more recently than the minconf blocks ago\n@@ -257,23 +257,23 @@ def test_balances(*, fee_node_1=0):\n         self.nodes[1].sendrawtransaction(hexstring=tx_replace, maxfeerate=0)\n \n         # Now confirm tx_replace\n-        block_reorg = self.nodes[1].generatetoaddress(1, ADDRESS_WATCHONLY)[0]\n+        block_reorg = self.generatetoaddress(self.nodes[1], 1, ADDRESS_WATCHONLY)[0]\n         self.sync_all()\n         assert_equal(self.nodes[0].getbalance(minconf=0), total_amount)\n \n         self.log.info('Put txs back into mempool of node 1 (not node 0)')\n         self.nodes[0].invalidateblock(block_reorg)\n         self.nodes[1].invalidateblock(block_reorg)\n         assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n-        self.nodes[0].generatetoaddress(1, ADDRESS_WATCHONLY)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_WATCHONLY)\n         assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n \n         # Now confirm tx_orig\n         self.restart_node(1, ['-persistmempool=0'])\n         self.connect_nodes(0, 1)\n         self.sync_blocks()\n         self.nodes[1].sendrawtransaction(tx_orig)\n-        self.nodes[1].generatetoaddress(1, ADDRESS_WATCHONLY)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_WATCHONLY)\n         self.sync_all()\n         assert_equal(self.nodes[0].getbalance(minconf=0), total_amount + 1)  # The reorg recovered our fee of 1 coin\n "
      },
      {
        "sha": "e7873a82bb770353f3669ea44341097ba3145b25",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -59,14 +59,14 @@ def run_test(self):\n \n         self.log.info(\"Mining blocks...\")\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         walletinfo = self.nodes[0].getwalletinfo()\n         assert_equal(walletinfo['immature_balance'], 50)\n         assert_equal(walletinfo['balance'], 0)\n \n         self.sync_all(self.nodes[0:3])\n-        self.nodes[1].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[1], COINBASE_MATURITY + 1)\n         self.sync_all(self.nodes[0:3])\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -115,7 +115,7 @@ def run_test(self):\n         assert_equal(walletinfo['immature_balance'], 0)\n \n         # Have node0 mine a block, thus it will collect its own fee.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all(self.nodes[0:3])\n \n         # Exercise locking of unspent outputs\n@@ -159,7 +159,7 @@ def run_test(self):\n         assert_equal(len(self.nodes[1].listlockunspent()), 0)\n \n         # Have node1 generate 100 blocks (so node0 can recover the fee)\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.sync_all(self.nodes[0:3])\n \n         # node0 should end up with 100 btc in block rewards plus fees, but\n@@ -188,7 +188,7 @@ def run_test(self):\n         self.nodes[1].sendrawtransaction(hexstring=txns_to_send[1][\"hex\"], maxfeerate=0)\n \n         # Have node1 mine a block to confirm transactions:\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all(self.nodes[0:3])\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n@@ -203,14 +203,14 @@ def run_test(self):\n         fee_per_byte = Decimal('0.001') / 1000\n         self.nodes[2].settxfee(fee_per_byte * 1000)\n         txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", False)\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         node_2_bal = self.check_fee_amount(self.nodes[2].getbalance(), Decimal('84'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(self.nodes[0].getbalance(), Decimal('10'))\n \n         # Send 10 BTC with subtract fee from amount\n         txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", True)\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         node_2_bal -= Decimal('10')\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n@@ -220,15 +220,15 @@ def run_test(self):\n \n         # Sendmany 10 BTC\n         txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [])\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         node_0_bal += Decimal('10')\n         node_2_bal = self.check_fee_amount(self.nodes[2].getbalance(), node_2_bal - Decimal('10'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(self.nodes[0].getbalance(), node_0_bal)\n \n         # Sendmany 10 BTC with subtract fee from amount\n         txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [address])\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         node_2_bal -= Decimal('10')\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n@@ -241,7 +241,7 @@ def run_test(self):\n \n         # Test passing fee_rate as a string\n         txid = self.nodes[2].sendmany(amounts={address: 10}, fee_rate=str(fee_rate_sat_vb))\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         balance = self.nodes[2].getbalance()\n         node_2_bal = self.check_fee_amount(balance, node_2_bal - Decimal('10'), explicit_fee_rate_btc_kvb, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n@@ -252,7 +252,7 @@ def run_test(self):\n         # Test passing fee_rate as an integer\n         amount = Decimal(\"0.0001\")\n         txid = self.nodes[2].sendmany(amounts={address: amount}, fee_rate=fee_rate_sat_vb)\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all(self.nodes[0:3])\n         balance = self.nodes[2].getbalance()\n         node_2_bal = self.check_fee_amount(balance, node_2_bal - amount, explicit_fee_rate_btc_kvb, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n@@ -314,7 +314,7 @@ def run_test(self):\n         self.nodes[1].sendrawtransaction(signed_raw_tx['hex'])\n \n         self.sync_all()\n-        self.nodes[1].generate(1)  # mine a block\n+        self.generate(self.nodes[1], 1)  # mine a block\n         self.sync_all()\n \n         unspent_txs = self.nodes[0].listunspent()  # zero value tx must be in listunspents output\n@@ -337,13 +337,13 @@ def run_test(self):\n \n         txid_not_broadcast = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n-        self.nodes[1].generate(1)  # mine a block, tx should not be in there\n+        self.generate(self.nodes[1], 1)  # mine a block, tx should not be in there\n         self.sync_all(self.nodes[0:3])\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)  # should not be changed because tx was not broadcasted\n \n         # now broadcast from another node, mine a block, sync, and check the balance\n         self.nodes[1].sendrawtransaction(tx_obj_not_broadcast['hex'])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all(self.nodes[0:3])\n         node_2_bal += 2\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n@@ -362,7 +362,7 @@ def run_test(self):\n         self.connect_nodes(0, 2)\n         self.sync_blocks(self.nodes[0:3])\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks(self.nodes[0:3])\n         node_2_bal += 2\n \n@@ -391,7 +391,7 @@ def run_test(self):\n         assert_raises_rpc_error(-3, \"Invalid amount\", self.nodes[0].sendtoaddress, self.nodes[2].getnewaddress(), \"1f-4\")\n \n         # This will raise an exception since generate does not accept a string\n-        assert_raises_rpc_error(-1, \"not an integer\", self.nodes[0].generate, \"2\")\n+        assert_raises_rpc_error(-1, \"not an integer\", self.generate, self.nodes[0], \"2\")\n \n         if not self.options.descriptors:\n \n@@ -427,7 +427,7 @@ def run_test(self):\n             # 1. Send some coins to generate new UTXO\n             address_to_import = self.nodes[2].getnewaddress()\n             txid = self.nodes[0].sendtoaddress(address_to_import, 1)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_all(self.nodes[0:3])\n \n             self.log.info(\"Test sendtoaddress with fee_rate param (explicit fee rate in sat/vB)\")\n@@ -440,7 +440,7 @@ def run_test(self):\n             # Test passing fee_rate as an integer\n             txid = self.nodes[2].sendtoaddress(address=address, amount=amount, fee_rate=fee_rate_sat_vb)\n             tx_size = self.get_vsize(self.nodes[2].gettransaction(txid)['hex'])\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_all(self.nodes[0:3])\n             postbalance = self.nodes[2].getbalance()\n             fee = prebalance - postbalance - Decimal(amount)\n@@ -453,7 +453,7 @@ def run_test(self):\n             # Test passing fee_rate as a string\n             txid = self.nodes[2].sendtoaddress(address=address, amount=amount, fee_rate=str(fee_rate_sat_vb))\n             tx_size = self.get_vsize(self.nodes[2].gettransaction(txid)['hex'])\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_all(self.nodes[0:3])\n             postbalance = self.nodes[2].getbalance()\n             fee = prebalance - postbalance - amount\n@@ -515,7 +515,7 @@ def run_test(self):\n \n         # Mine a block from node0 to an address from node1\n         coinbase_addr = self.nodes[1].getnewaddress()\n-        block_hash = self.nodes[0].generatetoaddress(1, coinbase_addr)[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, coinbase_addr)[0]\n         coinbase_txid = self.nodes[0].getblock(block_hash)['tx'][0]\n         self.sync_all(self.nodes[0:3])\n \n@@ -524,7 +524,7 @@ def run_test(self):\n \n         # check if wallet or blockchain maintenance changes the balance\n         self.sync_all(self.nodes[0:3])\n-        blocks = self.nodes[0].generate(2)\n+        blocks = self.generate(self.nodes[0], 2)\n         self.sync_all(self.nodes[0:3])\n         balance_nodes = [self.nodes[i].getbalance() for i in range(3)]\n         block_count = self.nodes[0].getblockcount()\n@@ -572,13 +572,13 @@ def run_test(self):\n         # Get all non-zero utxos together\n         chain_addrs = [self.nodes[0].getnewaddress(), self.nodes[0].getnewaddress()]\n         singletxid = self.nodes[0].sendtoaddress(chain_addrs[0], self.nodes[0].getbalance(), \"\", \"\", True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         node0_balance = self.nodes[0].getbalance()\n         # Split into two chains\n         rawtx = self.nodes[0].createrawtransaction([{\"txid\": singletxid, \"vout\": 0}], {chain_addrs[0]: node0_balance / 2 - Decimal('0.01'), chain_addrs[1]: node0_balance / 2 - Decimal('0.01')})\n         signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx)\n         singletxid = self.nodes[0].sendrawtransaction(hexstring=signedtx[\"hex\"], maxfeerate=0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Make a long chain of unconfirmed payments without hitting mempool limit\n         # Each tx we make leaves only one output of change on a chain 1 longer\n@@ -629,7 +629,7 @@ def run_test(self):\n         assert not address_info[\"ischange\"]\n \n         # Test getaddressinfo 'ischange' field on change address.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         destination = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(destination, 0.123)\n         tx = self.nodes[0].decoderawtransaction(self.nodes[0].gettransaction(txid)['hex'])"
      },
      {
        "sha": "a1676fffa551d29e0bc1a159d1495846a104eed1",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -59,7 +59,7 @@ def skip_test_if_missing_module(self):\n \n     def clear_mempool(self):\n         # Clear mempool between subtests. The subtests may only depend on chainstate (utxos)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n     def run_test(self):\n@@ -72,12 +72,12 @@ def run_test(self):\n \n         # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n         self.log.info(\"Mining blocks...\")\n-        peer_node.generate(110)\n+        self.generate(peer_node, 110)\n         self.sync_all()\n         for _ in range(25):\n             peer_node.sendtoaddress(rbf_node_address, 0.001)\n         self.sync_all()\n-        peer_node.generate(1)\n+        self.generate(peer_node, 1)\n         self.sync_all()\n         assert_equal(rbf_node.getbalance(), Decimal(\"0.025\"))\n \n@@ -272,7 +272,7 @@ def test_small_output_with_feerate_succeeds(self, rbf_node, dest_address):\n     self.log.info('Testing small output with feerate bump succeeds')\n \n     # Make sure additional inputs exist\n-    rbf_node.generatetoaddress(COINBASE_MATURITY + 1, rbf_node.getnewaddress())\n+    self.generatetoaddress(rbf_node, COINBASE_MATURITY + 1, rbf_node.getnewaddress())\n     rbfid = spend_one_input(rbf_node, dest_address)\n     input_list = rbf_node.getrawtransaction(rbfid, 1)[\"vin\"]\n     assert_equal(len(input_list), 1)\n@@ -305,7 +305,7 @@ def test_small_output_with_feerate_succeeds(self, rbf_node, dest_address):\n             if txin[\"txid\"] == original_txin[\"txid\"]\n             and txin[\"vout\"] == original_txin[\"vout\"]]\n \n-    rbf_node.generatetoaddress(1, rbf_node.getnewaddress())\n+    self.generatetoaddress(rbf_node, 1, rbf_node.getnewaddress())\n     assert_equal(rbf_node.gettransaction(rbfid)[\"confirmations\"], 1)\n     self.clear_mempool()\n \n@@ -433,7 +433,7 @@ def test_watchonly_psbt(self, peer_node, rbf_node, dest_address):\n     funding_address1 = watcher.getnewaddress(address_type='bech32')\n     funding_address2 = watcher.getnewaddress(address_type='bech32')\n     peer_node.sendmany(\"\", {funding_address1: 0.001, funding_address2: 0.001})\n-    peer_node.generate(1)\n+    self.generate(peer_node, 1)\n     self.sync_all()\n \n     # Create single-input PSBT for transaction to be bumped\n@@ -519,7 +519,7 @@ def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):\n     assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == rbfid], [])\n \n     # check that the main output from the rbf tx is spendable after confirmed\n-    rbf_node.generate(1)\n+    self.generate(rbf_node, 1)\n     assert_equal(\n         sum(1 for t in rbf_node.listunspent(minconf=0, include_unsafe=False)\n             if t[\"txid\"] == rbfid and t[\"address\"] == rbf_node_address and t[\"spendable\"]), 1)\n@@ -529,7 +529,7 @@ def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):\n def test_bumpfee_metadata(self, rbf_node, dest_address):\n     self.log.info('Test that bumped txn metadata persists to new txn record')\n     assert(rbf_node.getbalance() < 49)\n-    rbf_node.generatetoaddress(101, rbf_node.getnewaddress())\n+    self.generatetoaddress(rbf_node, 101, rbf_node.getnewaddress())\n     rbfid = rbf_node.sendtoaddress(dest_address, 49, \"comment value\", \"to value\")\n     bumped_tx = rbf_node.bumpfee(rbfid)\n     bumped_wtx = rbf_node.gettransaction(bumped_tx[\"txid\"])\n@@ -599,7 +599,7 @@ def submit_block_with_tx(node, tx):\n def test_no_more_inputs_fails(self, rbf_node, dest_address):\n     self.log.info('Test that bumpfee fails when there are no available confirmed outputs')\n     # feerate rbf requires confirmed outputs when change output doesn't exist or is insufficient\n-    rbf_node.generatetoaddress(1, dest_address)\n+    self.generatetoaddress(rbf_node, 1, dest_address)\n     # spend all funds, no change output\n     rbfid = rbf_node.sendtoaddress(rbf_node.getnewaddress(), rbf_node.getbalance(), \"\", \"\", True)\n     assert_raises_rpc_error(-4, \"Unable to create transaction. Insufficient funds\", rbf_node.bumpfee, rbfid)"
      },
      {
        "sha": "3c7abd08009600907409519ebfd38160349878dd",
        "filename": "test/functional/wallet_coinbase_category.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_coinbase_category.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_coinbase_category.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_coinbase_category.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -33,20 +33,20 @@ def assert_category(self, category, address, txid, skip):\n     def run_test(self):\n         # Generate one block to an address\n         address = self.nodes[0].getnewaddress()\n-        self.nodes[0].generatetoaddress(1, address)\n+        self.generatetoaddress(self.nodes[0], 1, address)\n         hash = self.nodes[0].getbestblockhash()\n         txid = self.nodes[0].getblock(hash)[\"tx\"][0]\n \n         # Coinbase transaction is immature after 1 confirmation\n         self.assert_category(\"immature\", address, txid, 0)\n \n         # Mine another 99 blocks on top\n-        self.nodes[0].generate(99)\n+        self.generate(self.nodes[0], 99)\n         # Coinbase transaction is still immature after 100 confirmations\n         self.assert_category(\"immature\", address, txid, 99)\n \n         # Mine one more block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         # Coinbase transaction is now matured, so category is \"generate\"\n         self.assert_category(\"generate\", address, txid, 100)\n "
      },
      {
        "sha": "c8b92ef1bfe103b563e1866fd87c9fdda3126825",
        "filename": "test/functional/wallet_create_tx.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_create_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_create_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_create_tx.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -24,7 +24,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         self.log.info('Create some old blocks')\n         self.nodes[0].setmocktime(TIME_GENESIS_BLOCK)\n-        self.nodes[0].generate(200)\n+        self.generate(self.nodes[0], 200)\n         self.nodes[0].setmocktime(0)\n \n         self.test_anti_fee_sniping()\n@@ -38,7 +38,7 @@ def test_anti_fee_sniping(self):\n         assert_equal(tx['locktime'], 0)\n \n         self.log.info('Check that anti-fee-sniping is enabled when we mine a recent block')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tx = self.nodes[0].decoderawtransaction(self.nodes[0].gettransaction(txid)['hex'])\n         assert 0 < tx['locktime'] <= 201"
      },
      {
        "sha": "d806f8f6d2c839e1006c22d692a4cf500940d659",
        "filename": "test/functional/wallet_createwallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_createwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_createwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_createwallet.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -24,7 +24,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         node = self.nodes[0]\n-        node.generate(1) # Leave IBD for sethdseed\n+        self.generate(node, 1) # Leave IBD for sethdseed\n \n         self.nodes[0].createwallet(wallet_name='w0')\n         w0 = node.get_wallet_rpc('w0')"
      },
      {
        "sha": "d0043e9bbbc204db981602c07fd366fedc868a5d",
        "filename": "test/functional/wallet_disable.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_disable.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_disable.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_disable.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -28,8 +28,8 @@ def run_test (self):\n \n         # Checking mining to an address without a wallet. Generating to a valid address should succeed\n         # but generating to an invalid address will fail.\n-        self.nodes[0].generatetoaddress(1, 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n-        assert_raises_rpc_error(-5, \"Invalid address\", self.nodes[0].generatetoaddress, 1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n+        self.generatetoaddress(self.nodes[0], 1, 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n+        assert_raises_rpc_error(-5, \"Invalid address\", self.generatetoaddress, self.nodes[0], 1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n \n if __name__ == '__main__':\n     DisableWalletTest ().main ()"
      },
      {
        "sha": "06460e17d29547601a4a8d9f6f0901cbfb3f3489",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -134,7 +134,7 @@ def run_test(self):\n         self.log.info('Mine a block one second before the wallet is dumped')\n         dump_time = int(time.time())\n         self.nodes[0].setmocktime(dump_time - 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.nodes[0].setmocktime(dump_time)\n         dump_time_str = '# * Created on {}Z'.format(\n             datetime.datetime.fromtimestamp("
      },
      {
        "sha": "674c37dc73c5389aa0d966f58e25babbdcbd67af",
        "filename": "test/functional/wallet_fallbackfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_fallbackfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_fallbackfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_fallbackfee.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -17,7 +17,7 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         # sending a transaction without fee estimations must be possible by default on regtest\n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)"
      },
      {
        "sha": "802fed6e7dbf31234ede8b06cdb8e6d8ddef8824",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -34,7 +34,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         self.log.info(\"Setting up\")\n         # Mine some coins\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         # Get some addresses from the two nodes\n         addr1 = [self.nodes[1].getnewaddress() for _ in range(3)]\n@@ -45,7 +45,7 @@ def run_test(self):\n         [self.nodes[0].sendtoaddress(addr, 1.0) for addr in addrs]\n         [self.nodes[0].sendtoaddress(addr, 0.5) for addr in addrs]\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # For each node, send 0.2 coins back to 0;\n@@ -77,7 +77,7 @@ def run_test(self):\n \n         self.log.info(\"Test avoiding partial spends if warranted, even if avoidpartialspends is disabled\")\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         # Nodes 1-2 now have confirmed UTXOs (letters denote destinations):\n         # Node #1:      Node #2:\n         # - A  1.0      - D0 1.0\n@@ -113,7 +113,7 @@ def run_test(self):\n         addr_aps = self.nodes[3].getnewaddress()\n         self.nodes[0].sendtoaddress(addr_aps, 1.0)\n         self.nodes[0].sendtoaddress(addr_aps, 1.0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         with self.nodes[3].assert_debug_log(['Fee non-grouped = 2820, grouped = 4160, using grouped']):\n             txid4 = self.nodes[3].sendtoaddress(self.nodes[0].getnewaddress(), 0.1)\n@@ -125,7 +125,7 @@ def run_test(self):\n \n         addr_aps2 = self.nodes[3].getnewaddress()\n         [self.nodes[0].sendtoaddress(addr_aps2, 1.0) for _ in range(5)]\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         with self.nodes[3].assert_debug_log(['Fee non-grouped = 5520, grouped = 8240, using non-grouped']):\n             txid5 = self.nodes[3].sendtoaddress(self.nodes[0].getnewaddress(), 2.95)\n@@ -139,7 +139,7 @@ def run_test(self):\n         self.log.info(\"Test wallet option maxapsfee threshold from non-grouped to grouped\")\n         addr_aps3 = self.nodes[4].getnewaddress()\n         [self.nodes[0].sendtoaddress(addr_aps3, 1.0) for _ in range(5)]\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         with self.nodes[4].assert_debug_log(['Fee non-grouped = 5520, grouped = 8240, using grouped']):\n             txid6 = self.nodes[4].sendtoaddress(self.nodes[0].getnewaddress(), 2.95)\n@@ -151,7 +151,7 @@ def run_test(self):\n         # Empty out node2's wallet\n         self.nodes[2].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=self.nodes[2].getbalance(), subtractfeefromamount=True)\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"Fill a wallet with 10,000 outputs corresponding to the same scriptPubKey\")\n         for _ in range(5):\n@@ -162,7 +162,7 @@ def run_test(self):\n             funded_tx = self.nodes[0].fundrawtransaction(tx.serialize().hex())\n             signed_tx = self.nodes[0].signrawtransactionwithwallet(funded_tx['hex'])\n             self.nodes[0].sendrawtransaction(signed_tx['hex'])\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_all()\n \n         # Check that we can create a transaction that only requires ~100 of our"
      },
      {
        "sha": "74f584f2cd20a90a4303c8214d0c02e7e2a5eef8",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -49,7 +49,7 @@ def run_test(self):\n \n         # Derive some HD addresses and remember the last\n         # Also send funds to each add\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         hd_add = None\n         NUM_HD_ADDS = 10\n         for i in range(1, NUM_HD_ADDS + 1):\n@@ -61,9 +61,9 @@ def run_test(self):\n                 assert_equal(hd_info[\"hdkeypath\"], \"m/0'/0'/\" + str(i) + \"'\")\n             assert_equal(hd_info[\"hdmasterfingerprint\"], hd_fingerprint)\n             self.nodes[0].sendtoaddress(hd_add, 1)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n         self.nodes[0].sendtoaddress(non_hd_add, 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # create an internal key (again)\n         change_addr = self.nodes[1].getrawchangeaddress()\n@@ -179,7 +179,7 @@ def run_test(self):\n             assert_raises_rpc_error(-5, \"Already have this key\", self.nodes[1].sethdseed, False, self.nodes[1].dumpprivkey(self.nodes[1].getnewaddress()))\n \n             self.log.info('Test sethdseed restoring with keys outside of the initial keypool')\n-            self.nodes[0].generate(10)\n+            self.generate(self.nodes[0], 10)\n             # Restart node 1 with keypool of 3 and a different wallet\n             self.nodes[1].createwallet(wallet_name='origin', blank=True)\n             self.restart_node(1, extra_args=['-keypool=3', '-wallet=origin'])\n@@ -228,7 +228,7 @@ def run_test(self):\n             # The wallet that has set a new seed (restore_rpc) should not detect this transaction.\n             txid = self.nodes[0].sendtoaddress(addr, 1)\n             origin_rpc.sendrawtransaction(self.nodes[0].gettransaction(txid)['hex'])\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks()\n             origin_rpc.gettransaction(txid)\n             assert_raises_rpc_error(-5, 'Invalid or non-wallet transaction id', restore_rpc.gettransaction, txid)\n@@ -239,7 +239,7 @@ def run_test(self):\n             # The previous transaction (out_of_kp_txid) should still not be detected as a rescan is required.\n             txid = self.nodes[0].sendtoaddress(last_addr, 1)\n             origin_rpc.sendrawtransaction(self.nodes[0].gettransaction(txid)['hex'])\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks()\n             origin_rpc.gettransaction(txid)\n             restore_rpc.gettransaction(txid)"
      },
      {
        "sha": "cbe3e9bfddd5a0bfbf350e121b72b4314329b539",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -178,7 +178,7 @@ def run_test(self):\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n             variant.initial_amount = get_rand_amount()\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n-            self.nodes[0].generate(1)  # Generate one block for each send\n+            self.generate(self.nodes[0], 1)  # Generate one block for each send\n             variant.confirmation_height = self.nodes[0].getblockcount()\n             variant.timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n         self.sync_all() # Conclude sync before calling setmocktime to avoid timeouts\n@@ -189,7 +189,7 @@ def run_test(self):\n             self.nodes,\n             self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"] + TIMESTAMP_WINDOW + 1,\n         )\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # For each variation of wallet key import, invoke the import RPC and\n@@ -212,7 +212,7 @@ def run_test(self):\n         for i, variant in enumerate(IMPORT_VARIANTS):\n             variant.sent_amount = get_rand_amount()\n             variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n-            self.nodes[0].generate(1)  # Generate one block for each send\n+            self.generate(self.nodes[0], 1)  # Generate one block for each send\n             variant.confirmation_height = self.nodes[0].getblockcount()\n \n         assert_equal(self.nodes[0].getrawmempool(), [])"
      },
      {
        "sha": "d86c3737fe5102583bdf475fe7a01da9c8c5e553",
        "filename": "test/functional/wallet_importdescriptors.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importdescriptors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importdescriptors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importdescriptors.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -451,12 +451,12 @@ def run_test(self):\n         assert_equal(change_addr, 'bcrt1qt9uhe3a9hnq7vajl7a094z4s3crm9ttf8zw3f5v9gr2nyd7e3lnsy44n8e')\n         assert_equal(wmulti_priv.getwalletinfo()['keypoolsize'], 1000)\n         txid = w0.sendtoaddress(addr, 10)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n         send_txid = wmulti_priv.sendtoaddress(w0.getnewaddress(), 8)\n         decoded = wmulti_priv.decoderawtransaction(wmulti_priv.gettransaction(send_txid)['hex'])\n         assert_equal(len(decoded['vin'][0]['txinwitness']), 4)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n \n         self.nodes[1].createwallet(wallet_name=\"wmulti_pub\", disable_private_keys=True, blank=True, descriptors=True)\n@@ -494,7 +494,7 @@ def run_test(self):\n         txid2 = w0.sendtoaddress(addr2, 10)\n         vout2 = find_vout_for_address(self.nodes[0], txid2, addr2)\n \n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n         assert_equal(wmulti_pub.getbalance(), wmulti_priv.getbalance())\n \n@@ -582,7 +582,7 @@ def run_test(self):\n \n         addr = wmulti_priv_big.getnewaddress()\n         w0.sendtoaddress(addr, 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         # It is standard and would relay.\n         txid = wmulti_priv_big.sendtoaddress(w0.getnewaddress(), 9.999)\n@@ -617,7 +617,7 @@ def run_test(self):\n \n         addr = multi_priv_big.getnewaddress(\"\", \"legacy\")\n         w0.sendtoaddress(addr, 10)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n         # It is standard and would relay.\n         txid = multi_priv_big.sendtoaddress(w0.getnewaddress(), 10, \"\", \"\","
      },
      {
        "sha": "4e8907bc3d40bbebac5eb7c407852d35bf99b5eb",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -62,8 +62,8 @@ def test_importmulti(self, req, success, error_code=None, error_message=None, wa\n \n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n-        self.nodes[0].generate(1)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[1], 1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()  # Sync the timestamp to the wallet, so that importmulti works\n \n@@ -256,9 +256,9 @@ def run_test(self):\n \n         # P2SH address\n         multisig = get_multisig(self.nodes[0])\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -277,9 +277,9 @@ def run_test(self):\n \n         # P2SH + Redeem script\n         multisig = get_multisig(self.nodes[0])\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -298,9 +298,9 @@ def run_test(self):\n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n         multisig = get_multisig(self.nodes[0])\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -324,9 +324,9 @@ def run_test(self):\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n         multisig = get_multisig(self.nodes[0])\n-        self.nodes[1].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n "
      },
      {
        "sha": "74c5100f401d8af03f6acaee36bbb23d7b2bf96f",
        "filename": "test/functional/wallet_importprunedfunds.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importprunedfunds.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -25,7 +25,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         self.sync_all()\n \n@@ -64,17 +64,17 @@ def run_test(self):\n \n         # Send funds to self\n         txnid1 = self.nodes[0].sendtoaddress(address1, 0.1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         rawtxn1 = self.nodes[0].gettransaction(txnid1)['hex']\n         proof1 = self.nodes[0].gettxoutproof([txnid1])\n \n         txnid2 = self.nodes[0].sendtoaddress(address2, 0.05)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         rawtxn2 = self.nodes[0].gettransaction(txnid2)['hex']\n         proof2 = self.nodes[0].gettxoutproof([txnid2])\n \n         txnid3 = self.nodes[0].sendtoaddress(address3, 0.025)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         rawtxn3 = self.nodes[0].gettransaction(txnid3)['hex']\n         proof3 = self.nodes[0].gettxoutproof([txnid3])\n "
      },
      {
        "sha": "c714993234230088cafac2bee1d5a7d6f40f627a",
        "filename": "test/functional/wallet_keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -156,7 +156,7 @@ def run_test(self):\n         w1.walletpassphrase('test', 100)\n \n         res = w1.sendtoaddress(address=address, amount=0.00010000)\n-        nodes[0].generate(1)\n+        self.generate(nodes[0], 1)\n         destination = addr.pop()\n \n         # Using a fee rate (10 sat / byte) well above the minimum relay rate"
      },
      {
        "sha": "f730f8239795450f1ada30cddacbcdbea7bc8310",
        "filename": "test/functional/wallet_keypool_topup.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_keypool_topup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_keypool_topup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool_topup.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -32,7 +32,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         wallet_path = os.path.join(self.nodes[1].datadir, self.chain, \"wallets\", self.default_wallet_name, self.wallet_data_filename)\n         wallet_backup_path = os.path.join(self.nodes[1].datadir, \"wallet.bak\")\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         self.log.info(\"Make backup of wallet\")\n         self.stop_node(1)\n@@ -63,9 +63,9 @@ def run_test(self):\n \n             self.log.info(\"Send funds to wallet\")\n             self.nodes[0].sendtoaddress(addr_oldpool, 10)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.nodes[0].sendtoaddress(addr_extpool, 5)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks()\n \n             self.log.info(\"Restart node with wallet backup\")"
      },
      {
        "sha": "150f2b341e03d86fcb793181c61b776faaad41d8",
        "filename": "test/functional/wallet_labels.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_labels.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_labels.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_labels.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -32,8 +32,8 @@ def run_test(self):\n \n         # Note each time we call generate, all generated coins go into\n         # the same address, so we call twice to get two addresses w/50 each\n-        node.generatetoaddress(nblocks=1, address=node.getnewaddress(label='coinbase'))\n-        node.generatetoaddress(nblocks=COINBASE_MATURITY + 1, address=node.getnewaddress(label='coinbase'))\n+        self.generatetoaddress(node, nblocks=1, address=node.getnewaddress(label='coinbase'))\n+        self.generatetoaddress(node, nblocks=COINBASE_MATURITY + 1, address=node.getnewaddress(label='coinbase'))\n         assert_equal(node.getbalance(), 100)\n \n         # there should be 2 address groups\n@@ -65,7 +65,7 @@ def run_test(self):\n         assert_equal(set([a[0] for a in address_groups[0]]), linked_addresses)\n         assert_equal([a[1] for a in address_groups[0]], [0, 0])\n \n-        node.generate(1)\n+        self.generate(node, 1)\n \n         # we want to reset so that the \"\" label has what's expected.\n         # otherwise we're off by exactly the fee amount as that's mined\n@@ -89,7 +89,7 @@ def run_test(self):\n             label.verify(node)\n \n         # Check the amounts received.\n-        node.generate(1)\n+        self.generate(node, 1)\n         for label in labels:\n             assert_equal(\n                 node.getreceivedbyaddress(label.addresses[0]), amount_to_send)\n@@ -98,14 +98,14 @@ def run_test(self):\n         for i, label in enumerate(labels):\n             to_label = labels[(i + 1) % len(labels)]\n             node.sendtoaddress(to_label.addresses[0], amount_to_send)\n-        node.generate(1)\n+        self.generate(node, 1)\n         for label in labels:\n             address = node.getnewaddress(label.name)\n             label.add_receive_address(address)\n             label.verify(node)\n             assert_equal(node.getreceivedbylabel(label.name), 2)\n             label.verify(node)\n-        node.generate(COINBASE_MATURITY + 1)\n+        self.generate(node, COINBASE_MATURITY + 1)\n \n         # Check that setlabel can assign a label to a new unused address.\n         for label in labels:\n@@ -125,7 +125,7 @@ def run_test(self):\n                 label.add_address(multisig_address)\n                 label.purpose[multisig_address] = \"send\"\n                 label.verify(node)\n-            node.generate(COINBASE_MATURITY + 1)\n+            self.generate(node, COINBASE_MATURITY + 1)\n \n         # Check that setlabel can change the label of an address from a\n         # different label.\n@@ -152,7 +152,7 @@ def run_test(self):\n             for l in BECH32_VALID:\n                 ad = BECH32_VALID[l]\n                 wallet_watch_only.importaddress(label=l, rescan=False, address=ad)\n-                node.generatetoaddress(1, ad)\n+                self.generatetoaddress(node, 1, ad)\n                 assert_equal(wallet_watch_only.getaddressesbylabel(label=l), {ad: {'purpose': 'receive'}})\n                 assert_equal(wallet_watch_only.getreceivedbylabel(label=l), 0)\n             for l in BECH32_INVALID:"
      },
      {
        "sha": "975bf9a84ba1d7ea9e37b18e567cd163c39169d3",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -24,7 +24,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         # Generate block to get out of IBD\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # save the number of coinbase reward addresses so far\n@@ -43,7 +43,7 @@ def run_test(self):\n                             {},\n                             True)\n         # Bury Tx under 10 block so it will be returned by listreceivedbyaddress\n-        self.nodes[1].generate(10)\n+        self.generate(self.nodes[1], 10)\n         self.sync_all()\n         assert_array_result(self.nodes[1].listreceivedbyaddress(),\n                             {\"address\": addr},\n@@ -78,7 +78,7 @@ def run_test(self):\n         assert_equal(len(res), 2 + num_cb_reward_addresses)  # Right now 2 entries\n         other_addr = self.nodes[1].getnewaddress()\n         txid2 = self.nodes[0].sendtoaddress(other_addr, 0.1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n         # Same test as above should still pass\n         expected = {\"address\": addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 11, \"txids\": [txid, ]}\n@@ -115,7 +115,7 @@ def run_test(self):\n         assert_equal(balance, Decimal(\"0.1\"))\n \n         # Bury Tx under 10 block so it will be returned by the default getreceivedbyaddress\n-        self.nodes[1].generate(10)\n+        self.generate(self.nodes[1], 10)\n         self.sync_all()\n         balance = self.nodes[1].getreceivedbyaddress(addr)\n         assert_equal(balance, Decimal(\"0.1\"))\n@@ -144,7 +144,7 @@ def run_test(self):\n         balance = self.nodes[1].getreceivedbylabel(label)\n         assert_equal(balance, balance_by_label)\n \n-        self.nodes[1].generate(10)\n+        self.generate(self.nodes[1], 10)\n         self.sync_all()\n         # listreceivedbylabel should return updated received list\n         assert_array_result(self.nodes[1].listreceivedbylabel(),"
      },
      {
        "sha": "bd3b29c81c7a4a3bbd92fbc101087e64af1b6059",
        "filename": "test/functional/wallet_listsinceblock.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listsinceblock.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -30,7 +30,7 @@ def run_test(self):\n         # All nodes are in IBD from genesis, so they'll need the miner (node2) to be an outbound connection, or have\n         # only one connection. (See fPreferredDownload in net_processing)\n         self.connect_nodes(1, 2)\n-        self.nodes[2].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[2], COINBASE_MATURITY + 1)\n         self.sync_all()\n \n         self.test_no_blockhash()\n@@ -44,7 +44,7 @@ def run_test(self):\n     def test_no_blockhash(self):\n         self.log.info(\"Test no blockhash\")\n         txid = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        blockhash, = self.nodes[2].generate(1)\n+        blockhash, = self.generate(self.nodes[2], 1)\n         blockheight = self.nodes[2].getblockheader(blockhash)['height']\n         self.sync_all()\n \n@@ -86,7 +86,7 @@ def test_targetconfirmations(self):\n         a -8 invalid parameter error is thrown.\n         '''\n         self.log.info(\"Test target_confirmations\")\n-        blockhash, = self.nodes[2].generate(1)\n+        blockhash, = self.generate(self.nodes[2], 1)\n         blockheight = self.nodes[2].getblockheader(blockhash)['height']\n         self.sync_all()\n \n@@ -136,8 +136,8 @@ def test_reorg(self):\n         senttx = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n \n         # generate on both sides\n-        nodes1_last_blockhash = self.nodes[1].generate(6)[-1]\n-        nodes2_first_blockhash = self.nodes[2].generate(7)[0]\n+        nodes1_last_blockhash = self.generate(self.nodes[1], 6)[-1]\n+        nodes2_first_blockhash = self.generate(self.nodes[2], 7)[0]\n         self.log.debug(\"nodes[1] last blockhash = {}\".format(nodes1_last_blockhash))\n         self.log.debug(\"nodes[2] first blockhash = {}\".format(nodes2_first_blockhash))\n \n@@ -191,7 +191,7 @@ def test_double_spend(self):\n         privkey = bytes_to_wif(eckey.get_bytes())\n         address = key_to_p2wpkh(eckey.get_pubkey().get_bytes())\n         self.nodes[2].sendtoaddress(address, 10)\n-        self.nodes[2].generate(6)\n+        self.generate(self.nodes[2], 6)\n         self.sync_all()\n         self.nodes[2].importprivkey(privkey)\n         utxos = self.nodes[2].listunspent()\n@@ -225,8 +225,8 @@ def test_double_spend(self):\n                 self.nodes[2].createrawtransaction(utxo_dicts, recipient_dict2))['hex'])\n \n         # generate on both sides\n-        lastblockhash = self.nodes[1].generate(3)[2]\n-        self.nodes[2].generate(4)\n+        lastblockhash = self.generate(self.nodes[1], 3)[2]\n+        self.generate(self.nodes[2], 4)\n \n         self.join_network()\n \n@@ -297,16 +297,16 @@ def test_double_send(self):\n         txid1 = self.nodes[1].sendrawtransaction(signedtx)\n \n         # generate bb1-bb2 on right side\n-        self.nodes[2].generate(2)\n+        self.generate(self.nodes[2], 2)\n \n         # send from nodes[2]; this will end up in bb3\n         txid2 = self.nodes[2].sendrawtransaction(signedtx)\n \n         assert_equal(txid1, txid2)\n \n         # generate on both sides\n-        lastblockhash = self.nodes[1].generate(3)[2]\n-        self.nodes[2].generate(2)\n+        lastblockhash = self.generate(self.nodes[1], 3)[2]\n+        self.generate(self.nodes[2], 2)\n \n         self.join_network()\n \n@@ -365,7 +365,7 @@ def double_spends_filtered(self):\n         assert_equal(original_found, True)\n         assert_equal(double_found, True)\n \n-        lastblockhash = spending_node.generate(1)[0]\n+        lastblockhash = self.generate(spending_node, 1)[0]\n \n         # check that neither transaction exists\n         block_hash = spending_node.listsinceblock(lastblockhash)"
      },
      {
        "sha": "a14bfe345cc561fc9d870762a07acf3e7d42ebcd",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -36,7 +36,7 @@ def run_test(self):\n                             {\"txid\": txid},\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n         self.log.info(\"Test confirmations change after mining a block\")\n-        blockhash = self.nodes[0].generate(1)[0]\n+        blockhash = self.generate(self.nodes[0], 1)[0]\n         blockheight = self.nodes[0].getblockheader(blockhash)['height']\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n@@ -94,7 +94,7 @@ def run_test(self):\n             multisig = self.nodes[1].createmultisig(1, [pubkey])\n             self.nodes[0].importaddress(multisig[\"redeemScript\"], \"watchonly\", False, True)\n             txid = self.nodes[1].sendtoaddress(multisig[\"address\"], 0.1)\n-            self.nodes[1].generate(1)\n+            self.generate(self.nodes[1], 1)\n             self.sync_all()\n             assert_equal(len(self.nodes[0].listtransactions(label=\"watchonly\", include_watchonly=True)), 1)\n             assert_equal(len(self.nodes[0].listtransactions(dummy=\"watchonly\", include_watchonly=True)), 1)\n@@ -205,7 +205,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n             assert_equal(n.gettransaction(txid_4)[\"bip125-replaceable\"], \"unknown\")\n \n         self.log.info(\"Test mined transactions are no longer bip125-replaceable\")\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert txid_3b not in self.nodes[0].getrawmempool()\n         assert_equal(self.nodes[0].gettransaction(txid_3b)[\"bip125-replaceable\"], \"no\")\n         assert_equal(self.nodes[0].gettransaction(txid_4)[\"bip125-replaceable\"], \"unknown\")"
      },
      {
        "sha": "d4768f5043738f84448fb0f83ba53675440bfbf4",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -185,7 +185,7 @@ def wallet_file(name):\n         self.nodes[0].createwallet(\"w5\")\n         assert_equal(set(node.listwallets()), {\"w4\", \"w5\"})\n         w5 = wallet(\"w5\")\n-        node.generatetoaddress(nblocks=1, address=w5.getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=w5.getnewaddress())\n \n         # now if wallets/ exists again, but the rootdir is specified as the walletdir, w4 and w5 should still be loaded\n         os.rename(wallet_dir2, wallet_dir())\n@@ -217,7 +217,7 @@ def wallet_file(name):\n         wallet_bad = wallet(\"bad\")\n \n         # check wallet names and balances\n-        node.generatetoaddress(nblocks=1, address=wallets[0].getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=wallets[0].getnewaddress())\n         for wallet_name, wallet in zip(wallet_names, wallets):\n             info = wallet.getwalletinfo()\n             assert_equal(info['immature_balance'], 50 if wallet is wallets[0] else 0)\n@@ -230,7 +230,7 @@ def wallet_file(name):\n         assert_raises_rpc_error(-19, \"Wallet file not specified\", node.getwalletinfo)\n \n         w1, w2, w3, w4, *_ = wallets\n-        node.generatetoaddress(nblocks=COINBASE_MATURITY + 1, address=w1.getnewaddress())\n+        self.generatetoaddress(node, nblocks=COINBASE_MATURITY + 1, address=w1.getnewaddress())\n         assert_equal(w1.getbalance(), 100)\n         assert_equal(w2.getbalance(), 0)\n         assert_equal(w3.getbalance(), 0)\n@@ -239,7 +239,7 @@ def wallet_file(name):\n         w1.sendtoaddress(w2.getnewaddress(), 1)\n         w1.sendtoaddress(w3.getnewaddress(), 2)\n         w1.sendtoaddress(w4.getnewaddress(), 3)\n-        node.generatetoaddress(nblocks=1, address=w1.getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=w1.getnewaddress())\n         assert_equal(w2.getbalance(), 1)\n         assert_equal(w3.getbalance(), 2)\n         assert_equal(w4.getbalance(), 3)"
      },
      {
        "sha": "ff1d1bd49b6709a5e68fb0d8a54d5eb948d8cab4",
        "filename": "test/functional/wallet_orphanedreward.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_orphanedreward.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_orphanedreward.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_orphanedreward.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -18,27 +18,27 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         # Generate some blocks and obtain some coins on node 0.  We send\n         # some balance to node 1, which will hold it as a single coin.\n-        self.nodes[0].generate(150)\n+        self.generate(self.nodes[0], 150)\n         self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 10)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Get a block reward with node 1 and remember the block so we can orphan\n         # it later.\n         self.sync_blocks()\n-        blk = self.nodes[1].generate(1)[0]\n+        blk = self.generate(self.nodes[1], 1)[0]\n         self.sync_blocks()\n \n         # Let the block reward mature and send coins including both\n         # the existing balance and the block reward.\n-        self.nodes[0].generate(150)\n+        self.generate(self.nodes[0], 150)\n         self.sync_blocks()\n         assert_equal(self.nodes[1].getbalance(), 10 + 25)\n         txid = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 30)\n \n         # Orphan the block reward and make sure that the original coins\n         # from the wallet can still be spent.\n         self.nodes[0].invalidateblock(blk)\n-        self.nodes[0].generate(152)\n+        self.generate(self.nodes[0], 152)\n         self.sync_blocks()\n         # Without the following abandontransaction call, the coins are\n         # not considered available yet."
      },
      {
        "sha": "1f452f833788382bf026573d56e336f1f3d9d6d4",
        "filename": "test/functional/wallet_reorgsrestore.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_reorgsrestore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_reorgsrestore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_reorgsrestore.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -32,7 +32,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         # Send a tx from which to conflict outputs later\n         txid_conflict_from = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Disconnect node1 from others to reorg its chain later\n@@ -43,7 +43,7 @@ def run_test(self):\n         # Send a tx to be unconfirmed later\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n         tx = self.nodes[0].gettransaction(txid)\n-        self.nodes[0].generate(4)\n+        self.generate(self.nodes[0], 4)\n         tx_before_reorg = self.nodes[0].gettransaction(txid)\n         assert_equal(tx_before_reorg[\"confirmations\"], 4)\n \n@@ -62,9 +62,9 @@ def run_test(self):\n         conflicting = self.nodes[0].signrawtransactionwithwallet(self.nodes[0].createrawtransaction(inputs, outputs_2))\n \n         conflicted_txid = self.nodes[0].sendrawtransaction(conflicted[\"hex\"])\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         conflicting_txid = self.nodes[2].sendrawtransaction(conflicting[\"hex\"])\n-        self.nodes[2].generate(9)\n+        self.generate(self.nodes[2], 9)\n \n         # Reconnect node0 and node2 and check that conflicted_txid is effectively conflicted\n         self.connect_nodes(0, 2)\n@@ -78,11 +78,11 @@ def run_test(self):\n         self.restart_node(0)\n \n         # The block chain re-orgs and the tx is included in a different block\n-        self.nodes[1].generate(9)\n+        self.generate(self.nodes[1], 9)\n         self.nodes[1].sendrawtransaction(tx[\"hex\"])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.nodes[1].sendrawtransaction(conflicted[\"hex\"])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n \n         # Node0 wallet file is loaded on longest sync'ed node1\n         self.stop_node(1)"
      },
      {
        "sha": "aecdaf821f38887aae2f746c4eedcbf5ba19258c",
        "filename": "test/functional/wallet_send.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_send.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_send.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_send.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -241,7 +241,7 @@ def run_test(self):\n                 assert_equal(res, [{\"success\": True}, {\"success\": True}])\n \n         w0.sendtoaddress(a2_receive, 10) # fund w3\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         if not self.options.descriptors:\n@@ -260,7 +260,7 @@ def run_test(self):\n                 assert_equal(res, [{\"success\": True}])\n \n             w0.sendtoaddress(a2_receive, 10) # fund w4\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks()\n \n         self.log.info(\"Send to address...\")\n@@ -435,14 +435,14 @@ def run_test(self):\n         assert not res[0][\"allowed\"]\n         assert_equal(res[0][\"reject-reason\"], \"non-final\")\n         # It shouldn't be confirmed in the next block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(self.nodes[0].gettransaction(txid)[\"confirmations\"], 0)\n         # The mempool should allow it now:\n         res = self.nodes[0].testmempoolaccept([hex])\n         assert res[0][\"allowed\"]\n         # Don't wait for wallet to add it to the mempool:\n         res = self.nodes[0].sendrawtransaction(hex)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(self.nodes[0].gettransaction(txid)[\"confirmations\"], 1)\n         self.sync_all()\n "
      },
      {
        "sha": "7b77755d644b4936f0f61f97e66ebb98590cd771",
        "filename": "test/functional/wallet_signer.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_signer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_signer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_signer.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -108,7 +108,7 @@ def run_test(self):\n \n         self.log.info('Prepare mock PSBT')\n         self.nodes[0].sendtoaddress(address1, 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Load private key into wallet to generate a signed PSBT for the mock"
      },
      {
        "sha": "4f84dbd1255b25d510111ea6ba072fbebacbd14d",
        "filename": "test/functional/wallet_taproot.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_taproot.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -272,11 +272,11 @@ def do_test_sendtoaddress(self, comment, pattern, privmap, treefn, keys_pay, key\n             boring_balance = int(self.boring.getbalance() * 100000000)\n             to_amnt = random.randrange(1000000, boring_balance)\n             self.boring.sendtoaddress(address=addr_g, amount=Decimal(to_amnt) / 100000000, subtractfeefromamount=True)\n-            self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n             test_balance = int(self.rpc_online.getbalance() * 100000000)\n             ret_amnt = random.randrange(100000, test_balance)\n             res = self.rpc_online.sendtoaddress(address=self.boring.getnewaddress(), amount=Decimal(ret_amnt) / 100000000, subtractfeefromamount=True)\n-            self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n             assert(self.rpc_online.gettransaction(res)[\"confirmations\"] > 0)\n \n     def do_test_psbt(self, comment, pattern, privmap, treefn, keys_pay, keys_change):\n@@ -303,15 +303,15 @@ def do_test_psbt(self, comment, pattern, privmap, treefn, keys_pay, keys_change)\n             boring_balance = int(self.boring.getbalance() * 100000000)\n             to_amnt = random.randrange(1000000, boring_balance)\n             self.boring.sendtoaddress(address=addr_g, amount=Decimal(to_amnt) / 100000000, subtractfeefromamount=True)\n-            self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n             test_balance = int(self.psbt_online.getbalance() * 100000000)\n             ret_amnt = random.randrange(100000, test_balance)\n             psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): Decimal(ret_amnt) / 100000000}], None, {\"subtractFeeFromOutputs\":[0]})['psbt']\n             res = self.psbt_offline.walletprocesspsbt(psbt)\n             assert(res['complete'])\n             rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']\n             txid = self.nodes[0].sendrawtransaction(rawtx)\n-            self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n             assert(self.psbt_online.gettransaction(txid)['confirmations'] > 0)\n \n     def do_test(self, comment, pattern, privmap, treefn, nkeys):\n@@ -343,7 +343,7 @@ def run_test(self):\n \n         self.log.info(\"Mining blocks...\")\n         gen_addr = self.boring.getnewaddress()\n-        self.nodes[0].generatetoaddress(101, gen_addr)\n+        self.generatetoaddress(self.nodes[0], 101, gen_addr)\n \n         self.do_test(\n             \"tr(XPRV)\",\n@@ -412,15 +412,15 @@ def run_test(self):\n         self.log.info(\"Sending everything back...\")\n \n         txid = self.rpc_online.sendtoaddress(address=self.boring.getnewaddress(), amount=self.rpc_online.getbalance(), subtractfeefromamount=True)\n-        self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n         assert(self.rpc_online.gettransaction(txid)[\"confirmations\"] > 0)\n \n         psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): self.psbt_online.getbalance()}], None, {\"subtractFeeFromOutputs\": [0]})['psbt']\n         res = self.psbt_offline.walletprocesspsbt(psbt)\n         assert(res['complete'])\n         rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']\n         txid = self.nodes[0].sendrawtransaction(rawtx)\n-        self.nodes[0].generatetoaddress(1, self.boring.getnewaddress())\n+        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n         assert(self.psbt_online.gettransaction(txid)['confirmations'] > 0)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "3eb525a9bc9c0c7a05d46204f4e4feb234251360",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -84,7 +84,7 @@ def run_test(self):\n \n         # Have node0 mine a block, if requested:\n         if (self.options.mine_block):\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks(self.nodes[0:2])\n \n         tx1 = self.nodes[0].gettransaction(txid1)\n@@ -114,13 +114,13 @@ def run_test(self):\n             return\n \n         # ... mine a block...\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n \n         # Reconnect the split network, and sync chain:\n         self.connect_nodes(1, 2)\n         self.nodes[2].sendrawtransaction(node0_tx2[\"hex\"])\n         self.nodes[2].sendrawtransaction(tx2[\"hex\"])\n-        self.nodes[2].generate(1)  # Mine another block to make sure we sync\n+        self.generate(self.nodes[2], 1)  # Mine another block to make sure we sync\n         self.sync_blocks()\n \n         # Re-fetch transaction info:"
      },
      {
        "sha": "bfa171d9137c0eb4e34278678d5ea778130a2157",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -82,7 +82,7 @@ def run_test(self):\n \n         # Have node0 mine a block:\n         if (self.options.mine_block):\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             self.sync_blocks(self.nodes[0:2])\n \n         tx1 = self.nodes[0].gettransaction(txid1)\n@@ -111,11 +111,11 @@ def run_test(self):\n         self.nodes[2].sendrawtransaction(fund_bar_tx[\"hex\"])\n         doublespend_txid = self.nodes[2].sendrawtransaction(doublespend[\"hex\"])\n         # ... mine a block...\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n \n         # Reconnect the split network, and sync chain:\n         self.connect_nodes(1, 2)\n-        self.nodes[2].generate(1)  # Mine another block to make sure we sync\n+        self.generate(self.nodes[2], 1)  # Mine another block to make sure we sync\n         self.sync_blocks()\n         assert_equal(self.nodes[0].gettransaction(doublespend_txid)[\"confirmations\"], 2)\n "
      },
      {
        "sha": "ed98db55c9db8cd645d6d2bd4168cc951732df4d",
        "filename": "test/functional/wallet_upgradewallet.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_upgradewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_upgradewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_upgradewallet.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -119,7 +119,7 @@ def test_upgradewallet_error(self, wallet, previous_version, requested_version,\n         assert_equal(wallet.getwalletinfo()[\"walletversion\"], previous_version)\n \n     def run_test(self):\n-        self.nodes[0].generatetoaddress(COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n         self.dumb_sync_blocks()\n         # # Sanity check the test framework:\n         res = self.nodes[0].getblockchaininfo()\n@@ -131,7 +131,7 @@ def run_test(self):\n         # Send coins to old wallets for later conversion checks.\n         v16_3_wallet  = v16_3_node.get_wallet_rpc('wallet.dat')\n         v16_3_address = v16_3_wallet.getnewaddress()\n-        node_master.generatetoaddress(COINBASE_MATURITY + 1, v16_3_address)\n+        self.generatetoaddress(node_master, COINBASE_MATURITY + 1, v16_3_address)\n         self.dumb_sync_blocks()\n         v16_3_balance = v16_3_wallet.getbalance()\n "
      },
      {
        "sha": "3a9800111b07a492b1f8d1ff9e6c037459ca0cc2",
        "filename": "test/functional/wallet_watchonly.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_watchonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0b916971e5bc23ad6396831940a2899ca05402/test/functional/wallet_watchonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_watchonly.py?ref=fa0b916971e5bc23ad6396831940a2899ca05402",
        "patch": "@@ -37,11 +37,11 @@ def run_test(self):\n         wo_wallet.importpubkey(pubkey=def_wallet.getaddressinfo(wo_change)['pubkey'])\n \n         # generate some btc for testing\n-        node.generatetoaddress(COINBASE_MATURITY + 1, a1)\n+        self.generatetoaddress(node, COINBASE_MATURITY + 1, a1)\n \n         # send 1 btc to our watch-only address\n         txid = def_wallet.sendtoaddress(wo_addr, 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # getbalance\n         self.log.info('include_watchonly should default to true for watch-only wallets')"
      }
    ]
  }
]