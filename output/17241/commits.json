[
  {
    "sha": "de1bffae72fb60d992c7ddc19c33768bcc562a79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTFiZmZhZTcyZmI2MGQ5OTJjN2RkYzE5YzMzNzY4YmNjNTYyYTc5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T15:35:42Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T15:35:42Z"
      },
      "message": "[validation] Add CValidationState subclasses\n\nSplit CValidationState into TxValidationState and BlockValidationState\nto store validation results for transactions and blocks respectively.",
      "tree": {
        "sha": "70014fc863e23e263f29ce13a73933200b547b73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70014fc863e23e263f29ce13a73933200b547b73"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de1bffae72fb60d992c7ddc19c33768bcc562a79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de1bffae72fb60d992c7ddc19c33768bcc562a79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de1bffae72fb60d992c7ddc19c33768bcc562a79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de1bffae72fb60d992c7ddc19c33768bcc562a79/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d53828cb79688d72a18d2cc550dcd1dfe2d3dd85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d53828cb79688d72a18d2cc550dcd1dfe2d3dd85",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d53828cb79688d72a18d2cc550dcd1dfe2d3dd85"
      }
    ],
    "stats": {
      "total": 681,
      "additions": 359,
      "deletions": 322
    },
    "files": [
      {
        "sha": "a3a44e5dbc3286074933422e7bbcba3ad751d9fb",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -38,7 +38,7 @@ static void AssembleBlock(benchmark::State& state)\n         LOCK(::cs_main); // Required for ::AcceptToMemoryPool.\n \n         for (const auto& txr : txs) {\n-            CValidationState state;\n+            TxValidationState state;\n             bool ret{::AcceptToMemoryPool(::mempool, state, txr, nullptr /* pfMissingInputs */, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)};\n             assert(ret);\n         }"
      },
      {
        "sha": "edf43bd4dc022adfccceaa065b60578695c3fa60",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -42,7 +42,7 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n         bool rewound = stream.Rewind(benchmark::data::block413567.size());\n         assert(rewound);\n \n-        CValidationState validationState;\n+        BlockValidationState validationState;\n         bool checked = CheckBlock(block, validationState, chainParams->GetConsensus());\n         assert(checked);\n     }"
      },
      {
        "sha": "a783370b4ea1bf4870c2d5e79ffbcfa6ac885c45",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -54,7 +54,7 @@ static void DuplicateInputs(benchmark::State& state)\n     block.hashMerkleRoot = BlockMerkleRoot(block);\n \n     while (state.KeepRunning()) {\n-        CValidationState cvstate{};\n+        BlockValidationState cvstate{};\n         assert(!CheckBlock(block, cvstate, chainparams.GetConsensus(), false, false));\n         assert(cvstate.GetRejectReason() == \"bad-txns-inputs-duplicate\");\n     }"
      },
      {
        "sha": "bf1329758232c901ac6f826f8fd4b1d18d3727bf",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -197,13 +197,13 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n     if (vtx_missing.size() != tx_missing_offset)\n         return READ_STATUS_INVALID;\n \n-    CValidationState state;\n+    BlockValidationState state;\n     if (!CheckBlock(block, state, Params().GetConsensus())) {\n         // TODO: We really want to just check merkle tree manually here,\n         // but that is expensive, and CheckBlock caches a block's\n         // \"checked-status\" (in the CBlock?). CBlock should be able to\n         // check its own merkle root and cache that check.\n-        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED)\n+        if (state.GetResult() == BlockValidationResult::BLOCK_MUTATED)\n             return READ_STATUS_FAILED; // Possible Short ID collision\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }"
      },
      {
        "sha": "27d9180c74061548fd1e803029cea79f26823232",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -7,28 +7,28 @@\n #include <primitives/transaction.h>\n #include <consensus/validation.h>\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+bool CheckTransaction(const CTransaction& tx, TxValidationState &state, bool fCheckDuplicateInputs)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vin-empty\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-empty\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-oversize\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values (see CVE-2010-5139)\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-negative\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -37,20 +37,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-length\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-prevout-null\");\n+                return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "a151197d8598698ccdc8d00501c20d2284dc1e37",
        "filename": "src/consensus/tx_check.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_check.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_check.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -13,8 +13,8 @@\n  */\n \n class CTransaction;\n-class CValidationState;\n+class TxValidationState;\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+bool CheckTransaction(const CTransaction& tx, TxValidationState& state, bool fCheckDuplicateInputs=true);\n \n #endif // BITCOIN_CONSENSUS_TX_CHECK_H"
      },
      {
        "sha": "47242aae9354e2245843fb27915bd93ad8fa10c2",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -156,11 +156,11 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee)\n+bool Consensus::CheckTxInputs(const CTransaction& tx, TxValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee)\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, \"bad-txns-inputs-missingorspent\",\n+        return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, false, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -172,27 +172,27 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-in-belowout\",\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "b6599f287800ad6d3e29a8c63087f6e28b86f86c",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -13,7 +13,7 @@\n class CBlockIndex;\n class CCoinsViewCache;\n class CTransaction;\n-class CValidationState;\n+class TxValidationState;\n \n /** Transaction validation functions */\n \n@@ -24,7 +24,7 @@ namespace Consensus {\n  * @param[out] txfee Set to the transaction fee if successful.\n  * Preconditions: tx.IsCoinBase() is false.\n  */\n-bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee);\n+bool CheckTxInputs(const CTransaction& tx, TxValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee);\n } // namespace Consensus\n \n /** Auxiliary functions for transaction validation (ideally should not be exposed) */"
      },
      {
        "sha": "a6fb6695da8635b6bd16b60491df3face0f21bea",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 75,
        "deletions": 52,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -12,32 +12,27 @@\n #include <primitives/transaction.h>\n #include <primitives/block.h>\n \n-/** A \"reason\" why something was invalid, suitable for determining whether the\n-  * provider of the object should be banned/ignored/disconnected/etc.\n+/** A \"reason\" why a transaction was invalid, suitable for determining whether the\n+  * provider of the transaction should be banned/ignored/disconnected/etc.\n   */\n-enum class ValidationInvalidReason {\n-    // txn and blocks:\n-    NONE,                    //!< not actually invalid\n-    CONSENSUS,               //!< invalid by consensus rules (excluding any below reasons)\n+enum class TxValidationResult {\n+    TX_RESULT_UNSET,         //!< initial value. Tx has not yet been rejected\n+    TX_CONSENSUS,            //!< invalid by consensus rules\n     /**\n      * Invalid by a change to consensus rules more recent than SegWit.\n      * Currently unused as there are no such consensus rule changes, and any download\n      * sources realistically need to support SegWit in order to provide useful data,\n      * so differentiating between always-invalid and invalid-by-pre-SegWit-soft-fork\n      * is uninteresting.\n      */\n-    RECENT_CONSENSUS_CHANGE,\n-    // Only blocks (or headers):\n-    CACHED_INVALID,          //!< this object was cached as being invalid, but we don't know why\n-    BLOCK_INVALID_HEADER,    //!< invalid proof of work or time too old\n-    BLOCK_MUTATED,           //!< the block's data didn't match the data committed to by the PoW\n-    BLOCK_MISSING_PREV,      //!< We don't have the previous block the checked one is built on\n-    BLOCK_INVALID_PREV,      //!< A block this one builds on is invalid\n-    BLOCK_TIME_FUTURE,          //!< block timestamp was > 2 hours in the future (or our clock is bad)\n-    BLOCK_CHECKPOINT,        //!< the block failed to meet one of our checkpoints\n-    // Only loose txn:\n+    TX_RECENT_CONSENSUS_CHANGE,\n     TX_NOT_STANDARD,          //!< didn't meet our local policy rules\n-    TX_MISSING_INPUTS,        //!< a transaction was missing some of its inputs\n+    /**\n+     * transaction was missing some of its inputs\n+     * TODO: ATMP uses fMissingInputs and a valid ValidationState to indicate missing inputs.\n+     *       Change ATMP to use TX_MISSING_INPUTS.\n+     */\n+    TX_MISSING_INPUTS,\n     TX_PREMATURE_SPEND,       //!< transaction spends a coinbase too early, or violates locktime/sequence locks\n     /**\n      * Transaction might be missing a witness, have a witness prior to SegWit\n@@ -48,64 +43,67 @@ enum class ValidationInvalidReason {\n     /**\n      * Tx already in mempool or conflicts with a tx in the chain\n      * (if it conflicts with another tx in mempool, we use MEMPOOL_POLICY as it failed to reach the RBF threshold)\n-     * TODO: Currently this is only used if the transaction already exists in the mempool or on chain,\n-     * TODO: ATMP's fMissingInputs and a valid CValidationState being used to indicate missing inputs\n+     * Currently this is only used if the transaction already exists in the mempool or on chain.\n      */\n     TX_CONFLICT,\n     TX_MEMPOOL_POLICY,        //!< violated mempool's fee/size/descendant/RBF/etc limits\n };\n \n-inline bool IsTransactionReason(ValidationInvalidReason r)\n-{\n-    return r == ValidationInvalidReason::NONE ||\n-           r == ValidationInvalidReason::CONSENSUS ||\n-           r == ValidationInvalidReason::RECENT_CONSENSUS_CHANGE ||\n-           r == ValidationInvalidReason::TX_NOT_STANDARD ||\n-           r == ValidationInvalidReason::TX_PREMATURE_SPEND ||\n-           r == ValidationInvalidReason::TX_MISSING_INPUTS ||\n-           r == ValidationInvalidReason::TX_WITNESS_MUTATED ||\n-           r == ValidationInvalidReason::TX_CONFLICT ||\n-           r == ValidationInvalidReason::TX_MEMPOOL_POLICY;\n-}\n+/** A \"reason\" why a block was invalid, suitable for determining whether the\n+  * provider of the block should be banned/ignored/disconnected/etc.\n+  * These are much more granular than the rejection codes, which may be more\n+  * useful for some other use-cases.\n+  */\n+enum class BlockValidationResult {\n+    BLOCK_RESULT_UNSET,      //!< initial value. Block has not yet been rejected\n+    BLOCK_CONSENSUS,         //!< invalid by consensus rules (excluding any below reasons)\n+    /**\n+     * Invalid by a change to consensus rules more recent than SegWit.\n+     * Currently unused as there are no such consensus rule changes, and any download\n+     * sources realistically need to support SegWit in order to provide useful data,\n+     * so differentiating between always-invalid and invalid-by-pre-SegWit-soft-fork\n+     * is uninteresting.\n+     */\n+    BLOCK_RECENT_CONSENSUS_CHANGE,\n+    BLOCK_CACHED_INVALID,    //!< this block was cached as being invalid and we didn't store the reason why\n+    BLOCK_INVALID_HEADER,    //!< invalid proof of work or time too old\n+    BLOCK_MUTATED,           //!< the block's data didn't match the data committed to by the PoW\n+    BLOCK_MISSING_PREV,      //!< We don't have the previous block the checked one is built on\n+    BLOCK_INVALID_PREV,      //!< A block this one builds on is invalid\n+    BLOCK_TIME_FUTURE,       //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    BLOCK_CHECKPOINT,        //!< the block failed to meet one of our checkpoints\n+};\n \n-inline bool IsBlockReason(ValidationInvalidReason r)\n-{\n-    return r == ValidationInvalidReason::NONE ||\n-           r == ValidationInvalidReason::CONSENSUS ||\n-           r == ValidationInvalidReason::RECENT_CONSENSUS_CHANGE ||\n-           r == ValidationInvalidReason::CACHED_INVALID ||\n-           r == ValidationInvalidReason::BLOCK_INVALID_HEADER ||\n-           r == ValidationInvalidReason::BLOCK_MUTATED ||\n-           r == ValidationInvalidReason::BLOCK_MISSING_PREV ||\n-           r == ValidationInvalidReason::BLOCK_INVALID_PREV ||\n-           r == ValidationInvalidReason::BLOCK_TIME_FUTURE ||\n-           r == ValidationInvalidReason::BLOCK_CHECKPOINT;\n-}\n \n-/** Capture information about block/transaction validation */\n-class CValidationState {\n+\n+/** Base class for capturing information about block/transaction validation. This is subclassed\n+ *  by TxValidationState and BlockValidationState for validation information on transactions\n+ *  and blocks respectively. */\n+class ValidationState {\n private:\n     enum mode_state {\n         MODE_VALID,   //!< everything ok\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n     } mode;\n-    ValidationInvalidReason m_reason;\n     std::string strRejectReason;\n     std::string strDebugMessage;\n-public:\n-    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE) {}\n-    bool Invalid(ValidationInvalidReason reasonIn, bool ret = false,\n+protected:\n+    bool Invalid(bool ret = false,\n             const std::string &strRejectReasonIn=\"\",\n             const std::string &strDebugMessageIn=\"\") {\n-        m_reason = reasonIn;\n         strRejectReason = strRejectReasonIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n             return ret;\n         mode = MODE_INVALID;\n         return ret;\n     }\n+public:\n+    // We use ValidationState polymorphically. Have a virtual destructor\n+    virtual ~ValidationState() {}\n+\n+    ValidationState() : mode(MODE_VALID) {}\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n@@ -121,11 +119,36 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    ValidationInvalidReason GetReason() const { return m_reason; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }\n };\n \n+class TxValidationState : public ValidationState {\n+private:\n+    TxValidationResult m_result;\n+public:\n+    bool Invalid(TxValidationResult result, bool ret = false,\n+                 const std::string &_strRejectReason=\"\",\n+                 const std::string &_strDebugMessage=\"\") {\n+        m_result = result;\n+        return ValidationState::Invalid(ret, _strRejectReason, _strDebugMessage);\n+    }\n+    TxValidationResult GetResult() const { return m_result; }\n+};\n+\n+class BlockValidationState : public ValidationState {\n+private:\n+    BlockValidationResult m_result;\n+public:\n+    bool Invalid(BlockValidationResult result, bool ret = false,\n+                 const std::string &_strRejectReason=\"\",\n+                 const std::string &_strDebugMessage=\"\") {\n+        m_result = result;\n+        return ValidationState::Invalid(ret, _strRejectReason, _strDebugMessage);\n+    }\n+    BlockValidationResult GetResult() const { return m_result; }\n+};\n+\n // These implement the weight = (stripped_size * 4) + witness_size formula,\n // using only serialization with and without witness data. As witness_size\n // is equal to total_size - stripped_size, this formula is identical to:"
      },
      {
        "sha": "01faf8f6c0f9c2b1ac51c8a3ce3cce7cb4d77c34",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -712,7 +712,7 @@ static void ThreadImport(std::vector<fs::path> vImportFiles)\n     }\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n-    CValidationState state;\n+    BlockValidationState state;\n     if (!ActivateBestChain(state, chainparams)) {\n         LogPrintf(\"Failed to connect best block (%s)\\n\", FormatStateMessage(state));\n         StartShutdown();"
      },
      {
        "sha": "d54a14022c7d6c5e59020f9507fb39ae617bc6f9",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -18,7 +18,6 @@ class CBlock;\n class CFeeRate;\n class CRPCCommand;\n class CScheduler;\n-class CValidationState;\n class Coin;\n class uint256;\n enum class RBFTransactionState;"
      },
      {
        "sha": "1c9174ee0725b01eb63c6b5eb3741ca8821c6e09",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -162,7 +162,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblock->nNonce         = 0;\n     pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\n \n-    CValidationState state;\n+    BlockValidationState state;\n     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n     }"
      },
      {
        "sha": "3fa71121ed09245905a048eafe7c8062d1e7ef70",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 43,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -980,38 +980,34 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n  * banning/disconnecting us. We use this to determine which unaccepted\n  * transactions from a whitelisted peer that we can safely relay.\n  */\n-static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n-{\n-    assert(IsTransactionReason(state.GetReason()));\n-    return state.GetReason() == ValidationInvalidReason::CONSENSUS;\n+static bool TxRelayMayResultInDisconnect(const TxValidationState& state) {\n+    return state.GetResult() == TxValidationResult::TX_CONSENSUS;\n }\n \n /**\n- * Potentially ban a node based on the contents of a CValidationState object\n+ * Potentially ban a node based on the contents of a BlockValidationState object\n  *\n  * @param[in] via_compact_block: this bool is passed in because net_processing should\n  * punish peers differently depending on whether the data was provided in a compact\n  * block message or not. If the compact block had a valid header, but contained invalid\n  * txs, the peer should not be punished. See BIP 152.\n  *\n  * @return Returns true if the peer was punished (probably disconnected)\n- *\n- * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n  */\n-static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n-    switch (state.GetReason()) {\n-    case ValidationInvalidReason::NONE:\n+static bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+    switch (state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n         break;\n     // The node is providing invalid data:\n-    case ValidationInvalidReason::CONSENSUS:\n-    case ValidationInvalidReason::BLOCK_MUTATED:\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+    case BlockValidationResult::BLOCK_MUTATED:\n         if (!via_compact_block) {\n             LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n             return true;\n         }\n         break;\n-    case ValidationInvalidReason::CACHED_INVALID:\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n         {\n             LOCK(cs_main);\n             CNodeState *node_state = State(nodeid);\n@@ -1027,30 +1023,24 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n             }\n             break;\n         }\n-    case ValidationInvalidReason::BLOCK_INVALID_HEADER:\n-    case ValidationInvalidReason::BLOCK_CHECKPOINT:\n-    case ValidationInvalidReason::BLOCK_INVALID_PREV:\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+    case BlockValidationResult::BLOCK_CHECKPOINT:\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n         {\n             LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n         }\n         return true;\n     // Conflicting (but not necessarily invalid) data or different policy:\n-    case ValidationInvalidReason::BLOCK_MISSING_PREV:\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n         {\n             // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n             LOCK(cs_main);\n             Misbehaving(nodeid, 10, message);\n         }\n         return true;\n-    case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n-    case ValidationInvalidReason::BLOCK_TIME_FUTURE:\n-    case ValidationInvalidReason::TX_NOT_STANDARD:\n-    case ValidationInvalidReason::TX_MISSING_INPUTS:\n-    case ValidationInvalidReason::TX_PREMATURE_SPEND:\n-    case ValidationInvalidReason::TX_WITNESS_MUTATED:\n-    case ValidationInvalidReason::TX_CONFLICT:\n-    case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n+    case BlockValidationResult::BLOCK_RECENT_CONSENSUS_CHANGE:\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n         break;\n     }\n     if (message != \"\") {\n@@ -1059,6 +1049,39 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n     return false;\n }\n \n+/**\n+ * Potentially ban a node based on the contents of a TxValidationState object\n+ *\n+ * @return Returns true if the peer was punished (probably disconnected)\n+ *\n+ * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n+ */\n+static bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message = \"\") {\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+        break;\n+    // The node is providing invalid data:\n+    case TxValidationResult::TX_CONSENSUS:\n+        {\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 100, message);\n+            return true;\n+        }\n+    // Conflicting (but not necessarily invalid) data or different policy:\n+    case TxValidationResult::TX_RECENT_CONSENSUS_CHANGE:\n+    case TxValidationResult::TX_NOT_STANDARD:\n+    case TxValidationResult::TX_MISSING_INPUTS:\n+    case TxValidationResult::TX_PREMATURE_SPEND:\n+    case TxValidationResult::TX_WITNESS_MUTATED:\n+    case TxValidationResult::TX_CONFLICT:\n+    case TxValidationResult::TX_MEMPOOL_POLICY:\n+        break;\n+    }\n+    if (message != \"\") {\n+        LogPrint(BCLog::NET, \"peer=%d: %s\\n\", nodeid, message);\n+    }\n+    return false;\n+}\n \n \n \n@@ -1227,7 +1250,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n  * Handle invalid block rejection and consequent peer banning, maintain which\n  * peers announce compact blocks.\n  */\n-void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n+void PeerLogicValidation::BlockChecked(const CBlock& block, const BlockValidationState& state) {\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1238,7 +1261,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     if (state.IsInvalid() &&\n         it != mapBlockSource.end() &&\n         State(it->second.first)) {\n-            MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n+            MaybePunishNodeForBlock(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n     }\n     // Check that:\n     // 1. The block is valid\n@@ -1376,7 +1399,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n         }\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n-        CValidationState state;\n+        BlockValidationState state;\n         if (!ActivateBestChain(state, Params(), a_recent_block)) {\n             LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));\n         }\n@@ -1664,11 +1687,11 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         }\n     }\n \n-    CValidationState state;\n+    BlockValidationState state;\n     CBlockHeader first_invalid_header;\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         if (state.IsInvalid()) {\n-            MaybePunishNode(pfrom->GetId(), state, via_compact_block, \"invalid header received\");\n+            MaybePunishNodeForBlock(pfrom->GetId(), state, via_compact_block, \"invalid header received\");\n             return false;\n         }\n     }\n@@ -1805,10 +1828,10 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n         const CTransaction& orphanTx = *porphanTx;\n         NodeId fromPeer = orphan_it->second.fromPeer;\n         bool fMissingInputs2 = false;\n-        // Use a new CValidationState because orphans come from different peers (and we call\n-        // MaybePunishNode based on the source peer from the orphan map, not based on the peer\n+        // Use a new TxValidationState because orphans come from different peers (and we call\n+        // MaybePunishNodeForTx based on the source peer from the orphan map, not based on the peer\n         // that relayed the previous transaction).\n-        CValidationState orphan_state;\n+        TxValidationState orphan_state;\n \n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &fMissingInputs2, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n@@ -1827,16 +1850,15 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n         } else if (!fMissingInputs2) {\n             if (orphan_state.IsInvalid()) {\n                 // Punish peer that gave us an invalid orphan tx\n-                if (MaybePunishNode(fromPeer, orphan_state, /*via_compact_block*/ false)) {\n+                if (MaybePunishNodeForTx(fromPeer, orphan_state)) {\n                     setMisbehaving.insert(fromPeer);\n                 }\n                 LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n             }\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee\n             LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-            assert(IsTransactionReason(orphan_state.GetReason()));\n-            if (!orphanTx.HasWitness() && orphan_state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n+            if (!orphanTx.HasWitness() && orphan_state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n@@ -2281,7 +2303,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_most_recent_block);\n                 a_recent_block = most_recent_block;\n             }\n-            CValidationState state;\n+            BlockValidationState state;\n             if (!ActivateBestChain(state, Params(), a_recent_block)) {\n                 LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));\n             }\n@@ -2462,7 +2484,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK2(cs_main, g_cs_orphans);\n \n         bool fMissingInputs = false;\n-        CValidationState state;\n+        TxValidationState state;\n \n         CNodeState* nodestate = State(pfrom->GetId());\n         nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n@@ -2527,8 +2549,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 recentRejects->insert(tx.GetHash());\n             }\n         } else {\n-            assert(IsTransactionReason(state.GetReason()));\n-            if (!tx.HasWitness() && state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n+            if (!tx.HasWitness() && state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n@@ -2583,7 +2604,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n-            MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false);\n+            MaybePunishNodeForTx(pfrom->GetId(), state);\n         }\n         return true;\n     }\n@@ -2617,10 +2638,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         const CBlockIndex *pindex = nullptr;\n-        CValidationState state;\n+        BlockValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             if (state.IsInvalid()) {\n-                MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n+                MaybePunishNodeForBlock(pfrom->GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n                 return true;\n             }\n         }"
      },
      {
        "sha": "4adb7d3a2151a33257d8660d27671a14b11941a7",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -40,7 +40,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     /**\n      * Overridden from CValidationInterface.\n      */\n-    void BlockChecked(const CBlock& block, const CValidationState& state) override;\n+    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n     /**\n      * Overridden from CValidationInterface.\n      */"
      },
      {
        "sha": "4645baa3d7a9a4c34e80ee0852ed457097373a7b",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -36,7 +36,7 @@ TransactionError BroadcastTransaction(const CTransactionRef tx, std::string& err\n     }\n     if (!mempool.exists(hashTx)) {\n         // Transaction is not already in the mempool. Submit it.\n-        CValidationState state;\n+        TxValidationState state;\n         bool fMissingInputs;\n         if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n                 nullptr /* plTxnReplaced */, false /* bypass_limits */, max_tx_fee)) {"
      },
      {
        "sha": "c4ce561fe3baedcec39ae212028abf8ca9690d1b",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -1470,7 +1470,7 @@ static UniValue preciousblock(const JSONRPCRequest& request)\n         }\n     }\n \n-    CValidationState state;\n+    BlockValidationState state;\n     PreciousBlock(state, Params(), pblockindex);\n \n     if (!state.IsValid()) {\n@@ -1495,7 +1495,7 @@ static UniValue invalidateblock(const JSONRPCRequest& request)\n             }.Check(request);\n \n     uint256 hash(ParseHashV(request.params[0], \"blockhash\"));\n-    CValidationState state;\n+    BlockValidationState state;\n \n     CBlockIndex* pblockindex;\n     {\n@@ -1545,7 +1545,7 @@ static UniValue reconsiderblock(const JSONRPCRequest& request)\n         ResetBlockFailureFlags(pblockindex);\n     }\n \n-    CValidationState state;\n+    BlockValidationState state;\n     ActivateBestChain(state, Params());\n \n     if (!state.IsValid()) {"
      },
      {
        "sha": "f294c815f65390792e8f93ea8d7074aadebffc08",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -252,7 +252,7 @@ static UniValue prioritisetransaction(const JSONRPCRequest& request)\n \n \n // NOTE: Assumes a conclusive result; if result is inconclusive, it must be handled by caller\n-static UniValue BIP22ValidationResult(const CValidationState& state)\n+static UniValue BIP22ValidationResult(const BlockValidationState& state)\n {\n     if (state.IsValid())\n         return NullUniValue;\n@@ -401,7 +401,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n             // TestBlockValidity only supports blocks built on the current Tip\n             if (block.hashPrevBlock != pindexPrev->GetBlockHash())\n                 return \"inconclusive-not-best-prevblk\";\n-            CValidationState state;\n+            BlockValidationState state;\n             TestBlockValidity(state, Params(), block, pindexPrev, false, true);\n             return BIP22ValidationResult(state);\n         }\n@@ -668,12 +668,12 @@ class submitblock_StateCatcher : public CValidationInterface\n public:\n     uint256 hash;\n     bool found;\n-    CValidationState state;\n+    BlockValidationState state;\n \n     explicit submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {}\n \n protected:\n-    void BlockChecked(const CBlock& block, const CValidationState& stateIn) override {\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override {\n         if (block.GetHash() != hash)\n             return;\n         found = true;\n@@ -772,7 +772,7 @@ static UniValue submitheader(const JSONRPCRequest& request)\n         }\n     }\n \n-    CValidationState state;\n+    BlockValidationState state;\n     ProcessNewBlockHeaders({h}, state, Params(), /* ppindex */ nullptr, /* first_invalid */ nullptr);\n     if (state.IsValid()) return NullUniValue;\n     if (state.IsError()) {"
      },
      {
        "sha": "68024fbe2f566d71f0496de619a27c202f47cb7d",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -893,7 +893,7 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     UniValue result_0(UniValue::VOBJ);\n     result_0.pushKV(\"txid\", tx_hash.GetHex());\n \n-    CValidationState state;\n+    TxValidationState state;\n     bool missing_inputs;\n     bool test_accept_res;\n     {"
      },
      {
        "sha": "2e40ed0dde5a0503e5d10e039bc3fe82b711176a",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -102,7 +102,7 @@ static bool BuildChain(const CBlockIndex* pindex, const CScript& coinbase_script\n         block = std::make_shared<CBlock>(CreateBlock(pindex, no_txns, coinbase_script_pub_key));\n         CBlockHeader header = block->GetBlockHeader();\n \n-        CValidationState state;\n+        BlockValidationState state;\n         if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex, nullptr)) {\n             return false;\n         }"
      },
      {
        "sha": "d83668460ff97cb101002573cb7d22c974bfdc17",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -95,7 +95,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         throw std::runtime_error(\"LoadGenesisBlock failed.\");\n     }\n \n-    CValidationState state;\n+    BlockValidationState state;\n     if (!ActivateBestChain(state, chainparams)) {\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n     }"
      },
      {
        "sha": "b18f9df72d27895fdf4ab074ab28440ce8b3b0d7",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -193,7 +193,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           CDataStream stream(ParseHex(raw_tx), SER_NETWORK, PROTOCOL_VERSION);\n           stream >> tx;\n \n-          CValidationState state;\n+          TxValidationState state;\n           BOOST_CHECK_MESSAGE(CheckTransaction(*tx, state), strTest);\n           BOOST_CHECK(state.IsValid());\n "
      },
      {
        "sha": "dac46879e87394da7c10cf6f577716c3a45c3f5b",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -152,7 +152,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n             CTransaction tx(deserialize, stream);\n \n-            CValidationState state;\n+            TxValidationState state;\n             BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n             BOOST_CHECK(state.IsValid());\n \n@@ -239,7 +239,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION );\n             CTransaction tx(deserialize, stream);\n \n-            CValidationState state;\n+            TxValidationState state;\n             fValid = CheckTransaction(tx, state) && state.IsValid();\n \n             PrecomputedTransactionData txdata(tx);\n@@ -274,7 +274,7 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n     CMutableTransaction tx;\n     stream >> tx;\n-    CValidationState state;\n+    TxValidationState state;\n     BOOST_CHECK_MESSAGE(CheckTransaction(CTransaction(tx), state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n \n     // Check that duplicate txins fail"
      },
      {
        "sha": "1f781ca83aa2fbf0d35d6956fa720587239b0285",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -30,7 +30,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n \n     BOOST_CHECK(CTransaction(coinbaseTx).IsCoinBase());\n \n-    CValidationState state;\n+    TxValidationState state;\n \n     LOCK(cs_main);\n \n@@ -50,7 +50,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     // Check that the validation state reflects the unsuccessful attempt.\n     BOOST_CHECK(state.IsInvalid());\n     BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n-    BOOST_CHECK(state.GetReason() == ValidationInvalidReason::CONSENSUS);\n+    BOOST_CHECK(state.GetResult() == TxValidationResult::TX_CONSENSUS);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ea2ef5546fd59641f39d400dc8b50cf9e7b91459",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -13,7 +13,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n \n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n@@ -22,7 +22,7 @@ ToMemPool(const CMutableTransaction& tx)\n {\n     LOCK(cs_main);\n \n-    CValidationState state;\n+    TxValidationState state;\n     return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), nullptr /* pfMissingInputs */,\n                               nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\n }\n@@ -114,7 +114,7 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n     // If we add many more flags, this loop can get too expensive, but we can\n     // rewrite in the future to randomly pick a set of flags to evaluate.\n     for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n-        CValidationState state;\n+        TxValidationState state;\n         // Filter out incompatible flag choices\n         if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n             // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\n@@ -201,7 +201,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     {\n         LOCK(cs_main);\n \n-        CValidationState state;\n+        TxValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n         BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n@@ -270,7 +270,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Make it valid, and check again\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n-        CValidationState state;\n+        TxValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n         BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n@@ -298,7 +298,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Make it valid, and check again\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n-        CValidationState state;\n+        TxValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n         BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n@@ -359,7 +359,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // Invalidate vin[1]\n         tx.vin[1].scriptWitness.SetNull();\n \n-        CValidationState state;\n+        TxValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n         BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));"
      },
      {
        "sha": "cc1406c062a70d90bafc6f53b741c2f06e984c12",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -151,7 +151,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     }\n \n     bool ignored;\n-    CValidationState state;\n+    BlockValidationState state;\n     std::vector<CBlockHeader> headers;\n     std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n \n@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n         // Add the txs to the tx pool\n         {\n             LOCK(cs_main);\n-            CValidationState state;\n+            TxValidationState state;\n             std::list<CTransactionRef> plTxnReplaced;\n             for (const auto& tx : txs) {\n                 BOOST_REQUIRE(AcceptToMemoryPool("
      },
      {
        "sha": "64d270f4c620312727a13b543fc2cd06786a5448",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -591,9 +591,9 @@ void CTxMemPool::clear()\n \n static void CheckInputsAndUpdateCoins(const CTransaction& tx, CCoinsViewCache& mempoolDuplicate, const int64_t spendheight)\n {\n-    CValidationState state;\n+    TxValidationState dummy_state; // Not used. CheckTxInputs() should always pass\n     CAmount txfee = 0;\n-    bool fCheckResult = tx.IsCoinBase() || Consensus::CheckTxInputs(tx, state, mempoolDuplicate, spendheight, txfee);\n+    bool fCheckResult = tx.IsCoinBase() || Consensus::CheckTxInputs(tx, dummy_state, mempoolDuplicate, spendheight, txfee);\n     assert(fCheckResult);\n     UpdateCoins(tx, mempoolDuplicate, std::numeric_limits<int>::max());\n }"
      },
      {
        "sha": "bd52f577516957e2d0b5455314db48bc127c8d0b",
        "filename": "src/util/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/util/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/util/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/validation.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -8,8 +8,8 @@\n #include <consensus/validation.h>\n #include <tinyformat.h>\n \n-/** Convert CValidationState to a human-readable message for logging */\n-std::string FormatStateMessage(const CValidationState &state)\n+/** Convert ValidationState to a human-readable message for logging */\n+std::string FormatStateMessage(const ValidationState &state)\n {\n     return strprintf(\"%s%s\",\n         state.GetRejectReason(),"
      },
      {
        "sha": "da2cf9f102eaebc8a3f40f03d81fab1dfcccb219",
        "filename": "src/util/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/util/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/util/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/validation.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -8,10 +8,10 @@\n \n #include <string>\n \n-class CValidationState;\n+class ValidationState;\n \n-/** Convert CValidationState to a human-readable message for logging */\n-std::string FormatStateMessage(const CValidationState &state);\n+/** Convert ValidationState to a human-readable message for logging */\n+std::string FormatStateMessage(const ValidationState &state);\n \n extern const std::string strMessageMagic;\n "
      },
      {
        "sha": "607ac842e468bafb54b144d3c17cee849d1b928c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 139,
        "changes": 271,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -181,7 +181,7 @@ std::unique_ptr<CBlockTreeDB> pblocktree;\n // See definition for documentation\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n+bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n@@ -363,7 +363,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n     auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n     while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n         // ignore validation errors in resurrected transactions\n-        CValidationState stateDummy;\n+        TxValidationState stateDummy;\n         if (!fAddToMempool || (*it)->IsCoinBase() ||\n             !AcceptToMemoryPool(mempool, stateDummy, *it, nullptr /* pfMissingInputs */,\n                                 nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */)) {\n@@ -391,7 +391,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n \n // Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n // were somehow broken and returning the wrong scriptPubKeys\n-static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& view, const CTxMemPool& pool,\n+static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationState& state, const CCoinsViewCache& view, const CTxMemPool& pool,\n                  unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     AssertLockHeld(cs_main);\n \n@@ -440,7 +440,7 @@ class MemPoolAccept\n     // around easier.\n     struct ATMPArgs {\n         const CChainParams& m_chainparams;\n-        CValidationState &m_state;\n+        TxValidationState &m_state;\n         bool* m_missing_inputs;\n         const int64_t m_accept_time;\n         std::list<CTransactionRef>* m_replaced_transactions;\n@@ -501,15 +501,15 @@ class MemPoolAccept\n     bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Compare a package's feerate against minimum allowed.\n-    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, TxValidationState& state)\n     {\n         CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n         if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n         }\n \n         if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n         }\n         return true;\n     }\n@@ -536,7 +536,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     const uint256& hash = ws.m_hash;\n \n     // Copy/alias what we need out of args\n-    CValidationState &state = args.m_state;\n+    TxValidationState &state = args.m_state;\n     bool* pfMissingInputs = args.m_missing_inputs;\n     const int64_t nAcceptTime = args.m_accept_time;\n     const bool bypass_limits = args.m_bypass_limits;\n@@ -562,29 +562,29 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"coinbase\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"coinbase\");\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason))\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, reason);\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to mitigate CVE-2017-12842 by not relaying\n     // 64-byte transactions.\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"tx-size-small\");\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"non-final\");\n+        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"non-final\");\n \n     // is it already in the memory pool?\n     if (m_pool.exists(hash)) {\n-        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, \"txn-already-in-mempool\");\n+        return state.Invalid(TxValidationResult::TX_CONFLICT, false, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -616,7 +616,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"txn-mempool-conflict\");\n+                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -642,7 +642,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             for (size_t out = 0; out < tx.vout.size(); out++) {\n                 // Optimistically just do efficient check of cache for outputs\n                 if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, \"txn-already-known\");\n+                    return state.Invalid(TxValidationResult::TX_CONFLICT, false, \"txn-already-known\");\n                 }\n             }\n             // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -667,7 +667,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n     // CoinsViewCache instead of create its own\n     if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"non-BIP68-final\");\n+        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"non-BIP68-final\");\n \n     CAmount nFees = 0;\n     if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n@@ -676,11 +676,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Check for non-standard pay-to-script-hash in inputs\n     if (fRequireStandard && !AreInputsStandard(tx, m_view))\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"bad-txns-nonstandard-inputs\");\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"bad-txns-nonstandard-inputs\");\n \n     // Check for non-standard witness in P2WSH\n     if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n-        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, \"bad-witness-nonstandard\");\n+        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, false, \"bad-witness-nonstandard\");\n \n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -704,15 +704,15 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     unsigned int nSize = entry->GetTxSize();\n \n     if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"bad-txns-too-many-sigops\",\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n     // No transactions are allowed below minRelayTxFee except from disconnected\n     // blocks\n     if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n     if (nAbsurdFee && nFees > nAbsurdFee)\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false,\n                 \"absurdly-high-fee\", strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n     const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n@@ -770,7 +770,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n         if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n                 !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"too-long-mempool-chain\", errString);\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"too-long-mempool-chain\", errString);\n         }\n     }\n \n@@ -783,7 +783,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n         if (setConflicts.count(hashAncestor))\n         {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-spends-conflicting-tx\",\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-spends-conflicting-tx\",\n                     strprintf(\"%s spends conflicting transaction %s\",\n                         hash.ToString(),\n                         hashAncestor.ToString()));\n@@ -823,7 +823,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n             if (newFeeRate <= oldFeeRate)\n             {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n                             newFeeRate.ToString(),\n@@ -851,7 +851,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 nConflictingSize += it->GetTxSize();\n             }\n         } else {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"too many potential replacements\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"too many potential replacements\",\n                     strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                         hash.ToString(),\n                         nConflictingCount,\n@@ -875,7 +875,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 // it's cheaper to just check if the new input refers to a\n                 // tx that's in the mempool.\n                 if (m_pool.exists(tx.vin[j].prevout.hash)) {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"replacement-adds-unconfirmed\",\n+                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"replacement-adds-unconfirmed\",\n                             strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                 hash.ToString(), j));\n                 }\n@@ -887,7 +887,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // transactions would not be paid for.\n         if (nModifiedFees < nConflictingFees)\n         {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                         hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n         }\n@@ -897,7 +897,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n         if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n         {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                         hash.ToString(),\n                         FormatMoney(nDeltaFees),\n@@ -911,7 +911,7 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n {\n     const CTransaction& tx = *ws.m_ptx;\n \n-    CValidationState &state = args.m_state;\n+    TxValidationState &state = args.m_state;\n \n     constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n@@ -921,14 +921,13 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n         // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n         // need to turn both off, and compare against just turning off CLEANSTACK\n         // to see if the failure is specifically due to witness validation.\n-        CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-        if (!tx.HasWitness() && CheckInputs(tx, stateDummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputs(tx, stateDummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+        TxValidationState state_dummy; // Want reported failures to be from first CheckInputs\n+        if (!tx.HasWitness() && CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n-            state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+            state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, false,\n                     state.GetRejectReason(), state.GetDebugMessage());\n         }\n-        assert(IsTransactionReason(state.GetReason()));\n         return false; // state filled in by CheckInputs\n     }\n \n@@ -940,7 +939,7 @@ bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, Precomp\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n \n-    CValidationState &state = args.m_state;\n+    TxValidationState &state = args.m_state;\n     const CChainParams& chainparams = args.m_chainparams;\n \n     // Check again against the current block tip's script verification\n@@ -971,7 +970,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n-    CValidationState &state = args.m_state;\n+    TxValidationState &state = args.m_state;\n     const bool bypass_limits = args.m_bypass_limits;\n \n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n@@ -1009,7 +1008,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     if (!bypass_limits) {\n         LimitMempoolSize(m_pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, std::chrono::hours{gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)});\n         if (!m_pool.exists(hash))\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"mempool full\");\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"mempool full\");\n     }\n     return true;\n }\n@@ -1046,7 +1045,7 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n } // anon namespace\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n-static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -1063,12 +1062,12 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n             ::ChainstateActive().CoinsTip().Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n-    CValidationState stateDummy;\n-    ::ChainstateActive().FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n+    BlockValidationState state_dummy;\n+    ::ChainstateActive().FlushStateToDisk(chainparams, state_dummy, FlushStateMode::PERIODIC);\n     return res;\n }\n \n-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)\n {\n@@ -1418,8 +1417,8 @@ void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(c\n     CheckForkWarningConditions();\n }\n \n-void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n-    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n+void CChainState::InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) {\n+    if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         m_blockman.m_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n@@ -1492,7 +1491,7 @@ void InitScriptExecutionCache() {\n  *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (tx.IsCoinBase()) return true;\n \n@@ -1544,18 +1543,18 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 CScriptCheck check2(coin.out, tx, i,\n                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                 if (check2())\n-                    return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n             }\n             // MANDATORY flag failures correspond to\n-            // ValidationInvalidReason::CONSENSUS. Because CONSENSUS\n+            // TxValidationResult::TX_CONSENSUS. Because CONSENSUS\n             // failures are the most serious case of validation\n             // failures, we may need to consider using\n             // RECENT_CONSENSUS_CHANGE for any script failure that\n             // could be due to non-upgraded nodes which we may want to\n             // support, to avoid splitting the network (but this\n             // depends on the details of how net_processing handles\n             // such errors).\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n         }\n     }\n \n@@ -1640,7 +1639,7 @@ static bool AbortNode(const std::string& strMessage, const std::string& userMess\n     return false;\n }\n \n-static bool AbortNode(CValidationState& state, const std::string& strMessage, const std::string& userMessage = \"\", unsigned int prefix = 0)\n+static bool AbortNode(BlockValidationState& state, const std::string& strMessage, const std::string& userMessage = \"\", unsigned int prefix = 0)\n {\n     AbortNode(strMessage, userMessage, prefix);\n     return state.Error(strMessage);\n@@ -1754,9 +1753,9 @@ void static FlushBlockFile(bool fFinalize = false)\n     }\n }\n \n-static bool FindUndoPos(CValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize);\n+static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize);\n \n-static bool WriteUndoDataForBlock(const CBlockUndo& blockundo, CValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n+static bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n {\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull()) {\n@@ -1895,7 +1894,7 @@ static int64_t nBlocksTotal = 0;\n /** Apply the effects of this block (with given index) on the UTXO set represented by coins.\n  *  Validity checks that depend on the UTXO set are also done; ConnectBlock()\n  *  can fail if those validity checks fail (among other reasons). */\n-bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n+bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n {\n     AssertLockHeld(cs_main);\n@@ -1917,7 +1916,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     // re-enforce that rule here (at least until we make it impossible for\n     // GetAdjustedTime() to go backward).\n     if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck)) {\n-        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED) {\n+        if (state.GetResult() == BlockValidationResult::BLOCK_MUTATED) {\n             // We don't write down blocks to disk if they may have been\n             // corrupted, so this should be impossible unless we're having hardware\n             // problems.\n@@ -2057,7 +2056,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      \"bad-txns-BIP30\");\n                 }\n             }\n@@ -2096,20 +2095,16 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         if (!tx.IsCoinBase())\n         {\n             CAmount txfee = 0;\n-            if (!Consensus::CheckTxInputs(tx, state, view, pindex->nHeight, txfee)) {\n-                if (!IsBlockReason(state.GetReason())) {\n-                    // CheckTxInputs may return MISSING_INPUTS or\n-                    // PREMATURE_SPEND but we can't return that, as it's not\n-                    // defined for a block, so we reset the reason flag to\n-                    // CONSENSUS here.\n-                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n-                            state.GetRejectReason(), state.GetDebugMessage());\n-                }\n+            TxValidationState tx_state;\n+            if (!Consensus::CheckTxInputs(tx, tx_state, view, pindex->nHeight, txfee)) {\n+                // Any transaction validation failure in ConnectBlock is a block consensus failure\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false,\n+                            tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n                                  \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n@@ -2122,7 +2117,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  \"bad-txns-nonfinal\");\n             }\n         }\n@@ -2133,25 +2128,19 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (fScriptChecks && !CheckInputs(tx, state, view, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n-                if (state.GetReason() == ValidationInvalidReason::TX_NOT_STANDARD) {\n-                    // CheckInputs may return NOT_STANDARD for extra flags we passed,\n-                    // but we can't return that, as it's not defined for a block, so\n-                    // we reset the reason flag to CONSENSUS here.\n-                    // In the event of a future soft-fork, we may need to\n-                    // consider whether rewriting to CONSENSUS or\n-                    // RECENT_CONSENSUS_CHANGE would be more appropriate.\n-                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectReason(), state.GetDebugMessage());\n-                }\n+            TxValidationState tx_state;\n+            if (fScriptChecks && !CheckInputs(tx, tx_state, view, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n+                // Any transaction validation failure in ConnectBlock is a block consensus failure\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false,\n+                              tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n@@ -2169,13 +2158,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS,\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n                                \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), \"block-validation-failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: CheckQueue failed\", __func__), \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -2205,7 +2194,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n bool CChainState::FlushStateToDisk(\n     const CChainParams& chainparams,\n-    CValidationState &state,\n+    BlockValidationState &state,\n     FlushStateMode mode,\n     int nManualPruneHeight)\n {\n@@ -2316,15 +2305,15 @@ bool CChainState::FlushStateToDisk(\n }\n \n void CChainState::ForceFlushStateToDisk() {\n-    CValidationState state;\n+    BlockValidationState state;\n     const CChainParams& chainparams = Params();\n     if (!this->FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, FormatStateMessage(state));\n     }\n }\n \n void CChainState::PruneAndFlush() {\n-    CValidationState state;\n+    BlockValidationState state;\n     fCheckForPruning = true;\n     const CChainParams& chainparams = Params();\n \n@@ -2410,7 +2399,7 @@ void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainPar\n   * disconnectpool (note that the caller is responsible for mempool consistency\n   * in any case).\n   */\n-bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n+bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n     CBlockIndex *pindexDelete = m_chain.Tip();\n     assert(pindexDelete);\n@@ -2530,7 +2519,7 @@ class ConnectTrace {\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n-bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n+bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n     assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n@@ -2662,7 +2651,7 @@ void CChainState::PruneBlockIndexCandidates() {\n  *\n  * @returns true unless a system error occurred\n  */\n-bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n+bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n     AssertLockHeld(cs_main);\n \n@@ -2709,10 +2698,10 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n             if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n-                    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n+                    if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n                         InvalidChainFound(vpindexToConnect.front());\n                     }\n-                    state = CValidationState();\n+                    state = BlockValidationState();\n                     fInvalidFound = true;\n                     fContinue = false;\n                     break;\n@@ -2780,7 +2769,7 @@ static void LimitValidationInterfaceQueue() LOCKS_EXCLUDED(cs_main) {\n     }\n }\n \n-bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n+bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n     // Note that while we're often called here from ProcessNewBlock, this is\n     // far from a guarantee. Things in the P2P/RPC will often end up calling\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n@@ -2880,11 +2869,11 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     return true;\n }\n \n-bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n+bool ActivateBestChain(BlockValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n     return ::ChainstateActive().ActivateBestChain(state, chainparams, std::move(pblock));\n }\n \n-bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex)\n+bool CChainState::PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex *pindex)\n {\n     {\n         LOCK(cs_main);\n@@ -2912,11 +2901,11 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n \n     return ActivateBestChain(state, params, std::shared_ptr<const CBlock>());\n }\n-bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex) {\n+bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex *pindex) {\n     return ::ChainstateActive().PreciousBlock(state, params, pindex);\n }\n \n-bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n+bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n {\n     CBlockIndex* to_mark_failed = pindex;\n     bool pindex_was_in_chain = false;\n@@ -3052,7 +3041,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     return true;\n }\n \n-bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex) {\n+bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex) {\n     return ::ChainstateActive().InvalidateBlock(state, chainparams, pindex);\n }\n \n@@ -3226,7 +3215,7 @@ static bool FindBlockPos(FlatFilePos &pos, unsigned int nAddSize, unsigned int n\n     return true;\n }\n \n-static bool FindUndoPos(CValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize)\n+static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -3248,16 +3237,16 @@ static bool FindUndoPos(CValidationState &state, int nFile, FlatFilePos &pos, un\n     return true;\n }\n \n-static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n+static bool CheckBlockHeader(const CBlockHeader& block, BlockValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"high-hash\", \"proof of work failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n \n-bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n+bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     // These are checks that are independent of context.\n \n@@ -3274,13 +3263,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-txns-duplicate\", \"duplicate transaction\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3291,29 +3280,34 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-length\", \"size limits failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-missing\", \"first tx is not coinbase\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-multiple\", \"more than one coinbase\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     // Must check for duplicate inputs (see CVE-2018-17144)\n-    for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, true))\n-            return state.Invalid(state.GetReason(), false, state.GetRejectReason(),\n-                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n-\n+    for (const auto& tx : block.vtx) {\n+        TxValidationState tx_state;\n+        if (!CheckTransaction(*tx, tx_state, true)) {\n+            // CheckBlock() does context-free validation checks. The only\n+            // possible failures are consensus failures.\n+            assert(tx_state.GetResult() == TxValidationResult::TX_CONSENSUS);\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, tx_state.GetRejectReason(),\n+                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), tx_state.GetDebugMessage()));\n+        }\n+    }\n     unsigned int nSigOps = 0;\n     for (const auto& tx : block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3406,15 +3400,15 @@ static CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOC\n  *  in ConnectBlock().\n  *  Note that -reindex-chainstate skips the validation that happens here!\n  */\n-static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& params, const CBlockIndex* pindexPrev, int64_t nAdjustedTime) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidationState& state, const CChainParams& params, const CBlockIndex* pindexPrev, int64_t nAdjustedTime) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     assert(pindexPrev != nullptr);\n     const int nHeight = pindexPrev->nHeight + 1;\n \n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"bad-diffbits\", \"incorrect proof of work\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3423,23 +3417,23 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // g_blockman.m_block_index.\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(ValidationInvalidReason::BLOCK_TIME_FUTURE, false, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(BlockValidationResult::BLOCK_TIME_FUTURE, false, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3451,7 +3445,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n  *  in ConnectBlock().\n  *  Note that -reindex-chainstate skips the validation that happens here!\n  */\n-static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n+static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n     const int nHeight = pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1;\n \n@@ -3469,7 +3463,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-nonfinal\", \"non-final transaction\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3479,7 +3473,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-height\", \"block height mismatch in coinbase\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3501,11 +3495,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3515,7 +3509,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3527,13 +3521,13 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n }\n \n-bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n@@ -3547,7 +3541,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), \"duplicate\");\n+                return state.Invalid(BlockValidationResult::BLOCK_CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), \"duplicate\");\n             return true;\n         }\n \n@@ -3558,10 +3552,10 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n         if (mi == m_block_index.end())\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), \"prev-blk-not-found\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n+            return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3598,7 +3592,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n+                    return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n                 }\n             }\n         }\n@@ -3613,7 +3607,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n }\n \n // Exposed wrapper for AcceptBlockHeader\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex, CBlockHeader *first_invalid)\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex, CBlockHeader *first_invalid)\n {\n     if (first_invalid != nullptr) first_invalid->SetNull();\n     {\n@@ -3660,7 +3654,7 @@ static FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, const CChai\n }\n \n /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n+bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n {\n     const CBlock& block = *pblock;\n \n@@ -3710,8 +3704,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n-        assert(IsBlockReason(state.GetReason()));\n-        if (state.IsInvalid() && state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n+        if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);\n         }\n@@ -3750,7 +3743,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n     {\n         CBlockIndex *pindex = nullptr;\n         if (fNewBlock) *fNewBlock = false;\n-        CValidationState state;\n+        BlockValidationState state;\n \n         // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n         // Therefore, the following critical section must include the CheckBlock() call as well.\n@@ -3771,14 +3764,14 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n \n     NotifyHeaderTip();\n \n-    CValidationState state; // Only used to report errors, not invalidity - ignore it\n+    BlockValidationState state; // Only used to report errors, not invalidity - ignore it\n     if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n         return error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n     return true;\n }\n \n-bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n+bool TestBlockValidity(BlockValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == ::ChainActive().Tip());\n@@ -3889,7 +3882,7 @@ static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPr\n /* This function is called from the RPC code for pruneblockchain */\n void PruneBlockFilesManual(int nManualPruneHeight)\n {\n-    CValidationState state;\n+    BlockValidationState state;\n     const CChainParams& chainparams = Params();\n     if (!::ChainstateActive().FlushStateToDisk(\n             chainparams, state, FlushStateMode::NONE, nManualPruneHeight)) {\n@@ -4185,7 +4178,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     CBlockIndex* pindex;\n     CBlockIndex* pindexFailure = nullptr;\n     int nGoodTransactions = 0;\n-    CValidationState state;\n+    BlockValidationState state;\n     int reportDone = 0;\n     LogPrintf(\"[0%%]...\"); /* Continued */\n     for (pindex = ::ChainActive().Tip(); pindex && pindex->pprev; pindex = pindex->pprev) {\n@@ -4429,7 +4422,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     }\n     // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n \n-    CValidationState state;\n+    BlockValidationState state;\n     // Loop until the tip is below nHeight, or we reach a pruned block.\n     while (!ShutdownRequested()) {\n         {\n@@ -4497,7 +4490,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n         // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n-        CValidationState state;\n+        BlockValidationState state;\n         if (!::ChainstateActive().FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n             LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", FormatStateMessage(state));\n             return false;\n@@ -4649,7 +4642,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                     // process in case the block isn't known yet\n                     CBlockIndex* pindex = LookupBlockIndex(hash);\n                     if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n-                      CValidationState state;\n+                      BlockValidationState state;\n                       if (::ChainstateActive().AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n                           nLoaded++;\n                       }\n@@ -4663,7 +4656,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n \n                 // Activate the genesis block so normal node progress can continue\n                 if (hash == chainparams.GetConsensus().hashGenesisBlock) {\n-                    CValidationState state;\n+                    BlockValidationState state;\n                     if (!ActivateBestChain(state, chainparams)) {\n                         break;\n                     }\n@@ -4686,7 +4679,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                             LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),\n                                     head.ToString());\n                             LOCK(cs_main);\n-                            CValidationState dummy;\n+                            BlockValidationState dummy;\n                             if (::ChainstateActive().AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n                             {\n                                 nLoaded++;\n@@ -4963,7 +4956,7 @@ bool LoadMempool(CTxMemPool& pool)\n             if (amountdelta) {\n                 pool.PrioritiseTransaction(tx->GetHash(), amountdelta);\n             }\n-            CValidationState state;\n+            TxValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n                 AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nullptr /* pfMissingInputs */, nTime,"
      },
      {
        "sha": "f346e5caace00d4a3c8c1ae7e03b5b56bb18a8f2",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 20,
        "deletions": 19,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -32,6 +32,7 @@\n #include <vector>\n \n class CChainState;\n+class BlockValidationState;\n class CBlockIndex;\n class CBlockTreeDB;\n class CBlockUndo;\n@@ -41,7 +42,7 @@ class CConnman;\n class CScriptCheck;\n class CBlockPolicyEstimator;\n class CTxMemPool;\n-class CValidationState;\n+class TxValidationState;\n struct ChainTxData;\n \n struct DisconnectedBlockTransactions;\n@@ -223,7 +224,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n  * @param[out] first_invalid First header that fails validation, if one exists\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex = nullptr, CBlockHeader* first_invalid = nullptr) LOCKS_EXCLUDED(cs_main);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex = nullptr, CBlockHeader* first_invalid = nullptr) LOCKS_EXCLUDED(cs_main);\n \n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n@@ -248,7 +249,7 @@ bool GetTransaction(const uint256& hash, CTransactionRef& tx, const Consensus::P\n  * May not be called with cs_main held. May not be called in a\n  * validationinterface callback.\n  */\n-bool ActivateBestChain(CValidationState& state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock = std::shared_ptr<const CBlock>());\n+bool ActivateBestChain(BlockValidationState& state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock = std::shared_ptr<const CBlock>());\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n \n /** Guess verification progress (as a fraction between 0.0=genesis and 1.0=current tip). */\n@@ -272,7 +273,7 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n \n /** (try to) add transaction to memory pool\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -368,10 +369,10 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);\n /** Functions for validating blocks and updating the block tree */\n \n /** Context-independent validity checks */\n-bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n+bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n /** Check a block is completely valid from start to finish (only works on top of our current best block) */\n-bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+bool TestBlockValidity(BlockValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Check whether witness commitments are required for a block, and whether to enforce NULLDUMMY (BIP 147) rules.\n  *  Note that transaction witness validation rules are always enforced when P2SH is enforced. */\n@@ -488,7 +489,7 @@ class BlockManager {\n      */\n     bool AcceptBlockHeader(\n         const CBlockHeader& block,\n-        CValidationState& state,\n+        BlockValidationState& state,\n         const CChainParams& chainparams,\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n@@ -652,7 +653,7 @@ class CChainState {\n      */\n     bool FlushStateToDisk(\n         const CChainParams& chainparams,\n-        CValidationState &state,\n+        BlockValidationState &state,\n         FlushStateMode mode,\n         int nManualPruneHeight = 0);\n \n@@ -678,23 +679,23 @@ class CChainState {\n      * @returns true unless a system error occurred\n      */\n     bool ActivateBestChain(\n-        CValidationState& state,\n+        BlockValidationState& state,\n         const CChainParams& chainparams,\n         std::shared_ptr<const CBlock> pblock) LOCKS_EXCLUDED(cs_main);\n \n-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Block (dis)connection on a given view:\n     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view);\n-    bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n+    bool ConnectBlock(const CBlock& block, BlockValidationState& state, CBlockIndex* pindex,\n                       CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Apply the effects of a block disconnection on the UTXO set.\n-    bool DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n \n     // Manual block validity manipulation:\n-    bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n-    bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n     void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Replay blocks that aren't fully applied to the database. */\n@@ -720,10 +721,10 @@ class CChainState {\n     bool LoadChainTip(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n private:\n-    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n-    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n \n-    void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -738,10 +739,10 @@ class CChainState {\n  * May not be called in a\n  * validationinterface callback.\n  */\n-bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex) LOCKS_EXCLUDED(cs_main);\n+bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex *pindex) LOCKS_EXCLUDED(cs_main);\n \n /** Mark a block as invalid. */\n-bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n \n /** Remove invalidity status from a block and its descendants. */\n void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "a46b4003f1df9c1645f8165411f8996fc51c10c4",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -32,7 +32,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (const std::shared_ptr<const CBlock> &)> BlockDisconnected;\n     boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n     boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n+    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n     boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n@@ -168,7 +168,7 @@ void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {\n     });\n }\n \n-void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& state) {\n+void CMainSignals::BlockChecked(const CBlock& block, const BlockValidationState& state) {\n     m_internals->BlockChecked(block, state);\n }\n "
      },
      {
        "sha": "dc8425869b26804019537dd83744e8c08aae0605",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de1bffae72fb60d992c7ddc19c33768bcc562a79/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "patch": "@@ -13,12 +13,12 @@\n #include <memory>\n \n extern CCriticalSection cs_main;\n+class BlockValidationState;\n class CBlock;\n class CBlockIndex;\n struct CBlockLocator;\n class CConnman;\n class CValidationInterface;\n-class CValidationState;\n class uint256;\n class CScheduler;\n class CTxMemPool;\n@@ -134,11 +134,11 @@ class CValidationInterface {\n     virtual void ChainStateFlushed(const CBlockLocator &locator) {}\n     /**\n      * Notifies listeners of a block validation result.\n-     * If the provided CValidationState IsValid, the provided block\n+     * If the provided BlockValidationState IsValid, the provided block\n      * is guaranteed to be the current best block at the time the\n      * callback was generated (not necessarily now)\n      */\n-    virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n+    virtual void BlockChecked(const CBlock&, const BlockValidationState&) {}\n     /**\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n@@ -180,7 +180,7 @@ class CMainSignals {\n     void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::shared_ptr<const std::vector<CTransactionRef>> &);\n     void BlockDisconnected(const std::shared_ptr<const CBlock> &);\n     void ChainStateFlushed(const CBlockLocator &);\n-    void BlockChecked(const CBlock&, const CValidationState&);\n+    void BlockChecked(const CBlock&, const BlockValidationState&);\n     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n };\n "
      }
    ]
  },
  {
    "sha": "d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNmI1MGMzNDA1MWVhYzgwYWQ0MWYyYWY4Y2I2ZmQzMTI2MWYyZGU3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-28T17:17:56Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T15:36:03Z"
      },
      "message": "[validation] Tidy Up ValidationResult class\n\nMinor style fixups and comment updates.\n\nThis is purely a style change. There is no change in behavior.",
      "tree": {
        "sha": "0ac2418a1008cf0bf6e377e4d306c7584ae830dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ac2418a1008cf0bf6e377e4d306c7584ae830dd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b50c34051eac80ad41f2af8cb6fd31261f2de7/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de1bffae72fb60d992c7ddc19c33768bcc562a79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de1bffae72fb60d992c7ddc19c33768bcc562a79"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 29,
      "deletions": 34
    },
    "files": [
      {
        "sha": "e5ab9ad27c267aa588142ea739608fc45e8fa050",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 29,
        "deletions": 34,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b50c34051eac80ad41f2af8cb6fd31261f2de7/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b50c34051eac80ad41f2af8cb6fd31261f2de7/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
        "patch": "@@ -85,53 +85,47 @@ class ValidationState {\n         MODE_VALID,   //!< everything ok\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n-    } mode;\n-    std::string strRejectReason;\n-    std::string strDebugMessage;\n+    } m_mode;\n+    std::string m_reject_reason;\n+    std::string m_debug_message;\n protected:\n-    bool Invalid(bool ret = false,\n-            const std::string &strRejectReasonIn=\"\",\n-            const std::string &strDebugMessageIn=\"\") {\n-        strRejectReason = strRejectReasonIn;\n-        strDebugMessage = strDebugMessageIn;\n-        if (mode == MODE_ERROR)\n-            return ret;\n-        mode = MODE_INVALID;\n-        return ret;\n+    void Invalid(const std::string &reject_reason=\"\",\n+                 const std::string &debug_message=\"\")\n+    {\n+        m_reject_reason = reject_reason;\n+        m_debug_message = debug_message;\n+        if (m_mode != MODE_ERROR) m_mode = MODE_INVALID;\n     }\n public:\n     // We use ValidationState polymorphically. Have a virtual destructor\n     virtual ~ValidationState() {}\n \n-    ValidationState() : mode(MODE_VALID) {}\n-    bool Error(const std::string& strRejectReasonIn) {\n-        if (mode == MODE_VALID)\n-            strRejectReason = strRejectReasonIn;\n-        mode = MODE_ERROR;\n+    ValidationState() : m_mode(MODE_VALID) {}\n+    bool Error(const std::string& reject_reason)\n+    {\n+        if (m_mode == MODE_VALID)\n+            m_reject_reason = reject_reason;\n+        m_mode = MODE_ERROR;\n         return false;\n     }\n-    bool IsValid() const {\n-        return mode == MODE_VALID;\n-    }\n-    bool IsInvalid() const {\n-        return mode == MODE_INVALID;\n-    }\n-    bool IsError() const {\n-        return mode == MODE_ERROR;\n-    }\n-    std::string GetRejectReason() const { return strRejectReason; }\n-    std::string GetDebugMessage() const { return strDebugMessage; }\n+    bool IsValid() const { return m_mode == MODE_VALID; }\n+    bool IsInvalid() const { return m_mode == MODE_INVALID; }\n+    bool IsError() const { return m_mode == MODE_ERROR; }\n+    std::string GetRejectReason() const { return m_reject_reason; }\n+    std::string GetDebugMessage() const { return m_debug_message; }\n };\n \n class TxValidationState : public ValidationState {\n private:\n     TxValidationResult m_result;\n public:\n     bool Invalid(TxValidationResult result, bool ret = false,\n-                 const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n+                 const std::string &reject_reason=\"\",\n+                 const std::string &debug_message=\"\")\n+    {\n         m_result = result;\n-        return ValidationState::Invalid(ret, _strRejectReason, _strDebugMessage);\n+        ValidationState::Invalid(reject_reason, debug_message);\n+        return ret;\n     }\n     TxValidationResult GetResult() const { return m_result; }\n };\n@@ -141,10 +135,11 @@ class BlockValidationState : public ValidationState {\n     BlockValidationResult m_result;\n public:\n     bool Invalid(BlockValidationResult result, bool ret = false,\n-                 const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n+                 const std::string &reject_reason=\"\",\n+                 const std::string &debug_message=\"\") {\n         m_result = result;\n-        return ValidationState::Invalid(ret, _strRejectReason, _strDebugMessage);\n+        ValidationState::Invalid(reject_reason, debug_message);\n+        return ret;\n     }\n     BlockValidationResult GetResult() const { return m_result; }\n };"
      }
    ]
  },
  {
    "sha": "5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YTY0NTYxMTNiNGYyOWYwNDJlNmYwOWY5ZTRjYzVhYjhjNjU0YmM0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-28T20:32:34Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T15:42:50Z"
      },
      "message": "[validation] Remove error() calls from Invalid() calls\n\nThis is in preparation for the next commit, which removes the useless\n`ret` parameter from ValidationState::Invalid().\n\nerror() is simply a convenience wrapper that calls LogPrintf and returns\nfalse. Call LogPrintf explicitly and substitute the error() call for a\nfalse bool literal.",
      "tree": {
        "sha": "3601e7d6e3f2a0b7c755fdc37c886f04e6ca78b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3601e7d6e3f2a0b7c755fdc37c886f04e6ca78b8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b50c34051eac80ad41f2af8cb6fd31261f2de7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6b50c34051eac80ad41f2af8cb6fd31261f2de7"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 37,
      "deletions": 26
    },
    "files": [
      {
        "sha": "5553cf137a271b01655d53ddcf68e23952a709e2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 26,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
        "patch": "@@ -2056,8 +2056,8 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                     \"bad-txns-BIP30\");\n+                    LogPrintf(\"ERROR: ConnectBlock(): tried to overwrite transaction\\n\");\n+                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -2104,8 +2104,8 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n-                                 \"bad-txns-accumulated-fee-outofrange\");\n+                LogPrintf(\"ERROR: %s: accumulated fee in the block out of range.\\n\", __func__);\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -2117,8 +2117,8 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n-                                 \"bad-txns-nonfinal\");\n+                LogPrintf(\"ERROR: %s: contains a non-BIP68-final transaction\\n\", __func__);\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -2127,9 +2127,10 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         // * p2sh (when P2SH enabled in flags and excludes coinbase)\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n-        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n-                             \"bad-blk-sigops\");\n+        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n+            LogPrintf(\"ERROR: ConnectBlock(): too many sigops\\n\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-sigops\");\n+        }\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n@@ -2157,14 +2158,15 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", (unsigned)block.vtx.size(), MILLI * (nTime3 - nTime2), MILLI * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : MILLI * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * MICRO, nTimeConnect * MILLI / nBlocksTotal);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n-    if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n-                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n-                               block.vtx[0]->GetValueOut(), blockReward),\n-                               \"bad-cb-amount\");\n-\n-    if (!control.Wait())\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, error(\"%s: CheckQueue failed\", __func__), \"block-validation-failed\");\n+    if (block.vtx[0]->GetValueOut() > blockReward) {\n+        LogPrintf(\"ERROR: ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\\n\", block.vtx[0]->GetValueOut(), blockReward);\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-amount\");\n+    }\n+\n+    if (!control.Wait()) {\n+        LogPrintf(\"ERROR: %s: CheckQueue failed\\n\", __func__);\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"block-validation-failed\");\n+    }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3416,8 +3418,10 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n         // g_blockman.m_block_index.\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n-        if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), \"bad-fork-prior-to-checkpoint\");\n+        if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n+            LogPrintf(\"ERROR: %s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n+            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, false, \"bad-fork-prior-to-checkpoint\");\n+        }\n     }\n \n     // Check timestamp against prev\n@@ -3540,8 +3544,10 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             pindex = miSelf->second;\n             if (ppindex)\n                 *ppindex = pindex;\n-            if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(BlockValidationResult::BLOCK_CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), \"duplicate\");\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n+                LogPrintf(\"ERROR: %s: block %s is marked invalid\\n\", __func__, hash.ToString());\n+                return state.Invalid(BlockValidationResult::BLOCK_CACHED_INVALID, false, \"duplicate\");\n+            }\n             return true;\n         }\n \n@@ -3551,11 +3557,15 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n-        if (mi == m_block_index.end())\n-            return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), \"prev-blk-not-found\");\n+        if (mi == m_block_index.end()) {\n+            LogPrintf(\"ERROR: %s: prev block not found\\n\", __func__);\n+            return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, false, \"prev-blk-not-found\");\n+        }\n         pindexPrev = (*mi).second;\n-        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n+        if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n+            LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n+            return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, false, \"bad-prevblk\");\n+        }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3592,7 +3602,8 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n+                    LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n+                    return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, false, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZTY0YjUyNmRkMTJjZDQ2OTA3MGVmNTA1YjhiY2UxMGM0ZjZmMWU0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-28T20:40:01Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T16:50:04Z"
      },
      "message": "[validation] Remove useless ret parameter from Invalid()\n\nValidationState::Invalid() takes a parameter `ret` which is returned to\nthe caller. All call sites set this to false. Remove the `ret` parameter\nand just return false always.",
      "tree": {
        "sha": "de2678ed78048e88d3db8e1e73380022a141df0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de2678ed78048e88d3db8e1e73380022a141df0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6456113b4f29f042e6f09f9e4cc5ab8c654bc4"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 74,
      "deletions": 74
    },
    "files": [
      {
        "sha": "9fc1d5dec062c5fbf0ff0ad33f5a0a5930cf3589",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "patch": "@@ -11,24 +11,24 @@ bool CheckTransaction(const CTransaction& tx, TxValidationState &state, bool fCh\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vin-empty\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-empty\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-oversize\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values (see CVE-2010-5139)\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-negative\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -37,20 +37,20 @@ bool CheckTransaction(const CTransaction& tx, TxValidationState &state, bool fCh\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-cb-length\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-prevout-null\");\n+                return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "31bdabea28103dfb19f3f1e0bcd69ebfde7f726c",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "patch": "@@ -160,7 +160,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, TxValidationState& state,\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, false, \"bad-txns-inputs-missingorspent\",\n+        return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -172,27 +172,27 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, TxValidationState& state,\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-in-belowout\",\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "edb37ed1df8f01a60072ad29a6c6933a8eab74d4",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "patch": "@@ -119,13 +119,13 @@ class TxValidationState : public ValidationState {\n private:\n     TxValidationResult m_result;\n public:\n-    bool Invalid(TxValidationResult result, bool ret = false,\n+    bool Invalid(TxValidationResult result,\n                  const std::string &reject_reason=\"\",\n                  const std::string &debug_message=\"\")\n     {\n         m_result = result;\n         ValidationState::Invalid(reject_reason, debug_message);\n-        return ret;\n+        return false;\n     }\n     TxValidationResult GetResult() const { return m_result; }\n };\n@@ -134,12 +134,12 @@ class BlockValidationState : public ValidationState {\n private:\n     BlockValidationResult m_result;\n public:\n-    bool Invalid(BlockValidationResult result, bool ret = false,\n+    bool Invalid(BlockValidationResult result,\n                  const std::string &reject_reason=\"\",\n                  const std::string &debug_message=\"\") {\n         m_result = result;\n         ValidationState::Invalid(reject_reason, debug_message);\n-        return ret;\n+        return false;\n     }\n     BlockValidationResult GetResult() const { return m_result; }\n };"
      },
      {
        "sha": "2e20b023b4bd8e385b11f1ffaab1cc87986cde6b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 56,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e64b526dd12cd469070ef505b8bce10c4f6f1e4/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "patch": "@@ -505,11 +505,11 @@ class MemPoolAccept\n     {\n         CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n         if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n         }\n \n         if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n         }\n         return true;\n     }\n@@ -562,29 +562,29 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"coinbase\");\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"coinbase\");\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason))\n-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, reason);\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to mitigate CVE-2017-12842 by not relaying\n     // 64-byte transactions.\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"tx-size-small\");\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"non-final\");\n+        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-final\");\n \n     // is it already in the memory pool?\n     if (m_pool.exists(hash)) {\n-        return state.Invalid(TxValidationResult::TX_CONFLICT, false, \"txn-already-in-mempool\");\n+        return state.Invalid(TxValidationResult::TX_CONFLICT, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -616,7 +616,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"txn-mempool-conflict\");\n+                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -642,7 +642,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             for (size_t out = 0; out < tx.vout.size(); out++) {\n                 // Optimistically just do efficient check of cache for outputs\n                 if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                    return state.Invalid(TxValidationResult::TX_CONFLICT, false, \"txn-already-known\");\n+                    return state.Invalid(TxValidationResult::TX_CONFLICT, \"txn-already-known\");\n                 }\n             }\n             // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -667,7 +667,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n     // CoinsViewCache instead of create its own\n     if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, false, \"non-BIP68-final\");\n+        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n     CAmount nFees = 0;\n     if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n@@ -676,11 +676,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Check for non-standard pay-to-script-hash in inputs\n     if (fRequireStandard && !AreInputsStandard(tx, m_view))\n-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"bad-txns-nonstandard-inputs\");\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"bad-txns-nonstandard-inputs\");\n \n     // Check for non-standard witness in P2WSH\n     if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n-        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, false, \"bad-witness-nonstandard\");\n+        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, \"bad-witness-nonstandard\");\n \n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -704,15 +704,15 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     unsigned int nSize = entry->GetTxSize();\n \n     if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, \"bad-txns-too-many-sigops\",\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n     // No transactions are allowed below minRelayTxFee except from disconnected\n     // blocks\n     if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n     if (nAbsurdFee && nFees > nAbsurdFee)\n-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false,\n+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD,\n                 \"absurdly-high-fee\", strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n     const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n@@ -770,7 +770,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n         if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n                 !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"too-long-mempool-chain\", errString);\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-mempool-chain\", errString);\n         }\n     }\n \n@@ -783,7 +783,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n         if (setConflicts.count(hashAncestor))\n         {\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, \"bad-txns-spends-conflicting-tx\",\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-spends-conflicting-tx\",\n                     strprintf(\"%s spends conflicting transaction %s\",\n                         hash.ToString(),\n                         hashAncestor.ToString()));\n@@ -823,7 +823,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n             if (newFeeRate <= oldFeeRate)\n             {\n-                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n                             newFeeRate.ToString(),\n@@ -851,7 +851,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 nConflictingSize += it->GetTxSize();\n             }\n         } else {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"too many potential replacements\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too many potential replacements\",\n                     strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                         hash.ToString(),\n                         nConflictingCount,\n@@ -875,7 +875,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 // it's cheaper to just check if the new input refers to a\n                 // tx that's in the mempool.\n                 if (m_pool.exists(tx.vin[j].prevout.hash)) {\n-                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"replacement-adds-unconfirmed\",\n+                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"replacement-adds-unconfirmed\",\n                             strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                 hash.ToString(), j));\n                 }\n@@ -887,7 +887,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // transactions would not be paid for.\n         if (nModifiedFees < nConflictingFees)\n         {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                         hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n         }\n@@ -897,7 +897,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n         if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n         {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                         hash.ToString(),\n                         FormatMoney(nDeltaFees),\n@@ -925,7 +925,7 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n         if (!tx.HasWitness() && CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n-            state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, false,\n+            state.Invalid(TxValidationResult::TX_WITNESS_MUTATED,\n                     state.GetRejectReason(), state.GetDebugMessage());\n         }\n         return false; // state filled in by CheckInputs\n@@ -1008,7 +1008,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     if (!bypass_limits) {\n         LimitMempoolSize(m_pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, std::chrono::hours{gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)});\n         if (!m_pool.exists(hash))\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, false, \"mempool full\");\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"mempool full\");\n     }\n     return true;\n }\n@@ -1543,7 +1543,7 @@ bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsV\n                 CScriptCheck check2(coin.out, tx, i,\n                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                 if (check2())\n-                    return state.Invalid(TxValidationResult::TX_NOT_STANDARD, false, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n             }\n             // MANDATORY flag failures correspond to\n             // TxValidationResult::TX_CONSENSUS. Because CONSENSUS\n@@ -1554,7 +1554,7 @@ bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsV\n             // support, to avoid splitting the network (but this\n             // depends on the details of how net_processing handles\n             // such errors).\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, false, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n         }\n     }\n \n@@ -2057,7 +2057,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     LogPrintf(\"ERROR: ConnectBlock(): tried to overwrite transaction\\n\");\n-                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-BIP30\");\n+                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -2098,14 +2098,14 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             TxValidationState tx_state;\n             if (!Consensus::CheckTxInputs(tx, tx_state, view, pindex->nHeight, txfee)) {\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n-                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false,\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                             tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n                 LogPrintf(\"ERROR: %s: accumulated fee in the block out of range.\\n\", __func__);\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-accumulated-fee-outofrange\");\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -2118,7 +2118,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n                 LogPrintf(\"ERROR: %s: contains a non-BIP68-final transaction\\n\", __func__);\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-nonfinal\");\n+                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -2129,7 +2129,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n             LogPrintf(\"ERROR: ConnectBlock(): too many sigops\\n\");\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-sigops\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-sigops\");\n         }\n \n         txdata.emplace_back(tx);\n@@ -2140,7 +2140,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             TxValidationState tx_state;\n             if (fScriptChecks && !CheckInputs(tx, tx_state, view, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n-                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false,\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                               tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n@@ -2160,12 +2160,12 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward) {\n         LogPrintf(\"ERROR: ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\\n\", block.vtx[0]->GetValueOut(), blockReward);\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-amount\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-amount\");\n     }\n \n     if (!control.Wait()) {\n         LogPrintf(\"ERROR: %s: CheckQueue failed\\n\", __func__);\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"block-validation-failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"block-validation-failed\");\n     }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n@@ -3243,7 +3243,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, BlockValidationState& st\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"high-hash\", \"proof of work failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3265,13 +3265,13 @@ bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensu\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-txns-duplicate\", \"duplicate transaction\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3282,14 +3282,14 @@ bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensu\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-length\", \"size limits failed\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-missing\", \"first tx is not coinbase\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-multiple\", \"more than one coinbase\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     // Must check for duplicate inputs (see CVE-2018-17144)\n@@ -3299,7 +3299,7 @@ bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensu\n             // CheckBlock() does context-free validation checks. The only\n             // possible failures are consensus failures.\n             assert(tx_state.GetResult() == TxValidationResult::TX_CONSENSUS);\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, tx_state.GetRejectReason(),\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, tx_state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), tx_state.GetDebugMessage()));\n         }\n     }\n@@ -3309,7 +3309,7 @@ bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensu\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3410,7 +3410,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"bad-diffbits\", \"incorrect proof of work\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3420,24 +3420,24 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n             LogPrintf(\"ERROR: %s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n-            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, false, \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n         }\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(BlockValidationResult::BLOCK_TIME_FUTURE, false, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(BlockValidationResult::BLOCK_TIME_FUTURE, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, false, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(BlockValidationResult::BLOCK_INVALID_HEADER, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3467,7 +3467,7 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-txns-nonfinal\", \"non-final transaction\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3477,7 +3477,7 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-cb-height\", \"block height mismatch in coinbase\");\n+            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3499,11 +3499,11 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3513,7 +3513,7 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, false, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3525,7 +3525,7 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, false, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3546,7 +3546,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 LogPrintf(\"ERROR: %s: block %s is marked invalid\\n\", __func__, hash.ToString());\n-                return state.Invalid(BlockValidationResult::BLOCK_CACHED_INVALID, false, \"duplicate\");\n+                return state.Invalid(BlockValidationResult::BLOCK_CACHED_INVALID, \"duplicate\");\n             }\n             return true;\n         }\n@@ -3559,12 +3559,12 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n         BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n         if (mi == m_block_index.end()) {\n             LogPrintf(\"ERROR: %s: prev block not found\\n\", __func__);\n-            return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, false, \"prev-blk-not-found\");\n+            return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, \"prev-blk-not-found\");\n         }\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n-            return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, false, \"bad-prevblk\");\n+            return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n         }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n@@ -3603,7 +3603,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n                         invalid_walk = invalid_walk->pprev;\n                     }\n                     LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n-                    return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, false, \"bad-prevblk\");\n+                    return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NTVkZDVmMmNmOTE0ZTNlY2M2NGJhNzNhM2JkNzA4MDBkZGQwZGM2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-28T20:46:35Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T16:50:07Z"
      },
      "message": "[validation] Remove unused first_invalid parameter from ProcessNewBlockHeaders()\n\nNo callers use the returned value in first_invalid. Remove it from the\nfunction signature and don't set it in the function.",
      "tree": {
        "sha": "13bc9098618b89685738a54f0577458860a0877a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13bc9098618b89685738a54f0577458860a0877a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e64b526dd12cd469070ef505b8bce10c4f6f1e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4e64b526dd12cd469070ef505b8bce10c4f6f1e4"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 5,
      "deletions": 9
    },
    "files": [
      {
        "sha": "bc5bf81e023f480fc51faa5aa42bb950adee6284",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "patch": "@@ -1688,8 +1688,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     }\n \n     BlockValidationState state;\n-    CBlockHeader first_invalid_header;\n-    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n+    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n         if (state.IsInvalid()) {\n             MaybePunishNodeForBlock(pfrom->GetId(), state, via_compact_block, \"invalid header received\");\n             return false;"
      },
      {
        "sha": "78e80195befd3b13e41a37d33d3a228a12fd1df3",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "patch": "@@ -773,7 +773,7 @@ static UniValue submitheader(const JSONRPCRequest& request)\n     }\n \n     BlockValidationState state;\n-    ProcessNewBlockHeaders({h}, state, Params(), /* ppindex */ nullptr, /* first_invalid */ nullptr);\n+    ProcessNewBlockHeaders({h}, state, Params());\n     if (state.IsValid()) return NullUniValue;\n     if (state.IsError()) {\n         throw JSONRPCError(RPC_VERIFY_ERROR, FormatStateMessage(state));"
      },
      {
        "sha": "4a15bf0c772e7615006eaca96bc759865d5f721c",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "patch": "@@ -103,7 +103,7 @@ static bool BuildChain(const CBlockIndex* pindex, const CScript& coinbase_script\n         CBlockHeader header = block->GetBlockHeader();\n \n         BlockValidationState state;\n-        if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex, nullptr)) {\n+        if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex)) {\n             return false;\n         }\n     }"
      },
      {
        "sha": "0e81e82722b5c3aa94de1974290c6e574e060609",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "patch": "@@ -3618,9 +3618,8 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n }\n \n // Exposed wrapper for AcceptBlockHeader\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex, CBlockHeader *first_invalid)\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex)\n {\n-    if (first_invalid != nullptr) first_invalid->SetNull();\n     {\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n@@ -3629,7 +3628,6 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, BlockValid\n             ::ChainstateActive().CheckBlockIndex(chainparams.GetConsensus());\n \n             if (!accepted) {\n-                if (first_invalid) *first_invalid = header;\n                 return false;\n             }\n             if (ppindex) {"
      },
      {
        "sha": "a8d7e76a31566b5000f07f3edc8960da6e73530b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "patch": "@@ -222,9 +222,8 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[out] state This may be set to an Error state if any error occurred processing them\n  * @param[in]  chainparams The params for the chain we want to connect to\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n- * @param[out] first_invalid First header that fails validation, if one exists\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex = nullptr, CBlockHeader* first_invalid = nullptr) LOCKS_EXCLUDED(cs_main);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex = nullptr) LOCKS_EXCLUDED(cs_main);\n \n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);"
      }
    ]
  },
  {
    "sha": "9ec6b4fb30142c182212fb24a581774a18fca00c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZWM2YjRmYjMwMTQyYzE4MjIxMmZiMjRhNTgxNzc0YTE4ZmNhMDBj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-28T21:26:31Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T16:52:04Z"
      },
      "message": "[validation] Remove fMissingInputs from AcceptToMemoryPool()\n\nHandle this failure in the same way as all other failures: call Invalid()\nwith the reasons for the failure.",
      "tree": {
        "sha": "94bd840e9890df024f317e0225a9a775600c2205",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94bd840e9890df024f317e0225a9a775600c2205"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ec6b4fb30142c182212fb24a581774a18fca00c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ec6b4fb30142c182212fb24a581774a18fca00c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ec6b4fb30142c182212fb24a581774a18fca00c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ec6b4fb30142c182212fb24a581774a18fca00c/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/955dd5f2cf914e3ecc64ba73a3bd70800ddd0dc6"
      }
    ],
    "stats": {
      "total": 73,
      "additions": 27,
      "deletions": 46
    },
    "files": [
      {
        "sha": "2f47398d99d1647eb9b18637ff8c655fcd5321b4",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -39,7 +39,7 @@ static void AssembleBlock(benchmark::State& state)\n \n         for (const auto& txr : txs) {\n             TxValidationState state;\n-            bool ret{::AcceptToMemoryPool(::mempool, state, txr, nullptr /* pfMissingInputs */, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)};\n+            bool ret{::AcceptToMemoryPool(::mempool, state, txr, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)};\n             assert(ret);\n         }\n     }"
      },
      {
        "sha": "56a352b501e75705e3ea26078f6d11d1b25884b1",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -27,12 +27,7 @@ enum class TxValidationResult {\n      */\n     TX_RECENT_CONSENSUS_CHANGE,\n     TX_NOT_STANDARD,          //!< didn't meet our local policy rules\n-    /**\n-     * transaction was missing some of its inputs\n-     * TODO: ATMP uses fMissingInputs and a valid ValidationState to indicate missing inputs.\n-     *       Change ATMP to use TX_MISSING_INPUTS.\n-     */\n-    TX_MISSING_INPUTS,\n+    TX_MISSING_INPUTS,        //!< transaction was missing some of its inputs\n     TX_PREMATURE_SPEND,       //!< transaction spends a coinbase too early, or violates locktime/sequence locks\n     /**\n      * Transaction might be missing a witness, have a witness prior to SegWit"
      },
      {
        "sha": "2e37270804ced2173a4417339d820ff945374c18",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -1826,14 +1826,13 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n         const CTransactionRef porphanTx = orphan_it->second.tx;\n         const CTransaction& orphanTx = *porphanTx;\n         NodeId fromPeer = orphan_it->second.fromPeer;\n-        bool fMissingInputs2 = false;\n         // Use a new TxValidationState because orphans come from different peers (and we call\n         // MaybePunishNodeForTx based on the source peer from the orphan map, not based on the peer\n         // that relayed the previous transaction).\n         TxValidationState orphan_state;\n \n         if (setMisbehaving.count(fromPeer)) continue;\n-        if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &fMissingInputs2, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+        if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanHash, *connman);\n             for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n@@ -1846,7 +1845,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             }\n             EraseOrphanTx(orphanHash);\n             done = true;\n-        } else if (!fMissingInputs2) {\n+        } else if (orphan_state.GetResult() != TxValidationResult::TX_MISSING_INPUTS) {\n             if (orphan_state.IsInvalid()) {\n                 // Punish peer that gave us an invalid orphan tx\n                 if (MaybePunishNodeForTx(fromPeer, orphan_state)) {\n@@ -2482,7 +2481,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK2(cs_main, g_cs_orphans);\n \n-        bool fMissingInputs = false;\n         TxValidationState state;\n \n         CNodeState* nodestate = State(pfrom->GetId());\n@@ -2493,7 +2491,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv) &&\n-            AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+            AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n             RelayTransaction(tx.GetHash(), *connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n@@ -2515,7 +2513,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Recursively process any orphan transactions that depended on this one\n             ProcessOrphanTx(connman, pfrom->orphan_work_set, lRemovedTxn);\n         }\n-        else if (fMissingInputs)\n+        else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n         {\n             bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n             for (const CTxIn& txin : tx.vin) {"
      },
      {
        "sha": "8989a77e573ad48212520f77f2468642bdae770d",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -37,17 +37,15 @@ TransactionError BroadcastTransaction(const CTransactionRef tx, std::string& err\n     if (!mempool.exists(hashTx)) {\n         // Transaction is not already in the mempool. Submit it.\n         TxValidationState state;\n-        bool fMissingInputs;\n-        if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n+        if (!AcceptToMemoryPool(mempool, state, std::move(tx),\n                 nullptr /* plTxnReplaced */, false /* bypass_limits */, max_tx_fee)) {\n+            err_string = FormatStateMessage(state);\n             if (state.IsInvalid()) {\n-                err_string = FormatStateMessage(state);\n-                return TransactionError::MEMPOOL_REJECTED;\n-            } else {\n-                if (fMissingInputs) {\n+                if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n                     return TransactionError::MISSING_INPUTS;\n                 }\n-                err_string = FormatStateMessage(state);\n+                return TransactionError::MEMPOOL_REJECTED;\n+            } else {\n                 return TransactionError::MEMPOOL_ERROR;\n             }\n         }"
      },
      {
        "sha": "48b26d2a6f77c548bc7a049e653f63c99b733b98",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -894,19 +894,20 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     result_0.pushKV(\"txid\", tx_hash.GetHex());\n \n     TxValidationState state;\n-    bool missing_inputs;\n     bool test_accept_res;\n     {\n         LOCK(cs_main);\n-        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx), &missing_inputs,\n+        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx),\n             nullptr /* plTxnReplaced */, false /* bypass_limits */, max_raw_tx_fee, /* test_accept */ true);\n     }\n     result_0.pushKV(\"allowed\", test_accept_res);\n     if (!test_accept_res) {\n         if (state.IsInvalid()) {\n-            result_0.pushKV(\"reject-reason\", strprintf(\"%s\", state.GetRejectReason()));\n-        } else if (missing_inputs) {\n-            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n+            if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+                result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n+            } else {\n+                result_0.pushKV(\"reject-reason\", strprintf(\"%s\", state.GetRejectReason()));\n+            }\n         } else {\n             result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n         }"
      },
      {
        "sha": "391ebfadfb7f8ed1ec585a65bdc0a50439f65b54",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -39,7 +39,6 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     BOOST_CHECK_EQUAL(\n             false,\n             AcceptToMemoryPool(mempool, state, MakeTransactionRef(coinbaseTx),\n-                nullptr /* pfMissingInputs */,\n                 nullptr /* plTxnReplaced */,\n                 true /* bypass_limits */,\n                 0 /* nAbsurdFee */));"
      },
      {
        "sha": "144230b114f95d3045e29b7f3ecc73079191ad7e",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -23,7 +23,7 @@ ToMemPool(const CMutableTransaction& tx)\n     LOCK(cs_main);\n \n     TxValidationState state;\n-    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), nullptr /* pfMissingInputs */,\n+    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx),\n                               nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\n }\n "
      },
      {
        "sha": "aca9f475ac24bd5a50dec976e569de39128c7b94",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -285,7 +285,6 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n                     ::mempool,\n                     state,\n                     tx,\n-                    /* pfMissingInputs */ &ignored,\n                     &plTxnReplaced,\n                     /* bypass_limits */ false,\n                     /* nAbsurdFee */ 0));"
      },
      {
        "sha": "11ef6fbffe637139c5834052130b5d897f060e4f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 16,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -365,7 +365,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n         // ignore validation errors in resurrected transactions\n         TxValidationState stateDummy;\n         if (!fAddToMempool || (*it)->IsCoinBase() ||\n-            !AcceptToMemoryPool(mempool, stateDummy, *it, nullptr /* pfMissingInputs */,\n+            !AcceptToMemoryPool(mempool, stateDummy, *it,\n                                 nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             // If the transaction doesn't make it in to the mempool, remove any\n             // transactions that depend on it (which would now be orphans).\n@@ -441,7 +441,6 @@ class MemPoolAccept\n     struct ATMPArgs {\n         const CChainParams& m_chainparams;\n         TxValidationState &m_state;\n-        bool* m_missing_inputs;\n         const int64_t m_accept_time;\n         std::list<CTransactionRef>* m_replaced_transactions;\n         const bool m_bypass_limits;\n@@ -537,7 +536,6 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Copy/alias what we need out of args\n     TxValidationState &state = args.m_state;\n-    bool* pfMissingInputs = args.m_missing_inputs;\n     const int64_t nAcceptTime = args.m_accept_time;\n     const bool bypass_limits = args.m_bypass_limits;\n     const CAmount& nAbsurdFee = args.m_absurd_fee;\n@@ -553,10 +551,6 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     CAmount& nConflictingFees = ws.m_conflicting_fees;\n     size_t& nConflictingSize = ws.m_conflicting_size;\n \n-    if (pfMissingInputs) {\n-        *pfMissingInputs = false;\n-    }\n-\n     if (!CheckTransaction(tx, state))\n         return false; // state filled in by CheckTransaction\n \n@@ -646,10 +640,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 }\n             }\n             // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-            if (pfMissingInputs) {\n-                *pfMissingInputs = true;\n-            }\n-            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n+            return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"bad-txns-inputs-missingorspent\");\n         }\n     }\n \n@@ -1046,11 +1037,11 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n+                        int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    MemPoolAccept::ATMPArgs args { chainparams, state, pfMissingInputs, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache, test_accept };\n+    MemPoolAccept::ATMPArgs args { chainparams, state, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache, test_accept };\n     bool res = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n     if (!res) {\n         // Remove coins that were not present in the coins cache before calling ATMPW;\n@@ -1068,11 +1059,11 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n }\n \n bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n+                        std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)\n {\n     const CChainParams& chainparams = Params();\n-    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, pfMissingInputs, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee, test_accept);\n+    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee, test_accept);\n }\n \n /**\n@@ -4968,7 +4959,7 @@ bool LoadMempool(CTxMemPool& pool)\n             TxValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nullptr /* pfMissingInputs */, nTime,\n+                AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nTime,\n                                            nullptr /* plTxnReplaced */, false /* bypass_limits */, 0 /* nAbsurdFee */,\n                                            false /* test_accept */);\n                 if (state.IsValid()) {"
      },
      {
        "sha": "7f9582adfd07f715a41af555afae45704b92d9e4",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -273,7 +273,7 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n /** (try to) add transaction to memory pool\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n+                        std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Get the BIP9 state for a given deployment at the current tip. */"
      },
      {
        "sha": "4ee46d5f535931fd9f4bc2c5417a5962f51036a1",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ec6b4fb30142c182212fb24a581774a18fca00c/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ec6b4fb30142c182212fb24a581774a18fca00c/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=9ec6b4fb30142c182212fb24a581774a18fca00c",
        "patch": "@@ -209,7 +209,7 @@ def run_test(self):\n         rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)\n \n         # This will raise an exception since there are missing inputs\n-        assert_raises_rpc_error(-25, \"Missing inputs\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n+        assert_raises_rpc_error(-25, \"bad-txns-inputs-missingorspent\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n         #####################################\n         # getrawtransaction with block hash #"
      }
    ]
  },
  {
    "sha": "654a9df354f47fa81006dfef616a6e010111a762",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTRhOWRmMzU0ZjQ3ZmE4MTAwNmRmZWY2MTZhNmUwMTAxMTFhNzYy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T16:37:43Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-24T16:53:12Z"
      },
      "message": "[validation] remove fCheckDuplicateInputs argument from CheckTransaction\n\nThis is always set to true, since commit\nb8f801964f59586508ea8da6cf3decd76bc0e571.",
      "tree": {
        "sha": "61ac4e96a10d6b3695db87528a40a53350b1f268",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61ac4e96a10d6b3695db87528a40a53350b1f268"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/654a9df354f47fa81006dfef616a6e010111a762",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/654a9df354f47fa81006dfef616a6e010111a762",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/654a9df354f47fa81006dfef616a6e010111a762",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/654a9df354f47fa81006dfef616a6e010111a762/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ec6b4fb30142c182212fb24a581774a18fca00c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ec6b4fb30142c182212fb24a581774a18fca00c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ec6b4fb30142c182212fb24a581774a18fca00c"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 10,
      "deletions": 12
    },
    "files": [
      {
        "sha": "f973c8156f82a53bc79a8dc27929c52bf37e4caa",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 8,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/654a9df354f47fa81006dfef616a6e010111a762/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/654a9df354f47fa81006dfef616a6e010111a762/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=654a9df354f47fa81006dfef616a6e010111a762",
        "patch": "@@ -7,7 +7,7 @@\n #include <primitives/transaction.h>\n #include <consensus/validation.h>\n \n-bool CheckTransaction(const CTransaction& tx, TxValidationState &state, bool fCheckDuplicateInputs)\n+bool CheckTransaction(const CTransaction& tx, TxValidationState &state)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -31,13 +31,11 @@ bool CheckTransaction(const CTransaction& tx, TxValidationState &state, bool fCh\n             return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-txouttotal-toolarge\");\n     }\n \n-    // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n-    if (fCheckDuplicateInputs) {\n-        std::set<COutPoint> vInOutPoints;\n-        for (const auto& txin : tx.vin)\n-        {\n-            if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputs-duplicate\");\n+    // Check for duplicate inputs\n+    std::set<COutPoint> vInOutPoints;\n+    for (const auto& txin : tx.vin) {\n+        if (!vInOutPoints.insert(txin.prevout).second) {\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputs-duplicate\");\n         }\n     }\n "
      },
      {
        "sha": "b818a284f1c183b12e60c9d0bd33b18d63161a3b",
        "filename": "src/consensus/tx_check.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/654a9df354f47fa81006dfef616a6e010111a762/src/consensus/tx_check.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/654a9df354f47fa81006dfef616a6e010111a762/src/consensus/tx_check.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.h?ref=654a9df354f47fa81006dfef616a6e010111a762",
        "patch": "@@ -15,6 +15,6 @@\n class CTransaction;\n class TxValidationState;\n \n-bool CheckTransaction(const CTransaction& tx, TxValidationState& state, bool fCheckDuplicateInputs=true);\n+bool CheckTransaction(const CTransaction& tx, TxValidationState& state);\n \n #endif // BITCOIN_CONSENSUS_TX_CHECK_H"
      },
      {
        "sha": "119a9fa689b398ece53d73759e6d3879c747d749",
        "filename": "src/test/fuzz/transaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/654a9df354f47fa81006dfef616a6e010111a762/src/test/fuzz/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/654a9df354f47fa81006dfef616a6e010111a762/src/test/fuzz/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/transaction.cpp?ref=654a9df354f47fa81006dfef616a6e010111a762",
        "patch": "@@ -43,9 +43,9 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     }\n \n     CValidationState state_with_dupe_check;\n-    const bool valid_with_dupe_check = CheckTransaction(tx, state_with_dupe_check, /* fCheckDuplicateInputs= */ true);\n+    const bool valid_with_dupe_check = CheckTransaction(tx, state_with_dupe_check);\n     CValidationState state_without_dupe_check;\n-    const bool valid_without_dupe_check = CheckTransaction(tx, state_without_dupe_check, /* fCheckDuplicateInputs= */ false);\n+    const bool valid_without_dupe_check = CheckTransaction(tx, state_without_dupe_check);\n     if (valid_with_dupe_check) {\n         assert(valid_without_dupe_check);\n     }"
      },
      {
        "sha": "2d6fc36ba7af998862b8f0e7a5cf7fed64e2fe54",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/654a9df354f47fa81006dfef616a6e010111a762/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/654a9df354f47fa81006dfef616a6e010111a762/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=654a9df354f47fa81006dfef616a6e010111a762",
        "patch": "@@ -3286,7 +3286,7 @@ bool CheckBlock(const CBlock& block, BlockValidationState& state, const Consensu\n     // Must check for duplicate inputs (see CVE-2018-17144)\n     for (const auto& tx : block.vtx) {\n         TxValidationState tx_state;\n-        if (!CheckTransaction(*tx, tx_state, true)) {\n+        if (!CheckTransaction(*tx, tx_state)) {\n             // CheckBlock() does context-free validation checks. The only\n             // possible failures are consensus failures.\n             assert(tx_state.GetResult() == TxValidationResult::TX_CONSENSUS);"
      }
    ]
  }
]