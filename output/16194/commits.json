[
  {
    "sha": "613c46fe9e39f55b0f0daa18fee20b4120db2539",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTNjNDZmZTllMzlmNTViMGYwZGFhMThmZWUyMGI0MTIwZGIyNTM5",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T21:07:32Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-08T15:33:12Z"
      },
      "message": "refactoring: move block metadata structures into BlockManager\n\nSeparate out the management of chain-agnostic block metadata from any given\nCChainState instance. This allows us to avoid duplicating data like\n`mapBlockIndex` unnecessarily for multiple chainstates.\n\nThis also adds a CChainState constructor that accepts and sets m_blockman.\nUltimately this reference will point to a BlockMan instance that\nis shared across CChainStates.\n\nThis commit can be decomposed into smaller commits if necessary.",
      "tree": {
        "sha": "55d37d42dbe08bc1869933173d710b97ed578474",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/55d37d42dbe08bc1869933173d710b97ed578474"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/613c46fe9e39f55b0f0daa18fee20b4120db2539",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/613c46fe9e39f55b0f0daa18fee20b4120db2539",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/613c46fe9e39f55b0f0daa18fee20b4120db2539",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/613c46fe9e39f55b0f0daa18fee20b4120db2539/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2679bb8919b5089f8067ccfd94f766747b8df671",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2679bb8919b5089f8067ccfd94f766747b8df671",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2679bb8919b5089f8067ccfd94f766747b8df671"
      }
    ],
    "stats": {
      "total": 273,
      "additions": 158,
      "deletions": 115
    },
    "files": [
      {
        "sha": "75d5bb9fe63188e784f9698fb5646f010acee0f5",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 68,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/613c46fe9e39f55b0f0daa18fee20b4120db2539/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/613c46fe9e39f55b0f0daa18fee20b4120db2539/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=613c46fe9e39f55b0f0daa18fee20b4120db2539",
        "patch": "@@ -77,7 +77,11 @@ bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIn\n     return false;\n }\n \n-static CChainState g_chainstate;\n+namespace {\n+BlockManager g_blockman;\n+} // anon namespace\n+\n+static CChainState g_chainstate(g_blockman);\n \n CChainState& ChainstateActive() { return g_chainstate; }\n \n@@ -95,7 +99,7 @@ CChain& ChainActive() { return g_chainstate.m_chain; }\n  */\n RecursiveMutex cs_main;\n \n-BlockMap& mapBlockIndex = ::ChainstateActive().mapBlockIndex;\n+BlockMap& mapBlockIndex = g_blockman.m_block_index;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n@@ -127,11 +131,6 @@ CScript COINBASE_FLAGS;\n namespace {\n     CBlockIndex *&pindexBestInvalid = ::ChainstateActive().pindexBestInvalid;\n \n-    /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n-     * Pruned nodes may have entries where B is missing data.\n-     */\n-    std::multimap<CBlockIndex*, CBlockIndex*>& mapBlocksUnlinked = ::ChainstateActive().mapBlocksUnlinked;\n-\n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n     int nLastBlockFile = 0;\n@@ -1160,7 +1159,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(c\n void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n     if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n-        m_failed_blocks.insert(pindex);\n+        m_blockman.m_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n@@ -1695,8 +1694,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         //  relative to a piece of software is an objective fact these defaults can be easily reviewed.\n         // This setting doesn't force the selection of any particular chain but makes validating some faster by\n         //  effectively caching the result of part of the verification.\n-        BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);\n-        if (it != mapBlockIndex.end()) {\n+        BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);\n+        if (it != m_blockman.m_block_index.end()) {\n             if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n@@ -2366,10 +2365,11 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n                     if (fFailedChain) {\n                         pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n                     } else if (fMissingData) {\n-                        // If we're missing data, then add back to mapBlocksUnlinked,\n+                        // If we're missing data, then add back to m_blocks_unlinked,\n                         // so that if the block arrives in the future we can try adding\n                         // to setBlockIndexCandidates again.\n-                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n+                        m_blockman.m_blocks_unlinked.insert(\n+                            std::make_pair(pindexFailed->pprev, pindexFailed));\n                     }\n                     setBlockIndexCandidates.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n@@ -2720,12 +2720,12 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         to_mark_failed->nStatus |= BLOCK_FAILED_VALID;\n         setDirtyBlockIndex.insert(to_mark_failed);\n         setBlockIndexCandidates.erase(to_mark_failed);\n-        m_failed_blocks.insert(to_mark_failed);\n+        m_blockman.m_failed_blocks.insert(to_mark_failed);\n \n         // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n         // add it again.\n-        BlockMap::iterator it = mapBlockIndex.begin();\n-        while (it != mapBlockIndex.end()) {\n+        BlockMap::iterator it = m_blockman.m_block_index.begin();\n+        while (it != m_blockman.m_block_index.end()) {\n             if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n@@ -2752,8 +2752,8 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     int nHeight = pindex->nHeight;\n \n     // Remove the invalidity flag from this block and all its descendants.\n-    BlockMap::iterator it = mapBlockIndex.begin();\n-    while (it != mapBlockIndex.end()) {\n+    BlockMap::iterator it = m_blockman.m_block_index.begin();\n+    while (it != m_blockman.m_block_index.end()) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(it->second);\n@@ -2764,7 +2764,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n-            m_failed_blocks.erase(it->second);\n+            m_blockman.m_failed_blocks.erase(it->second);\n         }\n         it++;\n     }\n@@ -2774,7 +2774,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n         if (pindex->nStatus & BLOCK_FAILED_MASK) {\n             pindex->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(pindex);\n-            m_failed_blocks.erase(pindex);\n+            m_blockman.m_failed_blocks.erase(pindex);\n         }\n         pindex = pindex->pprev;\n     }\n@@ -2784,14 +2784,14 @@ void ResetBlockFailureFlags(CBlockIndex *pindex) {\n     return ::ChainstateActive().ResetBlockFailureFlags(pindex);\n }\n \n-CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n+CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n {\n     AssertLockHeld(cs_main);\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n-    if (it != mapBlockIndex.end())\n+    BlockMap::iterator it = m_block_index.find(hash);\n+    if (it != m_block_index.end())\n         return it->second;\n \n     // Construct new block index object\n@@ -2800,10 +2800,10 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n-    if (miPrev != mapBlockIndex.end())\n+    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n+    if (miPrev != m_block_index.end())\n     {\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n@@ -2852,17 +2852,17 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n             if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = m_blockman.m_blocks_unlinked.equal_range(pindex);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n                 queue.push_back(it->second);\n                 range.first++;\n-                mapBlocksUnlinked.erase(it);\n+                m_blockman.m_blocks_unlinked.erase(it);\n             }\n         }\n     } else {\n         if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {\n-            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n+            m_blockman.m_blocks_unlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n         }\n     }\n }\n@@ -3230,15 +3230,15 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     return true;\n }\n \n-bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n+    BlockMap::iterator miSelf = m_block_index.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-        if (miSelf != mapBlockIndex.end()) {\n+        if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n             pindex = miSelf->second;\n             if (ppindex)\n@@ -3253,8 +3253,8 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi == mapBlockIndex.end())\n+        BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n+        if (mi == m_block_index.end())\n             return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n@@ -3306,8 +3306,6 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n     if (ppindex)\n         *ppindex = pindex;\n \n-    CheckBlockIndex(chainparams.GetConsensus());\n-\n     return true;\n }\n \n@@ -3319,7 +3317,10 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidatio\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n-            if (!::ChainstateActive().AcceptBlockHeader(header, state, chainparams, &pindex)) {\n+            bool accepted = g_blockman.AcceptBlockHeader(header, state, chainparams, &pindex);\n+            ::ChainstateActive().CheckBlockIndex(chainparams.GetConsensus());\n+\n+            if (!accepted) {\n                 if (first_invalid) *first_invalid = header;\n                 return false;\n             }\n@@ -3362,7 +3363,10 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n \n-    if (!AcceptBlockHeader(block, state, chainparams, &pindex))\n+    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, chainparams, &pindex);\n+    CheckBlockIndex(chainparams.GetConsensus());\n+\n+    if (!accepted_header)\n         return false;\n \n     // Try to process all requested blocks that we don't have, but only\n@@ -3513,7 +3517,7 @@ void PruneOneBlockFile(const int fileNumber)\n {\n     LOCK(cs_LastBlockFile);\n \n-    for (const auto& entry : mapBlockIndex) {\n+    for (const auto& entry : g_blockman.m_block_index) {\n         CBlockIndex* pindex = entry.second;\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n@@ -3523,16 +3527,16 @@ void PruneOneBlockFile(const int fileNumber)\n             pindex->nUndoPos = 0;\n             setDirtyBlockIndex.insert(pindex);\n \n-            // Prune from mapBlocksUnlinked -- any block we prune would have\n+            // Prune from m_blocks_unlinked -- any block we prune would have\n             // to be downloaded again in order to consider its chain, at which\n             // point it would be considered as a candidate for\n-            // mapBlocksUnlinked or setBlockIndexCandidates.\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);\n+            // m_blocks_unlinked or setBlockIndexCandidates.\n+            auto range = g_blockman.m_blocks_unlinked.equal_range(pindex->pprev);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n                 range.first++;\n                 if (_it->second == pindex) {\n-                    mapBlocksUnlinked.erase(_it);\n+                    g_blockman.m_blocks_unlinked.erase(_it);\n                 }\n             }\n         }\n@@ -3681,27 +3685,27 @@ fs::path GetBlockPosFilename(const FlatFilePos &pos)\n     return BlockFileSeq().FileName(pos);\n }\n \n-CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n+CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n \n     if (hash.IsNull())\n         return nullptr;\n \n     // Return existing\n-    BlockMap::iterator mi = mapBlockIndex.find(hash);\n-    if (mi != mapBlockIndex.end())\n+    BlockMap::iterator mi = m_block_index.find(hash);\n+    if (mi != m_block_index.end())\n         return (*mi).second;\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n     return pindexNew;\n }\n \n-bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree)\n+bool BlockManager::LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree)\n {\n     if (!blocktree.LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }))\n         return false;\n@@ -3729,7 +3733,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n                     pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n                 } else {\n                     pindex->nChainTx = 0;\n-                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));\n+                    m_blocks_unlinked.insert(std::make_pair(pindex->pprev, pindex));\n                 }\n             } else {\n                 pindex->nChainTx = pindex->nTx;\n@@ -3740,7 +3744,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n             setDirtyBlockIndex.insert(pindex);\n         }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))\n-            setBlockIndexCandidates.insert(pindex);\n+            ::ChainstateActive().setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n@@ -3752,9 +3756,20 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n     return true;\n }\n \n+void BlockManager::Unload() {\n+    m_failed_blocks.clear();\n+    m_blocks_unlinked.clear();\n+\n+    for (const BlockMap::value_type& entry : m_block_index) {\n+        delete entry.second;\n+    }\n+\n+    m_block_index.clear();\n+}\n+\n bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (!::ChainstateActive().LoadBlockIndex(chainparams.GetConsensus(), *pblocktree))\n+    if (!g_blockman.LoadBlockIndex(chainparams.GetConsensus(), *pblocktree))\n         return false;\n \n     // Load block file info\n@@ -4051,10 +4066,10 @@ void CChainState::EraseBlockData(CBlockIndex* index)\n     setDirtyBlockIndex.insert(index);\n     // Update indexes\n     setBlockIndexCandidates.erase(index);\n-    std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(index->pprev);\n+    auto ret = m_blockman.m_blocks_unlinked.equal_range(index->pprev);\n     while (ret.first != ret.second) {\n         if (ret.first->second == index) {\n-            mapBlocksUnlinked.erase(ret.first++);\n+            m_blockman.m_blocks_unlinked.erase(ret.first++);\n         } else {\n             ++ret.first;\n         }\n@@ -4180,7 +4195,6 @@ bool RewindBlockIndex(const CChainParams& params) {\n \n void CChainState::UnloadBlockIndex() {\n     nBlockSequenceId = 1;\n-    m_failed_blocks.clear();\n     setBlockIndexCandidates.clear();\n }\n \n@@ -4191,10 +4205,10 @@ void UnloadBlockIndex()\n {\n     LOCK(cs_main);\n     ::ChainActive().SetTip(nullptr);\n+    g_blockman.Unload();\n     pindexBestInvalid = nullptr;\n     pindexBestHeader = nullptr;\n     mempool.clear();\n-    mapBlocksUnlinked.clear();\n     vinfoBlockFile.clear();\n     nLastBlockFile = 0;\n     setDirtyBlockIndex.clear();\n@@ -4203,11 +4217,6 @@ void UnloadBlockIndex()\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();\n     }\n-\n-    for (const BlockMap::value_type& entry : mapBlockIndex) {\n-        delete entry.second;\n-    }\n-    mapBlockIndex.clear();\n     fHavePruned = false;\n \n     ::ChainstateActive().UnloadBlockIndex();\n@@ -4251,7 +4260,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n         FlatFilePos blockPos = SaveBlockToDisk(block, 0, chainparams, nullptr);\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n-        CBlockIndex *pindex = AddToBlockIndex(block);\n+        CBlockIndex *pindex = m_blockman.AddToBlockIndex(block);\n         ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n     } catch (const std::runtime_error& e) {\n         return error(\"%s: failed to write genesis block: %s\", __func__, e.what());\n@@ -4482,13 +4491,13 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n                 }\n                 // If some parent is missing, then it could be that this block was in\n                 // setBlockIndexCandidates but had to be removed because of the missing data.\n-                // In this case it must be in mapBlocksUnlinked -- see test below.\n+                // In this case it must be in m_blocks_unlinked -- see test below.\n             }\n         } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n-        // Check whether this block is in mapBlocksUnlinked.\n-        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);\n+        // Check whether this block is in m_blocks_unlinked.\n+        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = m_blockman.m_blocks_unlinked.equal_range(pindex->pprev);\n         bool foundInUnlinked = false;\n         while (rangeUnlinked.first != rangeUnlinked.second) {\n             assert(rangeUnlinked.first->first == pindex->pprev);\n@@ -4499,22 +4508,22 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             rangeUnlinked.first++;\n         }\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != nullptr && pindexFirstInvalid == nullptr) {\n-            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n+            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in m_blocks_unlinked.\n             assert(foundInUnlinked);\n         }\n-        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA\n-        if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n+        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in m_blocks_unlinked if we don't HAVE_DATA\n+        if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {\n             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n             assert(fHavePruned); // We must have pruned.\n-            // This block may have entered mapBlocksUnlinked if:\n+            // This block may have entered m_blocks_unlinked if:\n             //  - it has a descendant that at some point had more work than the\n             //    tip, and\n             //  - we tried switching to that descendant but were missing\n             //    data for some intermediate block between m_chain and the\n             //    tip.\n             // So if this block is itself better than m_chain.Tip() and it wasn't in\n-            // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.\n+            // setBlockIndexCandidates, then it must be in m_blocks_unlinked.\n             if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n                 if (pindexFirstInvalid == nullptr) {\n                     assert(foundInUnlinked);"
      },
      {
        "sha": "09afbf7b101c073ab7a15b5579953470de211030",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 81,
        "deletions": 47,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/613c46fe9e39f55b0f0daa18fee20b4120db2539/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/613c46fe9e39f55b0f0daa18fee20b4120db2539/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=613c46fe9e39f55b0f0daa18fee20b4120db2539",
        "patch": "@@ -439,27 +439,80 @@ struct CBlockIndexWorkComparator\n };\n \n /**\n- * CChainState stores and provides an API to update our local knowledge of the\n- * current best chain and header tree.\n+ * Maintains a tree of blocks (stored in `m_block_index`) which is consulted\n+ * to determine where the most-work tip is.\n  *\n- * It generally provides access to the current block tree, as well as functions\n- * to provide new data, which it will appropriately validate and incorporate in\n- * its state as necessary.\n+ * This data is used mostly in `CChainState` - information about, e.g.,\n+ * candidate tips is not maintained here.\n+ */\n+class BlockManager {\n+public:\n+    BlockMap m_block_index GUARDED_BY(cs_main);\n+\n+    /** In order to efficiently track invalidity of headers, we keep the set of\n+      * blocks which we tried to connect and found to be invalid here (ie which\n+      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n+      * walk this set and check if a new header is a descendant of something in\n+      * this set, preventing us from having to walk m_block_index when we try\n+      * to connect a bad block and fail.\n+      *\n+      * While this is more complicated than marking everything which descends\n+      * from an invalid block as invalid at the time we discover it to be\n+      * invalid, doing so would require walking all of m_block_index to find all\n+      * descendants. Since this case should be very rare, keeping track of all\n+      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n+      * well.\n+      *\n+      * Because we already walk m_block_index in height-order at startup, we go\n+      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n+      * instead of putting things in this set.\n+      */\n+    std::set<CBlockIndex*> m_failed_blocks;\n+\n+    /**\n+     * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n+     * Pruned nodes may have entries where B is missing data.\n+     */\n+    std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n+\n+    bool LoadBlockIndex(\n+        const Consensus::Params& consensus_params,\n+        CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Clear all data members. */\n+    void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Create a new block index entry for a given block hash */\n+    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /**\n+     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n+     * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n+     */\n+    bool AcceptBlockHeader(\n+        const CBlockHeader& block,\n+        CValidationState& state,\n+        const CChainParams& chainparams,\n+        CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+};\n+\n+/**\n+ * CChainState stores and provides an API to update our local knowledge of the\n+ * current best chain.\n  *\n  * Eventually, the API here is targeted at being exposed externally as a\n  * consumable libconsensus library, so any functions added must only call\n  * other class member functions, pure functions in other parts of the consensus\n  * library, callbacks via the validation interface, or read/write-to-disk\n  * functions (eventually this will also be via callbacks).\n+ *\n+ * Anything that is contingent on the current tip of the chain is stored here,\n+ * whereas block information and metadata independent of the current tip is\n+ * kept in `BlockMetadataManager`.\n  */\n class CChainState {\n private:\n-    /**\n-     * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n-     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n-     * missing the data for the block.\n-     */\n-    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n     /**\n      * Every received block is assigned a unique and increasing identifier, so we\n@@ -473,26 +526,6 @@ class CChainState {\n     /** chainwork for the last block that preciousblock has been applied to. */\n     arith_uint256 nLastPreciousChainwork = 0;\n \n-    /** In order to efficiently track invalidity of headers, we keep the set of\n-      * blocks which we tried to connect and found to be invalid here (ie which\n-      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n-      * walk this set and check if a new header is a descendant of something in\n-      * this set, preventing us from having to walk mapBlockIndex when we try\n-      * to connect a bad block and fail.\n-      *\n-      * While this is more complicated than marking everything which descends\n-      * from an invalid block as invalid at the time we discover it to be\n-      * invalid, doing so would require walking all of mapBlockIndex to find all\n-      * descendants. Since this case should be very rare, keeping track of all\n-      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n-      * well.\n-      *\n-      * Because we already walk mapBlockIndex in height-order at startup, we go\n-      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n-      * instead of putting things in this set.\n-      */\n-    std::set<CBlockIndex*> m_failed_blocks;\n-\n     /**\n      * the ChainState CriticalSection\n      * A lock that must be held when modifying this ChainState - held in ActivateBestChain()\n@@ -507,15 +540,24 @@ class CChainState {\n      */\n     mutable std::atomic<bool> m_cached_finished_ibd{false};\n \n+    //! Reference to a BlockManager instance which itself is shared across all\n+    //! CChainState instances. Keeping a local reference allows us to test more\n+    //! easily as opposed to referencing a global.\n+    BlockManager& m_blockman;\n+\n public:\n+    CChainState(BlockManager& blockman) : m_blockman(blockman) { }\n+\n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n     CChain m_chain;\n-    BlockMap mapBlockIndex GUARDED_BY(cs_main);\n-    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n     CBlockIndex *pindexBestInvalid = nullptr;\n-\n-    bool LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /**\n+     * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n+     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n+     * missing the data for the block.\n+     */\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n     /**\n      * Update the on-disk chain state.\n@@ -541,11 +583,6 @@ class CChainState {\n \n     bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) LOCKS_EXCLUDED(cs_main);\n \n-    /**\n-     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n-     * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n-     */\n-    bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Block (dis)connection on a given view:\n@@ -572,20 +609,17 @@ class CChainState {\n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n \n-private:\n-    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n-    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n-\n-    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /** Create a new block index entry for a given block hash */\n-    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /**\n      * Make various assertions about the state of the block index.\n      *\n      * By default this only executes fully when using the Regtest chain; see: fCheckBlockIndex.\n      */\n     void CheckBlockIndex(const Consensus::Params& consensusParams);\n \n+private:\n+    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+\n     void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  },
  {
    "sha": "4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWQ1NWRmY2Q3ODk0ZmQ1YmE2Mzk1ZjI0NGExN2FiMWY4ZTc4NmQ0",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-06-24T19:22:33Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-08T15:33:12Z"
      },
      "message": "refactoring: add block_index_candidates arg to LoadBlockIndex\n\nPrevents BlockManager from having to reference ChainstateActive()\nwithin one of its methods which improves encapsulation and makes\ntesting easier.",
      "tree": {
        "sha": "08cf711fb536abef170886660f3d5fa6ffd0592d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/08cf711fb536abef170886660f3d5fa6ffd0592d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "613c46fe9e39f55b0f0daa18fee20b4120db2539",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/613c46fe9e39f55b0f0daa18fee20b4120db2539",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/613c46fe9e39f55b0f0daa18fee20b4120db2539"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 20,
      "deletions": 5
    },
    "files": [
      {
        "sha": "3e71928d172ee6669c41e79cce0b0d6f4b991c2a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
        "patch": "@@ -3705,7 +3705,10 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n     return pindexNew;\n }\n \n-bool BlockManager::LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree)\n+bool BlockManager::LoadBlockIndex(\n+    const Consensus::Params& consensus_params,\n+    CBlockTreeDB& blocktree,\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n {\n     if (!blocktree.LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }))\n         return false;\n@@ -3743,8 +3746,9 @@ bool BlockManager::LoadBlockIndex(const Consensus::Params& consensus_params, CBl\n             pindex->nStatus |= BLOCK_FAILED_CHILD;\n             setDirtyBlockIndex.insert(pindex);\n         }\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))\n-            ::ChainstateActive().setBlockIndexCandidates.insert(pindex);\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr)) {\n+            block_index_candidates.insert(pindex);\n+        }\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n@@ -3769,7 +3773,8 @@ void BlockManager::Unload() {\n \n bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (!g_blockman.LoadBlockIndex(chainparams.GetConsensus(), *pblocktree))\n+    if (!g_blockman.LoadBlockIndex(\n+            chainparams.GetConsensus(), *pblocktree, ::ChainstateActive().setBlockIndexCandidates))\n         return false;\n \n     // Load block file info"
      },
      {
        "sha": "ab18f662a407acfa5985cb6d5c5817e1249e1485",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
        "patch": "@@ -475,9 +475,19 @@ class BlockManager {\n      */\n     std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n \n+    /**\n+     * Load the blocktree off disk and into memory. Populate certain metadata\n+     * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n+     * collections like setDirtyBlockIndex.\n+     *\n+     * @param[out] block_index_candidates  Fill this set with any valid blocks for\n+     *                                     which we've downloaded all transactions.\n+     */\n     bool LoadBlockIndex(\n         const Consensus::Params& consensus_params,\n-        CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+        CBlockTreeDB& blocktree,\n+        std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n+        EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Clear all data members. */\n     void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  },
  {
    "sha": "55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NWQ1MjVhYjkwMDQ2MzFkMzBkY2M2MGExZWM1ZDljZDZjNmFmZTU2",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-06-24T17:57:01Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-08T15:33:13Z"
      },
      "message": "refactoring: make pindexBestInvalid internal to validation.cpp\n\nThere's no need to have this member live on CChainState since it's only used\nin validation.cpp.",
      "tree": {
        "sha": "5ee99567d2d6de74378b5db890823cbdfb27bf98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ee99567d2d6de74378b5db890823cbdfb27bf98"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ed55dfcd7894fd5ba6395f244a17ab1f8e786d4"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "0a84a0eec2fbca9683653d66e05d0a3d60af10a6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
        "patch": "@@ -129,7 +129,7 @@ CScript COINBASE_FLAGS;\n \n // Internal stuff\n namespace {\n-    CBlockIndex *&pindexBestInvalid = ::ChainstateActive().pindexBestInvalid;\n+    CBlockIndex* pindexBestInvalid = nullptr;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;"
      },
      {
        "sha": "4e971901b8b54d961a80f784958a6ba1b6ae4b01",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
        "patch": "@@ -561,7 +561,6 @@ class CChainState {\n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n     CChain m_chain;\n-    CBlockIndex *pindexBestInvalid = nullptr;\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be"
      }
    ]
  },
  {
    "sha": "682a1d0f2004d808b87b3106d0dfae547005e638",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODJhMWQwZjIwMDRkODA4Yjg3YjMxMDZkMGRmYWU1NDcwMDVlNjM4",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-04-10T18:34:46Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-08T15:33:13Z"
      },
      "message": "refactoring: remove mapBlockIndex global\n\nin lieu of ::BlockIndex().",
      "tree": {
        "sha": "33d9bcfcc7dd0614af9a379420a5a698b29cf7be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33d9bcfcc7dd0614af9a379420a5a698b29cf7be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/682a1d0f2004d808b87b3106d0dfae547005e638",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/682a1d0f2004d808b87b3106d0dfae547005e638",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/682a1d0f2004d808b87b3106d0dfae547005e638",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/682a1d0f2004d808b87b3106d0dfae547005e638/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/55d525ab9004631d30dcc60a1ec5d9cd6c6afe56"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 48,
      "deletions": 39
    },
    "files": [
      {
        "sha": "3ad94ed1c311837250b7002cbcfaf7cba4a2f33b",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -492,7 +492,7 @@ void SetupServerArgs()\n         \"and level 4 tries to reconnect the blocks, \"\n         \"each level includes the checks of the previous levels \"\n         \"(0-4, default: %u)\", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);\n-    gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, ::ChainActive() and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for the block tree, setBlockIndexCandidates, ::ChainActive() and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u, regtest: %u)\", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\", true, OptionsCategory::DEBUG_TEST);\n@@ -1517,7 +1517,8 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n+                if (!::BlockIndex().empty() &&\n+                        !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n                 }\n \n@@ -1538,7 +1539,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n                 }\n \n                 // At this point we're either in reindex or we've loaded a useful\n-                // block tree into mapBlockIndex!\n+                // block tree into BlockIndex()!\n \n                 pcoinsdbview.reset(new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState));\n                 pcoinscatcher.reset(new CCoinsViewErrorCatcher(pcoinsdbview.get()));\n@@ -1577,7 +1578,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n             if (!fReset) {\n                 // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n                 // It both disconnects blocks based on ::ChainActive(), and drops block data in\n-                // mapBlockIndex based on lack of available witness data.\n+                // BlockIndex() based on lack of available witness data.\n                 uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                 if (!RewindBlockIndex(chainparams)) {\n                     strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n@@ -1749,7 +1750,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n     //// debug print\n     {\n         LOCK(cs_main);\n-        LogPrintf(\"mapBlockIndex.size() = %u\\n\", mapBlockIndex.size());\n+        LogPrintf(\"block tree size = %u\\n\", ::BlockIndex().size());\n         chain_active_height = ::ChainActive().Height();\n     }\n     LogPrintf(\"nBestHeight = %d\\n\", chain_active_height);"
      },
      {
        "sha": "b1027dffdbda5d2bee57495bcc41854f85d02176",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -1456,15 +1456,15 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     /*\n      * Idea:  the set of chain tips is ::ChainActive().tip, plus orphan blocks which do not have another orphan building off of them.\n      * Algorithm:\n-     *  - Make one pass through mapBlockIndex, picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n+     *  - Make one pass through g_blockman.m_block_index, picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n      *  - Iterate through the orphan blocks. If the block isn't pointed to by another orphan, it is a chain tip.\n      *  - add ::ChainActive().Tip()\n      */\n     std::set<const CBlockIndex*, CompareBlocksByHeight> setTips;\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : ::BlockIndex())\n     {\n         if (!::ChainActive().Contains(item.second)) {\n             setOrphans.insert(item.second);"
      },
      {
        "sha": "90b92969b9e27bd233758755149feab6066c176b",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -250,7 +250,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts(const Consensus::Params& consensusParams,\n \n     pcursor->Seek(std::make_pair(DB_BLOCK_INDEX, uint256()));\n \n-    // Load mapBlockIndex\n+    // Load m_block_index\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n         if (ShutdownRequested()) return false;"
      },
      {
        "sha": "0bc6167bad1ec3a1642a3ca3df09a54368b64b90",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 22,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -99,7 +99,6 @@ CChain& ChainActive() { return g_chainstate.m_chain; }\n  */\n RecursiveMutex cs_main;\n \n-BlockMap& mapBlockIndex = g_blockman.m_block_index;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n@@ -147,6 +146,13 @@ namespace {\n     std::set<int> setDirtyFileInfo;\n } // anon namespace\n \n+CBlockIndex* LookupBlockIndex(const uint256& hash)\n+{\n+    AssertLockHeld(cs_main);\n+    BlockMap::const_iterator it = g_blockman.m_block_index.find(hash);\n+    return it == g_blockman.m_block_index.end() ? nullptr : it->second;\n+}\n+\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n     AssertLockHeld(cs_main);\n@@ -1046,6 +1052,11 @@ bool CChainState::IsInitialBlockDownload() const\n \n static CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n \n+BlockMap& BlockIndex()\n+{\n+    return g_blockman.m_block_index;\n+}\n+\n static void AlertNotify(const std::string& strMessage)\n {\n     uiInterface.NotifyAlertChanged();\n@@ -3117,7 +3128,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     if (fCheckpointsEnabled) {\n         // Don't accept any forks from the main chain prior to last checkpoint.\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n-        // MapBlockIndex.\n+        // g_blockman.m_block_index.\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n             return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n@@ -3715,8 +3726,8 @@ bool BlockManager::LoadBlockIndex(\n \n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n-    vSortedByHeight.reserve(mapBlockIndex.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n+    vSortedByHeight.reserve(m_block_index.size());\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n     {\n         CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n@@ -3797,7 +3808,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_RE\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : g_blockman.m_block_index)\n     {\n         CBlockIndex* pindex = item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n@@ -3996,16 +4007,16 @@ bool CChainState::ReplayBlocks(const CChainParams& params, CCoinsView* view)\n     const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n     const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n \n-    if (mapBlockIndex.count(hashHeads[0]) == 0) {\n+    if (m_blockman.m_block_index.count(hashHeads[0]) == 0) {\n         return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n     }\n-    pindexNew = mapBlockIndex[hashHeads[0]];\n+    pindexNew = m_blockman.m_block_index[hashHeads[0]];\n \n     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n-        if (mapBlockIndex.count(hashHeads[1]) == 0) {\n+        if (m_blockman.m_block_index.count(hashHeads[1]) == 0) {\n             return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n         }\n-        pindexOld = mapBlockIndex[hashHeads[1]];\n+        pindexOld = m_blockman.m_block_index[hashHeads[1]];\n         pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n         assert(pindexFork != nullptr);\n     }\n@@ -4094,7 +4105,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     // blocks will be dealt with below (releasing cs_main in between).\n     {\n         LOCK(cs_main);\n-        for (const auto& entry : mapBlockIndex) {\n+        for (const auto& entry : m_blockman.m_block_index) {\n             if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n                 EraseBlockData(entry.second);\n             }\n@@ -4234,7 +4245,7 @@ bool LoadBlockIndex(const CChainParams& chainparams)\n     if (!fReindex) {\n         bool ret = LoadBlockIndexDB(chainparams);\n         if (!ret) return false;\n-        needs_init = mapBlockIndex.empty();\n+        needs_init = g_blockman.m_block_index.empty();\n     }\n \n     if (needs_init) {\n@@ -4254,10 +4265,10 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n     LOCK(cs_main);\n \n     // Check whether we're already initialized by checking for genesis in\n-    // mapBlockIndex. Note that we can't use m_chain here, since it is\n+    // m_blockman.m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n-    if (mapBlockIndex.count(chainparams.GenesisBlock().GetHash()))\n+    if (m_blockman.m_block_index.count(chainparams.GenesisBlock().GetHash()))\n         return true;\n \n     try {\n@@ -4410,20 +4421,20 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n     LOCK(cs_main);\n \n     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,\n-    // so we have the genesis block in mapBlockIndex but no active chain.  (A few of the tests when\n-    // iterating the block tree require that m_chain has been initialized.)\n+    // so we have the genesis block in m_blockman.m_block_index but no active chain. (A few of the\n+    // tests when iterating the block tree require that m_chain has been initialized.)\n     if (m_chain.Height() < 0) {\n-        assert(mapBlockIndex.size() <= 1);\n+        assert(m_blockman.m_block_index.size() <= 1);\n         return;\n     }\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {\n+    for (const std::pair<const uint256, CBlockIndex*>& entry : m_blockman.m_block_index) {\n         forward.insert(std::make_pair(entry.second->pprev, entry.second));\n     }\n \n-    assert(forward.size() == mapBlockIndex.size());\n+    assert(forward.size() == m_blockman.m_block_index.size());\n \n     std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(nullptr);\n     CBlockIndex *pindex = rangeGenesis.first->second;\n@@ -4477,7 +4488,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n         assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.\n-        assert(pindexFirstNotTreeValid == nullptr); // All mapBlockIndex entries must at least be TREE valid\n+        assert(pindexFirstNotTreeValid == nullptr); // All m_blockman.m_block_index entries must at least be TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == nullptr); // TREE valid implies all parents are TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_CHAIN) assert(pindexFirstNotChainValid == nullptr); // CHAIN valid implies all parents are CHAIN valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == nullptr); // SCRIPTS valid implies all parents are SCRIPTS valid\n@@ -4772,10 +4783,10 @@ class CMainCleanup\n     CMainCleanup() {}\n     ~CMainCleanup() {\n         // block headers\n-        BlockMap::iterator it1 = mapBlockIndex.begin();\n-        for (; it1 != mapBlockIndex.end(); it1++)\n+        BlockMap::iterator it1 = g_blockman.m_block_index.begin();\n+        for (; it1 != g_blockman.m_block_index.end(); it1++)\n             delete (*it1).second;\n-        mapBlockIndex.clear();\n+        g_blockman.m_block_index.clear();\n     }\n };\n static CMainCleanup instance_of_cmaincleanup;"
      },
      {
        "sha": "a1b8029e0114333b84f95733eeb07fc0c4afb7bb",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -144,7 +144,6 @@ extern CCriticalSection cs_main;\n extern CBlockPolicyEstimator feeEstimator;\n extern CTxMemPool mempool;\n typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n-extern BlockMap& mapBlockIndex GUARDED_BY(cs_main);\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n extern uint256 g_best_block;\n@@ -406,12 +405,7 @@ class CVerifyDB {\n /** Replay blocks that aren't fully applied to the database. */\n bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n \n-inline CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    AssertLockHeld(cs_main);\n-    BlockMap::const_iterator it = mapBlockIndex.find(hash);\n-    return it == mapBlockIndex.end() ? nullptr : it->second;\n-}\n+CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -498,7 +492,7 @@ class BlockManager {\n \n     /**\n      * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n-     * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n+     * that it doesn't descend from an invalid block, and then add it to m_block_index.\n      */\n     bool AcceptBlockHeader(\n         const CBlockHeader& block,\n@@ -658,6 +652,9 @@ CChainState& ChainstateActive();\n /** @returns the most-work chain. */\n CChain& ChainActive();\n \n+/** @returns the global block index map. */\n+BlockMap& BlockIndex();\n+\n /** Global variable that points to the coins database (protected by cs_main) */\n extern std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n "
      },
      {
        "sha": "c7a39af8108f805537889da949e4d3d8a31ca95b",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/682a1d0f2004d808b87b3106d0dfae547005e638/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/682a1d0f2004d808b87b3106d0dfae547005e638/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=682a1d0f2004d808b87b3106d0dfae547005e638",
        "patch": "@@ -272,7 +272,7 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     if (blockTime > 0) {\n         auto locked_chain = wallet.chain().lock();\n         LockAssertion lock(::cs_main);\n-        auto inserted = mapBlockIndex.emplace(GetRandHash(), new CBlockIndex);\n+        auto inserted = ::BlockIndex().emplace(GetRandHash(), new CBlockIndex);\n         assert(inserted.second);\n         const uint256& hash = inserted.first->first;\n         block = inserted.first->second;"
      }
    ]
  }
]