[
  {
    "sha": "664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NjQyOTllYzNiMjRiNGU3NmNhMmFkYjMzZDMxZjZkY2VjNTNlMThm",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2017-05-07T03:27:46Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2017-05-08T02:57:57Z"
      },
      "message": "Refactor script interpreter flags to use new CScriptFlags class for stricter checking",
      "tree": {
        "sha": "769cd5cb9f307c3cc31b3925102d1a8cc2245158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/769cd5cb9f307c3cc31b3925102d1a8cc2245158"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "170bc2c381f86a523de2fc8b71d62ade66303c0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/170bc2c381f86a523de2fc8b71d62ade66303c0d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/170bc2c381f86a523de2fc8b71d62ade66303c0d"
      }
    ],
    "stats": {
      "total": 399,
      "additions": 230,
      "deletions": 169
    },
    "files": [
      {
        "sha": "2975c714bedff0a5c30495b2cbdf3bbafdb804b3",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -50,7 +50,7 @@ static CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, co\n // modified to measure performance of other types of scripts.\n static void VerifyScriptBench(benchmark::State& state)\n {\n-    const int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n+    CScriptFlags flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n     const int witnessversion = 0;\n \n     // Keypair.\n@@ -93,7 +93,7 @@ static void VerifyScriptBench(benchmark::State& state)\n             txCredit.vout[0].scriptPubKey.data(),\n             txCredit.vout[0].scriptPubKey.size(),\n             txCredit.vout[0].nValue,\n-            (const unsigned char*)stream.data(), stream.size(), 0, flags, nullptr);\n+            (const unsigned char*)stream.data(), stream.size(), 0, flags.ToBitfieldInt(), nullptr);\n         assert(csuccess == 1);\n #endif\n     }"
      },
      {
        "sha": "f654ab0777febe37223ca690a849cc69b75e353f",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -49,7 +49,7 @@ static const unsigned int DUST_RELAY_TX_FEE = 1000;\n  * with. However scripts violating these flags may still be present in valid\n  * blocks and we must accept those blocks.\n  */\n-static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n+static const CScriptFlags STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n                                                          SCRIPT_VERIFY_DERSIG |\n                                                          SCRIPT_VERIFY_STRICTENC |\n                                                          SCRIPT_VERIFY_MINIMALDATA |\n@@ -66,7 +66,7 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_WITNESS_PUBKEYTYPE;\n \n /** For convenience, standard but not mandatory verify flags. */\n-static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n+static const CScriptFlags STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS.WithFlagsCleared(MANDATORY_SCRIPT_VERIFY_FLAGS);\n \n /** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |"
      },
      {
        "sha": "af3eca47fa8fae810377916559a4cc5ef417b31e",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -71,14 +71,14 @@ ECCryptoClosure instance_of_eccryptoclosure;\n }\n \n /** Check that all specified flags are part of the libconsensus interface. */\n-static bool verify_flags(unsigned int flags)\n+static bool verify_flags(uint64_t flags)\n {\n     return (flags & ~(bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n }\n \n static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+                                    unsigned int nIn, uint64_t flags, bitcoinconsensus_error* err)\n {\n     if (!verify_flags(flags)) {\n         return bitcoinconsensus_ERR_INVALID_FLAGS;\n@@ -95,7 +95,7 @@ static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptP\n         set_error(err, bitcoinconsensus_ERR_OK);\n \n         PrecomputedTransactionData txdata(tx);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, CScriptFlags::FromBitfieldInt(flags), TransactionSignatureChecker(&tx, nIn, amount, txdata), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "8f2065fb7dad3c6aabf0b651e2f005c0718cdd6f",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -72,6 +72,8 @@ EXPORT_SYMBOL int bitcoinconsensus_verify_script_with_amount(const unsigned char\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);\n \n+// TODO: flags should be made uint64_t when ABI is changed or new APIs added\n+\n EXPORT_SYMBOL unsigned int bitcoinconsensus_version();\n \n #ifdef __cplusplus"
      },
      {
        "sha": "0b373114082fa37e2d4dcd3be64061707da0397e",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 36,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -192,29 +192,29 @@ bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n     return true;\n }\n \n-bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror) {\n+bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, const CScriptFlags flags, ScriptError* serror) {\n     // Empty signature. Not strictly DER encoded, but allowed to provide a\n     // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n     if (vchSig.size() == 0) {\n         return true;\n     }\n-    if ((flags & (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 && !IsValidSignatureEncoding(vchSig)) {\n+    if (flags.IsAtLeastOneSet(SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC) && !IsValidSignatureEncoding(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_SIG_DER);\n-    } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig, serror)) {\n+    } else if (flags.IsSet(SCRIPT_VERIFY_LOW_S) && !IsLowDERSignature(vchSig, serror)) {\n         // serror is set\n         return false;\n-    } else if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsDefinedHashtypeSignature(vchSig)) {\n+    } else if (flags.IsSet(SCRIPT_VERIFY_STRICTENC) != 0 && !IsDefinedHashtypeSignature(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_SIG_HASHTYPE);\n     }\n     return true;\n }\n \n-bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, const SigVersion &sigversion, ScriptError* serror) {\n-    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchPubKey)) {\n+bool static CheckPubKeyEncoding(const valtype &vchPubKey, const CScriptFlags flags, const SigVersion &sigversion, ScriptError* serror) {\n+    if (flags.IsSet(SCRIPT_VERIFY_STRICTENC) && !IsCompressedOrUncompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     // Only compressed keys are accepted in segwit\n-    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+    if (flags.IsSet(SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n     }\n     return true;\n@@ -243,7 +243,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CScriptFlags flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -264,7 +264,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     if (script.size() > MAX_SCRIPT_SIZE)\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n     int nOpCount = 0;\n-    bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    bool fRequireMinimal = flags.IsSet(SCRIPT_VERIFY_MINIMALDATA);\n \n     try\n     {\n@@ -347,9 +347,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n \n                 case OP_CHECKLOCKTIMEVERIFY:\n                 {\n-                    if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n+                    if (!flags.IsSet(SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n                         // not enabled; treat as a NOP2\n-                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                        if (flags.IsSet(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)) {\n                             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n                         }\n                         break;\n@@ -389,9 +389,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n \n                 case OP_CHECKSEQUENCEVERIFY:\n                 {\n-                    if (!(flags & SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n+                    if (!flags.IsSet(SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n                         // not enabled; treat as a NOP3\n-                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                        if (flags.IsSet(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)) {\n                             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n                         }\n                         break;\n@@ -427,8 +427,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 case OP_NOP1: case OP_NOP4: case OP_NOP5:\n                 case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                 {\n-                    if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n+                    if (flags.IsSet(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)) {\n                         return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                    }\n                 }\n                 break;\n \n@@ -442,7 +443,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SIGVERSION_WITNESS_V0 && flags.IsSet(SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -899,8 +900,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     }\n                     bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n \n-                    if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n+                    if (!fSuccess && flags.IsSet(SCRIPT_VERIFY_NULLFAIL) && vchSig.size()) {\n                         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                    }\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -992,8 +994,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     // Clean up stack of actual arguments\n                     while (i-- > 1) {\n                         // If the operation failed, we require that all signatures must be empty vector\n-                        if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && !ikey2 && stacktop(-1).size())\n+                        if (!fSuccess && flags.IsSet(SCRIPT_VERIFY_NULLFAIL) && !ikey2 && stacktop(-1).size()) {\n                             return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                        }\n                         if (ikey2 > 0)\n                             ikey2--;\n                         popstack(stack);\n@@ -1007,8 +1010,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     // to removing it from the stack.\n                     if (stack.size() < 1)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n-                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n+                    if (flags.IsSet(SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size()) {\n                         return set_error(serror, SCRIPT_ERR_SIG_NULLDUMMY);\n+                    }\n                     popstack(stack);\n \n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -1351,7 +1355,7 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, const CScriptFlags flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     std::vector<std::vector<unsigned char> > stack;\n     CScript scriptPubKey;\n@@ -1379,7 +1383,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n-    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n+    } else if (flags.IsSet(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\n         return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n     } else {\n         // Higher version witness scripts return true for future softfork compatibility\n@@ -1404,7 +1408,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, const CScriptFlags flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     static const CScriptWitness emptyWitness;\n     if (witness == NULL) {\n@@ -1414,16 +1418,17 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n \n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n \n-    if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n+    if (flags.IsSet(SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n         return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n     std::vector<std::vector<unsigned char> > stack, stackCopy;\n     if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n-    if (flags & SCRIPT_VERIFY_P2SH)\n+    if (flags.IsSet(SCRIPT_VERIFY_P2SH)) {\n         stackCopy = stack;\n+    }\n     if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n@@ -1435,7 +1440,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     // Bare witness programs\n     int witnessversion;\n     std::vector<unsigned char> witnessprogram;\n-    if (flags & SCRIPT_VERIFY_WITNESS) {\n+    if (flags.IsSet(SCRIPT_VERIFY_WITNESS)) {\n         if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n             hadWitness = true;\n             if (scriptSig.size() != 0) {\n@@ -1452,8 +1457,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     // Additional validation for spend-to-script-hash transactions:\n-    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n-    {\n+    if (flags.IsSet(SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash()) {\n         // scriptSig must be literals-only or validation fails\n         if (!scriptSig.IsPushOnly())\n             return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n@@ -1479,7 +1483,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n             return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n         // P2SH witness program\n-        if (flags & SCRIPT_VERIFY_WITNESS) {\n+        if (flags.IsSet(SCRIPT_VERIFY_WITNESS)) {\n             if (pubKey2.IsWitnessProgram(witnessversion, witnessprogram)) {\n                 hadWitness = true;\n                 if (scriptSig != CScript() << std::vector<unsigned char>(pubKey2.begin(), pubKey2.end())) {\n@@ -1500,21 +1504,21 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     // The CLEANSTACK check is only performed after potential P2SH evaluation,\n     // as the non-P2SH evaluation of a P2SH script will obviously not result in\n     // a clean stack (the P2SH inputs remain). The same holds for witness evaluation.\n-    if ((flags & SCRIPT_VERIFY_CLEANSTACK) != 0) {\n+    if (flags.IsSet(SCRIPT_VERIFY_CLEANSTACK)) {\n         // Disallow CLEANSTACK without P2SH, as otherwise a switch CLEANSTACK->P2SH+CLEANSTACK\n         // would be possible, which is not a softfork (and P2SH should be one).\n-        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n-        assert((flags & SCRIPT_VERIFY_WITNESS) != 0);\n+        assert(flags.IsSet(SCRIPT_VERIFY_P2SH));\n+        assert(flags.IsSet(SCRIPT_VERIFY_WITNESS));\n         if (stack.size() != 1) {\n             return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n         }\n     }\n \n-    if (flags & SCRIPT_VERIFY_WITNESS) {\n+    if (flags.IsSet(SCRIPT_VERIFY_WITNESS)) {\n         // We can't check for correct unexpected witness data if P2SH was off, so require\n         // that WITNESS implies P2SH. Otherwise, going from WITNESS->P2SH+WITNESS would be\n         // possible, which is not a softfork.\n-        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+        assert(flags.IsSet(SCRIPT_VERIFY_P2SH));\n         if (!hadWitness && !witness->IsNull()) {\n             return set_error(serror, SCRIPT_ERR_WITNESS_UNEXPECTED);\n         }\n@@ -1523,7 +1527,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     return set_success(serror);\n }\n \n-size_t static WitnessSigOps(int witversion, const std::vector<unsigned char>& witprogram, const CScriptWitness& witness, int flags)\n+size_t static WitnessSigOps(int witversion, const std::vector<unsigned char>& witprogram, const CScriptWitness& witness, CScriptFlags flags)\n {\n     if (witversion == 0) {\n         if (witprogram.size() == 20)\n@@ -1539,14 +1543,14 @@ size_t static WitnessSigOps(int witversion, const std::vector<unsigned char>& wi\n     return 0;\n }\n \n-size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags)\n+size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, CScriptFlags flags)\n {\n     static const CScriptWitness witnessEmpty;\n \n-    if ((flags & SCRIPT_VERIFY_WITNESS) == 0) {\n+    if (!flags.IsSet(SCRIPT_VERIFY_WITNESS)) {\n         return 0;\n     }\n-    assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+    assert(flags.IsSet(SCRIPT_VERIFY_P2SH));\n \n     int witnessversion;\n     std::vector<unsigned char> witnessprogram;"
      },
      {
        "sha": "16d9e313a6ae462b89b61017af229537c6059e9f",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 61,
        "deletions": 5,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -28,7 +28,7 @@ enum\n };\n \n /** Script verification flags */\n-enum\n+enum CScriptFlag\n {\n     SCRIPT_VERIFY_NONE      = 0,\n \n@@ -108,7 +108,63 @@ enum\n     SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1U << 15),\n };\n \n-bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n+class CScriptFlags\n+{\n+private:\n+    typedef uint16_t _flags_type;\n+    _flags_type flags;\n+\n+public:\n+    CScriptFlags() : flags(0) { }\n+    CScriptFlags(CScriptFlag flag) : flags(_flags_type(flag)) { }\n+\n+    static CScriptFlags FromBitfieldInt(const uint64_t _flags) {\n+        CScriptFlags r;\n+        r.flags = _flags;\n+        return r;\n+    }\n+\n+    inline uint64_t ToBitfieldInt() const {\n+        return flags;\n+    }\n+\n+    inline bool IsNull() const {\n+        return (flags == 0);\n+    }\n+\n+    inline void ClearFlags(const CScriptFlags _flags) {\n+        flags &= ~(_flags.flags);\n+    }\n+\n+    inline CScriptFlags WithFlagsCleared(const CScriptFlags _flags) const {\n+        CScriptFlags r(*this);\n+        r.ClearFlags(_flags);\n+        return r;\n+    }\n+\n+    inline CScriptFlags& operator|=(const CScriptFlag flag) {\n+        flags |= _flags_type(flag);\n+        return *this;\n+    }\n+\n+    inline CScriptFlags& operator|(const CScriptFlag flag) const {\n+        return CScriptFlags(*this) |= flag;\n+    }\n+\n+    inline bool IsSet(const CScriptFlag flag) const {\n+        return (flags & _flags_type(flag));\n+    }\n+\n+    inline bool IsAtLeastOneSet(const CScriptFlags _flags) const {\n+        return (flags & _flags.flags);\n+    }\n+};\n+\n+inline CScriptFlags operator|(const CScriptFlag flagA, const CScriptFlag flagB) {\n+    return CScriptFlags() | flagA | flagB;\n+}\n+\n+bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, const CScriptFlags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n@@ -174,9 +230,9 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n     MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : TransactionSignatureChecker(&txTo, nInIn, amountIn), txTo(*txToIn) {}\n };\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = NULL);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CScriptFlags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = NULL);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, const CScriptFlags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n \n-size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);\n+size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, const CScriptFlags);\n \n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "1c8c060ef5ad0ad135514a04139cbef0df5347c8",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -40,7 +40,7 @@ extern unsigned nMaxDatacarrierBytes;\n  * Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n  * details.\n  */\n-static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n+static const CScriptFlags MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n \n enum txnouttype\n {"
      },
      {
        "sha": "31625e54c6ab4e8a31f62a8d2f8c61a959cfe551",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -40,7 +40,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n \n BOOST_AUTO_TEST_CASE(multisig_verify)\n {\n-    unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n+    CScriptFlags flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n \n     ScriptError err;\n     CKey key[4];"
      },
      {
        "sha": "71c1aa4ea5a29a0479903cb93f03776696bd0b1e",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -32,10 +32,10 @@\n // Uncomment if you want to output updated JSON tests.\n // #define UPDATE_JSON_TESTS\n \n-static const unsigned int gFlags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n+static const CScriptFlags gFlags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n \n-unsigned int ParseScriptFlags(std::string strFlags);\n-std::string FormatScriptFlags(unsigned int flags);\n+CScriptFlags ParseScriptFlags(std::string strFlags);\n+std::string FormatScriptFlags(const CScriptFlags);\n \n UniValue\n read_json(const std::string& jsondata)\n@@ -154,10 +154,10 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CSc\n     return txSpend;\n }\n \n-void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, int flags, const std::string& message, int scriptError, CAmount nValue = 0)\n+void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, CScriptFlags flags, const std::string& message, int scriptError, CAmount nValue = 0)\n {\n     bool expect = (scriptError == SCRIPT_ERR_OK);\n-    if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n+    if (flags.IsSet(SCRIPT_VERIFY_CLEANSTACK)) {\n         flags |= SCRIPT_VERIFY_P2SH;\n         flags |= SCRIPT_VERIFY_WITNESS;\n     }\n@@ -170,9 +170,9 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n-    int libconsensus_flags = flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL;\n-    if (libconsensus_flags == flags) {\n-        if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n+    uint64_t libconsensus_flags = flags.ToBitfieldInt() & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL;\n+    if (libconsensus_flags == flags.ToBitfieldInt()) {\n+        if (flags.IsSet(SCRIPT_VERIFY_WITNESS)) {\n             BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, NULL) == expect, message);\n         } else {\n             BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, NULL) == expect, message);\n@@ -278,7 +278,7 @@ class TestBuilder\n     bool havePush;\n     std::vector<unsigned char> push;\n     std::string comment;\n-    int flags;\n+    CScriptFlags flags;\n     int scriptError;\n     CAmount nValue;\n \n@@ -298,7 +298,7 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, const CScriptFlags flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n         if (wm == WITNESS_PKH) {\n@@ -477,24 +477,24 @@ BOOST_AUTO_TEST_CASE(script_build)\n     std::vector<TestBuilder> tests;\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2PK\", 0\n+                                \"P2PK\", CScriptFlags()\n                                ).PushSig(keys.key0));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2PK, bad sig\", 0\n+                                \"P2PK, bad sig\", CScriptFlags()\n                                ).PushSig(keys.key0).DamagePush(10).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                                \"P2PKH\", 0\n+                                \"P2PKH\", CScriptFlags()\n                                ).PushSig(keys.key1).Push(keys.pubkey1C));\n     tests.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey2C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                                \"P2PKH, bad pubkey\", 0\n+                                \"P2PKH, bad pubkey\", CScriptFlags()\n                                ).PushSig(keys.key2).Push(keys.pubkey2C).DamagePush(5).ScriptError(SCRIPT_ERR_EQUALVERIFY));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"P2PK anyonecanpay\", 0\n+                                \"P2PK anyonecanpay\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"P2PK anyonecanpay marked with normal hashtype\", 0\n+                                \"P2PK anyonecanpay marked with normal hashtype\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY).EditPush(70, \"81\", \"01\").ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n@@ -508,17 +508,17 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                 \"P2SH(P2PKH)\", SCRIPT_VERIFY_P2SH, true\n                                ).PushSig(keys.key0).Push(keys.pubkey0).PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                                \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\", 0, true\n+                                \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\", CScriptFlags(), true\n                                ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n                                 \"P2SH(P2PKH), bad sig\", SCRIPT_VERIFY_P2SH, true\n                                ).PushSig(keys.key0).DamagePush(10).PushRedeem().ScriptError(SCRIPT_ERR_EQUALVERIFY));\n \n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                                \"3-of-3\", 0\n+                                \"3-of-3\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                                \"3-of-3, 2 sigs\", 0\n+                                \"3-of-3, 2 sigs\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key0).PushSig(keys.key1).Num(0).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n@@ -529,142 +529,142 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).Num(0).PushSig(keys.key1).Num(0).PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"P2PK with too much R padding but no DERSIG\", 0\n+                                \"P2PK with too much R padding but no DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"P2PK with too much R padding\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"P2PK with too much S padding but no DERSIG\", 0\n+                                \"P2PK with too much S padding but no DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"P2PK with too much S padding\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"P2PK with too little R padding but no DERSIG\", 0\n+                                \"P2PK with too little R padding but no DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"P2PK with too little R padding\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                                \"P2PK NOT with bad sig with too much R padding but no DERSIG\", 0\n+                                \"P2PK NOT with bad sig with too much R padding but no DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n                                 \"P2PK NOT with bad sig with too much R padding\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10).ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                                \"P2PK NOT with too much R padding but no DERSIG\", 0\n+                                \"P2PK NOT with too much R padding but no DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n                                 \"P2PK NOT with too much R padding\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").ScriptError(SCRIPT_ERR_SIG_DER));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"BIP66 example 1, without DERSIG\", 0\n+                                \"BIP66 example 1, without DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"BIP66 example 1, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n-                                \"BIP66 example 2, without DERSIG\", 0\n+                                \"BIP66 example 2, without DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n                                 \"BIP66 example 2, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"BIP66 example 3, without DERSIG\", 0\n+                                \"BIP66 example 3, without DERSIG\", CScriptFlags()\n                                ).Num(0).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"BIP66 example 3, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n-                                \"BIP66 example 4, without DERSIG\", 0\n+                                \"BIP66 example 4, without DERSIG\", CScriptFlags()\n                                ).Num(0));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n                                 \"BIP66 example 4, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                                \"BIP66 example 5, without DERSIG\", 0\n+                                \"BIP66 example 5, without DERSIG\", CScriptFlags()\n                                ).Num(1).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n                                 \"BIP66 example 5, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(1).ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n-                                \"BIP66 example 6, without DERSIG\", 0\n+                                \"BIP66 example 6, without DERSIG\", CScriptFlags()\n                                ).Num(1));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG << OP_NOT,\n                                 \"BIP66 example 6, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(1).ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"BIP66 example 7, without DERSIG\", 0\n+                                \"BIP66 example 7, without DERSIG\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").PushSig(keys.key2));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n                                 \"BIP66 example 7, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").PushSig(keys.key2).ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n-                                \"BIP66 example 8, without DERSIG\", 0\n+                                \"BIP66 example 8, without DERSIG\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").PushSig(keys.key2).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n                                 \"BIP66 example 8, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").PushSig(keys.key2).ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"BIP66 example 9, without DERSIG\", 0\n+                                \"BIP66 example 9, without DERSIG\", CScriptFlags()\n                                ).Num(0).Num(0).PushSig(keys.key2, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n                                 \"BIP66 example 9, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).Num(0).PushSig(keys.key2, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n-                                \"BIP66 example 10, without DERSIG\", 0\n+                                \"BIP66 example 10, without DERSIG\", CScriptFlags()\n                                ).Num(0).Num(0).PushSig(keys.key2, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n                                 \"BIP66 example 10, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).Num(0).PushSig(keys.key2, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").ScriptError(SCRIPT_ERR_SIG_DER));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"BIP66 example 11, without DERSIG\", 0\n+                                \"BIP66 example 11, without DERSIG\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").Num(0).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG,\n                                 \"BIP66 example 11, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").Num(0).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n-                                \"BIP66 example 12, without DERSIG\", 0\n+                                \"BIP66 example 12, without DERSIG\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").Num(0));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_2 << OP_CHECKMULTISIG << OP_NOT,\n                                 \"BIP66 example 12, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\").Num(0));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                                \"P2PK with multi-byte hashtype, without DERSIG\", 0\n+                                \"P2PK with multi-byte hashtype, without DERSIG\", CScriptFlags()\n                                ).PushSig(keys.key2, SIGHASH_ALL).EditPush(70, \"01\", \"0101\"));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n                                 \"P2PK with multi-byte hashtype, with DERSIG\", SCRIPT_VERIFY_DERSIG\n                                ).PushSig(keys.key2, SIGHASH_ALL).EditPush(70, \"01\", \"0101\").ScriptError(SCRIPT_ERR_SIG_DER));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                                \"P2PK with high S but no LOW_S\", 0\n+                                \"P2PK with high S but no LOW_S\", CScriptFlags()\n                                ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n                                 \"P2PK with high S\", SCRIPT_VERIFY_LOW_S\n                                ).PushSig(keys.key2, SIGHASH_ALL, 32, 33).ScriptError(SCRIPT_ERR_SIG_HIGH_S));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n-                                \"P2PK with hybrid pubkey but no STRICTENC\", 0\n+                                \"P2PK with hybrid pubkey but no STRICTENC\", CScriptFlags()\n                                ).PushSig(keys.key0, SIGHASH_ALL));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n                                 \"P2PK with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n                                ).PushSig(keys.key0, SIGHASH_ALL).ScriptError(SCRIPT_ERR_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                                \"P2PK NOT with hybrid pubkey but no STRICTENC\", 0\n+                                \"P2PK NOT with hybrid pubkey but no STRICTENC\", CScriptFlags()\n                                ).PushSig(keys.key0, SIGHASH_ALL).ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n                                 \"P2PK NOT with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n                                ).PushSig(keys.key0, SIGHASH_ALL).ScriptError(SCRIPT_ERR_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                                \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\", 0\n+                                \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\", CScriptFlags()\n                                ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n                                 \"P2PK NOT with invalid hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n                                ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10).ScriptError(SCRIPT_ERR_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey0H) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"1-of-2 with the second 1 hybrid pubkey and no STRICTENC\", 0\n+                                \"1-of-2 with the second 1 hybrid pubkey and no STRICTENC\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey0H) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n                                 \"1-of-2 with the second 1 hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n@@ -674,42 +674,42 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).Num(0).PushSig(keys.key1, SIGHASH_ALL).ScriptError(SCRIPT_ERR_PUBKEYTYPE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"P2PK with undefined hashtype but no STRICTENC\", 0\n+                                \"P2PK with undefined hashtype but no STRICTENC\", CScriptFlags()\n                                ).PushSig(keys.key1, 5));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n                                 \"P2PK with undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n                                ).PushSig(keys.key1, 5).ScriptError(SCRIPT_ERR_SIG_HASHTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n-                                \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\", 0\n+                                \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\", CScriptFlags()\n                                ).PushSig(keys.key1, 5).DamagePush(10));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n                                 \"P2PK NOT with invalid sig and undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n                                ).PushSig(keys.key1, 5).DamagePush(10).ScriptError(SCRIPT_ERR_SIG_HASHTYPE));\n \n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                                \"3-of-3 with nonzero dummy but no NULLDUMMY\", 0\n+                                \"3-of-3 with nonzero dummy but no NULLDUMMY\", CScriptFlags()\n                                ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n                                 \"3-of-3 with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n                                ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).ScriptError(SCRIPT_ERR_SIG_NULLDUMMY));\n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n-                                \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\", 0\n+                                \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\", CScriptFlags()\n                                ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n     tests.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n                                 \"3-of-3 NOT with invalid sig with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n                                ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10).ScriptError(SCRIPT_ERR_SIG_NULLDUMMY));\n \n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\", 0\n+                                \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\", CScriptFlags()\n                                ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n     tests.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n                                 \"2-of-2 with two identical keys and sigs pushed using OP_DUP\", SCRIPT_VERIFY_SIGPUSHONLY\n                                ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP).ScriptError(SCRIPT_ERR_SIG_PUSHONLY));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                                \"P2SH(P2PK) with non-push scriptSig but no P2SH or SIGPUSHONLY\", 0, true\n+                                \"P2SH(P2PK) with non-push scriptSig but no P2SH or SIGPUSHONLY\", CScriptFlags(), true\n                                ).PushSig(keys.key2).Add(CScript() << OP_NOP8).PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                                \"P2PK with non-push scriptSig but with P2SH validation\", 0\n+                                \"P2PK with non-push scriptSig but with P2SH validation\", CScriptFlags()\n                                ).PushSig(keys.key2).Add(CScript() << OP_NOP8));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n                                 \"P2SH(P2PK) with non-push scriptSig but no SIGPUSHONLY\", SCRIPT_VERIFY_P2SH, true\n@@ -981,7 +981,7 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n         CScript scriptSig = ParseScript(scriptSigString);\n         std::string scriptPubKeyString = test[pos++].get_str();\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n-        unsigned int scriptflags = ParseScriptFlags(test[pos++].get_str());\n+        CScriptFlags scriptflags = ParseScriptFlags(test[pos++].get_str());\n         int scriptError = ParseScriptError(test[pos++].get_str());\n \n         DoTest(scriptPubKey, scriptSig, witness, scriptflags, strTest, scriptError, nValue);"
      },
      {
        "sha": "87c39f6a6d9ef61b4c730c9932ad41e88bff190a",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n  * Verifies script execution of the zeroth scriptPubKey of tx output and\n  * zeroth scriptSig and witness of tx input.\n  */\n-ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n+ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, const CScriptFlags flags)\n {\n     ScriptError error;\n     CTransaction inputi(input);\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n     key.MakeNewKey(true);\n     CPubKey pubkey = key.GetPubKey();\n     // Default flags\n-    int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n+    CScriptFlags flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n \n     // Multisig script (legacy counting)\n     {\n@@ -165,7 +165,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n         // No signature operations if we don't verify the witness.\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags.WithFlagsCleared(SCRIPT_VERIFY_WITNESS)) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n \n         // The sig op cost for witness version != 0 is zero.\n@@ -208,7 +208,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags.WithFlagsCleared(SCRIPT_VERIFY_WITNESS)) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n "
      },
      {
        "sha": "8f551e66c37b9cf7a24f407a4d19e27d6d5c57c4",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 50,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -37,31 +37,31 @@ typedef std::vector<unsigned char> valtype;\n // In script_tests.cpp\n extern UniValue read_json(const std::string& jsondata);\n \n-static std::map<std::string, unsigned int> mapFlagNames = boost::assign::map_list_of\n-    (std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n-    (std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n-    (std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n-    (std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n-    (std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n-    (std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n-    (std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n-    (std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n-    (std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n-    (std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n-    (std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n-    (std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL)\n-    (std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n-    (std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n-    (std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n-    (std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n-    (std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n-\n-unsigned int ParseScriptFlags(std::string strFlags)\n+static std::map<std::string, CScriptFlag> mapFlagNames = boost::assign::map_list_of\n+    (std::string(\"NONE\"), SCRIPT_VERIFY_NONE)\n+    (std::string(\"P2SH\"), SCRIPT_VERIFY_P2SH)\n+    (std::string(\"STRICTENC\"), SCRIPT_VERIFY_STRICTENC)\n+    (std::string(\"DERSIG\"), SCRIPT_VERIFY_DERSIG)\n+    (std::string(\"LOW_S\"), SCRIPT_VERIFY_LOW_S)\n+    (std::string(\"SIGPUSHONLY\"), SCRIPT_VERIFY_SIGPUSHONLY)\n+    (std::string(\"MINIMALDATA\"), SCRIPT_VERIFY_MINIMALDATA)\n+    (std::string(\"NULLDUMMY\"), SCRIPT_VERIFY_NULLDUMMY)\n+    (std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n+    (std::string(\"CLEANSTACK\"), SCRIPT_VERIFY_CLEANSTACK)\n+    (std::string(\"MINIMALIF\"), SCRIPT_VERIFY_MINIMALIF)\n+    (std::string(\"NULLFAIL\"), SCRIPT_VERIFY_NULLFAIL)\n+    (std::string(\"CHECKLOCKTIMEVERIFY\"), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n+    (std::string(\"CHECKSEQUENCEVERIFY\"), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n+    (std::string(\"WITNESS\"), SCRIPT_VERIFY_WITNESS)\n+    (std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n+    (std::string(\"WITNESS_PUBKEYTYPE\"), SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n+\n+CScriptFlags ParseScriptFlags(std::string strFlags)\n {\n     if (strFlags.empty()) {\n-        return 0;\n+        return CScriptFlags();\n     }\n-    unsigned int flags = 0;\n+    CScriptFlags flags;\n     std::vector<std::string> words;\n     boost::algorithm::split(words, strFlags, boost::algorithm::is_any_of(\",\"));\n \n@@ -75,18 +75,16 @@ unsigned int ParseScriptFlags(std::string strFlags)\n     return flags;\n }\n \n-std::string FormatScriptFlags(unsigned int flags)\n+std::string FormatScriptFlags(const CScriptFlags flags)\n {\n-    if (flags == 0) {\n+    if (flags.IsNull()) {\n         return \"\";\n     }\n     std::string ret;\n-    std::map<std::string, unsigned int>::const_iterator it = mapFlagNames.begin();\n-    while (it != mapFlagNames.end()) {\n-        if (flags & it->second) {\n-            ret += it->first + \",\";\n+    for (auto& flagpair : mapFlagNames) {\n+        if (flags.IsSet(flagpair.second)) {\n+            ret += flagpair.first + \",\";\n         }\n-        it++;\n     }\n     return ret.substr(0, ret.size() - 1);\n }\n@@ -167,7 +165,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 if (mapprevOutValues.count(tx.vin[i].prevout)) {\n                     amount = mapprevOutValues[tx.vin[i].prevout];\n                 }\n-                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n+                CScriptFlags verify_flags = ParseScriptFlags(test[2].get_str());\n                 const CScriptWitness *witness = &tx.vin[i].scriptWitness;\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n                                                  witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err),\n@@ -249,7 +247,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                     break;\n                 }\n \n-                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n+                CScriptFlags verify_flags = ParseScriptFlags(test[2].get_str());\n                 CAmount amount = 0;\n                 if (mapprevOutValues.count(tx.vin[i].prevout)) {\n                     amount = mapprevOutValues[tx.vin[i].prevout];\n@@ -382,7 +380,7 @@ void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, C\n     assert(input.vin[0].scriptWitness.stack == inputm.vin[0].scriptWitness.stack);\n }\n \n-void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\n+void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, const CScriptFlags flags, bool success)\n {\n     ScriptError error;\n     CTransaction inputi(input);\n@@ -543,11 +541,11 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     // Normal pay-to-compressed-pubkey.\n     CreateCreditAndSpend(keystore, scriptPubkey1, output1, input1);\n     CreateCreditAndSpend(keystore, scriptPubkey2, output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, false);\n+    CheckWithFlag(output1, input2, CScriptFlags(), false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n@@ -556,23 +554,23 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1)), output1, input1);\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2)), output2, input2);\n     ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, CScriptFlags(), true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n \n     // Witness pay-to-compressed-pubkey (v0).\n     CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1), output1, input1);\n     CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2), output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, CScriptFlags(), true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n@@ -581,23 +579,23 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1))), output1, input1);\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2))), output2, input2);\n     ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1));\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, CScriptFlags(), true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n \n     // Normal pay-to-uncompressed-pubkey.\n     CreateCreditAndSpend(keystore, scriptPubkey1L, output1, input1);\n     CreateCreditAndSpend(keystore, scriptPubkey2L, output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, false);\n+    CheckWithFlag(output1, input2, CScriptFlags(), false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n@@ -606,11 +604,11 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1L)), output1, input1);\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2L)), output2, input2);\n     ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1L);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, CScriptFlags(), true);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n@@ -625,19 +623,19 @@ BOOST_AUTO_TEST_CASE(test_witness)\n \n     // Normal 2-of-2 multisig\n     CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, false);\n+    CheckWithFlag(output1, input1, CScriptFlags(), false);\n     CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, false);\n+    CheckWithFlag(output2, input2, CScriptFlags(), false);\n     BOOST_CHECK(*output1 == *output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n     // P2SH 2-of-2 multisig\n     CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptMulti)), output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, false);\n     CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(scriptMulti)), output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, true);\n+    CheckWithFlag(output2, input2, CScriptFlags(), true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n     BOOST_CHECK(*output1 == *output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n@@ -646,10 +644,10 @@ BOOST_AUTO_TEST_CASE(test_witness)\n \n     // Witness 2-of-2 multisig\n     CreateCreditAndSpend(keystore, GetScriptForWitness(scriptMulti), output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, CScriptFlags(), true);\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     CreateCreditAndSpend(keystore2, GetScriptForWitness(scriptMulti), output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, true);\n+    CheckWithFlag(output2, input2, CScriptFlags(), true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));"
      },
      {
        "sha": "8d1e6dd8ce2da0f466e3ac4f8196a6d17e2bb9c7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -434,14 +434,14 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     return nSigOps;\n }\n \n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, const CScriptFlags flags)\n {\n     int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n \n     if (tx.IsCoinBase())\n         return nSigOps;\n \n-    if (flags & SCRIPT_VERIFY_P2SH) {\n+    if (flags.IsSet(SCRIPT_VERIFY_P2SH)) {\n         nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n     }\n \n@@ -885,9 +885,9 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             }\n         }\n \n-        unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n+        CScriptFlags scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n         if (!Params().RequireStandard()) {\n-            scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);\n+            scriptVerifyFlags = CScriptFlags::FromBitfieldInt(GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags.ToBitfieldInt()));\n         }\n \n         // Check against previous transactions\n@@ -898,8 +898,8 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags.WithFlagsCleared(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags.WithFlagsCleared(SCRIPT_VERIFY_CLEANSTACK), true, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n@@ -1355,7 +1355,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, const CScriptFlags flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1386,15 +1386,15 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n                 } else if (!check()) {\n-                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n+                    if (flags.IsAtLeastOneSet(STANDARD_NOT_MANDATORY_VERIFY_FLAGS)) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n                         // non-standard DER encodings or non-null dummy\n                         // arguments; if so, don't trigger DoS protection to\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n                         CScriptCheck check2(*coins, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n+                                flags.WithFlagsCleared(STANDARD_NOT_MANDATORY_VERIFY_FLAGS), cacheStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n@@ -1782,7 +1782,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     int64_t nBIP16SwitchTime = 1333238400;\n     bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n \n-    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n+    CScriptFlags flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n \n     // Start enforcing the DERSIG (BIP66) rule\n     if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {"
      },
      {
        "sha": "236de20ccf0cfda810578a7f5802057f30b99989",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664299ec3b24b4e76ca2adb33d31f6dcec53e18f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=664299ec3b24b4e76ca2adb33d31f6dcec53e18f",
        "patch": "@@ -14,6 +14,7 @@\n #include \"coins.h\"\n #include \"fs.h\"\n #include \"protocol.h\" // For CMessageHeader::MessageStartChars\n+#include \"script/interpreter.h\"\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n@@ -364,15 +365,15 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& ma\n  * @param[out] flags Script verification flags\n  * @return Total signature operation cost of tx\n  */\n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, const CScriptFlags);\n \n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n  * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+                 const CScriptFlags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);\n@@ -443,14 +444,14 @@ class CScriptCheck\n     CAmount amount;\n     const CTransaction *ptxTo;\n     unsigned int nIn;\n-    unsigned int nFlags;\n+    CScriptFlags nFlags;\n     bool cacheStore;\n     ScriptError error;\n     PrecomputedTransactionData *txdata;\n \n public:\n-    CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n+    CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n+    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, const CScriptFlags nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n         scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), amount(txFromIn.vout[txToIn.vin[nInIn].prevout.n].nValue),\n         ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR), txdata(txdataIn) { }\n "
      }
    ]
  }
]