[
  {
    "sha": "27c63dc059f17f86bfa2ece0eb456b75340498fe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyN2M2M2RjMDU5ZjE3Zjg2YmZhMmVjZTBlYjQ1NmI3NTM0MDQ5OGZl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T13:52:13Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-07-02T20:55:13Z"
      },
      "message": "[tests] nits in dbcrash.py",
      "tree": {
        "sha": "b94e4f2238c3dd9ad5dade4c5dd6ae751868d692",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b94e4f2238c3dd9ad5dade4c5dd6ae751868d692"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27c63dc059f17f86bfa2ece0eb456b75340498fe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27c63dc059f17f86bfa2ece0eb456b75340498fe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27c63dc059f17f86bfa2ece0eb456b75340498fe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27c63dc059f17f86bfa2ece0eb456b75340498fe/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2935b469ae96a3203bb997a6eddc098903b336ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2935b469ae96a3203bb997a6eddc098903b336ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2935b469ae96a3203bb997a6eddc098903b336ce"
      }
    ],
    "stats": {
      "total": 114,
      "additions": 65,
      "deletions": 49
    },
    "files": [
      {
        "sha": "8339305f5e45250d40540c8aebbfbec3a2c3dccf",
        "filename": "test/functional/dbcrash.py",
        "status": "modified",
        "additions": 61,
        "deletions": 48,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27c63dc059f17f86bfa2ece0eb456b75340498fe/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27c63dc059f17f86bfa2ece0eb456b75340498fe/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=27c63dc059f17f86bfa2ece0eb456b75340498fe",
        "patch": "@@ -2,21 +2,7 @@\n # Copyright (c) 2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test recovery from a crash during chainstate writing.\"\"\"\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-from test_framework.script import *\n-from test_framework.mininode import *\n-import random\n-try:\n-    import http.client as httplib\n-except ImportError:\n-    import httplib\n-import errno\n-\n-'''\n-Test structure:\n+\"\"\"Test recovery from a crash during chainstate writing.\n \n - 4 nodes\n   * node0, node1, and node2 will have different dbcrash ratios, and different\n@@ -37,11 +23,26 @@\n        * submit block to node\n        * if node crashed on/after submitting:\n          - restart until recovery succeeds\n-         - check that utxo matches node3 using gettxoutsetinfo\n-'''\n+         - check that utxo matches node3 using gettxoutsetinfo\"\"\"\n \n-class ChainstateWriteCrashTest(BitcoinTestFramework):\n+import errno\n+import http.client\n+import random\n+import sys\n+import time\n+\n+from test_framework.mininode import *\n+from test_framework.script import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+HTTP_DISCONNECT_ERRORS = [http.client.CannotSendRequest]\n+try:\n+    HTTP_DISCONNECT_ERRORS.append(http.client.RemoteDisconnected)\n+except AttributeError:\n+    pass\n \n+class ChainstateWriteCrashTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 4\n@@ -50,32 +51,28 @@ def __init__(self):\n         # Set -maxmempool=0 to turn off mempool memory sharing with dbcache\n         # Set -rpcservertimeout=900 to reduce socket disconnects in this\n         # long-running test\n-        self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\"]\n+        self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\", \"-dbbatchsize=200000\"]\n \n         # Set different crash ratios and cache sizes.  Note that not all of\n         # -dbcache goes to pcoinsTip.\n-        self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\", \"-dbbatchsize=200000\"] + self.base_args\n-        self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\", \"-dbbatchsize=200000\"] + self.base_args\n-        self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\", \"-dbbatchsize=200000\"] + self.base_args\n+        self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\"] + self.base_args\n+        self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\"] + self.base_args\n+        self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\"] + self.base_args\n \n         # Node3 is a normal node with default args, except will mine full blocks\n         self.node3_args = [\"-blockmaxweight=4000000\"]\n         self.extra_args = [self.node0_args, self.node1_args, self.node2_args, self.node3_args]\n \n-        # We'll track some test coverage statistics\n-        self.restart_counts = [0, 0, 0] # Track the restarts for nodes 0-2\n-        self.crashed_on_restart = 0     # Track count of crashes during recovery\n-\n     def setup_network(self):\n         self.setup_nodes()\n         # Leave them unconnected, we'll use submitblock directly in this test\n \n-    # Starts up a given node id, waits for the tip to reach the given block\n-    # hash, and calculates the utxo hash.  Exceptions on startup should\n-    # indicate node crash (due to -dbcrashratio), in which case we try again.\n-    # Give up after 60 seconds.\n-    # Returns the utxo hash of the given node.\n     def restart_node(self, node_index, expected_tip):\n+        \"\"\"Start up a given node id, wait for the tip to reach the given block hash, and calculate the utxo hash.\n+\n+        Exceptions on startup should indicate node crash (due to -dbcrashratio), in which case we try again. Give up\n+        after 60 seconds. Returns the utxo hash of the given node.\"\"\"\n+\n         time_start = time.time()\n         while time.time() - time_start < 60:\n             try:\n@@ -99,14 +96,23 @@ def restart_node(self, node_index, expected_tip):\n         # and make sure that recovery happens.\n         raise AssertionError(\"Unable to successfully restart node %d in allotted time\", node_index)\n \n-    # Try submitting a block to the given node.\n-    # Catch any exceptions that indicate the node has crashed.\n-    # Returns true if the block was submitted successfully; false otherwise.\n     def submit_block_catch_error(self, node_index, block):\n+        \"\"\"Try submitting a block to the given node.\n+\n+        Catch any exceptions that indicate the node has crashed.\n+        Returns true if the block was submitted successfully; false otherwise.\"\"\"\n+\n         try:\n             self.nodes[node_index].submitblock(block)\n             return True\n-        except (httplib.CannotSendRequest, httplib.RemoteDisconnected) as e:\n+        except http.client.BadStatusLine as e:\n+            # Prior to 3.5 BadStatusLine('') was raised for a remote disconnect error.\n+            if sys.version_info[0] == 3 and sys.version_info[1] < 5 and e.line == \"''\":\n+                self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n+                return False\n+            else:\n+                raise\n+        except tuple(HTTP_DISCONNECT_ERRORS) as e:\n             self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n             return False\n         except OSError as e:\n@@ -118,11 +124,13 @@ def submit_block_catch_error(self, node_index, block):\n                 # Unexpected exception, raise\n                 raise\n \n-    # Use submitblock to sync node3's chain with the other nodes\n-    # If submitblock fails, restart the node and get the new utxo hash.\n     def sync_node3blocks(self, block_hashes):\n-        # If any nodes crash while updating, we'll compare utxo hashes to\n-        # ensure recovery was successful.\n+        \"\"\"Use submitblock to sync node3's chain with the other nodes\n+\n+        If submitblock fails, restart the node and get the new utxo hash.\n+        If any nodes crash while updating, we'll compare utxo hashes to\n+        ensure recovery was successful.\"\"\"\n+\n         node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n \n         # Retrieve all the blocks from node3\n@@ -161,9 +169,10 @@ def sync_node3blocks(self, block_hashes):\n                 self.log.debug(\"Checking txoutsetinfo matches for node %d\", i)\n                 assert_equal(nodei_utxo_hash, node3_utxo_hash)\n \n-    # Verify that the utxo hash of each node matches node3.\n-    # Restart any nodes that crash while querying.\n     def verify_utxo_hash(self):\n+        \"\"\"Verify that the utxo hash of each node matches node3.\n+\n+        Restart any nodes that crash while querying.\"\"\"\n         node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n         self.log.info(\"Verifying utxo hash matches for all nodes\")\n \n@@ -175,9 +184,8 @@ def verify_utxo_hash(self):\n                 nodei_utxo_hash = self.restart_node(i, self.nodes[3].getbestblockhash())\n             assert_equal(nodei_utxo_hash, node3_utxo_hash)\n \n-\n     def generate_small_transactions(self, node, count, utxo_list):\n-        FEE = 1000 # TODO: replace this with node relay fee based calculation\n+        FEE = 1000  # TODO: replace this with node relay fee based calculation\n         num_transactions = 0\n         random.shuffle(utxo_list)\n         while len(utxo_list) >= 2 and num_transactions < count:\n@@ -186,8 +194,8 @@ def generate_small_transactions(self, node, count, utxo_list):\n             for i in range(2):\n                 utxo = utxo_list.pop()\n                 tx.vin.append(CTxIn(COutPoint(int(utxo['txid'], 16), utxo['vout'])))\n-                input_amount += int(utxo['amount']*COIN)\n-            output_amount = (input_amount - FEE)//3\n+                input_amount += int(utxo['amount'] * COIN)\n+            output_amount = (input_amount - FEE) // 3\n \n             if output_amount <= 0:\n                 # Sanity check -- if we chose inputs that are too small, skip\n@@ -202,6 +210,9 @@ def generate_small_transactions(self, node, count, utxo_list):\n             num_transactions += 1\n \n     def run_test(self):\n+        # Track test coverage statistics\n+        self.restart_counts = [0, 0, 0]  # Track the restarts for nodes 0-2\n+        self.crashed_on_restart = 0      # Track count of crashes during recovery\n \n         # Start by creating a lot of utxos on node3\n         initial_height = self.nodes[3].getblockcount()\n@@ -210,7 +221,7 @@ def run_test(self):\n \n         # Sync these blocks with the other nodes\n         block_hashes_to_sync = []\n-        for height in range(initial_height+1, self.nodes[3].getblockcount()+1):\n+        for height in range(initial_height + 1, self.nodes[3].getblockcount() + 1):\n             block_hashes_to_sync.append(self.nodes[3].getblockhash(height))\n \n         self.log.debug(\"Syncing %d blocks with other nodes\", len(block_hashes_to_sync))\n@@ -233,13 +244,15 @@ def run_test(self):\n             if random_height > starting_tip_height:\n                 # Randomly reorg from this point with some probability (1/4 for\n                 # tip, 1/5 for tip-1, ...)\n-                if random.random() < 1.0/(current_height + 4 - random_height):\n+                if random.random() < 1.0 / (current_height + 4 - random_height):\n                     self.log.debug(\"Invalidating block at height %d\", random_height)\n                     self.nodes[3].invalidateblock(self.nodes[3].getblockhash(random_height))\n \n             # Now generate new blocks until we pass the old tip height\n             self.log.debug(\"Mining longer tip\")\n-            block_hashes = self.nodes[3].generate(current_height+1-self.nodes[3].getblockcount())\n+            block_hashes = []\n+            while current_height + 1 > self.nodes[3].getblockcount():\n+                block_hashes.extend(self.nodes[3].generate(min(10, current_height + 1 - self.nodes[3].getblockcount())))\n             self.log.debug(\"Syncing %d new blocks...\", len(block_hashes))\n             self.sync_node3blocks(block_hashes)\n             utxo_list = self.nodes[3].listunspent()"
      },
      {
        "sha": "8a2d8de50ebc826258cea9b654bf290db2ff826a",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27c63dc059f17f86bfa2ece0eb456b75340498fe/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27c63dc059f17f86bfa2ece0eb456b75340498fe/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=27c63dc059f17f86bfa2ece0eb456b75340498fe",
        "patch": "@@ -412,7 +412,10 @@ def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n def create_confirmed_utxos(fee, node, count):\n-    node.generate(int(0.5 * count) + 101)\n+    to_generate = int(0.5 * count) + 101\n+    while to_generate > 0:\n+        node.generate(min(25, to_generate))\n+        to_generate -= 25\n     utxos = node.listunspent()\n     iterations = count - len(utxos)\n     addr1 = node.getnewaddress()"
      }
    ]
  }
]