[
  {
    "sha": "faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWFiZWI4NTRhNmU0NmI0NmU0ZjI2YjIyZGMyYzgxZTY4ZTJkODYz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-17T17:17:40Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-17T18:13:34Z"
      },
      "message": "refactor: Mark member functions const",
      "tree": {
        "sha": "89342ff54d5ebfae272d48a613c38d669a454bba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89342ff54d5ebfae272d48a613c38d669a454bba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjLsAwAupnnlNAbMcCVgNkn4OpBvbk1Zlbxz0h7zG8Dln3xsxKfrHIl1vm40Bkk\nXXx1BS3ePgb3piN472pO7vR1tuWlTj6tFbPbH8GSFtNmkxuxlhl2WQ1qeYXkSsxT\nRhXaaPR0ll5eKSSpUQBybmxPLMO8LiMr08EOeNVPLmqbyJ1oRD8rYwWo0RwExsHa\nQn37tInMDVkBJCnXdRMO0SbeqLhlVDcnBqP8gek9/NSXfLNglq0uTy6ScfQ7MZO7\nEIKg9p+2e2IBBsLhL+5YCkMMEEfmVKphdB7BAS4m0PUDTriHLnh95iCTgIjCfGOT\nLLzUqkHHS9LN6y1s1vdA1uwKOrpUa1HPE9LIsjOEguKf3e6Kw04rDEwt0nIwwGj0\nQlIgjLjQWxyfE6iv8wx8JdYQpZvF6NY8FhYn4Vdz4Y56M2W8M6lfjtP8FdrAW3Se\nJwT9FnbmfCeQLGWVO9QLyrNb+q8C6kdjPYXS/bpoTwLoljSz3s0wSjBeTWcf8n8e\nJXRFOmkC\n=mG17\n-----END PGP SIGNATURE-----",
        "payload": "tree 89342ff54d5ebfae272d48a613c38d669a454bba\nparent 0dd7b234895b02bfc512ae83bd77b581c861d6e9\nauthor MarcoFalke <falke.marco@gmail.com> 1618679860 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1618683214 +0200\n\nrefactor: Mark member functions const\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0dd7b234895b02bfc512ae83bd77b581c861d6e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0dd7b234895b02bfc512ae83bd77b581c861d6e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0dd7b234895b02bfc512ae83bd77b581c861d6e9"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 34,
      "deletions": 34
    },
    "files": [
      {
        "sha": "5aa267f0d7a92b6b7e83f2f0b93255f3e32ad1d3",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "patch": "@@ -1732,7 +1732,7 @@ void CConnman::ProcessAddrFetch()\n     }\n }\n \n-bool CConnman::GetTryNewOutboundPeer()\n+bool CConnman::GetTryNewOutboundPeer() const\n {\n     return m_try_another_outbound_peer;\n }\n@@ -1749,7 +1749,7 @@ void CConnman::SetTryNewOutboundPeer(bool flag)\n // Also exclude peers that haven't finished initial connection handshake yet\n // (so that we don't decide we're over our desired connection limit, and then\n // evict some peer that has finished the handshake)\n-int CConnman::GetExtraFullOutboundCount()\n+int CConnman::GetExtraFullOutboundCount() const\n {\n     int full_outbound_peers = 0;\n     {\n@@ -1763,7 +1763,7 @@ int CConnman::GetExtraFullOutboundCount()\n     return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);\n }\n \n-int CConnman::GetExtraBlockRelayCount()\n+int CConnman::GetExtraBlockRelayCount() const\n {\n     int block_relay_peers = 0;\n     {\n@@ -2061,7 +2061,7 @@ std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const\n     return ret;\n }\n \n-std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n+std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const\n {\n     std::vector<AddedNodeInfo> ret;\n \n@@ -2671,7 +2671,7 @@ CConnman::~CConnman()\n     Stop();\n }\n \n-std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct)\n+std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct) const\n {\n     std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct);\n     if (m_banman) {\n@@ -2746,7 +2746,7 @@ bool CConnman::RemoveAddedNode(const std::string& strNode)\n     return false;\n }\n \n-size_t CConnman::GetNodeCount(ConnectionDirection flags)\n+size_t CConnman::GetNodeCount(ConnectionDirection flags) const\n {\n     LOCK(cs_vNodes);\n     if (flags == ConnectionDirection::Both) // Shortcut if we want total\n@@ -2762,7 +2762,7 @@ size_t CConnman::GetNodeCount(ConnectionDirection flags)\n     return nNum;\n }\n \n-void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats)\n+void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n {\n     vstats.clear();\n     LOCK(cs_vNodes);\n@@ -2839,18 +2839,18 @@ void CConnman::RecordBytesSent(uint64_t bytes)\n     nMaxOutboundTotalBytesSentInCycle += bytes;\n }\n \n-uint64_t CConnman::GetMaxOutboundTarget()\n+uint64_t CConnman::GetMaxOutboundTarget() const\n {\n     LOCK(cs_totalBytesSent);\n     return nMaxOutboundLimit;\n }\n \n-std::chrono::seconds CConnman::GetMaxOutboundTimeframe()\n+std::chrono::seconds CConnman::GetMaxOutboundTimeframe() const\n {\n     return MAX_UPLOAD_TIMEFRAME;\n }\n \n-std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle()\n+std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle() const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2864,7 +2864,7 @@ std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle()\n     return (cycleEndTime < now) ? 0s : cycleEndTime - now;\n }\n \n-bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n+bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit) const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2884,7 +2884,7 @@ bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n     return false;\n }\n \n-uint64_t CConnman::GetOutboundTargetBytesLeft()\n+uint64_t CConnman::GetOutboundTargetBytesLeft() const\n {\n     LOCK(cs_totalBytesSent);\n     if (nMaxOutboundLimit == 0)\n@@ -2893,13 +2893,13 @@ uint64_t CConnman::GetOutboundTargetBytesLeft()\n     return (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit) ? 0 : nMaxOutboundLimit - nMaxOutboundTotalBytesSentInCycle;\n }\n \n-uint64_t CConnman::GetTotalBytesRecv()\n+uint64_t CConnman::GetTotalBytesRecv() const\n {\n     LOCK(cs_totalBytesRecv);\n     return nTotalBytesRecv;\n }\n \n-uint64_t CConnman::GetTotalBytesSent()\n+uint64_t CConnman::GetTotalBytesSent() const\n {\n     LOCK(cs_totalBytesSent);\n     return nTotalBytesSent;"
      },
      {
        "sha": "6b9a7ef1366139648f169403bb1deb9b672e6308",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "patch": "@@ -923,7 +923,7 @@ class CConnman\n     };\n \n     // Addrman functions\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct) const;\n     /**\n      * Cache is used to minimize topology leaks, so it should\n      * be used for all non-trusted calls, for example, p2p.\n@@ -935,7 +935,7 @@ class CConnman\n     // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers.\n     void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+    bool GetTryNewOutboundPeer() const;\n \n     void StartExtraBlockRelayPeers() {\n         LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n@@ -948,13 +948,13 @@ class CConnman\n     // return a value less than (num_outbound_connections - num_outbound_slots)\n     // in cases where some outbound connections are not yet fully connected, or\n     // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n+    int GetExtraFullOutboundCount() const;\n     // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+    int GetExtraBlockRelayCount() const;\n \n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo() const;\n \n     /**\n      * Attempts to open a connection. Currently only used from tests.\n@@ -969,8 +969,8 @@ class CConnman\n      */\n     bool AddConnection(const std::string& address, ConnectionType conn_type);\n \n-    size_t GetNodeCount(ConnectionDirection);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    size_t GetNodeCount(ConnectionDirection) const;\n+    void GetNodeStats(std::vector<CNodeStats>& vstats) const;\n     bool DisconnectNode(const std::string& node);\n     bool DisconnectNode(const CSubNet& subnet);\n     bool DisconnectNode(const CNetAddr& addr);\n@@ -984,24 +984,24 @@ class CConnman\n     //! that peer during `net_processing.cpp:PushNodeVersion()`.\n     ServiceFlags GetLocalServices() const;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+    uint64_t GetMaxOutboundTarget() const;\n+    std::chrono::seconds GetMaxOutboundTimeframe() const;\n \n     //! check if the outbound target is reached\n     //! if param historicalBlockServingLimit is set true, the function will\n     //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const;\n \n     //! response the bytes left in the current max outbound cycle\n     //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+    uint64_t GetOutboundTargetBytesLeft() const;\n \n     //! returns the time left in the current max outbound cycle\n     //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle() const;\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n+    uint64_t GetTotalBytesRecv() const;\n+    uint64_t GetTotalBytesSent() const;\n \n     /** Get a unique deterministic randomizer. */\n     CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n@@ -1106,8 +1106,8 @@ class CConnman\n     static bool NodeFullyConnected(const CNode* pnode);\n \n     // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n+    mutable RecursiveMutex cs_totalBytesRecv;\n+    mutable RecursiveMutex cs_totalBytesSent;\n     uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n     uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n@@ -1133,7 +1133,7 @@ class CConnman\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n+    mutable RecursiveMutex cs_vAddedNodes;\n     std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n     std::list<CNode*> vNodesDisconnected;\n     mutable RecursiveMutex cs_vNodes;"
      },
      {
        "sha": "d0cddabde28594eca0fa656add12a67d39b572e4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "patch": "@@ -246,7 +246,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Implement PeerManager */\n     void CheckForStaleTipAndEvictPeers() override;\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n     void SendPings() override;\n     void RelayTransaction(const uint256& txid, const uint256& wtxid) override;\n@@ -1101,7 +1101,7 @@ PeerRef PeerManagerImpl::RemovePeer(NodeId id)\n     return ret;\n }\n \n-bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n+bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const\n {\n     {\n         LOCK(cs_main);"
      },
      {
        "sha": "67252acbb6b56c5a32086a7f517e0fdb80e03b8b",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faabeb854a6e46b46e4f26b22dc2c81e68e2d863/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "patch": "@@ -43,7 +43,7 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     virtual ~PeerManager() { }\n \n     /** Get statistics from node state */\n-    virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) = 0;\n+    virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const = 0;\n \n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;"
      }
    ]
  },
  {
    "sha": "fafb68add5e16e8bd5b9428bcffcaee2639747cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWZiNjhhZGQ1ZTE2ZThiZDViOTQyOGJjZmZjYWVlMjYzOTc0N2Nm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-17T18:59:17Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-19T11:04:23Z"
      },
      "message": "refactor: Add and use EnsureConnman in rpc code",
      "tree": {
        "sha": "990c05dc7743dadfc8e0c280b92169c16f5494f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/990c05dc7743dadfc8e0c280b92169c16f5494f1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fafb68add5e16e8bd5b9428bcffcaee2639747cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUimaAv/ZYc2ci7MH0CO1ge7B3/ntc+eU8fdA+ps9PhKgL6VbQ8NpnHGA921zL64\nHepWqegZHHXgMuMN0UApGWKbPOwf2gDUqaavK7m4jZKkUcSKbIetAOrYoWH8lQe6\n0GKUqj05b06sZCN+oAzWja4ae+j8T1Xn6ifB2knImiiH/HYh29SA2fwAa373L9Pb\nsiTuM3TJe/ubKVAd/sEkk3zj0+JVm+xd1XUHTduR/JnIuPQZyqvGz5fmyONvB7Fu\nSQq2YAxmy0kOh5HbULAnUKD4ibq0F6ju3V1ZR5VHkTcFsnl8vc0Lmr0NgozcguVH\n8KiSnZqxh5/xyCnMT/b+1pKyKUoF3uRXOLTHabkuNnx+H302rbk+mu85wnUzVym0\ndL650tThXfLBK+2YvAtp6H3JOliD1aIEYs/nUpr8oEnBILuubhnbAGzBOt887iX+\nm4EyN1OVd2yIXYq1uqJKmwxHwdfZRSBoqNgmscxZWktCUO/2INLQ2N16ibA2VKuM\nqN0cDZ+W\n=bUMv\n-----END PGP SIGNATURE-----",
        "payload": "tree 990c05dc7743dadfc8e0c280b92169c16f5494f1\nparent faabeb854a6e46b46e4f26b22dc2c81e68e2d863\nauthor MarcoFalke <falke.marco@gmail.com> 1618685957 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1618830263 +0200\n\nrefactor: Add and use EnsureConnman in rpc code\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fafb68add5e16e8bd5b9428bcffcaee2639747cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fafb68add5e16e8bd5b9428bcffcaee2639747cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fafb68add5e16e8bd5b9428bcffcaee2639747cf/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faabeb854a6e46b46e4f26b22dc2c81e68e2d863",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/faabeb854a6e46b46e4f26b22dc2c81e68e2d863"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 70,
      "deletions": 51
    },
    "files": [
      {
        "sha": "e25e210e1ebb814dfea4cb4cdccce90997555b14",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fafb68add5e16e8bd5b9428bcffcaee2639747cf",
        "patch": "@@ -199,6 +199,7 @@ BITCOIN_CORE_H = \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n   rpc/mining.h \\\n+  rpc/net.h \\\n   rpc/protocol.h \\\n   rpc/rawtransaction_util.h \\\n   rpc/register.h \\"
      },
      {
        "sha": "abb5a0b3a133a35ac8ca7556afc619087c5442ab",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=fafb68add5e16e8bd5b9428bcffcaee2639747cf",
        "patch": "@@ -18,6 +18,7 @@\n #include <pow.h>\n #include <rpc/blockchain.h>\n #include <rpc/mining.h>\n+#include <rpc/net.h>\n #include <rpc/server.h>\n #include <rpc/util.h>\n #include <script/descriptor.h>\n@@ -671,11 +672,9 @@ static RPCHelpMan getblocktemplate()\n     if (strMode != \"template\")\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n \n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n     if (!Params().IsTestChain()) {\n-        if (node.connman->GetNodeCount(ConnectionDirection::Both) == 0) {\n+        const CConnman& connman = EnsureConnman(node);\n+        if (connman.GetNodeCount(ConnectionDirection::Both) == 0) {\n             throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n         }\n "
      },
      {
        "sha": "fff7d3b604efdfffe4dabc6e53ae9f4c73a86121",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 47,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=fafb68add5e16e8bd5b9428bcffcaee2639747cf",
        "patch": "@@ -39,6 +39,22 @@ const std::vector<std::string> CONNECTION_TYPE_DOC{\n         \"feeler (short-lived automatic connection for testing addresses)\"\n };\n \n+CConnman& EnsureConnman(const NodeContext& node)\n+{\n+    if (!node.connman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+    return *node.connman;\n+}\n+\n+PeerManager& EnsurePeerman(const NodeContext& node)\n+{\n+    if (!node.peerman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+    return *node.peerman;\n+}\n+\n static RPCHelpMan getconnectioncount()\n {\n     return RPCHelpMan{\"getconnectioncount\",\n@@ -54,10 +70,9 @@ static RPCHelpMan getconnectioncount()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n-    return (int)node.connman->GetNodeCount(ConnectionDirection::Both);\n+    return (int)connman.GetNodeCount(ConnectionDirection::Both);\n },\n     };\n }\n@@ -77,12 +92,10 @@ static RPCHelpMan ping()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.peerman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    PeerManager& peerman = EnsurePeerman(node);\n \n     // Request that each node send a ping during next message processing pass\n-    node.peerman->SendPings();\n+    peerman.SendPings();\n     return NullUniValue;\n },\n     };\n@@ -166,19 +179,18 @@ static RPCHelpMan getpeerinfo()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman || !node.peerman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    const CConnman& connman = EnsureConnman(node);\n+    const PeerManager& peerman = EnsurePeerman(node);\n \n     std::vector<CNodeStats> vstats;\n-    node.connman->GetNodeStats(vstats);\n+    connman.GetNodeStats(vstats);\n \n     UniValue ret(UniValue::VARR);\n \n     for (const CNodeStats& stats : vstats) {\n         UniValue obj(UniValue::VOBJ);\n         CNodeStateStats statestats;\n-        bool fStateStats = node.peerman->GetNodeStateStats(stats.nodeid, statestats);\n+        bool fStateStats = peerman.GetNodeStateStats(stats.nodeid, statestats);\n         obj.pushKV(\"id\", stats.nodeid);\n         obj.pushKV(\"addr\", stats.addrName);\n         if (stats.addrBind.IsValid()) {\n@@ -286,27 +298,28 @@ static RPCHelpMan addnode()\n     }\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    CConnman& connman = EnsureConnman(node);\n \n     std::string strNode = request.params[0].get_str();\n \n     if (strCommand == \"onetry\")\n     {\n         CAddress addr;\n-        node.connman->OpenNetworkConnection(addr, false, nullptr, strNode.c_str(), ConnectionType::MANUAL);\n+        connman.OpenNetworkConnection(addr, false, nullptr, strNode.c_str(), ConnectionType::MANUAL);\n         return NullUniValue;\n     }\n \n     if (strCommand == \"add\")\n     {\n-        if(!node.connman->AddNode(strNode))\n+        if (!connman.AddNode(strNode)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: Node already added\");\n+        }\n     }\n     else if(strCommand == \"remove\")\n     {\n-        if(!node.connman->RemoveAddedNode(strNode))\n+        if (!connman.RemoveAddedNode(strNode)) {\n             throw JSONRPCError(RPC_CLIENT_NODE_NOT_ADDED, \"Error: Node could not be removed. It has not been added previously.\");\n+        }\n     }\n \n     return NullUniValue;\n@@ -351,11 +364,9 @@ static RPCHelpMan addconnection()\n     }\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled.\");\n-    }\n+    CConnman& connman = EnsureConnman(node);\n \n-    const bool success = node.connman->AddConnection(address, conn_type);\n+    const bool success = connman.AddConnection(address, conn_type);\n     if (!success) {\n         throw JSONRPCError(RPC_CLIENT_NODE_CAPACITY_REACHED, \"Error: Already at capacity for specified connection type.\");\n     }\n@@ -389,20 +400,19 @@ static RPCHelpMan disconnectnode()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    CConnman& connman = EnsureConnman(node);\n \n     bool success;\n     const UniValue &address_arg = request.params[0];\n     const UniValue &id_arg = request.params[1];\n \n     if (!address_arg.isNull() && id_arg.isNull()) {\n         /* handle disconnect-by-address */\n-        success = node.connman->DisconnectNode(address_arg.get_str());\n+        success = connman.DisconnectNode(address_arg.get_str());\n     } else if (!id_arg.isNull() && (address_arg.isNull() || (address_arg.isStr() && address_arg.get_str().empty()))) {\n         /* handle disconnect-by-id */\n         NodeId nodeid = (NodeId) id_arg.get_int64();\n-        success = node.connman->DisconnectNode(nodeid);\n+        success = connman.DisconnectNode(nodeid);\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMS, \"Only one of address and nodeid should be provided.\");\n     }\n@@ -449,10 +459,9 @@ static RPCHelpMan getaddednodeinfo()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n-    std::vector<AddedNodeInfo> vInfo = node.connman->GetAddedNodeInfo();\n+    std::vector<AddedNodeInfo> vInfo = connman.GetAddedNodeInfo();\n \n     if (!request.params[0].isNull()) {\n         bool found = false;\n@@ -520,21 +529,20 @@ static RPCHelpMan getnettotals()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if(!node.connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    const CConnman& connman = EnsureConnman(node);\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.pushKV(\"totalbytesrecv\", node.connman->GetTotalBytesRecv());\n-    obj.pushKV(\"totalbytessent\", node.connman->GetTotalBytesSent());\n+    obj.pushKV(\"totalbytesrecv\", connman.GetTotalBytesRecv());\n+    obj.pushKV(\"totalbytessent\", connman.GetTotalBytesSent());\n     obj.pushKV(\"timemillis\", GetTimeMillis());\n \n     UniValue outboundLimit(UniValue::VOBJ);\n-    outboundLimit.pushKV(\"timeframe\", count_seconds(node.connman->GetMaxOutboundTimeframe()));\n-    outboundLimit.pushKV(\"target\", node.connman->GetMaxOutboundTarget());\n-    outboundLimit.pushKV(\"target_reached\", node.connman->OutboundTargetReached(false));\n-    outboundLimit.pushKV(\"serve_historical_blocks\", !node.connman->OutboundTargetReached(true));\n-    outboundLimit.pushKV(\"bytes_left_in_cycle\", node.connman->GetOutboundTargetBytesLeft());\n-    outboundLimit.pushKV(\"time_left_in_cycle\", count_seconds(node.connman->GetMaxOutboundTimeLeftInCycle()));\n+    outboundLimit.pushKV(\"timeframe\", count_seconds(connman.GetMaxOutboundTimeframe()));\n+    outboundLimit.pushKV(\"target\", connman.GetMaxOutboundTarget());\n+    outboundLimit.pushKV(\"target_reached\", connman.OutboundTargetReached(false));\n+    outboundLimit.pushKV(\"serve_historical_blocks\", !connman.OutboundTargetReached(true));\n+    outboundLimit.pushKV(\"bytes_left_in_cycle\", connman.GetOutboundTargetBytesLeft());\n+    outboundLimit.pushKV(\"time_left_in_cycle\", count_seconds(connman.GetMaxOutboundTimeLeftInCycle()));\n     obj.pushKV(\"uploadtarget\", outboundLimit);\n     return obj;\n },\n@@ -826,13 +834,11 @@ static RPCHelpMan setnetworkactive()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    CConnman& connman = EnsureConnman(node);\n \n-    node.connman->SetNetworkActive(request.params[0].get_bool());\n+    connman.SetNetworkActive(request.params[0].get_bool());\n \n-    return node.connman->GetNetworkActive();\n+    return connman.GetNetworkActive();\n },\n     };\n }\n@@ -864,15 +870,13 @@ static RPCHelpMan getnodeaddresses()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureAnyNodeContext(request.context);\n-    if (!node.connman) {\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-    }\n+    const CConnman& connman = EnsureConnman(node);\n \n     const int count{request.params[0].isNull() ? 1 : request.params[0].get_int()};\n     if (count < 0) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n \n     // returns a shuffled list of CAddress\n-    const std::vector<CAddress> vAddr{node.connman->GetAddresses(count, /* max_pct */ 0)};\n+    const std::vector<CAddress> vAddr{connman.GetAddresses(count, /* max_pct */ 0)};\n     UniValue ret(UniValue::VARR);\n \n     for (const CAddress& addr : vAddr) {"
      },
      {
        "sha": "7a4d8440ba45b95cbdbd027171bc8f8121e4566a",
        "filename": "src/rpc/net.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fafb68add5e16e8bd5b9428bcffcaee2639747cf/src/rpc/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.h?ref=fafb68add5e16e8bd5b9428bcffcaee2639747cf",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_NET_H\n+#define BITCOIN_RPC_NET_H\n+\n+class CConnman;\n+class PeerManager;\n+struct NodeContext;\n+\n+CConnman& EnsureConnman(const NodeContext& node);\n+PeerManager& EnsurePeerman(const NodeContext& node);\n+\n+#endif // BITCOIN_RPC_NET_H"
      }
    ]
  }
]