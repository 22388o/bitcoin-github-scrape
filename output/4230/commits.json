[
  {
    "sha": "28a7464bb7e851800c4924162ecd9d1ec5961288",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOGE3NDY0YmI3ZTg1MTgwMGM0OTI0MTYyZWNkOWQxZWM1OTYxMjg4",
    "commit": {
      "author": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2014-08-28T11:17:06Z"
      },
      "committer": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2014-09-02T09:45:47Z"
      },
      "message": "Refactor message handling for lower latency #4230\n\n- ThreadMessageHandler woken up by events that require it\n- TRY_LOCKs replaced with LOCKs to limit worst-case delays\n- Trickle behaviour split into separate thread\n- SendMessages() split in two: original now only handles cs_main-dependent work",
      "tree": {
        "sha": "63ac364c2fa5a75bbeef3b7e8932e27a78d3578f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63ac364c2fa5a75bbeef3b7e8932e27a78d3578f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28a7464bb7e851800c4924162ecd9d1ec5961288",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG/MacGPG2 v2.0.20 (Darwin)\n\niQGcBAABAgAGBQJUBZHsAAoJEDVfPwlxLasyXkML/jVTJc53dQ/kLJ94+AFmxpBF\n2nbzT8Jn1z8KRz3fio+JVeiZsI+AkZKE4IKs4HJ6qoWbMY3OWwbkGiWVgao4uZ4Z\nxJ0VoFi3A8viWEzAHR+VVkTrHhdUseKNx3cFvPIjS0cSavyjbFfgXKEuo8qu63D/\nI1vCdAD4JhCs3zzKYO284hEFbOKNEmebX5mr3BJnk4LK1Hrzib5XBBYefG4IzGM0\nc1y66I0ofyTjhQ/yadN9y5xk7/fsJIN9vYQd5iTfSg9vC+dBaXflQ8u88FJgEcC9\nmYpzYcQhrE16eWbISN5YIdmNQ3Qzp6GDUcUl6bNjlNlI4CpoQXs708Nj0Ca9YoUy\n6P6sTpcJ0RTkSPSnMqpV0uE0/UCDkUj2JZe134ppbQnA79OAP1AOORa1vJlCRn7n\n6cUhe+a++QQK+mHv0xLDOvC1Gv2Dl5/EGEa24IjzImTM+tzacLYxt739+SMcfhjx\np1ukEhdjVN3O3qrPZ/RUVQsAJUdTlYjZkwnZEsaHjw==\n=c75I\n-----END PGP SIGNATURE-----",
        "payload": "tree 63ac364c2fa5a75bbeef3b7e8932e27a78d3578f\nparent 11a899445edf3e07317eb312d3c1d9c71c06f618\nauthor Ashley Holman <dscvlt@gmail.com> 1409224626 +1000\ncommitter Ashley Holman <dscvlt@gmail.com> 1409651147 +1000\n\nRefactor message handling for lower latency #4230\n\n- ThreadMessageHandler woken up by events that require it\n- TRY_LOCKs replaced with LOCKs to limit worst-case delays\n- Trickle behaviour split into separate thread\n- SendMessages() split in two: original now only handles cs_main-dependent work\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28a7464bb7e851800c4924162ecd9d1ec5961288",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/28a7464bb7e851800c4924162ecd9d1ec5961288",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28a7464bb7e851800c4924162ecd9d1ec5961288/comments",
    "author": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "11a899445edf3e07317eb312d3c1d9c71c06f618",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11a899445edf3e07317eb312d3c1d9c71c06f618",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/11a899445edf3e07317eb312d3c1d9c71c06f618"
      }
    ],
    "stats": {
      "total": 322,
      "additions": 214,
      "deletions": 108
    },
    "files": [
      {
        "sha": "e326fb708119bf7aa0e27830acb124af59f14913",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 81,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a7464bb7e851800c4924162ecd9d1ec5961288/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a7464bb7e851800c4924162ecd9d1ec5961288/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=28a7464bb7e851800c4924162ecd9d1ec5961288",
        "patch": "@@ -283,6 +283,7 @@ void MarkBlockAsReceived(const uint256 &hash, NodeId nodeFrom = -1) {\n         CNodeState *state = State(itInFlight->second.first);\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n         state->nBlocksInFlight--;\n+        WakeMessageHandler();\n         if (itInFlight->second.first == nodeFrom)\n             state->nLastBlockReceive = GetTimeMicros();\n         mapBlocksInFlight.erase(itInFlight);\n@@ -1380,6 +1381,7 @@ void Misbehaving(NodeId pnode, int howmuch)\n     {\n         LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n         state->fShouldBan = true;\n+        WakeMessageHandler();\n     } else\n         LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n }\n@@ -1410,6 +1412,7 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n             State(it->second)->rejects.push_back(reject);\n             if (nDoS > 0)\n                 Misbehaving(it->second, nDoS);\n+            WakeMessageHandler();\n         }\n     }\n     if (!state.CorruptionPossible()) {\n@@ -4025,6 +4028,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == \"pong\")\n     {\n+        LOCK(pfrom->cs_ping);\n         int64_t pingUsecEnd = nTimeReceived;\n         uint64_t nonce = 0;\n         size_t nAvail = vRecv.in_avail();\n@@ -4317,45 +4321,15 @@ bool ProcessMessages(CNode* pfrom)\n }\n \n \n+// Perform SendMessages tasks that require cs_main, such as addr and getdata messages.\n bool SendMessages(CNode* pto, bool fSendTrickle)\n {\n     {\n         // Don't send anything until we get their version message\n         if (pto->nVersion == 0)\n             return true;\n \n-        //\n-        // Message: ping\n-        //\n-        bool pingSend = false;\n-        if (pto->fPingQueued) {\n-            // RPC ping request by user\n-            pingSend = true;\n-        }\n-        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {\n-            // Ping automatically sent as a latency probe & keepalive.\n-            pingSend = true;\n-        }\n-        if (pingSend) {\n-            uint64_t nonce = 0;\n-            while (nonce == 0) {\n-                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n-            }\n-            pto->fPingQueued = false;\n-            pto->nPingUsecStart = GetTimeMicros();\n-            if (pto->nVersion > BIP0031_VERSION) {\n-                pto->nPingNonceSent = nonce;\n-                pto->PushMessage(\"ping\", nonce);\n-            } else {\n-                // Peer is too old to support ping command with nonce, pong will never arrive.\n-                pto->nPingNonceSent = 0;\n-                pto->PushMessage(\"ping\");\n-            }\n-        }\n-\n-        TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n-        if (!lockMain)\n-            return true;\n+        LOCK2(cs_main, pto->cs_vSend); // cs_main required for IsInitialBlockDownload() and CNodeState()\n \n         // Address refresh broadcast\n         static int64_t nLastRebroadcast;\n@@ -4439,55 +4413,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             g_signals.Broadcast();\n         }\n \n-        //\n-        // Message: inventory\n-        //\n-        vector<CInv> vInv;\n-        vector<CInv> vInvWait;\n-        {\n-            LOCK(pto->cs_inventory);\n-            vInv.reserve(pto->vInventoryToSend.size());\n-            vInvWait.reserve(pto->vInventoryToSend.size());\n-            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n-            {\n-                if (pto->setInventoryKnown.count(inv))\n-                    continue;\n-\n-                // trickle out tx inv to protect privacy\n-                if (inv.type == MSG_TX && !fSendTrickle)\n-                {\n-                    // 1/4 of tx invs blast to all immediately\n-                    static uint256 hashSalt;\n-                    if (hashSalt == 0)\n-                        hashSalt = GetRandHash();\n-                    uint256 hashRand = inv.hash ^ hashSalt;\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    bool fTrickleWait = ((hashRand & 3) != 0);\n-\n-                    if (fTrickleWait)\n-                    {\n-                        vInvWait.push_back(inv);\n-                        continue;\n-                    }\n-                }\n-\n-                // returns true if wasn't already contained in the set\n-                if (pto->setInventoryKnown.insert(inv).second)\n-                {\n-                    vInv.push_back(inv);\n-                    if (vInv.size() >= 1000)\n-                    {\n-                        pto->PushMessage(\"inv\", vInv);\n-                        vInv.clear();\n-                    }\n-                }\n-            }\n-            pto->vInventoryToSend = vInvWait;\n-        }\n-        if (!vInv.empty())\n-            pto->PushMessage(\"inv\", vInv);\n-\n-\n         // Detect stalled peers. Require that blocks are in flight, we haven't\n         // received a (requested) block in one minute, and that all blocks are\n         // in flight for over two minutes, since we first had a chance to"
      },
      {
        "sha": "c3c564fa0c0df33f47009ff7ca8b5722289d5bb9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 161,
        "deletions": 25,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a7464bb7e851800c4924162ecd9d1ec5961288/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a7464bb7e851800c4924162ecd9d1ec5961288/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=28a7464bb7e851800c4924162ecd9d1ec5961288",
        "patch": "@@ -99,6 +99,7 @@ NodeId nLastNodeId = 0;\n CCriticalSection cs_nLastNodeId;\n \n static CSemaphore *semOutbound = NULL;\n+CTimeoutCondition condMessageHandler;\n \n // Signals for message handling\n static CNodeSignals g_signals;\n@@ -665,8 +666,11 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n         pch += handled;\n         nBytes -= handled;\n \n-        if (msg.complete())\n+        if (msg.complete()) {\n             msg.nTime = GetTimeMicros();\n+            // signal to Message Handler that there is a new complete message\n+            WakeMessageHandler();\n+        }\n     }\n \n     return true;\n@@ -745,6 +749,9 @@ void SocketSendData(CNode *pnode)\n                 pnode->nSendOffset = 0;\n                 pnode->nSendSize -= data.size();\n                 it++;\n+                // send buffer has decreased, so possibly we can send new\n+                // messages now\n+                WakeMessageHandler();\n             } else {\n                 // could not send full message; stop sending more\n                 break;\n@@ -1068,10 +1075,13 @@ void ThreadSocketHandler()\n                     LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n                     pnode->fDisconnect = true;\n                 }\n-                else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n-                {\n-                    LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n-                    pnode->fDisconnect = true;\n+                else {\n+                    LOCK(pnode->cs_ping);\n+                    if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n+                    {\n+                        LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n+                        pnode->fDisconnect = true;\n+                    }\n                 }\n             }\n         }\n@@ -1523,6 +1533,7 @@ void static StartSync(const vector<CNode*> &vNodes) {\n     if (pnodeNewSync) {\n         pnodeNewSync->fStartSync = true;\n         pnodeSync = pnodeNewSync;\n+        WakeMessageHandler();\n     }\n }\n \n@@ -1548,10 +1559,6 @@ void ThreadMessageHandler()\n             StartSync(vNodesCopy);\n \n         // Poll the connected nodes for messages\n-        CNode* pnodeTrickle = NULL;\n-        if (!vNodesCopy.empty())\n-            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n-\n         bool fSleep = true;\n \n         BOOST_FOREACH(CNode* pnode, vNodesCopy)\n@@ -1561,29 +1568,23 @@ void ThreadMessageHandler()\n \n             // Receive messages\n             {\n-                TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n-                if (lockRecv)\n-                {\n-                    if (!g_signals.ProcessMessages(pnode))\n-                        pnode->CloseSocketDisconnect();\n+                LOCK(pnode->cs_vRecvMsg);\n+                if (!g_signals.ProcessMessages(pnode))\n+                    pnode->CloseSocketDisconnect();\n \n-                    if (pnode->nSendSize < SendBufferSize())\n+                if (pnode->nSendSize < SendBufferSize())\n+                {\n+                    if (!pnode->vRecvGetData.empty() || (!pnode->vRecvMsg.empty() && pnode->vRecvMsg[0].complete()))\n                     {\n-                        if (!pnode->vRecvGetData.empty() || (!pnode->vRecvMsg.empty() && pnode->vRecvMsg[0].complete()))\n-                        {\n-                            fSleep = false;\n-                        }\n+                        fSleep = false;\n                     }\n                 }\n             }\n             boost::this_thread::interruption_point();\n \n             // Send messages\n-            {\n-                TRY_LOCK(pnode->cs_vSend, lockSend);\n-                if (lockSend)\n-                    g_signals.SendMessages(pnode, pnode == pnodeTrickle);\n-            }\n+            g_signals.SendMessages(pnode, false);\n+\n             boost::this_thread::interruption_point();\n         }\n \n@@ -1594,14 +1595,139 @@ void ThreadMessageHandler()\n         }\n \n         if (fSleep)\n-            MilliSleep(100);\n+            condMessageHandler.timed_wait(1000);\n     }\n }\n \n+void ThreadTrickle ()\n+{\n+    SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n \n+    while (true)\n+    {\n+        CNode* pnodeTrickle = NULL;\n+\n+        boost::this_thread::interruption_point();\n+\n+        {\n+            LOCK(cs_vNodes);\n+            if (!vNodes.empty()) {\n+                pnodeTrickle = vNodes[GetRand(vNodes.size())];\n+                pnodeTrickle->AddRef();\n+            }\n+        }\n \n+        boost::this_thread::interruption_point();\n+\n+        if (pnodeTrickle)\n+        {\n+            // Send messages\n+            g_signals.SendMessages(pnodeTrickle, true);\n+\n+            LOCK(cs_vNodes);\n+            pnodeTrickle->Release();\n+        }\n \n+        MilliSleep(100);\n+    }\n+}\n \n+// Sends ping and inv messages\n+bool SendMessagesNet(CNode* pto, bool fSendTrickle)\n+{\n+    // Don't send anything until we get their version message\n+    if (pto->nVersion == 0)\n+        return true;\n+\n+    LOCK(pto->cs_vSend);\n+\n+    //\n+    // Message: ping\n+    //\n+    {\n+        LOCK(pto->cs_ping);\n+        bool pingSend = false;\n+        if (pto->fPingQueued) {\n+            // RPC ping request by user\n+            pingSend = true;\n+        }\n+        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {\n+            // Ping automatically sent as a latency probe & keepalive.\n+            pingSend = true;\n+        }\n+        if (pingSend) {\n+            uint64_t nonce = 0;\n+            while (nonce == 0) {\n+                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n+            }\n+            pto->fPingQueued = false;\n+            pto->nPingUsecStart = GetTimeMicros();\n+            if (pto->nVersion > BIP0031_VERSION) {\n+                pto->nPingNonceSent = nonce;\n+                pto->PushMessage(\"ping\", nonce);\n+            } else {\n+                // Peer is too old to support ping command with nonce, pong will never arrive.\n+                pto->nPingNonceSent = 0;\n+                pto->PushMessage(\"ping\");\n+            }\n+        }\n+    }\n+\n+    //\n+    // Message: inventory\n+    //\n+    vector<CInv> vInv;\n+    vector<CInv> vInvWait;\n+    {\n+        LOCK(pto->cs_inventory);\n+        vInv.reserve(pto->vInventoryToSend.size());\n+        vInvWait.reserve(pto->vInventoryToSend.size());\n+        BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n+        {\n+            if (pto->setInventoryKnown.count(inv))\n+                continue;\n+\n+            // trickle out tx inv to protect privacy\n+            if (inv.type == MSG_TX && !fSendTrickle)\n+            {\n+                // 1/4 of tx invs blast to all immediately\n+                static uint256 hashSalt;\n+                if (hashSalt == 0)\n+                    hashSalt = GetRandHash();\n+                uint256 hashRand = inv.hash ^ hashSalt;\n+                hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                bool fTrickleWait = ((hashRand & 3) != 0);\n+\n+                if (fTrickleWait)\n+                {\n+                    vInvWait.push_back(inv);\n+                    continue;\n+                }\n+            }\n+\n+            // returns true if wasn't already contained in the set\n+            if (pto->setInventoryKnown.insert(inv).second)\n+            {\n+                vInv.push_back(inv);\n+                if (vInv.size() >= 1000)\n+                {\n+                    pto->PushMessage(\"inv\", vInv);\n+                    vInv.clear();\n+                }\n+            }\n+        }\n+        pto->vInventoryToSend = vInvWait;\n+    }\n+    if (!vInv.empty())\n+        pto->PushMessage(\"inv\", vInv);\n+\n+    return true;\n+}\n+\n+void WakeMessageHandler()\n+{\n+    condMessageHandler.notify_one();\n+}\n \n bool BindListenPort(const CService &addrBind, string& strError, bool fWhitelisted)\n {\n@@ -1756,6 +1882,9 @@ void StartNode(boost::thread_group& threadGroup)\n \n     Discover(threadGroup);\n \n+    // Register SendMessages handler\n+    g_signals.SendMessages.connect(&SendMessagesNet);\n+\n     //\n     // Start threads\n     //\n@@ -1780,6 +1909,9 @@ void StartNode(boost::thread_group& threadGroup)\n     // Process messages\n     threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"msghand\", &ThreadMessageHandler));\n \n+    // Trickle messages\n+    threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"trickle\", &ThreadTrickle));\n+\n     // Dump network addresses\n     threadGroup.create_thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, DUMP_ADDRESSES_INTERVAL * 1000));\n }\n@@ -2133,6 +2265,7 @@ void CNode::AskFor(const CInv& inv)\n     else\n         mapAlreadyAskedFor.insert(std::make_pair(inv, nRequestTime));\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n+    WakeMessageHandler();\n }\n \n void CNode::BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSend)\n@@ -2191,4 +2324,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n         SocketSendData(this);\n \n     LEAVE_CRITICAL_SECTION(cs_vSend);\n+\n+    // wake up ThreadMessageHandler\n+    WakeMessageHandler();\n }"
      },
      {
        "sha": "5448311eae74388758f1837968e90dd2ef2adda7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a7464bb7e851800c4924162ecd9d1ec5961288/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a7464bb7e851800c4924162ecd9d1ec5961288/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=28a7464bb7e851800c4924162ecd9d1ec5961288",
        "patch": "@@ -52,6 +52,9 @@ static const bool DEFAULT_UPNP = USE_UPNP;\n static const bool DEFAULT_UPNP = false;\n #endif\n \n+/* notify when new protocol messages can be sent/received */\n+void WakeMessageHandler();\n+\n unsigned int ReceiveFloodSize();\n unsigned int SendBufferSize();\n \n@@ -300,6 +303,8 @@ class CNode\n     int64_t nPingUsecTime;\n     // Whether a ping is requested.\n     bool fPingQueued;\n+    // Lock to protect ping state.\n+    CCriticalSection cs_ping;\n \n     CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn = \"\", bool fInboundIn=false);\n     ~CNode();\n@@ -369,8 +374,10 @@ class CNode\n         // Known checking here is only to save space from duplicates.\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n-        if (addr.IsValid() && !setAddrKnown.count(addr))\n+        if (addr.IsValid() && !setAddrKnown.count(addr)) {\n             vAddrToSend.push_back(addr);\n+            WakeMessageHandler();\n+        }\n     }\n \n \n@@ -386,8 +393,10 @@ class CNode\n     {\n         {\n             LOCK(cs_inventory);\n-            if (!setInventoryKnown.count(inv))\n+            if (!setInventoryKnown.count(inv)) {\n                 vInventoryToSend.push_back(inv);\n+                WakeMessageHandler();\n+            }\n         }\n     }\n "
      },
      {
        "sha": "ae8c2beb6a9f561a92c7063d8eb402d7d42d1f23",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a7464bb7e851800c4924162ecd9d1ec5961288/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a7464bb7e851800c4924162ecd9d1ec5961288/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=28a7464bb7e851800c4924162ecd9d1ec5961288",
        "patch": "@@ -53,6 +53,7 @@ Value ping(const Array& params, bool fHelp)\n     BOOST_FOREACH(CNode* pNode, vNodes) {\n         pNode->fPingQueued = true;\n     }\n+    WakeMessageHandler();\n \n     return Value::null;\n }"
      },
      {
        "sha": "068f356a3dd4430ac41a1b658d227ab3a03349af",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a7464bb7e851800c4924162ecd9d1ec5961288/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a7464bb7e851800c4924162ecd9d1ec5961288/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=28a7464bb7e851800c4924162ecd9d1ec5961288",
        "patch": "@@ -103,6 +103,41 @@ void static inline AssertLockHeldInternal(const char* pszName, const char* pszFi\n void PrintLockContention(const char* pszName, const char* pszFile, int nLine);\n #endif\n \n+class CTimeoutCondition\n+{\n+private:\n+    boost::condition_variable condition;\n+    boost::mutex mutex;\n+    bool fHasWork;\n+    boost::posix_time::ptime alarm;\n+\n+public:\n+    void wait() {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        while (!fHasWork) {\n+            condition.wait(lock);\n+        }\n+        fHasWork = false;\n+    }\n+\n+    void timed_wait(int milliseconds) {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        boost::posix_time::ptime now = boost::posix_time::microsec_clock::universal_time();\n+        alarm = now + boost::posix_time::milliseconds(milliseconds);\n+        while (!fHasWork && now < alarm) {\n+            condition.timed_wait(lock, alarm);\n+            now = boost::posix_time::microsec_clock::universal_time();\n+        }\n+        fHasWork = false;\n+    }\n+\n+    void notify_one() {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        fHasWork = true;\n+        condition.notify_one();\n+    }\n+};\n+\n /** Wrapper around boost::unique_lock<Mutex> */\n template<typename Mutex>\n class CMutexLock"
      }
    ]
  }
]