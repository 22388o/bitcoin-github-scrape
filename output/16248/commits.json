[
  {
    "sha": "e5b26deaaa6842f7dd7c4537ede000f965ea0189",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNWIyNmRlYWFhNjg0MmY3ZGQ3YzQ1MzdlZGUwMDBmOTY1ZWEwMTg5",
    "commit": {
      "author": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-06-20T09:37:51Z"
      },
      "committer": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-08-11T02:33:27Z"
      },
      "message": "Make whitebind/whitelist permissions more flexible",
      "tree": {
        "sha": "c45a24d8290b86ef74bb6b95287de5972768caa2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c45a24d8290b86ef74bb6b95287de5972768caa2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5b26deaaa6842f7dd7c4537ede000f965ea0189",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEq0z6mJWsoNvif2s0Zhh2PvCRhv4FAl1PfncACgkQZhh2PvCR\nhv6prQ//bIm7Tq/m6Ok2F5IzofY9zxhINX6TeiTFfaOj1wAxiuNeJJw3KED1+29x\nWtxFbGxalGvgaWKDTyVN8wJn7aQOFBAu8EaitJAFHAYCaJuEedRlDbZkVTwvK6rF\nGGlIHwkjhnWd/OVy5sjs/Clo2+VV9+OlktCqXif609/ui9LbADbXUPJ8g3S5kLXD\n7HWJBu0smBlyBE7+aHBVd5BcNl6nUU1QaZAId4y8WDt2ZXcLg+cv71wyPUpFKxtB\n+30MzTzGgYDPilp/E57NFznr+IFnubT/4zm1c/mCbmQy2nM9eSt0e23CIbxID7hV\ns69HJPdrUmm09vVKC+fUqRp8swhVjv6lk5jCpp7YDFrO7fvsODquA53GrPJRJ7I7\nhXTKPBZP71gXPFc3r0giLMx/KTpuq2Ojkp8ztyK7eDtSsXLrn/pl/6SzoM0Tm0bL\nN5vW4+GsN4cyIZAzYURhVpxZVRsT//Oz8la3z3p0cHSXyQuFbCK6gsIbVdOfVaVM\n/8Zofq6Nd3HVa2MQcmc9+zZ7FCoUk88vEu+Xs5PeDT6+DYQso7XV9z+faXJ3Ymgb\nlI9Puunl1IzPaMIfSFQpE7JBzLcIUz39Dvzgj46LZ/oWCI7wvQ+Z/PqapUi2AVtk\nZgBFj7x+7rDHoyJsMsuTZA3eFN1LELbfH82UwxWtCot8j8kJ0Uo=\n=4va1\n-----END PGP SIGNATURE-----",
        "payload": "tree c45a24d8290b86ef74bb6b95287de5972768caa2\nparent e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e\nauthor nicolas.dorier <nicolas.dorier@gmail.com> 1561023471 +0900\ncommitter nicolas.dorier <nicolas.dorier@gmail.com> 1565490807 +0900\n\nMake whitebind/whitelist permissions more flexible\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5b26deaaa6842f7dd7c4537ede000f965ea0189",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e5b26deaaa6842f7dd7c4537ede000f965ea0189",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5b26deaaa6842f7dd7c4537ede000f965ea0189/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e"
      }
    ],
    "stats": {
      "total": 364,
      "additions": 321,
      "deletions": 43
    },
    "files": [
      {
        "sha": "141d8e68ea20fe5f44fc892f691f525123c2c621",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -150,6 +150,7 @@ BITCOIN_CORE_H = \\\n   merkleblock.h \\\n   miner.h \\\n   net.h \\\n+  net_permissions.h \\\n   net_processing.h \\\n   netaddress.h \\\n   netbase.h \\\n@@ -454,6 +455,7 @@ libbitcoin_common_a_SOURCES = \\\n   merkleblock.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\\n+  net_permissions.cpp \\\n   outputtype.cpp \\\n   policy/feerate.cpp \\\n   policy/policy.cpp \\"
      },
      {
        "sha": "25c964205a539a3689deaa6d742edfe4197e7457",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 12,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -27,6 +27,7 @@\n #include <key.h>\n #include <miner.h>\n #include <net.h>\n+#include <net_permissions.h>\n #include <net_processing.h>\n #include <netbase.h>\n #include <policy/feerate.h>\n@@ -1775,21 +1776,16 @@ bool AppInitMain(InitInterfaces& interfaces)\n         connOptions.vBinds.push_back(addrBind);\n     }\n     for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n-        CService addrBind;\n-        if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n-            return InitError(ResolveErrMsg(\"whitebind\", strBind));\n-        }\n-        if (addrBind.GetPort() == 0) {\n-            return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\").translated, strBind));\n-        }\n-        connOptions.vWhiteBinds.push_back(addrBind);\n+        NetWhitebindPermissions whitebind;\n+        std::string error;\n+        if (!NetWhitebindPermissions::TryParse(strBind, whitebind, error)) return InitError(error);\n+        connOptions.vWhiteBinds.push_back(whitebind);\n     }\n \n     for (const auto& net : gArgs.GetArgs(\"-whitelist\")) {\n-        CSubNet subnet;\n-        LookupSubNet(net.c_str(), subnet);\n-        if (!subnet.IsValid())\n-            return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\").translated, net));\n+        NetWhitelistPermissions subnet;\n+        std::string error;\n+        if (!NetWhitelistPermissions::TryParse(net, subnet, error)) return InitError(error);\n         connOptions.vWhitelistedRange.push_back(subnet);\n     }\n "
      },
      {
        "sha": "fb04650ed75488ca7414ff0991f1712700f72a4a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 20,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -16,6 +16,7 @@\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n #include <netbase.h>\n+#include <net_permissions.h>\n #include <primitives/transaction.h>\n #include <scheduler.h>\n #include <ui_interface.h>\n@@ -67,7 +68,6 @@ enum BindFlags {\n     BF_NONE         = 0,\n     BF_EXPLICIT     = (1U << 0),\n     BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n };\n \n // The set of sockets cannot be modified while waiting\n@@ -459,12 +459,10 @@ void CNode::CloseSocketDisconnect()\n     }\n }\n \n-bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n-    for (const CSubNet& subnet : vWhitelistedRange) {\n-        if (subnet.Match(addr))\n-            return true;\n+void CConnman::AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const {\n+    for (const auto& subnet : vWhitelistedRange) {\n+        if (subnet.m_subnet.Match(addr)) NetPermissions::AddFlag(flags, subnet.m_flags);\n     }\n-    return false;\n }\n \n std::string CNode::GetAddrName() const {\n@@ -529,6 +527,7 @@ void CNode::copyStats(CNodeStats &stats)\n         X(nRecvBytes);\n     }\n     X(fWhitelisted);\n+    X(m_permissionFlags);\n     {\n         LOCK(cs_feeFilter);\n         X(minFeeFilter);\n@@ -904,7 +903,20 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n         }\n     }\n \n-    bool whitelisted = hListenSocket.whitelisted || IsWhitelistedRange(addr);\n+    NetPermissionFlags permissionFlags = NetPermissionFlags::PF_NONE;\n+    hListenSocket.AddSocketPermissionFlags(permissionFlags);\n+    AddWhitelistPermissionFlags(permissionFlags, addr);\n+    const bool noban = NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_NOBAN);\n+    bool legacyWhitelisted = false;\n+    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_ISIMPLICIT)) {\n+        NetPermissions::ClearFlag(permissionFlags, PF_ISIMPLICIT);\n+        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", false)) NetPermissions::AddFlag(permissionFlags, PF_FORCERELAY);\n+        if (gArgs.GetBoolArg(\"-whitelistrelay\", false)) NetPermissions::AddFlag(permissionFlags, PF_RELAY);\n+        NetPermissions::AddFlag(permissionFlags, PF_MEMPOOL);\n+        NetPermissions::AddFlag(permissionFlags, PF_NOBAN);\n+        legacyWhitelisted = true;\n+    }\n+\n     {\n         LOCK(cs_vNodes);\n         for (const CNode* pnode : vNodes) {\n@@ -941,7 +953,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     // Don't accept connections from banned peers, but if our inbound slots aren't almost full, accept\n     // if the only banning reason was an automatic misbehavior ban.\n-    if (!whitelisted && bannedlevel > ((nInbound + 1 < nMaxInbound) ? 1 : 0))\n+    if (!noban && bannedlevel > ((nInbound + 1 < nMaxInbound) ? 1 : 0))\n     {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n@@ -962,9 +974,15 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n     CAddress addr_bind = GetBindAddress(hSocket);\n \n-    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n+    ServiceFlags nodeServices = nLocalServices;\n+    if (NetPermissions::HasFlag(permissionFlags, PF_BLOOMFILTER)) {\n+        nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);\n+    }\n+    CNode* pnode = new CNode(id, nodeServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n-    pnode->fWhitelisted = whitelisted;\n+    pnode->m_permissionFlags = permissionFlags;\n+    // If this flag is present, the user probably expect that RPC and QT report it as whitelisted (backward compatibility)\n+    pnode->fWhitelisted = legacyWhitelisted;\n     pnode->m_prefer_evict = bannedlevel > 0;\n     m_msgproc->InitializeNode(pnode);\n \n@@ -1983,7 +2001,7 @@ void CConnman::ThreadMessageHandler()\n \n \n \n-bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, bool fWhitelisted)\n+bool CConnman::BindListenPort(const CService& addrBind, std::string& strError, NetPermissionFlags permissions)\n {\n     strError = \"\";\n     int nOne = 1;\n@@ -2044,9 +2062,9 @@ bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, b\n         return false;\n     }\n \n-    vhListenSocket.push_back(ListenSocket(hListenSocket, fWhitelisted));\n+    vhListenSocket.push_back(ListenSocket(hListenSocket, permissions));\n \n-    if (addrBind.IsRoutable() && fDiscover && !fWhitelisted)\n+    if (addrBind.IsRoutable() && fDiscover && (permissions & PF_NOBAN) == 0)\n         AddLocal(addrBind, LOCAL_BIND);\n \n     return true;\n@@ -2130,11 +2148,11 @@ NodeId CConnman::GetNewNodeId()\n }\n \n \n-bool CConnman::Bind(const CService &addr, unsigned int flags) {\n+bool CConnman::Bind(const CService &addr, unsigned int flags, NetPermissionFlags permissions) {\n     if (!(flags & BF_EXPLICIT) && !IsReachable(addr))\n         return false;\n     std::string strError;\n-    if (!BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n+    if (!BindListenPort(addr, strError, permissions)) {\n         if ((flags & BF_REPORT_ERROR) && clientInterface) {\n             clientInterface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n@@ -2143,20 +2161,21 @@ bool CConnman::Bind(const CService &addr, unsigned int flags) {\n     return true;\n }\n \n-bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds) {\n+bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<NetWhitebindPermissions>& whiteBinds)\n+{\n     bool fBound = false;\n     for (const auto& addrBind : binds) {\n-        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR), NetPermissionFlags::PF_NONE);\n     }\n     for (const auto& addrBind : whiteBinds) {\n-        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n+        fBound |= Bind(addrBind.m_service, (BF_EXPLICIT | BF_REPORT_ERROR), addrBind.m_flags);\n     }\n     if (binds.empty() && whiteBinds.empty()) {\n         struct in_addr inaddr_any;\n         inaddr_any.s_addr = INADDR_ANY;\n         struct in6_addr inaddr6_any = IN6ADDR_ANY_INIT;\n-        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE);\n-        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n+        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE, NetPermissionFlags::PF_NONE);\n+        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE, NetPermissionFlags::PF_NONE);\n     }\n     return fBound;\n }"
      },
      {
        "sha": "8e4521694ec9fdbc0e2b4a00636a8b557266fd79",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 19,
        "deletions": 11,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -15,6 +15,7 @@\n #include <hash.h>\n #include <limitedmap.h>\n #include <netaddress.h>\n+#include <net_permissions.h>\n #include <policy/feerate.h>\n #include <protocol.h>\n #include <random.h>\n@@ -138,8 +139,9 @@ class CConnman\n         uint64_t nMaxOutboundLimit = 0;\n         int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n         std::vector<std::string> vSeedNodes;\n-        std::vector<CSubNet> vWhitelistedRange;\n-        std::vector<CService> vBinds, vWhiteBinds;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n         bool m_use_addrman_outgoing = true;\n         std::vector<std::string> m_specified_outgoing;\n         std::vector<std::string> m_added_nodes;\n@@ -314,15 +316,17 @@ class CConnman\n \n private:\n     struct ListenSocket {\n+    public:\n         SOCKET socket;\n-        bool whitelisted;\n-\n-        ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n-    bool Bind(const CService &addr, unsigned int flags);\n-    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n+    bool BindListenPort(const CService& bindAddr, std::string& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(const std::vector<CService>& binds, const std::vector<NetWhitebindPermissions>& whiteBinds);\n     void ThreadOpenAddedConnections();\n     void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n@@ -347,7 +351,7 @@ class CConnman\n \n     bool AttemptToEvictConnection();\n     CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection);\n-    bool IsWhitelistedRange(const CNetAddr &addr);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n \n     void DeleteNode(CNode* pnode);\n \n@@ -380,7 +384,7 @@ class CConnman\n \n     // Whitelisted ranges. Any node connecting from these is automatically\n     // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<CSubNet> vWhitelistedRange;\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n     unsigned int nSendBufferMaxSize{0};\n     unsigned int nReceiveFloodSize{0};\n@@ -448,7 +452,6 @@ void StartMapPort();\n void InterruptMapPort();\n void StopMapPort();\n unsigned short GetListenPort();\n-bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n \n struct CombinerAll\n {\n@@ -555,6 +558,7 @@ class CNodeStats\n     mapMsgCmdSize mapSendBytesPerMsgCmd;\n     uint64_t nRecvBytes;\n     mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n     bool fWhitelisted;\n     double dPingTime;\n     double dPingWait;\n@@ -657,6 +661,9 @@ class CNode\n      */\n     std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n     bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n     bool fWhitelisted{false}; // This peer can bypass DoS banning.\n     bool fFeeler{false}; // If true this node is being used as a short lived feeler.\n     bool fOneShot{false};\n@@ -753,6 +760,7 @@ class CNode\n     const ServiceFlags nLocalServices;\n     const int nMyStartingHeight;\n     int nSendVersion{0};\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n     std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n     mutable CCriticalSection cs_addrName;"
      },
      {
        "sha": "736f19293a1b5b6bd5be32e24a92e01ec96451ae",
        "filename": "src/net_permissions.cpp",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net_permissions.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net_permissions.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.cpp?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -0,0 +1,106 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_permissions.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <netbase.h>\n+\n+// The parse the following format \"perm1,perm2@xxxxxx\"\n+bool TryParsePermissionFlags(const std::string str, NetPermissionFlags& output, size_t& readen, std::string& error)\n+{\n+    NetPermissionFlags flags = PF_NONE;\n+    const auto atSeparator = str.find('@');\n+\n+    // if '@' is not found (ie, \"xxxxx\"), the caller should apply implicit permissions\n+    if (atSeparator == std::string::npos) {\n+        NetPermissions::AddFlag(flags, PF_ISIMPLICIT);\n+        readen = 0;\n+    }\n+    // else (ie, \"perm1,perm2@xxxxx\"), let's enumerate the permissions by splitting by ',' and calculate the flags\n+    else {\n+        readen = 0;\n+        // permissions == perm1,perm2\n+        const auto permissions = str.substr(0, atSeparator);\n+        while (readen < permissions.length()) {\n+            const auto commaSeparator = permissions.find(',', readen);\n+            const auto len = commaSeparator == std::string::npos ? permissions.length() - readen : commaSeparator - readen;\n+            // permission == perm1\n+            const auto permission = permissions.substr(readen, len);\n+            readen += len; // We read \"perm1\"\n+            if (commaSeparator != std::string::npos) readen++; // We read \",\"\n+\n+            if (permission == \"bloomfilter\" || permission == \"bloom\") NetPermissions::AddFlag(flags, PF_BLOOMFILTER);\n+            else if (permission == \"noban\") NetPermissions::AddFlag(flags, PF_NOBAN);\n+            else if (permission == \"forcerelay\") NetPermissions::AddFlag(flags, PF_FORCERELAY);\n+            else if (permission == \"mempool\") NetPermissions::AddFlag(flags, PF_MEMPOOL);\n+            else if (permission == \"all\") NetPermissions::AddFlag(flags, PF_ALL);\n+            else if (permission == \"relay\") NetPermissions::AddFlag(flags, PF_RELAY);\n+            else if (permission.length() == 0); // Allow empty entries\n+            else {\n+                error = strprintf(_(\"Invalid P2P permission: '%s'\").translated, permission);\n+                return false;\n+            }\n+        }\n+        readen++;\n+    }\n+\n+    output = flags;\n+    error = \"\";\n+    return true;\n+}\n+\n+std::vector<std::string> NetPermissions::ToStrings(NetPermissionFlags flags)\n+{\n+    std::vector<std::string> strings;\n+    if (NetPermissions::HasFlag(flags, PF_BLOOMFILTER)) strings.push_back(\"bloomfilter\");\n+    if (NetPermissions::HasFlag(flags, PF_NOBAN)) strings.push_back(\"noban\");\n+    if (NetPermissions::HasFlag(flags, PF_FORCERELAY)) strings.push_back(\"forcerelay\");\n+    if (NetPermissions::HasFlag(flags, PF_RELAY)) strings.push_back(\"relay\");\n+    if (NetPermissions::HasFlag(flags, PF_MEMPOOL)) strings.push_back(\"mempool\");\n+    return strings;\n+}\n+\n+bool NetWhitebindPermissions::TryParse(const std::string str, NetWhitebindPermissions& output, std::string& error)\n+{\n+    NetPermissionFlags flags;\n+    size_t offset;\n+    if (!TryParsePermissionFlags(str, flags, offset, error)) return false;\n+\n+    const std::string strBind = str.substr(offset);\n+    CService addrBind;\n+    if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n+        error = strprintf(_(\"Cannot resolve -%s address: '%s'\").translated, \"whitebind\", strBind);\n+        return false;\n+    }\n+    if (addrBind.GetPort() == 0) {\n+        error = strprintf(_(\"Need to specify a port with -whitebind: '%s'\").translated, strBind);\n+        return false;\n+    }\n+\n+    output.m_flags = flags;\n+    output.m_service = addrBind;\n+    error = \"\";\n+    return true;\n+}\n+\n+bool NetWhitelistPermissions::TryParse(const std::string str, NetWhitelistPermissions& output, std::string& error)\n+{\n+    NetPermissionFlags flags;\n+    size_t offset;\n+    if (!TryParsePermissionFlags(str, flags, offset, error)) return false;\n+\n+    const std::string net = str.substr(offset);\n+    CSubNet subnet;\n+    LookupSubNet(net.c_str(), subnet);\n+    if (!subnet.IsValid()) {\n+        error = strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\").translated, net);\n+        return false;\n+    }\n+\n+    output.m_flags = flags;\n+    output.m_subnet = subnet;\n+    error = \"\";\n+    return true;\n+}"
      },
      {
        "sha": "b3987de65f75c22ea11d29aadd04522a066d8769",
        "filename": "src/net_permissions.h",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net_permissions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/net_permissions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.h?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -0,0 +1,62 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <netaddress.h>\n+\n+#ifndef BITCOIN_NET_PERMISSIONS_H\n+#define BITCOIN_NET_PERMISSIONS_H\n+enum NetPermissionFlags\n+{\n+    PF_NONE = 0,\n+    // Can query bloomfilter even if -peerbloomfilters is false\n+    PF_BLOOMFILTER = (1U << 1),\n+    // Relay and accept transactions from this peer, even if -blocksonly is true\n+    PF_RELAY = (1U << 3),\n+    // Always relay transactions from this peer, even if already in mempool or rejected from policy\n+    // Keep parameter interaction: forcerelay implies relay\n+    PF_FORCERELAY = (1U << 2) | PF_RELAY,\n+    // Can't be banned for misbehavior\n+    PF_NOBAN = (1U << 4),\n+    // Can query the mempool\n+    PF_MEMPOOL = (1U << 5),\n+\n+    // True if the user did not specifically set fine grained permissions\n+    PF_ISIMPLICIT = (1U << 31),\n+    PF_ALL = PF_BLOOMFILTER | PF_FORCERELAY | PF_RELAY | PF_NOBAN | PF_MEMPOOL,\n+};\n+class NetPermissions\n+{\n+public:\n+    NetPermissionFlags m_flags;\n+    static std::vector<std::string> ToStrings(NetPermissionFlags flags);\n+    static inline bool HasFlag(const NetPermissionFlags& flags, NetPermissionFlags f)\n+    {\n+        return (flags & f) == f;\n+    }\n+    static inline void AddFlag(NetPermissionFlags& flags, NetPermissionFlags f)\n+    {\n+        flags = static_cast<NetPermissionFlags>(flags | f);\n+    }\n+    static inline void ClearFlag(NetPermissionFlags& flags, NetPermissionFlags f)\n+    {\n+        flags = static_cast<NetPermissionFlags>(flags & ~f);\n+    }\n+};\n+class NetWhitebindPermissions : public NetPermissions\n+{\n+public:\n+    static bool TryParse(const std::string str, NetWhitebindPermissions& output, std::string& error);\n+    CService m_service;\n+};\n+\n+class NetWhitelistPermissions : public NetPermissions\n+{\n+public:\n+    static bool TryParse(const std::string str, NetWhitelistPermissions& output, std::string& error);\n+    CSubNet m_subnet;\n+};\n+\n+#endif // BITCOIN_NET_PERMISSIONS_H\n\\ No newline at end of file"
      },
      {
        "sha": "196e69066bc3b24962faa8165a339701293110f5",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -9,6 +9,7 @@\n #include <core_io.h>\n #include <net.h>\n #include <net_processing.h>\n+#include <net_permissions.h>\n #include <netbase.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n@@ -178,6 +179,11 @@ static UniValue getpeerinfo(const JSONRPCRequest& request)\n             obj.pushKV(\"inflight\", heights);\n         }\n         obj.pushKV(\"whitelisted\", stats.fWhitelisted);\n+        UniValue permissions(UniValue::VARR);\n+        for (const auto& permission : NetPermissions::ToStrings(stats.m_permissionFlags)) {\n+            permissions.push_back(permission);\n+        }\n+        obj.pushKV(\"permissions\", permissions);\n         obj.pushKV(\"minfeefilter\", ValueFromAmount(stats.minFeeFilter));\n \n         UniValue sendPerMsgCmd(UniValue::VOBJ);"
      },
      {
        "sha": "a3d08316247ea8966e85fbc9db20d7d01ebd900f",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 0,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5b26deaaa6842f7dd7c4537ede000f965ea0189/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <netbase.h>\n+#include <net_permissions.h>\n #include <test/setup_common.h>\n #include <util/strencodings.h>\n \n@@ -321,4 +322,82 @@ BOOST_AUTO_TEST_CASE(netbase_parsenetwork)\n     BOOST_CHECK_EQUAL(ParseNetwork(\"\"), NET_UNROUTABLE);\n }\n \n+BOOST_AUTO_TEST_CASE(netpermissions_test)\n+{\n+    std::string error;\n+    NetWhitebindPermissions whitebindPermissions;\n+    NetWhitelistPermissions whitelistPermissions;\n+\n+    // Detect invalid white bind\n+    BOOST_CHECK(!NetWhitebindPermissions::TryParse(\"\", whitebindPermissions, error));\n+    BOOST_CHECK(error.find(\"Cannot resolve -whitebind address\") != std::string::npos);\n+    BOOST_CHECK(!NetWhitebindPermissions::TryParse(\"127.0.0.1\", whitebindPermissions, error));\n+    BOOST_CHECK(error.find(\"Need to specify a port with -whitebind\") != std::string::npos);\n+    BOOST_CHECK(!NetWhitebindPermissions::TryParse(\"\", whitebindPermissions, error));\n+\n+    // If no permission flags, assume backward compatibility\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK(error.empty());\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_ISIMPLICIT);\n+    BOOST_CHECK(NetPermissions::HasFlag(whitebindPermissions.m_flags, PF_ISIMPLICIT));\n+    NetPermissions::ClearFlag(whitebindPermissions.m_flags, PF_ISIMPLICIT);\n+    BOOST_CHECK(!NetPermissions::HasFlag(whitebindPermissions.m_flags, PF_ISIMPLICIT));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_NONE);\n+    NetPermissions::AddFlag(whitebindPermissions.m_flags, PF_ISIMPLICIT);\n+    BOOST_CHECK(NetPermissions::HasFlag(whitebindPermissions.m_flags, PF_ISIMPLICIT));\n+\n+    // Can set one permission\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_BLOOMFILTER);\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_NONE);\n+\n+    // Happy path, can parse flags\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom,forcerelay@1.2.3.4:32\", whitebindPermissions, error));\n+    // forcerelay should also activate the relay permission\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_BLOOMFILTER | PF_FORCERELAY | PF_RELAY);\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom,relay,noban@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_BLOOMFILTER | PF_RELAY | PF_NOBAN);\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom,forcerelay,noban@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"all@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_ALL);\n+\n+    // Allow dups\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom,relay,noban,noban@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_BLOOMFILTER | PF_RELAY | PF_NOBAN);\n+\n+    // Allow empty\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\"bloom,relay,,noban@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_BLOOMFILTER | PF_RELAY | PF_NOBAN);\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\",@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_NONE);\n+    BOOST_CHECK(NetWhitebindPermissions::TryParse(\",,@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK_EQUAL(whitebindPermissions.m_flags, PF_NONE);\n+\n+    // Detect invalid flag\n+    BOOST_CHECK(!NetWhitebindPermissions::TryParse(\"bloom,forcerelay,oopsie@1.2.3.4:32\", whitebindPermissions, error));\n+    BOOST_CHECK(error.find(\"Invalid P2P permission\") != std::string::npos);\n+\n+    // Check whitelist error\n+    BOOST_CHECK(!NetWhitelistPermissions::TryParse(\"bloom,forcerelay,noban@1.2.3.4:32\", whitelistPermissions, error));\n+    BOOST_CHECK(error.find(\"Invalid netmask specified in -whitelist\") != std::string::npos);\n+\n+    // Happy path for whitelist parsing\n+    BOOST_CHECK(NetWhitelistPermissions::TryParse(\"noban@1.2.3.4\", whitelistPermissions, error));\n+    BOOST_CHECK_EQUAL(whitelistPermissions.m_flags, PF_NOBAN);\n+    BOOST_CHECK(NetWhitelistPermissions::TryParse(\"bloom,forcerelay,noban,relay@1.2.3.4/32\", whitelistPermissions, error));\n+    BOOST_CHECK_EQUAL(whitelistPermissions.m_flags, PF_BLOOMFILTER | PF_FORCERELAY | PF_NOBAN | PF_RELAY);\n+    BOOST_CHECK(error.empty());\n+    BOOST_CHECK_EQUAL(whitelistPermissions.m_subnet.ToString(), \"1.2.3.4/32\");\n+    BOOST_CHECK(NetWhitelistPermissions::TryParse(\"bloom,forcerelay,noban,relay,mempool@1.2.3.4/32\", whitelistPermissions, error));\n+\n+    const auto strings = NetPermissions::ToStrings(PF_ALL);\n+    BOOST_CHECK_EQUAL(strings.size(), 5);\n+    BOOST_CHECK(std::find(strings.begin(), strings.end(), \"bloomfilter\") != strings.end());\n+    BOOST_CHECK(std::find(strings.begin(), strings.end(), \"forcerelay\") != strings.end());\n+    BOOST_CHECK(std::find(strings.begin(), strings.end(), \"relay\") != strings.end());\n+    BOOST_CHECK(std::find(strings.begin(), strings.end(), \"noban\") != strings.end());\n+    BOOST_CHECK(std::find(strings.begin(), strings.end(), \"mempool\") != strings.end());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "ecd5cf7ea4c3644a30092100ffc399e30e193275",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplY2Q1Y2Y3ZWE0YzM2NDRhMzAwOTIxMDBmZmMzOTllMzBlMTkzMjc1",
    "commit": {
      "author": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-06-21T02:31:12Z"
      },
      "committer": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-08-11T02:33:27Z"
      },
      "message": "Do not disconnect peer for asking mempool if it has NO_BAN permission",
      "tree": {
        "sha": "2132837f6235f75b7cb6b5319fe78e0c738fa3d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2132837f6235f75b7cb6b5319fe78e0c738fa3d6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecd5cf7ea4c3644a30092100ffc399e30e193275",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEq0z6mJWsoNvif2s0Zhh2PvCRhv4FAl1PfncACgkQZhh2PvCR\nhv7Stg/+JeGfeK73xl9OejpeZN2HAI/4PNoUCgxOjydroxBThjbPQfrMTGp6mgpZ\nh/peYqtK+LGQT44aGHu8kprdhBY5M8VNb7i5m/cGkv3UEg0vwzb+hQsoA20eYkEP\nm4e5Z7cT3uZGNP8cgCTav8ZP3nC6mYU3E35nXRT0pbqG9pZkx/dNbo7+NGZrta/V\nxXeqXlmMtkE1EYTKyFjAnB6lHKDCT8/niCS+oUVh1wBXgFl8SiYdru39m6o7s7FO\nm2nJ9mCCcVYDJP35Y3AjkZf++OXUFqg8/dZGZm2O6wv5A6Kez/tTLd1/LM7xgQQF\n2YkQYl0wtwcezw62syrHTrmY/dYUsn1dflQRoccpLO5weCbyvJaPOMi/kFxRAM+8\neG2tdHmo+R/FiwbjZtWNa7MI09+GlBhbqntmtfY1zbWs3V+kv1u8fQ1Bf7sX1I7I\n2i4eYwxJJDKXmb1zwXWjTbO7sb8KL/MEyyyL64jp7NFFkP+5HPBBeXkIJX816w04\nb0KzjxV2ckSO1GN92Qkuwu3f/S3cSkj3pHen3g9TeuHr1Nfeq6RYRGgsKD3TY9XE\nb+6H9UtXfAtGD/hauR3CsDLreuSx/dZfsPn4KyuSzflVAft7o7wReqI3sibTglPt\nleNDWMCet6dBtA6ANBnXmBcSRFPXpnKCSo67hT2Tj2PqpYV6mMk=\n=b4IM\n-----END PGP SIGNATURE-----",
        "payload": "tree 2132837f6235f75b7cb6b5319fe78e0c738fa3d6\nparent e5b26deaaa6842f7dd7c4537ede000f965ea0189\nauthor nicolas.dorier <nicolas.dorier@gmail.com> 1561084272 +0900\ncommitter nicolas.dorier <nicolas.dorier@gmail.com> 1565490807 +0900\n\nDo not disconnect peer for asking mempool if it has NO_BAN permission\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecd5cf7ea4c3644a30092100ffc399e30e193275",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ecd5cf7ea4c3644a30092100ffc399e30e193275",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecd5cf7ea4c3644a30092100ffc399e30e193275/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5b26deaaa6842f7dd7c4537ede000f965ea0189",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e5b26deaaa6842f7dd7c4537ede000f965ea0189"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 10,
      "deletions": 4
    },
    "files": [
      {
        "sha": "5edb6ecf9bc2a58960ccbf2c23c366557f8d92ff",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ecd5cf7ea4c3644a30092100ffc399e30e193275/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ecd5cf7ea4c3644a30092100ffc399e30e193275/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ecd5cf7ea4c3644a30092100ffc399e30e193275",
        "patch": "@@ -3012,15 +3012,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     if (strCommand == NetMsgType::MEMPOOL) {\n         if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n-            pfrom->fDisconnect = true;\n+            if (!pfrom->HasPermission(PF_NOBAN))\n+            {\n+                LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n+                pfrom->fDisconnect = true;\n+            }\n             return true;\n         }\n \n         if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n-            pfrom->fDisconnect = true;\n+            if (!pfrom->HasPermission(PF_NOBAN))\n+            {\n+                LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+                pfrom->fDisconnect = true;\n+            }\n             return true;\n         }\n "
      }
    ]
  },
  {
    "sha": "d541fa391844f658bd7035659b5b16695733dd56",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTQxZmEzOTE4NDRmNjU4YmQ3MDM1NjU5YjViMTY2OTU3MzNkZDU2",
    "commit": {
      "author": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-06-21T02:42:04Z"
      },
      "committer": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-08-11T02:33:28Z"
      },
      "message": "Replace the use of fWhitelisted by permission checks",
      "tree": {
        "sha": "655966a9b458e463187e6bd9abad30e5c43bbaba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/655966a9b458e463187e6bd9abad30e5c43bbaba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d541fa391844f658bd7035659b5b16695733dd56",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEq0z6mJWsoNvif2s0Zhh2PvCRhv4FAl1PfngACgkQZhh2PvCR\nhv5Qfw/+JjN10vMdUcvioQNUMYJePoYukIF38kwVjCP7ext6OSsego8VQENqVBuV\njHEobVt9MrobzZGiQf9EeSyu8v5mTI7Rn41O/UrMxlEgJf6GcgjCJUFoTVTxFWzr\nmN6SAblYYUasDxkaWR/9yin8T8GT5K8NVlJNi0PSspNXSXn9yIalqB6PHAeAIcVl\nfEPa124Fwwto5nY7KAuRQbJH656A4jD8Xja7UDPfMU0Yaj4VdHArXZFylU8pYiCt\nfirLeRZOVqHa2F31IJEf489NFHmg1+rDkH7yBxnml7IitWHetmOhSVQmVSI7hNuk\nMwkRgCyU39CfPukiU1jcFqLXNEeetMxj5ho7q9s5O8Ip3xrLgUsOqhlgPNFcFlAw\ngGNTjtJpyNpASs56jLsG+rDf95dcKe+ci8Yjx9UaeYRNgqY0Q1aSvBT1xMq00BXW\nBplHFqHtXwqtztNyFN4w56CYIajvdjZ4B1SSW4Ah2ok17v5lpJ2M5PEutSollVbH\nr7tmlaz+sq+fkMfpOoUJcOG5O1rIMUKhn5qf9sZU3K6jwkPlZfniQoyB9/LpEc4Y\nzhAmit3wL3Tj6ey9t2xAvGdLlm8eoMsoAJrOkY+e0wfIdBZxmlXtw02Ctkjgtc9E\n3I6LRlGmQKedZGqy1gr4Nk6CJczwfm1neNdCquG3R9QP2LYBu9w=\n=FewT\n-----END PGP SIGNATURE-----",
        "payload": "tree 655966a9b458e463187e6bd9abad30e5c43bbaba\nparent ecd5cf7ea4c3644a30092100ffc399e30e193275\nauthor nicolas.dorier <nicolas.dorier@gmail.com> 1561084924 +0900\ncommitter nicolas.dorier <nicolas.dorier@gmail.com> 1565490808 +0900\n\nReplace the use of fWhitelisted by permission checks\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d541fa391844f658bd7035659b5b16695733dd56",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d541fa391844f658bd7035659b5b16695733dd56",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d541fa391844f658bd7035659b5b16695733dd56/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ecd5cf7ea4c3644a30092100ffc399e30e193275",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecd5cf7ea4c3644a30092100ffc399e30e193275",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ecd5cf7ea4c3644a30092100ffc399e30e193275"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 21,
      "deletions": 20
    },
    "files": [
      {
        "sha": "0464a6e9ea7d9a7d7a0cdd2d3ba19a4c930c230a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d541fa391844f658bd7035659b5b16695733dd56/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d541fa391844f658bd7035659b5b16695733dd56/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d541fa391844f658bd7035659b5b16695733dd56",
        "patch": "@@ -526,7 +526,7 @@ void CNode::copyStats(CNodeStats &stats)\n         X(mapRecvBytesPerMsgCmd);\n         X(nRecvBytes);\n     }\n-    X(fWhitelisted);\n+    X(m_legacyWhitelisted);\n     X(m_permissionFlags);\n     {\n         LOCK(cs_feeFilter);\n@@ -812,7 +812,7 @@ bool CConnman::AttemptToEvictConnection()\n         LOCK(cs_vNodes);\n \n         for (const CNode* node : vNodes) {\n-            if (node->fWhitelisted)\n+            if (node->HasPermission(PF_NOBAN))\n                 continue;\n             if (!node->fInbound)\n                 continue;\n@@ -982,7 +982,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     pnode->AddRef();\n     pnode->m_permissionFlags = permissionFlags;\n     // If this flag is present, the user probably expect that RPC and QT report it as whitelisted (backward compatibility)\n-    pnode->fWhitelisted = legacyWhitelisted;\n+    pnode->m_legacyWhitelisted = legacyWhitelisted;\n     pnode->m_prefer_evict = bannedlevel > 0;\n     m_msgproc->InitializeNode(pnode);\n "
      },
      {
        "sha": "75c05c9cb5ddf3835c82bf9be8f1c312df0cf767",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d541fa391844f658bd7035659b5b16695733dd56/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d541fa391844f658bd7035659b5b16695733dd56/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d541fa391844f658bd7035659b5b16695733dd56",
        "patch": "@@ -559,7 +559,7 @@ class CNodeStats\n     uint64_t nRecvBytes;\n     mapMsgCmdSize mapRecvBytesPerMsgCmd;\n     NetPermissionFlags m_permissionFlags;\n-    bool fWhitelisted;\n+    bool m_legacyWhitelisted;\n     double dPingTime;\n     double dPingWait;\n     double dMinPing;\n@@ -664,7 +664,8 @@ class CNode\n     bool HasPermission(NetPermissionFlags permission) const {\n         return NetPermissions::HasFlag(m_permissionFlags, permission);\n     }\n-    bool fWhitelisted{false}; // This peer can bypass DoS banning.\n+    // This boolean is unusued in actual processing, only present for backward compatibility at RPC/QT level\n+    bool m_legacyWhitelisted{false};\n     bool fFeeler{false}; // If true this node is being used as a short lived feeler.\n     bool fOneShot{false};\n     bool m_manual_connection{false};"
      },
      {
        "sha": "3db460d44458587c3820b16ecff3585b244be004",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d541fa391844f658bd7035659b5b16695733dd56/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d541fa391844f658bd7035659b5b16695733dd56/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d541fa391844f658bd7035659b5b16695733dd56",
        "patch": "@@ -408,7 +408,7 @@ static void UpdatePreferredDownload(CNode* node, CNodeState* state) EXCLUSIVE_LO\n     nPreferredDownload -= state->fPreferredDownload;\n \n     // Whether this node should be marked as a preferred download node.\n-    state->fPreferredDownload = (!node->fInbound || node->fWhitelisted) && !node->fOneShot && !node->fClient;\n+    state->fPreferredDownload = (!node->fInbound || node->HasPermission(PF_NOBAN)) && !node->fOneShot && !node->fClient;\n \n     nPreferredDownload += state->fPreferredDownload;\n }\n@@ -1398,7 +1398,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     // never disconnect whitelisted nodes\n-    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->HasPermission(PF_NOBAN))\n     {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1407,7 +1407,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n         send = false;\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n-    if (send && !pfrom->fWhitelisted && (\n+    if (send && !pfrom->HasPermission(PF_NOBAN) && (\n             (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n@@ -2217,7 +2217,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool fBlocksOnly = !g_relay_txes;\n \n         // Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true\n-        if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY))\n+        if (pfrom->HasPermission(PF_RELAY))\n             fBlocksOnly = false;\n \n         LOCK(cs_main);\n@@ -2412,7 +2412,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         LOCK(cs_main);\n-        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n+        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom->HasPermission(PF_NOBAN)) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n@@ -2470,7 +2470,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     if (strCommand == NetMsgType::TX) {\n         // Stop processing the transaction early if\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n-        if (!g_relay_txes && (!pfrom->fWhitelisted || !gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n+        if (!g_relay_txes && !pfrom->HasPermission(PF_RELAY))\n         {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n             return true;\n@@ -2565,7 +2565,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 AddToCompactExtraTransactions(ptx);\n             }\n \n-            if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n+            if (pfrom->HasPermission(PF_FORCERELAY)) {\n                 // Always relay transactions received from whitelisted peers, even\n                 // if they were already in the mempool or rejected from it due\n                 // to policy, allowing the node to function as a gateway for\n@@ -3010,7 +3010,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n     if (strCommand == NetMsgType::MEMPOOL) {\n-        if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n+        if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->HasPermission(PF_MEMPOOL))\n         {\n             if (!pfrom->HasPermission(PF_NOBAN))\n             {\n@@ -3020,7 +3020,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)\n+        if (connman->OutboundTargetReached(false) && !pfrom->HasPermission(PF_MEMPOOL))\n         {\n             if (!pfrom->HasPermission(PF_NOBAN))\n             {\n@@ -3222,7 +3222,7 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n \n     if (state.fShouldBan) {\n         state.fShouldBan = false;\n-        if (pnode->fWhitelisted)\n+        if (pnode->HasPermission(PF_NOBAN))\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n         else if (pnode->m_manual_connection)\n             LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode->addr.ToString());\n@@ -3792,7 +3792,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             pto->vInventoryBlockToSend.clear();\n \n             // Check whether periodic sends should happen\n-            bool fSendTrickle = pto->fWhitelisted;\n+            bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n             if (pto->nNextInvSend < nNow) {\n                 fSendTrickle = true;\n                 if (pto->fInbound) {\n@@ -3948,7 +3948,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     // Note: If all our peers are inbound, then we won't\n                     // disconnect our sync peer for stalling; we have bigger\n                     // problems if we can't get any outbound peers.\n-                    if (!pto->fWhitelisted) {\n+                    if (!pto->HasPermission(PF_NOBAN)) {\n                         LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n                         pto->fDisconnect = true;\n                         return true;\n@@ -4066,7 +4066,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n         if (pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n-            !(pto->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))) {\n+            !pto->HasPermission(PF_FORCERELAY)) {\n             CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();\n             if (timeNow > pto->nextSendTimeFeeFilter) {"
      },
      {
        "sha": "19b11ba1cdafdbc89172e92b82175d8dcf7582fe",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d541fa391844f658bd7035659b5b16695733dd56/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d541fa391844f658bd7035659b5b16695733dd56/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=d541fa391844f658bd7035659b5b16695733dd56",
        "patch": "@@ -1120,7 +1120,7 @@ void RPCConsole::updateNodeDetail(const CNodeCombinedStats *stats)\n     ui->peerSubversion->setText(QString::fromStdString(stats->nodeStats.cleanSubVer));\n     ui->peerDirection->setText(stats->nodeStats.fInbound ? tr(\"Inbound\") : tr(\"Outbound\"));\n     ui->peerHeight->setText(QString(\"%1\").arg(QString::number(stats->nodeStats.nStartingHeight)));\n-    ui->peerWhitelisted->setText(stats->nodeStats.fWhitelisted ? tr(\"Yes\") : tr(\"No\"));\n+    ui->peerWhitelisted->setText(stats->nodeStats.m_legacyWhitelisted ? tr(\"Yes\") : tr(\"No\"));\n \n     // This check fails for example if the lock was busy and\n     // nodeStateStats couldn't be fetched."
      },
      {
        "sha": "25dda924a4c2af7228b184e2da038f5dfb439799",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d541fa391844f658bd7035659b5b16695733dd56/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d541fa391844f658bd7035659b5b16695733dd56/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=d541fa391844f658bd7035659b5b16695733dd56",
        "patch": "@@ -178,7 +178,7 @@ static UniValue getpeerinfo(const JSONRPCRequest& request)\n             }\n             obj.pushKV(\"inflight\", heights);\n         }\n-        obj.pushKV(\"whitelisted\", stats.fWhitelisted);\n+        obj.pushKV(\"whitelisted\", stats.m_legacyWhitelisted);\n         UniValue permissions(UniValue::VARR);\n         for (const auto& permission : NetPermissions::ToStrings(stats.m_permissionFlags)) {\n             permissions.push_back(permission);"
      }
    ]
  },
  {
    "sha": "c5b404e8f1973afe071a07c63ba1038eefe13f0f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNWI0MDRlOGYxOTczYWZlMDcxYTA3YzYzYmExMDM4ZWVmZTEzZjBm",
    "commit": {
      "author": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-06-21T04:15:26Z"
      },
      "committer": {
        "name": "nicolas.dorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2019-08-11T02:33:29Z"
      },
      "message": "Add functional tests for flexible whitebind/list",
      "tree": {
        "sha": "6888d611e5d66527bef59a7486ab6e3b16877132",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6888d611e5d66527bef59a7486ab6e3b16877132"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5b404e8f1973afe071a07c63ba1038eefe13f0f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEq0z6mJWsoNvif2s0Zhh2PvCRhv4FAl1PfnkACgkQZhh2PvCR\nhv6KjQ//T2RDiWnDKwPTXQNq7hglBL/2DQ4lqWUOKr8TOswa0a5Zd4tsUF+Fjqez\nUa8a/Pa8ltHR6Wt/6Zm/fwKP2KTshXB5HjASe9bIM2QYx55Grk4yMscL5yOpCJPV\nU92VYtWIXksPiWRKODkeQ4y6KJ1MKLhmbLN2FxPY+R1tSE7BggIqxpPAIxyg4E86\nj5MtfBSzD+Xvc6XFNNksOOu2xz1PSo6sAL7NTYNKuLZQoSblKzZay34E56BtzMc1\nbzgkRYVh/XxvjczmFDnWmRNQAXw0BX8aZ2rezlb2+FXe+jeTElYaKqDkrfpRr7Lf\nM+VmyciOYhZUY6b3bhuT0M1wTNIXKNBK5FvijT37/gzJ5AAZTApzL56HBmZSBjhK\n/DHQV1K5mU1qya3wn7lbQm3HFZJIGJEKifeb5b9vWziWaepdo9uEeDJ+s0VXXdOA\ntlV/jKIhRT51UGl4tBp9BR020d9sPZksoF/z1fF8RziXqaqHgCOJUXhLr2GJj+No\n4xBCogCOnB/Ry2o+9xt7piJZmqc0Fmu+qXM/3XVMNDVt4uMRMytvKFr7QDuuQdQs\nNDmrO7BOQT5K6RfpzEYEH9TbRJSMlvyCDdpq8V1oR6p5BsxwiOV0zK6jnvZRd5ZO\nWETDRyP881CmDrMgiBp1eC2c0u8DrTYmsqjc+e/Bkg4jlWKRi7Y=\n=crDF\n-----END PGP SIGNATURE-----",
        "payload": "tree 6888d611e5d66527bef59a7486ab6e3b16877132\nparent d541fa391844f658bd7035659b5b16695733dd56\nauthor nicolas.dorier <nicolas.dorier@gmail.com> 1561090526 +0900\ncommitter nicolas.dorier <nicolas.dorier@gmail.com> 1565490809 +0900\n\nAdd functional tests for flexible whitebind/list\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5b404e8f1973afe071a07c63ba1038eefe13f0f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c5b404e8f1973afe071a07c63ba1038eefe13f0f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5b404e8f1973afe071a07c63ba1038eefe13f0f/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d541fa391844f658bd7035659b5b16695733dd56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d541fa391844f658bd7035659b5b16695733dd56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d541fa391844f658bd7035659b5b16695733dd56"
      }
    ],
    "stats": {
      "total": 99,
      "additions": 99,
      "deletions": 0
    },
    "files": [
      {
        "sha": "101305542045444e7aeb48a9327e1b5a41acbfcb",
        "filename": "test/functional/p2p_permissions.py",
        "status": "added",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=c5b404e8f1973afe071a07c63ba1038eefe13f0f",
        "patch": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test p2p permission message.\n+\n+Test that permissions are correctly calculated and applied\n+\"\"\"\n+\n+from test_framework.test_node import ErrorMatch\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    p2p_port,\n+)\n+\n+class P2PPermissionsTests(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        self.extra_args = [[],[]]\n+\n+    def run_test(self):\n+        self.checkpermission(\n+        # relay permission added\n+        [\"-whitelist=127.0.0.1\", \"-whitelistrelay\"],\n+        [\"relay\", \"noban\", \"mempool\"],\n+        True)\n+\n+        self.checkpermission(\n+        # forcerelay and relay permission added\n+        # Legacy parameter interaction which set whitelistrelay to true\n+        # if whitelistforcerelay is true\n+        [\"-whitelist=127.0.0.1\", \"-whitelistforcerelay\"],\n+        [\"forcerelay\", \"relay\", \"noban\", \"mempool\"],\n+        True)\n+\n+        # Let's make sure permissions are merged correctly\n+        # For this, we need to use whitebind instead of bind\n+        # by modifying the configuration file.\n+        ip_port = \"127.0.0.1:{}\".format(p2p_port(1))\n+        self.replaceinconfig(1, \"bind=127.0.0.1\", \"whitebind=bloomfilter,forcerelay@\" + ip_port)\n+        self.checkpermission(\n+        [\"-whitelist=noban@127.0.0.1\" ],\n+        # Check parameter interaction forcerelay should activate relay\n+        [\"noban\", \"bloomfilter\", \"forcerelay\", \"relay\" ],\n+        False)\n+        self.replaceinconfig(1, \"whitebind=bloomfilter,forcerelay@\" + ip_port, \"bind=127.0.0.1\")\n+\n+        self.checkpermission(\n+        # legacy whitelistrelay should be ignored\n+        [\"-whitelist=noban,mempool@127.0.0.1\", \"-whitelistrelay\"],\n+        [\"noban\", \"mempool\"],\n+        False)\n+\n+        self.checkpermission(\n+        # legacy whitelistforcerelay should be ignored\n+        [\"-whitelist=noban,mempool@127.0.0.1\", \"-whitelistforcerelay\"],\n+        [\"noban\", \"mempool\"],\n+        False)\n+\n+        self.checkpermission(\n+        # missing mempool permission to be considered legacy whitelisted\n+        [\"-whitelist=noban@127.0.0.1\"],\n+        [\"noban\"],\n+        False)\n+\n+        self.checkpermission(\n+        # all permission added\n+        [\"-whitelist=all@127.0.0.1\"],\n+        [\"forcerelay\", \"noban\", \"mempool\", \"bloomfilter\", \"relay\"],\n+        False)\n+\n+        self.stop_node(1)\n+        self.nodes[1].assert_start_raises_init_error([\"-whitelist=oopsie@127.0.0.1\"], \"Invalid P2P permission\", match=ErrorMatch.PARTIAL_REGEX)\n+        self.nodes[1].assert_start_raises_init_error([\"-whitelist=noban@127.0.0.1:230\"], \"Invalid netmask specified in\", match=ErrorMatch.PARTIAL_REGEX)\n+        self.nodes[1].assert_start_raises_init_error([\"-whitebind=noban@127.0.0.1/10\"], \"Cannot resolve -whitebind address\", match=ErrorMatch.PARTIAL_REGEX)\n+\n+    def checkpermission(self, args, expectedPermissions, whitelisted):\n+        self.restart_node(1, args)\n+        connect_nodes(self.nodes[0], 1)\n+        peerinfo = self.nodes[1].getpeerinfo()[0]\n+        assert_equal(peerinfo['whitelisted'], whitelisted)\n+        assert_equal(len(expectedPermissions), len(peerinfo['permissions']))\n+        for p in expectedPermissions:\n+            if not p in peerinfo['permissions']:\n+                raise AssertionError(\"Expected permissions %r is not granted.\" % p)\n+\n+    def replaceinconfig(self, nodeid, old, new):\n+        with open(self.nodes[nodeid].bitcoinconf, encoding=\"utf8\") as f:\n+            newText=f.read().replace(old, new)\n+        with open(self.nodes[nodeid].bitcoinconf, 'w', encoding=\"utf8\") as f:\n+            f.write(newText)\n+\n+if __name__ == '__main__':\n+    P2PPermissionsTests().main()"
      },
      {
        "sha": "df027397d2738d9ca18179ec4eed98baa8ab4269",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=c5b404e8f1973afe071a07c63ba1038eefe13f0f",
        "patch": "@@ -68,6 +68,7 @@ def __init__(self, i, datadir, *, chain, rpchost, timewait, bitcoind, bitcoin_cl\n \n         self.index = i\n         self.datadir = datadir\n+        self.bitcoinconf = os.path.join(self.datadir, \"bitcoin.conf\")\n         self.stdout_dir = os.path.join(self.datadir, \"stdout\")\n         self.stderr_dir = os.path.join(self.datadir, \"stderr\")\n         self.chain = chain"
      },
      {
        "sha": "1742a8e3195af0f1d3f1b813326424601780e318",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b404e8f1973afe071a07c63ba1038eefe13f0f/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=c5b404e8f1973afe071a07c63ba1038eefe13f0f",
        "patch": "@@ -200,6 +200,7 @@\n     'rpc_scantxoutset.py',\n     'feature_logging.py',\n     'p2p_node_network_limited.py',\n+    'p2p_permissions.py',\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n     'rpc_help.py',"
      }
    ]
  }
]