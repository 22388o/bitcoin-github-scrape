jnewbery,2020-05-12 15:06:17,This takes a different approach from the caching in #16442. I prefer it because it isolates all of the caching logic inside the indexer rather than in net processing. I'll put the other approach up as a different branch for comparison.,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-627403715,627403715,
DrahtBot,2020-05-13 07:52:38,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #18354 (Protect wallet by using shared pointers by bvbfan)\n\nIf you consider this pull request important, please also hel",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-627814619,627814619,
theStack,2020-05-13 12:10:16,"I'm almost ready for ACKing this PR, just have some minor suggestion/discussion points:\n- Would it make sense to also only check the cache if we have checkpoints, i.e. a method structure like\n```\nbool is_checkpoint = (block_index->nHeight % CFCHECKPT_INTERVAL == 0); \nif (is_checkpoint)\n    // Check the headers cache\n\n// Regular lookup\n\nif (is_checkpoint)\n    // Add to the heade",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-627939760,627939760,
jonasschnelli,2020-05-13 18:25:49,Concept ACK,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628166454,628166454,
jnewbery,2020-05-13 22:48:06,"@theStack \n> Would it make sense to also only check the cache if we have checkpoints, i.e. a method structure like\n\nDone\n\n@MarcoFalke \n> a non-recursive mutex should be sufficient.\n\nChanged `RecursiveMutex` -> `Mutex`\n\nI'm still working on adding a microbench, although it's not clear to me that it'll show any improvement since the disk reads may be cached by the OS for the micr",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628285474,628285474,
theStack,2020-05-14 16:56:36,Using jnewbery's nice [node-shell module](https://github.com/jnewbery/bitcoin/tree/node-shell) (a modification of test-shell that allows to connect with the functional test framework to a running full-node) I crafted up a quick and dirty [test-script](https://github.com/theStack/bitcoin/blob/pr18960_test/test/functional/p2p_18960.py) (see branch https://github.com/theStack/bitcoin/tree/pr18960_tes,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628761578,628761578,
michaelfolkson,2020-05-14 18:36:34,Approach ACK,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628815890,628815890,
MarcoFalke,2020-05-14 22:26:37,@theStack I believe in between the requests you can drop the cache to simulate eviction (which may occasionally happen during normal operation). See https://unix.stackexchange.com/questions/17936/setting-proc-sys-vm-drop-caches-to-clear-cache,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628918187,628918187,
jnewbery,2020-05-15 01:36:30,"@narula suggested in today's PR Review Club meeting that it'd be less cognitive overhead to simply take the `m_cs_headers_cache` for the entirety of the `LookupFilterHeader()` function, rather than taking, releasing and taking it again. That seem like a reasonable request to me. We can't ever block important work with this lock, so holding it a bit longer than strictly necessary is not an issue.",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628974368,628974368,
jnewbery,2020-05-15 01:56:31,"@theStack - thank you for doing some benching of this. Your approach inspired me to do something similar myself, using debug logs to find the exact time to construct a cfcheckpt response. I've added a [`debug_log_delta` context wrapper](https://github.com/jnewbery/bitcoin/commit/99ea8d5b228c3c5ddec5de76bbf830c666738485#diff-86294e5ae5283eebdd9f98d79007a0e1R386) to the node_shell, which allows me t",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628980196,628980196,
jnewbery,2020-05-15 02:08:18,"> @narula suggested in today's PR Review Club meeting that it'd be less cognitive overhead to simply take the m_cs_headers_cache for the entirety of the LookupFilterHeader() function, rather than taking, releasing and taking it again.\n\nI'll make this change tomorrow.",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628983530,628983530,
theStack,2020-05-15 10:37:19,"In yesterday's [review club meeting on this PR](https://bitcoincore.reviews/18960.html), it was suggested to put LogPrintf() directly into the network processing code parts to measure the execution time of getcfcheckpt requests. (My previous approach of [measuring the request response time from the test framework](https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-628761578) was not precis",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629163428,629163428,
jnewbery,2020-05-15 16:17:49,"> it'd be less cognitive overhead to simply take the m_cs_headers_cache for the entirety of the LookupFilterHeader() function\n\n@narula \n\nDone.",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629351023,629351023,
narula,2020-05-15 16:40:38,utACK,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629361597,629361597,
jnewbery,2020-05-15 16:41:15,"I've force-pushed a branch that changes this to use an unordered_map and only lock once.\n\nComparing the unordered map implementation to map:\n\n#### unordered_map\n\n<details><summary>Log</summary>\n\n```\ngetcfcheckpt request received to cfcheckpt response constructed: 12.808ms\ngetcfcheckpt request received to cfcheckpt response constructed: 2.783ms\ngetcfcheckpt request received to",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629361873,629361873,
jnewbery,2020-05-15 16:48:25,Feedback from @narula and @jkczyz addressed. Thanks!,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629365265,629365265,
jkczyz,2020-05-15 17:55:23,"ACK b6eba9e492e1dfb38baec894bfda1cfb4d709e5d\n\nRan all tests.",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629397391,629397391,
fjahr,2020-05-15 19:30:33,utACK b6eba9e492e1dfb38baec894bfda1cfb4d709e5d,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629439397,629439397,
jnewbery,2020-05-18 16:55:26,"Thanks for the rereview @jkczyz and @theStack , and for catching the problems with checking checkpoint heights. Should be fixed now.",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-630310732,630310732,
jkczyz,2020-05-18 17:22:26,ACK 0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-630325155,630325155,
theStack,2020-05-19 09:33:31,"ACK 0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf :tada: \n\nBy the way, I'm neutral to the question on whether to use `std::map` or `std::unordered_map` for the cache -- `std::unordered_map` does indeed seem to lead to some performance improvement (my tests show a rough 10% improvement, see numbers below; [jnewberys tests](https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-629361873) show an",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-630706114,630706114,
fjahr,2020-05-19 14:08:37,"re-utACK 0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf\n\nCompared to my last review `is_checkpoint` variable is introduced for better readability and if statement that was removed in error is added back: https://github.com/bitcoin/bitcoin/compare/b6eba9e492e1dfb38baec894bfda1cfb4d709e5d..0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-630843553,630843553,
laanwj,2020-05-21 17:34:20,code review ACK 0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf,https://github.com/bitcoin/bitcoin/pull/18960#issuecomment-632242849,632242849,
theStack,2020-05-12 15:18:56,"Is there any particular reason for limiting the size of the cache? With this numbers it would be full at block 2000000, i.e. in (2000000-630000)/(6 * 24 * 365) ~ 26 years.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r423819184,423819184,src/index/blockfilterindex.cpp
jnewbery,2020-05-12 20:08:44,"I wanted to have some limit so that a bug doesn't turn into a memory exhaustion possibility (since we only ever add to this map, and never remove). I don't think the exact number matters. Presumably in 26 years, anyone who wants to serve compact block filters from a v0.21 Bitcoin Core server will be able to patch their own code.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424002630,424002630,src/index/blockfilterindex.cpp
theStack,2020-05-13 11:26:57,"I agree that when in doubt, it's better to be overcautious than risking introducing a memory exhaustion bug -- I just wanted to get sure there are no other reasons for the limit that I'm not aware of.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424364005,424364005,src/index/blockfilterindex.cpp
MarcoFalke,2020-05-13 12:43:33,"```suggestion\n    Mutex m_cs_headers_cache;\n```\n\nnit (feel free to ignore). I haven't tested this, but from reading the code, a non-recursive mutex should be sufficient.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424406311,424406311,src/index/blockfilterindex.h
fjahr,2020-05-13 14:59:39,"This is a very minor issue but if we use the hash instead of the height as the key we could end up with headers of orphaned blocks in the cache since they will not be overridden or removed. This could also be the case if `CFCHECKPT_INTERVAL` would ever change. I know the chances for that happening are slim and if it happens we can deal with it then, just wanted to put it there.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424507108,424507108,src/index/blockfilterindex.cpp
clarkmoody,2020-05-13 18:14:51,"The test suite explicitly checks that filters for stale blocks may still be fetched.\n\nhttps://github.com/jnewbery/bitcoin/blob/2020-05-cfcheckpts-cache/test/functional/p2p_blockfilters.py#L89-L101",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424637193,424637193,src/index/blockfilterindex.cpp
jonasschnelli,2020-05-13 18:24:51,doesn't this statically cap (and freeze forever) the cache after inserting 2000 entries? Wouldn't it make sense to have some sort of invalidation logic? (I can't come up with a good one though),https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424643299,424643299,src/index/blockfilterindex.cpp
MarcoFalke,2020-05-13 18:32:45,"If someone can mine enough blocks to fill up this cache, we have other problems. I think an adversary needs to mine blocks in the order of the 2000th triangle number to fill this up.\n\nAnd when this cache is full due to natural reasons (in 20 years), disks will be fast enough that we won't need a cache.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424648190,424648190,src/index/blockfilterindex.cpp
MarcoFalke,2020-05-13 18:33:41,"Maybe disks are fast enough or smart enough with caching today already, so it might not be needed after all. A benchmark would be nice...",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424648698,424648698,src/index/blockfilterindex.cpp
jonasschnelli,2020-05-13 18:38:10,"Oh. You'r right. \nI missed the `% CFCHECKPT_INTERVAL == 0`.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424651189,424651189,src/index/blockfilterindex.cpp
jnewbery,2020-05-13 19:29:50,"> we could end up with headers of orphaned blocks in the cache\n\nCorrect. If there's a re-org across checkpoint block, then the disconnect block's filter header stays in the cache. That's an explicit design decision, since:\n- the cost is very small (32 bytes for header + map overhead so < 100 bytes)\n- it's an infrequent event\n- it saves on the complexity of having to recalculate the cache",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424680456,424680456,src/index/blockfilterindex.cpp
jnewbery,2020-05-13 19:30:23,Agree. I'll change to `Mutex`.,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424680741,424680741,src/index/blockfilterindex.h
jnewbery,2020-05-13 19:31:36,"Remind me to change this to 4000 in 2026 :)\n\nI agree that a benchmark would be nice.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424681368,424681368,src/index/blockfilterindex.cpp
MarcoFalke,2020-05-13 19:33:17,"```cpp\n// TODO change to 4000 in 2026\n```\n\n;)",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424682225,424682225,src/index/blockfilterindex.cpp
jnewbery,2020-05-13 19:38:25,"oops sorry, I meant 2046",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424685028,424685028,src/index/blockfilterindex.cpp
jnewbery,2020-05-13 22:44:08,Done,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424772712,424772712,src/index/blockfilterindex.h
jkczyz,2020-05-14 06:00:57,"Any reason `std::unordered_map` can't be used? I see that the tree-based `std::map` and `std::set` are used primarily throughout the codebase, but figured it may just be historical. Is there another reason these are preferred?",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r424888402,424888402,src/index/blockfilterindex.h
jnewbery,2020-05-15 02:07:31,"I expect mostly laziness. With an `unordered_map`, you need to provide a hash function. In this case, it's easy. The data is all hash digests from block chain data, so I can just take the first 8 bytes from the uint256 filter header.\n\nI'll make that change tomorrow.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425526443,425526443,src/index/blockfilterindex.h
MarcoFalke,2020-05-15 10:23:09,Just as a reminder: There is no free lunch and unordered_map comes with a size penalty,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425708660,425708660,src/index/blockfilterindex.h
jnewbery,2020-05-15 16:17:09,I've reimplemented this as an unordered_map,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425907876,425907876,src/index/blockfilterindex.h
narula,2020-05-15 16:24:18,Nit: give justification in comments for magic numbers so future readers have some idea how this was chosen and if/when it will need to be adjusted.,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425911921,425911921,src/index/blockfilterindex.cpp
jkczyz,2020-05-15 16:34:43,"You'll still want to condition this on `block_index->nHeight % CFCHECKPT_INTERVAL == 0`, otherwise the most recent 2000 requested headers will be cached rather than the desired ones.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425918218,425918218,src/index/blockfilterindex.cpp
jnewbery,2020-05-15 16:35:39,yikes. Thanks,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425918731,425918731,src/index/blockfilterindex.cpp
jnewbery,2020-05-15 16:48:01,done,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425925522,425925522,src/index/blockfilterindex.cpp
jnewbery,2020-05-15 16:48:05,done,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r425925547,425925547,src/index/blockfilterindex.cpp
theStack,2020-05-17 10:49:38,"Before the last change, the cache lookup only happened for checkpoint blocks (i.e. block number modulo 1000 is zero). Is this removal of the condition intended?",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r426246248,426246248,src/index/blockfilterindex.cpp
jnewbery,2020-05-18 16:54:54,No. Not intentional. I just messed up splitting out the `LOCK(m_cs_headers_cache)`. Thanks for catching this.,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r426766679,426766679,src/index/blockfilterindex.cpp
ariard,2020-05-21 01:25:22,"If you have to change PR again, you may comment that key value is block hash and mapped value filter-header, type being the same it may be confusing at first look.",https://github.com/bitcoin/bitcoin/pull/18960#discussion_r428395728,428395728,src/index/blockfilterindex.h
jnewbery,2020-05-21 15:06:27,Good point. I'll add a comment if I need to retouch the branch.,https://github.com/bitcoin/bitcoin/pull/18960#discussion_r428714115,428714115,src/index/blockfilterindex.h
