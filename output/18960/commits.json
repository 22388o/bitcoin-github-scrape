[
  {
    "sha": "0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTg3ZDRjMTE4YWI0YzBmNWMyZDRmYjE4MGMyYThkZWE4YWM1M2Nm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-05-11T02:28:21Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-05-18T16:54:07Z"
      },
      "message": "[indexes] Add compact block filter headers cache\n\nCache block filter headers at heights of multiples of 1000 in memory.\n\nBlock filter headers at height 1000x are checkpointed, and will be the\nmost frequently requested. Cache them in memory to avoid costly disk\nreads.",
      "tree": {
        "sha": "606fe9d9496a2270afefe0f7ac7ffe6513f07614",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/606fe9d9496a2270afefe0f7ac7ffe6513f07614"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8da1e43b63cb36759eeb1fcfd6768163265c44e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8da1e43b63cb36759eeb1fcfd6768163265c44e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8da1e43b63cb36759eeb1fcfd6768163265c44e2"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 40,
      "deletions": 6
    },
    "files": [
      {
        "sha": "7dba115593b81e58280e5deca74e1dbea01ee1e0",
        "filename": "src/index/blockfilterindex.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 1,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/index/blockfilterindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/index/blockfilterindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/blockfilterindex.cpp?ref=0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
        "patch": "@@ -31,6 +31,12 @@ constexpr char DB_FILTER_POS = 'P';\n constexpr unsigned int MAX_FLTR_FILE_SIZE = 0x1000000; // 16 MiB\n /** The pre-allocation chunk size for fltr?????.dat files */\n constexpr unsigned int FLTR_FILE_CHUNK_SIZE = 0x100000; // 1 MiB\n+/** Maximum size of the cfheaders cache\n+ *  We have a limit to prevent a bug in filling this cache\n+ *  potentially turning into an OOM. At 2000 entries, this cache\n+ *  is big enough for a 2,000,000 length block chain, which\n+ *  we should be enough until ~2047. */\n+constexpr size_t CF_HEADERS_CACHE_MAX_SZ{2000};\n \n namespace {\n \n@@ -387,13 +393,32 @@ bool BlockFilterIndex::LookupFilter(const CBlockIndex* block_index, BlockFilter&\n     return ReadFilterFromDisk(entry.pos, filter_out);\n }\n \n-bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out) const\n+bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out)\n {\n+    LOCK(m_cs_headers_cache);\n+\n+    bool is_checkpoint{block_index->nHeight % CFCHECKPT_INTERVAL == 0};\n+\n+    if (is_checkpoint) {\n+        // Try to find the block in the headers cache if this is a checkpoint height.\n+        auto header = m_headers_cache.find(block_index->GetBlockHash());\n+        if (header != m_headers_cache.end()) {\n+            header_out = header->second;\n+            return true;\n+        }\n+    }\n+\n     DBVal entry;\n     if (!LookupOne(*m_db, block_index, entry)) {\n         return false;\n     }\n \n+    if (is_checkpoint &&\n+        m_headers_cache.size() < CF_HEADERS_CACHE_MAX_SZ) {\n+        // Add to the headers cache if this is a checkpoint height.\n+        m_headers_cache.emplace(block_index->GetBlockHash(), entry.header);\n+    }\n+\n     header_out = entry.header;\n     return true;\n }"
      },
      {
        "sha": "7ca43540c7fb80b7b973504e35affd530e5b7595",
        "filename": "src/index/blockfilterindex.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/index/blockfilterindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/index/blockfilterindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/blockfilterindex.h?ref=0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
        "patch": "@@ -10,6 +10,14 @@\n #include <flatfile.h>\n #include <index/base.h>\n \n+/** Interval between compact filter checkpoints. See BIP 157. */\n+static constexpr int CFCHECKPT_INTERVAL = 1000;\n+\n+struct FilterHeaderHasher\n+{\n+    size_t operator()(const uint256& hash) const { return ReadLE64(hash.begin()); }\n+};\n+\n /**\n  * BlockFilterIndex is used to store and retrieve block filters, hashes, and headers for a range of\n  * blocks by height. An index is constructed for each supported filter type with its own database\n@@ -30,6 +38,9 @@ class BlockFilterIndex final : public BaseIndex\n     bool ReadFilterFromDisk(const FlatFilePos& pos, BlockFilter& filter) const;\n     size_t WriteFilterToDisk(FlatFilePos& pos, const BlockFilter& filter);\n \n+    Mutex m_cs_headers_cache;\n+    std::unordered_map<uint256, uint256, FilterHeaderHasher> m_headers_cache GUARDED_BY(m_cs_headers_cache);\n+\n protected:\n     bool Init() override;\n \n@@ -54,7 +65,7 @@ class BlockFilterIndex final : public BaseIndex\n     bool LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const;\n \n     /** Get a single filter header by block. */\n-    bool LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out) const;\n+    bool LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out);\n \n     /** Get a range of filters between two heights on a chain. */\n     bool LookupFilterRange(int start_height, const CBlockIndex* stop_index,"
      },
      {
        "sha": "61a254db7dc6acb2745b5694376b8b23907be695",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0187d4c118ab4c0f5c2d4fb180c2a8dea8ac53cf",
        "patch": "@@ -129,8 +129,6 @@ static constexpr unsigned int INVENTORY_BROADCAST_MAX = 7 * INVENTORY_BROADCAST_\n static constexpr unsigned int AVG_FEEFILTER_BROADCAST_INTERVAL = 10 * 60;\n /** Maximum feefilter broadcast delay after significant change. */\n static constexpr unsigned int MAX_FEEFILTER_CHANGE_DELAY = 5 * 60;\n-/** Interval between compact filter checkpoints. See BIP 157. */\n-static constexpr int CFCHECKPT_INTERVAL = 1000;\n \n struct COrphanTx {\n     // When modifying, adapt the copy of this definition in tests/DoS_tests.\n@@ -1990,7 +1988,7 @@ static bool PrepareBlockFilterRequest(CNode* pfrom, const CChainParams& chain_pa\n                                       BlockFilterType filter_type,\n                                       const uint256& stop_hash,\n                                       const CBlockIndex*& stop_index,\n-                                      const BlockFilterIndex*& filter_index)\n+                                      BlockFilterIndex*& filter_index)\n {\n     const bool supported_filter_type =\n         (filter_type == BlockFilterType::BASIC &&\n@@ -2045,7 +2043,7 @@ static void ProcessGetCFCheckPt(CNode* pfrom, CDataStream& vRecv, const CChainPa\n     const BlockFilterType filter_type = static_cast<BlockFilterType>(filter_type_ser);\n \n     const CBlockIndex* stop_index;\n-    const BlockFilterIndex* filter_index;\n+    BlockFilterIndex* filter_index;\n     if (!PrepareBlockFilterRequest(pfrom, chain_params, filter_type, stop_hash,\n                                    stop_index, filter_index)) {\n         return;"
      }
    ]
  }
]