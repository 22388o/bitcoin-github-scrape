[
  {
    "sha": "1672225670cd34e21e397968433d47e6997f9a5f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNjcyMjI1NjcwY2QzNGUyMWUzOTc5Njg0MzNkNDdlNjk5N2Y5YTVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-08-16T15:38:57Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:42:12Z"
      },
      "message": "Do not store witness txn in rejection cache\n\nGithub-Pull: #8525\nRebased-From: 34521e4d7d176109dedf52ec8ef2b5052b9a30f3",
      "tree": {
        "sha": "eb5ed3725a4aa804354d79d37ba3a8e62a8ebb8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb5ed3725a4aa804354d79d37ba3a8e62a8ebb8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1672225670cd34e21e397968433d47e6997f9a5f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1672225670cd34e21e397968433d47e6997f9a5f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1672225670cd34e21e397968433d47e6997f9a5f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1672225670cd34e21e397968433d47e6997f9a5f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "254e990ce5c380d328da4db4646bd7fb4b37e864",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/254e990ce5c380d328da4db4646bd7fb4b37e864",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/254e990ce5c380d328da4db4646bd7fb4b37e864"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 12,
      "deletions": 8
    },
    "files": [
      {
        "sha": "a664bf2de702f19e62ede662a7655bd92062d8dc",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1672225670cd34e21e397968433d47e6997f9a5f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1672225670cd34e21e397968433d47e6997f9a5f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1672225670cd34e21e397968433d47e6997f9a5f",
        "patch": "@@ -1506,9 +1506,9 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n-            if (CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n+            if (tx.wit.IsNull() && CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n                 !CheckInputs(tx, state, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {\n-                // Only the witness is wrong, so the transaction itself may be fine.\n+                // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n             return false;\n@@ -5505,7 +5505,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     else if (!fMissingInputs2)\n                     {\n                         int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0 && (!state.CorruptionPossible() || State(fromPeer)->fHaveWitness))\n+                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n                         {\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n@@ -5516,7 +5516,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // Probably non-standard or insufficient fee/priority\n                         LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n-                        if (!stateDummy.CorruptionPossible()) {\n+                        if (orphanTx.wit.IsNull() && !stateDummy.CorruptionPossible()) {\n+                            // Do not use rejection cache for witness transactions or\n+                            // witness-stripped transactions, as they can have been malleated.\n+                            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n                             assert(recentRejects);\n                             recentRejects->insert(orphanHash);\n                         }\n@@ -5554,7 +5557,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 LogPrint(\"mempool\", \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n             }\n         } else {\n-            if (!state.CorruptionPossible()) {\n+            if (tx.wit.IsNull() && !state.CorruptionPossible()) {\n+                // Do not use rejection cache for witness transactions or\n+                // witness-stripped transactions, as they can have been malleated.\n+                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n                 assert(recentRejects);\n                 recentRejects->insert(tx.GetHash());\n             }\n@@ -5586,9 +5592,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n-            if (nDoS > 0 && (!state.CorruptionPossible() || State(pfrom->id)->fHaveWitness)) {\n-                // When a non-witness-supporting peer gives us a transaction that would\n-                // be accepted if witness validation was off, we can't blame them for it.\n+            if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n         }"
      }
    ]
  },
  {
    "sha": "b394a96396ce166bf2b519190fdc2a124f57eb5e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzk0YTk2Mzk2Y2UxNjZiZjJiNTE5MTkwZmRjMmExMjRmNTdlYjVl",
    "commit": {
      "author": {
        "name": "instagibbs",
        "email": "gsanders87@gmail.com",
        "date": "2016-08-18T16:04:33Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:42:27Z"
      },
      "message": "Add basic test for IsStandard witness transaction blinding\n\nGithub-Pull: #8525\nRebased-From: ca10a03addf70421893791c2c499e82fc494d60b",
      "tree": {
        "sha": "3b1cc3bb9f95a87f38b4372fc4b18a1299cc7832",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b1cc3bb9f95a87f38b4372fc4b18a1299cc7832"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b394a96396ce166bf2b519190fdc2a124f57eb5e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b394a96396ce166bf2b519190fdc2a124f57eb5e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b394a96396ce166bf2b519190fdc2a124f57eb5e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b394a96396ce166bf2b519190fdc2a124f57eb5e/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1672225670cd34e21e397968433d47e6997f9a5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1672225670cd34e21e397968433d47e6997f9a5f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1672225670cd34e21e397968433d47e6997f9a5f"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 17,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8af46f031653452c85443a6aa0ad665e2db6dbfa",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b394a96396ce166bf2b519190fdc2a124f57eb5e/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b394a96396ce166bf2b519190fdc2a124f57eb5e/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=b394a96396ce166bf2b519190fdc2a124f57eb5e",
        "patch": "@@ -965,8 +965,24 @@ def test_tx_relay_after_segwit_activation(self):\n \n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE])))\n         tx3.wit.vtxinwit.append(CTxInWitness())\n+\n+        # Add too-large for IsStandard witness and check that it does not enter reject filter\n+        p2sh_program = CScript([OP_TRUE])\n+        p2sh_pubkey = hash160(p2sh_program)\n+        witness_program2 = CScript([b'a'*400000])\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])))\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program2]\n+        tx3.rehash()\n+\n+        # Node will not be blinded to the transaction\n+        self.std_node.announce_tx_and_wait_for_getdata(tx3)\n+        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+        self.std_node.announce_tx_and_wait_for_getdata(tx3)\n+        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+\n+        # Remove witness stuffing, instead add extra witness push on stack\n+        tx3.vout[0] = CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE]))\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n         tx3.rehash()\n "
      }
    ]
  },
  {
    "sha": "a5ec2483235d5585e985715a5f66d41dbe1c424e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNWVjMjQ4MzIzNWQ1NTg1ZTk4NTcxNWE1ZjY2ZDQxZGJlMWM0MjRl",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-09-11T18:03:55Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:43:10Z"
      },
      "message": "Remove createwitnessaddress\n\nThis RPC command is unsafe as it will return an address even if the script is invalid.\n\nGithub-Pull: #8699\nRebased-From: 86c3f8db0bf64693313a81d5fe92ef603499030a",
      "tree": {
        "sha": "01aa945a6dd04cef29fe53a468fc716c2e39e05e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01aa945a6dd04cef29fe53a468fc716c2e39e05e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5ec2483235d5585e985715a5f66d41dbe1c424e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5ec2483235d5585e985715a5f66d41dbe1c424e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5ec2483235d5585e985715a5f66d41dbe1c424e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5ec2483235d5585e985715a5f66d41dbe1c424e/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b394a96396ce166bf2b519190fdc2a124f57eb5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b394a96396ce166bf2b519190fdc2a124f57eb5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b394a96396ce166bf2b519190fdc2a124f57eb5e"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 0,
      "deletions": 38
    },
    "files": [
      {
        "sha": "06489566ba3364e1dd9a6b38824919da138279cc",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 38,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5ec2483235d5585e985715a5f66d41dbe1c424e/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5ec2483235d5585e985715a5f66d41dbe1c424e/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=a5ec2483235d5585e985715a5f66d41dbe1c424e",
        "patch": "@@ -320,43 +320,6 @@ UniValue createmultisig(const UniValue& params, bool fHelp)\n     return result;\n }\n \n-UniValue createwitnessaddress(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 1)\n-    {\n-        string msg = \"createwitnessaddress \\\"script\\\"\\n\"\n-            \"\\nCreates a witness address for a particular script.\\n\"\n-            \"It returns a json object with the address and witness script.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"script\\\"       (string, required) A hex encoded script\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n-            \"  \\\"witnessScript\\\":\\\"script\\\"      (string) The string value of the hex-encoded witness script.\\n\"\n-            \"}\\n\"\n-        ;\n-        throw runtime_error(msg);\n-    }\n-\n-    if (!IsHex(params[0].get_str())) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Script must be hex-encoded\");\n-    }\n-\n-    std::vector<unsigned char> code = ParseHex(params[0].get_str());\n-    CScript script(code.begin(), code.end());\n-    CScript witscript = GetScriptForWitness(script);\n-    CScriptID witscriptid(witscript);\n-    CBitcoinAddress address(witscriptid);\n-\n-    UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"address\", address.ToString()));\n-    result.push_back(Pair(\"witnessScript\", HexStr(witscript.begin(), witscript.end())));\n-\n-    return result;\n-}\n-\n UniValue verifymessage(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() != 3)\n@@ -490,7 +453,6 @@ static const CRPCCommand commands[] =\n     { \"control\",            \"getinfo\",                &getinfo,                true  }, /* uses wallet if enabled */\n     { \"util\",               \"validateaddress\",        &validateaddress,        true  }, /* uses wallet if enabled */\n     { \"util\",               \"createmultisig\",         &createmultisig,         true  },\n-    { \"util\",               \"createwitnessaddress\",   &createwitnessaddress,   true  },\n     { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n "
      }
    ]
  },
  {
    "sha": "23feab1f38cd63f55631a1b5125ef1bd5ce049df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyM2ZlYWIxZjM4Y2Q2M2Y1NTYzMWExYjUxMjVlZjFiZDVjZTA0OWRm",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-09-13T16:08:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:43:28Z"
      },
      "message": "Remove maxuploadtargets recommended minimum\n\nGithub-Pull: #8712\nRebased-From: 1b6bcdd3aa379a50c960e23d7c55db8294e76f7f",
      "tree": {
        "sha": "e2e66bc2a81e50888469566559246f9f6477be22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e2e66bc2a81e50888469566559246f9f6477be22"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/23feab1f38cd63f55631a1b5125ef1bd5ce049df",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/23feab1f38cd63f55631a1b5125ef1bd5ce049df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/23feab1f38cd63f55631a1b5125ef1bd5ce049df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/23feab1f38cd63f55631a1b5125ef1bd5ce049df/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a5ec2483235d5585e985715a5f66d41dbe1c424e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5ec2483235d5585e985715a5f66d41dbe1c424e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a5ec2483235d5585e985715a5f66d41dbe1c424e"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 1,
      "deletions": 6
    },
    "files": [
      {
        "sha": "697099beabe96ee7eb15032e557fea652fe98901",
        "filename": "doc/reduce-traffic.md",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/23feab1f38cd63f55631a1b5125ef1bd5ce049df/doc/reduce-traffic.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/23feab1f38cd63f55631a1b5125ef1bd5ce049df/doc/reduce-traffic.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/reduce-traffic.md?ref=23feab1f38cd63f55631a1b5125ef1bd5ce049df",
        "patch": "@@ -19,8 +19,7 @@ This is *not* a hard limit; only a threshold to minimize the outbound\n traffic. When the limit is about to be reached, the uploaded data is cut by no\n longer serving historic blocks (blocks older than one week).\n Keep in mind that new nodes require other nodes that are willing to serve\n-historic blocks. **The recommended minimum is 144 blocks per day (max. 144MB\n-per day)**\n+historic blocks.\n \n Whitelisted peers will never be disconnected, although their traffic counts for\n calculating the target."
      },
      {
        "sha": "5e38ec07790e8cec362f745fb1c13e6ce2e8214a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/23feab1f38cd63f55631a1b5125ef1bd5ce049df/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/23feab1f38cd63f55631a1b5125ef1bd5ce049df/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=23feab1f38cd63f55631a1b5125ef1bd5ce049df",
        "patch": "@@ -2226,11 +2226,7 @@ void CNode::RecordBytesSent(uint64_t bytes)\n void CNode::SetMaxOutboundTarget(uint64_t limit)\n {\n     LOCK(cs_totalBytesSent);\n-    uint64_t recommendedMinimum = (nMaxOutboundTimeframe / 600) * MAX_BLOCK_SERIALIZED_SIZE;\n     nMaxOutboundLimit = limit;\n-\n-    if (limit > 0 && limit < recommendedMinimum)\n-        LogPrintf(\"Max outbound target is very small (%s bytes) and will be overshot. Recommended minimum is %s bytes.\\n\", nMaxOutboundLimit, recommendedMinimum);\n }\n \n uint64_t CNode::GetMaxOutboundTarget()"
      }
    ]
  },
  {
    "sha": "198494ce5323cafbf90a7b543d1b07355eb3db6c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOTg0OTRjZTUzMjNjYWZiZjkwYTdiNTQzZDFiMDczNTVlYjNkYjZj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-25T21:22:37Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:46:19Z"
      },
      "message": "Allow changing BIP9 parameters on regtest\n\nGithub-Pull: #8418\nRebased-From: 56c87e92110f05d7452f1e85bf755246ffc77206",
      "tree": {
        "sha": "1fb64c9e2ec8ebb1fb9d5b4911369c2299a38138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1fb64c9e2ec8ebb1fb9d5b4911369c2299a38138"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/198494ce5323cafbf90a7b543d1b07355eb3db6c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/198494ce5323cafbf90a7b543d1b07355eb3db6c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/198494ce5323cafbf90a7b543d1b07355eb3db6c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/198494ce5323cafbf90a7b543d1b07355eb3db6c/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "23feab1f38cd63f55631a1b5125ef1bd5ce049df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/23feab1f38cd63f55631a1b5125ef1bd5ce049df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/23feab1f38cd63f55631a1b5125ef1bd5ce049df"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 52,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7b493ed8a7e8bd31fd7e903e7108f0b68a5e61ab",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=198494ce5323cafbf90a7b543d1b07355eb3db6c",
        "patch": "@@ -303,6 +303,12 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n         base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n     }\n+\n+    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+    {\n+        consensus.vDeployments[d].nStartTime = nStartTime;\n+        consensus.vDeployments[d].nTimeout = nTimeout;\n+    }\n };\n static CRegTestParams regTestParams;\n \n@@ -330,4 +336,9 @@ void SelectParams(const std::string& network)\n     SelectBaseParams(network);\n     pCurrentParams = &Params(network);\n }\n+\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+}\n  "
      },
      {
        "sha": "0c3820b7c6e725ff5e468606c3b985185fb41754",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=198494ce5323cafbf90a7b543d1b07355eb3db6c",
        "patch": "@@ -112,4 +112,9 @@ CChainParams& Params(const std::string& chain);\n  */\n void SelectParams(const std::string& chain);\n \n+/**\n+ * Allows modifying the BIP9 regtest parameters.\n+ */\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+\n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "f2b13b627ae14d6a45aac15f8aedc6cc0ea67f87",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/198494ce5323cafbf90a7b543d1b07355eb3db6c/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=198494ce5323cafbf90a7b543d1b07355eb3db6c",
        "patch": "@@ -410,6 +410,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified bip9 deployment (regtest-only)\");\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n@@ -990,6 +991,41 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n+    if (!mapMultiArgs[\"-bip9params\"].empty()) {\n+        // Allow overriding bip9 parameters for testing\n+        if (!Params().MineBlocksOnDemand()) {\n+            return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n+        }\n+        const vector<string>& deployments = mapMultiArgs[\"-bip9params\"];\n+        for (auto i : deployments) {\n+            std::vector<std::string> vDeploymentParams;\n+            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            if (vDeploymentParams.size() != 3) {\n+                return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n+            }\n+            int64_t nStartTime, nTimeout;\n+            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n+                return InitError(strprintf(\"Invalid nStartTime (%s)\", vDeploymentParams[1]));\n+            }\n+            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {\n+                return InitError(strprintf(\"Invalid nTimeout (%s)\", vDeploymentParams[2]));\n+            }\n+            bool found = false;\n+            for (int i=0; i<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++i)\n+            {\n+                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[i].name) == 0) {\n+                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(i), nStartTime, nTimeout);\n+                    found = true;\n+                    LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                return InitError(strprintf(\"Invalid deployment (%s)\", vDeploymentParams[0]));\n+            }\n+        }\n+    }\n+\n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n     // Initialize elliptic curve code"
      }
    ]
  },
  {
    "sha": "ff893aa5574f5c422b72dd10b00eac805fc737e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjg5M2FhNTU3NGY1YzQyMmI3MmRkMTBiMDBlYWM4MDVmYzczN2U1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-27T14:06:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:46:56Z"
      },
      "message": "Implement SipHash in Python\n\nGithub-Pull: #8418\nRebased-From: 9c8593d2b4e25ef628172ceadbedf0ef078d01ef",
      "tree": {
        "sha": "d56d3b4f0a6aa6042a0984d692facc32a8ea9baf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d56d3b4f0a6aa6042a0984d692facc32a8ea9baf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff893aa5574f5c422b72dd10b00eac805fc737e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff893aa5574f5c422b72dd10b00eac805fc737e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff893aa5574f5c422b72dd10b00eac805fc737e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff893aa5574f5c422b72dd10b00eac805fc737e5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "198494ce5323cafbf90a7b543d1b07355eb3db6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/198494ce5323cafbf90a7b543d1b07355eb3db6c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/198494ce5323cafbf90a7b543d1b07355eb3db6c"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 68,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c0574bd931758cca0b1583da0269bec96b5d8bf",
        "filename": "qa/rpc-tests/test_framework/siphash.py",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff893aa5574f5c422b72dd10b00eac805fc737e5/qa/rpc-tests/test_framework/siphash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff893aa5574f5c422b72dd10b00eac805fc737e5/qa/rpc-tests/test_framework/siphash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/siphash.py?ref=ff893aa5574f5c422b72dd10b00eac805fc737e5",
        "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# siphash.py - Specialized SipHash-2-4 implementations\n+#\n+# This implements SipHash-2-4 for 256-bit integers.\n+\n+def rotl64(n, b):\n+    return n >> (64 - b) | (n & ((1 << (64 - b)) - 1)) << b\n+\n+def siphash_round(v0, v1, v2, v3):\n+    v0 = (v0 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 13)\n+    v1 ^= v0\n+    v0 = rotl64(v0, 32)\n+    v2 = (v2 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 16)\n+    v3 ^= v2\n+    v0 = (v0 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 21)\n+    v3 ^= v0\n+    v2 = (v2 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 17)\n+    v1 ^= v2\n+    v2 = rotl64(v2, 32)\n+    return (v0, v1, v2, v3)\n+\n+def siphash256(k0, k1, h):\n+    n0 = h & ((1 << 64) - 1)\n+    n1 = (h >> 64) & ((1 << 64) - 1)\n+    n2 = (h >> 128) & ((1 << 64) - 1)\n+    n3 = (h >> 192) & ((1 << 64) - 1)\n+    v0 = 0x736f6d6570736575 ^ k0\n+    v1 = 0x646f72616e646f6d ^ k1\n+    v2 = 0x6c7967656e657261 ^ k0\n+    v3 = 0x7465646279746573 ^ k1 ^ n0\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n0\n+    v3 ^= n1\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n1\n+    v3 ^= n2\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n2\n+    v3 ^= n3\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n3\n+    v3 ^= 0x2000000000000000\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= 0x2000000000000000\n+    v2 ^= 0xFF\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    return v0 ^ v1 ^ v2 ^ v3"
      },
      {
        "sha": "fa9624f13daf5508d21571c50d2540f5580ba8e3",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff893aa5574f5c422b72dd10b00eac805fc737e5/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff893aa5574f5c422b72dd10b00eac805fc737e5/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=ff893aa5574f5c422b72dd10b00eac805fc737e5",
        "patch": "@@ -122,6 +122,10 @@ BOOST_AUTO_TEST_CASE(siphash)\n         hasher3.Write(uint64_t(x)|(uint64_t(x+1)<<8)|(uint64_t(x+2)<<16)|(uint64_t(x+3)<<24)|\n                      (uint64_t(x+4)<<32)|(uint64_t(x+5)<<40)|(uint64_t(x+6)<<48)|(uint64_t(x+7)<<56));\n     }\n+\n+    CHashWriter ss(SER_DISK, CLIENT_VERSION);\n+    ss << CTransaction();\n+    BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "4295a7aea55be34c95a0624e95ea0b9587e644b6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Mjk1YTdhZWE1NWJlMzRjOTVhMDYyNGU5NWVhMGI5NTg3ZTY0NGI2",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-06-18T01:17:25Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:47:06Z"
      },
      "message": "Tests: refactor compact size serialization in mininode\n\nGithub-Pull: #8418\nRebased-From: a8689fdf8e10300b73750161a73a23467ecd1efe",
      "tree": {
        "sha": "f6c6b4a5deb73a71c9da889a59de97e38957cb62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6c6b4a5deb73a71c9da889a59de97e38957cb62"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4295a7aea55be34c95a0624e95ea0b9587e644b6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4295a7aea55be34c95a0624e95ea0b9587e644b6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4295a7aea55be34c95a0624e95ea0b9587e644b6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4295a7aea55be34c95a0624e95ea0b9587e644b6/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff893aa5574f5c422b72dd10b00eac805fc737e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff893aa5574f5c422b72dd10b00eac805fc737e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff893aa5574f5c422b72dd10b00eac805fc737e5"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 25,
      "deletions": 72
    },
    "files": [
      {
        "sha": "67aaab698e9521a3ed3de13b0892fbcd2779b7cc",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 25,
        "deletions": 72,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4295a7aea55be34c95a0624e95ea0b9587e644b6/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4295a7aea55be34c95a0624e95ea0b9587e644b6/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=4295a7aea55be34c95a0624e95ea0b9587e644b6",
        "patch": "@@ -74,25 +74,34 @@ def ripemd160(s):\n def hash256(s):\n     return sha256(sha256(s))\n \n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n \n-def deser_string(f):\n+def deser_compact_size(f):\n     nit = struct.unpack(\"<B\", f.read(1))[0]\n     if nit == 253:\n         nit = struct.unpack(\"<H\", f.read(2))[0]\n     elif nit == 254:\n         nit = struct.unpack(\"<I\", f.read(4))[0]\n     elif nit == 255:\n         nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return nit\n+\n+def deser_string(f):\n+    nit = deser_compact_size(f)\n     return f.read(nit)\n \n def ser_string(s):\n-    if len(s) < 253:\n-        return struct.pack(\"B\", len(s)) + s\n-    elif len(s) < 0x10000:\n-        return struct.pack(\"<BH\", 253, len(s)) + s\n-    elif len(s) < 0x100000000:\n-        return struct.pack(\"<BI\", 254, len(s)) + s\n-    return struct.pack(\"<BQ\", 255, len(s)) + s\n+    return ser_compact_size(len(s)) + s\n \n def deser_uint256(f):\n     r = 0\n@@ -125,13 +134,7 @@ def uint256_from_compact(c):\n \n \n def deser_vector(f, c):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = c()\n@@ -144,15 +147,7 @@ def deser_vector(f, c):\n # entries in the vector (we use this for serializing the vector of transactions\n # for a witness block).\n def ser_vector(l, ser_function_name=None):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         if ser_function_name:\n             r += getattr(i, ser_function_name)()\n@@ -162,13 +157,7 @@ def ser_vector(l, ser_function_name=None):\n \n \n def deser_uint256_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_uint256(f)\n@@ -177,28 +166,14 @@ def deser_uint256_vector(f):\n \n \n def ser_uint256_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += ser_uint256(i)\n     return r\n \n \n def deser_string_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_string(f)\n@@ -207,28 +182,14 @@ def deser_string_vector(f):\n \n \n def ser_string_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for sv in l:\n         r += ser_string(sv)\n     return r\n \n \n def deser_int_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = struct.unpack(\"<i\", f.read(4))[0]\n@@ -237,15 +198,7 @@ def deser_int_vector(f):\n \n \n def ser_int_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += struct.pack(\"<i\", i)\n     return r"
      }
    ]
  },
  {
    "sha": "f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNmJlNDc4YjBhYTBkNDhkYmI5ZWQ0MGY5N2Y1OWE3NDAyMTRiN2U1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-12T20:04:38Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:47:09Z"
      },
      "message": "Add support for compactblocks to mininode\n\nGithub-Pull: #8418\nRebased-From: 9a22a6c0891256f02f4906c1c13fb22a9722ec7c",
      "tree": {
        "sha": "119111aaba6c644143f7a50c87fc5134f8766fc1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/119111aaba6c644143f7a50c87fc5134f8766fc1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4295a7aea55be34c95a0624e95ea0b9587e644b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4295a7aea55be34c95a0624e95ea0b9587e644b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4295a7aea55be34c95a0624e95ea0b9587e644b6"
      }
    ],
    "stats": {
      "total": 276,
      "additions": 272,
      "deletions": 4
    },
    "files": [
      {
        "sha": "caffab35351df437f8828baa60284f0b3ac79cac",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 272,
        "deletions": 4,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
        "patch": "@@ -36,9 +36,10 @@\n from threading import Thread\n import logging\n import copy\n+from test_framework.siphash import siphash256\n \n BIP0031_VERSION = 60000\n-MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n \n MAX_INV_SZ = 50000\n@@ -52,7 +53,7 @@\n NODE_WITNESS = (1 << 3)\n \n # Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to workaround an issue with closing an asyncore socket when \n+# ourselves (to workaround an issue with closing an asyncore socket when\n # using select)\n mininode_socket_map = dict()\n \n@@ -247,7 +248,8 @@ class CInv(object):\n         1: \"TX\",\n         2: \"Block\",\n         1|MSG_WITNESS_FLAG: \"WitnessTx\",\n-        2|MSG_WITNESS_FLAG : \"WitnessBlock\"\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n+        4: \"CompactBlock\"\n     }\n \n     def __init__(self, t=0, h=0):\n@@ -734,6 +736,187 @@ def __repr__(self):\n             % (len(self.vchMsg), len(self.vchSig))\n \n \n+class PrefilledTransaction(object):\n+    def __init__(self, index=0, tx = None):\n+        self.index = index\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.index = deser_compact_size(f)\n+        self.tx = CTransaction()\n+        self.tx.deserialize(f)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_compact_size(self.index)\n+        if with_witness:\n+            r += self.tx.serialize_with_witness()\n+        else:\n+            r += self.tx.serialize_without_witness()\n+        return r\n+\n+    def __repr__(self):\n+        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n+\n+# This is what we send on the wire, in a cmpctblock message.\n+class P2PHeaderAndShortIDs(object):\n+    def __init__(self):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids_length = 0\n+        self.shortids = []\n+        self.prefilled_txn_length = 0\n+        self.prefilled_txn = []\n+\n+    def deserialize(self, f):\n+        self.header.deserialize(f)\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.shortids_length = deser_compact_size(f)\n+        for i in range(self.shortids_length):\n+            # shortids are defined to be 6 bytes in the spec, so append\n+            # two zero bytes and read it in as an 8-byte number\n+            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n+        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n+        self.prefilled_txn_length = len(self.prefilled_txn)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += self.header.serialize()\n+        r += struct.pack(\"<Q\", self.nonce)\n+        r += ser_compact_size(self.shortids_length)\n+        for x in self.shortids:\n+            # We only want the first 6 bytes\n+            r += struct.pack(\"<Q\", x)[0:6]\n+        r += ser_vector(self.prefilled_txn)\n+        return r\n+\n+    def __repr__(self):\n+        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n+\n+\n+# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n+def calculate_shortid(k0, k1, tx_hash):\n+    expected_shortid = siphash256(k0, k1, tx_hash)\n+    expected_shortid &= 0x0000ffffffffffff\n+    return expected_shortid\n+\n+# This version gets rid of the array lengths, and reinterprets the differential\n+# encoding into indices that can be used for lookup.\n+class HeaderAndShortIDs(object):\n+    def __init__(self, p2pheaders_and_shortids = None):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids = []\n+        self.prefilled_txn = []\n+\n+        if p2pheaders_and_shortids != None:\n+            self.header = p2pheaders_and_shortids.header\n+            self.nonce = p2pheaders_and_shortids.nonce\n+            self.shortids = p2pheaders_and_shortids.shortids\n+            last_index = -1\n+            for x in p2pheaders_and_shortids.prefilled_txn:\n+                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n+                last_index = self.prefilled_txn[-1].index\n+\n+    def to_p2p(self):\n+        ret = P2PHeaderAndShortIDs()\n+        ret.header = self.header\n+        ret.nonce = self.nonce\n+        ret.shortids_length = len(self.shortids)\n+        ret.shortids = self.shortids\n+        ret.prefilled_txn_length = len(self.prefilled_txn)\n+        ret.prefilled_txn = []\n+        last_index = -1\n+        for x in self.prefilled_txn:\n+            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n+            last_index = x.index\n+        return ret\n+\n+    def get_siphash_keys(self):\n+        header_nonce = self.header.serialize()\n+        header_nonce += struct.pack(\"<Q\", self.nonce)\n+        hash_header_nonce_as_str = sha256(header_nonce)\n+        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n+        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n+        return [ key0, key1 ]\n+\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0]):\n+        self.header = CBlockHeader(block)\n+        self.nonce = nonce\n+        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n+        self.shortids = []\n+        [k0, k1] = self.get_siphash_keys()\n+        for i in range(len(block.vtx)):\n+            if i not in prefill_list:\n+                self.shortids.append(calculate_shortid(k0, k1, block.vtx[i].sha256))\n+\n+    def __repr__(self):\n+        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n+\n+\n+class BlockTransactionsRequest(object):\n+\n+    def __init__(self, blockhash=0, indexes = None):\n+        self.blockhash = blockhash\n+        self.indexes = indexes if indexes != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        indexes_length = deser_compact_size(f)\n+        for i in range(indexes_length):\n+            self.indexes.append(deser_compact_size(f))\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        r += ser_compact_size(len(self.indexes))\n+        for x in self.indexes:\n+            r += ser_compact_size(x)\n+        return r\n+\n+    # helper to set the differentially encoded indexes from absolute ones\n+    def from_absolute(self, absolute_indexes):\n+        self.indexes = []\n+        last_index = -1\n+        for x in absolute_indexes:\n+            self.indexes.append(x-last_index-1)\n+            last_index = x\n+\n+    def to_absolute(self):\n+        absolute_indexes = []\n+        last_index = -1\n+        for x in self.indexes:\n+            absolute_indexes.append(x+last_index+1)\n+            last_index = absolute_indexes[-1]\n+        return absolute_indexes\n+\n+    def __repr__(self):\n+        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n+\n+\n+class BlockTransactions(object):\n+\n+    def __init__(self, blockhash=0, transactions = None):\n+        self.blockhash = blockhash\n+        self.transactions = transactions if transactions != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        self.transactions = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        if with_witness:\n+            r += ser_vector(self.transactions, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.transactions)\n+        return r\n+\n+    def __repr__(self):\n+        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n+\n+\n # Objects that correspond to messages on the wire\n class msg_version(object):\n     command = b\"version\"\n@@ -1168,6 +1351,79 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_feefilter(feerate=%08x)\" % self.feerate\n \n+class msg_sendcmpct(object):\n+    command = b\"sendcmpct\"\n+\n+    def __init__(self):\n+        self.announce = False\n+        self.version = 1\n+\n+    def deserialize(self, f):\n+        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.announce)\n+        r += struct.pack(\"<Q\", self.version)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n+\n+class msg_cmpctblock(object):\n+    command = b\"cmpctblock\"\n+\n+    def __init__(self, header_and_shortids = None):\n+        self.header_and_shortids = header_and_shortids\n+\n+    def deserialize(self, f):\n+        self.header_and_shortids = P2PHeaderAndShortIDs()\n+        self.header_and_shortids.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.header_and_shortids.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n+\n+class msg_getblocktxn(object):\n+    command = b\"getblocktxn\"\n+\n+    def __init__(self):\n+        self.block_txn_request = None\n+\n+    def deserialize(self, f):\n+        self.block_txn_request = BlockTransactionsRequest()\n+        self.block_txn_request.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_txn_request.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n+\n+class msg_blocktxn(object):\n+    command = b\"blocktxn\"\n+\n+    def __init__(self):\n+        self.block_transactions = BlockTransactions()\n+\n+    def deserialize(self, f):\n+        self.block_transactions.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n+\n # This is what a callback should look like for NodeConn\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n@@ -1248,6 +1504,10 @@ def on_mempool(self, conn): pass\n     def on_pong(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n     def on_sendheaders(self, conn, message): pass\n+    def on_sendcmpct(self, conn, message): pass\n+    def on_cmpctblock(self, conn, message): pass\n+    def on_getblocktxn(self, conn, message): pass\n+    def on_blocktxn(self, conn, message): pass\n \n # More useful callbacks and functions for NodeConnCB's which have a single NodeConn\n class SingleNodeConnCB(NodeConnCB):\n@@ -1264,6 +1524,10 @@ def add_connection(self, conn):\n     def send_message(self, message):\n         self.connection.send_message(message)\n \n+    def send_and_ping(self, message):\n+        self.send_message(message)\n+        self.sync_with_ping()\n+\n     def on_pong(self, conn, message):\n         self.last_pong = message\n \n@@ -1297,7 +1561,11 @@ class NodeConn(asyncore.dispatcher):\n         b\"reject\": msg_reject,\n         b\"mempool\": msg_mempool,\n         b\"feefilter\": msg_feefilter,\n-        b\"sendheaders\": msg_sendheaders\n+        b\"sendheaders\": msg_sendheaders,\n+        b\"sendcmpct\": msg_sendcmpct,\n+        b\"cmpctblock\": msg_cmpctblock,\n+        b\"getblocktxn\": msg_getblocktxn,\n+        b\"blocktxn\": msg_blocktxn\n     }\n     MAGIC_BYTES = {\n         \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet"
      }
    ]
  },
  {
    "sha": "fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYjg3MDZlYmQ3NDhlOGI5OWUzZDA4YTQ5ZGE5ZmRjOGU4MDA4MDZi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-07-12T20:05:02Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:47:11Z"
      },
      "message": "Add p2p test for BIP 152 (compact blocks)\n\nGithub-Pull: #8418\nRebased-From: 45c7ddd109465e03551f5b39c2e650c243b4a078",
      "tree": {
        "sha": "27a2b9f09fbab4e87cbc87c02331c06e0c070a21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27a2b9f09fbab4e87cbc87c02331c06e0c070a21"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb8706ebd748e8b99e3d08a49da9fdc8e800806b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6be478b0aa0d48dbb9ed40f97f59a740214b7e5"
      }
    ],
    "stats": {
      "total": 609,
      "additions": 609,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1e57a3fc20a3fc5bb5f20f5b60ff264b98a30c99",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb8706ebd748e8b99e3d08a49da9fdc8e800806b/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb8706ebd748e8b99e3d08a49da9fdc8e800806b/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
        "patch": "@@ -142,6 +142,7 @@\n     'segwit.py',\n     'importprunedfunds.py',\n     'signmessages.py',\n+    'p2p-compactblocks.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "7fe7ecc16c6e19ae3fb4e9ece144f28fcee60740",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "added",
        "additions": 608,
        "deletions": 0,
        "changes": 608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb8706ebd748e8b99e3d08a49da9fdc8e800806b/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb8706ebd748e8b99e3d08a49da9fdc8e800806b/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
        "patch": "@@ -0,0 +1,608 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.siphash import siphash256\n+from test_framework.script import CScript, OP_TRUE\n+\n+'''\n+CompactBlocksTest -- test compact blocks (BIP 152)\n+'''\n+\n+\n+# TestNode: A peer we use to send messages to bitcoind, and store responses.\n+class TestNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_sendcmpct = None\n+        self.last_headers = None\n+        self.last_inv = None\n+        self.last_cmpctblock = None\n+        self.block_announced = False\n+        self.last_getdata = None\n+        self.last_getblocktxn = None\n+        self.last_block = None\n+        self.last_blocktxn = None\n+\n+    def on_sendcmpct(self, conn, message):\n+        self.last_sendcmpct = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message\n+\n+    def on_cmpctblock(self, conn, message):\n+        self.last_cmpctblock = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_getblocktxn(self, conn, message):\n+        self.last_getblocktxn = message\n+\n+    def on_blocktxn(self, conn, message):\n+        self.last_blocktxn = message\n+\n+    # Requires caller to hold mininode_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+            self.last_cmpctblock = None\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n+        self.send_message(headers_message)\n+\n+\n+class CompactBlocksTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.utxos = []\n+\n+    def setup_network(self):\n+        self.nodes = []\n+\n+        # Turn off segwit in this test, as compact blocks don't currently work\n+        # with segwit.  (After BIP 152 is updated to support segwit, we can\n+        # test behavior with and without segwit enabled by adding a second node\n+        # to the test.)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"]])\n+\n+    def build_block_on_tip(self):\n+        height = self.nodes[0].getblockcount()\n+        tip = self.nodes[0].getbestblockhash()\n+        mtp = self.nodes[0].getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.solve()\n+        return block\n+\n+    # Create 10 more anyone-can-spend utxo's for testing.\n+    def make_utxos(self):\n+        block = self.build_block_on_tip()\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n+        self.nodes[0].generate(100)\n+\n+        total_value = block.vtx[0].vout[0].nValue\n+        out_value = total_value // 10\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(block.vtx[0].sha256, 0), b''))\n+        for i in range(10):\n+            tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n+        tx.rehash()\n+\n+        block2 = self.build_block_on_tip()\n+        block2.vtx.append(tx)\n+        block2.hashMerkleRoot = block2.calc_merkle_root()\n+        block2.solve()\n+        self.test_node.send_and_ping(msg_block(block2))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block2.sha256)\n+        self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n+        return\n+\n+    # Test \"sendcmpct\":\n+    # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n+    #   sendcmpct is sent.\n+    # - If sendcmpct is sent with version > 0, the message is ignored.\n+    # - If sendcmpct is sent with boolean 0, then block announcements are not\n+    #   made with compact blocks.\n+    # - If sendcmpct is then sent with boolean 1, then new block announcements\n+    #   are made with compact blocks.\n+    def test_sendcmpct(self):\n+        print(\"Testing SENDCMPCT p2p message... \")\n+\n+        # Make sure we get a version 0 SENDCMPCT message from our peer\n+        def received_sendcmpct():\n+            return (self.test_node.last_sendcmpct is not None)\n+        got_message = wait_until(received_sendcmpct, timeout=30)\n+        assert(got_message)\n+        assert_equal(self.test_node.last_sendcmpct.version, 1)\n+\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+\n+        def check_announcement_of_new_block(node, peer, predicate):\n+            self.test_node.clear_block_announcement()\n+            node.generate(1)\n+            got_message = wait_until(peer.received_block_announcement, timeout=30)\n+            assert(got_message)\n+            with mininode_lock:\n+                assert(predicate)\n+\n+        # We shouldn't get any block announcements via cmpctblock yet.\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Try one more time, this time after requesting headers.\n+        self.test_node.clear_block_announcement()\n+        self.test_node.get_headers(locator=[tip], hashstop=0)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_inv is not None)\n+\n+        # Now try a SENDCMPCT message with too-high version\n+        sendcmpct = msg_sendcmpct()\n+        sendcmpct.version = 2\n+        self.test_node.send_message(sendcmpct)\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Now try a SENDCMPCT message with valid version, but announce=False\n+        self.test_node.send_message(msg_sendcmpct())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Finally, try a SENDCMPCT message with announce=True\n+        sendcmpct.version = 1\n+        sendcmpct.announce = True\n+        self.test_node.send_message(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time, after turning on sendheaders\n+        self.test_node.send_message(msg_sendheaders())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Now turn off announcements\n+        sendcmpct.announce = False\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_headers is not None)\n+\n+    # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n+    def test_invalid_cmpctblock_message(self):\n+        print(\"Testing invalid index in cmpctblock message...\")\n+        self.nodes[0].generate(101)\n+        block = self.build_block_on_tip()\n+\n+        cmpct_block = P2PHeaderAndShortIDs()\n+        cmpct_block.header = CBlockHeader(block)\n+        cmpct_block.prefilled_txn_length = 1\n+        # This index will be too high\n+        prefilled_txn = PrefilledTransaction(1, block.vtx[0])\n+        cmpct_block.prefilled_txn = [prefilled_txn]\n+        self.test_node.send_and_ping(msg_cmpctblock(cmpct_block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.hashPrevBlock)\n+\n+    # Compare the generated shortids to what we expect based on BIP 152, given\n+    # bitcoind's choice of nonce.\n+    def test_compactblock_construction(self):\n+        print(\"Testing compactblock headers and shortIDs are correct...\")\n+\n+        # Generate a bunch of transactions.\n+        self.nodes[0].generate(101)\n+        num_transactions = 25\n+        address = self.nodes[0].getnewaddress()\n+        for i in range(num_transactions):\n+            self.nodes[0].sendtoaddress(address, 0.1)\n+\n+        # Now mine a block, and look at the resulting compact block.\n+        self.test_node.clear_block_announcement()\n+        block_hash = int(self.nodes[0].generate(1)[0], 16)\n+\n+        # Store the raw block in our internal format.\n+        block = FromHex(CBlock(), self.nodes[0].getblock(\"%02x\" % block_hash, False))\n+        [tx.calc_sha256() for tx in block.vtx]\n+        block.rehash()\n+\n+        # Don't care which type of announcement came back for this test; just\n+        # request the compact block if we didn't get one yet.\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        with mininode_lock:\n+            if self.test_node.last_cmpctblock is None:\n+                self.test_node.clear_block_announcement()\n+                inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n+                self.test_node.send_message(msg_getdata([inv]))\n+\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        # Now we should have the compactblock\n+        header_and_shortids = None\n+        with mininode_lock:\n+            assert(self.test_node.last_cmpctblock is not None)\n+            # Convert the on-the-wire representation to absolute indexes\n+            header_and_shortids = HeaderAndShortIDs(self.test_node.last_cmpctblock.header_and_shortids)\n+\n+        # Check that we got the right block!\n+        header_and_shortids.header.calc_sha256()\n+        assert_equal(header_and_shortids.header.sha256, block_hash)\n+\n+        # Make sure the prefilled_txn appears to have included the coinbase\n+        assert(len(header_and_shortids.prefilled_txn) >= 1)\n+        assert_equal(header_and_shortids.prefilled_txn[0].index, 0)\n+\n+        # Check that all prefilled_txn entries match what's in the block.\n+        for entry in header_and_shortids.prefilled_txn:\n+            entry.tx.calc_sha256()\n+            assert_equal(entry.tx.sha256, block.vtx[entry.index].sha256)\n+\n+        # Check that the cmpctblock message announced all the transactions.\n+        assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n+\n+        # And now check that all the shortids are as expected as well.\n+        # Determine the siphash keys to use.\n+        [k0, k1] = header_and_shortids.get_siphash_keys()\n+\n+        index = 0\n+        while index < len(block.vtx):\n+            if (len(header_and_shortids.prefilled_txn) > 0 and\n+                    header_and_shortids.prefilled_txn[0].index == index):\n+                # Already checked prefilled transactions above\n+                header_and_shortids.prefilled_txn.pop(0)\n+            else:\n+                shortid = calculate_shortid(k0, k1, block.vtx[index].sha256)\n+                assert_equal(shortid, header_and_shortids.shortids[0])\n+                header_and_shortids.shortids.pop(0)\n+            index += 1\n+\n+    # Test that bitcoind requests compact blocks when we announce new blocks\n+    # via header or inv, and that responding to getblocktxn causes the block\n+    # to be successfully reconstructed.\n+    def test_compactblock_requests(self):\n+        print(\"Testing compactblock requests... \")\n+\n+        # Try announcing a block with an inv or header, expect a compactblock\n+        # request\n+        for announce in [\"inv\", \"header\"]:\n+            block = self.build_block_on_tip()\n+            with mininode_lock:\n+                self.test_node.last_getdata = None\n+\n+            if announce == \"inv\":\n+                self.test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n+            else:\n+                self.test_node.send_header_for_blocks([block])\n+            success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=30)\n+            assert(success)\n+            assert_equal(len(self.test_node.last_getdata.inv), 1)\n+            assert_equal(self.test_node.last_getdata.inv[0].type, 4)\n+            assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+            # Send back a compactblock message that omits the coinbase\n+            comp_block = HeaderAndShortIDs()\n+            comp_block.header = CBlockHeader(block)\n+            comp_block.nonce = 0\n+            comp_block.shortids = [1]  # this is useless, and wrong\n+            self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+            # Expect a getblocktxn message.\n+            with mininode_lock:\n+                assert(self.test_node.last_getblocktxn is not None)\n+                absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert_equal(absolute_indexes, [0])  # should be a coinbase request\n+\n+            # Send the coinbase, and verify that the tip advances.\n+            msg = msg_blocktxn()\n+            msg.block_transactions.blockhash = block.sha256\n+            msg.block_transactions.transactions = [block.vtx[0]]\n+            self.test_node.send_and_ping(msg)\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Create a chain of transactions from given utxo, and add to a new block.\n+    def build_block_with_transactions(self, utxo, num_transactions):\n+        block = self.build_block_on_tip()\n+\n+        for i in range(num_transactions):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(utxo[0], utxo[1]), b''))\n+            tx.vout.append(CTxOut(utxo[2] - 1000, CScript([OP_TRUE])))\n+            tx.rehash()\n+            utxo = [tx.sha256, 0, tx.vout[0].nValue]\n+            block.vtx.append(tx)\n+\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.solve()\n+        return block\n+\n+    # Test that we only receive getblocktxn requests for transactions that the\n+    # node needs, and that responding to them causes the block to be\n+    # reconstructed.\n+    def test_getblocktxn_requests(self):\n+        print(\"Testing getblocktxn requests...\")\n+\n+        # First try announcing compactblocks that won't reconstruct, and verify\n+        # that we receive getblocktxn messages back.\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [1, 2, 3, 4, 5])\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        # Now try interspersing the prefilled transactions\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [2, 3, 4])\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now try giving one transaction ahead of time.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        self.test_node.send_and_ping(msg_tx(block.vtx[1]))\n+        assert(block.vtx[1].hash in self.nodes[0].getrawmempool())\n+\n+        # Prefill 4 out of the 6 transactions, and verify that only the one\n+        # that was not in the mempool is requested.\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [5])\n+\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now provide all transactions to the node before the block is\n+        # announced and verify reconstruction happens immediately.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        for tx in block.vtx[1:]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:]:\n+            assert(tx.hash in mempool)\n+\n+        # Clear out last request.\n+        with mininode_lock:\n+            self.test_node.last_getblocktxn = None\n+\n+        # Send compact block\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            # Shouldn't have gotten a request for any transaction\n+            assert(self.test_node.last_getblocktxn is None)\n+        # Tip should have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n+    # permanently failed.\n+    def test_incorrect_blocktxn_response(self):\n+        print(\"Testing handling of incorrect blocktxn responses...\")\n+\n+        if (len(self.utxos) == 0):\n+            self.make_utxos()\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        # Relay the first 5 transactions from the block in advance\n+        for tx in block.vtx[1:6]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:6]:\n+            assert(tx.hash in mempool)\n+\n+        # Send compact block\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        absolute_indexes = []\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n+\n+        # Now give an incorrect response.\n+        # Note that it's possible for bitcoind to be smart enough to know we're\n+        # lying, since it could check to see if the shortid matches what we're\n+        # sending, and eg disconnect us for misbehavior.  If that behavior\n+        # change were made, we could just modify this test by having a\n+        # different peer provide the block further down, so that we're still\n+        # verifying that the block isn't marked bad permanently. This is good\n+        # enough for now.\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n+        self.test_node.send_and_ping(msg)\n+\n+        # Tip should not have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+\n+        # We should receive a getdata request\n+        success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=10)\n+        assert(success)\n+        assert_equal(len(self.test_node.last_getdata.inv), 1)\n+        assert_equal(self.test_node.last_getdata.inv[0].type, 2)\n+        assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+        # Deliver the block\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    def test_getblocktxn_handler(self):\n+        print(\"Testing getblocktxn handler...\")\n+\n+        # bitcoind won't respond for blocks whose height is more than 15 blocks\n+        # deep.\n+        MAX_GETBLOCKTXN_DEPTH = 15\n+        chain_height = self.nodes[0].getblockcount()\n+        current_height = chain_height\n+        while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n+            block_hash = self.nodes[0].getblockhash(current_height)\n+            block = FromHex(CBlock(), self.nodes[0].getblock(block_hash, False))\n+\n+            msg = msg_getblocktxn()\n+            msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n+            num_to_request = random.randint(1, len(block.vtx))\n+            msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n+            self.test_node.send_message(msg)\n+            success = wait_until(lambda: self.test_node.last_blocktxn is not None, timeout=10)\n+            assert(success)\n+\n+            [tx.calc_sha256() for tx in block.vtx]\n+            with mininode_lock:\n+                assert_equal(self.test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                all_indices = msg.block_txn_request.to_absolute()\n+                for index in all_indices:\n+                    tx = self.test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx.calc_sha256()\n+                    assert_equal(tx.sha256, block.vtx[index].sha256)\n+                self.test_node.last_blocktxn = None\n+            current_height -= 1\n+\n+        # Next request should be ignored, as we're past the allowed depth.\n+        block_hash = self.nodes[0].getblockhash(current_height)\n+        msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert_equal(self.test_node.last_blocktxn, None)\n+\n+    def test_compactblocks_not_at_tip(self):\n+        print(\"Testing compactblock requests/announcements not at chain tip...\")\n+\n+        # Test that requesting old compactblocks doesn't work.\n+        MAX_CMPCTBLOCK_DEPTH = 11\n+        new_blocks = []\n+        for i in range(MAX_CMPCTBLOCK_DEPTH):\n+            self.test_node.clear_block_announcement()\n+            new_blocks.append(self.nodes[0].generate(1)[0])\n+            wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_cmpctblock is not None, timeout=30)\n+        assert(success)\n+\n+        self.test_node.clear_block_announcement()\n+        self.nodes[0].generate(1)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_block is not None, timeout=30)\n+        assert(success)\n+        with mininode_lock:\n+            self.test_node.last_block.block.calc_sha256()\n+            assert_equal(self.test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+\n+        # Generate an old compactblock, and verify that it's not accepted.\n+        cur_height = self.nodes[0].getblockcount()\n+        hashPrevBlock = int(self.nodes[0].getblockhash(cur_height-5), 16)\n+        block = self.build_block_on_tip()\n+        block.hashPrevBlock = hashPrevBlock\n+        block.solve()\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+\n+        tips = self.nodes[0].getchaintips()\n+        found = False\n+        for x in tips:\n+            if x[\"hash\"] == block.hash:\n+                assert_equal(x[\"status\"], \"headers-only\")\n+                found = True\n+                break\n+        assert(found)\n+\n+        # Requesting this block via getblocktxn should silently fail\n+        # (to avoid fingerprinting attacks).\n+        msg = msg_getblocktxn()\n+        msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n+        with mininode_lock:\n+            self.test_node.last_blocktxn = None\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert(self.test_node.last_blocktxn is None)\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        self.test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n+        self.test_node.add_connection(connections[0])\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        self.test_node.wait_for_verack()\n+\n+        # We will need UTXOs to construct transactions in later tests.\n+        self.make_utxos()\n+\n+        self.test_sendcmpct()\n+        self.test_compactblock_construction()\n+        self.test_compactblock_requests()\n+        self.test_getblocktxn_requests()\n+        self.test_getblocktxn_handler()\n+        self.test_compactblocks_not_at_tip()\n+        self.test_incorrect_blocktxn_response()\n+        self.test_invalid_cmpctblock_message()\n+\n+\n+if __name__ == '__main__':\n+    CompactBlocksTest().main()"
      }
    ]
  },
  {
    "sha": "cef633ce63937eea37048fe07da2488fefb4ec7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZWY2MzNjZTYzOTM3ZWVhMzcwNDhmZTA3ZGEyNDg4ZmVmYjRlYzdj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-15T01:00:53Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:49:14Z"
      },
      "message": "Fix broken sendcmpct test in p2p-compactblocks.py\n\nPython lambda use was incorrect.\n\nsendcmpct messages need to be synchronized with RPC calls to generate().\n\nHeaders need to be synced (eg with getheaders) for cmpctblock announcements\nto start.\n\nLast test omitted sending a sendcmpct message.\n\nGithub-Pull: #8739\nRebased-From: 157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2)",
      "tree": {
        "sha": "88a0d4bb8b840091c76693e848661085f17addaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88a0d4bb8b840091c76693e848661085f17addaf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cef633ce63937eea37048fe07da2488fefb4ec7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cef633ce63937eea37048fe07da2488fefb4ec7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cef633ce63937eea37048fe07da2488fefb4ec7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cef633ce63937eea37048fe07da2488fefb4ec7c/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb8706ebd748e8b99e3d08a49da9fdc8e800806b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb8706ebd748e8b99e3d08a49da9fdc8e800806b"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 37,
      "deletions": 21
    },
    "files": [
      {
        "sha": "bf4fb43add3df6bb420e86cc7dcbdf4382d94206",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 37,
        "deletions": 21,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cef633ce63937eea37048fe07da2488fefb4ec7c/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cef633ce63937eea37048fe07da2488fefb4ec7c/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=cef633ce63937eea37048fe07da2488fefb4ec7c",
        "patch": "@@ -78,6 +78,13 @@ def send_header_for_blocks(self, new_blocks):\n         headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n         self.send_message(headers_message)\n \n+    def request_headers_and_sync(self, locator, hashstop=0):\n+        self.clear_block_announcement()\n+        self.get_headers(locator, hashstop)\n+        assert(wait_until(self.received_block_announcement, timeout=30))\n+        assert(self.received_block_announcement())\n+        self.clear_block_announcement()\n+\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -130,7 +137,7 @@ def make_utxos(self):\n     # Test \"sendcmpct\":\n     # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n     #   sendcmpct is sent.\n-    # - If sendcmpct is sent with version > 0, the message is ignored.\n+    # - If sendcmpct is sent with version > 1, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n     # - If sendcmpct is then sent with boolean 1, then new block announcements\n@@ -142,57 +149,66 @@ def test_sendcmpct(self):\n         def received_sendcmpct():\n             return (self.test_node.last_sendcmpct is not None)\n         got_message = wait_until(received_sendcmpct, timeout=30)\n+        assert(received_sendcmpct())\n         assert(got_message)\n         assert_equal(self.test_node.last_sendcmpct.version, 1)\n \n         tip = int(self.nodes[0].getbestblockhash(), 16)\n \n         def check_announcement_of_new_block(node, peer, predicate):\n-            self.test_node.clear_block_announcement()\n+            peer.clear_block_announcement()\n             node.generate(1)\n-            got_message = wait_until(peer.received_block_announcement, timeout=30)\n+            got_message = wait_until(lambda: peer.block_announced, timeout=30)\n+            assert(peer.block_announced)\n             assert(got_message)\n             with mininode_lock:\n-                assert(predicate)\n+                assert(predicate(peer))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n \n         # Try one more time, this time after requesting headers.\n-        self.test_node.clear_block_announcement()\n-        self.test_node.get_headers(locator=[tip], hashstop=0)\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n-        self.test_node.clear_block_announcement()\n+        self.test_node.request_headers_and_sync(locator=[tip])\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n \n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_inv is not None)\n+        # Test a few ways of using sendcmpct that should NOT\n+        # result in compact block announcements.\n+        # Before each test, sync the headers chain.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n         sendcmpct.version = 2\n-        self.test_node.send_message(sendcmpct)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n \n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        # Headers sync before next test.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with valid version, but announce=False\n-        self.test_node.send_message(msg_sendcmpct())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        self.test_node.send_and_ping(msg_sendcmpct())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+\n+        # Headers sync before next test.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Finally, try a SENDCMPCT message with announce=True\n         sendcmpct.version = 1\n         sendcmpct.announce = True\n-        self.test_node.send_message(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n-        # Try one more time\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        # Try one more time (no headers sync should be needed!)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time, after turning on sendheaders\n-        self.test_node.send_message(msg_sendheaders())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        self.test_node.send_and_ping(msg_sendheaders())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Now turn off announcements\n         sendcmpct.announce = False\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_headers is not None)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):"
      }
    ]
  },
  {
    "sha": "9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZGZhMGM4ZDkwMTc3YTEyYzNhM2IxYWM1OWMzMjcyNzA3N2Q2ODAz",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-08-31T11:38:23Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-26T14:50:39Z"
      },
      "message": "Implement NULLDUMMY softfork\n\nGithub-Pull: #8636\nRebased-From: 482f852da65457eb2fbea6b259e7568133fb81c4",
      "tree": {
        "sha": "e66d2eb4787ec93c5fbcd207ccd1b84dfee42688",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e66d2eb4787ec93c5fbcd207ccd1b84dfee42688"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cef633ce63937eea37048fe07da2488fefb4ec7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cef633ce63937eea37048fe07da2488fefb4ec7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cef633ce63937eea37048fe07da2488fefb4ec7c"
      }
    ],
    "stats": {
      "total": 150,
      "additions": 150,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dbd6de5599de4c9d13707d1b86b304a20caeb50a",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
        "patch": "@@ -143,6 +143,7 @@\n     'importprunedfunds.py',\n     'signmessages.py',\n     'p2p-compactblocks.py',\n+    'nulldummy.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "eaed7a8c789705abc779db9a6d86e4b2ed48c8e3",
        "filename": "qa/rpc-tests/nulldummy.py",
        "status": "added",
        "additions": 148,
        "deletions": 0,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/qa/rpc-tests/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/qa/rpc-tests/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/nulldummy.py?ref=9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
        "patch": "@@ -0,0 +1,148 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.comptool import TestManager\n+from test_framework.script import CScript\n+from io import BytesIO\n+import time\n+\n+NULLDUMMY_ERROR = \"64: non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero)\"\n+\n+def trueDummy(tx):\n+    scriptSig = CScript(tx.vin[0].scriptSig)\n+    newscript = []\n+    for i in scriptSig:\n+        if (len(newscript) == 0):\n+            assert(len(i) == 0)\n+            newscript.append(b'\\x51')\n+        else:\n+            newscript.append(i)\n+    tx.vin[0].scriptSig = CScript(newscript)\n+    tx.rehash()\n+\n+'''\n+This test is meant to exercise NULLDUMMY softfork.\n+Connect to a single node.\n+Generate 2 blocks (save the coinbases for later).\n+Generate 427 more blocks.\n+[Policy/Consensus] Check that NULLDUMMY compliant transactions are accepted in the 430th block.\n+[Policy] Check that non-NULLDUMMY transactions are rejected before activation.\n+[Consensus] Check that the new NULLDUMMY rules are not enforced on the 431st block.\n+[Policy/Consensus] Check that the new NULLDUMMY rules are enforced on the 432nd block.\n+'''\n+\n+class NULLDUMMYTest(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-walletprematurewitness']])\n+\n+    def run_test(self):\n+        self.address = self.nodes[0].getnewaddress()\n+        self.ms_address = self.nodes[0].addmultisigaddress(1,[self.address])\n+        self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n+        self.wit_ms_address = self.nodes[0].addwitnessaddress(self.ms_address)\n+\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        self.coinbase_blocks = self.nodes[0].generate(2) # Block 2\n+        coinbase_txid = []\n+        for i in self.coinbase_blocks:\n+            coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n+        self.nodes[0].generate(427) # Block 429\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        self.lastblockheight = 429\n+        self.lastblocktime = int(time.time()) + 429\n+\n+        print (\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n+        test1txs = [self.create_transaction(self.nodes[0], coinbase_txid[0], self.ms_address, 49)]\n+        txid1 = self.tx_submit(self.nodes[0], test1txs[0])\n+        test1txs.append(self.create_transaction(self.nodes[0], txid1, self.ms_address, 48))\n+        txid2 = self.tx_submit(self.nodes[0], test1txs[1])\n+        test1txs.append(self.create_transaction(self.nodes[0], coinbase_txid[1], self.wit_ms_address, 49))\n+        txid3 = self.tx_submit(self.nodes[0], test1txs[2])\n+        self.block_submit(self.nodes[0], test1txs, False, True)\n+\n+        print (\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n+        test2tx = self.create_transaction(self.nodes[0], txid2, self.ms_address, 48)\n+        trueDummy(test2tx)\n+        txid4 = self.tx_submit(self.nodes[0], test2tx, NULLDUMMY_ERROR)\n+\n+        print (\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n+        self.block_submit(self.nodes[0], [test2tx], False, True)\n+\n+        print (\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n+        test4tx = self.create_transaction(self.nodes[0], txid4, self.address, 47)\n+        test6txs=[CTransaction(test4tx)]\n+        trueDummy(test4tx)\n+        self.tx_submit(self.nodes[0], test4tx, NULLDUMMY_ERROR)\n+        self.block_submit(self.nodes[0], [test4tx])\n+\n+        print (\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n+        test5tx = self.create_transaction(self.nodes[0], txid3, self.wit_address, 48)\n+        test6txs.append(CTransaction(test5tx))\n+        test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n+        self.tx_submit(self.nodes[0], test5tx, NULLDUMMY_ERROR)\n+        self.block_submit(self.nodes[0], [test5tx], True)\n+\n+        print (\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n+        for i in test6txs:\n+            self.tx_submit(self.nodes[0], i)\n+        self.block_submit(self.nodes[0], test6txs, True, True)\n+\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+\n+    def tx_submit(self, node, tx, msg = \"\"):\n+        tx.rehash()\n+        try:\n+            node.sendrawtransaction(bytes_to_hex_str(tx.serialize_with_witness()), True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], msg)\n+        return tx.hash\n+\n+\n+    def block_submit(self, node, txs, witness = False, accept = False):\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(bytes_to_hex_str(block.serialize(True)))\n+        if (accept):\n+            assert_equal(node.getbestblockhash(), block.hash)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert_equal(node.getbestblockhash(), self.lastblockhash)\n+\n+if __name__ == '__main__':\n+    NULLDUMMYTest().main()\n\\ No newline at end of file"
      },
      {
        "sha": "c9869d04f999dab7d7136f20d42fcb3ce0d98a5f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9dfa0c8d90177a12c3a3b1ac59c32727077d6803/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9dfa0c8d90177a12c3a3b1ac59c32727077d6803",
        "patch": "@@ -2399,6 +2399,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     // Start enforcing WITNESS rules using versionbits logic.\n     if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {\n         flags |= SCRIPT_VERIFY_WITNESS;\n+        flags |= SCRIPT_VERIFY_NULLDUMMY;\n     }\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;"
      }
    ]
  }
]