[
  {
    "sha": "82fc1bc05c4675b4e1716209c063b9c2cec8a438",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MmZjMWJjMDVjNDY3NWI0ZTE3MTYyMDljMDYzYjljMmNlYzhhNDM4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-27T13:42:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Add p2p connection to TestNode\n\np2p connections can now be added to TestNode instances.",
      "tree": {
        "sha": "de5a675fae7e5d1450f088cf9755114d783e2241",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de5a675fae7e5d1450f088cf9755114d783e2241"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82fc1bc05c4675b4e1716209c063b9c2cec8a438",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82fc1bc05c4675b4e1716209c063b9c2cec8a438",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/82fc1bc05c4675b4e1716209c063b9c2cec8a438",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82fc1bc05c4675b4e1716209c063b9c2cec8a438/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26fee4f6bd9aec62c6caa60683ad66574cf16aa6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26fee4f6bd9aec62c6caa60683ad66574cf16aa6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26fee4f6bd9aec62c6caa60683ad66574cf16aa6"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 59,
      "deletions": 20
    },
    "files": [
      {
        "sha": "71513ccdc6372d1b685b99dd3567328390721895",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 8,
        "deletions": 15,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82fc1bc05c4675b4e1716209c063b9c2cec8a438/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82fc1bc05c4675b4e1716209c063b9c2cec8a438/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=82fc1bc05c4675b4e1716209c063b9c2cec8a438",
        "patch": "@@ -18,7 +18,6 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConn,\n     NodeConnCB,\n     mininode_lock,\n     msg_block,\n@@ -28,7 +27,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    p2p_port,\n     wait_until,\n )\n \n@@ -134,16 +132,13 @@ def run_test(self):\n         \"\"\"Main test logic\"\"\"\n \n         # Create a P2P connection to one of the nodes\n-        node0 = BaseNode()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=BaseNode)\n \n         # Start up network handling in another thread. This needs to be called\n         # after the P2P connections have been created.\n         NetworkThread().start()\n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Generating a block on one of the nodes will get us out of IBD\n         blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n@@ -180,7 +175,7 @@ def run_test(self):\n             block.solve()\n             block_message = msg_block(block)\n             # Send message is used to send a P2P message to the node over our NodeConn connection\n-            node0.send_message(block_message)\n+            self.nodes[0].send_message(block_message)\n             self.tip = block.sha256\n             blocks.append(self.tip)\n             self.block_time += 1\n@@ -193,28 +188,26 @@ def run_test(self):\n         connect_nodes(self.nodes[1], 2)\n \n         self.log.info(\"Add P2P connection to node2\")\n-        node2 = BaseNode()\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n-        node2.add_connection(connections[1])\n-        node2.wait_for_verack()\n+        self.nodes[2].add_p2p_connection(p2p_conn_type=BaseNode)\n+        self.nodes[2].p2p.wait_for_verack()\n \n         self.log.info(\"Wait for node2 reach current tip. Test that it has propagated all the blocks to us\")\n \n         getdata_request = msg_getdata()\n         for block in blocks:\n             getdata_request.inv.append(CInv(2, block))\n-        node2.send_message(getdata_request)\n+        self.nodes[2].send_message(getdata_request)\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # NodeConnCB objects.\n-        wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+        wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving\n         # messages. The test thread should acquire the global lock before accessing any NodeConn data to avoid locking\n         # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n         with mininode_lock:\n-            for block in node2.block_receive_map.values():\n+            for block in self.nodes[2].p2p.block_receive_map.values():\n                 assert_equal(block, 1)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "296ec27dde8d9a2bfea33587e6b358286bb098a0",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 51,
        "deletions": 5,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82fc1bc05c4675b4e1716209c063b9c2cec8a438/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82fc1bc05c4675b4e1716209c063b9c2cec8a438/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=82fc1bc05c4675b4e1716209c063b9c2cec8a438",
        "patch": "@@ -13,13 +13,19 @@\n import subprocess\n import time\n \n+from .authproxy import JSONRPCException\n+from .mininode import (\n+    NodeConn,\n+    NodeConnCB,\n+    NODE_NETWORK,\n+)\n from .util import (\n     assert_equal,\n     get_rpc_proxy,\n     rpc_url,\n     wait_until,\n+    p2p_port,\n )\n-from .authproxy import JSONRPCException\n \n BITCOIND_PROC_WAIT_TIMEOUT = 60\n \n@@ -31,9 +37,13 @@ class TestNode():\n     - state about the node (whether it's running, etc)\n     - a Python subprocess.Popen object representing the running process\n     - an RPC connection to the node\n+    - one or more P2P connections to the node\n \n-    To make things easier for the test writer, a bit of magic is happening under the covers.\n-    Any unrecognised messages will be dispatched to the RPC connection.\"\"\"\n+\n+    To make things easier for the test writer, this class will try to dispatch\n+    messages over the correct interface:\n+    - send_message is dispatched to the first P2P connection.\n+    - Any unrecognised messages will be dispatched to the RPC connection.\"\"\"\n \n     def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mocktime, coverage_dir):\n         self.index = i\n@@ -63,10 +73,12 @@ def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mo\n         self.url = None\n         self.log = logging.getLogger('TestFramework.node%d' % i)\n \n-    def __getattr__(self, *args, **kwargs):\n+        self.p2ps = []\n+\n+    def __getattr__(self, name):\n         \"\"\"Dispatches any unrecognised messages to the RPC connection.\"\"\"\n         assert self.rpc_connected and self.rpc is not None, \"Error: no RPC connection\"\n-        return self.rpc.__getattr__(*args, **kwargs)\n+        return self.rpc.__getattr__(name)\n \n     def start(self, extra_args=None, stderr=None):\n         \"\"\"Start the node.\"\"\"\n@@ -119,6 +131,7 @@ def stop_node(self):\n             self.stop()\n         except http.client.CannotSendRequest:\n             self.log.exception(\"Unable to stop node.\")\n+        self.p2ps = []\n \n     def is_node_stopped(self):\n         \"\"\"Checks whether the node has stopped.\n@@ -151,6 +164,39 @@ def node_encrypt_wallet(self, passphrase):\n         self.encryptwallet(passphrase)\n         self.wait_until_stopped()\n \n+    def add_p2p_connection(self, p2p_conn_type, dstaddr='127.0.0.1', dstport=None, services=NODE_NETWORK, send_version=True):\n+        \"\"\"Add a p2p connection to the node.\n+\n+        This method adds the p2p connection to the self.p2ps list and also\n+        returns the connection to the caller.\"\"\"\n+        if dstport is None:\n+            dstport = p2p_port(self.index)\n+        p2p_conn = p2p_conn_type()\n+        self.p2ps.append(p2p_conn)\n+        p2p_conn.add_connection(NodeConn(dstaddr, dstport, self.rpc, p2p_conn, services=services, send_version=send_version))\n+\n+        return p2p_conn\n+\n+    @property\n+    def p2p(self):\n+        \"\"\"Return the first p2p connection\n+\n+        Convenience property - most tests only use a single p2p connection to each\n+        node, so this saves having to write node.p2ps[0] many times.\"\"\"\n+        assert self.p2ps, \"No p2p connection\"\n+        return self.p2ps[0]\n+\n+    def send_message(self, message):\n+        \"\"\"Send a p2p message to the node.\"\"\"\n+        assert self.p2ps != [], \"No p2p connection\"\n+        self.p2ps[0].send_message(message)\n+\n+    def disconnect_p2p(self, index=0):\n+        \"\"\"Close the p2p connection to the node.\"\"\"\n+        if self.p2ps[index].connection is not None:\n+            self.p2ps[index].connection.disconnect_node()\n+        self.p2ps.pop(index)\n+\n class TestNodeCLI():\n     \"\"\"Interface to bitcoin-cli for an individual node\"\"\"\n "
      }
    ]
  },
  {
    "sha": "b1ae3961b361cdf943e212dab65c0a096c6bc435",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMWFlMzk2MWIzNjFjZGY5NDNlMjEyZGFiNjVjMGEwOTZjNmJjNDM1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-08-24T19:36:02Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] use TestNode p2p connection in tests",
      "tree": {
        "sha": "0486c4c29909ca0bac4787c058073f8febe9b511",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0486c4c29909ca0bac4787c058073f8febe9b511"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1ae3961b361cdf943e212dab65c0a096c6bc435",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1ae3961b361cdf943e212dab65c0a096c6bc435",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b1ae3961b361cdf943e212dab65c0a096c6bc435",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1ae3961b361cdf943e212dab65c0a096c6bc435/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82fc1bc05c4675b4e1716209c063b9c2cec8a438",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82fc1bc05c4675b4e1716209c063b9c2cec8a438",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82fc1bc05c4675b4e1716209c063b9c2cec8a438"
      }
    ],
    "stats": {
      "total": 391,
      "additions": 155,
      "deletions": 236
    },
    "files": [
      {
        "sha": "59d2a3ba0c00ea75eab250e57655ae78febffe66",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 19,
        "deletions": 27,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -39,13 +39,12 @@\n                                      CTxIn,\n                                      CTxOut,\n                                      NetworkThread,\n-                                     NodeConn,\n                                      NodeConnCB,\n                                      msg_block,\n                                      msg_headers)\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (p2p_port, assert_equal)\n+from test_framework.util import assert_equal\n \n class BaseNode(NodeConnCB):\n     def send_header_for_blocks(self, new_blocks):\n@@ -65,13 +64,13 @@ def setup_network(self):\n         # signature so we can pass in the block hash as assumevalid.\n         self.start_node(0)\n \n-    def send_blocks_until_disconnected(self, node):\n+    def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if not node.connection:\n+            if not p2p_conn.connection:\n                 break\n             try:\n-                node.send_message(msg_block(self.blocks[i]))\n+                p2p_conn.send_message(msg_block(self.blocks[i]))\n             except IOError as e:\n                 assert str(e) == 'Not connected, no pushbuf'\n                 break\n@@ -97,13 +96,10 @@ def assert_blockchain_height(self, node, height):\n     def run_test(self):\n \n         # Connect to node0\n-        node0 = BaseNode()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        p2p0 = self.nodes[0].add_p2p_connection(p2p_conn_type=BaseNode)\n \n         NetworkThread().start()  # Start up network handling in another thread\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Build the blockchain\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n@@ -165,37 +161,33 @@ def run_test(self):\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.start_node(1, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n-        node1 = BaseNode()  # connects to node1\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], node1))\n-        node1.add_connection(connections[1])\n-        node1.wait_for_verack()\n+        p2p1 = self.nodes[1].add_p2p_connection(p2p_conn_type=BaseNode)\n+        p2p1.wait_for_verack()\n \n         self.start_node(2, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n-        node2 = BaseNode()  # connects to node2\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n-        node2.add_connection(connections[2])\n-        node2.wait_for_verack()\n+        p2p2 =self.nodes[2].add_p2p_connection(p2p_conn_type=BaseNode)\n+        p2p2.wait_for_verack()\n \n         # send header lists to all three nodes\n-        node0.send_header_for_blocks(self.blocks[0:2000])\n-        node0.send_header_for_blocks(self.blocks[2000:])\n-        node1.send_header_for_blocks(self.blocks[0:2000])\n-        node1.send_header_for_blocks(self.blocks[2000:])\n-        node2.send_header_for_blocks(self.blocks[0:200])\n+        p2p0.send_header_for_blocks(self.blocks[0:2000])\n+        p2p0.send_header_for_blocks(self.blocks[2000:])\n+        p2p1.send_header_for_blocks(self.blocks[0:2000])\n+        p2p1.send_header_for_blocks(self.blocks[2000:])\n+        p2p2.send_header_for_blocks(self.blocks[0:200])\n \n         # Send blocks to node0. Block 102 will be rejected.\n-        self.send_blocks_until_disconnected(node0)\n+        self.send_blocks_until_disconnected(p2p0)\n         self.assert_blockchain_height(self.nodes[0], 101)\n \n         # Send all blocks to node1. All blocks will be accepted.\n         for i in range(2202):\n-            node1.send_message(msg_block(self.blocks[i]))\n+            p2p1.send_message(msg_block(self.blocks[i]))\n         # Syncing 2200 blocks can take a while on slow systems. Give it plenty of time to sync.\n-        node1.sync_with_ping(120)\n+        p2p1.sync_with_ping(120)\n         assert_equal(self.nodes[1].getblock(self.nodes[1].getbestblockhash())['height'], 2202)\n \n         # Send blocks to node2. Block 102 will be rejected.\n-        self.send_blocks_until_disconnected(node2)\n+        self.send_blocks_until_disconnected(p2p2)\n         self.assert_blockchain_height(self.nodes[2], 101)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "97ec324cf58a52cd1d437a4f25a44251494f4c27",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 18,
        "deletions": 21,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -66,15 +66,12 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        node0 = NodeConnCB()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)\n         self.coinbase_blocks = self.nodes[0].generate(CLTV_HEIGHT - 2)\n@@ -95,7 +92,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 4\")\n@@ -104,15 +101,15 @@ def run_test(self):\n         block = create_block(tip, create_coinbase(CLTV_HEIGHT), block_time)\n         block.nVersion = 3\n         block.solve()\n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            del node0.last_message[\"reject\"]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            del self.nodes[0].p2p.last_message[\"reject\"]\n \n         self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n@@ -125,26 +122,26 @@ def run_test(self):\n         # First we show that this tx is valid except for CLTV by getting it\n         # accepted to the mempool (which we can achieve with\n         # -promiscuousmempoolflags).\n-        node0.send_and_ping(msg_tx(spendtx))\n+        self.nodes[0].p2p.send_and_ping(msg_tx(spendtx))\n         assert spendtx.hash in self.nodes[0].getrawmempool()\n \n         # Now we verify that a block with this transaction is invalid.\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n                 # Generic rejection when a block is invalid\n-                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n             else:\n-                assert b'Negative locktime' in node0.last_message[\"reject\"].reason\n+                assert b'Negative locktime' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)\n@@ -155,7 +152,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n \n "
      },
      {
        "sha": "ec556dcb707f4bf218c59591f018ebaf1ade80a9",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -54,14 +54,12 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        node0 = NodeConnCB()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+\n         NetworkThread().start() # Start up network handling in another thread\n \n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", DERSIG_HEIGHT - 2)\n         self.coinbase_blocks = self.nodes[0].generate(DERSIG_HEIGHT - 2)\n@@ -83,7 +81,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 3\")\n@@ -93,15 +91,15 @@ def run_test(self):\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            del node0.last_message[\"reject\"]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            del self.nodes[0].p2p.last_message[\"reject\"]\n \n         self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n@@ -114,7 +112,7 @@ def run_test(self):\n         # First we show that this tx is valid except for DERSIG by getting it\n         # accepted to the mempool (which we can achieve with\n         # -promiscuousmempoolflags).\n-        node0.send_and_ping(msg_tx(spendtx))\n+        self.nodes[0].p2p.send_and_ping(msg_tx(spendtx))\n         assert spendtx.hash in self.nodes[0].getrawmempool()\n \n         # Now we verify that a block with this transaction is invalid.\n@@ -123,23 +121,23 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             # We can receive different reject messages depending on whether\n             # bitcoind is running with multiple script check threads. If script\n             # check threads are not in use, then transaction script validation\n             # happens sequentially, and bitcoind produces more specific reject\n             # reasons.\n-            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n                 # Generic rejection when a block is invalid\n-                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n             else:\n-                assert b'Non-canonical DER signature' in node0.last_message[\"reject\"].reason\n+                assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n         block.vtx[1] = create_transaction(self.nodes[0],\n@@ -148,7 +146,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "e6ff42f838687a26718e1674974ff08ae8b09687",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 34,
        "deletions": 37,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -49,19 +49,17 @@ def run_test(self):\n         # Generate some old blocks\n         self.nodes[0].generate(130)\n \n-        # test_nodes[0] will only request old blocks\n-        # test_nodes[1] will only request new blocks\n-        # test_nodes[2] will test resetting the counters\n-        test_nodes = []\n-        connections = []\n+        # p2p_conns[0] will only request old blocks\n+        # p2p_conns[1] will only request new blocks\n+        # p2p_conns[2] will test resetting the counters\n+        p2p_conns = []\n \n         for i in range(3):\n-            test_nodes.append(TestNode())\n-            connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[i]))\n-            test_nodes[i].add_connection(connections[i])\n+            p2p_conns.append(self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode))\n \n         NetworkThread().start() # Start up network handling in another thread\n-        [x.wait_for_verack() for x in test_nodes]\n+        for p2pc in p2p_conns:\n+            p2pc.wait_for_verack()\n \n         # Test logic begins here\n \n@@ -83,7 +81,7 @@ def run_test(self):\n         big_new_block = self.nodes[0].getbestblockhash()\n         big_new_block = int(big_new_block, 16)\n \n-        # test_nodes[0] will test what happens if we just keep requesting the\n+        # p2p_conns[0] will test what happens if we just keep requesting the\n         # the same big old block too many times (expect: disconnect)\n \n         getdata_request = msg_getdata()\n@@ -97,74 +95,73 @@ def run_test(self):\n         # 576MB will be reserved for relaying new blocks, so expect this to\n         # succeed for ~235 tries.\n         for i in range(success_count):\n-            test_nodes[0].send_message(getdata_request)\n-            test_nodes[0].sync_with_ping()\n-            assert_equal(test_nodes[0].block_receive_map[big_old_block], i+1)\n+            p2p_conns[0].send_message(getdata_request)\n+            p2p_conns[0].sync_with_ping()\n+            assert_equal(p2p_conns[0].block_receive_map[big_old_block], i+1)\n \n         assert_equal(len(self.nodes[0].getpeerinfo()), 3)\n         # At most a couple more tries should succeed (depending on how long \n         # the test has been running so far).\n         for i in range(3):\n-            test_nodes[0].send_message(getdata_request)\n-        test_nodes[0].wait_for_disconnect()\n+            p2p_conns[0].send_message(getdata_request)\n+        p2p_conns[0].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n         self.log.info(\"Peer 0 disconnected after downloading old block too many times\")\n \n-        # Requesting the current block on test_nodes[1] should succeed indefinitely,\n+        # Requesting the current block on p2p_conns[1] should succeed indefinitely,\n         # even when over the max upload target.\n         # We'll try 800 times\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(800):\n-            test_nodes[1].send_message(getdata_request)\n-            test_nodes[1].sync_with_ping()\n-            assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n+            p2p_conns[1].send_message(getdata_request)\n+            p2p_conns[1].sync_with_ping()\n+            assert_equal(p2p_conns[1].block_receive_map[big_new_block], i+1)\n \n         self.log.info(\"Peer 1 able to repeatedly download new block\")\n \n-        # But if test_nodes[1] tries for an old block, it gets disconnected too.\n+        # But if p2p_conns[1] tries for an old block, it gets disconnected too.\n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[1].send_message(getdata_request)\n-        test_nodes[1].wait_for_disconnect()\n+        p2p_conns[1].send_message(getdata_request)\n+        p2p_conns[1].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 1)\n \n         self.log.info(\"Peer 1 disconnected after trying to download old block\")\n \n         self.log.info(\"Advancing system time on node to clear counters...\")\n \n         # If we advance the time by 24 hours, then the counters should reset,\n-        # and test_nodes[2] should be able to retrieve the old block.\n+        # and p2p_conns[2] should be able to retrieve the old block.\n         self.nodes[0].setmocktime(int(time.time()))\n-        test_nodes[2].sync_with_ping()\n-        test_nodes[2].send_message(getdata_request)\n-        test_nodes[2].sync_with_ping()\n-        assert_equal(test_nodes[2].block_receive_map[big_old_block], 1)\n+        p2p_conns[2].sync_with_ping()\n+        p2p_conns[2].send_message(getdata_request)\n+        p2p_conns[2].sync_with_ping()\n+        assert_equal(p2p_conns[2].block_receive_map[big_old_block], 1)\n \n         self.log.info(\"Peer 2 able to download old block\")\n \n-        [c.disconnect_node() for c in connections]\n+        for i in range(3):\n+            self.nodes[0].disconnect_p2p()\n \n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n         self.log.info(\"Restarting nodes with -whitelist=127.0.0.1\")\n         self.stop_node(0)\n         self.start_node(0, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n-        #recreate/reconnect a test node\n-        test_nodes = [TestNode()]\n-        connections = [NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[0])]\n-        test_nodes[0].add_connection(connections[0])\n+        # Reconnect to self.nodes[0]\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n \n         NetworkThread().start() # Start up network handling in another thread\n-        test_nodes[0].wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(20):\n-            test_nodes[0].send_message(getdata_request)\n-            test_nodes[0].sync_with_ping()\n-            assert_equal(test_nodes[0].block_receive_map[big_new_block], i+1)\n+            self.nodes[0].send_message(getdata_request)\n+            self.nodes[0].p2p.sync_with_ping()\n+            assert_equal(self.nodes[0].p2p.block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[0].send_and_ping(getdata_request)\n+        self.nodes[0].p2p.send_and_ping(getdata_request)\n         assert_equal(len(self.nodes[0].getpeerinfo()), 1) #node is still connected because of the whitelist\n \n         self.log.info(\"Peer still connected after trying to download old block (whitelisted)\")"
      },
      {
        "sha": "55b0576b3270c53cd45ee8b85a6ccf71890b434b",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -73,18 +73,13 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n-        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n-        test_node.add_connection(connections[0])\n-        white_node.add_connection(connections[1])\n+        # test_node connects to node0 (not whitelisted)\n+        test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        # test_node connects to node1 (whitelisted)\n+        white_node = self.nodes[1].add_p2p_connection(p2p_conn_type=NodeConnCB)\n \n         NetworkThread().start() # Start up network handling in another thread\n \n-        # Test logic begins here\n         test_node.wait_for_verack()\n         white_node.wait_for_verack()\n \n@@ -217,7 +212,5 @@ def run_test(self):\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        [ c.disconnect_node() for c in connections ]\n-\n if __name__ == '__main__':\n     AcceptBlockTest().main()"
      },
      {
        "sha": "7cddc275b763573f40668cb4660cb1a69a98e7fd",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 3,
        "deletions": 14,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -786,23 +786,12 @@ def announce_cmpct_block(node, peer):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.test_node = TestNode()\n-        self.segwit_node = TestNode()\n-        self.old_node = TestNode()  # version 1 peer <--> segwit node\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n-                    self.segwit_node, services=NODE_NETWORK|NODE_WITNESS))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n-                    self.old_node, services=NODE_NETWORK))\n-        self.test_node.add_connection(connections[0])\n-        self.segwit_node.add_connection(connections[1])\n-        self.old_node.add_connection(connections[2])\n+        self.test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n+        self.segwit_node = self.nodes[1].add_p2p_connection(p2p_conn_type=TestNode, services=NODE_NETWORK|NODE_WITNESS)\n+        self.old_node = self.nodes[1].add_p2p_connection(p2p_conn_type=TestNode, services=NODE_NETWORK)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n-        # Test logic begins here\n         self.test_node.wait_for_verack()\n \n         # We will need UTXOs to construct transactions in later tests."
      },
      {
        "sha": "2c552f5955acad5ae21cce486e14b19dfdddc982",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -48,25 +48,23 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # Setup the p2p connections and start up the network thread.\n-        test_node = TestNode()\n-        connection = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n-        test_node.add_connection(connection)\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n         NetworkThread().start()\n-        test_node.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Test that invs are received for all txs at feerate of 20 sat/byte\n         node1.settxfee(Decimal(\"0.00020000\"))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Set a filter of 15 sat/byte\n-        test_node.send_and_ping(msg_feefilter(15000))\n+        self.nodes[0].p2p.send_and_ping(msg_feefilter(15000))\n \n         # Test that txs are still being received (paying 20 sat/byte)\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Change tx fee rate to 10 sat/byte and test they are no longer received\n         node1.settxfee(Decimal(\"0.00010000\"))\n@@ -82,14 +80,14 @@ def run_test(self):\n         # as well.\n         node0.settxfee(Decimal(\"0.00020000\"))\n         txids = [node0.sendtoaddress(node0.getnewaddress(), 1)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n-        test_node.send_and_ping(msg_feefilter(0))\n+        self.nodes[0].p2p.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n if __name__ == '__main__':\n     FeeFilterTest().main()"
      },
      {
        "sha": "e4319d3b1e4d86e544b2b6a5825a165ab23720f3",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 10,
        "deletions": 25,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -97,24 +97,13 @@ def set_test_params(self):\n         self.extra_args = [['-banscore='+str(banscore)]]\n \n     def run_test(self):\n-        no_version_bannode = CNodeNoVersionBan()\n-        no_version_idlenode = CNodeNoVersionIdle()\n-        no_verack_idlenode = CNodeNoVerackIdle()\n-        unsupported_service_bit5_node = CLazyNode()\n-        unsupported_service_bit7_node = CLazyNode()\n-\n         self.nodes[0].setmocktime(1501545600)  # August 1st 2017\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_bannode, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_idlenode, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_verack_idlenode))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], unsupported_service_bit5_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], unsupported_service_bit7_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7))\n-        no_version_bannode.add_connection(connections[0])\n-        no_version_idlenode.add_connection(connections[1])\n-        no_verack_idlenode.add_connection(connections[2])\n-        unsupported_service_bit5_node.add_connection(connections[3])\n-        unsupported_service_bit7_node.add_connection(connections[4])\n+\n+        no_version_bannode = self.nodes[0].add_p2p_connection(p2p_conn_type=CNodeNoVersionBan, send_version=False)\n+        no_version_idlenode = self.nodes[0].add_p2p_connection(p2p_conn_type=CNodeNoVersionIdle, send_version=False)\n+        no_verack_idlenode = self.nodes[0].add_p2p_connection(p2p_conn_type=CNodeNoVerackIdle)\n+        unsupported_service_bit5_node = self.nodes[0].add_p2p_connection(p2p_conn_type=CLazyNode, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n+        unsupported_service_bit7_node = self.nodes[0].add_p2p_connection(p2p_conn_type=CLazyNode, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n@@ -137,7 +126,8 @@ def run_test(self):\n         assert not unsupported_service_bit5_node.connected\n         assert not unsupported_service_bit7_node.connected\n \n-        [conn.disconnect_node() for conn in connections]\n+        for _ in range(5):\n+            self.nodes[0].disconnect_p2p()\n \n         # Wait until all connections are closed\n         wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n@@ -152,13 +142,8 @@ def run_test(self):\n         self.log.info(\"Service bits 5 and 7 are allowed after August 1st 2018\")\n         self.nodes[0].setmocktime(1533168000)  # August 2nd 2018\n \n-        allowed_service_bit5_node = NodeConnCB()\n-        allowed_service_bit7_node = NodeConnCB()\n-\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], allowed_service_bit5_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], allowed_service_bit7_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7))\n-        allowed_service_bit5_node.add_connection(connections[5])\n-        allowed_service_bit7_node.add_connection(connections[6])\n+        allowed_service_bit5_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n+        allowed_service_bit7_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n         NetworkThread().start()  # Network thread stopped when all previous NodeConnCBs disconnected. Restart it\n "
      },
      {
        "sha": "4b7bc9de9cb3f59ea5f1e6fcc82e568114b17e2b",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -19,16 +19,14 @@ def set_test_params(self):\n         self.extra_args = [[\"-peerbloomfilters=0\"]]\n \n     def run_test(self):\n-        #connect a mininode\n-        aTestNode = NodeConnCB()\n-        node = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], aTestNode)\n-        aTestNode.add_connection(node)\n+        # Add a p2p connection\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n         NetworkThread().start()\n-        aTestNode.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         #request mempool\n-        aTestNode.send_message(msg_mempool())\n-        aTestNode.wait_for_disconnect()\n+        self.nodes[0].p2p.send_message(msg_mempool())\n+        self.nodes[0].p2p.wait_for_disconnect()\n \n         #mininode must be disconnected at this point\n         assert_equal(len(self.nodes[0].getpeerinfo()), 0)"
      },
      {
        "sha": "1050b150a91f44aa2b1c577155dff0ef7d0e96df",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -1867,19 +1867,12 @@ def test_non_standard_witness(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.test_node = TestNode() # sets NODE_WITNESS|NODE_NETWORK\n-        self.old_node = TestNode()  # only NODE_NETWORK\n-        self.std_node = TestNode() # for testing node1 (fRequireStandard=true)\n-\n-        self.p2p_connections = [self.test_node, self.old_node]\n-\n-        self.connections = []\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=NODE_NETWORK|NODE_WITNESS))\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.old_node, services=NODE_NETWORK))\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], self.std_node, services=NODE_NETWORK|NODE_WITNESS))\n-        self.test_node.add_connection(self.connections[0])\n-        self.old_node.add_connection(self.connections[1])\n-        self.std_node.add_connection(self.connections[2])\n+        # self.test_node sets NODE_WITNESS|NODE_NETWORK\n+        self.test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode, services=NODE_NETWORK|NODE_WITNESS)\n+        # self.old_node sets only NODE_NETWORK\n+        self.old_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode, services=NODE_NETWORK)\n+        # self.std_node is for testing node1 (fRequireStandard=true)\n+        self.std_node = self.nodes[1].add_p2p_connection(p2p_conn_type=TestNode, services=NODE_NETWORK|NODE_WITNESS)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "20ac69f426c5f54abfefc025bc6a0ea9a0ae4681",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 17,
        "deletions": 26,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -39,46 +39,37 @@ def set_test_params(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.no_verack_node = TestNode() # never send verack\n-        self.no_version_node = TestNode() # never send version (just ping)\n-        self.no_send_node = TestNode() # never send anything\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_verack_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_version_node, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_send_node, send_version=False))\n-        self.no_verack_node.add_connection(connections[0])\n-        self.no_version_node.add_connection(connections[1])\n-        self.no_send_node.add_connection(connections[2])\n+        no_verack_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n+        no_version_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode, send_version=False)\n+        no_send_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode, send_version=False)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n         sleep(1)\n \n-        assert(self.no_verack_node.connected)\n-        assert(self.no_version_node.connected)\n-        assert(self.no_send_node.connected)\n+        assert no_verack_node.connected\n+        assert no_version_node.connected\n+        assert no_send_node.connected\n \n-        ping_msg = msg_ping()\n-        connections[0].send_message(ping_msg)\n-        connections[1].send_message(ping_msg)\n+        no_verack_node.send_message(msg_ping())\n+        no_version_node.send_message(msg_ping())\n \n         sleep(30)\n \n-        assert \"version\" in self.no_verack_node.last_message\n+        assert \"version\" in no_verack_node.last_message\n \n-        assert(self.no_verack_node.connected)\n-        assert(self.no_version_node.connected)\n-        assert(self.no_send_node.connected)\n+        assert no_verack_node.connected\n+        assert no_version_node.connected\n+        assert no_send_node.connected\n \n-        connections[0].send_message(ping_msg)\n-        connections[1].send_message(ping_msg)\n+        no_verack_node.send_message(msg_ping())\n+        no_version_node.send_message(msg_ping())\n \n         sleep(31)\n \n-        assert(not self.no_verack_node.connected)\n-        assert(not self.no_version_node.connected)\n-        assert(not self.no_send_node.connected)\n+        assert not no_verack_node.connected\n+        assert not no_version_node.connected\n+        assert not no_send_node.connected\n \n if __name__ == '__main__':\n     TimeoutsTest().main()"
      },
      {
        "sha": "8b6878d09910e0e86a9b0c0b4112f691fd20662f",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -64,24 +64,20 @@ def test_versionbits_in_alert_file(self):\n \n     def run_test(self):\n         # Setup the p2p connection and start up the network thread.\n-        test_node = TestNode()\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        test_node.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n-        test_node.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # 1. Have the node mine one period worth of blocks\n         self.nodes[0].generate(VB_PERIOD)\n \n         # 2. Now build one period of blocks on the tip, with < VB_THRESHOLD\n         # blocks signaling some unknown bit.\n         nVersion = VB_TOP_BITS | (1<<VB_UNKNOWN_BIT)\n-        self.send_blocks_with_version(test_node, VB_THRESHOLD-1, nVersion)\n+        self.send_blocks_with_version(self.nodes[0].p2p, VB_THRESHOLD-1, nVersion)\n \n         # Fill rest of period with regular version blocks\n         self.nodes[0].generate(VB_PERIOD - VB_THRESHOLD + 1)\n@@ -92,7 +88,7 @@ def run_test(self):\n \n         # 3. Now build one period of blocks with >= VB_THRESHOLD blocks signaling\n         # some unknown bit\n-        self.send_blocks_with_version(test_node, VB_THRESHOLD, nVersion)\n+        self.send_blocks_with_version(self.nodes[0].p2p, VB_THRESHOLD, nVersion)\n         self.nodes[0].generate(VB_PERIOD - VB_THRESHOLD)\n         # Might not get a versionbits-related alert yet, as we should\n         # have gotten a different alert due to more than 51/100 blocks"
      },
      {
        "sha": "59a0ba62266cc69f1e829eb53922da6330e988c4",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1ae3961b361cdf943e212dab65c0a096c6bc435/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "patch": "@@ -181,7 +181,7 @@ def set_test_params(self):\n     # mine count blocks and return the new tip\n     def mine_blocks(self, count):\n         # Clear out last block announcement from each p2p listener\n-        [ x.clear_last_announcement() for x in self.p2p_connections ]\n+        [x.clear_last_announcement() for x in self.nodes[0].p2ps]\n         self.nodes[0].generate(count)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n@@ -193,7 +193,7 @@ def mine_blocks(self, count):\n     def mine_reorg(self, length):\n         self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n         sync_blocks(self.nodes, wait=0.1)\n-        for x in self.p2p_connections:\n+        for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n             x.clear_last_announcement()\n \n@@ -206,18 +206,10 @@ def mine_reorg(self, length):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        inv_node = TestNode()\n-        test_node = TestNode()\n-\n-        self.p2p_connections = [inv_node, test_node]\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        inv_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode)\n         # Set nServices to 0 for test_node, so no block download will occur outside of\n         # direct fetching\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node, services=0))\n-        inv_node.add_connection(connections[0])\n-        test_node.add_connection(connections[1])\n+        test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=TestNode, services=0)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      }
    ]
  },
  {
    "sha": "64d947b82df924c101f0fd00f4891177a2d0ed44",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGQ5NDdiODJkZjkyNGMxMDFmMGZkMDBmNDg5MTE3N2EyZDBlZDQ0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T02:25:15Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Move test_framework Bitcoin primitives into separate module\n\nmininode.py wildcard imports all names from primitives.py. This is\nto avoid having to change all test scripts that import from mininode.py.",
      "tree": {
        "sha": "a7d1aa469a6384a2b4cc667450605f42ba541131",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a7d1aa469a6384a2b4cc667450605f42ba541131"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64d947b82df924c101f0fd00f4891177a2d0ed44",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64d947b82df924c101f0fd00f4891177a2d0ed44",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64d947b82df924c101f0fd00f4891177a2d0ed44",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64d947b82df924c101f0fd00f4891177a2d0ed44/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1ae3961b361cdf943e212dab65c0a096c6bc435",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b1ae3961b361cdf943e212dab65c0a096c6bc435"
      }
    ],
    "stats": {
      "total": 2839,
      "additions": 1424,
      "deletions": 1415
    },
    "files": [
      {
        "sha": "6e07157195ee24bdba421faa08864fe04b2f6448",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1415,
        "changes": 1415,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64d947b82df924c101f0fd00f4891177a2d0ed44/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64d947b82df924c101f0fd00f4891177a2d0ed44/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=64d947b82df924c101f0fd00f4891177a2d0ed44",
        "patch": "@@ -12,47 +12,17 @@\n NodeConn: an object which manages p2p connectivity to a bitcoin node\n NodeConnCB: a base class that describes the interface for receiving\n             callbacks with network messages from a NodeConn\n-CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n-    data structures that should map to corresponding structures in\n-    bitcoin/primitives\n-msg_block, msg_tx, msg_headers, etc.:\n-    data structures that represent network messages\n-ser_*, deser_*: functions that handle serialization/deserialization\n \"\"\"\n-\n import asyncore\n-from codecs import encode\n from collections import defaultdict\n-import copy\n-import hashlib\n from io import BytesIO\n import logging\n-import random\n import socket\n import struct\n import sys\n import time\n from threading import RLock, Thread\n \n-from test_framework.siphash import siphash256\n-from test_framework.util import hex_str_to_bytes, bytes_to_hex_str, wait_until\n-\n-BIP0031_VERSION = 60000\n-MY_VERSION = 70014  # past bip-31 for ping/pong\n-MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n-MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n-\n-MAX_INV_SZ = 50000\n-MAX_BLOCK_BASE_SIZE = 1000000\n-\n-COIN = 100000000 # 1 btc in satoshis\n-\n-NODE_NETWORK = (1 << 0)\n-# NODE_GETUTXO = (1 << 1)\n-# NODE_BLOOM = (1 << 2)\n-NODE_WITNESS = (1 << 3)\n-NODE_UNSUPPORTED_SERVICE_BIT_5 = (1 << 5)\n-NODE_UNSUPPORTED_SERVICE_BIT_7 = (1 << 7)\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n@@ -69,1391 +39,6 @@\n # access to any data shared with the NodeConnCB or NodeConn.\n mininode_lock = RLock()\n \n-# Serialization/deserialization tools\n-def sha256(s):\n-    return hashlib.new('sha256', s).digest()\n-\n-def ripemd160(s):\n-    return hashlib.new('ripemd160', s).digest()\n-\n-def hash256(s):\n-    return sha256(sha256(s))\n-\n-def ser_compact_size(l):\n-    r = b\"\"\n-    if l < 253:\n-        r = struct.pack(\"B\", l)\n-    elif l < 0x10000:\n-        r = struct.pack(\"<BH\", 253, l)\n-    elif l < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, l)\n-    else:\n-        r = struct.pack(\"<BQ\", 255, l)\n-    return r\n-\n-def deser_compact_size(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n-    return nit\n-\n-def deser_string(f):\n-    nit = deser_compact_size(f)\n-    return f.read(nit)\n-\n-def ser_string(s):\n-    return ser_compact_size(len(s)) + s\n-\n-def deser_uint256(f):\n-    r = 0\n-    for i in range(8):\n-        t = struct.unpack(\"<I\", f.read(4))[0]\n-        r += t << (i * 32)\n-    return r\n-\n-\n-def ser_uint256(u):\n-    rs = b\"\"\n-    for i in range(8):\n-        rs += struct.pack(\"<I\", u & 0xFFFFFFFF)\n-        u >>= 32\n-    return rs\n-\n-\n-def uint256_from_str(s):\n-    r = 0\n-    t = struct.unpack(\"<IIIIIIII\", s[:32])\n-    for i in range(8):\n-        r += t[i] << (i * 32)\n-    return r\n-\n-\n-def uint256_from_compact(c):\n-    nbytes = (c >> 24) & 0xFF\n-    v = (c & 0xFFFFFF) << (8 * (nbytes - 3))\n-    return v\n-\n-\n-def deser_vector(f, c):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = c()\n-        t.deserialize(f)\n-        r.append(t)\n-    return r\n-\n-\n-# ser_function_name: Allow for an alternate serialization function on the\n-# entries in the vector (we use this for serializing the vector of transactions\n-# for a witness block).\n-def ser_vector(l, ser_function_name=None):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        if ser_function_name:\n-            r += getattr(i, ser_function_name)()\n-        else:\n-            r += i.serialize()\n-    return r\n-\n-\n-def deser_uint256_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = deser_uint256(f)\n-        r.append(t)\n-    return r\n-\n-\n-def ser_uint256_vector(l):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        r += ser_uint256(i)\n-    return r\n-\n-\n-def deser_string_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = deser_string(f)\n-        r.append(t)\n-    return r\n-\n-\n-def ser_string_vector(l):\n-    r = ser_compact_size(len(l))\n-    for sv in l:\n-        r += ser_string(sv)\n-    return r\n-\n-\n-def deser_int_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = struct.unpack(\"<i\", f.read(4))[0]\n-        r.append(t)\n-    return r\n-\n-\n-def ser_int_vector(l):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        r += struct.pack(\"<i\", i)\n-    return r\n-\n-# Deserialize from a hex string representation (eg from RPC)\n-def FromHex(obj, hex_string):\n-    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n-    return obj\n-\n-# Convert a binary-serializable object to hex (eg for submission via RPC)\n-def ToHex(obj):\n-    return bytes_to_hex_str(obj.serialize())\n-\n-# Objects that map to bitcoind objects, which can be serialized/deserialized\n-\n-class CAddress():\n-    def __init__(self):\n-        self.nServices = 1\n-        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n-        self.ip = \"0.0.0.0\"\n-        self.port = 0\n-\n-    def deserialize(self, f):\n-        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.pchReserved = f.read(12)\n-        self.ip = socket.inet_ntoa(f.read(4))\n-        self.port = struct.unpack(\">H\", f.read(2))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nServices)\n-        r += self.pchReserved\n-        r += socket.inet_aton(self.ip)\n-        r += struct.pack(\">H\", self.port)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n-                                                         self.ip, self.port)\n-\n-MSG_WITNESS_FLAG = 1<<30\n-\n-class CInv():\n-    typemap = {\n-        0: \"Error\",\n-        1: \"TX\",\n-        2: \"Block\",\n-        1|MSG_WITNESS_FLAG: \"WitnessTx\",\n-        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n-        4: \"CompactBlock\"\n-    }\n-\n-    def __init__(self, t=0, h=0):\n-        self.type = t\n-        self.hash = h\n-\n-    def deserialize(self, f):\n-        self.type = struct.unpack(\"<i\", f.read(4))[0]\n-        self.hash = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.type)\n-        r += ser_uint256(self.hash)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CInv(type=%s hash=%064x)\" \\\n-            % (self.typemap[self.type], self.hash)\n-\n-\n-class CBlockLocator():\n-    def __init__(self):\n-        self.nVersion = MY_VERSION\n-        self.vHave = []\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.vHave = deser_uint256_vector(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_uint256_vector(self.vHave)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n-            % (self.nVersion, repr(self.vHave))\n-\n-\n-class COutPoint():\n-    def __init__(self, hash=0, n=0):\n-        self.hash = hash\n-        self.n = n\n-\n-    def deserialize(self, f):\n-        self.hash = deser_uint256(f)\n-        self.n = struct.unpack(\"<I\", f.read(4))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_uint256(self.hash)\n-        r += struct.pack(\"<I\", self.n)\n-        return r\n-\n-    def __repr__(self):\n-        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n-\n-\n-class CTxIn():\n-    def __init__(self, outpoint=None, scriptSig=b\"\", nSequence=0):\n-        if outpoint is None:\n-            self.prevout = COutPoint()\n-        else:\n-            self.prevout = outpoint\n-        self.scriptSig = scriptSig\n-        self.nSequence = nSequence\n-\n-    def deserialize(self, f):\n-        self.prevout = COutPoint()\n-        self.prevout.deserialize(f)\n-        self.scriptSig = deser_string(f)\n-        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.prevout.serialize()\n-        r += ser_string(self.scriptSig)\n-        r += struct.pack(\"<I\", self.nSequence)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n-            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n-               self.nSequence)\n-\n-\n-class CTxOut():\n-    def __init__(self, nValue=0, scriptPubKey=b\"\"):\n-        self.nValue = nValue\n-        self.scriptPubKey = scriptPubKey\n-\n-    def deserialize(self, f):\n-        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n-        self.scriptPubKey = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<q\", self.nValue)\n-        r += ser_string(self.scriptPubKey)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n-            % (self.nValue // COIN, self.nValue % COIN,\n-               bytes_to_hex_str(self.scriptPubKey))\n-\n-\n-class CScriptWitness():\n-    def __init__(self):\n-        # stack is a vector of strings\n-        self.stack = []\n-\n-    def __repr__(self):\n-        return \"CScriptWitness(%s)\" % \\\n-               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n-\n-    def is_null(self):\n-        if self.stack:\n-            return False\n-        return True\n-\n-\n-class CTxInWitness():\n-    def __init__(self):\n-        self.scriptWitness = CScriptWitness()\n-\n-    def deserialize(self, f):\n-        self.scriptWitness.stack = deser_string_vector(f)\n-\n-    def serialize(self):\n-        return ser_string_vector(self.scriptWitness.stack)\n-\n-    def __repr__(self):\n-        return repr(self.scriptWitness)\n-\n-    def is_null(self):\n-        return self.scriptWitness.is_null()\n-\n-\n-class CTxWitness():\n-    def __init__(self):\n-        self.vtxinwit = []\n-\n-    def deserialize(self, f):\n-        for i in range(len(self.vtxinwit)):\n-            self.vtxinwit[i].deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        # This is different than the usual vector serialization --\n-        # we omit the length of the vector, which is required to be\n-        # the same length as the transaction's vin vector.\n-        for x in self.vtxinwit:\n-            r += x.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxWitness(%s)\" % \\\n-               (';'.join([repr(x) for x in self.vtxinwit]))\n-\n-    def is_null(self):\n-        for x in self.vtxinwit:\n-            if not x.is_null():\n-                return False\n-        return True\n-\n-\n-class CTransaction():\n-    def __init__(self, tx=None):\n-        if tx is None:\n-            self.nVersion = 1\n-            self.vin = []\n-            self.vout = []\n-            self.wit = CTxWitness()\n-            self.nLockTime = 0\n-            self.sha256 = None\n-            self.hash = None\n-        else:\n-            self.nVersion = tx.nVersion\n-            self.vin = copy.deepcopy(tx.vin)\n-            self.vout = copy.deepcopy(tx.vout)\n-            self.nLockTime = tx.nLockTime\n-            self.sha256 = tx.sha256\n-            self.hash = tx.hash\n-            self.wit = copy.deepcopy(tx.wit)\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.vin = deser_vector(f, CTxIn)\n-        flags = 0\n-        if len(self.vin) == 0:\n-            flags = struct.unpack(\"<B\", f.read(1))[0]\n-            # Not sure why flags can't be zero, but this\n-            # matches the implementation in bitcoind\n-            if (flags != 0):\n-                self.vin = deser_vector(f, CTxIn)\n-                self.vout = deser_vector(f, CTxOut)\n-        else:\n-            self.vout = deser_vector(f, CTxOut)\n-        if flags != 0:\n-            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n-            self.wit.deserialize(f)\n-        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def serialize_without_witness(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_vector(self.vin)\n-        r += ser_vector(self.vout)\n-        r += struct.pack(\"<I\", self.nLockTime)\n-        return r\n-\n-    # Only serialize with witness when explicitly called for\n-    def serialize_with_witness(self):\n-        flags = 0\n-        if not self.wit.is_null():\n-            flags |= 1\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        if flags:\n-            dummy = []\n-            r += ser_vector(dummy)\n-            r += struct.pack(\"<B\", flags)\n-        r += ser_vector(self.vin)\n-        r += ser_vector(self.vout)\n-        if flags & 1:\n-            if (len(self.wit.vtxinwit) != len(self.vin)):\n-                # vtxinwit must have the same length as vin\n-                self.wit.vtxinwit = self.wit.vtxinwit[:len(self.vin)]\n-                for i in range(len(self.wit.vtxinwit), len(self.vin)):\n-                    self.wit.vtxinwit.append(CTxInWitness())\n-            r += self.wit.serialize()\n-        r += struct.pack(\"<I\", self.nLockTime)\n-        return r\n-\n-    # Regular serialization is without witness -- must explicitly\n-    # call serialize_with_witness to include witness data.\n-    def serialize(self):\n-        return self.serialize_without_witness()\n-\n-    # Recalculate the txid (transaction hash without witness)\n-    def rehash(self):\n-        self.sha256 = None\n-        self.calc_sha256()\n-\n-    # We will only cache the serialization without witness in\n-    # self.sha256 and self.hash -- those are expected to be the txid.\n-    def calc_sha256(self, with_witness=False):\n-        if with_witness:\n-            # Don't cache the result, just return it\n-            return uint256_from_str(hash256(self.serialize_with_witness()))\n-\n-        if self.sha256 is None:\n-            self.sha256 = uint256_from_str(hash256(self.serialize_without_witness()))\n-        self.hash = encode(hash256(self.serialize())[::-1], 'hex_codec').decode('ascii')\n-\n-    def is_valid(self):\n-        self.calc_sha256()\n-        for tout in self.vout:\n-            if tout.nValue < 0 or tout.nValue > 21000000 * COIN:\n-                return False\n-        return True\n-\n-    def __repr__(self):\n-        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n-            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n-\n-\n-class CBlockHeader():\n-    def __init__(self, header=None):\n-        if header is None:\n-            self.set_null()\n-        else:\n-            self.nVersion = header.nVersion\n-            self.hashPrevBlock = header.hashPrevBlock\n-            self.hashMerkleRoot = header.hashMerkleRoot\n-            self.nTime = header.nTime\n-            self.nBits = header.nBits\n-            self.nNonce = header.nNonce\n-            self.sha256 = header.sha256\n-            self.hash = header.hash\n-            self.calc_sha256()\n-\n-    def set_null(self):\n-        self.nVersion = 1\n-        self.hashPrevBlock = 0\n-        self.hashMerkleRoot = 0\n-        self.nTime = 0\n-        self.nBits = 0\n-        self.nNonce = 0\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.hashPrevBlock = deser_uint256(f)\n-        self.hashMerkleRoot = deser_uint256(f)\n-        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n-        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n-        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_uint256(self.hashPrevBlock)\n-        r += ser_uint256(self.hashMerkleRoot)\n-        r += struct.pack(\"<I\", self.nTime)\n-        r += struct.pack(\"<I\", self.nBits)\n-        r += struct.pack(\"<I\", self.nNonce)\n-        return r\n-\n-    def calc_sha256(self):\n-        if self.sha256 is None:\n-            r = b\"\"\n-            r += struct.pack(\"<i\", self.nVersion)\n-            r += ser_uint256(self.hashPrevBlock)\n-            r += ser_uint256(self.hashMerkleRoot)\n-            r += struct.pack(\"<I\", self.nTime)\n-            r += struct.pack(\"<I\", self.nBits)\n-            r += struct.pack(\"<I\", self.nNonce)\n-            self.sha256 = uint256_from_str(hash256(r))\n-            self.hash = encode(hash256(r)[::-1], 'hex_codec').decode('ascii')\n-\n-    def rehash(self):\n-        self.sha256 = None\n-        self.calc_sha256()\n-        return self.sha256\n-\n-    def __repr__(self):\n-        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n-            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n-               time.ctime(self.nTime), self.nBits, self.nNonce)\n-\n-\n-class CBlock(CBlockHeader):\n-    def __init__(self, header=None):\n-        super(CBlock, self).__init__(header)\n-        self.vtx = []\n-\n-    def deserialize(self, f):\n-        super(CBlock, self).deserialize(f)\n-        self.vtx = deser_vector(f, CTransaction)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += super(CBlock, self).serialize()\n-        if with_witness:\n-            r += ser_vector(self.vtx, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.vtx)\n-        return r\n-\n-    # Calculate the merkle root given a vector of transaction hashes\n-    @classmethod\n-    def get_merkle_root(cls, hashes):\n-        while len(hashes) > 1:\n-            newhashes = []\n-            for i in range(0, len(hashes), 2):\n-                i2 = min(i+1, len(hashes)-1)\n-                newhashes.append(hash256(hashes[i] + hashes[i2]))\n-            hashes = newhashes\n-        return uint256_from_str(hashes[0])\n-\n-    def calc_merkle_root(self):\n-        hashes = []\n-        for tx in self.vtx:\n-            tx.calc_sha256()\n-            hashes.append(ser_uint256(tx.sha256))\n-        return self.get_merkle_root(hashes)\n-\n-    def calc_witness_merkle_root(self):\n-        # For witness root purposes, the hash of the\n-        # coinbase, with witness, is defined to be 0...0\n-        hashes = [ser_uint256(0)]\n-\n-        for tx in self.vtx[1:]:\n-            # Calculate the hashes with witness data\n-            hashes.append(ser_uint256(tx.calc_sha256(True)))\n-\n-        return self.get_merkle_root(hashes)\n-\n-    def is_valid(self):\n-        self.calc_sha256()\n-        target = uint256_from_compact(self.nBits)\n-        if self.sha256 > target:\n-            return False\n-        for tx in self.vtx:\n-            if not tx.is_valid():\n-                return False\n-        if self.calc_merkle_root() != self.hashMerkleRoot:\n-            return False\n-        return True\n-\n-    def solve(self):\n-        self.rehash()\n-        target = uint256_from_compact(self.nBits)\n-        while self.sha256 > target:\n-            self.nNonce += 1\n-            self.rehash()\n-\n-    def __repr__(self):\n-        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n-            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n-               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n-\n-\n-class CUnsignedAlert():\n-    def __init__(self):\n-        self.nVersion = 1\n-        self.nRelayUntil = 0\n-        self.nExpiration = 0\n-        self.nID = 0\n-        self.nCancel = 0\n-        self.setCancel = []\n-        self.nMinVer = 0\n-        self.nMaxVer = 0\n-        self.setSubVer = []\n-        self.nPriority = 0\n-        self.strComment = b\"\"\n-        self.strStatusBar = b\"\"\n-        self.strReserved = b\"\"\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n-        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n-        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n-        self.setCancel = deser_int_vector(f)\n-        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n-        self.setSubVer = deser_string_vector(f)\n-        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n-        self.strComment = deser_string(f)\n-        self.strStatusBar = deser_string(f)\n-        self.strReserved = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += struct.pack(\"<q\", self.nRelayUntil)\n-        r += struct.pack(\"<q\", self.nExpiration)\n-        r += struct.pack(\"<i\", self.nID)\n-        r += struct.pack(\"<i\", self.nCancel)\n-        r += ser_int_vector(self.setCancel)\n-        r += struct.pack(\"<i\", self.nMinVer)\n-        r += struct.pack(\"<i\", self.nMaxVer)\n-        r += ser_string_vector(self.setSubVer)\n-        r += struct.pack(\"<i\", self.nPriority)\n-        r += ser_string(self.strComment)\n-        r += ser_string(self.strStatusBar)\n-        r += ser_string(self.strReserved)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n-            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n-               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n-               self.strComment, self.strStatusBar, self.strReserved)\n-\n-\n-class CAlert():\n-    def __init__(self):\n-        self.vchMsg = b\"\"\n-        self.vchSig = b\"\"\n-\n-    def deserialize(self, f):\n-        self.vchMsg = deser_string(f)\n-        self.vchSig = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_string(self.vchMsg)\n-        r += ser_string(self.vchSig)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n-            % (len(self.vchMsg), len(self.vchSig))\n-\n-\n-class PrefilledTransaction():\n-    def __init__(self, index=0, tx = None):\n-        self.index = index\n-        self.tx = tx\n-\n-    def deserialize(self, f):\n-        self.index = deser_compact_size(f)\n-        self.tx = CTransaction()\n-        self.tx.deserialize(f)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += ser_compact_size(self.index)\n-        if with_witness:\n-            r += self.tx.serialize_with_witness()\n-        else:\n-            r += self.tx.serialize_without_witness()\n-        return r\n-\n-    def serialize_with_witness(self):\n-        return self.serialize(with_witness=True)\n-\n-    def __repr__(self):\n-        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n-\n-# This is what we send on the wire, in a cmpctblock message.\n-class P2PHeaderAndShortIDs():\n-    def __init__(self):\n-        self.header = CBlockHeader()\n-        self.nonce = 0\n-        self.shortids_length = 0\n-        self.shortids = []\n-        self.prefilled_txn_length = 0\n-        self.prefilled_txn = []\n-\n-    def deserialize(self, f):\n-        self.header.deserialize(f)\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.shortids_length = deser_compact_size(f)\n-        for i in range(self.shortids_length):\n-            # shortids are defined to be 6 bytes in the spec, so append\n-            # two zero bytes and read it in as an 8-byte number\n-            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n-        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n-        self.prefilled_txn_length = len(self.prefilled_txn)\n-\n-    # When using version 2 compact blocks, we must serialize with_witness.\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += self.header.serialize()\n-        r += struct.pack(\"<Q\", self.nonce)\n-        r += ser_compact_size(self.shortids_length)\n-        for x in self.shortids:\n-            # We only want the first 6 bytes\n-            r += struct.pack(\"<Q\", x)[0:6]\n-        if with_witness:\n-            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.prefilled_txn)\n-        return r\n-\n-    def __repr__(self):\n-        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n-\n-# P2P version of the above that will use witness serialization (for compact\n-# block version 2)\n-class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n-    def serialize(self):\n-        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n-\n-# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n-def calculate_shortid(k0, k1, tx_hash):\n-    expected_shortid = siphash256(k0, k1, tx_hash)\n-    expected_shortid &= 0x0000ffffffffffff\n-    return expected_shortid\n-\n-# This version gets rid of the array lengths, and reinterprets the differential\n-# encoding into indices that can be used for lookup.\n-class HeaderAndShortIDs():\n-    def __init__(self, p2pheaders_and_shortids = None):\n-        self.header = CBlockHeader()\n-        self.nonce = 0\n-        self.shortids = []\n-        self.prefilled_txn = []\n-        self.use_witness = False\n-\n-        if p2pheaders_and_shortids != None:\n-            self.header = p2pheaders_and_shortids.header\n-            self.nonce = p2pheaders_and_shortids.nonce\n-            self.shortids = p2pheaders_and_shortids.shortids\n-            last_index = -1\n-            for x in p2pheaders_and_shortids.prefilled_txn:\n-                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n-                last_index = self.prefilled_txn[-1].index\n-\n-    def to_p2p(self):\n-        if self.use_witness:\n-            ret = P2PHeaderAndShortWitnessIDs()\n-        else:\n-            ret = P2PHeaderAndShortIDs()\n-        ret.header = self.header\n-        ret.nonce = self.nonce\n-        ret.shortids_length = len(self.shortids)\n-        ret.shortids = self.shortids\n-        ret.prefilled_txn_length = len(self.prefilled_txn)\n-        ret.prefilled_txn = []\n-        last_index = -1\n-        for x in self.prefilled_txn:\n-            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n-            last_index = x.index\n-        return ret\n-\n-    def get_siphash_keys(self):\n-        header_nonce = self.header.serialize()\n-        header_nonce += struct.pack(\"<Q\", self.nonce)\n-        hash_header_nonce_as_str = sha256(header_nonce)\n-        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n-        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n-        return [ key0, key1 ]\n-\n-    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n-    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n-        self.header = CBlockHeader(block)\n-        self.nonce = nonce\n-        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n-        self.shortids = []\n-        self.use_witness = use_witness\n-        [k0, k1] = self.get_siphash_keys()\n-        for i in range(len(block.vtx)):\n-            if i not in prefill_list:\n-                tx_hash = block.vtx[i].sha256\n-                if use_witness:\n-                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n-                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n-\n-    def __repr__(self):\n-        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n-\n-\n-class BlockTransactionsRequest():\n-\n-    def __init__(self, blockhash=0, indexes = None):\n-        self.blockhash = blockhash\n-        self.indexes = indexes if indexes != None else []\n-\n-    def deserialize(self, f):\n-        self.blockhash = deser_uint256(f)\n-        indexes_length = deser_compact_size(f)\n-        for i in range(indexes_length):\n-            self.indexes.append(deser_compact_size(f))\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_uint256(self.blockhash)\n-        r += ser_compact_size(len(self.indexes))\n-        for x in self.indexes:\n-            r += ser_compact_size(x)\n-        return r\n-\n-    # helper to set the differentially encoded indexes from absolute ones\n-    def from_absolute(self, absolute_indexes):\n-        self.indexes = []\n-        last_index = -1\n-        for x in absolute_indexes:\n-            self.indexes.append(x-last_index-1)\n-            last_index = x\n-\n-    def to_absolute(self):\n-        absolute_indexes = []\n-        last_index = -1\n-        for x in self.indexes:\n-            absolute_indexes.append(x+last_index+1)\n-            last_index = absolute_indexes[-1]\n-        return absolute_indexes\n-\n-    def __repr__(self):\n-        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n-\n-\n-class BlockTransactions():\n-\n-    def __init__(self, blockhash=0, transactions = None):\n-        self.blockhash = blockhash\n-        self.transactions = transactions if transactions != None else []\n-\n-    def deserialize(self, f):\n-        self.blockhash = deser_uint256(f)\n-        self.transactions = deser_vector(f, CTransaction)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += ser_uint256(self.blockhash)\n-        if with_witness:\n-            r += ser_vector(self.transactions, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.transactions)\n-        return r\n-\n-    def __repr__(self):\n-        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n-\n-\n-# Objects that correspond to messages on the wire\n-class msg_version():\n-    command = b\"version\"\n-\n-    def __init__(self):\n-        self.nVersion = MY_VERSION\n-        self.nServices = 1\n-        self.nTime = int(time.time())\n-        self.addrTo = CAddress()\n-        self.addrFrom = CAddress()\n-        self.nNonce = random.getrandbits(64)\n-        self.strSubVer = MY_SUBVERSION\n-        self.nStartingHeight = -1\n-        self.nRelay = MY_RELAY\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        if self.nVersion == 10300:\n-            self.nVersion = 300\n-        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n-        self.addrTo = CAddress()\n-        self.addrTo.deserialize(f)\n-\n-        if self.nVersion >= 106:\n-            self.addrFrom = CAddress()\n-            self.addrFrom.deserialize(f)\n-            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n-            self.strSubVer = deser_string(f)\n-        else:\n-            self.addrFrom = None\n-            self.nNonce = None\n-            self.strSubVer = None\n-            self.nStartingHeight = None\n-\n-        if self.nVersion >= 209:\n-            self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n-        else:\n-            self.nStartingHeight = None\n-\n-        if self.nVersion >= 70001:\n-            # Relay field is optional for version 70001 onwards\n-            try:\n-                self.nRelay = struct.unpack(\"<b\", f.read(1))[0]\n-            except:\n-                self.nRelay = 0\n-        else:\n-            self.nRelay = 0\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += struct.pack(\"<Q\", self.nServices)\n-        r += struct.pack(\"<q\", self.nTime)\n-        r += self.addrTo.serialize()\n-        r += self.addrFrom.serialize()\n-        r += struct.pack(\"<Q\", self.nNonce)\n-        r += ser_string(self.strSubVer)\n-        r += struct.pack(\"<i\", self.nStartingHeight)\n-        r += struct.pack(\"<b\", self.nRelay)\n-        return r\n-\n-    def __repr__(self):\n-        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i nRelay=%i)' \\\n-            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n-               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n-               self.strSubVer, self.nStartingHeight, self.nRelay)\n-\n-\n-class msg_verack():\n-    command = b\"verack\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_verack()\"\n-\n-\n-class msg_addr():\n-    command = b\"addr\"\n-\n-    def __init__(self):\n-        self.addrs = []\n-\n-    def deserialize(self, f):\n-        self.addrs = deser_vector(f, CAddress)\n-\n-    def serialize(self):\n-        return ser_vector(self.addrs)\n-\n-    def __repr__(self):\n-        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n-\n-\n-class msg_alert():\n-    command = b\"alert\"\n-\n-    def __init__(self):\n-        self.alert = CAlert()\n-\n-    def deserialize(self, f):\n-        self.alert = CAlert()\n-        self.alert.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.alert.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n-\n-\n-class msg_inv():\n-    command = b\"inv\"\n-\n-    def __init__(self, inv=None):\n-        if inv is None:\n-            self.inv = []\n-        else:\n-            self.inv = inv\n-\n-    def deserialize(self, f):\n-        self.inv = deser_vector(f, CInv)\n-\n-    def serialize(self):\n-        return ser_vector(self.inv)\n-\n-    def __repr__(self):\n-        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n-\n-\n-class msg_getdata():\n-    command = b\"getdata\"\n-\n-    def __init__(self, inv=None):\n-        self.inv = inv if inv != None else []\n-\n-    def deserialize(self, f):\n-        self.inv = deser_vector(f, CInv)\n-\n-    def serialize(self):\n-        return ser_vector(self.inv)\n-\n-    def __repr__(self):\n-        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n-\n-\n-class msg_getblocks():\n-    command = b\"getblocks\"\n-\n-    def __init__(self):\n-        self.locator = CBlockLocator()\n-        self.hashstop = 0\n-\n-    def deserialize(self, f):\n-        self.locator = CBlockLocator()\n-        self.locator.deserialize(f)\n-        self.hashstop = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.locator.serialize()\n-        r += ser_uint256(self.hashstop)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n-            % (repr(self.locator), self.hashstop)\n-\n-\n-class msg_tx():\n-    command = b\"tx\"\n-\n-    def __init__(self, tx=CTransaction()):\n-        self.tx = tx\n-\n-    def deserialize(self, f):\n-        self.tx.deserialize(f)\n-\n-    def serialize(self):\n-        return self.tx.serialize_without_witness()\n-\n-    def __repr__(self):\n-        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n-\n-class msg_witness_tx(msg_tx):\n-\n-    def serialize(self):\n-        return self.tx.serialize_with_witness()\n-\n-\n-class msg_block():\n-    command = b\"block\"\n-\n-    def __init__(self, block=None):\n-        if block is None:\n-            self.block = CBlock()\n-        else:\n-            self.block = block\n-\n-    def deserialize(self, f):\n-        self.block.deserialize(f)\n-\n-    def serialize(self):\n-        return self.block.serialize()\n-\n-    def __repr__(self):\n-        return \"msg_block(block=%s)\" % (repr(self.block))\n-\n-# for cases where a user needs tighter control over what is sent over the wire\n-# note that the user must supply the name of the command, and the data\n-class msg_generic():\n-    def __init__(self, command, data=None):\n-        self.command = command\n-        self.data = data\n-\n-    def serialize(self):\n-        return self.data\n-\n-    def __repr__(self):\n-        return \"msg_generic()\"\n-\n-class msg_witness_block(msg_block):\n-\n-    def serialize(self):\n-        r = self.block.serialize(with_witness=True)\n-        return r\n-\n-class msg_getaddr():\n-    command = b\"getaddr\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_getaddr()\"\n-\n-\n-class msg_ping_prebip31():\n-    command = b\"ping\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_ping() (pre-bip31)\"\n-\n-\n-class msg_ping():\n-    command = b\"ping\"\n-\n-    def __init__(self, nonce=0):\n-        self.nonce = nonce\n-\n-    def deserialize(self, f):\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nonce)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_ping(nonce=%08x)\" % self.nonce\n-\n-\n-class msg_pong():\n-    command = b\"pong\"\n-\n-    def __init__(self, nonce=0):\n-        self.nonce = nonce\n-\n-    def deserialize(self, f):\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nonce)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_pong(nonce=%08x)\" % self.nonce\n-\n-\n-class msg_mempool():\n-    command = b\"mempool\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_mempool()\"\n-\n-class msg_sendheaders():\n-    command = b\"sendheaders\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_sendheaders()\"\n-\n-\n-# getheaders message has\n-# number of entries\n-# vector of hashes\n-# hash_stop (hash of last desired block header, 0 to get as many as possible)\n-class msg_getheaders():\n-    command = b\"getheaders\"\n-\n-    def __init__(self):\n-        self.locator = CBlockLocator()\n-        self.hashstop = 0\n-\n-    def deserialize(self, f):\n-        self.locator = CBlockLocator()\n-        self.locator.deserialize(f)\n-        self.hashstop = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.locator.serialize()\n-        r += ser_uint256(self.hashstop)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n-            % (repr(self.locator), self.hashstop)\n-\n-\n-# headers message has\n-# <count> <vector of block headers>\n-class msg_headers():\n-    command = b\"headers\"\n-\n-    def __init__(self, headers=None):\n-        self.headers = headers if headers is not None else []\n-\n-    def deserialize(self, f):\n-        # comment in bitcoind indicates these should be deserialized as blocks\n-        blocks = deser_vector(f, CBlock)\n-        for x in blocks:\n-            self.headers.append(CBlockHeader(x))\n-\n-    def serialize(self):\n-        blocks = [CBlock(x) for x in self.headers]\n-        return ser_vector(blocks)\n-\n-    def __repr__(self):\n-        return \"msg_headers(headers=%s)\" % repr(self.headers)\n-\n-\n-class msg_reject():\n-    command = b\"reject\"\n-    REJECT_MALFORMED = 1\n-\n-    def __init__(self):\n-        self.message = b\"\"\n-        self.code = 0\n-        self.reason = b\"\"\n-        self.data = 0\n-\n-    def deserialize(self, f):\n-        self.message = deser_string(f)\n-        self.code = struct.unpack(\"<B\", f.read(1))[0]\n-        self.reason = deser_string(f)\n-        if (self.code != self.REJECT_MALFORMED and\n-                (self.message == b\"block\" or self.message == b\"tx\")):\n-            self.data = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = ser_string(self.message)\n-        r += struct.pack(\"<B\", self.code)\n-        r += ser_string(self.reason)\n-        if (self.code != self.REJECT_MALFORMED and\n-                (self.message == b\"block\" or self.message == b\"tx\")):\n-            r += ser_uint256(self.data)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_reject: %s %d %s [%064x]\" \\\n-            % (self.message, self.code, self.reason, self.data)\n-\n-class msg_feefilter():\n-    command = b\"feefilter\"\n-\n-    def __init__(self, feerate=0):\n-        self.feerate = feerate\n-\n-    def deserialize(self, f):\n-        self.feerate = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.feerate)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_feefilter(feerate=%08x)\" % self.feerate\n-\n-class msg_sendcmpct():\n-    command = b\"sendcmpct\"\n-\n-    def __init__(self):\n-        self.announce = False\n-        self.version = 1\n-\n-    def deserialize(self, f):\n-        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n-        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<?\", self.announce)\n-        r += struct.pack(\"<Q\", self.version)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n-\n-class msg_cmpctblock():\n-    command = b\"cmpctblock\"\n-\n-    def __init__(self, header_and_shortids = None):\n-        self.header_and_shortids = header_and_shortids\n-\n-    def deserialize(self, f):\n-        self.header_and_shortids = P2PHeaderAndShortIDs()\n-        self.header_and_shortids.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.header_and_shortids.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n-\n-class msg_getblocktxn():\n-    command = b\"getblocktxn\"\n-\n-    def __init__(self):\n-        self.block_txn_request = None\n-\n-    def deserialize(self, f):\n-        self.block_txn_request = BlockTransactionsRequest()\n-        self.block_txn_request.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_txn_request.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n-\n-class msg_blocktxn():\n-    command = b\"blocktxn\"\n-\n-    def __init__(self):\n-        self.block_transactions = BlockTransactions()\n-\n-    def deserialize(self, f):\n-        self.block_transactions.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_transactions.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n-\n-class msg_witness_blocktxn(msg_blocktxn):\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_transactions.serialize(with_witness=True)\n-        return r\n-\n class NodeConnCB():\n     \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n "
      },
      {
        "sha": "f11f41b75d81e770087d996410a767a1c0945116",
        "filename": "test/functional/test_framework/primitives.py",
        "status": "added",
        "additions": 1424,
        "deletions": 0,
        "changes": 1424,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64d947b82df924c101f0fd00f4891177a2d0ed44/test/functional/test_framework/primitives.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64d947b82df924c101f0fd00f4891177a2d0ed44/test/functional/test_framework/primitives.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/primitives.py?ref=64d947b82df924c101f0fd00f4891177a2d0ed44",
        "patch": "@@ -0,0 +1,1424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2010 ArtForz -- public domain half-a-node\n+# Copyright (c) 2012 Jeff Garzik\n+# Copyright (c) 2010-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Bitcoin test framework primitives\n+\n+CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n+    data structures that should map to corresponding structures in\n+    bitcoin/primitives\n+msg_block, msg_tx, msg_headers, etc.:\n+    data structures that represent network messages\n+ser_*, deser_*: functions that handle serialization/deserialization\n+\"\"\"\n+from codecs import encode\n+import copy\n+import hashlib\n+from io import BytesIO\n+import random\n+import socket\n+import struct\n+import time\n+\n+from test_framework.siphash import siphash256\n+from test_framework.util import hex_str_to_bytes, bytes_to_hex_str\n+\n+BIP0031_VERSION = 60000\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n+MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n+MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n+\n+MAX_INV_SZ = 50000\n+MAX_BLOCK_BASE_SIZE = 1000000\n+\n+MSG_WITNESS_FLAG = 1<<30\n+\n+COIN = 100000000 # 1 btc in satoshis\n+\n+NODE_NETWORK = (1 << 0)\n+# NODE_GETUTXO = (1 << 1)\n+# NODE_BLOOM = (1 << 2)\n+NODE_WITNESS = (1 << 3)\n+NODE_UNSUPPORTED_SERVICE_BIT_5 = (1 << 5)\n+NODE_UNSUPPORTED_SERVICE_BIT_7 = (1 << 7)\n+\n+# Serialization/deserialization tools\n+def sha256(s):\n+    return hashlib.new('sha256', s).digest()\n+\n+def ripemd160(s):\n+    return hashlib.new('ripemd160', s).digest()\n+\n+def hash256(s):\n+    return sha256(sha256(s))\n+\n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n+\n+def deser_compact_size(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return nit\n+\n+def deser_string(f):\n+    nit = deser_compact_size(f)\n+    return f.read(nit)\n+\n+def ser_string(s):\n+    return ser_compact_size(len(s)) + s\n+\n+def deser_uint256(f):\n+    r = 0\n+    for i in range(8):\n+        t = struct.unpack(\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+def ser_uint256(u):\n+    rs = b\"\"\n+    for i in range(8):\n+        rs += struct.pack(\"<I\", u & 0xFFFFFFFF)\n+        u >>= 32\n+    return rs\n+\n+def uint256_from_str(s):\n+    r = 0\n+    t = struct.unpack(\"<IIIIIIII\", s[:32])\n+    for i in range(8):\n+        r += t[i] << (i * 32)\n+    return r\n+\n+def uint256_from_compact(c):\n+    nbytes = (c >> 24) & 0xFF\n+    v = (c & 0xFFFFFF) << (8 * (nbytes - 3))\n+    return v\n+\n+def deser_vector(f, c):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = c()\n+        t.deserialize(f)\n+        r.append(t)\n+    return r\n+\n+# ser_function_name: Allow for an alternate serialization function on the\n+# entries in the vector (we use this for serializing the vector of transactions\n+# for a witness block).\n+def ser_vector(l, ser_function_name=None):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        if ser_function_name:\n+            r += getattr(i, ser_function_name)()\n+        else:\n+            r += i.serialize()\n+    return r\n+\n+def deser_uint256_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_uint256(f)\n+        r.append(t)\n+    return r\n+\n+def ser_uint256_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += ser_uint256(i)\n+    return r\n+\n+def deser_string_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_string(f)\n+        r.append(t)\n+    return r\n+\n+def ser_string_vector(l):\n+    r = ser_compact_size(len(l))\n+    for sv in l:\n+        r += ser_string(sv)\n+    return r\n+\n+def deser_int_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = struct.unpack(\"<i\", f.read(4))[0]\n+        r.append(t)\n+    return r\n+\n+def ser_int_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += struct.pack(\"<i\", i)\n+    return r\n+\n+# Deserialize from a hex string representation (eg from RPC)\n+def FromHex(obj, hex_string):\n+    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n+    return obj\n+\n+# Convert a binary-serializable object to hex (eg for submission via RPC)\n+def ToHex(obj):\n+    return bytes_to_hex_str(obj.serialize())\n+\n+# Objects that map to bitcoind objects, which can be serialized/deserialized\n+\n+class CAddress():\n+    def __init__(self):\n+        self.nServices = 1\n+        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        self.ip = \"0.0.0.0\"\n+        self.port = 0\n+\n+    def deserialize(self, f):\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.pchReserved = f.read(12)\n+        self.ip = socket.inet_ntoa(f.read(4))\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += self.pchReserved\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n+                                                         self.ip, self.port)\n+\n+\n+class CInv():\n+    typemap = {\n+        0: \"Error\",\n+        1: \"TX\",\n+        2: \"Block\",\n+        1|MSG_WITNESS_FLAG: \"WitnessTx\",\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n+        4: \"CompactBlock\"\n+    }\n+\n+    def __init__(self, t=0, h=0):\n+        self.type = t\n+        self.hash = h\n+\n+    def deserialize(self, f):\n+        self.type = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hash = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.type)\n+        r += ser_uint256(self.hash)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CInv(type=%s hash=%064x)\" \\\n+            % (self.typemap[self.type], self.hash)\n+\n+\n+class CBlockLocator():\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.vHave = []\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vHave = deser_uint256_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256_vector(self.vHave)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n+            % (self.nVersion, repr(self.vHave))\n+\n+\n+class COutPoint():\n+    def __init__(self, hash=0, n=0):\n+        self.hash = hash\n+        self.n = n\n+\n+    def deserialize(self, f):\n+        self.hash = deser_uint256(f)\n+        self.n = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.hash)\n+        r += struct.pack(\"<I\", self.n)\n+        return r\n+\n+    def __repr__(self):\n+        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n+\n+\n+class CTxIn():\n+    def __init__(self, outpoint=None, scriptSig=b\"\", nSequence=0):\n+        if outpoint is None:\n+            self.prevout = COutPoint()\n+        else:\n+            self.prevout = outpoint\n+        self.scriptSig = scriptSig\n+        self.nSequence = nSequence\n+\n+    def deserialize(self, f):\n+        self.prevout = COutPoint()\n+        self.prevout.deserialize(f)\n+        self.scriptSig = deser_string(f)\n+        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.prevout.serialize()\n+        r += ser_string(self.scriptSig)\n+        r += struct.pack(\"<I\", self.nSequence)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n+            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n+               self.nSequence)\n+\n+\n+class CTxOut():\n+    def __init__(self, nValue=0, scriptPubKey=b\"\"):\n+        self.nValue = nValue\n+        self.scriptPubKey = scriptPubKey\n+\n+    def deserialize(self, f):\n+        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n+        self.scriptPubKey = deser_string(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<q\", self.nValue)\n+        r += ser_string(self.scriptPubKey)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n+            % (self.nValue // COIN, self.nValue % COIN,\n+               bytes_to_hex_str(self.scriptPubKey))\n+\n+\n+class CScriptWitness():\n+    def __init__(self):\n+        # stack is a vector of strings\n+        self.stack = []\n+\n+    def __repr__(self):\n+        return \"CScriptWitness(%s)\" % \\\n+               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n+\n+    def is_null(self):\n+        if self.stack:\n+            return False\n+        return True\n+\n+\n+class CTxInWitness():\n+    def __init__(self):\n+        self.scriptWitness = CScriptWitness()\n+\n+    def deserialize(self, f):\n+        self.scriptWitness.stack = deser_string_vector(f)\n+\n+    def serialize(self):\n+        return ser_string_vector(self.scriptWitness.stack)\n+\n+    def __repr__(self):\n+        return repr(self.scriptWitness)\n+\n+    def is_null(self):\n+        return self.scriptWitness.is_null()\n+\n+\n+class CTxWitness():\n+    def __init__(self):\n+        self.vtxinwit = []\n+\n+    def deserialize(self, f):\n+        for i in range(len(self.vtxinwit)):\n+            self.vtxinwit[i].deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        # This is different than the usual vector serialization --\n+        # we omit the length of the vector, which is required to be\n+        # the same length as the transaction's vin vector.\n+        for x in self.vtxinwit:\n+            r += x.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxWitness(%s)\" % \\\n+               (';'.join([repr(x) for x in self.vtxinwit]))\n+\n+    def is_null(self):\n+        for x in self.vtxinwit:\n+            if not x.is_null():\n+                return False\n+        return True\n+\n+\n+class CTransaction():\n+    def __init__(self, tx=None):\n+        if tx is None:\n+            self.nVersion = 1\n+            self.vin = []\n+            self.vout = []\n+            self.wit = CTxWitness()\n+            self.nLockTime = 0\n+            self.sha256 = None\n+            self.hash = None\n+        else:\n+            self.nVersion = tx.nVersion\n+            self.vin = copy.deepcopy(tx.vin)\n+            self.vout = copy.deepcopy(tx.vout)\n+            self.nLockTime = tx.nLockTime\n+            self.sha256 = tx.sha256\n+            self.hash = tx.hash\n+            self.wit = copy.deepcopy(tx.wit)\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vin = deser_vector(f, CTxIn)\n+        flags = 0\n+        if len(self.vin) == 0:\n+            flags = struct.unpack(\"<B\", f.read(1))[0]\n+            # Not sure why flags can't be zero, but this\n+            # matches the implementation in bitcoind\n+            if (flags != 0):\n+                self.vin = deser_vector(f, CTxIn)\n+                self.vout = deser_vector(f, CTxOut)\n+        else:\n+            self.vout = deser_vector(f, CTxOut)\n+        if flags != 0:\n+            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n+            self.wit.deserialize(f)\n+        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize_without_witness(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    # Only serialize with witness when explicitly called for\n+    def serialize_with_witness(self):\n+        flags = 0\n+        if not self.wit.is_null():\n+            flags |= 1\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        if flags:\n+            dummy = []\n+            r += ser_vector(dummy)\n+            r += struct.pack(\"<B\", flags)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        if flags & 1:\n+            if (len(self.wit.vtxinwit) != len(self.vin)):\n+                # vtxinwit must have the same length as vin\n+                self.wit.vtxinwit = self.wit.vtxinwit[:len(self.vin)]\n+                for i in range(len(self.wit.vtxinwit), len(self.vin)):\n+                    self.wit.vtxinwit.append(CTxInWitness())\n+            r += self.wit.serialize()\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    # Regular serialization is without witness -- must explicitly\n+    # call serialize_with_witness to include witness data.\n+    def serialize(self):\n+        return self.serialize_without_witness()\n+\n+    # Recalculate the txid (transaction hash without witness)\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+\n+    # We will only cache the serialization without witness in\n+    # self.sha256 and self.hash -- those are expected to be the txid.\n+    def calc_sha256(self, with_witness=False):\n+        if with_witness:\n+            # Don't cache the result, just return it\n+            return uint256_from_str(hash256(self.serialize_with_witness()))\n+\n+        if self.sha256 is None:\n+            self.sha256 = uint256_from_str(hash256(self.serialize_without_witness()))\n+        self.hash = encode(hash256(self.serialize())[::-1], 'hex_codec').decode('ascii')\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        for tout in self.vout:\n+            if tout.nValue < 0 or tout.nValue > 21000000 * COIN:\n+                return False\n+        return True\n+\n+    def __repr__(self):\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n+\n+\n+class CBlockHeader():\n+    def __init__(self, header=None):\n+        if header is None:\n+            self.set_null()\n+        else:\n+            self.nVersion = header.nVersion\n+            self.hashPrevBlock = header.hashPrevBlock\n+            self.hashMerkleRoot = header.hashMerkleRoot\n+            self.nTime = header.nTime\n+            self.nBits = header.nBits\n+            self.nNonce = header.nNonce\n+            self.sha256 = header.sha256\n+            self.hash = header.hash\n+            self.calc_sha256()\n+\n+    def set_null(self):\n+        self.nVersion = 1\n+        self.hashPrevBlock = 0\n+        self.hashMerkleRoot = 0\n+        self.nTime = 0\n+        self.nBits = 0\n+        self.nNonce = 0\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hashPrevBlock = deser_uint256(f)\n+        self.hashMerkleRoot = deser_uint256(f)\n+        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256(self.hashPrevBlock)\n+        r += ser_uint256(self.hashMerkleRoot)\n+        r += struct.pack(\"<I\", self.nTime)\n+        r += struct.pack(\"<I\", self.nBits)\n+        r += struct.pack(\"<I\", self.nNonce)\n+        return r\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            r = b\"\"\n+            r += struct.pack(\"<i\", self.nVersion)\n+            r += ser_uint256(self.hashPrevBlock)\n+            r += ser_uint256(self.hashMerkleRoot)\n+            r += struct.pack(\"<I\", self.nTime)\n+            r += struct.pack(\"<I\", self.nBits)\n+            r += struct.pack(\"<I\", self.nNonce)\n+            self.sha256 = uint256_from_str(hash256(r))\n+            self.hash = encode(hash256(r)[::-1], 'hex_codec').decode('ascii')\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+        return self.sha256\n+\n+    def __repr__(self):\n+        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce)\n+\n+\n+class CBlock(CBlockHeader):\n+    def __init__(self, header=None):\n+        super(CBlock, self).__init__(header)\n+        self.vtx = []\n+\n+    def deserialize(self, f):\n+        super(CBlock, self).deserialize(f)\n+        self.vtx = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += super(CBlock, self).serialize()\n+        if with_witness:\n+            r += ser_vector(self.vtx, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.vtx)\n+        return r\n+\n+    # Calculate the merkle root given a vector of transaction hashes\n+    @classmethod\n+    def get_merkle_root(cls, hashes):\n+        while len(hashes) > 1:\n+            newhashes = []\n+            for i in range(0, len(hashes), 2):\n+                i2 = min(i+1, len(hashes)-1)\n+                newhashes.append(hash256(hashes[i] + hashes[i2]))\n+            hashes = newhashes\n+        return uint256_from_str(hashes[0])\n+\n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        return self.get_merkle_root(hashes)\n+\n+    def calc_witness_merkle_root(self):\n+        # For witness root purposes, the hash of the\n+        # coinbase, with witness, is defined to be 0...0\n+        hashes = [ser_uint256(0)]\n+\n+        for tx in self.vtx[1:]:\n+            # Calculate the hashes with witness data\n+            hashes.append(ser_uint256(tx.calc_sha256(True)))\n+\n+        return self.get_merkle_root(hashes)\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        if self.sha256 > target:\n+            return False\n+        for tx in self.vtx:\n+            if not tx.is_valid():\n+                return False\n+        if self.calc_merkle_root() != self.hashMerkleRoot:\n+            return False\n+        return True\n+\n+    def solve(self):\n+        self.rehash()\n+        target = uint256_from_compact(self.nBits)\n+        while self.sha256 > target:\n+            self.nNonce += 1\n+            self.rehash()\n+\n+    def __repr__(self):\n+        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n+\n+\n+class CUnsignedAlert():\n+    def __init__(self):\n+        self.nVersion = 1\n+        self.nRelayUntil = 0\n+        self.nExpiration = 0\n+        self.nID = 0\n+        self.nCancel = 0\n+        self.setCancel = []\n+        self.nMinVer = 0\n+        self.nMaxVer = 0\n+        self.setSubVer = []\n+        self.nPriority = 0\n+        self.strComment = b\"\"\n+        self.strStatusBar = b\"\"\n+        self.strReserved = b\"\"\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setCancel = deser_int_vector(f)\n+        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setSubVer = deser_string_vector(f)\n+        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n+        self.strComment = deser_string(f)\n+        self.strStatusBar = deser_string(f)\n+        self.strReserved = deser_string(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<q\", self.nRelayUntil)\n+        r += struct.pack(\"<q\", self.nExpiration)\n+        r += struct.pack(\"<i\", self.nID)\n+        r += struct.pack(\"<i\", self.nCancel)\n+        r += ser_int_vector(self.setCancel)\n+        r += struct.pack(\"<i\", self.nMinVer)\n+        r += struct.pack(\"<i\", self.nMaxVer)\n+        r += ser_string_vector(self.setSubVer)\n+        r += struct.pack(\"<i\", self.nPriority)\n+        r += ser_string(self.strComment)\n+        r += ser_string(self.strStatusBar)\n+        r += ser_string(self.strReserved)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n+            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n+               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n+               self.strComment, self.strStatusBar, self.strReserved)\n+\n+\n+class CAlert():\n+    def __init__(self):\n+        self.vchMsg = b\"\"\n+        self.vchSig = b\"\"\n+\n+    def deserialize(self, f):\n+        self.vchMsg = deser_string(f)\n+        self.vchSig = deser_string(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_string(self.vchMsg)\n+        r += ser_string(self.vchSig)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n+            % (len(self.vchMsg), len(self.vchSig))\n+\n+\n+class PrefilledTransaction():\n+    def __init__(self, index=0, tx = None):\n+        self.index = index\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.index = deser_compact_size(f)\n+        self.tx = CTransaction()\n+        self.tx.deserialize(f)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_compact_size(self.index)\n+        if with_witness:\n+            r += self.tx.serialize_with_witness()\n+        else:\n+            r += self.tx.serialize_without_witness()\n+        return r\n+\n+    def serialize_with_witness(self):\n+        return self.serialize(with_witness=True)\n+\n+    def __repr__(self):\n+        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n+\n+# This is what we send on the wire, in a cmpctblock message.\n+class P2PHeaderAndShortIDs():\n+    def __init__(self):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids_length = 0\n+        self.shortids = []\n+        self.prefilled_txn_length = 0\n+        self.prefilled_txn = []\n+\n+    def deserialize(self, f):\n+        self.header.deserialize(f)\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.shortids_length = deser_compact_size(f)\n+        for i in range(self.shortids_length):\n+            # shortids are defined to be 6 bytes in the spec, so append\n+            # two zero bytes and read it in as an 8-byte number\n+            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n+        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n+        self.prefilled_txn_length = len(self.prefilled_txn)\n+\n+    # When using version 2 compact blocks, we must serialize with_witness.\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += self.header.serialize()\n+        r += struct.pack(\"<Q\", self.nonce)\n+        r += ser_compact_size(self.shortids_length)\n+        for x in self.shortids:\n+            # We only want the first 6 bytes\n+            r += struct.pack(\"<Q\", x)[0:6]\n+        if with_witness:\n+            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.prefilled_txn)\n+        return r\n+\n+    def __repr__(self):\n+        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n+\n+# P2P version of the above that will use witness serialization (for compact\n+# block version 2)\n+class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n+    def serialize(self):\n+        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n+\n+# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n+def calculate_shortid(k0, k1, tx_hash):\n+    expected_shortid = siphash256(k0, k1, tx_hash)\n+    expected_shortid &= 0x0000ffffffffffff\n+    return expected_shortid\n+\n+# This version gets rid of the array lengths, and reinterprets the differential\n+# encoding into indices that can be used for lookup.\n+class HeaderAndShortIDs():\n+    def __init__(self, p2pheaders_and_shortids = None):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids = []\n+        self.prefilled_txn = []\n+        self.use_witness = False\n+\n+        if p2pheaders_and_shortids != None:\n+            self.header = p2pheaders_and_shortids.header\n+            self.nonce = p2pheaders_and_shortids.nonce\n+            self.shortids = p2pheaders_and_shortids.shortids\n+            last_index = -1\n+            for x in p2pheaders_and_shortids.prefilled_txn:\n+                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n+                last_index = self.prefilled_txn[-1].index\n+\n+    def to_p2p(self):\n+        if self.use_witness:\n+            ret = P2PHeaderAndShortWitnessIDs()\n+        else:\n+            ret = P2PHeaderAndShortIDs()\n+        ret.header = self.header\n+        ret.nonce = self.nonce\n+        ret.shortids_length = len(self.shortids)\n+        ret.shortids = self.shortids\n+        ret.prefilled_txn_length = len(self.prefilled_txn)\n+        ret.prefilled_txn = []\n+        last_index = -1\n+        for x in self.prefilled_txn:\n+            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n+            last_index = x.index\n+        return ret\n+\n+    def get_siphash_keys(self):\n+        header_nonce = self.header.serialize()\n+        header_nonce += struct.pack(\"<Q\", self.nonce)\n+        hash_header_nonce_as_str = sha256(header_nonce)\n+        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n+        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n+        return [ key0, key1 ]\n+\n+    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n+        self.header = CBlockHeader(block)\n+        self.nonce = nonce\n+        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n+        self.shortids = []\n+        self.use_witness = use_witness\n+        [k0, k1] = self.get_siphash_keys()\n+        for i in range(len(block.vtx)):\n+            if i not in prefill_list:\n+                tx_hash = block.vtx[i].sha256\n+                if use_witness:\n+                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n+                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n+\n+    def __repr__(self):\n+        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n+\n+\n+class BlockTransactionsRequest():\n+    def __init__(self, blockhash=0, indexes = None):\n+        self.blockhash = blockhash\n+        self.indexes = indexes if indexes != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        indexes_length = deser_compact_size(f)\n+        for i in range(indexes_length):\n+            self.indexes.append(deser_compact_size(f))\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        r += ser_compact_size(len(self.indexes))\n+        for x in self.indexes:\n+            r += ser_compact_size(x)\n+        return r\n+\n+    # helper to set the differentially encoded indexes from absolute ones\n+    def from_absolute(self, absolute_indexes):\n+        self.indexes = []\n+        last_index = -1\n+        for x in absolute_indexes:\n+            self.indexes.append(x-last_index-1)\n+            last_index = x\n+\n+    def to_absolute(self):\n+        absolute_indexes = []\n+        last_index = -1\n+        for x in self.indexes:\n+            absolute_indexes.append(x+last_index+1)\n+            last_index = absolute_indexes[-1]\n+        return absolute_indexes\n+\n+    def __repr__(self):\n+        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n+\n+\n+class BlockTransactions():\n+    def __init__(self, blockhash=0, transactions = None):\n+        self.blockhash = blockhash\n+        self.transactions = transactions if transactions != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        self.transactions = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        if with_witness:\n+            r += ser_vector(self.transactions, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.transactions)\n+        return r\n+\n+    def __repr__(self):\n+        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n+\n+\n+# Objects that correspond to messages on the wire\n+class msg_generic():\n+# for cases where a user needs tight control over what is sent over the wire\n+# the user must supply the name of the command, and the data\n+    def __init__(self, command, data=None):\n+        self.command = command\n+        self.data = data\n+\n+    def serialize(self):\n+        return self.data\n+\n+    def __repr__(self):\n+        return \"msg_generic()\"\n+\n+class msg_version():\n+    command = b\"version\"\n+\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.nServices = 1\n+        self.nTime = int(time.time())\n+        self.addrTo = CAddress()\n+        self.addrFrom = CAddress()\n+        self.nNonce = random.getrandbits(64)\n+        self.strSubVer = MY_SUBVERSION\n+        self.nStartingHeight = -1\n+        self.nRelay = MY_RELAY\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        if self.nVersion == 10300:\n+            self.nVersion = 300\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n+        self.addrTo = CAddress()\n+        self.addrTo.deserialize(f)\n+\n+        if self.nVersion >= 106:\n+            self.addrFrom = CAddress()\n+            self.addrFrom.deserialize(f)\n+            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n+            self.strSubVer = deser_string(f)\n+        else:\n+            self.addrFrom = None\n+            self.nNonce = None\n+            self.strSubVer = None\n+            self.nStartingHeight = None\n+\n+        if self.nVersion >= 209:\n+            self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n+        else:\n+            self.nStartingHeight = None\n+\n+        if self.nVersion >= 70001:\n+            # Relay field is optional for version 70001 onwards\n+            try:\n+                self.nRelay = struct.unpack(\"<b\", f.read(1))[0]\n+            except:\n+                self.nRelay = 0\n+        else:\n+            self.nRelay = 0\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += struct.pack(\"<q\", self.nTime)\n+        r += self.addrTo.serialize()\n+        r += self.addrFrom.serialize()\n+        r += struct.pack(\"<Q\", self.nNonce)\n+        r += ser_string(self.strSubVer)\n+        r += struct.pack(\"<i\", self.nStartingHeight)\n+        r += struct.pack(\"<b\", self.nRelay)\n+        return r\n+\n+    def __repr__(self):\n+        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i nRelay=%i)' \\\n+            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n+               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n+               self.strSubVer, self.nStartingHeight, self.nRelay)\n+\n+\n+class msg_verack():\n+    command = b\"verack\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_verack()\"\n+\n+\n+class msg_addr():\n+    command = b\"addr\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress)\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs)\n+\n+    def __repr__(self):\n+        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_alert():\n+    command = b\"alert\"\n+\n+    def __init__(self):\n+        self.alert = CAlert()\n+\n+    def deserialize(self, f):\n+        self.alert = CAlert()\n+        self.alert.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.alert.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n+\n+\n+class msg_inv():\n+    command = b\"inv\"\n+\n+    def __init__(self, inv=None):\n+        if inv is None:\n+            self.inv = []\n+        else:\n+            self.inv = inv\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getdata():\n+    command = b\"getdata\"\n+\n+    def __init__(self, inv=None):\n+        self.inv = inv if inv != None else []\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getblocks():\n+    command = b\"getblocks\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+class msg_tx():\n+    command = b\"tx\"\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize_without_witness()\n+\n+    def __repr__(self):\n+        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n+\n+class msg_witness_tx(msg_tx):\n+\n+    def serialize(self):\n+        return self.tx.serialize_with_witness()\n+\n+\n+class msg_block():\n+    command = b\"block\"\n+\n+    def __init__(self, block=None):\n+        if block is None:\n+            self.block = CBlock()\n+        else:\n+            self.block = block\n+\n+    def deserialize(self, f):\n+        self.block.deserialize(f)\n+\n+    def serialize(self):\n+        return self.block.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_block(block=%s)\" % (repr(self.block))\n+\n+\n+class msg_witness_block(msg_block):\n+    def serialize(self):\n+        r = self.block.serialize(with_witness=True)\n+        return r\n+\n+\n+class msg_getaddr():\n+    command = b\"getaddr\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_getaddr()\"\n+\n+\n+class msg_ping_prebip31():\n+    command = b\"ping\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_ping() (pre-bip31)\"\n+\n+\n+class msg_ping():\n+    command = b\"ping\"\n+\n+    def __init__(self, nonce=0):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_ping(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_pong():\n+    command = b\"pong\"\n+\n+    def __init__(self, nonce=0):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_pong(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_mempool():\n+    command = b\"mempool\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_mempool()\"\n+\n+\n+class msg_sendheaders():\n+    command = b\"sendheaders\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_sendheaders()\"\n+\n+\n+# getheaders message has\n+# number of entries\n+# vector of hashes\n+# hash_stop (hash of last desired block header, 0 to get as many as possible)\n+class msg_getheaders():\n+    command = b\"getheaders\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+# headers message has\n+# <count> <vector of block headers>\n+class msg_headers():\n+    command = b\"headers\"\n+\n+    def __init__(self, headers=None):\n+        self.headers = headers if headers is not None else []\n+\n+    def deserialize(self, f):\n+        # comment in bitcoind indicates these should be deserialized as blocks\n+        blocks = deser_vector(f, CBlock)\n+        for x in blocks:\n+            self.headers.append(CBlockHeader(x))\n+\n+    def serialize(self):\n+        blocks = [CBlock(x) for x in self.headers]\n+        return ser_vector(blocks)\n+\n+    def __repr__(self):\n+        return \"msg_headers(headers=%s)\" % repr(self.headers)\n+\n+\n+class msg_reject():\n+    command = b\"reject\"\n+    REJECT_MALFORMED = 1\n+\n+    def __init__(self):\n+        self.message = b\"\"\n+        self.code = 0\n+        self.reason = b\"\"\n+        self.data = 0\n+\n+    def deserialize(self, f):\n+        self.message = deser_string(f)\n+        self.code = struct.unpack(\"<B\", f.read(1))[0]\n+        self.reason = deser_string(f)\n+        if (self.code != self.REJECT_MALFORMED and\n+                (self.message == b\"block\" or self.message == b\"tx\")):\n+            self.data = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = ser_string(self.message)\n+        r += struct.pack(\"<B\", self.code)\n+        r += ser_string(self.reason)\n+        if (self.code != self.REJECT_MALFORMED and\n+                (self.message == b\"block\" or self.message == b\"tx\")):\n+            r += ser_uint256(self.data)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reject: %s %d %s [%064x]\" \\\n+            % (self.message, self.code, self.reason, self.data)\n+\n+\n+class msg_feefilter():\n+    command = b\"feefilter\"\n+\n+    def __init__(self, feerate=0):\n+        self.feerate = feerate\n+\n+    def deserialize(self, f):\n+        self.feerate = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.feerate)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_feefilter(feerate=%08x)\" % self.feerate\n+\n+\n+class msg_sendcmpct():\n+    command = b\"sendcmpct\"\n+\n+    def __init__(self):\n+        self.announce = False\n+        self.version = 1\n+\n+    def deserialize(self, f):\n+        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.announce)\n+        r += struct.pack(\"<Q\", self.version)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n+\n+\n+class msg_cmpctblock():\n+    command = b\"cmpctblock\"\n+\n+    def __init__(self, header_and_shortids = None):\n+        self.header_and_shortids = header_and_shortids\n+\n+    def deserialize(self, f):\n+        self.header_and_shortids = P2PHeaderAndShortIDs()\n+        self.header_and_shortids.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.header_and_shortids.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n+\n+\n+class msg_getblocktxn():\n+    command = b\"getblocktxn\"\n+\n+    def __init__(self):\n+        self.block_txn_request = None\n+\n+    def deserialize(self, f):\n+        self.block_txn_request = BlockTransactionsRequest()\n+        self.block_txn_request.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_txn_request.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n+\n+\n+class msg_blocktxn():\n+    command = b\"blocktxn\"\n+\n+    def __init__(self):\n+        self.block_transactions = BlockTransactions()\n+\n+    def deserialize(self, f):\n+        self.block_transactions.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n+\n+\n+class msg_witness_blocktxn(msg_blocktxn):\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize(with_witness=True)\n+        return r"
      }
    ]
  },
  {
    "sha": "c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjN2JmMWZlYmJiNTQ4ZDgzNzBmMTg3MmUwYzBlOWZmODhmZTY2NTc5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T02:31:18Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Remove dead code from mininode.py\n\nRemoves the dead deliver_sleep_time and EarlyDisconnectError code",
      "tree": {
        "sha": "1bb33fbfd6664659279ffe3a3db9ba7139993e76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1bb33fbfd6664659279ffe3a3db9ba7139993e76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7bf1febbb548d8370f1872e0c0e9ff88fe66579/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "64d947b82df924c101f0fd00f4891177a2d0ed44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64d947b82df924c101f0fd00f4891177a2d0ed44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/64d947b82df924c101f0fd00f4891177a2d0ed44"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 5,
      "deletions": 32
    },
    "files": [
      {
        "sha": "654da3ebdcc18342fc1e05908ebbbd7a2741da2a",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 5,
        "deletions": 32,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7bf1febbb548d8370f1872e0c0e9ff88fe66579/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7bf1febbb548d8370f1872e0c0e9ff88fe66579/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
        "patch": "@@ -43,9 +43,7 @@ class NodeConnCB():\n     \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n \n     Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\n-    \"\"\"\n-\n+    if they want to alter message handling behaviour.\"\"\"\n     def __init__(self):\n         # Track whether we have a P2P connection open to the node\n         self.connected = False\n@@ -59,25 +57,13 @@ def __init__(self):\n         # A count of the number of ping messages we've sent to the node\n         self.ping_counter = 1\n \n-        # deliver_sleep_time is helpful for debugging race conditions in p2p\n-        # tests; it causes message delivery to sleep for the specified time\n-        # before acquiring the global lock and delivering the next message.\n-        self.deliver_sleep_time = None\n-\n     # Message receiving methods\n \n     def deliver(self, conn, message):\n         \"\"\"Receive message and dispatch message to appropriate callback.\n \n         We keep a count of how many of each message type has been received\n-        and the most recent message of each type.\n-\n-        Optionally waits for deliver_sleep_time before dispatching message.\n-        \"\"\"\n-\n-        deliver_sleep = self.get_deliver_sleep_time()\n-        if deliver_sleep is not None:\n-            time.sleep(deliver_sleep)\n+        and the most recent message of each type.\"\"\"\n         with mininode_lock:\n             try:\n                 command = message.command.decode('ascii')\n@@ -89,10 +75,6 @@ def deliver(self, conn, message):\n                                                     sys.exc_info()[0]))\n                 raise\n \n-    def get_deliver_sleep_time(self):\n-        with mininode_lock:\n-            return self.deliver_sleep_time\n-\n     # Callback methods. Can be overridden by subclasses in individual test\n     # cases to provide custom message handling behaviour.\n \n@@ -202,9 +184,10 @@ def sync_with_ping(self, timeout=60):\n         self.ping_counter += 1\n         return True\n \n-# The actual NodeConn class\n-# This class provides an interface for a p2p connection to a specified node\n class NodeConn(asyncore.dispatcher):\n+    \"\"\"The actual NodeConn class\n+\n+    This class provides an interface for a p2p connection to a specified node.\"\"\"\n     messagemap = {\n         b\"version\": msg_version,\n         b\"verack\": msg_verack,\n@@ -424,13 +407,3 @@ def run(self):\n             [ obj.handle_close() for obj in disconnected ]\n             asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n         logger.debug(\"Network thread closing\")\n-\n-\n-# An exception we can raise if we detect a potential disconnect\n-# (p2p or rpc) before the test is complete\n-class EarlyDisconnectError(Exception):\n-    def __init__(self, value):\n-        self.value = value\n-\n-    def __str__(self):\n-        return repr(self.value)"
      }
    ]
  },
  {
    "sha": "b8c6d95b528884d0d1043debf8a76f508cea547b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGM2ZDk1YjUyODg4NGQwZDEwNDNkZWJmOGE3NmY1MDhjZWE1NDdi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T11:57:37Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Remove support for bre-BIP31 ping messages\n\nBIP31 support was added to Bitcoin Core in version 0.6.1. Our test\nframework is incompatible with Bitcoin Core versions that old, so remove\nall special logic for handling pre-BIP31 pings.",
      "tree": {
        "sha": "022deb5ff80d523585e33c1820e43c7ce2a1c5d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/022deb5ff80d523585e33c1820e43c7ce2a1c5d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8c6d95b528884d0d1043debf8a76f508cea547b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8c6d95b528884d0d1043debf8a76f508cea547b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8c6d95b528884d0d1043debf8a76f508cea547b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8c6d95b528884d0d1043debf8a76f508cea547b/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7bf1febbb548d8370f1872e0c0e9ff88fe66579",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c7bf1febbb548d8370f1872e0c0e9ff88fe66579"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 1,
      "deletions": 22
    },
    "files": [
      {
        "sha": "dd9c3291666f61263a43e1f112eacf1d58ed6d61",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8c6d95b528884d0d1043debf8a76f508cea547b/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8c6d95b528884d0d1043debf8a76f508cea547b/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=b8c6d95b528884d0d1043debf8a76f508cea547b",
        "patch": "@@ -113,8 +113,7 @@ def on_inv(self, conn, message):\n             conn.send_message(want)\n \n     def on_ping(self, conn, message):\n-        if conn.ver_send > BIP0031_VERSION:\n-            conn.send_message(msg_pong(message.nonce))\n+        conn.send_message(msg_pong(message.nonce))\n \n     def on_verack(self, conn, message):\n         conn.ver_recv = conn.ver_send\n@@ -372,9 +371,6 @@ def send_message(self, message, pushbuf=False):\n             self.last_sent = time.time()\n \n     def got_message(self, message):\n-        if message.command == b\"version\":\n-            if message.nVersion <= BIP0031_VERSION:\n-                self.messagemap[b'ping'] = msg_ping_prebip31\n         if self.last_sent + 30 * 60 < time.time():\n             self.send_message(self.messagemap[b'ping']())\n         self._log_message(\"receive\", message)"
      },
      {
        "sha": "ae8abf5c5d9b4ddcbac7958859078e66feea976d",
        "filename": "test/functional/test_framework/primitives.py",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8c6d95b528884d0d1043debf8a76f508cea547b/test/functional/test_framework/primitives.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8c6d95b528884d0d1043debf8a76f508cea547b/test/functional/test_framework/primitives.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/primitives.py?ref=b8c6d95b528884d0d1043debf8a76f508cea547b",
        "patch": "@@ -25,7 +25,6 @@\n from test_framework.siphash import siphash256\n from test_framework.util import hex_str_to_bytes, bytes_to_hex_str\n \n-BIP0031_VERSION = 60000\n MY_VERSION = 70014  # past bip-31 for ping/pong\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n@@ -1157,22 +1156,6 @@ def __repr__(self):\n         return \"msg_getaddr()\"\n \n \n-class msg_ping_prebip31():\n-    command = b\"ping\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_ping() (pre-bip31)\"\n-\n-\n class msg_ping():\n     command = b\"ping\"\n "
      }
    ]
  },
  {
    "sha": "c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMGNhYTdiYTllZjkzMmFmZWNjODVhNjRmMWZmM2RhNjI3MGRmNmUx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T11:51:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Tidy up mininode.py module\n\nMostly move only. Adds a few extra comments.",
      "tree": {
        "sha": "7ed4d66482f26ddc6cd6c8f340a066da8eaeb486",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ed4d66482f26ddc6cd6c8f340a066da8eaeb486"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8c6d95b528884d0d1043debf8a76f508cea547b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8c6d95b528884d0d1043debf8a76f508cea547b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8c6d95b528884d0d1043debf8a76f508cea547b"
      }
    ],
    "stats": {
      "total": 174,
      "additions": 93,
      "deletions": 81
    },
    "files": [
      {
        "sha": "f3cc99adbe6b9e29edfe5f88d8aa65f76ce76a23",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 93,
        "deletions": 81,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
        "patch": "@@ -24,20 +24,38 @@\n from threading import RLock, Thread\n \n \n-logger = logging.getLogger(\"TestFramework.mininode\")\n-\n-# Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to workaround an issue with closing an asyncore socket when\n-# using select)\n-mininode_socket_map = dict()\n+messagemap = {\n+    b\"version\": msg_version,\n+    b\"verack\": msg_verack,\n+    b\"addr\": msg_addr,\n+    b\"alert\": msg_alert,\n+    b\"inv\": msg_inv,\n+    b\"getdata\": msg_getdata,\n+    b\"getblocks\": msg_getblocks,\n+    b\"tx\": msg_tx,\n+    b\"block\": msg_block,\n+    b\"getaddr\": msg_getaddr,\n+    b\"ping\": msg_ping,\n+    b\"pong\": msg_pong,\n+    b\"headers\": msg_headers,\n+    b\"getheaders\": msg_getheaders,\n+    b\"reject\": msg_reject,\n+    b\"mempool\": msg_mempool,\n+    b\"feefilter\": msg_feefilter,\n+    b\"sendheaders\": msg_sendheaders,\n+    b\"sendcmpct\": msg_sendcmpct,\n+    b\"cmpctblock\": msg_cmpctblock,\n+    b\"getblocktxn\": msg_getblocktxn,\n+    b\"blocktxn\": msg_blocktxn\n+}\n+\n+MAGIC_BYTES = {\n+    \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n+    \"testnet3\": b\"\\x0b\\x11\\x09\\x07\",  # testnet3\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n+}\n \n-# One lock for synchronizing all data access between the networking thread (see\n-# NetworkThread below) and the thread running the test logic.  For simplicity,\n-# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n-# and whenever adding anything to the send buffer (in send_message()).  This\n-# lock should be acquired in the thread running the test logic to synchronize\n-# access to any data shared with the NodeConnCB or NodeConn.\n-mininode_lock = RLock()\n+logger = logging.getLogger(\"TestFramework.mininode\")\n \n class NodeConnCB():\n     \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n@@ -187,36 +205,6 @@ class NodeConn(asyncore.dispatcher):\n     \"\"\"The actual NodeConn class\n \n     This class provides an interface for a p2p connection to a specified node.\"\"\"\n-    messagemap = {\n-        b\"version\": msg_version,\n-        b\"verack\": msg_verack,\n-        b\"addr\": msg_addr,\n-        b\"alert\": msg_alert,\n-        b\"inv\": msg_inv,\n-        b\"getdata\": msg_getdata,\n-        b\"getblocks\": msg_getblocks,\n-        b\"tx\": msg_tx,\n-        b\"block\": msg_block,\n-        b\"getaddr\": msg_getaddr,\n-        b\"ping\": msg_ping,\n-        b\"pong\": msg_pong,\n-        b\"headers\": msg_headers,\n-        b\"getheaders\": msg_getheaders,\n-        b\"reject\": msg_reject,\n-        b\"mempool\": msg_mempool,\n-        b\"feefilter\": msg_feefilter,\n-        b\"sendheaders\": msg_sendheaders,\n-        b\"sendcmpct\": msg_sendcmpct,\n-        b\"cmpctblock\": msg_cmpctblock,\n-        b\"getblocktxn\": msg_getblocktxn,\n-        b\"blocktxn\": msg_blocktxn\n-    }\n-    MAGIC_BYTES = {\n-        \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n-        \"testnet3\": b\"\\x0b\\x11\\x09\\x07\",  # testnet3\n-        \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n-    }\n-\n     def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.dstaddr = dstaddr\n@@ -252,6 +240,8 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n             self.handle_close()\n         self.rpc = rpc\n \n+    # Connection and disconnection methods\n+\n     def handle_connect(self):\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n@@ -269,44 +259,30 @@ def handle_close(self):\n             pass\n         self.cb.on_close(self)\n \n+    def disconnect_node(self):\n+        \"\"\"Disconnect the p2p connection.\n+\n+        Called by the test logic thread. Causes the p2p connection\n+        to be disconnected on the next iteration of the asyncore loop.\"\"\"\n+        self.disconnect = True\n+\n+    # Socket read methods\n+\n+    def readable(self):\n+        return True\n+\n     def handle_read(self):\n         t = self.recv(8192)\n         if len(t) > 0:\n             self.recvbuf += t\n             self.got_data()\n \n-    def readable(self):\n-        return True\n-\n-    def writable(self):\n-        with mininode_lock:\n-            pre_connection = self.state == \"connecting\"\n-            length = len(self.sendbuf)\n-        return (length > 0 or pre_connection)\n-\n-    def handle_write(self):\n-        with mininode_lock:\n-            # asyncore does not expose socket connection, only the first read/write\n-            # event, thus we must check connection manually here to know when we\n-            # actually connect\n-            if self.state == \"connecting\":\n-                self.handle_connect()\n-            if not self.writable():\n-                return\n-\n-            try:\n-                sent = self.send(self.sendbuf)\n-            except:\n-                self.handle_close()\n-                return\n-            self.sendbuf = self.sendbuf[sent:]\n-\n     def got_data(self):\n         try:\n             while True:\n                 if len(self.recvbuf) < 4:\n                     return\n-                if self.recvbuf[:4] != self.MAGIC_BYTES[self.network]:\n+                if self.recvbuf[:4] != MAGIC_BYTES[self.network]:\n                     raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n                 if self.ver_recv < 209:\n                     if len(self.recvbuf) < 4 + 12 + 4:\n@@ -332,9 +308,9 @@ def got_data(self):\n                     if checksum != h[:4]:\n                         raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n                     self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n-                if command in self.messagemap:\n+                if command in messagemap:\n                     f = BytesIO(msg)\n-                    t = self.messagemap[command]()\n+                    t = messagemap[command]()\n                     t.deserialize(f)\n                     self.got_message(t)\n                 else:\n@@ -344,13 +320,44 @@ def got_data(self):\n             logger.exception('got_data:', repr(e))\n             raise\n \n+    def got_message(self, message):\n+        if self.last_sent + 30 * 60 < time.time():\n+            self.send_message(messagemap[b'ping']())\n+        self._log_message(\"receive\", message)\n+        self.cb.deliver(self, message)\n+\n+    # Socket write methods\n+\n+    def writable(self):\n+        with mininode_lock:\n+            pre_connection = self.state == \"connecting\"\n+            length = len(self.sendbuf)\n+        return (length > 0 or pre_connection)\n+\n+    def handle_write(self):\n+        with mininode_lock:\n+            # asyncore does not expose socket connection, only the first read/write\n+            # event, thus we must check connection manually here to know when we\n+            # actually connect\n+            if self.state == \"connecting\":\n+                self.handle_connect()\n+            if not self.writable():\n+                return\n+\n+            try:\n+                sent = self.send(self.sendbuf)\n+            except:\n+                self.handle_close()\n+                return\n+            self.sendbuf = self.sendbuf[sent:]\n+\n     def send_message(self, message, pushbuf=False):\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n         self._log_message(\"send\", message)\n         command = message.command\n         data = message.serialize()\n-        tmsg = self.MAGIC_BYTES[self.network]\n+        tmsg = MAGIC_BYTES[self.network]\n         tmsg += command\n         tmsg += b\"\\x00\" * (12 - len(command))\n         tmsg += struct.pack(\"<I\", len(data))\n@@ -370,11 +377,7 @@ def send_message(self, message, pushbuf=False):\n                 self.sendbuf += tmsg\n             self.last_sent = time.time()\n \n-    def got_message(self, message):\n-        if self.last_sent + 30 * 60 < time.time():\n-            self.send_message(self.messagemap[b'ping']())\n-        self._log_message(\"receive\", message)\n-        self.cb.deliver(self, message)\n+    # Class utility methods\n \n     def _log_message(self, direction, msg):\n         if direction == \"send\":\n@@ -386,9 +389,18 @@ def _log_message(self, direction, msg):\n             log_message += \"... (msg truncated)\"\n         logger.debug(log_message)\n \n-    def disconnect_node(self):\n-        self.disconnect = True\n+# Keep our own socket map for asyncore, so that we can track disconnects\n+# ourselves (to workaround an issue with closing an asyncore socket when\n+# using select)\n+mininode_socket_map = dict()\n \n+# One lock for synchronizing all data access between the networking thread (see\n+# NetworkThread below) and the thread running the test logic.  For simplicity,\n+# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n+# and whenever adding anything to the send buffer (in send_message()).  This\n+# lock should be acquired in the thread running the test logic to synchronize\n+# access to any data shared with the NodeConnCB or NodeConn.\n+mininode_lock = RLock()\n \n class NetworkThread(Thread):\n     def run(self):\n@@ -400,6 +412,6 @@ def run(self):\n             for fd, obj in mininode_socket_map.items():\n                 if obj.disconnect:\n                     disconnected.append(obj)\n-            [ obj.handle_close() for obj in disconnected ]\n+            [obj.handle_close() for obj in disconnected]\n             asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n         logger.debug(\"Network thread closing\")"
      }
    ]
  },
  {
    "sha": "999167764b22fc7a527723931437bf5ba22fb56c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTkxNjc3NjRiMjJmYzdhNTI3NzIzOTMxNDM3YmY1YmEyMmZiNTZj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T14:59:20Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Explicitly disallow support for p2p versions below 60001\n\nThe mininode module includes code to support p2p versions below\n60001. However, the test_framework does not support versions\nof Bitcoin Core before V0.13.0. Remove code supporting\np2p versions before 60001 (which has never been run).",
      "tree": {
        "sha": "1eb937c6c57134d541fd33f89aa8c13cca48b4cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1eb937c6c57134d541fd33f89aa8c13cca48b4cc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/999167764b22fc7a527723931437bf5ba22fb56c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999167764b22fc7a527723931437bf5ba22fb56c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/999167764b22fc7a527723931437bf5ba22fb56c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999167764b22fc7a527723931437bf5ba22fb56c/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c0caa7ba9ef932afecc85a64f1ff3da6270df6e1"
      }
    ],
    "stats": {
      "total": 75,
      "additions": 29,
      "deletions": 46
    },
    "files": [
      {
        "sha": "6944226216c75666c98d9d80aaac036d9b4754f8",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 29,
        "deletions": 46,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/999167764b22fc7a527723931437bf5ba22fb56c/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/999167764b22fc7a527723931437bf5ba22fb56c/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=999167764b22fc7a527723931437bf5ba22fb56c",
        "patch": "@@ -23,6 +23,10 @@\n import time\n from threading import RLock, Thread\n \n+from test_framework.primitives import *\n+from test_framework.util import wait_until\n+\n+MIN_VERSION_SUPPORTED = 60001\n \n messagemap = {\n     b\"version\": msg_version,\n@@ -134,15 +138,11 @@ def on_ping(self, conn, message):\n         conn.send_message(msg_pong(message.nonce))\n \n     def on_verack(self, conn, message):\n-        conn.ver_recv = conn.ver_send\n         self.verack_received = True\n \n     def on_version(self, conn, message):\n-        if message.nVersion >= 209:\n-            conn.send_message(msg_verack())\n-        conn.ver_send = min(MY_VERSION, message.nVersion)\n-        if message.nVersion < 209:\n-            conn.ver_recv = conn.ver_send\n+        assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n+        conn.send_message(msg_verack())\n         conn.nServices = message.nServices\n \n     # Connection helper methods\n@@ -213,8 +213,6 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n         self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n         self.sendbuf = b\"\"\n         self.recvbuf = b\"\"\n-        self.ver_send = 209\n-        self.ver_recv = 209\n         self.last_sent = 0\n         self.state = \"connecting\"\n         self.network = net\n@@ -284,41 +282,27 @@ def got_data(self):\n                     return\n                 if self.recvbuf[:4] != MAGIC_BYTES[self.network]:\n                     raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n-                if self.ver_recv < 209:\n-                    if len(self.recvbuf) < 4 + 12 + 4:\n-                        return\n-                    command = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                    msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                    checksum = None\n-                    if len(self.recvbuf) < 4 + 12 + 4 + msglen:\n-                        return\n-                    msg = self.recvbuf[4+12+4:4+12+4+msglen]\n-                    self.recvbuf = self.recvbuf[4+12+4+msglen:]\n-                else:\n-                    if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                        return\n-                    command = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                    msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                    checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                    if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                        return\n-                    msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                    th = sha256(msg)\n-                    h = sha256(th)\n-                    if checksum != h[:4]:\n-                        raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                    self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n-                if command in messagemap:\n-                    f = BytesIO(msg)\n-                    t = messagemap[command]()\n-                    t.deserialize(f)\n-                    self.got_message(t)\n-                else:\n-                    logger.warning(\"Received unknown command from %s:%d: '%s' %s\" % (self.dstaddr, self.dstport, command, repr(msg)))\n-                    raise ValueError(\"Unknown command: '%s'\" % (command))\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = self.recvbuf[4+12+4:4+12+4+4]\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n+                th = sha256(msg)\n+                h = sha256(th)\n+                if checksum != h[:4]:\n+                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n+                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if command not in messagemap:\n+                    raise ValueError(\"Received unknown command from %s:%d: '%s' %s\" % (self.dstaddr, self.dstport, command, repr(msg)))\n+                f = BytesIO(msg)\n+                t = messagemap[command]()\n+                t.deserialize(f)\n+                self.got_message(t)\n         except Exception as e:\n-            logger.exception('got_data:', repr(e))\n-            raise\n+            logger.exception('Error reading message:', repr(e))\n \n     def got_message(self, message):\n         if self.last_sent + 30 * 60 < time.time():\n@@ -361,10 +345,9 @@ def send_message(self, message, pushbuf=False):\n         tmsg += command\n         tmsg += b\"\\x00\" * (12 - len(command))\n         tmsg += struct.pack(\"<I\", len(data))\n-        if self.ver_send >= 209:\n-            th = sha256(data)\n-            h = sha256(th)\n-            tmsg += h[:4]\n+        th = sha256(data)\n+        h = sha256(th)\n+        tmsg += h[:4]\n         tmsg += data\n         with mininode_lock:\n             if (len(self.sendbuf) == 0 and not pushbuf):"
      }
    ]
  },
  {
    "sha": "f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNWE4YzVkMGE0ZTczNzk5OTM4YTEwY2Q0ZGFkODE5ZTZlMGYxNTBh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T15:01:37Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Remove support for p2p alert messages\n\nAlert messages were removed in p2p version 70013 (Bitcoin Core V0.13.0)",
      "tree": {
        "sha": "dade544faa4eef5b76bb50acb31ed52039f68c5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dade544faa4eef5b76bb50acb31ed52039f68c5d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "999167764b22fc7a527723931437bf5ba22fb56c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999167764b22fc7a527723931437bf5ba22fb56c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/999167764b22fc7a527723931437bf5ba22fb56c"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 0,
      "deletions": 97
    },
    "files": [
      {
        "sha": "f6dfd1fe23add3ba070a39131a45474ac222bb4f",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
        "patch": "@@ -39,7 +39,6 @@ def on_verack(self, conn, message): self.bad_message(message)\n     def on_reject(self, conn, message): self.bad_message(message)\n     def on_inv(self, conn, message): self.bad_message(message)\n     def on_addr(self, conn, message): self.bad_message(message)\n-    def on_alert(self, conn, message): self.bad_message(message)\n     def on_getdata(self, conn, message): self.bad_message(message)\n     def on_getblocks(self, conn, message): self.bad_message(message)\n     def on_tx(self, conn, message): self.bad_message(message)"
      },
      {
        "sha": "30ac05747762bd8387af23e2e175a953bd01e7f8",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
        "patch": "@@ -32,7 +32,6 @@\n     b\"version\": msg_version,\n     b\"verack\": msg_verack,\n     b\"addr\": msg_addr,\n-    b\"alert\": msg_alert,\n     b\"inv\": msg_inv,\n     b\"getdata\": msg_getdata,\n     b\"getblocks\": msg_getblocks,\n@@ -108,7 +107,6 @@ def on_close(self, conn):\n         self.connection = None\n \n     def on_addr(self, conn, message): pass\n-    def on_alert(self, conn, message): pass\n     def on_block(self, conn, message): pass\n     def on_blocktxn(self, conn, message): pass\n     def on_cmpctblock(self, conn, message): pass"
      },
      {
        "sha": "47a462b64dc231499be680c2616bdb118445ba25",
        "filename": "test/functional/test_framework/primitives.py",
        "status": "modified",
        "additions": 0,
        "deletions": 94,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/test_framework/primitives.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a/test/functional/test_framework/primitives.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/primitives.py?ref=f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
        "patch": "@@ -628,81 +628,6 @@ def __repr__(self):\n                time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n \n \n-class CUnsignedAlert():\n-    def __init__(self):\n-        self.nVersion = 1\n-        self.nRelayUntil = 0\n-        self.nExpiration = 0\n-        self.nID = 0\n-        self.nCancel = 0\n-        self.setCancel = []\n-        self.nMinVer = 0\n-        self.nMaxVer = 0\n-        self.setSubVer = []\n-        self.nPriority = 0\n-        self.strComment = b\"\"\n-        self.strStatusBar = b\"\"\n-        self.strReserved = b\"\"\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n-        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n-        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n-        self.setCancel = deser_int_vector(f)\n-        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n-        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n-        self.setSubVer = deser_string_vector(f)\n-        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n-        self.strComment = deser_string(f)\n-        self.strStatusBar = deser_string(f)\n-        self.strReserved = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += struct.pack(\"<q\", self.nRelayUntil)\n-        r += struct.pack(\"<q\", self.nExpiration)\n-        r += struct.pack(\"<i\", self.nID)\n-        r += struct.pack(\"<i\", self.nCancel)\n-        r += ser_int_vector(self.setCancel)\n-        r += struct.pack(\"<i\", self.nMinVer)\n-        r += struct.pack(\"<i\", self.nMaxVer)\n-        r += ser_string_vector(self.setSubVer)\n-        r += struct.pack(\"<i\", self.nPriority)\n-        r += ser_string(self.strComment)\n-        r += ser_string(self.strStatusBar)\n-        r += ser_string(self.strReserved)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n-            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n-               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n-               self.strComment, self.strStatusBar, self.strReserved)\n-\n-\n-class CAlert():\n-    def __init__(self):\n-        self.vchMsg = b\"\"\n-        self.vchSig = b\"\"\n-\n-    def deserialize(self, f):\n-        self.vchMsg = deser_string(f)\n-        self.vchSig = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_string(self.vchMsg)\n-        r += ser_string(self.vchSig)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n-            % (len(self.vchMsg), len(self.vchSig))\n-\n-\n class PrefilledTransaction():\n     def __init__(self, index=0, tx = None):\n         self.index = index\n@@ -1017,25 +942,6 @@ def __repr__(self):\n         return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n \n \n-class msg_alert():\n-    command = b\"alert\"\n-\n-    def __init__(self):\n-        self.alert = CAlert()\n-\n-    def deserialize(self, f):\n-        self.alert = CAlert()\n-        self.alert.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.alert.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n-\n-\n class msg_inv():\n     command = b\"inv\"\n "
      }
    ]
  },
  {
    "sha": "333012d5487a526f8917fe6b841c933c88511cb9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzMwMTJkNTQ4N2E1MjZmODkxN2ZlNmI4NDFjOTMzYzg4NTExY2I5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T12:02:15Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Remove rpc property from NodeConn.\n\nIt's only used in a helper method in p2p-segwit.py.\n\nChange that helper method to a function which takes a node and a p2p\nconnection as arguments.",
      "tree": {
        "sha": "6681c790d90d32f2e0737621203b517f96bcb6b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6681c790d90d32f2e0737621203b517f96bcb6b7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/333012d5487a526f8917fe6b841c933c88511cb9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/333012d5487a526f8917fe6b841c933c88511cb9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/333012d5487a526f8917fe6b841c933c88511cb9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/333012d5487a526f8917fe6b841c933c88511cb9/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f5a8c5d0a4e73799938a10cd4dad819e6e0f150a"
      }
    ],
    "stats": {
      "total": 274,
      "additions": 140,
      "deletions": 134
    },
    "files": [
      {
        "sha": "0aad688bc790dc5dab4e6a87df8de459cac2a5e1",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 137,
        "deletions": 130,
        "changes": 267,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=333012d5487a526f8917fe6b841c933c88511cb9",
        "patch": "@@ -31,6 +31,34 @@ def get_virtual_size(witness_block):\n     vsize = int((3*base_size + total_size + 3)/4)\n     return vsize\n \n+def test_transaction_acceptance(node, p2p, tx, with_witness, accepted, reason=None):\n+    \"\"\"Send a transaction to the node and check that it's accepted to the mempool\n+\n+    - Submit the transaction over the p2p interface\n+    - use the getrawmempool rpc to check for acceptance.\"\"\"\n+    tx_message = msg_tx(tx)\n+    if with_witness:\n+        tx_message = msg_witness_tx(tx)\n+    p2p.send_message(tx_message)\n+    p2p.sync_with_ping()\n+    assert_equal(tx.hash in node.getrawmempool(), accepted)\n+    if (reason != None and not accepted):\n+        # Check the rejection reason as well.\n+        with mininode_lock:\n+            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+\n+def test_witness_block(node, p2p, block, accepted, with_witness=True):\n+    \"\"\"Send a block to the node and check that it's accepted\n+\n+    - Submit the block over the p2p interface\n+    - use the getbestblockhash rpc to check for acceptance.\"\"\"\n+    if with_witness:\n+        node.send_message(msg_witness_block(block))\n+    else:\n+        node.send_message(msg_block(block))\n+    p2p.sync_with_ping()\n+    assert_equal(node.rpc.getbestblockhash() == block.hash, accepted)\n+\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n@@ -67,27 +95,6 @@ def request_block(self, blockhash, inv_type, timeout=60):\n         self.wait_for_block(blockhash, timeout)\n         return self.last_message[\"block\"].block\n \n-    def test_transaction_acceptance(self, tx, with_witness, accepted, reason=None):\n-        tx_message = msg_tx(tx)\n-        if with_witness:\n-            tx_message = msg_witness_tx(tx)\n-        self.send_message(tx_message)\n-        self.sync_with_ping()\n-        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n-        if (reason != None and not accepted):\n-            # Check the rejection reason as well.\n-            with mininode_lock:\n-                assert_equal(self.last_message[\"reject\"].reason, reason)\n-\n-    # Test whether a witness block had the correct effect on the tip\n-    def test_witness_block(self, block, accepted, with_witness=True):\n-        if with_witness:\n-            self.send_message(msg_witness_block(block))\n-        else:\n-            self.send_message(msg_block(block))\n-        self.sync_with_ping()\n-        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n-\n # Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO():\n     def __init__(self, sha256, n, nValue):\n@@ -199,7 +206,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n         # TODO: fix synchronization so we can test reject reason\n         # Right now, bitcoind delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n@@ -226,7 +233,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n         tx2.rehash()\n-        self.test_node.test_transaction_acceptance(tx2, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, False, True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -243,18 +250,18 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         tx3.rehash()\n         # Note that this should be rejected for the premature witness reason,\n         # rather than a policy check, since segwit hasn't activated yet.\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'no-witness-yet')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'no-witness-yet')\n \n         # If we send without witness, it should be accepted.\n-        self.std_node.test_transaction_acceptance(tx3, False, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, False, True)\n \n         # Now create a new anyone-can-spend utxo for the next test.\n         tx4 = CTransaction()\n         tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), CScript([p2sh_program])))\n         tx4.vout.append(CTxOut(tx3.vout[0].nValue-1000, CScript([OP_TRUE])))\n         tx4.rehash()\n-        self.test_node.test_transaction_acceptance(tx3, False, True)\n-        self.test_node.test_transaction_acceptance(tx4, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, False, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, False, True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -315,7 +322,7 @@ def test_witness_commitments(self):\n         assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n \n         # This empty block should be valid.\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Try to tweak the nonce\n         block_2 = self.build_next_block()\n@@ -326,7 +333,7 @@ def test_witness_commitments(self):\n         assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n \n         # This should also be valid.\n-        self.test_node.test_witness_block(block_2, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_2, accepted=True)\n \n         # Now test commitments with actual transactions\n         assert (len(self.utxo) > 0)\n@@ -359,7 +366,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         block_3.solve()\n \n-        self.test_node.test_witness_block(block_3, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=False)\n \n         # Add a different commitment with different nonce, but in the\n         # right location, and with some funds burned(!).\n@@ -373,7 +380,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n         block_3.solve()\n-        self.test_node.test_witness_block(block_3, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=True)\n \n         # Finally test that a block with no witness transactions can\n         # omit the commitment.\n@@ -385,7 +392,7 @@ def test_witness_commitments(self):\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n         block_4.solve()\n-        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_4, with_witness=False, accepted=True)\n \n         # Update available utxo's for use in later test.\n         self.utxo.pop(0)\n@@ -426,11 +433,11 @@ def test_block_malleability(self):\n         # Change the nonce -- should not cause the block to be permanently\n         # failed\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Changing the witness nonce doesn't change the block hash\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n \n     def test_witness_block_size(self):\n@@ -495,7 +502,7 @@ def test_witness_block_size(self):\n         # limit\n         assert(len(block.serialize(True)) > 2*1024*1024)\n \n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now resize the second transaction to make the block fit.\n         cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n@@ -505,7 +512,7 @@ def test_witness_block_size(self):\n         block.solve()\n         assert(get_virtual_size(block) == MAX_BLOCK_BASE_SIZE)\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update available utxo's\n         self.utxo.pop(0)\n@@ -572,7 +579,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx])\n \n         # Extra witness data should not be allowed.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Try extra signature data.  Ok if we're not spending a witness output.\n         block.vtx[1].wit.vtxinwit = []\n@@ -581,7 +588,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now try extra witness/signature data on an input that DOES require a\n         # witness\n@@ -597,7 +604,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx2])\n \n         # This has extra witness data, so it should fail.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now get rid of the extra witness, but add extra scriptSig data\n         tx2.vin[0].scriptSig = CScript([OP_TRUE])\n@@ -609,7 +616,7 @@ def test_extra_witness_data(self):\n         block.solve()\n \n         # This has extra signature data for a witness input, so it should fail.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now get rid of the extra scriptsig on the witness input, and verify\n         # success (even with extra scriptsig data in the non-witness input)\n@@ -618,7 +625,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update utxo for later tests\n         self.utxo.pop(0)\n@@ -651,14 +658,14 @@ def test_max_witness_push_length(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now reduce the length of the stack element\n         tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n \n         add_witness_commitment(block)\n         block.solve()\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Update the utxo for later tests\n         self.utxo.pop()\n@@ -693,7 +700,7 @@ def test_max_witness_program_length(self):\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Try again with one less byte in the witness program\n         witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n@@ -708,7 +715,7 @@ def test_max_witness_program_length(self):\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -734,7 +741,7 @@ def test_witness_input_length(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Try various ways to spend tx that should all break.\n         # This \"broken\" transaction serializer will not normalize\n@@ -769,15 +776,15 @@ def serialize_with_witness(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now try using a too short vtxinwit\n         tx2.wit.vtxinwit.pop()\n         tx2.wit.vtxinwit.pop()\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n@@ -786,13 +793,13 @@ def serialize_with_witness(self):\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Fix the broken witness and the block should be accepted.\n         tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -832,11 +839,11 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # its from)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.old_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=False)\n \n         # But eliminating the witness should fix it\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n@@ -868,11 +875,11 @@ def test_tx_relay_after_segwit_activation(self):\n         # Verify that unnecessary witnesses are rejected.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=False)\n \n         # Verify that removing the witness succeeds.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n         witness_program = CScript([OP_TRUE])\n@@ -897,24 +904,24 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE]))\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n         tx3.rehash()\n \n-        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n         self.old_node.wait_for_inv([CInv(1, tx2.sha256)]) # wait until tx2 was inv'ed\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n         self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n         # Test that getrawtransaction returns correct witness information\n@@ -953,20 +960,20 @@ def test_block_relay(self, segwit_activated):\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block1, True)\n+        test_witness_block(self.nodes[0], self.test_node, block1, True)\n \n         block2 = self.build_next_block(nVersion=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block2, True)\n+        test_witness_block(self.nodes[0], self.test_node, block2, True)\n \n         block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block3, True)\n+        test_witness_block(self.nodes[0], self.test_node, block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n@@ -996,7 +1003,7 @@ def test_block_relay(self, segwit_activated):\n             # This gives us a witness commitment.\n             assert(len(block.vtx[0].wit.vtxinwit) == 1)\n             assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n             # Now try to retrieve it...\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n             non_wit_block = self.test_node.request_block(block.sha256, 2)\n@@ -1050,7 +1057,7 @@ def test_standardness_v0(self, segwit_activated):\n         p2sh_tx.rehash()\n \n         # Mine it on test_node to create the confirmed output.\n-        self.test_node.test_transaction_acceptance(p2sh_tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_tx, with_witness=True, accepted=True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -1062,7 +1069,7 @@ def test_standardness_v0(self, segwit_activated):\n         tx.vout.append(CTxOut(8000, scriptPubKey)) # Might burn this later\n         tx.rehash()\n \n-        self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=segwit_activated)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n         scriptPubKey = CScript([OP_0, hash160(witness_hash)])\n@@ -1079,7 +1086,7 @@ def test_standardness_v0(self, segwit_activated):\n             tx2.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, scriptPubKey)]\n         tx2.rehash()\n \n-        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=segwit_activated)\n \n         # Now update self.utxo for later tests.\n         tx3 = CTransaction()\n@@ -1092,13 +1099,13 @@ def test_standardness_v0(self, segwit_activated):\n             tx3.wit.vtxinwit.append(CTxInWitness())\n             tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n             tx3.rehash()\n-            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n         else:\n             # tx and tx2 didn't go anywhere; just clean up the p2sh_tx output.\n             tx3.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n             tx3.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, witness_program)]\n             tx3.rehash()\n-            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1122,7 +1129,7 @@ def test_segwit_versions(self):\n             tx.rehash()\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [tx])\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n             self.utxo.pop(0)\n             for i in range(NUM_TESTS):\n                 self.utxo.append(UTXO(tx.sha256, i, split_value))\n@@ -1141,8 +1148,8 @@ def test_segwit_versions(self):\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n             tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n             tx.rehash()\n-            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n-            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=False)\n+            test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=True)\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n@@ -1161,8 +1168,8 @@ def test_segwit_versions(self):\n         tx2.rehash()\n         # Gets accepted to test_node, because standardness of outputs isn't\n         # checked with fRequireStandard\n-        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n-        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=False)\n         temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n         temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n@@ -1178,15 +1185,15 @@ def test_segwit_versions(self):\n         tx3.rehash()\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n         self.test_node.sync_with_ping()\n         with mininode_lock:\n             assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2, tx3])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n \n         # Add utxo to our list\n@@ -1204,7 +1211,7 @@ def test_premature_coinbase_witness_spend(self):\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n         self.update_witness_block_with_transactions(block, [])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         spend_tx = CTransaction()\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n@@ -1218,13 +1225,13 @@ def test_premature_coinbase_witness_spend(self):\n         sync_blocks(self.nodes)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        self.test_node.test_witness_block(block2, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block2, accepted=False)\n \n         # Advancing one more block should allow the spend.\n         self.nodes[0].generate(1)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        self.test_node.test_witness_block(block2, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n \n@@ -1245,11 +1252,11 @@ def test_signature_version_1(self):\n         tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n         tx.rehash()\n \n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=True)\n         # Mine this transaction in preparation for following tests.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n         self.utxo.pop(0)\n \n@@ -1266,19 +1273,19 @@ def test_signature_version_1(self):\n                 # Too-large input value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue+1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=False)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Too-small input value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue-1, key)\n                 block.vtx.pop() # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=False)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Now try correct value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=True)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n                 prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n \n@@ -1302,7 +1309,7 @@ def test_signature_version_1(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         block = self.build_next_block()\n         used_sighash_single_out_of_bounds = False\n@@ -1344,15 +1351,15 @@ def test_signature_version_1(self):\n             # Test the block periodically, if we're close to maxblocksize\n             if (get_virtual_size(block) > MAX_BLOCK_BASE_SIZE - 1000):\n                 self.update_witness_block_with_transactions(block, [])\n-                self.test_node.test_witness_block(block, accepted=True)\n+                test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n                 block = self.build_next_block()\n \n         if (not used_sighash_single_out_of_bounds):\n             self.log.info(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n         # Test the transactions we've added to the block\n         if (len(block.vtx) > 1):\n             self.update_witness_block_with_transactions(block, [])\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now test witness version 0 P2PKH transactions\n         pubkeyhash = hash160(pubkey)\n@@ -1374,7 +1381,7 @@ def test_signature_version_1(self):\n         tx2.vin[0].scriptSig = CScript([signature, pubkey])\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Move the signature to the witness.\n         block.vtx.pop()\n@@ -1384,7 +1391,7 @@ def test_signature_version_1(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         temp_utxos.pop(0)\n \n@@ -1403,7 +1410,7 @@ def test_signature_version_1(self):\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n@@ -1430,10 +1437,10 @@ def test_p2sh_witness(self, segwit_activated):\n         tx.rehash()\n \n         # Verify mempool acceptance and block validity\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True, with_witness=segwit_activated)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=segwit_activated)\n         sync_blocks(self.nodes)\n \n         # Now test attempts to spend the output.\n@@ -1447,12 +1454,12 @@ def test_p2sh_witness(self, segwit_activated):\n         # will require a witness to spend a witness program regardless of\n         # segwit activation.  Note that older bitcoind's that are not\n         # segwit-aware would also reject this for failing CLEANSTACK.\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Try to put the witness script in the scriptSig, should also fail.\n         spend_tx.vin[0].scriptSig = CScript([p2wsh_pubkey, b'a'])\n         spend_tx.rehash()\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Now put the witness script in the witness, should succeed after\n         # segwit activates.\n@@ -1462,17 +1469,17 @@ def test_p2sh_witness(self, segwit_activated):\n         spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a', witness_program ]\n \n         # Verify mempool acceptance\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [spend_tx])\n \n         # If we're before activation, then sending this without witnesses\n         # should be valid.  If we're after activation, then sending this with\n         # witnesses should be valid.\n         if segwit_activated:\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         else:\n-            self.test_node.test_witness_block(block, accepted=True, with_witness=False)\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=False)\n \n         # Update self.utxo\n         self.utxo.pop(0)\n@@ -1556,7 +1563,7 @@ def test_witness_sigops(self):\n \n         block_1 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_1, [tx])\n-        self.test_node.test_witness_block(block_1, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_1, accepted=True)\n \n         tx2 = CTransaction()\n         # If we try to spend the first n-1 outputs from tx, that should be\n@@ -1573,7 +1580,7 @@ def test_witness_sigops(self):\n \n         block_2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_2, [tx2])\n-        self.test_node.test_witness_block(block_2, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_2, accepted=False)\n \n         # Try dropping the last input in tx2, and add an output that has\n         # too many sigops (contributing to legacy sigop count).\n@@ -1586,14 +1593,14 @@ def test_witness_sigops(self):\n         tx2.rehash()\n         block_3 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_3, [tx2])\n-        self.test_node.test_witness_block(block_3, accepted=False)\n+        test_witness_block(self.nodes[0], self.test_node, block_3, accepted=False)\n \n         # If we drop the last checksig in this output, the tx should succeed.\n         block_4 = self.build_next_block()\n         tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG]*(checksig_count-1))\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_4, [tx2])\n-        self.test_node.test_witness_block(block_4, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_4, accepted=True)\n \n         # Reset the tip back down for the next test\n         sync_blocks(self.nodes)\n@@ -1609,7 +1616,7 @@ def test_witness_sigops(self):\n         tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_justright ]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n-        self.test_node.test_witness_block(block_5, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block_5, accepted=True)\n \n         # TODO: test p2sh sigop counting\n \n@@ -1687,7 +1694,7 @@ def test_uncompressed_pubkey(self):\n         # Confirm it in a block.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Now try to spend it. Send it to a P2WSH output, which we'll\n         # use in the next test.\n@@ -1706,11 +1713,11 @@ def test_uncompressed_pubkey(self):\n         tx2.rehash()\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 2: P2WSH\n         # Try to spend the P2WSH output created in last test.\n@@ -1726,11 +1733,11 @@ def test_uncompressed_pubkey(self):\n         sign_P2PK_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx3])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 3: P2SH(P2WSH)\n         # Try to spend the P2SH output created in the last test.\n@@ -1743,10 +1750,10 @@ def test_uncompressed_pubkey(self):\n         sign_P2PK_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx4])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n         # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n         # transactions.\n@@ -1758,10 +1765,10 @@ def test_uncompressed_pubkey(self):\n         tx5.vin[0].scriptSig = CScript([signature, pubkey])\n         tx5.rehash()\n         # Should pass policy and consensus.\n-        self.test_node.test_transaction_acceptance(tx5, True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx5, True, True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx5])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n     def test_non_standard_witness(self):\n@@ -1791,7 +1798,7 @@ def test_non_standard_witness(self):\n             tx.vout.append(CTxOut(outputvalue, CScript([OP_HASH160, p2sh, OP_EQUAL])))\n         tx.rehash()\n         txid = tx.sha256\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1816,45 +1823,45 @@ def test_non_standard_witness(self):\n         # Testing native P2WSH\n         # Witness stack size, excluding witnessScript, over 100 is non-standard\n         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, True)\n \n         # witnessScript size at 3600 bytes is standard\n         p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[2], True, True)\n \n         # witnessScript size at 3601 bytes is non-standard\n         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n-        self.std_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)\n         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n         self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n         # Valid but non-standard transactions in a block should be accepted by standard node"
      },
      {
        "sha": "fa2117f01c538d910b141fed41698bae29fe9242",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=333012d5487a526f8917fe6b841c933c88511cb9",
        "patch": "@@ -177,7 +177,7 @@ def add_all_connections(self, nodes):\n             # Create a p2p connection to each node\n             test_node = TestNode(self.block_store, self.tx_store)\n             self.test_nodes.append(test_node)\n-            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), nodes[i], test_node))\n+            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), test_node))\n             # Make sure the TestNode (callback class) has a reference to its\n             # associated NodeConn\n             test_node.add_connection(self.connections[-1])"
      },
      {
        "sha": "f4194af9337d7c8342777a0ed92342cf78fd3e58",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=333012d5487a526f8917fe6b841c933c88511cb9",
        "patch": "@@ -203,7 +203,7 @@ class NodeConn(asyncore.dispatcher):\n     \"\"\"The actual NodeConn class\n \n     This class provides an interface for a p2p connection to a specified node.\"\"\"\n-    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+    def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n@@ -234,7 +234,6 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n             self.connect((dstaddr, dstport))\n         except:\n             self.handle_close()\n-        self.rpc = rpc\n \n     # Connection and disconnection methods\n "
      },
      {
        "sha": "7d12a1cab4af2a892b351d263c716bfd71cecaaa",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/333012d5487a526f8917fe6b841c933c88511cb9/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=333012d5487a526f8917fe6b841c933c88511cb9",
        "patch": "@@ -173,7 +173,7 @@ def add_p2p_connection(self, p2p_conn_type, dstaddr='127.0.0.1', dstport=None, s\n             dstport = p2p_port(self.index)\n         p2p_conn = p2p_conn_type()\n         self.p2ps.append(p2p_conn)\n-        p2p_conn.add_connection(NodeConn(dstaddr, dstport, self.rpc, p2p_conn, services=services, send_version=send_version))\n+        p2p_conn.add_connection(NodeConn(dstaddr, dstport, p2p_conn, services=services, send_version=send_version))\n \n         return p2p_conn\n "
      }
    ]
  },
  {
    "sha": "dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWI5ZTIyYjgyMmVlZmRjNGFjZGQ5YWUxYmNhM2QxNzRiNzU5OWQ3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T17:21:27Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] use add_p2p_connection in p2p-fingerprint.py",
      "tree": {
        "sha": "0af31268712b415a61daa0f407f11af07b19bb4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0af31268712b415a61daa0f407f11af07b19bb4e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "333012d5487a526f8917fe6b841c933c88511cb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/333012d5487a526f8917fe6b841c933c88511cb9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/333012d5487a526f8917fe6b841c933c88511cb9"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 24,
      "deletions": 32
    },
    "files": [
      {
        "sha": "a3e123009c18be4e85a8017064be4c3741dc0cc0",
        "filename": "test/functional/p2p-fingerprint.py",
        "status": "modified",
        "additions": 24,
        "deletions": 32,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7/test/functional/p2p-fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7/test/functional/p2p-fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-fingerprint.py?ref=dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
        "patch": "@@ -14,7 +14,6 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConn,\n     NodeConnCB,\n     msg_headers,\n     msg_block,\n@@ -23,10 +22,7 @@\n     wait_until,\n )\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    p2p_port,\n-)\n+from test_framework.util import assert_equal\n \n class P2PFingerprintTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -77,14 +73,10 @@ def last_header_equals(self, expected_hash, node):\n     # This does not currently test that stale blocks timestamped within the\n     # last month but that have over a month's worth of work are also withheld.\n     def run_test(self):\n-        node0 = NodeConnCB()\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        p2p = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n \n         NetworkThread().start()\n-        node0.wait_for_verack()\n+        p2p.wait_for_verack()\n \n         # Set node time to 60 days ago\n         self.nodes[0].setmocktime(int(time.time()) - 60 * 24 * 60 * 60)\n@@ -99,24 +91,24 @@ def run_test(self):\n         new_blocks = self.build_chain(5, block_hash, height, block_time)\n \n         # Force reorg to a longer chain\n-        node0.send_message(msg_headers(new_blocks))\n-        node0.wait_for_getdata()\n+        p2p.send_message(msg_headers(new_blocks))\n+        p2p.wait_for_getdata()\n         for block in new_blocks:\n-            node0.send_and_ping(msg_block(block))\n+            p2p.send_and_ping(msg_block(block))\n \n         # Check that reorg succeeded\n         assert_equal(self.nodes[0].getblockcount(), 13)\n \n         stale_hash = int(block_hashes[-1], 16)\n \n         # Check that getdata request for stale block succeeds\n-        self.send_block_request(stale_hash, node0)\n-        test_function = lambda: self.last_block_equals(stale_hash, node0)\n+        self.send_block_request(stale_hash, p2p)\n+        test_function = lambda: self.last_block_equals(stale_hash, p2p)\n         wait_until(test_function, timeout=3)\n \n         # Check that getheader request for stale block header succeeds\n-        self.send_header_request(stale_hash, node0)\n-        test_function = lambda: self.last_header_equals(stale_hash, node0)\n+        self.send_header_request(stale_hash, p2p)\n+        test_function = lambda: self.last_header_equals(stale_hash, p2p)\n         wait_until(test_function, timeout=3)\n \n         # Longest chain is extended so stale is much older than chain tip\n@@ -126,32 +118,32 @@ def run_test(self):\n \n         # Send getdata & getheaders to refresh last received getheader message\n         block_hash = int(tip, 16)\n-        self.send_block_request(block_hash, node0)\n-        self.send_header_request(block_hash, node0)\n-        node0.sync_with_ping()\n+        self.send_block_request(block_hash, p2p)\n+        self.send_header_request(block_hash, p2p)\n+        p2p.sync_with_ping()\n \n         # Request for very old stale block should now fail\n-        self.send_block_request(stale_hash, node0)\n+        self.send_block_request(stale_hash, p2p)\n         time.sleep(3)\n-        assert not self.last_block_equals(stale_hash, node0)\n+        assert not self.last_block_equals(stale_hash, p2p)\n \n         # Request for very old stale block header should now fail\n-        self.send_header_request(stale_hash, node0)\n+        self.send_header_request(stale_hash, p2p)\n         time.sleep(3)\n-        assert not self.last_header_equals(stale_hash, node0)\n+        assert not self.last_header_equals(stale_hash, p2p)\n \n         # Verify we can fetch very old blocks and headers on the active chain\n         block_hash = int(block_hashes[2], 16)\n-        self.send_block_request(block_hash, node0)\n-        self.send_header_request(block_hash, node0)\n-        node0.sync_with_ping()\n+        self.send_block_request(block_hash, p2p)\n+        self.send_header_request(block_hash, p2p)\n+        p2p.sync_with_ping()\n \n-        self.send_block_request(block_hash, node0)\n-        test_function = lambda: self.last_block_equals(block_hash, node0)\n+        self.send_block_request(block_hash, p2p)\n+        test_function = lambda: self.last_block_equals(block_hash, p2p)\n         wait_until(test_function, timeout=3)\n \n-        self.send_header_request(block_hash, node0)\n-        test_function = lambda: self.last_header_equals(block_hash, node0)\n+        self.send_header_request(block_hash, p2p)\n+        test_function = lambda: self.last_header_equals(block_hash, p2p)\n         wait_until(test_function, timeout=3)\n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "5765169080ac3c6990e88b2ee0674a7ffc53015f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NzY1MTY5MDgwYWMzYzY5OTBlODhiMmVlMDY3NGE3ZmZjNTMwMTVm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T18:04:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Better document the distinction between NodeConn and NodeConnCB\n\nThis adds documentation explaining the separation between\nNodeConn (representing the low-level connection and P2P\nheader parsing) from NodeConnCB (representing the higher\nlevel P2P payload processing and convenience methods).\n\nThis commit also removes the ping keepalive logic. No tests\nrun for more than 30 minutes, so this logic is never\nexercised.",
      "tree": {
        "sha": "f0efeaf6e744c11700bafdbaea5de2554155be02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0efeaf6e744c11700bafdbaea5de2554155be02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5765169080ac3c6990e88b2ee0674a7ffc53015f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5765169080ac3c6990e88b2ee0674a7ffc53015f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5765169080ac3c6990e88b2ee0674a7ffc53015f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5765169080ac3c6990e88b2ee0674a7ffc53015f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dab9e22b822eefdc4acdd9ae1bca3d174b7599d7"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 44,
      "deletions": 19
    },
    "files": [
      {
        "sha": "c79cdd1242fdf0a8039ba19e3909e8fda66db057",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 44,
        "deletions": 19,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5765169080ac3c6990e88b2ee0674a7ffc53015f/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5765169080ac3c6990e88b2ee0674a7ffc53015f/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=5765169080ac3c6990e88b2ee0674a7ffc53015f",
        "patch": "@@ -61,10 +61,17 @@\n logger = logging.getLogger(\"TestFramework.mininode\")\n \n class NodeConnCB():\n-    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+    \"\"\"A high-level P2P interface class for communicating with a Bitcoin node.\n+\n+    This class provides high-level callbacks for processing P2P message\n+    payloads, as well as convenience methods for interacting with the\n+    node over P2P.\n \n     Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\"\"\"\n+    if they want to alter message handling behaviour.\n+\n+    TODO: rename this class P2PInterface\"\"\"\n+\n     def __init__(self):\n         # Track whether we have a P2P connection open to the node\n         self.connected = False\n@@ -80,7 +87,7 @@ def __init__(self):\n \n     # Message receiving methods\n \n-    def deliver(self, conn, message):\n+    def on_message(self, conn, message):\n         \"\"\"Receive message and dispatch message to appropriate callback.\n \n         We keep a count of how many of each message type has been received\n@@ -92,8 +99,7 @@ def deliver(self, conn, message):\n                 self.last_message[command] = message\n                 getattr(self, 'on_' + command)(conn, message)\n             except:\n-                print(\"ERROR delivering %s (%s)\" % (repr(message),\n-                                                    sys.exc_info()[0]))\n+                print(\"ERROR delivering %s (%s)\" % (repr(message), sys.exc_info()[0]))\n                 raise\n \n     # Callback methods. Can be overridden by subclasses in individual test\n@@ -200,9 +206,20 @@ def sync_with_ping(self, timeout=60):\n         return True\n \n class NodeConn(asyncore.dispatcher):\n-    \"\"\"The actual NodeConn class\n+    \"\"\"A low-level connection object to a node's P2P interface.\n+\n+    This class is responsible for:\n+\n+    - opening and closing the TCP connection to the node\n+    - reading bytes from and writing bytes to the socket\n+    - deserializing and serializing the P2P message header\n+    - logging messages as they are sent and received\n+\n+    This class contains no logic for handing the P2P message payloads.\n+    P2P payload processing is done by the NodeConnCB class.\n+\n+    TODO: rename this class P2PConnection.\"\"\"\n \n-    This class provides an interface for a p2p connection to a specified node.\"\"\"\n     def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.dstaddr = dstaddr\n@@ -220,6 +237,7 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n \n         if send_version:\n             # stuff version msg into sendbuf\n+            # TODO: this is P2P payload-level logic. It should live in NodeConnCB\n             vt = msg_version()\n             vt.nServices = services\n             vt.addrTo.ip = self.dstaddr\n@@ -238,12 +256,14 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n     # Connection and disconnection methods\n \n     def handle_connect(self):\n+        \"\"\"asyncore callback when a connection is opened.\"\"\"\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n             self.state = \"connected\"\n             self.cb.on_open(self)\n \n     def handle_close(self):\n+        \"\"\"asyncore callback when a connection is closed.\"\"\"\n         logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self.state = \"closed\"\n         self.recvbuf = b\"\"\n@@ -263,16 +283,19 @@ def disconnect_node(self):\n \n     # Socket read methods\n \n-    def readable(self):\n-        return True\n-\n     def handle_read(self):\n+        \"\"\"asyncore callback when data is read from the socket.\"\"\"\n         t = self.recv(8192)\n         if len(t) > 0:\n             self.recvbuf += t\n-            self.got_data()\n+            self.read_message()\n \n-    def got_data(self):\n+    def read_message(self):\n+        \"\"\"Try to read a P2P message from the recv buffer.\n+\n+        This method reads a message from the buffer, deserializes, parses\n+        and verifies the P2P header. It then passes the P2P payload to the\n+        on_message callback for processing.\"\"\"\n         try:\n             while True:\n                 if len(self.recvbuf) < 4:\n@@ -297,25 +320,22 @@ def got_data(self):\n                 f = BytesIO(msg)\n                 t = messagemap[command]()\n                 t.deserialize(f)\n-                self.got_message(t)\n+                self._log_message(\"receive\", t)\n+                self.cb.on_message(self, t)\n         except Exception as e:\n             logger.exception('Error reading message:', repr(e))\n \n-    def got_message(self, message):\n-        if self.last_sent + 30 * 60 < time.time():\n-            self.send_message(messagemap[b'ping']())\n-        self._log_message(\"receive\", message)\n-        self.cb.deliver(self, message)\n-\n     # Socket write methods\n \n     def writable(self):\n+        \"\"\"asyncore method to determine whether the handle_write() callback should be called on the next loop.\"\"\"\n         with mininode_lock:\n             pre_connection = self.state == \"connecting\"\n             length = len(self.sendbuf)\n         return (length > 0 or pre_connection)\n \n     def handle_write(self):\n+        \"\"\"asyncore callback when data should be written to the socket.\"\"\"\n         with mininode_lock:\n             # asyncore does not expose socket connection, only the first read/write\n             # event, thus we must check connection manually here to know when we\n@@ -333,6 +353,10 @@ def handle_write(self):\n             self.sendbuf = self.sendbuf[sent:]\n \n     def send_message(self, message, pushbuf=False):\n+        \"\"\"Send a P2P message over the socket.\n+\n+        This method takes a P2P payload, builds the P2P header and adds\n+        the message to the send buffer to be sent over the socket.\"\"\"\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n         self._log_message(\"send\", message)\n@@ -360,6 +384,7 @@ def send_message(self, message, pushbuf=False):\n     # Class utility methods\n \n     def _log_message(self, direction, msg):\n+        \"\"\"Logs a message being sent or received over the connection.\"\"\"\n         if direction == \"send\":\n             log_message = \"Send message to \"\n         elif direction == \"receive\":"
      }
    ]
  },
  {
    "sha": "afa6fc1eee15dc3301f9f8e005d355620fa47438",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZmE2ZmMxZWVlMTVkYzMzMDFmOWY4ZTAwNWQzNTU2MjBmYTQ3NDM4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T19:40:22Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Make NodeConnCB a subclass of NodeConn\n\nThis makes NodeConnCB a subclass of NodeConn, and\nremoves the need for the client code to know\nanything about the implementation details of NodeConnCB.\n\nNodeConn can now be swapped out for any other implementation\nof a low-level connection without changing client code.",
      "tree": {
        "sha": "c69a8894286ebaf82ad9ab7d3abe5db8dd490c8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c69a8894286ebaf82ad9ab7d3abe5db8dd490c8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afa6fc1eee15dc3301f9f8e005d355620fa47438",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afa6fc1eee15dc3301f9f8e005d355620fa47438",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/afa6fc1eee15dc3301f9f8e005d355620fa47438",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afa6fc1eee15dc3301f9f8e005d355620fa47438/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5765169080ac3c6990e88b2ee0674a7ffc53015f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5765169080ac3c6990e88b2ee0674a7ffc53015f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5765169080ac3c6990e88b2ee0674a7ffc53015f"
      }
    ],
    "stats": {
      "total": 598,
      "additions": 285,
      "deletions": 313
    },
    "files": [
      {
        "sha": "883f06c3101368f8fbb92b9021ad7abfffa27933",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -67,7 +67,7 @@ def setup_network(self):\n     def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if not p2p_conn.connection:\n+            if p2p_conn.state != \"connected\":\n                 break\n             try:\n                 p2p_conn.send_message(msg_block(self.blocks[i]))"
      },
      {
        "sha": "ec4d1d93652964684a58d1dfd15b29d4f73f5f29",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -246,7 +246,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         self.setup_network()\n         self.test.add_all_connections(self.nodes)\n         NetworkThread().start()\n-        self.test.test_nodes[0].wait_for_verack()\n+        self.test.p2p_connections[0].wait_for_verack()\n \n     def get_tests(self):\n         for test in itertools.chain("
      },
      {
        "sha": "a14598fbd7edfd6df222e281859554fd04fce092",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -22,6 +22,7 @@\n     mininode_lock,\n     msg_block,\n     msg_getdata,\n+    NODE_NETWORK,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -34,7 +35,7 @@\n # message is received from the node-under-test. Subclass NodeConnCB and\n # override the on_*() methods if you need custom behaviour.\n class BaseNode(NodeConnCB):\n-    def __init__(self):\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         \"\"\"Initialize the NodeConnCB\n \n         Used to inialize custom properties for the Node that aren't\n@@ -45,18 +46,18 @@ def __init__(self):\n \n         Call super().__init__() first for standard initialization and then\n         initialize custom properties.\"\"\"\n-        super().__init__()\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         # Stores a dictionary of all blocks received\n         self.block_receive_map = defaultdict(int)\n \n-    def on_block(self, conn, message):\n+    def on_block(self, message):\n         \"\"\"Override the standard on_block callback\n \n         Store the hash of a received block in the dictionary.\"\"\"\n         message.block.calc_sha256()\n         self.block_receive_map[message.block.sha256] += 1\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         \"\"\"Override the standard on_inv callback\"\"\"\n         pass\n "
      },
      {
        "sha": "0470c566babd975967ff532f53b284bd9feabcc2",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -18,14 +18,14 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.block_receive_map = defaultdict(int)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         pass\n \n-    def on_block(self, conn, message):\n+    def on_block(self, message):\n         message.block.calc_sha256()\n         self.block_receive_map[message.block.sha256] += 1\n "
      },
      {
        "sha": "40c4b87bfad81a7d7f353b027254cabafd795817",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -16,30 +16,30 @@\n \n # TestNode: A peer we use to send messages to bitcoind, and store responses.\n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.last_sendcmpct = []\n         self.block_announced = False\n         # Store the hashes of blocks we've seen announced.\n         # This is for synchronizing the p2p message traffic,\n         # so we can eg wait until a particular block is announced.\n         self.announced_blockhashes = set()\n \n-    def on_sendcmpct(self, conn, message):\n+    def on_sendcmpct(self, message):\n         self.last_sendcmpct.append(message)\n \n-    def on_cmpctblock(self, conn, message):\n+    def on_cmpctblock(self, message):\n         self.block_announced = True\n         self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n         self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n \n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         self.block_announced = True\n         for x in self.last_message[\"headers\"].headers:\n             x.calc_sha256()\n             self.announced_blockhashes.add(x.sha256)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         for x in self.last_message[\"inv\"].inv:\n             if x.type == 2:\n                 self.block_announced = True\n@@ -60,7 +60,7 @@ def get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n         msg.locator.vHave = locator\n         msg.hashstop = hashstop\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n@@ -86,7 +86,7 @@ def send_await_disconnect(self, message, timeout=30):\n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: not self.connected, timeout=timeout, lock=mininode_lock)\n+        wait_until(lambda: self.state != \"connected\", timeout=timeout, lock=mininode_lock)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):"
      },
      {
        "sha": "287e8d160bff35fdb314a2335cfad8ad9a602d5f",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -23,11 +23,11 @@ def allInvsMatch(invsExpected, testnode):\n     return False\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.txinvs = []\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         for i in message.inv:\n             if (i.type == 1):\n                 self.txinvs.append(hashToHex(i.hash))"
      },
      {
        "sha": "72b0aebcaa42ee860ca65a347f7c590fedb56c2d",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 39,
        "deletions": 40,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -21,74 +21,73 @@\n banscore = 10\n \n class CLazyNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.unexpected_msg = False\n         self.ever_connected = False\n \n     def bad_message(self, message):\n         self.unexpected_msg = True\n         self.log.info(\"should not have received message: %s\" % message.command)\n \n-    def on_open(self, conn):\n-        self.connected = True\n+    def on_open(self):\n         self.ever_connected = True\n \n-    def on_version(self, conn, message): self.bad_message(message)\n-    def on_verack(self, conn, message): self.bad_message(message)\n-    def on_reject(self, conn, message): self.bad_message(message)\n-    def on_inv(self, conn, message): self.bad_message(message)\n-    def on_addr(self, conn, message): self.bad_message(message)\n-    def on_getdata(self, conn, message): self.bad_message(message)\n-    def on_getblocks(self, conn, message): self.bad_message(message)\n-    def on_tx(self, conn, message): self.bad_message(message)\n-    def on_block(self, conn, message): self.bad_message(message)\n-    def on_getaddr(self, conn, message): self.bad_message(message)\n-    def on_headers(self, conn, message): self.bad_message(message)\n-    def on_getheaders(self, conn, message): self.bad_message(message)\n-    def on_ping(self, conn, message): self.bad_message(message)\n-    def on_mempool(self, conn): self.bad_message(message)\n-    def on_pong(self, conn, message): self.bad_message(message)\n-    def on_feefilter(self, conn, message): self.bad_message(message)\n-    def on_sendheaders(self, conn, message): self.bad_message(message)\n-    def on_sendcmpct(self, conn, message): self.bad_message(message)\n-    def on_cmpctblock(self, conn, message): self.bad_message(message)\n-    def on_getblocktxn(self, conn, message): self.bad_message(message)\n-    def on_blocktxn(self, conn, message): self.bad_message(message)\n+    def on_version(self, message): self.bad_message(message)\n+    def on_verack(self, message): self.bad_message(message)\n+    def on_reject(self, message): self.bad_message(message)\n+    def on_inv(self, message): self.bad_message(message)\n+    def on_addr(self, message): self.bad_message(message)\n+    def on_getdata(self, message): self.bad_message(message)\n+    def on_getblocks(self, message): self.bad_message(message)\n+    def on_tx(self, message): self.bad_message(message)\n+    def on_block(self, message): self.bad_message(message)\n+    def on_getaddr(self, message): self.bad_message(message)\n+    def on_headers(self, message): self.bad_message(message)\n+    def on_getheaders(self, message): self.bad_message(message)\n+    def on_ping(self, message): self.bad_message(message)\n+    def on_mempool(self, message): self.bad_message(message)\n+    def on_pong(self, message): self.bad_message(message)\n+    def on_feefilter(self, message): self.bad_message(message)\n+    def on_sendheaders(self, message): self.bad_message(message)\n+    def on_sendcmpct(self, message): self.bad_message(message)\n+    def on_cmpctblock(self, message): self.bad_message(message)\n+    def on_getblocktxn(self, message): self.bad_message(message)\n+    def on_blocktxn(self, message): self.bad_message(message)\n \n # Node that never sends a version. We'll use this to send a bunch of messages\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n     # send a bunch of veracks without sending a message. This should get us disconnected.\n     # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n-    def on_open(self, conn):\n-        super().on_open(conn)\n+    def on_open(self):\n+        super().on_open()\n         for i in range(banscore):\n             self.send_message(msg_verack())\n \n-    def on_reject(self, conn, message): pass\n+    def on_reject(self, message): pass\n \n # Node that never sends a version. This one just sits idle and hopes to receive\n # any message (it shouldn't!)\n class CNodeNoVersionIdle(CLazyNode):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n \n # Node that sends a version but not a verack.\n class CNodeNoVerackIdle(CLazyNode):\n-    def __init__(self):\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         self.version_received = False\n-        super().__init__()\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n \n-    def on_reject(self, conn, message): pass\n-    def on_verack(self, conn, message): pass\n+    def on_reject(self, message): pass\n+    def on_verack(self, message): pass\n     # When version is received, don't reply with a verack. Instead, see if the\n     # node will give us a message that it shouldn't. This is not an exhaustive\n     # list!\n-    def on_version(self, conn, message):\n+    def on_version(self, message):\n         self.version_received = True\n-        conn.send_message(msg_ping())\n-        conn.send_message(msg_getaddr())\n+        self.send_message(msg_ping())\n+        self.send_message(msg_getaddr())\n \n class P2PLeakTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -119,11 +118,11 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert not no_version_bannode.connected\n+        assert no_version_bannode.state != \"connected\"\n \n         # These nodes should have been disconnected\n-        assert not unsupported_service_bit5_node.connected\n-        assert not unsupported_service_bit7_node.connected\n+        assert unsupported_service_bit5_node.state != \"connected\"\n+        assert unsupported_service_bit7_node.state != \"connected\"\n \n         for _ in range(5):\n             self.nodes[0].disconnect_p2p()"
      },
      {
        "sha": "8adeff0811d855dc9eb01f8edc79a8d6d4357b32",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -60,11 +60,11 @@ def test_witness_block(node, p2p, block, accepted, with_witness=True):\n     assert_equal(node.rpc.getbestblockhash() == block.hash, accepted)\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.getdataset = set()\n \n-    def on_getdata(self, conn, message):\n+    def on_getdata(self, message):\n         for inv in message.inv:\n             self.getdataset.add(inv.hash)\n \n@@ -147,7 +147,7 @@ def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n     ''' Individual tests '''\n     def test_witness_services(self):\n         self.log.info(\"Verifying NODE_WITNESS service bit\")\n-        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+        assert((self.test_node.nServices & NODE_WITNESS) != 0)\n \n \n     # See if sending a regular transaction works, and create a utxo"
      },
      {
        "sha": "2c6cf7b6efac0bf9ce09acb0f827e9a94e8e265d",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -28,7 +28,7 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def on_version(self, conn, message):\n+    def on_version(self, message):\n         # Don't send a verack in response\n         pass\n "
      },
      {
        "sha": "5b348ba0b4c41fc2e9c84851a4a206242e10b8f8",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -24,7 +24,7 @@\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n class TestNode(NodeConnCB):\n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         pass\n \n class VersionBitsWarningTest(BitcoinTestFramework):"
      },
      {
        "sha": "4f530f51c1d3474ad416d914f944d8b2852591cc",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -82,8 +82,8 @@\n direct_fetch_response_time = 0.05\n \n class TestNode(NodeConnCB):\n-    def __init__(self):\n-        super().__init__()\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.block_announced = False\n         self.last_blockhash_announced = None\n \n@@ -98,24 +98,24 @@ def get_data(self, block_hashes):\n         msg = msg_getdata()\n         for x in block_hashes:\n             msg.inv.append(CInv(2, x))\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n         msg.locator.vHave = locator\n         msg.hashstop = hashstop\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_block_inv(self, blockhash):\n         msg = msg_inv()\n         msg.inv = [CInv(2, blockhash)]\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         self.block_announced = True\n         self.last_blockhash_announced = message.inv[-1].hash\n \n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         if len(message.headers):\n             self.block_announced = True\n             message.headers[-1].calc_sha256()"
      },
      {
        "sha": "8b760cd6167314248cb1a0b98e6dce1ddb53e486",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 58,
        "deletions": 69,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -41,9 +41,8 @@ def __repr__(self):\n \n class TestNode(NodeConnCB):\n \n-    def __init__(self, block_store, tx_store):\n-        super().__init__()\n-        self.conn = None\n+    def __init__(self, block_store, tx_store, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.bestblockhash = None\n         self.block_store = block_store\n         self.block_request_map = {}\n@@ -58,74 +57,71 @@ def __init__(self, block_store, tx_store):\n         self.lastInv = []\n         self.closed = False\n \n-    def on_close(self, conn):\n+    def on_close(self):\n         self.closed = True\n \n-    def add_connection(self, conn):\n-        self.conn = conn\n-\n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         if len(message.headers) > 0:\n             best_header = message.headers[-1]\n             best_header.calc_sha256()\n             self.bestblockhash = best_header.sha256\n \n-    def on_getheaders(self, conn, message):\n+    def on_getheaders(self, message):\n         response = self.block_store.headers_for(message.locator, message.hashstop)\n         if response is not None:\n-            conn.send_message(response)\n+            self.send_message(response)\n \n-    def on_getdata(self, conn, message):\n-        [conn.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n-        [conn.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n+    def on_getdata(self, message):\n+        [self.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n+        [self.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n \n         for i in message.inv:\n             if i.type == 1:\n                 self.tx_request_map[i.hash] = True\n             elif i.type == 2:\n                 self.block_request_map[i.hash] = True\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         self.lastInv = [x.hash for x in message.inv]\n \n-    def on_pong(self, conn, message):\n+    def on_pong(self, message):\n         try:\n             del self.pingMap[message.nonce]\n         except KeyError:\n             raise AssertionError(\"Got pong for unknown ping [%s]\" % repr(message))\n \n-    def on_reject(self, conn, message):\n+    def on_reject(self, message):\n         if message.message == b'tx':\n             self.tx_reject_map[message.data] = RejectResult(message.code, message.reason)\n         if message.message == b'block':\n             self.block_reject_map[message.data] = RejectResult(message.code, message.reason)\n \n     def send_inv(self, obj):\n         mtype = 2 if isinstance(obj, CBlock) else 1\n-        self.conn.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n+        self.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n \n     def send_getheaders(self):\n         # We ask for headers from their last tip.\n         m = msg_getheaders()\n         m.locator = self.block_store.get_locator(self.bestblockhash)\n-        self.conn.send_message(m)\n+        self.send_message(m)\n \n     def send_header(self, header):\n         m = msg_headers()\n         m.headers.append(header)\n-        self.conn.send_message(m)\n+        self.send_message(m)\n \n     # This assumes BIP31\n     def send_ping(self, nonce):\n         self.pingMap[nonce] = True\n-        self.conn.send_message(msg_ping(nonce))\n+        self.send_message(msg_ping(nonce))\n \n     def received_ping_response(self, nonce):\n         return nonce not in self.pingMap\n \n     def send_mempool(self):\n         self.lastInv = []\n-        self.conn.send_message(msg_mempool())\n+        self.send_message(msg_mempool())\n \n # TestInstance:\n #\n@@ -166,37 +162,30 @@ class TestManager():\n \n     def __init__(self, testgen, datadir):\n         self.test_generator = testgen\n-        self.connections    = []\n-        self.test_nodes     = []\n+        self.p2p_connections= []\n         self.block_store    = BlockStore(datadir)\n         self.tx_store       = TxStore(datadir)\n         self.ping_counter   = 1\n \n     def add_all_connections(self, nodes):\n         for i in range(len(nodes)):\n             # Create a p2p connection to each node\n-            test_node = TestNode(self.block_store, self.tx_store)\n-            self.test_nodes.append(test_node)\n-            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), test_node))\n-            # Make sure the TestNode (callback class) has a reference to its\n-            # associated NodeConn\n-            test_node.add_connection(self.connections[-1])\n+            self.p2p_connections.append(TestNode(self.block_store, self.tx_store, '127.0.0.1', p2p_port(i),))\n \n     def clear_all_connections(self):\n-        self.connections    = []\n-        self.test_nodes     = []\n+        self.p2p_connections = []\n \n     def wait_for_disconnections(self):\n         def disconnected():\n-            return all(node.closed for node in self.test_nodes)\n+            return all(node.closed for node in self.p2p_connections)\n         wait_until(disconnected, timeout=10, lock=mininode_lock)\n \n     def wait_for_verack(self):\n-        return all(node.wait_for_verack() for node in self.test_nodes)\n+        return all(node.wait_for_verack() for node in self.p2p_connections)\n \n     def wait_for_pings(self, counter):\n         def received_pongs():\n-            return all(node.received_ping_response(counter) for node in self.test_nodes)\n+            return all(node.received_ping_response(counter) for node in self.p2p_connections)\n         wait_until(received_pongs, lock=mininode_lock)\n \n     # sync_blocks: Wait for all connections to request the blockhash given\n@@ -206,17 +195,17 @@ def sync_blocks(self, blockhash, num_blocks):\n         def blocks_requested():\n             return all(\n                 blockhash in node.block_request_map and node.block_request_map[blockhash]\n-                for node in self.test_nodes\n+                for node in self.p2p_connections\n             )\n \n         # --> error if not requested\n         wait_until(blocks_requested, attempts=20*num_blocks, lock=mininode_lock)\n \n         # Send getheaders message\n-        [ c.cb.send_getheaders() for c in self.connections ]\n+        [ c.send_getheaders() for c in self.p2p_connections ]\n \n         # Send ping and wait for response -- synchronization hack\n-        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n         self.wait_for_pings(self.ping_counter)\n         self.ping_counter += 1\n \n@@ -226,42 +215,42 @@ def sync_transaction(self, txhash, num_events):\n         def transaction_requested():\n             return all(\n                 txhash in node.tx_request_map and node.tx_request_map[txhash]\n-                for node in self.test_nodes\n+                for node in self.p2p_connections\n             )\n \n         # --> error if not requested\n         wait_until(transaction_requested, attempts=20*num_events, lock=mininode_lock)\n \n         # Get the mempool\n-        [ c.cb.send_mempool() for c in self.connections ]\n+        [ c.send_mempool() for c in self.p2p_connections ]\n \n         # Send ping and wait for response -- synchronization hack\n-        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n         self.wait_for_pings(self.ping_counter)\n         self.ping_counter += 1\n \n         # Sort inv responses from each node\n         with mininode_lock:\n-            [ c.cb.lastInv.sort() for c in self.connections ]\n+            [ c.lastInv.sort() for c in self.p2p_connections ]\n \n     # Verify that the tip of each connection all agree with each other, and\n     # with the expected outcome (if given)\n     def check_results(self, blockhash, outcome):\n         with mininode_lock:\n-            for c in self.connections:\n+            for c in self.p2p_connections:\n                 if outcome is None:\n-                    if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+                    if c.bestblockhash != self.p2p_connections[0].bestblockhash:\n                         return False\n                 elif isinstance(outcome, RejectResult): # Check that block was rejected w/ code\n-                    if c.cb.bestblockhash == blockhash:\n+                    if c.bestblockhash == blockhash:\n                         return False\n-                    if blockhash not in c.cb.block_reject_map:\n+                    if blockhash not in c.block_reject_map:\n                         logger.error('Block not in reject map: %064x' % (blockhash))\n                         return False\n-                    if not outcome.match(c.cb.block_reject_map[blockhash]):\n-                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.cb.block_reject_map[blockhash], outcome, blockhash))\n+                    if not outcome.match(c.block_reject_map[blockhash]):\n+                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.block_reject_map[blockhash], outcome, blockhash))\n                         return False\n-                elif ((c.cb.bestblockhash == blockhash) != outcome):\n+                elif ((c.bestblockhash == blockhash) != outcome):\n                     return False\n             return True\n \n@@ -273,21 +262,21 @@ def check_results(self, blockhash, outcome):\n     # a particular tx's existence in the mempool is the same across all nodes.\n     def check_mempool(self, txhash, outcome):\n         with mininode_lock:\n-            for c in self.connections:\n+            for c in self.p2p_connections:\n                 if outcome is None:\n                     # Make sure the mempools agree with each other\n-                    if c.cb.lastInv != self.connections[0].cb.lastInv:\n+                    if c.lastInv != self.p2p_connections[0].lastInv:\n                         return False\n                 elif isinstance(outcome, RejectResult): # Check that tx was rejected w/ code\n-                    if txhash in c.cb.lastInv:\n+                    if txhash in c.lastInv:\n                         return False\n-                    if txhash not in c.cb.tx_reject_map:\n+                    if txhash not in c.tx_reject_map:\n                         logger.error('Tx not in reject map: %064x' % (txhash))\n                         return False\n-                    if not outcome.match(c.cb.tx_reject_map[txhash]):\n-                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.cb.tx_reject_map[txhash], outcome, txhash))\n+                    if not outcome.match(c.tx_reject_map[txhash]):\n+                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.tx_reject_map[txhash], outcome, txhash))\n                         return False\n-                elif ((txhash in c.cb.lastInv) != outcome):\n+                elif ((txhash in c.lastInv) != outcome):\n                     return False\n             return True\n \n@@ -329,25 +318,25 @@ def run(self):\n                         first_block_with_hash = False\n                     with mininode_lock:\n                         self.block_store.add_block(block)\n-                        for c in self.connections:\n-                            if first_block_with_hash and block.sha256 in c.cb.block_request_map and c.cb.block_request_map[block.sha256] == True:\n+                        for c in self.p2p_connections:\n+                            if first_block_with_hash and block.sha256 in c.block_request_map and c.block_request_map[block.sha256] == True:\n                                 # There was a previous request for this block hash\n                                 # Most likely, we delivered a header for this block\n                                 # but never had the block to respond to the getdata\n                                 c.send_message(msg_block(block))\n                             else:\n-                                c.cb.block_request_map[block.sha256] = False\n+                                c.block_request_map[block.sha256] = False\n                     # Either send inv's to each node and sync, or add\n                     # to invqueue for later inv'ing.\n                     if (test_instance.sync_every_block):\n                         # if we expect success, send inv and sync every block\n                         # if we expect failure, just push the block and see what happens.\n                         if outcome == True:\n-                            [ c.cb.send_inv(block) for c in self.connections ]\n+                            [ c.send_inv(block) for c in self.p2p_connections ]\n                             self.sync_blocks(block.sha256, 1)\n                         else:\n-                            [ c.send_message(msg_block(block)) for c in self.connections ]\n-                            [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+                            [ c.send_message(msg_block(block)) for c in self.p2p_connections ]\n+                            [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n                             self.wait_for_pings(self.ping_counter)\n                             self.ping_counter += 1\n                         if (not self.check_results(tip, outcome)):\n@@ -357,7 +346,7 @@ def run(self):\n                 elif isinstance(b_or_t, CBlockHeader):\n                     block_header = b_or_t\n                     self.block_store.add_header(block_header)\n-                    [ c.cb.send_header(block_header) for c in self.connections ]\n+                    [ c.send_header(block_header) for c in self.p2p_connections ]\n \n                 else:  # Tx test runner\n                     assert(isinstance(b_or_t, CTransaction))\n@@ -366,32 +355,32 @@ def run(self):\n                     # Add to shared tx store and clear map entry\n                     with mininode_lock:\n                         self.tx_store.add_transaction(tx)\n-                        for c in self.connections:\n-                            c.cb.tx_request_map[tx.sha256] = False\n+                        for c in self.p2p_connections:\n+                            c.tx_request_map[tx.sha256] = False\n                     # Again, either inv to all nodes or save for later\n                     if (test_instance.sync_every_tx):\n-                        [ c.cb.send_inv(tx) for c in self.connections ]\n+                        [ c.send_inv(tx) for c in self.p2p_connections ]\n                         self.sync_transaction(tx.sha256, 1)\n                         if (not self.check_mempool(tx.sha256, outcome)):\n                             raise AssertionError(\"Test failed at test %d\" % test_number)\n                     else:\n                         invqueue.append(CInv(1, tx.sha256))\n                 # Ensure we're not overflowing the inv queue\n                 if len(invqueue) == MAX_INV_SZ:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n \n             # Do final sync if we weren't syncing on every block or every tx.\n             if (not test_instance.sync_every_block and block is not None):\n                 if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n                 self.sync_blocks(block.sha256, len(test_instance.blocks_and_transactions))\n                 if (not self.check_results(tip, block_outcome)):\n                     raise AssertionError(\"Block test failed at test %d\" % test_number)\n             if (not test_instance.sync_every_tx and tx is not None):\n                 if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n                 self.sync_transaction(tx.sha256, len(test_instance.blocks_and_transactions))\n                 if (not self.check_mempool(tx.sha256, tx_outcome)):\n@@ -400,7 +389,7 @@ def run(self):\n             logger.info(\"Test %d: PASS\" % test_number)\n             test_number += 1\n \n-        [ c.disconnect_node() for c in self.connections ]\n+        [ c.disconnect_node() for c in self.p2p_connections ]\n         self.wait_for_disconnections()\n         self.block_store.close()\n         self.tx_store.close()"
      },
      {
        "sha": "434ddb617b7615e50b97ac82ad0544c2f84c24e8",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 148,
        "deletions": 161,
        "changes": 309,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -20,7 +20,6 @@\n import socket\n import struct\n import sys\n-import time\n from threading import RLock, Thread\n \n from test_framework.primitives import *\n@@ -60,151 +59,6 @@\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n-class NodeConnCB():\n-    \"\"\"A high-level P2P interface class for communicating with a Bitcoin node.\n-\n-    This class provides high-level callbacks for processing P2P message\n-    payloads, as well as convenience methods for interacting with the\n-    node over P2P.\n-\n-    Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\n-\n-    TODO: rename this class P2PInterface\"\"\"\n-\n-    def __init__(self):\n-        # Track whether we have a P2P connection open to the node\n-        self.connected = False\n-        self.connection = None\n-\n-        # Track number of messages of each type received and the most recent\n-        # message of each type\n-        self.message_count = defaultdict(int)\n-        self.last_message = {}\n-\n-        # A count of the number of ping messages we've sent to the node\n-        self.ping_counter = 1\n-\n-    # Message receiving methods\n-\n-    def on_message(self, conn, message):\n-        \"\"\"Receive message and dispatch message to appropriate callback.\n-\n-        We keep a count of how many of each message type has been received\n-        and the most recent message of each type.\"\"\"\n-        with mininode_lock:\n-            try:\n-                command = message.command.decode('ascii')\n-                self.message_count[command] += 1\n-                self.last_message[command] = message\n-                getattr(self, 'on_' + command)(conn, message)\n-            except:\n-                print(\"ERROR delivering %s (%s)\" % (repr(message), sys.exc_info()[0]))\n-                raise\n-\n-    # Callback methods. Can be overridden by subclasses in individual test\n-    # cases to provide custom message handling behaviour.\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n-        self.connection = None\n-\n-    def on_addr(self, conn, message): pass\n-    def on_block(self, conn, message): pass\n-    def on_blocktxn(self, conn, message): pass\n-    def on_cmpctblock(self, conn, message): pass\n-    def on_feefilter(self, conn, message): pass\n-    def on_getaddr(self, conn, message): pass\n-    def on_getblocks(self, conn, message): pass\n-    def on_getblocktxn(self, conn, message): pass\n-    def on_getdata(self, conn, message): pass\n-    def on_getheaders(self, conn, message): pass\n-    def on_headers(self, conn, message): pass\n-    def on_mempool(self, conn): pass\n-    def on_pong(self, conn, message): pass\n-    def on_reject(self, conn, message): pass\n-    def on_sendcmpct(self, conn, message): pass\n-    def on_sendheaders(self, conn, message): pass\n-    def on_tx(self, conn, message): pass\n-\n-    def on_inv(self, conn, message):\n-        want = msg_getdata()\n-        for i in message.inv:\n-            if i.type != 0:\n-                want.inv.append(i)\n-        if len(want.inv):\n-            conn.send_message(want)\n-\n-    def on_ping(self, conn, message):\n-        conn.send_message(msg_pong(message.nonce))\n-\n-    def on_verack(self, conn, message):\n-        self.verack_received = True\n-\n-    def on_version(self, conn, message):\n-        assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n-        conn.send_message(msg_verack())\n-        conn.nServices = message.nServices\n-\n-    # Connection helper methods\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: not self.connected\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    # Message receiving helper methods\n-\n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_getdata(self, timeout=60):\n-        test_function = lambda: self.last_message.get(\"getdata\")\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_message.get(\"getheaders\")\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_inv(self, expected_inv, timeout=60):\n-        \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n-        if len(expected_inv) > 1:\n-            raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n-        test_function = lambda: self.last_message.get(\"inv\") and \\\n-                                self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n-                                self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_verack(self, timeout=60):\n-        test_function = lambda: self.message_count[\"verack\"]\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    # Message sending helper functions\n-\n-    def send_message(self, message):\n-        if self.connection:\n-            self.connection.send_message(message)\n-        else:\n-            logger.error(\"Cannot send message. No connection to node!\")\n-\n-    def send_and_ping(self, message):\n-        self.send_message(message)\n-        self.sync_with_ping()\n-\n-    # Sync up with the node\n-    def sync_with_ping(self, timeout=60):\n-        self.send_message(msg_ping(nonce=self.ping_counter))\n-        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-        self.ping_counter += 1\n-        return True\n-\n class NodeConn(asyncore.dispatcher):\n     \"\"\"A low-level connection object to a node's P2P interface.\n \n@@ -215,25 +69,22 @@ class NodeConn(asyncore.dispatcher):\n     - deserializing and serializing the P2P message header\n     - logging messages as they are sent and received\n \n-    This class contains no logic for handing the P2P message payloads.\n-    P2P payload processing is done by the NodeConnCB class.\n+    This class contains no logic for handing the P2P message payloads. It must be\n+    sub-classed and the on_message() callback overridden.\n \n     TODO: rename this class P2PConnection.\"\"\"\n \n-    def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n-        asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(map=mininode_socket_map)\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n         self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n         self.sendbuf = b\"\"\n         self.recvbuf = b\"\"\n-        self.last_sent = 0\n         self.state = \"connecting\"\n         self.network = net\n-        self.cb = callback\n         self.disconnect = False\n-        self.nServices = 0\n \n         if send_version:\n             # stuff version msg into sendbuf\n@@ -248,10 +99,10 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n \n         logger.info('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n-        try:\n-            self.connect((dstaddr, dstport))\n-        except:\n-            self.handle_close()\n+        # try:\n+        self.connect((dstaddr, dstport))\n+        # except:\n+        #     self.handle_close()\n \n     # Connection and disconnection methods\n \n@@ -260,7 +111,7 @@ def handle_connect(self):\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n             self.state = \"connected\"\n-            self.cb.on_open(self)\n+            self.on_open()\n \n     def handle_close(self):\n         \"\"\"asyncore callback when a connection is closed.\"\"\"\n@@ -272,7 +123,7 @@ def handle_close(self):\n             self.close()\n         except:\n             pass\n-        self.cb.on_close(self)\n+        self.on_close()\n \n     def disconnect_node(self):\n         \"\"\"Disconnect the p2p connection.\n@@ -321,10 +172,14 @@ def read_message(self):\n                 t = messagemap[command]()\n                 t.deserialize(f)\n                 self._log_message(\"receive\", t)\n-                self.cb.on_message(self, t)\n+                self.on_message(t)\n         except Exception as e:\n             logger.exception('Error reading message:', repr(e))\n \n+    def on_message(message):\n+        \"\"\"Callback for processing a P2P payload. Must be overridden by derived class.\"\"\"\n+        raise NotImplementedError\n+\n     # Socket write methods\n \n     def writable(self):\n@@ -379,7 +234,6 @@ def send_message(self, message, pushbuf=False):\n                     self.sendbuf = tmsg\n             else:\n                 self.sendbuf += tmsg\n-            self.last_sent = time.time()\n \n     # Class utility methods\n \n@@ -394,6 +248,139 @@ def _log_message(self, direction, msg):\n             log_message += \"... (msg truncated)\"\n         logger.debug(log_message)\n \n+class NodeConnCB(NodeConn):\n+    \"\"\"A high-level P2P interface class for communicating with a Bitcoin node.\n+\n+    This class provides high-level callbacks for processing P2P message\n+    payloads, as well as convenience methods for interacting with the\n+    node over P2P.\n+\n+    Individual testcases should subclass this and override the on_* methods\n+    if they want to alter message handling behaviour.\n+\n+    TODO: rename this class P2PInterface\"\"\"\n+\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n+\n+        # Track number of messages of each type received and the most recent\n+        # message of each type\n+        self.message_count = defaultdict(int)\n+        self.last_message = {}\n+\n+        # A count of the number of ping messages we've sent to the node\n+        self.ping_counter = 1\n+\n+    # Message receiving methods\n+\n+    def on_message(self, message):\n+        \"\"\"Receive message and dispatch message to appropriate callback.\n+\n+        We keep a count of how many of each message type has been received\n+        and the most recent message of each type.\"\"\"\n+        with mininode_lock:\n+            try:\n+                command = message.command.decode('ascii')\n+                self.message_count[command] += 1\n+                self.last_message[command] = message\n+                getattr(self, 'on_' + command)(message)\n+            except:\n+                print(\"ERROR delivering %s (%s)\" % (repr(message), sys.exc_info()[0]))\n+                raise\n+\n+    # Callback methods. Can be overridden by subclasses in individual test\n+    # cases to provide custom message handling behaviour.\n+\n+    def on_open(self):\n+        pass\n+\n+    def on_close(self):\n+        pass\n+\n+    def on_addr(self, message): pass\n+    def on_block(self, message): pass\n+    def on_blocktxn(self, message): pass\n+    def on_cmpctblock(self, message): pass\n+    def on_feefilter(self, message): pass\n+    def on_getaddr(self, message): pass\n+    def on_getblocks(self, message): pass\n+    def on_getblocktxn(self, message): pass\n+    def on_getdata(self, message): pass\n+    def on_getheaders(self, message): pass\n+    def on_headers(self, message): pass\n+    def on_mempool(self): pass\n+    def on_pong(self, message): pass\n+    def on_reject(self, message): pass\n+    def on_sendcmpct(self, message): pass\n+    def on_sendheaders(self, message): pass\n+    def on_tx(self, message): pass\n+\n+    def on_inv(self, message):\n+        want = msg_getdata()\n+        for i in message.inv:\n+            if i.type != 0:\n+                want.inv.append(i)\n+        if len(want.inv):\n+            self.send_message(want)\n+\n+    def on_ping(self, message):\n+        self.send_message(msg_pong(message.nonce))\n+\n+    def on_verack(self, message):\n+        self.verack_received = True\n+\n+    def on_version(self, message):\n+        assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n+        self.send_message(msg_verack())\n+        self.nServices = message.nServices\n+\n+    # Connection helper methods\n+\n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: self.state != \"connected\"\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    # Message receiving helper methods\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getdata\")\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getheaders\")\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n+        if len(expected_inv) > 1:\n+            raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n+        test_function = lambda: self.last_message.get(\"inv\") and \\\n+                                self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n+                                self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_verack(self, timeout=60):\n+        test_function = lambda: self.message_count[\"verack\"]\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    # Message sending helper functions\n+\n+    def send_and_ping(self, message):\n+        self.send_message(message)\n+        self.sync_with_ping()\n+\n+    # Sync up with the node\n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+        self.ping_counter += 1\n+        return True\n+\n # Keep our own socket map for asyncore, so that we can track disconnects\n # ourselves (to workaround an issue with closing an asyncore socket when\n # using select)"
      },
      {
        "sha": "f85fdaab574b5eb1c4ec4a14afad723d465c39a7",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 5,
        "deletions": 9,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afa6fc1eee15dc3301f9f8e005d355620fa47438/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "patch": "@@ -14,11 +14,7 @@\n import time\n \n from .authproxy import JSONRPCException\n-from .mininode import (\n-    NodeConn,\n-    NodeConnCB,\n-    NODE_NETWORK,\n-)\n+from .mininode import NODE_NETWORK\n from .util import (\n     assert_equal,\n     get_rpc_proxy,\n@@ -171,9 +167,9 @@ def add_p2p_connection(self, p2p_conn_type, dstaddr='127.0.0.1', dstport=None, s\n         returns the connection to the caller.\"\"\"\n         if dstport is None:\n             dstport = p2p_port(self.index)\n-        p2p_conn = p2p_conn_type()\n+\n+        p2p_conn = p2p_conn_type(dstaddr, dstport, net=\"regtest\", services=services, send_version=send_version)\n         self.p2ps.append(p2p_conn)\n-        p2p_conn.add_connection(NodeConn(dstaddr, dstport, p2p_conn, services=services, send_version=send_version))\n \n         return p2p_conn\n \n@@ -193,8 +189,8 @@ def send_message(self, message):\n \n     def disconnect_p2p(self, index=0):\n         \"\"\"Close the p2p connection to the node.\"\"\"\n-        if self.p2ps[index].connection is not None:\n-            self.p2ps[index].connection.disconnect_node()\n+        if self.p2ps[index].state == \"connected\":\n+            self.p2ps[index].disconnect_node()\n         self.p2ps.pop(index)\n \n class TestNodeCLI():"
      }
    ]
  },
  {
    "sha": "cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZjIzNmY0MWUxNzIyYThhNDBhYmFhOWVmZmIwZTJkMWNhZmE2MTAw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T19:56:12Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Move version message sending from NodeConn to NodeConnCB\n\nThis commit moves the logic that sends a version message\non connection from NodeConn to NodeConnCB. NodeConn should\nnot be aware of the semantics or meaning of the P2P payloads.",
      "tree": {
        "sha": "a2eb10f166c5b96fc53ce8dffeb466303c5b0e68",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2eb10f166c5b96fc53ce8dffeb466303c5b0e68"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf236f41e1722a8a40abaa9effb0e2d1cafa6100/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afa6fc1eee15dc3301f9f8e005d355620fa47438",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/afa6fc1eee15dc3301f9f8e005d355620fa47438"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 18,
      "deletions": 19
    },
    "files": [
      {
        "sha": "abdd89a038b25b23c005d4dfd6d954e0b19ea2d9",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf236f41e1722a8a40abaa9effb0e2d1cafa6100/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf236f41e1722a8a40abaa9effb0e2d1cafa6100/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
        "patch": "@@ -18,8 +18,8 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n-        super().__init__(dstaddr, dstport, net, services, send_version)\n+    def __init__(self, dstaddr, dstport):\n+        super().__init__(dstaddr, dstport)\n         self.block_receive_map = defaultdict(int)\n \n     def on_inv(self, message):"
      },
      {
        "sha": "d47746249971c05447e491feb9db2ccab869ca63",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 16,
        "deletions": 17,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf236f41e1722a8a40abaa9effb0e2d1cafa6100/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf236f41e1722a8a40abaa9effb0e2d1cafa6100/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
        "patch": "@@ -74,7 +74,7 @@ class NodeConn(asyncore.dispatcher):\n \n     TODO: rename this class P2PConnection.\"\"\"\n \n-    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+    def __init__(self, dstaddr, dstport, net=\"regtest\"):\n         super().__init__(map=mininode_socket_map)\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n@@ -86,23 +86,12 @@ def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_\n         self.network = net\n         self.disconnect = False\n \n-        if send_version:\n-            # stuff version msg into sendbuf\n-            # TODO: this is P2P payload-level logic. It should live in NodeConnCB\n-            vt = msg_version()\n-            vt.nServices = services\n-            vt.addrTo.ip = self.dstaddr\n-            vt.addrTo.port = self.dstport\n-            vt.addrFrom.ip = \"0.0.0.0\"\n-            vt.addrFrom.port = 0\n-            self.send_message(vt, True)\n-\n         logger.info('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n-        # try:\n-        self.connect((dstaddr, dstport))\n-        # except:\n-        #     self.handle_close()\n+        try:\n+            self.connect((dstaddr, dstport))\n+        except:\n+            self.handle_close()\n \n     # Connection and disconnection methods\n \n@@ -261,7 +250,17 @@ class NodeConnCB(NodeConn):\n     TODO: rename this class P2PInterface\"\"\"\n \n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n-        super().__init__(dstaddr, dstport, net, services, send_version)\n+        super().__init__(dstaddr, dstport, net)\n+\n+        if send_version:\n+            # send a version msg\n+            vt = msg_version()\n+            vt.nServices = services\n+            vt.addrTo.ip = self.dstaddr\n+            vt.addrTo.port = self.dstport\n+            vt.addrFrom.ip = \"0.0.0.0\"\n+            vt.addrFrom.port = 0\n+            self.send_message(vt, True)\n \n         # Track number of messages of each type received and the most recent\n         # message of each type"
      }
    ]
  },
  {
    "sha": "293459aee935cf217f0d3cdd00b055575aacc6d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOTM0NTlhZWU5MzVjZjIxN2YwZDNjZGQwMGIwNTU1NzVhYWNjNmQy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T20:16:39Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-18T12:34:45Z"
      },
      "message": "[tests] Rename NodeConn and NodeConnCB\n\nNodeConn -> P2PConnection\nNodeConnCB -> P2PInterface",
      "tree": {
        "sha": "96adaf7bd2a4340a3caca0cc80589924c6590fee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96adaf7bd2a4340a3caca0cc80589924c6590fee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/293459aee935cf217f0d3cdd00b055575aacc6d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/293459aee935cf217f0d3cdd00b055575aacc6d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/293459aee935cf217f0d3cdd00b055575aacc6d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/293459aee935cf217f0d3cdd00b055575aacc6d2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf236f41e1722a8a40abaa9effb0e2d1cafa6100",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cf236f41e1722a8a40abaa9effb0e2d1cafa6100"
      }
    ],
    "stats": {
      "total": 100,
      "additions": 47,
      "deletions": 53
    },
    "files": [
      {
        "sha": "193ca947bc662db0fb69bf050cd81be5ef15cb62",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -63,12 +63,12 @@ wrappers for them, `msg_block`, `msg_tx`, etc).\n with the bitcoind(s) being tested (using python's asyncore package); the other\n implements the test logic.\n \n-- `NodeConn` is the class used to connect to a bitcoind.  If you implement\n-a callback class that derives from `NodeConnCB` and pass that to the\n-`NodeConn` object, your code will receive the appropriate callbacks when\n-events of interest arrive.\n+- `P2PConnection` is the class used to connect to a bitcoind.  `P2PInterface`\n+contains the higher level logic for processing P2P payloads and connecting to\n+the Bitcoin Core node application logic. For custom behaviour, subclass the\n+P2PInterface object and override the callback methods.\n \n-- Call `NetworkThread.start()` after all `NodeConn` objects are created to\n+- Call `NetworkThread.start()` after all `P2PInterface` objects are created to\n start the networking thread.  (Continue with the test logic in your existing\n thread.)\n "
      },
      {
        "sha": "32c067f7a804489225107771f7ab79559ecfd5fc",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -39,14 +39,14 @@\n                                      CTxIn,\n                                      CTxOut,\n                                      NetworkThread,\n-                                     NodeConnCB,\n+                                     P2PInterface,\n                                      msg_block,\n                                      msg_headers)\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n-class BaseNode(NodeConnCB):\n+class BaseNode(P2PInterface):\n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n         headers_message.headers = [CBlockHeader(b) for b in new_blocks]"
      },
      {
        "sha": "0ef2bdcb14cbceb2c4bf89ff984fc9d25d722acd",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -66,7 +66,7 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "0c36d63f3eb7cffab113ff78441179f2a41ce88e",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -54,7 +54,7 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "5b0f3e39ee9642b3c168c71bf50d81b33930096e",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -18,7 +18,7 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConnCB,\n+    P2PInterface,\n     mininode_lock,\n     msg_block,\n     msg_getdata,\n@@ -31,15 +31,15 @@\n     wait_until,\n )\n \n-# NodeConnCB is a class containing callbacks to be executed when a P2P\n-# message is received from the node-under-test. Subclass NodeConnCB and\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n # override the on_*() methods if you need custom behaviour.\n-class BaseNode(NodeConnCB):\n+class BaseNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n-        \"\"\"Initialize the NodeConnCB\n+        \"\"\"Initialize the P2PInterface\n \n         Used to inialize custom properties for the Node that aren't\n-        included by default in the base class. Be aware that the NodeConnCB\n+        included by default in the base class. Be aware that the P2PInterface\n         base class already stores a counter for each P2P message type and the\n         last received message of each type, which should be sufficient for the\n         needs of most tests.\n@@ -175,7 +175,7 @@ def run_test(self):\n             block = create_block(self.tip, create_coinbase(height), self.block_time)\n             block.solve()\n             block_message = msg_block(block)\n-            # Send message is used to send a P2P message to the node over our NodeConn connection\n+            # Send message is used to send a P2P message to the node over our P2PInterface\n             self.nodes[0].send_message(block_message)\n             self.tip = block.sha256\n             blocks.append(self.tip)\n@@ -200,12 +200,12 @@ def run_test(self):\n         self.nodes[2].send_message(getdata_request)\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n-        # NodeConnCB objects.\n+        # P2PInterface objects.\n         wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n \n         self.log.info(\"Check that each block was received only once\")\n-        # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving\n-        # messages. The test thread should acquire the global lock before accessing any NodeConn data to avoid locking\n+        # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n+        # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n         # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n         with mininode_lock:\n             for block in self.nodes[2].p2p.block_receive_map.values():"
      },
      {
        "sha": "918ffd4eaf88a330efff1d5cce6a207d1745dabe",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -17,9 +17,9 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n-class TestNode(NodeConnCB):\n-    def __init__(self, dstaddr, dstport):\n-        super().__init__(dstaddr, dstport)\n+class TestNode(P2PInterface):\n+    def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n+        super().__init__(dstaddr, dstport, net, services, send_version)\n         self.block_receive_map = defaultdict(int)\n \n     def on_inv(self, message):"
      },
      {
        "sha": "73fa173bf32ecf79b5627750ec2b88a302b647fd",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -12,7 +12,7 @@\n whitelist localhost, but node1 does. They will each be on their own chain for\n this test.\n \n-We have one NodeConn connection to each, test_node and white_node respectively.\n+We have one P2PInterface connection to each, test_node and white_node respectively.\n \n The test:\n 1. Generate one block on each node, to leave IBD.\n@@ -74,9 +74,9 @@ def setup_network(self):\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         # test_node connects to node0 (not whitelisted)\n-        test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        test_node = self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface)\n         # test_node connects to node1 (whitelisted)\n-        white_node = self.nodes[1].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        white_node = self.nodes[1].add_p2p_connection(p2p_conn_type=P2PInterface)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "59f7c925c174ae69e3def48cb08962c13731c542",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -15,7 +15,7 @@\n from test_framework.script import CScript, OP_TRUE\n \n # TestNode: A peer we use to send messages to bitcoind, and store responses.\n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)\n         self.last_sendcmpct = []"
      },
      {
        "sha": "a6cdc5c5668ab232b75c22be3e6e7442826996e1",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -22,7 +22,7 @@ def allInvsMatch(invsExpected, testnode):\n         time.sleep(1)\n     return False\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)\n         self.txinvs = []"
      },
      {
        "sha": "77874727ddb76a93dfd9c824c9063fb7e699af3c",
        "filename": "test/functional/p2p-fingerprint.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-fingerprint.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -14,7 +14,7 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConnCB,\n+    P2PInterface,\n     msg_headers,\n     msg_block,\n     msg_getdata,\n@@ -73,7 +73,7 @@ def last_header_equals(self, expected_hash, node):\n     # This does not currently test that stale blocks timestamped within the\n     # last month but that have over a month's worth of work are also withheld.\n     def run_test(self):\n-        p2p = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        p2p = self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface)\n \n         NetworkThread().start()\n         p2p.wait_for_verack()"
      },
      {
        "sha": "db67451af74905fb943bd52cf6b5c78bcb20c8c3",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -20,7 +20,7 @@\n \n banscore = 10\n \n-class CLazyNode(NodeConnCB):\n+class CLazyNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)\n         self.unexpected_msg = False\n@@ -140,10 +140,10 @@ def run_test(self):\n         self.log.info(\"Service bits 5 and 7 are allowed after August 1st 2018\")\n         self.nodes[0].setmocktime(1533168000)  # August 2nd 2018\n \n-        allowed_service_bit5_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n-        allowed_service_bit7_node = self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n+        allowed_service_bit5_node = self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n+        allowed_service_bit7_node = self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n-        NetworkThread().start()  # Network thread stopped when all previous NodeConnCBs disconnected. Restart it\n+        NetworkThread().start()  # Network thread stopped when all previous P2PInterfaces disconnected. Restart it\n \n         wait_until(lambda: allowed_service_bit5_node.message_count[\"verack\"], lock=mininode_lock)\n         wait_until(lambda: allowed_service_bit7_node.message_count[\"verack\"], lock=mininode_lock)"
      },
      {
        "sha": "29378b27949360620a49c3a5623b9735e17e0c2d",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -20,7 +20,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         # Add a p2p connection\n-        self.nodes[0].add_p2p_connection(p2p_conn_type=NodeConnCB)\n+        self.nodes[0].add_p2p_connection(p2p_conn_type=P2PInterface)\n         NetworkThread().start()\n         self.nodes[0].p2p.wait_for_verack()\n "
      },
      {
        "sha": "3e0c8042b4f36932cccc9c38dc80fb5e7902b359",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -59,7 +59,7 @@ def test_witness_block(node, p2p, block, accepted, with_witness=True):\n     p2p.sync_with_ping()\n     assert_equal(node.rpc.getbestblockhash() == block.hash, accepted)\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)\n         self.getdataset = set()"
      },
      {
        "sha": "f79294bc993224ef9d4fe7ec4445b878103c8591",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -27,7 +27,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def on_version(self, message):\n         # Don't send a verack in response\n         pass"
      },
      {
        "sha": "bc7115ba35171fe13f0370c59089bb7ddfc4aebb",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -23,7 +23,7 @@\n WARN_UNKNOWN_RULES_ACTIVE = \"unknown new rules activated (versionbit {})\".format(VB_UNKNOWN_BIT)\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def on_inv(self, message):\n         pass\n "
      },
      {
        "sha": "8f6f3e046e2bf159bbeb4d029165df1c54ed9e4e",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -81,7 +81,7 @@\n \n direct_fetch_response_time = 0.05\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)\n         self.block_announced = False"
      },
      {
        "sha": "5b1e6c7f1fffe0c6a1e7e9e64ea835a8d7c620bb",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -39,7 +39,7 @@ def match(self, other):\n     def __repr__(self):\n         return '%i:%s' % (self.code,self.reason or '*')\n \n-class TestNode(NodeConnCB):\n+class TestNode(P2PInterface):\n \n     def __init__(self, block_store, tx_store, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net, services, send_version)"
      },
      {
        "sha": "403b193e3986c214ce4232b183ea6c77e44c57f6",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 8,
        "deletions": 14,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/293459aee935cf217f0d3cdd00b055575aacc6d2/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=293459aee935cf217f0d3cdd00b055575aacc6d2",
        "patch": "@@ -9,10 +9,8 @@\n This python code was modified from ArtForz' public domain  half-a-node, as\n found in the mini-node branch of http://github.com/jgarzik/pynode.\n \n-NodeConn: an object which manages p2p connectivity to a bitcoin node\n-NodeConnCB: a base class that describes the interface for receiving\n-            callbacks with network messages from a NodeConn\n-\"\"\"\n+P2PConnection: A low-level connection object to a node's P2P interface\n+P2PInterface: A high-level interface object for communicating to a node over P2P\"\"\"\n import asyncore\n from collections import defaultdict\n from io import BytesIO\n@@ -59,7 +57,7 @@\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n-class NodeConn(asyncore.dispatcher):\n+class P2PConnection(asyncore.dispatcher):\n     \"\"\"A low-level connection object to a node's P2P interface.\n \n     This class is responsible for:\n@@ -70,9 +68,7 @@ class NodeConn(asyncore.dispatcher):\n     - logging messages as they are sent and received\n \n     This class contains no logic for handing the P2P message payloads. It must be\n-    sub-classed and the on_message() callback overridden.\n-\n-    TODO: rename this class P2PConnection.\"\"\"\n+    sub-classed and the on_message() callback overridden.\"\"\"\n \n     def __init__(self, dstaddr, dstport, net=\"regtest\"):\n         super().__init__(map=mininode_socket_map)\n@@ -237,17 +233,15 @@ def _log_message(self, direction, msg):\n             log_message += \"... (msg truncated)\"\n         logger.debug(log_message)\n \n-class NodeConnCB(NodeConn):\n+class P2PInterface(P2PConnection):\n     \"\"\"A high-level P2P interface class for communicating with a Bitcoin node.\n \n     This class provides high-level callbacks for processing P2P message\n     payloads, as well as convenience methods for interacting with the\n     node over P2P.\n \n     Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\n-\n-    TODO: rename this class P2PInterface\"\"\"\n+    if they want to alter message handling behaviour.\"\"\"\n \n     def __init__(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         super().__init__(dstaddr, dstport, net)\n@@ -387,10 +381,10 @@ def sync_with_ping(self, timeout=60):\n \n # One lock for synchronizing all data access between the networking thread (see\n # NetworkThread below) and the thread running the test logic.  For simplicity,\n-# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n+# P2PConnection acquires this lock whenever delivering a message to a P2PInterface,\n # and whenever adding anything to the send buffer (in send_message()).  This\n # lock should be acquired in the thread running the test logic to synchronize\n-# access to any data shared with the NodeConnCB or NodeConn.\n+# access to any data shared with the P2PInterface or P2PConnection.\n mininode_lock = RLock()\n \n class NetworkThread(Thread):"
      }
    ]
  }
]