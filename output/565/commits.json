[
  {
    "sha": "31af86e0458e711208befa792b28d85b7fc20803",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMWFmODZlMDQ1OGU3MTEyMDhiZWZhNzkyYjI4ZDg1YjdmYzIwODAz",
    "commit": {
      "author": {
        "name": "David Joel Schwartz",
        "email": "davidjoelschwartz@gmail.com",
        "date": "2011-08-06T13:15:00Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-02-18T15:15:20Z"
      },
      "message": "Detect typical 'getwork' calls and accelerate them. Bypass the JSON request parser, and the JSON reply builder.",
      "tree": {
        "sha": "b2947ef9c083a1891bc78f321913d7c931c126f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2947ef9c083a1891bc78f321913d7c931c126f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31af86e0458e711208befa792b28d85b7fc20803",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31af86e0458e711208befa792b28d85b7fc20803",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/31af86e0458e711208befa792b28d85b7fc20803",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31af86e0458e711208befa792b28d85b7fc20803/comments",
    "author": {
      "login": "JoelKatz",
      "id": 877549,
      "node_id": "MDQ6VXNlcjg3NzU0OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/877549?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JoelKatz",
      "html_url": "https://github.com/JoelKatz",
      "followers_url": "https://api.github.com/users/JoelKatz/followers",
      "following_url": "https://api.github.com/users/JoelKatz/following{/other_user}",
      "gists_url": "https://api.github.com/users/JoelKatz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JoelKatz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JoelKatz/subscriptions",
      "organizations_url": "https://api.github.com/users/JoelKatz/orgs",
      "repos_url": "https://api.github.com/users/JoelKatz/repos",
      "events_url": "https://api.github.com/users/JoelKatz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JoelKatz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9a041c536f1f46d218127bad1989be58f095680",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9a041c536f1f46d218127bad1989be58f095680",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9a041c536f1f46d218127bad1989be58f095680"
      }
    ],
    "stats": {
      "total": 155,
      "additions": 123,
      "deletions": 32
    },
    "files": [
      {
        "sha": "e053dd0aac4d971adef1aaf2d66032cad0e1fb69",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 123,
        "deletions": 32,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31af86e0458e711208befa792b28d85b7fc20803/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31af86e0458e711208befa792b28d85b7fc20803/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=31af86e0458e711208befa792b28d85b7fc20803",
        "patch": "@@ -1763,37 +1763,24 @@ Value validateaddress(const Array& params, bool fHelp)\n     return ret;\n }\n \n-Value getwork(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 1)\n-        throw runtime_error(\n-            \"getwork [data]\\n\"\n-            \"If [data] is not specified, returns formatted hash data to work on:\\n\"\n-            \"  \\\"midstate\\\" : precomputed hash state after hashing the first half of the data (DEPRECATED)\\n\" // deprecated\n-            \"  \\\"data\\\" : block data\\n\"\n-            \"  \\\"hash1\\\" : formatted hash buffer for second hash (DEPRECATED)\\n\" // deprecated\n-            \"  \\\"target\\\" : little endian hash target\\n\"\n-            \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n \n-    if (vNodes.empty())\n-        throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n-\n-    if (IsInitialBlockDownload())\n-        throw JSONRPCError(-10, \"Bitcoin is downloading blocks...\");\n+static boost::mutex mGetWork;\n+static CReserveKey *reservekey = NULL;\n+typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n+static mapNewBlock_t mapNewBlock;\n \n-    typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n-    static mapNewBlock_t mapNewBlock;\n-    static vector<CBlock*> vNewBlock;\n-    static CReserveKey reservekey(pwalletMain);\n+void GetWorkBlock(char *pmidstate, char *pdata, char *phash1, uint256 &hashTarget)\n+{ // Fill the buffers with a correct work unit\n+    boost::unique_lock<boost::mutex> lock(mGetWork);\n \n-    if (params.size() == 0)\n-    {\n-        // Update block\n         static unsigned int nTransactionsUpdatedLast;\n         static CBlockIndex* pindexPrev;\n         static int64 nStart;\n         static CBlock* pblock;\n-        if (pindexPrev != pindexBest ||\n+    static vector<CBlock*> vNewBlock;\n+\n+    // Update block if needed\n+    while (pindexPrev != pindexBest ||\n             (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n         {\n             if (pindexPrev != pindexBest)\n@@ -1809,9 +1796,12 @@ Value getwork(const Array& params, bool fHelp)\n             nStart = GetTime();\n \n             // Create new block\n-            pblock = CreateNewBlock(reservekey);\n-            if (!pblock)\n+        if (reservekey == NULL)\n+            reservekey = new CReserveKey(pwalletMain);\n+        pblock = CreateNewBlock(*reservekey);\n+        if (pblock == NULL)\n                 throw JSONRPCError(-7, \"Out of memory\");\n+\n             vNewBlock.push_back(pblock);\n         }\n \n@@ -1827,12 +1817,36 @@ Value getwork(const Array& params, bool fHelp)\n         mapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, pblock->vtx[0].vin[0].scriptSig);\n \n         // Prebuild hash buffers\n+    FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n+    hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+}\n+\n+Value getwork(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw runtime_error(\n+            \"getwork [data]\\n\"\n+            \"If [data] is not specified, returns formatted hash data to work on:\\n\"\n+            \"  \\\"midstate\\\" : precomputed hash state after hashing the first half of the data (DEPRECATED)\\n\" // deprecated\n+            \"  \\\"data\\\" : block data\\n\"\n+            \"  \\\"hash1\\\" : formatted hash buffer for second hash (DEPRECATED)\\n\" // deprecated\n+            \"  \\\"target\\\" : little endian hash target\\n\"\n+            \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n+\n+    if (vNodes.empty())\n+        throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n+\n+    if (IsInitialBlockDownload())\n+        throw JSONRPCError(-10, \"Bitcoin is downloading blocks...\");\n+\n+    if (params.size() == 0)\n+    {\n         char pmidstate[32];\n         char pdata[128];\n         char phash1[64];\n-        FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n+        uint256 hashTarget;\n \n-        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+        GetWorkBlock(pmidstate, pdata, phash1, hashTarget);\n \n         Object result;\n         result.push_back(Pair(\"midstate\", HexStr(BEGIN(pmidstate), END(pmidstate)))); // deprecated\n@@ -1853,6 +1867,9 @@ Value getwork(const Array& params, bool fHelp)\n         for (int i = 0; i < 128/4; i++)\n             ((unsigned int*)pdata)[i] = ByteReverse(((unsigned int*)pdata)[i]);\n \n+        // Get exclusive access to getwork structures\n+        boost::unique_lock<boost::mutex> lock(mGetWork);\n+\n         // Get saved block\n         if (!mapNewBlock.count(pdata->hashMerkleRoot))\n             return false;\n@@ -1863,10 +1880,38 @@ Value getwork(const Array& params, bool fHelp)\n         pblock->vtx[0].vin[0].scriptSig = mapNewBlock[pdata->hashMerkleRoot].second;\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n \n-        return CheckWork(pblock, *pwalletMain, reservekey);\n+        return CheckWork(pblock, *pwalletMain, *reservekey);\n     }\n }\n \n+std::string FastGetWork(const std::string id)\n+{ // bypass JSON in the most common case\n+    if (vNodes.empty())\n+        throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n+\n+    if (IsInitialBlockDownload())\n+        throw JSONRPCError(-10, \"Bitcoin is downloading blocks...\");\n+\n+    char pmidstate[32];\n+    char pdata[128];\n+    char phash1[64];\n+    uint256 hashTarget;\n+\n+    GetWorkBlock(pmidstate, pdata, phash1, hashTarget);\n+\n+    std::string result = \"{\\\"result\\\":{\\\"midstate\\\" : \\\"\";\n+    result += HexStr(BEGIN(pmidstate), END(pmidstate));\n+    result += \"\\\",\\\"data\\\":\\\"\";\n+    result += HexStr(BEGIN(pdata), END(pdata));\n+    result += \"\\\",\\\"hash1\\\":\\\"\";\n+    result += HexStr(BEGIN(phash1), END(phash1));\n+    result += \"\\\",\\\"target\\\":\\\"\";\n+    result += HexStr(BEGIN(hashTarget), END(hashTarget));\n+    result += \"\\\"},\\\"error\\\":null,\\\"id\\\":\\\"\";\n+    result += id;\n+    result += \"\\\"}\\n\";\n+    return result;\n+}\n \n Value getmemorypool(const Array& params, bool fHelp)\n {\n@@ -2492,6 +2537,30 @@ void ThreadRPCServer2(void* parg)\n             continue;\n         }\n \n+        if ((strRequest.find(\"\\\"getwork\\\"\") != std::string::npos) && strRequest.find(\"[]\") != std::string::npos)\n+        { // This is imperfect code\n+            std::string id;\n+            size_t p = strRequest.find(\"\\\"id\\\":\\\"\");\n+            if (p != std::string::npos)\n+            {\n+                size_t ep = strRequest.find(\"\\\"\", p+6);\n+                id = strRequest.substr(p+6, p+ep);\n+            }\n+            try\n+            {\n+                stream << HTTPReply(200, FastGetWork(id)) << std::flush;\n+            }\n+            catch (std::exception& e)\n+            {\n+                ErrorReply(stream, JSONRPCError(-1, e.what()), id);\n+            }\n+            catch (Object& e)\n+            {\n+                ErrorReply(stream, e, id);\n+            }\n+            continue;\n+        }\n+\n         Value id = Value::null;\n         try\n         {\n@@ -2505,17 +2574,39 @@ void ThreadRPCServer2(void* parg)\n             id = find_value(request, \"id\");\n \n             // Parse method\n+            Value valParams = find_value(request, \"params\");\n             Value valMethod = find_value(request, \"method\");\n             if (valMethod.type() == null_type)\n                 throw JSONRPCError(-32600, \"Missing method\");\n             if (valMethod.type() != str_type)\n                 throw JSONRPCError(-32600, \"Method must be a string\");\n             string strMethod = valMethod.get_str();\n-            if (strMethod != \"getwork\" && strMethod != \"getmemorypool\")\n-                printf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+            if (strMethod != \"getwork\")\n+            {\n+                if (strMethod != \"getmemorypool\")\n+                    printf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+            }\n+            else\n+            { // is a getwork request\n+                if( (valParams.type() == array_type) && valParams.get_array().size() == 0 )\n+                {\n+                    try\n+                    {\n+                        stream << HTTPReply(200, FastGetWork(id.type()==str_type ? id.get_str() : \"\")) << std::flush;\n+                    }\n+                    catch (std::exception& e)\n+                    {\n+                        ErrorReply(stream, JSONRPCError(-1, e.what()), id);\n+                    }\n+                    catch (Object& e)\n+                    {\n+                        ErrorReply(stream, e, id);\n+                    }\n+                    continue;\n+                }\n+            }\n \n             // Parse params\n-            Value valParams = find_value(request, \"params\");\n             Array params;\n             if (valParams.type() == array_type)\n                 params = valParams.get_array();"
      }
    ]
  }
]