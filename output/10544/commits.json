[
  {
    "sha": "cf44e4ca7762742c6c3154447b40869ec9d041db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZjQ0ZTRjYTc3NjI3NDJjNmMzMTU0NDQ3YjQwODY5ZWM5ZDA0MWRi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:24:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:24:30Z"
      },
      "message": "Squashed 'src/leveldb/' changes from a31c8aa40..196962ff0\n\n196962ff0 Add AcceleratedCRC32C to port_win.h\n1bdf1c34c Merge upstream LevelDB v1.20\nd31721eb0 Merge #17: Fixed file sharing errors\nfecd44902 Fixed file sharing error in Win32Env::GetFileSize(), Win32SequentialFile::_Init(), Win32RandomAccessFile::_Init() Fixed error checking in Win32SequentialFile::_Init()\n5b7510f1b Merge #14: Merge upstream LevelDB 1.19\n0d969fd57 Merge #16: [LevelDB] Do no crash if filesystem can't fsync\nc8c029b5b [LevelDB] Do no crash if filesystem can't fsync\na53934a3a Increase leveldb version to 1.20.\nf3f139737 Separate Env tests from PosixEnv tests.\neb4f0972f leveldb: Fix compilation warnings in port_posix_sse.cc on x86 (32-bit).\nd0883b600 Fixed path to doc file: index.md.\n7fa20948d Convert documentation to markdown.\nea175e28f Implement support for Intel crc32 instruction (SSE 4.2)\n95cd743e5 Including <limits> for std::numeric_limits.\n646c3588d Limit the number of read-only files the POSIX Env will have open.\nd40bc3fa5 Merge #13: Typo\nebbd772d3 Typo\na2fb086d0 Add option for max file size. The currend hard-coded value of 2M is inefficient in colossus.\n\ngit-subtree-dir: src/leveldb\ngit-subtree-split: 196962ff01c39b4705d8117df5c3f8c205349950",
      "tree": {
        "sha": "d5a89851da0a8ab07c40966ac137f4e299c80927",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5a89851da0a8ab07c40966ac137f4e299c80927"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf44e4ca7762742c6c3154447b40869ec9d041db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf44e4ca7762742c6c3154447b40869ec9d041db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cf44e4ca7762742c6c3154447b40869ec9d041db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf44e4ca7762742c6c3154447b40869ec9d041db/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "634ad517037b319147816f1d112b066528e1724a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/634ad517037b319147816f1d112b066528e1724a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/634ad517037b319147816f1d112b066528e1724a"
      }
    ],
    "stats": {
      "total": 2565,
      "additions": 1414,
      "deletions": 1151
    },
    "files": [
      {
        "sha": "f7cc7d736c4f20d6cab6e760d43b76e880b80e95",
        "filename": "Makefile",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -44,6 +44,7 @@ TESTS = \\\n \tutil/cache_test \\\n \tutil/coding_test \\\n \tutil/crc32c_test \\\n+\tutil/env_posix_test \\\n \tutil/env_test \\\n \tutil/hash_test\n \n@@ -121,7 +122,7 @@ SHARED_MEMENVLIB = $(SHARED_OUTDIR)/libmemenv.a\n else\n # Update db.h if you change these.\n SHARED_VERSION_MAJOR = 1\n-SHARED_VERSION_MINOR = 19\n+SHARED_VERSION_MINOR = 20\n SHARED_LIB1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED_LIB2 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR)\n SHARED_LIB3 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR).$(SHARED_VERSION_MINOR)\n@@ -337,6 +338,9 @@ $(STATIC_OUTDIR)/db_test:db/db_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n $(STATIC_OUTDIR)/dbformat_test:db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+$(STATIC_OUTDIR)/env_posix_test:util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n $(STATIC_OUTDIR)/env_test:util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n@@ -412,3 +416,9 @@ $(SHARED_OUTDIR)/%.o: %.cc\n \n $(SHARED_OUTDIR)/%.o: %.c\n \t$(CC) $(CFLAGS) $(PLATFORM_SHARED_CFLAGS) -c $< -o $@\n+\n+$(STATIC_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@\n+\n+$(SHARED_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@"
      },
      {
        "sha": "a010c508585e89ad3aacf50dd3630feb05ac24db",
        "filename": "README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -16,7 +16,7 @@ Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n   * External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.\n \n # Documentation\n-  [LevelDB library documentation](https://rawgit.com/google/leveldb/master/doc/index.html) is online and bundled with the source code.\n+  [LevelDB library documentation](https://github.com/google/leveldb/blob/master/doc/index.md) is online and bundled with the source code.\n \n \n # Limitations\n@@ -113,29 +113,30 @@ by the one or two disk seeks needed to fetch the data from disk.\n Write performance will be mostly unaffected by whether or not the\n working set fits in memory.\n \n-    readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)\n-    readseq      :       0.476 micros/op;  232.3 MB/s\n-    readreverse  :       0.724 micros/op;  152.9 MB/s\n+    readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)\n+    readseq     :  0.476 micros/op;  232.3 MB/s\n+    readreverse :  0.724 micros/op;  152.9 MB/s\n \n LevelDB compacts its underlying storage data in the background to\n improve read performance.  The results listed above were done\n immediately after a lot of random writes.  The results after\n compactions (which are usually triggered automatically) are better.\n \n-    readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)\n-    readseq      :       0.423 micros/op;  261.8 MB/s\n-    readreverse  :       0.663 micros/op;  166.9 MB/s\n+    readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)\n+    readseq     :  0.423 micros/op;  261.8 MB/s\n+    readreverse :  0.663 micros/op;  166.9 MB/s\n \n Some of the high cost of reads comes from repeated decompression of blocks\n read from disk.  If we supply enough cache to the leveldb so it can hold the\n uncompressed blocks in memory, the read performance improves again:\n \n-    readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n-    readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n+    readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n+    readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n \n ## Repository contents\n \n-See doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.\n+See [doc/index.md](doc/index.md) for more explanation. See\n+[doc/impl.md](doc/impl.md) for a brief overview of the implementation.\n \n The public interface is in include/*.h.  Callers should not include or\n rely on the details of any other header files in this package.  Those\n@@ -148,7 +149,7 @@ Guide to header files:\n * **include/options.h**: Control over the behavior of an entire database,\n and also control over the behavior of individual reads and writes.\n \n-* **include/comparator.h**: Abstraction for user-specified comparison function. \n+* **include/comparator.h**: Abstraction for user-specified comparison function.\n If you want just bytewise comparison of keys, you can use the default\n comparator, but clients can write their own comparator implementations if they\n want custom ordering (e.g. to handle different character encodings, etc.)\n@@ -165,7 +166,7 @@ length into some other byte array.\n * **include/status.h**: Status is returned from many of the public interfaces\n and is used to report success and various kinds of errors.\n \n-* **include/env.h**: \n+* **include/env.h**:\n Abstraction of the OS environment.  A posix implementation of this interface is\n in util/env_posix.cc\n "
      },
      {
        "sha": "4a94715900969161b9f29d41e27f0659c648df10",
        "filename": "build_detect_platform",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_detect_platform?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -63,6 +63,7 @@ PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n PLATFORM_SHARED_VERSIONED=true\n+PLATFORM_SSEFLAGS=\n \n MEMCMP_FLAG=\n if [ \"$CXX\" = \"g++\" ]; then\n@@ -77,6 +78,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -lpthread -DOS_LINUX -DCYGWIN\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Darwin)\n         PLATFORM=OS_MACOSX\n@@ -85,24 +87,28 @@ case \"$TARGET_OS\" in\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n         PLATFORM_LIBS=\"-lpthread -lrt\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     GNU/kFreeBSD)\n         PLATFORM=OS_KFREEBSD\n@@ -115,31 +121,36 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n         PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         CROSS_COMPILE=true\n         ;;\n     HP-UX)\n         PLATFORM=OS_HPUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         # man ld: +h internal_name\n         PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n@@ -148,6 +159,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         PLATFORM_SHARED_EXT=\n         PLATFORM_SHARED_LDFLAGS=\n         PLATFORM_SHARED_CFLAGS=\n@@ -182,7 +194,7 @@ set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE $PORT_SSE_FILE\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n@@ -213,6 +225,21 @@ EOF\n     fi\n \n     rm -f $CXXOUTPUT 2>/dev/null\n+\n+    # Test if gcc SSE 4.2 is supported\n+    $CXX $CXXFLAGS -x c++ - -o $CXXOUTPUT -msse4.2 2>/dev/null  <<EOF\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        PLATFORM_SSEFLAGS=\"-msse4.2\"\n+    fi\n+\n+    rm -f $CXXOUTPUT 2>/dev/null\n+fi\n+\n+# Use the SSE 4.2 CRC32C intrinsics iff runtime checks indicate compiler supports them.\n+if [ -n \"$PLATFORM_SSEFLAGS\" ]; then\n+    PLATFORM_SSEFLAGS=\"$PLATFORM_SSEFLAGS -DLEVELDB_PLATFORM_POSIX_SSE\"\n fi\n \n PLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\n@@ -225,6 +252,7 @@ echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n echo \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SSEFLAGS=$PLATFORM_SSEFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "3ad19a512b56c92ba4d4ba26d1a8638d12611d57",
        "filename": "db/db_bench.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 9,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_bench.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -84,6 +84,14 @@ static bool FLAGS_histogram = false;\n // (initialized to default value by \"main\")\n static int FLAGS_write_buffer_size = 0;\n \n+// Number of bytes written to each file.\n+// (initialized to default value by \"main\")\n+static int FLAGS_max_file_size = 0;\n+\n+// Approximate size of user data packed per block (before compression.\n+// (initialized to default value by \"main\")\n+static int FLAGS_block_size = 0;\n+\n // Number of bytes to use as a cache of uncompressed data.\n // Negative means use default settings.\n static int FLAGS_cache_size = -1;\n@@ -109,6 +117,7 @@ static const char* FLAGS_db = NULL;\n namespace leveldb {\n \n namespace {\n+leveldb::Env* g_env = NULL;\n \n // Helper for quickly generating random data.\n class RandomGenerator {\n@@ -186,7 +195,7 @@ class Stats {\n     done_ = 0;\n     bytes_ = 0;\n     seconds_ = 0;\n-    start_ = Env::Default()->NowMicros();\n+    start_ = g_env->NowMicros();\n     finish_ = start_;\n     message_.clear();\n   }\n@@ -204,7 +213,7 @@ class Stats {\n   }\n \n   void Stop() {\n-    finish_ = Env::Default()->NowMicros();\n+    finish_ = g_env->NowMicros();\n     seconds_ = (finish_ - start_) * 1e-6;\n   }\n \n@@ -214,7 +223,7 @@ class Stats {\n \n   void FinishedSingleOp() {\n     if (FLAGS_histogram) {\n-      double now = Env::Default()->NowMicros();\n+      double now = g_env->NowMicros();\n       double micros = now - last_op_finish_;\n       hist_.Add(micros);\n       if (micros > 20000) {\n@@ -404,10 +413,10 @@ class Benchmark {\n     reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n     heap_counter_(0) {\n     std::vector<std::string> files;\n-    Env::Default()->GetChildren(FLAGS_db, &files);\n+    g_env->GetChildren(FLAGS_db, &files);\n     for (size_t i = 0; i < files.size(); i++) {\n       if (Slice(files[i]).starts_with(\"heap-\")) {\n-        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n+        g_env->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n       }\n     }\n     if (!FLAGS_use_existing_db) {\n@@ -589,7 +598,7 @@ class Benchmark {\n       arg[i].shared = &shared;\n       arg[i].thread = new ThreadState(i);\n       arg[i].thread->shared = &shared;\n-      Env::Default()->StartThread(ThreadBody, &arg[i]);\n+      g_env->StartThread(ThreadBody, &arg[i]);\n     }\n \n     shared.mu.Lock();\n@@ -700,9 +709,12 @@ class Benchmark {\n   void Open() {\n     assert(db_ == NULL);\n     Options options;\n+    options.env = g_env;\n     options.create_if_missing = !FLAGS_use_existing_db;\n     options.block_cache = cache_;\n     options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.max_file_size = FLAGS_max_file_size;\n+    options.block_size = FLAGS_block_size;\n     options.max_open_files = FLAGS_open_files;\n     options.filter_policy = filter_policy_;\n     options.reuse_logs = FLAGS_reuse_logs;\n@@ -925,7 +937,7 @@ class Benchmark {\n     char fname[100];\n     snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n     WritableFile* file;\n-    Status s = Env::Default()->NewWritableFile(fname, &file);\n+    Status s = g_env->NewWritableFile(fname, &file);\n     if (!s.ok()) {\n       fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n       return;\n@@ -934,7 +946,7 @@ class Benchmark {\n     delete file;\n     if (!ok) {\n       fprintf(stderr, \"heap profiling not supported\\n\");\n-      Env::Default()->DeleteFile(fname);\n+      g_env->DeleteFile(fname);\n     }\n   }\n };\n@@ -943,6 +955,8 @@ class Benchmark {\n \n int main(int argc, char** argv) {\n   FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n+  FLAGS_max_file_size = leveldb::Options().max_file_size;\n+  FLAGS_block_size = leveldb::Options().block_size;\n   FLAGS_open_files = leveldb::Options().max_open_files;\n   std::string default_db_path;\n \n@@ -973,6 +987,10 @@ int main(int argc, char** argv) {\n       FLAGS_value_size = n;\n     } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_write_buffer_size = n;\n+    } else if (sscanf(argv[i], \"--max_file_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_max_file_size = n;\n+    } else if (sscanf(argv[i], \"--block_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_block_size = n;\n     } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_cache_size = n;\n     } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n@@ -987,9 +1005,11 @@ int main(int argc, char** argv) {\n     }\n   }\n \n+  leveldb::g_env = leveldb::Env::Default();\n+\n   // Choose a location for the test database if none given with --db=<path>\n   if (FLAGS_db == NULL) {\n-      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      leveldb::g_env->GetTestDirectory(&default_db_path);\n       default_db_path += \"/dbbench\";\n       FLAGS_db = default_db_path.c_str();\n   }"
      },
      {
        "sha": "f43ad7679436b312959e5e0487c9313694d83ecc",
        "filename": "db/db_impl.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/db_impl.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -96,6 +96,7 @@ Options SanitizeOptions(const std::string& dbname,\n   result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n   ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n   ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n+  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);\n   ClipToRange(&result.block_size,        1<<10,                       4<<20);\n   if (result.info_log == NULL) {\n     // Open a log file in the same directory as the db"
      },
      {
        "sha": "356e69fca231def5f74b95eaff53f12f42169317",
        "filename": "db/log_format.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/db/log_format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/db/log_format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/log_format.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -3,7 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n //\n // Log format information shared by reader and writer.\n-// See ../doc/log_format.txt for more detail.\n+// See ../doc/log_format.md for more detail.\n \n #ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n #define STORAGE_LEVELDB_DB_LOG_FORMAT_H_"
      },
      {
        "sha": "b1256f90e1c2bc6f9f6f449029bed9266bbb55b9",
        "filename": "db/version_set.cc",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/version_set.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -20,30 +20,39 @@\n \n namespace leveldb {\n \n-static const int kTargetFileSize = 2 * 1048576;\n+static int TargetFileSize(const Options* options) {\n+  return options->max_file_size;\n+}\n \n // Maximum bytes of overlaps in grandparent (i.e., level+2) before we\n // stop building a single file in a level->level+1 compaction.\n-static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;\n+static int64_t MaxGrandParentOverlapBytes(const Options* options) {\n+  return 10 * TargetFileSize(options);\n+}\n \n // Maximum number of bytes in all compacted files.  We avoid expanding\n // the lower level file set of a compaction if it would make the\n // total compaction cover more than this many bytes.\n-static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;\n+static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {\n+  return 25 * TargetFileSize(options);\n+}\n \n-static double MaxBytesForLevel(int level) {\n+static double MaxBytesForLevel(const Options* options, int level) {\n   // Note: the result for level zero is not really used since we set\n   // the level-0 compaction threshold based on number of files.\n-  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n+\n+  // Result for both level-0 and level-1\n+  double result = 10. * 1048576.0;\n   while (level > 1) {\n     result *= 10;\n     level--;\n   }\n   return result;\n }\n \n-static uint64_t MaxFileSizeForLevel(int level) {\n-  return kTargetFileSize;  // We could vary per level to reduce number of files?\n+static uint64_t MaxFileSizeForLevel(const Options* options, int level) {\n+  // We could vary per level to reduce number of files?\n+  return TargetFileSize(options);\n }\n \n static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n@@ -508,7 +517,7 @@ int Version::PickLevelForMemTableOutput(\n         // Check that file does not overlap too many grandparent bytes.\n         GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n         const int64_t sum = TotalFileSize(overlaps);\n-        if (sum > kMaxGrandParentOverlapBytes) {\n+        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {\n           break;\n         }\n       }\n@@ -1027,7 +1036,7 @@ bool VersionSet::ReuseManifest(const std::string& dscname,\n       manifest_type != kDescriptorFile ||\n       !env_->GetFileSize(dscname, &manifest_size).ok() ||\n       // Make new compacted MANIFEST if old one is too big\n-      manifest_size >= kTargetFileSize) {\n+      manifest_size >= TargetFileSize(options_)) {\n     return false;\n   }\n \n@@ -1076,7 +1085,8 @@ void VersionSet::Finalize(Version* v) {\n     } else {\n       // Compute the ratio of current size to size limit.\n       const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n-      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n+      score =\n+          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);\n     }\n \n     if (score > best_score) {\n@@ -1290,7 +1300,7 @@ Compaction* VersionSet::PickCompaction() {\n     level = current_->compaction_level_;\n     assert(level >= 0);\n     assert(level+1 < config::kNumLevels);\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n \n     // Pick the first file that comes after compact_pointer_[level]\n     for (size_t i = 0; i < current_->files_[level].size(); i++) {\n@@ -1307,7 +1317,7 @@ Compaction* VersionSet::PickCompaction() {\n     }\n   } else if (seek_compaction) {\n     level = current_->file_to_compact_level_;\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n     c->inputs_[0].push_back(current_->file_to_compact_);\n   } else {\n     return NULL;\n@@ -1352,7 +1362,8 @@ void VersionSet::SetupOtherInputs(Compaction* c) {\n     const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n     const int64_t expanded0_size = TotalFileSize(expanded0);\n     if (expanded0.size() > c->inputs_[0].size() &&\n-        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n+        inputs1_size + expanded0_size <\n+            ExpandedCompactionByteSizeLimit(options_)) {\n       InternalKey new_start, new_limit;\n       GetRange(expanded0, &new_start, &new_limit);\n       std::vector<FileMetaData*> expanded1;\n@@ -1414,7 +1425,7 @@ Compaction* VersionSet::CompactRange(\n   // and we must not pick one file and drop another older file if the\n   // two files overlap.\n   if (level > 0) {\n-    const uint64_t limit = MaxFileSizeForLevel(level);\n+    const uint64_t limit = MaxFileSizeForLevel(options_, level);\n     uint64_t total = 0;\n     for (size_t i = 0; i < inputs.size(); i++) {\n       uint64_t s = inputs[i]->file_size;\n@@ -1426,17 +1437,17 @@ Compaction* VersionSet::CompactRange(\n     }\n   }\n \n-  Compaction* c = new Compaction(level);\n+  Compaction* c = new Compaction(options_, level);\n   c->input_version_ = current_;\n   c->input_version_->Ref();\n   c->inputs_[0] = inputs;\n   SetupOtherInputs(c);\n   return c;\n }\n \n-Compaction::Compaction(int level)\n+Compaction::Compaction(const Options* options, int level)\n     : level_(level),\n-      max_output_file_size_(MaxFileSizeForLevel(level)),\n+      max_output_file_size_(MaxFileSizeForLevel(options, level)),\n       input_version_(NULL),\n       grandparent_index_(0),\n       seen_key_(false),\n@@ -1453,12 +1464,13 @@ Compaction::~Compaction() {\n }\n \n bool Compaction::IsTrivialMove() const {\n+  const VersionSet* vset = input_version_->vset_;\n   // Avoid a move if there is lots of overlapping grandparent data.\n   // Otherwise, the move could create a parent file that will require\n   // a very expensive merge later on.\n-  return (num_input_files(0) == 1 &&\n-          num_input_files(1) == 0 &&\n-          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n+  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&\n+          TotalFileSize(grandparents_) <=\n+              MaxGrandParentOverlapBytes(vset->options_));\n }\n \n void Compaction::AddInputDeletions(VersionEdit* edit) {\n@@ -1491,8 +1503,9 @@ bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n }\n \n bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n+  const VersionSet* vset = input_version_->vset_;\n   // Scan to find earliest grandparent file that contains key.\n-  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n+  const InternalKeyComparator* icmp = &vset->icmp_;\n   while (grandparent_index_ < grandparents_.size() &&\n       icmp->Compare(internal_key,\n                     grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n@@ -1503,7 +1516,7 @@ bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n   }\n   seen_key_ = true;\n \n-  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n+  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {\n     // Too much overlap for current output; start new output\n     overlapped_bytes_ = 0;\n     return true;"
      },
      {
        "sha": "c4e7ac360b87d842ee9dbc0a2bf80f122a65dad7",
        "filename": "db/version_set.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/db/version_set.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -366,7 +366,7 @@ class Compaction {\n   friend class Version;\n   friend class VersionSet;\n \n-  explicit Compaction(int level);\n+  Compaction(const Options* options, int level);\n \n   int level_;\n   uint64_t max_output_file_size_;"
      },
      {
        "sha": "700c564e433827c311cd8a26896ceaa7c8260818",
        "filename": "doc/doc.css",
        "status": "removed",
        "additions": 0,
        "deletions": 89,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634ad517037b319147816f1d112b066528e1724a/doc/doc.css",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634ad517037b319147816f1d112b066528e1724a/doc/doc.css",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/doc.css?ref=634ad517037b319147816f1d112b066528e1724a",
        "patch": "@@ -1,89 +0,0 @@\n-body {\n-  margin-left: 0.5in;\n-  margin-right: 0.5in;\n-  background: white;\n-  color: black;\n-}\n-\n-h1 {\n-  margin-left: -0.2in;\n-  font-size: 14pt;\n-}\n-h2 {\n-  margin-left: -0in;\n-  font-size: 12pt;\n-}\n-h3 {\n-  margin-left: -0in;\n-}\n-h4 {\n-  margin-left: -0in;\n-}\n-hr {\n-  margin-left: -0in;\n-}\n-\n-/* Definition lists: definition term bold */\n-dt {\n-  font-weight: bold;\n-}\n-\n-address {\n-  text-align: center;\n-}\n-code,samp,var {\n-  color: blue;\n-}\n-kbd {\n-  color: #600000;\n-}\n-div.note p {\n-  float: right;\n-  width: 3in;\n-  margin-right: 0%;\n-  padding: 1px;\n-  border: 2px solid #6060a0;\n-  background-color: #fffff0;\n-}\n-\n-ul {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-ol {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-UL.nobullets {\n-  list-style-type: none;\n-  list-style-image: none;\n-  margin-left: -1em;\n-}\n-\n-p {\n-  margin: 1em 0 1em 0;\n-  padding: 0 0 0 0;\n-}\n-\n-pre {\n-  line-height: 1.3em;\n-  padding: 0.4em 0 0.8em 0;\n-  margin:  0 0 0 0;\n-  border:  0 0 0 0;\n-  color: blue;\n-}\n-\n-.datatable {\n-  margin-left: auto;\n-  margin-right: auto;\n-  margin-top: 2em;\n-  margin-bottom: 2em;\n-  border: 1px solid;\n-}\n-\n-.datatable td,th {\n-  padding: 0 0.5em 0 0.5em;\n-  text-align: right;\n-}"
      },
      {
        "sha": "6a468be0955d921a3e7bad2d55a71989209d06ae",
        "filename": "doc/impl.html",
        "status": "removed",
        "additions": 0,
        "deletions": 213,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634ad517037b319147816f1d112b066528e1724a/doc/impl.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634ad517037b319147816f1d112b066528e1724a/doc/impl.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/impl.html?ref=634ad517037b319147816f1d112b066528e1724a",
        "patch": "@@ -1,213 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb file layout and compactions</title>\n-</head>\n-\n-<body>\n-\n-<h1>Files</h1>\n-\n-The implementation of leveldb is similar in spirit to the\n-representation of a single\n-<a href=\"http://research.google.com/archive/bigtable.html\">\n-Bigtable tablet (section 5.3)</a>.\n-However the organization of the files that make up the representation\n-is somewhat different and is explained below.\n-\n-<p>\n-Each database is represented by a set of files stored in a directory.\n-There are several different types of files as documented below:\n-<p>\n-<h2>Log files</h2>\n-<p>\n-A log file (*.log) stores a sequence of recent updates.  Each update\n-is appended to the current log file.  When the log file reaches a\n-pre-determined size (approximately 4MB by default), it is converted\n-to a sorted table (see below) and a new log file is created for future\n-updates.\n-<p>\n-A copy of the current log file is kept in an in-memory structure (the\n-<code>memtable</code>).  This copy is consulted on every read so that read\n-operations reflect all logged updates.\n-<p>\n-<h2>Sorted tables</h2>\n-<p>\n-A sorted table (*.sst) stores a sequence of entries sorted by key.\n-Each entry is either a value for the key, or a deletion marker for the\n-key.  (Deletion markers are kept around to hide obsolete values\n-present in older sorted tables).\n-<p>\n-The set of sorted tables are organized into a sequence of levels.  The\n-sorted table generated from a log file is placed in a special <code>young</code>\n-level (also called level-0).  When the number of young files exceeds a\n-certain threshold (currently four), all of the young files are merged\n-together with all of the overlapping level-1 files to produce a\n-sequence of new level-1 files (we create a new level-1 file for every\n-2MB of data.)\n-<p>\n-Files in the young level may contain overlapping keys.  However files\n-in other levels have distinct non-overlapping key ranges.  Consider\n-level number L where L >= 1.  When the combined size of files in\n-level-L exceeds (10^L) MB (i.e., 10MB for level-1, 100MB for level-2,\n-...), one file in level-L, and all of the overlapping files in\n-level-(L+1) are merged to form a set of new files for level-(L+1).\n-These merges have the effect of gradually migrating new updates from\n-the young level to the largest level using only bulk reads and writes\n-(i.e., minimizing expensive seeks).\n-\n-<h2>Manifest</h2>\n-<p>\n-A MANIFEST file lists the set of sorted tables that make up each\n-level, the corresponding key ranges, and other important metadata.\n-A new MANIFEST file (with a new number embedded in the file name)\n-is created whenever the database is reopened.  The MANIFEST file is\n-formatted as a log, and changes made to the serving state (as files\n-are added or removed) are appended to this log.\n-<p>\n-<h2>Current</h2>\n-<p>\n-CURRENT is a simple text file that contains the name of the latest\n-MANIFEST file.\n-<p>\n-<h2>Info logs</h2>\n-<p>\n-Informational messages are printed to files named LOG and LOG.old.\n-<p>\n-<h2>Others</h2>\n-<p>\n-Other files used for miscellaneous purposes may also be present\n-(LOCK, *.dbtmp).\n-\n-<h1>Level 0</h1>\n-When the log file grows above a certain size (1MB by default):\n-<ul>\n-<li>Create a brand new memtable and log file and direct future updates here\n-<li>In the background:\n-<ul>\n-<li>Write the contents of the previous memtable to an sstable\n-<li>Discard the memtable\n-<li>Delete the old log file and the old memtable\n-<li>Add the new sstable to the young (level-0) level.\n-</ul>\n-</ul>\n-\n-<h1>Compactions</h1>\n-\n-<p>\n-When the size of level L exceeds its limit, we compact it in a\n-background thread.  The compaction picks a file from level L and all\n-overlapping files from the next level L+1.  Note that if a level-L\n-file overlaps only part of a level-(L+1) file, the entire file at\n-level-(L+1) is used as an input to the compaction and will be\n-discarded after the compaction.  Aside: because level-0 is special\n-(files in it may overlap each other), we treat compactions from\n-level-0 to level-1 specially: a level-0 compaction may pick more than\n-one level-0 file in case some of these files overlap each other.\n-\n-<p>\n-A compaction merges the contents of the picked files to produce a\n-sequence of level-(L+1) files.  We switch to producing a new\n-level-(L+1) file after the current output file has reached the target\n-file size (2MB).  We also switch to a new output file when the key\n-range of the current output file has grown enough to overlap more than\n-ten level-(L+2) files.  This last rule ensures that a later compaction\n-of a level-(L+1) file will not pick up too much data from level-(L+2).\n-\n-<p>\n-The old files are discarded and the new files are added to the serving\n-state.\n-\n-<p>\n-Compactions for a particular level rotate through the key space.  In\n-more detail, for each level L, we remember the ending key of the last\n-compaction at level L.  The next compaction for level L will pick the\n-first file that starts after this key (wrapping around to the\n-beginning of the key space if there is no such file).\n-\n-<p>\n-Compactions drop overwritten values.  They also drop deletion markers\n-if there are no higher numbered levels that contain a file whose range\n-overlaps the current key.\n-\n-<h2>Timing</h2>\n-\n-Level-0 compactions will read up to four 1MB files from level-0, and\n-at worst all the level-1 files (10MB).  I.e., we will read 14MB and\n-write 14MB.\n-\n-<p>\n-Other than the special level-0 compactions, we will pick one 2MB file\n-from level L.  In the worst case, this will overlap ~ 12 files from\n-level L+1 (10 because level-(L+1) is ten times the size of level-L,\n-and another two at the boundaries since the file ranges at level-L\n-will usually not be aligned with the file ranges at level-L+1).  The\n-compaction will therefore read 26MB and write 26MB.  Assuming a disk\n-IO rate of 100MB/s (ballpark range for modern drives), the worst\n-compaction cost will be approximately 0.5 second.\n-\n-<p>\n-If we throttle the background writing to something small, say 10% of\n-the full 100MB/s speed, a compaction may take up to 5 seconds.  If the\n-user is writing at 10MB/s, we might build up lots of level-0 files\n-(~50 to hold the 5*10MB).  This may significantly increase the cost of\n-reads due to the overhead of merging more files together on every\n-read.\n-\n-<p>\n-Solution 1: To reduce this problem, we might want to increase the log\n-switching threshold when the number of level-0 files is large.  Though\n-the downside is that the larger this threshold, the more memory we will\n-need to hold the corresponding memtable.\n-\n-<p>\n-Solution 2: We might want to decrease write rate artificially when the\n-number of level-0 files goes up.\n-\n-<p>\n-Solution 3: We work on reducing the cost of very wide merges.\n-Perhaps most of the level-0 files will have their blocks sitting\n-uncompressed in the cache and we will only need to worry about the\n-O(N) complexity in the merging iterator.\n-\n-<h2>Number of files</h2>\n-\n-Instead of always making 2MB files, we could make larger files for\n-larger levels to reduce the total file count, though at the expense of\n-more bursty compactions.  Alternatively, we could shard the set of\n-files into multiple directories.\n-\n-<p>\n-An experiment on an <code>ext3</code> filesystem on Feb 04, 2011 shows\n-the following timings to do 100K file opens in directories with\n-varying number of files:\n-<table class=\"datatable\">\n-<tr><th>Files in directory</th><th>Microseconds to open a file</th></tr>\n-<tr><td>1000</td><td>9</td>\n-<tr><td>10000</td><td>10</td>\n-<tr><td>100000</td><td>16</td>\n-</table>\n-So maybe even the sharding is not necessary on modern filesystems?\n-\n-<h1>Recovery</h1>\n-\n-<ul>\n-<li> Read CURRENT to find name of the latest committed MANIFEST\n-<li> Read the named MANIFEST file\n-<li> Clean up stale files\n-<li> We could open all sstables here, but it is probably better to be lazy...\n-<li> Convert log chunk to a new level-0 sstable\n-<li> Start directing new writes to a new log file with recovered sequence#\n-</ul>\n-\n-<h1>Garbage collection of files</h1>\n-\n-<code>DeleteObsoleteFiles()</code> is called at the end of every\n-compaction and at the end of recovery.  It finds the names of all\n-files in the database.  It deletes all log files that are not the\n-current log file.  It deletes all table files that are not referenced\n-from some level and are not the output of an active compaction.\n-\n-</body>\n-</html>"
      },
      {
        "sha": "4b13f2a6ba73bd46667eec0e63e6af6e10bad6d4",
        "filename": "doc/impl.md",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/impl.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/impl.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/impl.md?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,170 @@\n+## Files\n+\n+The implementation of leveldb is similar in spirit to the representation of a\n+single [Bigtable tablet (section 5.3)](http://research.google.com/archive/bigtable.html).\n+However the organization of the files that make up the representation is\n+somewhat different and is explained below.\n+\n+Each database is represented by a set of files stored in a directory. There are\n+several different types of files as documented below:\n+\n+### Log files\n+\n+A log file (*.log) stores a sequence of recent updates. Each update is appended\n+to the current log file. When the log file reaches a pre-determined size\n+(approximately 4MB by default), it is converted to a sorted table (see below)\n+and a new log file is created for future updates.\n+\n+A copy of the current log file is kept in an in-memory structure (the\n+`memtable`). This copy is consulted on every read so that read operations\n+reflect all logged updates.\n+\n+## Sorted tables\n+\n+A sorted table (*.ldb) stores a sequence of entries sorted by key. Each entry is\n+either a value for the key, or a deletion marker for the key. (Deletion markers\n+are kept around to hide obsolete values present in older sorted tables).\n+\n+The set of sorted tables are organized into a sequence of levels. The sorted\n+table generated from a log file is placed in a special **young** level (also\n+called level-0). When the number of young files exceeds a certain threshold\n+(currently four), all of the young files are merged together with all of the\n+overlapping level-1 files to produce a sequence of new level-1 files (we create\n+a new level-1 file for every 2MB of data.)\n+\n+Files in the young level may contain overlapping keys. However files in other\n+levels have distinct non-overlapping key ranges. Consider level number L where\n+L >= 1. When the combined size of files in level-L exceeds (10^L) MB (i.e., 10MB\n+for level-1, 100MB for level-2, ...), one file in level-L, and all of the\n+overlapping files in level-(L+1) are merged to form a set of new files for\n+level-(L+1). These merges have the effect of gradually migrating new updates\n+from the young level to the largest level using only bulk reads and writes\n+(i.e., minimizing expensive seeks).\n+\n+### Manifest\n+\n+A MANIFEST file lists the set of sorted tables that make up each level, the\n+corresponding key ranges, and other important metadata. A new MANIFEST file\n+(with a new number embedded in the file name) is created whenever the database\n+is reopened. The MANIFEST file is formatted as a log, and changes made to the\n+serving state (as files are added or removed) are appended to this log.\n+\n+### Current\n+\n+CURRENT is a simple text file that contains the name of the latest MANIFEST\n+file.\n+\n+### Info logs\n+\n+Informational messages are printed to files named LOG and LOG.old.\n+\n+### Others\n+\n+Other files used for miscellaneous purposes may also be present (LOCK, *.dbtmp).\n+\n+## Level 0\n+\n+When the log file grows above a certain size (1MB by default):\n+Create a brand new memtable and log file and direct future updates here\n+In the background:\n+Write the contents of the previous memtable to an sstable\n+Discard the memtable\n+Delete the old log file and the old memtable\n+Add the new sstable to the young (level-0) level.\n+\n+## Compactions\n+\n+When the size of level L exceeds its limit, we compact it in a background\n+thread. The compaction picks a file from level L and all overlapping files from\n+the next level L+1. Note that if a level-L file overlaps only part of a\n+level-(L+1) file, the entire file at level-(L+1) is used as an input to the\n+compaction and will be discarded after the compaction.  Aside: because level-0\n+is special (files in it may overlap each other), we treat compactions from\n+level-0 to level-1 specially: a level-0 compaction may pick more than one\n+level-0 file in case some of these files overlap each other.\n+\n+A compaction merges the contents of the picked files to produce a sequence of\n+level-(L+1) files. We switch to producing a new level-(L+1) file after the\n+current output file has reached the target file size (2MB). We also switch to a\n+new output file when the key range of the current output file has grown enough\n+to overlap more than ten level-(L+2) files.  This last rule ensures that a later\n+compaction of a level-(L+1) file will not pick up too much data from\n+level-(L+2).\n+\n+The old files are discarded and the new files are added to the serving state.\n+\n+Compactions for a particular level rotate through the key space. In more detail,\n+for each level L, we remember the ending key of the last compaction at level L.\n+The next compaction for level L will pick the first file that starts after this\n+key (wrapping around to the beginning of the key space if there is no such\n+file).\n+\n+Compactions drop overwritten values. They also drop deletion markers if there\n+are no higher numbered levels that contain a file whose range overlaps the\n+current key.\n+\n+### Timing\n+\n+Level-0 compactions will read up to four 1MB files from level-0, and at worst\n+all the level-1 files (10MB). I.e., we will read 14MB and write 14MB.\n+\n+Other than the special level-0 compactions, we will pick one 2MB file from level\n+L. In the worst case, this will overlap ~ 12 files from level L+1 (10 because\n+level-(L+1) is ten times the size of level-L, and another two at the boundaries\n+since the file ranges at level-L will usually not be aligned with the file\n+ranges at level-L+1). The compaction will therefore read 26MB and write 26MB.\n+Assuming a disk IO rate of 100MB/s (ballpark range for modern drives), the worst\n+compaction cost will be approximately 0.5 second.\n+\n+If we throttle the background writing to something small, say 10% of the full\n+100MB/s speed, a compaction may take up to 5 seconds. If the user is writing at\n+10MB/s, we might build up lots of level-0 files (~50 to hold the 5*10MB). This\n+may significantly increase the cost of reads due to the overhead of merging more\n+files together on every read.\n+\n+Solution 1: To reduce this problem, we might want to increase the log switching\n+threshold when the number of level-0 files is large. Though the downside is that\n+the larger this threshold, the more memory we will need to hold the\n+corresponding memtable.\n+\n+Solution 2: We might want to decrease write rate artificially when the number of\n+level-0 files goes up.\n+\n+Solution 3: We work on reducing the cost of very wide merges. Perhaps most of\n+the level-0 files will have their blocks sitting uncompressed in the cache and\n+we will only need to worry about the O(N) complexity in the merging iterator.\n+\n+### Number of files\n+\n+Instead of always making 2MB files, we could make larger files for larger levels\n+to reduce the total file count, though at the expense of more bursty\n+compactions.  Alternatively, we could shard the set of files into multiple\n+directories.\n+\n+An experiment on an ext3 filesystem on Feb 04, 2011 shows the following timings\n+to do 100K file opens in directories with varying number of files:\n+\n+\n+| Files in directory | Microseconds to open a file |\n+|-------------------:|----------------------------:|\n+|               1000 |                           9 |\n+|              10000 |                          10 |\n+|             100000 |                          16 |\n+\n+So maybe even the sharding is not necessary on modern filesystems?\n+\n+## Recovery\n+\n+* Read CURRENT to find name of the latest committed MANIFEST\n+* Read the named MANIFEST file\n+* Clean up stale files\n+* We could open all sstables here, but it is probably better to be lazy...\n+* Convert log chunk to a new level-0 sstable\n+* Start directing new writes to a new log file with recovered sequence#\n+\n+## Garbage collection of files\n+\n+`DeleteObsoleteFiles()` is called at the end of every compaction and at the end\n+of recovery. It finds the names of all files in the database. It deletes all log\n+files that are not the current log file. It deletes all table files that are not\n+referenced from some level and are not the output of an active compaction."
      },
      {
        "sha": "2155192581e7b79784564f190a47138ae29461f0",
        "filename": "doc/index.html",
        "status": "removed",
        "additions": 0,
        "deletions": 549,
        "changes": 549,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634ad517037b319147816f1d112b066528e1724a/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634ad517037b319147816f1d112b066528e1724a/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/index.html?ref=634ad517037b319147816f1d112b066528e1724a",
        "patch": "@@ -1,549 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb</title>\n-</head>\n-\n-<body>\n-<h1>Leveldb</h1>\n-<address>Jeff Dean, Sanjay Ghemawat</address>\n-<p>\n-The <code>leveldb</code> library provides a persistent key value store.  Keys and\n-values are arbitrary byte arrays.  The keys are ordered within the key\n-value store according to a user-specified comparator function.\n-\n-<p>\n-<h1>Opening A Database</h1>\n-<p>\n-A <code>leveldb</code> database has a name which corresponds to a file system\n-directory.  All of the contents of database are stored in this\n-directory.  The following example shows how to open a database,\n-creating it if necessary:\n-<p>\n-<pre>\n-  #include &lt;cassert&gt;\n-  #include \"leveldb/db.h\"\n-\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  assert(status.ok());\n-  ...\n-</pre>\n-If you want to raise an error if the database already exists, add\n-the following line before the <code>leveldb::DB::Open</code> call:\n-<pre>\n-  options.error_if_exists = true;\n-</pre>\n-<h1>Status</h1>\n-<p>\n-You may have noticed the <code>leveldb::Status</code> type above.  Values of this\n-type are returned by most functions in <code>leveldb</code> that may encounter an\n-error.  You can check if such a result is ok, and also print an\n-associated error message:\n-<p>\n-<pre>\n-   leveldb::Status s = ...;\n-   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;\n-</pre>\n-<h1>Closing A Database</h1>\n-<p>\n-When you are done with a database, just delete the database object.\n-Example:\n-<p>\n-<pre>\n-  ... open the db as described above ...\n-  ... do something with db ...\n-  delete db;\n-</pre>\n-<h1>Reads And Writes</h1>\n-<p>\n-The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to\n-modify/query the database.  For example, the following code\n-moves the value stored under key1 to key2.\n-<pre>\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);\n-  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);\n-</pre>\n-\n-<h1>Atomic Updates</h1>\n-<p>\n-Note that if the process dies after the Put of key2 but before the\n-delete of key1, the same value may be left stored under multiple keys.\n-Such problems can be avoided by using the <code>WriteBatch</code> class to\n-atomically apply a set of updates:\n-<p>\n-<pre>\n-  #include \"leveldb/write_batch.h\"\n-  ...\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) {\n-    leveldb::WriteBatch batch;\n-    batch.Delete(key1);\n-    batch.Put(key2, value);\n-    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);\n-  }\n-</pre>\n-The <code>WriteBatch</code> holds a sequence of edits to be made to the database,\n-and these edits within the batch are applied in order.  Note that we\n-called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,\n-we do not end up erroneously dropping the value entirely.\n-<p>\n-Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to\n-speed up bulk updates by placing lots of individual mutations into the\n-same batch.\n-\n-<h1>Synchronous Writes</h1>\n-By default, each write to <code>leveldb</code> is asynchronous: it\n-returns after pushing the write from the process into the operating\n-system.  The transfer from operating system memory to the underlying\n-persistent storage happens asynchronously.  The <code>sync</code> flag\n-can be turned on for a particular write to make the write operation\n-not return until the data being written has been pushed all the way to\n-persistent storage.  (On Posix systems, this is implemented by calling\n-either <code>fsync(...)</code> or <code>fdatasync(...)</code> or\n-<code>msync(..., MS_SYNC)</code> before the write operation returns.)\n-<pre>\n-  leveldb::WriteOptions write_options;\n-  write_options.sync = true;\n-  db-&gt;Put(write_options, ...);\n-</pre>\n-Asynchronous writes are often more than a thousand times as fast as\n-synchronous writes.  The downside of asynchronous writes is that a\n-crash of the machine may cause the last few updates to be lost.  Note\n-that a crash of just the writing process (i.e., not a reboot) will not\n-cause any loss since even when <code>sync</code> is false, an update\n-is pushed from the process memory into the operating system before it\n-is considered done.\n-\n-<p>\n-Asynchronous writes can often be used safely.  For example, when\n-loading a large amount of data into the database you can handle lost\n-updates by restarting the bulk load after a crash.  A hybrid scheme is\n-also possible where every Nth write is synchronous, and in the event\n-of a crash, the bulk load is restarted just after the last synchronous\n-write finished by the previous run.  (The synchronous write can update\n-a marker that describes where to restart on a crash.)\n-\n-<p>\n-<code>WriteBatch</code> provides an alternative to asynchronous writes.\n-Multiple updates may be placed in the same <code>WriteBatch</code> and\n-applied together using a synchronous write (i.e.,\n-<code>write_options.sync</code> is set to true).  The extra cost of\n-the synchronous write will be amortized across all of the writes in\n-the batch.\n-\n-<p>\n-<h1>Concurrency</h1>\n-<p>\n-A database may only be opened by one process at a time.\n-The <code>leveldb</code> implementation acquires a lock from the\n-operating system to prevent misuse.  Within a single process, the\n-same <code>leveldb::DB</code> object may be safely shared by multiple\n-concurrent threads.  I.e., different threads may write into or fetch\n-iterators or call <code>Get</code> on the same database without any\n-external synchronization (the leveldb implementation will\n-automatically do the required synchronization).  However other objects\n-(like Iterator and WriteBatch) may require external synchronization.\n-If two threads share such an object, they must protect access to it\n-using their own locking protocol.  More details are available in\n-the public header files.\n-<p>\n-<h1>Iteration</h1>\n-<p>\n-The following example demonstrates how to print all key,value pairs\n-in a database.\n-<p>\n-<pre>\n-  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; \": \"  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;\n-  }\n-  assert(it-&gt;status().ok());  // Check for any errors found during the scan\n-  delete it;\n-</pre>\n-The following variation shows how to process just the keys in the\n-range <code>[start,limit)</code>:\n-<p>\n-<pre>\n-  for (it-&gt;Seek(start);\n-       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;\n-       it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-You can also process entries in reverse order.  (Caveat: reverse\n-iteration may be somewhat slower than forward iteration.)\n-<p>\n-<pre>\n-  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {\n-    ...\n-  }\n-</pre>\n-<h1>Snapshots</h1>\n-<p>\n-Snapshots provide consistent read-only views over the entire state of\n-the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate\n-that a read should operate on a particular version of the DB state.\n-If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an\n-implicit snapshot of the current state.\n-<p>\n-Snapshots are created by the DB::GetSnapshot() method:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.snapshot = db-&gt;GetSnapshot();\n-  ... apply some updates to db ...\n-  leveldb::Iterator* iter = db-&gt;NewIterator(options);\n-  ... read using iter to view the state when the snapshot was created ...\n-  delete iter;\n-  db-&gt;ReleaseSnapshot(options.snapshot);\n-</pre>\n-Note that when a snapshot is no longer needed, it should be released\n-using the DB::ReleaseSnapshot interface.  This allows the\n-implementation to get rid of state that was being maintained just to\n-support reading as of that snapshot.\n-<h1>Slice</h1>\n-<p>\n-The return value of the <code>it->key()</code> and <code>it->value()</code> calls above\n-are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple\n-structure that contains a length and a pointer to an external byte\n-array.  Returning a <code>Slice</code> is a cheaper alternative to returning a\n-<code>std::string</code> since we do not need to copy potentially large keys and\n-values.  In addition, <code>leveldb</code> methods do not return null-terminated\n-C-style strings since <code>leveldb</code> keys and values are allowed to\n-contain '\\0' bytes.\n-<p>\n-C++ strings and null-terminated C-style strings can be easily converted\n-to a Slice:\n-<p>\n-<pre>\n-   leveldb::Slice s1 = \"hello\";\n-\n-   std::string str(\"world\");\n-   leveldb::Slice s2 = str;\n-</pre>\n-A Slice can be easily converted back to a C++ string:\n-<pre>\n-   std::string str = s1.ToString();\n-   assert(str == std::string(\"hello\"));\n-</pre>\n-Be careful when using Slices since it is up to the caller to ensure that\n-the external byte array into which the Slice points remains live while\n-the Slice is in use.  For example, the following is buggy:\n-<p>\n-<pre>\n-   leveldb::Slice slice;\n-   if (...) {\n-     std::string str = ...;\n-     slice = str;\n-   }\n-   Use(slice);\n-</pre>\n-When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the\n-backing storage for <code>slice</code> will disappear.\n-<p>\n-<h1>Comparators</h1>\n-<p>\n-The preceding examples used the default ordering function for key,\n-which orders bytes lexicographically.  You can however supply a custom\n-comparator when opening a database.  For example, suppose each\n-database key consists of two numbers and we should sort by the first\n-number, breaking ties by the second number.  First, define a proper\n-subclass of <code>leveldb::Comparator</code> that expresses these rules:\n-<p>\n-<pre>\n-  class TwoPartComparator : public leveldb::Comparator {\n-   public:\n-    // Three-way comparison function:\n-    //   if a &lt; b: negative result\n-    //   if a &gt; b: positive result\n-    //   else: zero result\n-    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {\n-      int a1, a2, b1, b2;\n-      ParseKey(a, &amp;a1, &amp;a2);\n-      ParseKey(b, &amp;b1, &amp;b2);\n-      if (a1 &lt; b1) return -1;\n-      if (a1 &gt; b1) return +1;\n-      if (a2 &lt; b2) return -1;\n-      if (a2 &gt; b2) return +1;\n-      return 0;\n-    }\n-\n-    // Ignore the following methods for now:\n-    const char* Name() const { return \"TwoPartComparator\"; }\n-    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }\n-    void FindShortSuccessor(std::string*) const { }\n-  };\n-</pre>\n-Now create a database using this custom comparator:\n-<p>\n-<pre>\n-  TwoPartComparator cmp;\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  options.comparator = &amp;cmp;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  ...\n-</pre>\n-<h2>Backwards compatibility</h2>\n-<p>\n-The result of the comparator's <code>Name</code> method is attached to the\n-database when it is created, and is checked on every subsequent\n-database open.  If the name changes, the <code>leveldb::DB::Open</code> call will\n-fail.  Therefore, change the name if and only if the new key format\n-and comparison function are incompatible with existing databases, and\n-it is ok to discard the contents of all existing databases.\n-<p>\n-You can however still gradually evolve your key format over time with\n-a little bit of pre-planning.  For example, you could store a version\n-number at the end of each key (one byte should suffice for most uses).\n-When you wish to switch to a new key format (e.g., adding an optional\n-third part to the keys processed by <code>TwoPartComparator</code>),\n-(a) keep the same comparator name (b) increment the version number\n-for new keys (c) change the comparator function so it uses the\n-version numbers found in the keys to decide how to interpret them.\n-<p>\n-<h1>Performance</h1>\n-<p>\n-Performance can be tuned by changing the default values of the\n-types defined in <code>include/leveldb/options.h</code>.\n-\n-<p>\n-<h2>Block size</h2>\n-<p>\n-<code>leveldb</code> groups adjacent keys together into the same block and such a\n-block is the unit of transfer to and from persistent storage.  The\n-default block size is approximately 4096 uncompressed bytes.\n-Applications that mostly do bulk scans over the contents of the\n-database may wish to increase this size.  Applications that do a lot\n-of point reads of small values may wish to switch to a smaller block\n-size if performance measurements indicate an improvement.  There isn't\n-much benefit in using blocks smaller than one kilobyte, or larger than\n-a few megabytes.  Also note that compression will be more effective\n-with larger block sizes.\n-<p>\n-<h2>Compression</h2>\n-<p>\n-Each block is individually compressed before being written to\n-persistent storage.  Compression is on by default since the default\n-compression method is very fast, and is automatically disabled for\n-uncompressible data.  In rare cases, applications may want to disable\n-compression entirely, but should only do so if benchmarks show a\n-performance improvement:\n-<p>\n-<pre>\n-  leveldb::Options options;\n-  options.compression = leveldb::kNoCompression;\n-  ... leveldb::DB::Open(options, name, ...) ....\n-</pre>\n-<h2>Cache</h2>\n-<p>\n-The contents of the database are stored in a set of files in the\n-filesystem and each file stores a sequence of compressed blocks.  If\n-<code>options.cache</code> is non-NULL, it is used to cache frequently used\n-uncompressed block contents.\n-<p>\n-<pre>\n-  #include \"leveldb/cache.h\"\n-\n-  leveldb::Options options;\n-  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n-  leveldb::DB* db;\n-  leveldb::DB::Open(options, name, &db);\n-  ... use the db ...\n-  delete db\n-  delete options.cache;\n-</pre>\n-Note that the cache holds uncompressed data, and therefore it should\n-be sized according to application level data sizes, without any\n-reduction from compression.  (Caching of compressed blocks is left to\n-the operating system buffer cache, or any custom <code>Env</code>\n-implementation provided by the client.)\n-<p>\n-When performing a bulk read, the application may wish to disable\n-caching so that the data processed by the bulk read does not end up\n-displacing most of the cached contents.  A per-iterator option can be\n-used to achieve this:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.fill_cache = false;\n-  leveldb::Iterator* it = db-&gt;NewIterator(options);\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-<h2>Key Layout</h2>\n-<p>\n-Note that the unit of disk transfer and caching is a block.  Adjacent\n-keys (according to the database sort order) will usually be placed in\n-the same block.  Therefore the application can improve its performance\n-by placing keys that are accessed together near each other and placing\n-infrequently used keys in a separate region of the key space.\n-<p>\n-For example, suppose we are implementing a simple file system on top\n-of <code>leveldb</code>.  The types of entries we might wish to store are:\n-<p>\n-<pre>\n-   filename -&gt; permission-bits, length, list of file_block_ids\n-   file_block_id -&gt; data\n-</pre>\n-We might want to prefix <code>filename</code> keys with one letter (say '/') and the\n-<code>file_block_id</code> keys with a different letter (say '0') so that scans\n-over just the metadata do not force us to fetch and cache bulky file\n-contents.\n-<p>\n-<h2>Filters</h2>\n-<p>\n-Because of the way <code>leveldb</code> data is organized on disk,\n-a single <code>Get()</code> call may involve multiple reads from disk.\n-The optional <code>FilterPolicy</code> mechanism can be used to reduce\n-the number of disk reads substantially.\n-<pre>\n-   leveldb::Options options;\n-   options.filter_policy = NewBloomFilterPolicy(10);\n-   leveldb::DB* db;\n-   leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-   ... use the database ...\n-   delete db;\n-   delete options.filter_policy;\n-</pre>\n-The preceding code associates a\n-<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a>\n-based filtering policy with the database.  Bloom filter based\n-filtering relies on keeping some number of bits of data in memory per\n-key (in this case 10 bits per key since that is the argument we passed\n-to NewBloomFilterPolicy).  This filter will reduce the number of unnecessary\n-disk reads needed for <code>Get()</code> calls by a factor of\n-approximately a 100.  Increasing the bits per key will lead to a\n-larger reduction at the cost of more memory usage.  We recommend that\n-applications whose working set does not fit in memory and that do a\n-lot of random reads set a filter policy.\n-<p>\n-If you are using a custom comparator, you should ensure that the filter\n-policy you are using is compatible with your comparator.  For example,\n-consider a comparator that ignores trailing spaces when comparing keys.\n-<code>NewBloomFilterPolicy</code> must not be used with such a comparator.\n-Instead, the application should provide a custom filter policy that\n-also ignores trailing spaces.  For example:\n-<pre>\n-  class CustomFilterPolicy : public leveldb::FilterPolicy {\n-   private:\n-    FilterPolicy* builtin_policy_;\n-   public:\n-    CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) { }\n-    ~CustomFilterPolicy() { delete builtin_policy_; }\n-\n-    const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n-\n-    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      std::vector&lt;Slice&gt; trimmed(n);\n-      for (int i = 0; i &lt; n; i++) {\n-        trimmed[i] = RemoveTrailingSpaces(keys[i]);\n-      }\n-      return builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);\n-    }\n-\n-    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      return builtin_policy_-&gt;KeyMayMatch(RemoveTrailingSpaces(key), filter);\n-    }\n-  };\n-</pre>\n-<p>\n-Advanced applications may provide a filter policy that does not use\n-a bloom filter but uses some other mechanism for summarizing a set\n-of keys.  See <code>leveldb/filter_policy.h</code> for detail.\n-<p>\n-<h1>Checksums</h1>\n-<p>\n-<code>leveldb</code> associates checksums with all data it stores in the file system.\n-There are two separate controls provided over how aggressively these\n-checksums are verified:\n-<p>\n-<ul>\n-<li> <code>ReadOptions::verify_checksums</code> may be set to true to force\n-  checksum verification of all data that is read from the file system on\n-  behalf of a particular read.  By default, no such verification is\n-  done.\n-<p>\n-<li> <code>Options::paranoid_checks</code> may be set to true before opening a\n-  database to make the database implementation raise an error as soon as\n-  it detects an internal corruption.  Depending on which portion of the\n-  database has been corrupted, the error may be raised when the database\n-  is opened, or later by another database operation.  By default,\n-  paranoid checking is off so that the database can be used even if\n-  parts of its persistent storage have been corrupted.\n-<p>\n-  If a database is corrupted (perhaps it cannot be opened when\n-  paranoid checking is turned on), the <code>leveldb::RepairDB</code> function\n-  may be used to recover as much of the data as possible\n-<p>\n-</ul>\n-<h1>Approximate Sizes</h1>\n-<p>\n-The <code>GetApproximateSizes</code> method can used to get the approximate\n-number of bytes of file system space used by one or more key ranges.\n-<p>\n-<pre>\n-   leveldb::Range ranges[2];\n-   ranges[0] = leveldb::Range(\"a\", \"c\");\n-   ranges[1] = leveldb::Range(\"x\", \"z\");\n-   uint64_t sizes[2];\n-   leveldb::Status s = db-&gt;GetApproximateSizes(ranges, 2, sizes);\n-</pre>\n-The preceding call will set <code>sizes[0]</code> to the approximate number of\n-bytes of file system space used by the key range <code>[a..c)</code> and\n-<code>sizes[1]</code> to the approximate number of bytes used by the key range\n-<code>[x..z)</code>.\n-<p>\n-<h1>Environment</h1>\n-<p>\n-All file operations (and other operating system calls) issued by the\n-<code>leveldb</code> implementation are routed through a <code>leveldb::Env</code> object.\n-Sophisticated clients may wish to provide their own <code>Env</code>\n-implementation to get better control.  For example, an application may\n-introduce artificial delays in the file IO paths to limit the impact\n-of <code>leveldb</code> on other activities in the system.\n-<p>\n-<pre>\n-  class SlowEnv : public leveldb::Env {\n-    .. implementation of the Env interface ...\n-  };\n-\n-  SlowEnv env;\n-  leveldb::Options options;\n-  options.env = &amp;env;\n-  Status s = leveldb::DB::Open(options, ...);\n-</pre>\n-<h1>Porting</h1>\n-<p>\n-<code>leveldb</code> may be ported to a new platform by providing platform\n-specific implementations of the types/methods/functions exported by\n-<code>leveldb/port/port.h</code>.  See <code>leveldb/port/port_example.h</code> for more\n-details.\n-<p>\n-In addition, the new platform may need a new default <code>leveldb::Env</code>\n-implementation.  See <code>leveldb/util/env_posix.h</code> for an example.\n-\n-<h1>Other Information</h1>\n-\n-<p>\n-Details about the <code>leveldb</code> implementation may be found in\n-the following documents:\n-<ul>\n-<li> <a href=\"impl.html\">Implementation notes</a>\n-<li> <a href=\"table_format.txt\">Format of an immutable Table file</a>\n-<li> <a href=\"log_format.txt\">Format of a log file</a>\n-</ul>\n-\n-</body>\n-</html>"
      },
      {
        "sha": "be8569692bb054676bf451e06a8dd4980c32edca",
        "filename": "doc/index.md",
        "status": "added",
        "additions": 523,
        "deletions": 0,
        "changes": 523,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/index.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/index.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/index.md?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,523 @@\n+leveldb\n+=======\n+\n+_Jeff Dean, Sanjay Ghemawat_\n+\n+The leveldb library provides a persistent key value store. Keys and values are\n+arbitrary byte arrays.  The keys are ordered within the key value store\n+according to a user-specified comparator function.\n+\n+## Opening A Database\n+\n+A leveldb database has a name which corresponds to a file system directory. All\n+of the contents of database are stored in this directory. The following example\n+shows how to open a database, creating it if necessary:\n+\n+```c++\n+#include <cassert>\n+#include \"leveldb/db.h\"\n+\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+assert(status.ok());\n+...\n+```\n+\n+If you want to raise an error if the database already exists, add the following\n+line before the `leveldb::DB::Open` call:\n+\n+```c++\n+options.error_if_exists = true;\n+```\n+\n+## Status\n+\n+You may have noticed the `leveldb::Status` type above. Values of this type are\n+returned by most functions in leveldb that may encounter an error. You can check\n+if such a result is ok, and also print an associated error message:\n+\n+```c++\n+leveldb::Status s = ...;\n+if (!s.ok()) cerr << s.ToString() << endl;\n+```\n+\n+## Closing A Database\n+\n+When you are done with a database, just delete the database object. Example:\n+\n+```c++\n+... open the db as described above ...\n+... do something with db ...\n+delete db;\n+```\n+\n+## Reads And Writes\n+\n+The database provides Put, Delete, and Get methods to modify/query the database.\n+For example, the following code moves the value stored under key1 to key2.\n+\n+```c++\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) s = db->Put(leveldb::WriteOptions(), key2, value);\n+if (s.ok()) s = db->Delete(leveldb::WriteOptions(), key1);\n+```\n+\n+## Atomic Updates\n+\n+Note that if the process dies after the Put of key2 but before the delete of\n+key1, the same value may be left stored under multiple keys. Such problems can\n+be avoided by using the `WriteBatch` class to atomically apply a set of updates:\n+\n+```c++\n+#include \"leveldb/write_batch.h\"\n+...\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) {\n+  leveldb::WriteBatch batch;\n+  batch.Delete(key1);\n+  batch.Put(key2, value);\n+  s = db->Write(leveldb::WriteOptions(), &batch);\n+}\n+```\n+\n+The `WriteBatch` holds a sequence of edits to be made to the database, and these\n+edits within the batch are applied in order. Note that we called Delete before\n+Put so that if key1 is identical to key2, we do not end up erroneously dropping\n+the value entirely.\n+\n+Apart from its atomicity benefits, `WriteBatch` may also be used to speed up\n+bulk updates by placing lots of individual mutations into the same batch.\n+\n+## Synchronous Writes\n+\n+By default, each write to leveldb is asynchronous: it returns after pushing the\n+write from the process into the operating system. The transfer from operating\n+system memory to the underlying persistent storage happens asynchronously. The\n+sync flag can be turned on for a particular write to make the write operation\n+not return until the data being written has been pushed all the way to\n+persistent storage. (On Posix systems, this is implemented by calling either\n+`fsync(...)` or `fdatasync(...)` or `msync(..., MS_SYNC)` before the write\n+operation returns.)\n+\n+```c++\n+leveldb::WriteOptions write_options;\n+write_options.sync = true;\n+db->Put(write_options, ...);\n+```\n+\n+Asynchronous writes are often more than a thousand times as fast as synchronous\n+writes. The downside of asynchronous writes is that a crash of the machine may\n+cause the last few updates to be lost. Note that a crash of just the writing\n+process (i.e., not a reboot) will not cause any loss since even when sync is\n+false, an update is pushed from the process memory into the operating system\n+before it is considered done.\n+\n+Asynchronous writes can often be used safely. For example, when loading a large\n+amount of data into the database you can handle lost updates by restarting the\n+bulk load after a crash. A hybrid scheme is also possible where every Nth write\n+is synchronous, and in the event of a crash, the bulk load is restarted just\n+after the last synchronous write finished by the previous run. (The synchronous\n+write can update a marker that describes where to restart on a crash.)\n+\n+`WriteBatch` provides an alternative to asynchronous writes. Multiple updates\n+may be placed in the same WriteBatch and applied together using a synchronous\n+write (i.e., `write_options.sync` is set to true). The extra cost of the\n+synchronous write will be amortized across all of the writes in the batch.\n+\n+## Concurrency\n+\n+A database may only be opened by one process at a time. The leveldb\n+implementation acquires a lock from the operating system to prevent misuse.\n+Within a single process, the same `leveldb::DB` object may be safely shared by\n+multiple concurrent threads. I.e., different threads may write into or fetch\n+iterators or call Get on the same database without any external synchronization\n+(the leveldb implementation will automatically do the required synchronization).\n+However other objects (like Iterator and `WriteBatch`) may require external\n+synchronization. If two threads share such an object, they must protect access\n+to it using their own locking protocol. More details are available in the public\n+header files.\n+\n+## Iteration\n+\n+The following example demonstrates how to print all key,value pairs in a\n+database.\n+\n+```c++\n+leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions());\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  cout << it->key().ToString() << \": \"  << it->value().ToString() << endl;\n+}\n+assert(it->status().ok());  // Check for any errors found during the scan\n+delete it;\n+```\n+\n+The following variation shows how to process just the keys in the range\n+[start,limit):\n+\n+```c++\n+for (it->Seek(start);\n+   it->Valid() && it->key().ToString() < limit;\n+   it->Next()) {\n+  ...\n+}\n+```\n+\n+You can also process entries in reverse order. (Caveat: reverse iteration may be\n+somewhat slower than forward iteration.)\n+\n+```c++\n+for (it->SeekToLast(); it->Valid(); it->Prev()) {\n+  ...\n+}\n+```\n+\n+## Snapshots\n+\n+Snapshots provide consistent read-only views over the entire state of the\n+key-value store.  `ReadOptions::snapshot` may be non-NULL to indicate that a\n+read should operate on a particular version of the DB state. If\n+`ReadOptions::snapshot` is NULL, the read will operate on an implicit snapshot\n+of the current state.\n+\n+Snapshots are created by the `DB::GetSnapshot()` method:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.snapshot = db->GetSnapshot();\n+... apply some updates to db ...\n+leveldb::Iterator* iter = db->NewIterator(options);\n+... read using iter to view the state when the snapshot was created ...\n+delete iter;\n+db->ReleaseSnapshot(options.snapshot);\n+```\n+\n+Note that when a snapshot is no longer needed, it should be released using the\n+`DB::ReleaseSnapshot` interface. This allows the implementation to get rid of\n+state that was being maintained just to support reading as of that snapshot.\n+\n+## Slice\n+\n+The return value of the `it->key()` and `it->value()` calls above are instances\n+of the `leveldb::Slice` type. Slice is a simple structure that contains a length\n+and a pointer to an external byte array. Returning a Slice is a cheaper\n+alternative to returning a `std::string` since we do not need to copy\n+potentially large keys and values. In addition, leveldb methods do not return\n+null-terminated C-style strings since leveldb keys and values are allowed to\n+contain `'\\0'` bytes.\n+\n+C++ strings and null-terminated C-style strings can be easily converted to a\n+Slice:\n+\n+```c++\n+leveldb::Slice s1 = \"hello\";\n+\n+std::string str(\"world\");\n+leveldb::Slice s2 = str;\n+```\n+\n+A Slice can be easily converted back to a C++ string:\n+\n+```c++\n+std::string str = s1.ToString();\n+assert(str == std::string(\"hello\"));\n+```\n+\n+Be careful when using Slices since it is up to the caller to ensure that the\n+external byte array into which the Slice points remains live while the Slice is\n+in use. For example, the following is buggy:\n+\n+```c++\n+leveldb::Slice slice;\n+if (...) {\n+  std::string str = ...;\n+  slice = str;\n+}\n+Use(slice);\n+```\n+\n+When the if statement goes out of scope, str will be destroyed and the backing\n+storage for slice will disappear.\n+\n+## Comparators\n+\n+The preceding examples used the default ordering function for key, which orders\n+bytes lexicographically. You can however supply a custom comparator when opening\n+a database.  For example, suppose each database key consists of two numbers and\n+we should sort by the first number, breaking ties by the second number. First,\n+define a proper subclass of `leveldb::Comparator` that expresses these rules:\n+\n+```c++\n+class TwoPartComparator : public leveldb::Comparator {\n+ public:\n+  // Three-way comparison function:\n+  //   if a < b: negative result\n+  //   if a > b: positive result\n+  //   else: zero result\n+  int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const {\n+    int a1, a2, b1, b2;\n+    ParseKey(a, &a1, &a2);\n+    ParseKey(b, &b1, &b2);\n+    if (a1 < b1) return -1;\n+    if (a1 > b1) return +1;\n+    if (a2 < b2) return -1;\n+    if (a2 > b2) return +1;\n+    return 0;\n+  }\n+\n+  // Ignore the following methods for now:\n+  const char* Name() const { return \"TwoPartComparator\"; }\n+  void FindShortestSeparator(std::string*, const leveldb::Slice&) const {}\n+  void FindShortSuccessor(std::string*) const {}\n+};\n+```\n+\n+Now create a database using this custom comparator:\n+\n+```c++\n+TwoPartComparator cmp;\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+options.comparator = &cmp;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+...\n+```\n+\n+### Backwards compatibility\n+\n+The result of the comparator's Name method is attached to the database when it\n+is created, and is checked on every subsequent database open. If the name\n+changes, the `leveldb::DB::Open` call will fail. Therefore, change the name if\n+and only if the new key format and comparison function are incompatible with\n+existing databases, and it is ok to discard the contents of all existing\n+databases.\n+\n+You can however still gradually evolve your key format over time with a little\n+bit of pre-planning. For example, you could store a version number at the end of\n+each key (one byte should suffice for most uses). When you wish to switch to a\n+new key format (e.g., adding an optional third part to the keys processed by\n+`TwoPartComparator`), (a) keep the same comparator name (b) increment the\n+version number for new keys (c) change the comparator function so it uses the\n+version numbers found in the keys to decide how to interpret them.\n+\n+## Performance\n+\n+Performance can be tuned by changing the default values of the types defined in\n+`include/leveldb/options.h`.\n+\n+### Block size\n+\n+leveldb groups adjacent keys together into the same block and such a block is\n+the unit of transfer to and from persistent storage. The default block size is\n+approximately 4096 uncompressed bytes.  Applications that mostly do bulk scans\n+over the contents of the database may wish to increase this size. Applications\n+that do a lot of point reads of small values may wish to switch to a smaller\n+block size if performance measurements indicate an improvement. There isn't much\n+benefit in using blocks smaller than one kilobyte, or larger than a few\n+megabytes. Also note that compression will be more effective with larger block\n+sizes.\n+\n+### Compression\n+\n+Each block is individually compressed before being written to persistent\n+storage. Compression is on by default since the default compression method is\n+very fast, and is automatically disabled for uncompressible data. In rare cases,\n+applications may want to disable compression entirely, but should only do so if\n+benchmarks show a performance improvement:\n+\n+```c++\n+leveldb::Options options;\n+options.compression = leveldb::kNoCompression;\n+... leveldb::DB::Open(options, name, ...) ....\n+```\n+\n+### Cache\n+\n+The contents of the database are stored in a set of files in the filesystem and\n+each file stores a sequence of compressed blocks. If options.cache is non-NULL,\n+it is used to cache frequently used uncompressed block contents.\n+\n+```c++\n+#include \"leveldb/cache.h\"\n+\n+leveldb::Options options;\n+options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n+leveldb::DB* db;\n+leveldb::DB::Open(options, name, &db);\n+... use the db ...\n+delete db\n+delete options.cache;\n+```\n+\n+Note that the cache holds uncompressed data, and therefore it should be sized\n+according to application level data sizes, without any reduction from\n+compression. (Caching of compressed blocks is left to the operating system\n+buffer cache, or any custom Env implementation provided by the client.)\n+\n+When performing a bulk read, the application may wish to disable caching so that\n+the data processed by the bulk read does not end up displacing most of the\n+cached contents. A per-iterator option can be used to achieve this:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.fill_cache = false;\n+leveldb::Iterator* it = db->NewIterator(options);\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  ...\n+}\n+```\n+\n+### Key Layout\n+\n+Note that the unit of disk transfer and caching is a block. Adjacent keys\n+(according to the database sort order) will usually be placed in the same block.\n+Therefore the application can improve its performance by placing keys that are\n+accessed together near each other and placing infrequently used keys in a\n+separate region of the key space.\n+\n+For example, suppose we are implementing a simple file system on top of leveldb.\n+The types of entries we might wish to store are:\n+\n+    filename -> permission-bits, length, list of file_block_ids\n+    file_block_id -> data\n+\n+We might want to prefix filename keys with one letter (say '/') and the\n+`file_block_id` keys with a different letter (say '0') so that scans over just\n+the metadata do not force us to fetch and cache bulky file contents.\n+\n+### Filters\n+\n+Because of the way leveldb data is organized on disk, a single `Get()` call may\n+involve multiple reads from disk. The optional FilterPolicy mechanism can be\n+used to reduce the number of disk reads substantially.\n+\n+```c++\n+leveldb::Options options;\n+options.filter_policy = NewBloomFilterPolicy(10);\n+leveldb::DB* db;\n+leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+... use the database ...\n+delete db;\n+delete options.filter_policy;\n+```\n+\n+The preceding code associates a Bloom filter based filtering policy with the\n+database.  Bloom filter based filtering relies on keeping some number of bits of\n+data in memory per key (in this case 10 bits per key since that is the argument\n+we passed to `NewBloomFilterPolicy`). This filter will reduce the number of\n+unnecessary disk reads needed for Get() calls by a factor of approximately\n+a 100. Increasing the bits per key will lead to a larger reduction at the cost\n+of more memory usage. We recommend that applications whose working set does not\n+fit in memory and that do a lot of random reads set a filter policy.\n+\n+If you are using a custom comparator, you should ensure that the filter policy\n+you are using is compatible with your comparator. For example, consider a\n+comparator that ignores trailing spaces when comparing keys.\n+`NewBloomFilterPolicy` must not be used with such a comparator. Instead, the\n+application should provide a custom filter policy that also ignores trailing\n+spaces. For example:\n+\n+```c++\n+class CustomFilterPolicy : public leveldb::FilterPolicy {\n+ private:\n+  FilterPolicy* builtin_policy_;\n+\n+ public:\n+  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) {}\n+  ~CustomFilterPolicy() { delete builtin_policy_; }\n+\n+  const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n+\n+  void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    // Use builtin bloom filter code after removing trailing spaces\n+    std::vector<Slice> trimmed(n);\n+    for (int i = 0; i < n; i++) {\n+      trimmed[i] = RemoveTrailingSpaces(keys[i]);\n+    }\n+    return builtin_policy_->CreateFilter(&trimmed[i], n, dst);\n+  }\n+};\n+```\n+\n+Advanced applications may provide a filter policy that does not use a bloom\n+filter but uses some other mechanism for summarizing a set of keys. See\n+`leveldb/filter_policy.h` for detail.\n+\n+## Checksums\n+\n+leveldb associates checksums with all data it stores in the file system. There\n+are two separate controls provided over how aggressively these checksums are\n+verified:\n+\n+`ReadOptions::verify_checksums` may be set to true to force checksum\n+verification of all data that is read from the file system on behalf of a\n+particular read.  By default, no such verification is done.\n+\n+`Options::paranoid_checks` may be set to true before opening a database to make\n+the database implementation raise an error as soon as it detects an internal\n+corruption. Depending on which portion of the database has been corrupted, the\n+error may be raised when the database is opened, or later by another database\n+operation. By default, paranoid checking is off so that the database can be used\n+even if parts of its persistent storage have been corrupted.\n+\n+If a database is corrupted (perhaps it cannot be opened when paranoid checking\n+is turned on), the `leveldb::RepairDB` function may be used to recover as much\n+of the data as possible\n+\n+## Approximate Sizes\n+\n+The `GetApproximateSizes` method can used to get the approximate number of bytes\n+of file system space used by one or more key ranges.\n+\n+```c++\n+leveldb::Range ranges[2];\n+ranges[0] = leveldb::Range(\"a\", \"c\");\n+ranges[1] = leveldb::Range(\"x\", \"z\");\n+uint64_t sizes[2];\n+leveldb::Status s = db->GetApproximateSizes(ranges, 2, sizes);\n+```\n+\n+The preceding call will set `sizes[0]` to the approximate number of bytes of\n+file system space used by the key range `[a..c)` and `sizes[1]` to the\n+approximate number of bytes used by the key range `[x..z)`.\n+\n+## Environment\n+\n+All file operations (and other operating system calls) issued by the leveldb\n+implementation are routed through a `leveldb::Env` object. Sophisticated clients\n+may wish to provide their own Env implementation to get better control.\n+For example, an application may introduce artificial delays in the file IO\n+paths to limit the impact of leveldb on other activities in the system.\n+\n+```c++\n+class SlowEnv : public leveldb::Env {\n+  ... implementation of the Env interface ...\n+};\n+\n+SlowEnv env;\n+leveldb::Options options;\n+options.env = &env;\n+Status s = leveldb::DB::Open(options, ...);\n+```\n+\n+## Porting\n+\n+leveldb may be ported to a new platform by providing platform specific\n+implementations of the types/methods/functions exported by\n+`leveldb/port/port.h`.  See `leveldb/port/port_example.h` for more details.\n+\n+In addition, the new platform may need a new default `leveldb::Env`\n+implementation.  See `leveldb/util/env_posix.h` for an example.\n+\n+## Other Information\n+\n+Details about the leveldb implementation may be found in the following\n+documents:\n+\n+1. [Implementation notes](impl.md)\n+2. [Format of an immutable Table file](table_format.md)\n+3. [Format of a log file](log_format.md)"
      },
      {
        "sha": "f32cb5d7dac482e71a103f85b1a2667b92e6120e",
        "filename": "doc/log_format.md",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/log_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/log_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/log_format.md?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,75 @@\n+leveldb Log format\n+==================\n+The log file contents are a sequence of 32KB blocks.  The only exception is that\n+the tail of the file may contain a partial block.\n+\n+Each block consists of a sequence of records:\n+\n+    block := record* trailer?\n+    record :=\n+      checksum: uint32     // crc32c of type and data[] ; little-endian\n+      length: uint16       // little-endian\n+      type: uint8          // One of FULL, FIRST, MIDDLE, LAST\n+      data: uint8[length]\n+\n+A record never starts within the last six bytes of a block (since it won't fit).\n+Any leftover bytes here form the trailer, which must consist entirely of zero\n+bytes and must be skipped by readers.\n+\n+Aside: if exactly seven bytes are left in the current block, and a new non-zero\n+length record is added, the writer must emit a FIRST record (which contains zero\n+bytes of user data) to fill up the trailing seven bytes of the block and then\n+emit all of the user data in subsequent blocks.\n+\n+More types may be added in the future.  Some Readers may skip record types they\n+do not understand, others may report that some data was skipped.\n+\n+    FULL == 1\n+    FIRST == 2\n+    MIDDLE == 3\n+    LAST == 4\n+\n+The FULL record contains the contents of an entire user record.\n+\n+FIRST, MIDDLE, LAST are types used for user records that have been split into\n+multiple fragments (typically because of block boundaries).  FIRST is the type\n+of the first fragment of a user record, LAST is the type of the last fragment of\n+a user record, and MIDDLE is the type of all interior fragments of a user\n+record.\n+\n+Example: consider a sequence of user records:\n+\n+    A: length 1000\n+    B: length 97270\n+    C: length 8000\n+\n+**A** will be stored as a FULL record in the first block.\n+\n+**B** will be split into three fragments: first fragment occupies the rest of\n+the first block, second fragment occupies the entirety of the second block, and\n+the third fragment occupies a prefix of the third block.  This will leave six\n+bytes free in the third block, which will be left empty as the trailer.\n+\n+**C** will be stored as a FULL record in the fourth block.\n+\n+----\n+\n+## Some benefits over the recordio format:\n+\n+1. We do not need any heuristics for resyncing - just go to next block boundary\n+   and scan.  If there is a corruption, skip to the next block.  As a\n+   side-benefit, we do not get confused when part of the contents of one log\n+   file are embedded as a record inside another log file.\n+\n+2. Splitting at approximate boundaries (e.g., for mapreduce) is simple: find the\n+   next block boundary and skip records until we hit a FULL or FIRST record.\n+\n+3. We do not need extra buffering for large records.\n+\n+## Some downsides compared to recordio format:\n+\n+1. No packing of tiny records.  This could be fixed by adding a new record type,\n+   so it is a shortcoming of the current implementation, not necessarily the\n+   format.\n+\n+2. No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "4cca5ef6ead327bc4c55d8941528f656fa68166c",
        "filename": "doc/log_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 75,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634ad517037b319147816f1d112b066528e1724a/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634ad517037b319147816f1d112b066528e1724a/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/log_format.txt?ref=634ad517037b319147816f1d112b066528e1724a",
        "patch": "@@ -1,75 +0,0 @@\n-The log file contents are a sequence of 32KB blocks.  The only\n-exception is that the tail of the file may contain a partial block.\n-\n-Each block consists of a sequence of records:\n-   block := record* trailer?\n-   record :=\n-\tchecksum: uint32\t// crc32c of type and data[] ; little-endian\n-\tlength: uint16\t\t// little-endian\n-\ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n-\tdata: uint8[length]\n-\n-A record never starts within the last six bytes of a block (since it\n-won't fit).  Any leftover bytes here form the trailer, which must\n-consist entirely of zero bytes and must be skipped by readers.\n-\n-Aside: if exactly seven bytes are left in the current block, and a new\n-non-zero length record is added, the writer must emit a FIRST record\n-(which contains zero bytes of user data) to fill up the trailing seven\n-bytes of the block and then emit all of the user data in subsequent\n-blocks.\n-\n-More types may be added in the future.  Some Readers may skip record\n-types they do not understand, others may report that some data was\n-skipped.\n-\n-FULL == 1\n-FIRST == 2\n-MIDDLE == 3\n-LAST == 4\n-\n-The FULL record contains the contents of an entire user record.\n-\n-FIRST, MIDDLE, LAST are types used for user records that have been\n-split into multiple fragments (typically because of block boundaries).\n-FIRST is the type of the first fragment of a user record, LAST is the\n-type of the last fragment of a user record, and MIDDLE is the type of\n-all interior fragments of a user record.\n-\n-Example: consider a sequence of user records:\n-   A: length 1000\n-   B: length 97270\n-   C: length 8000\n-A will be stored as a FULL record in the first block.\n-\n-B will be split into three fragments: first fragment occupies the rest\n-of the first block, second fragment occupies the entirety of the\n-second block, and the third fragment occupies a prefix of the third\n-block.  This will leave six bytes free in the third block, which will\n-be left empty as the trailer.\n-\n-C will be stored as a FULL record in the fourth block.\n-\n-===================\n-\n-Some benefits over the recordio format:\n-\n-(1) We do not need any heuristics for resyncing - just go to next\n-block boundary and scan.  If there is a corruption, skip to the next\n-block.  As a side-benefit, we do not get confused when part of the\n-contents of one log file are embedded as a record inside another log\n-file.\n-\n-(2) Splitting at approximate boundaries (e.g., for mapreduce) is\n-simple: find the next block boundary and skip records until we\n-hit a FULL or FIRST record.\n-\n-(3) We do not need extra buffering for large records.\n-\n-Some downsides compared to recordio format:\n-\n-(1) No packing of tiny records.  This could be fixed by adding a new\n-record type, so it is a shortcoming of the current implementation,\n-not necessarily the format.\n-\n-(2) No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "5fe7e72411b828ddc3453754d451fe357626382e",
        "filename": "doc/table_format.md",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/table_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/doc/table_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/table_format.md?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,107 @@\n+leveldb File format\n+===================\n+\n+    <beginning_of_file>\n+    [data block 1]\n+    [data block 2]\n+    ...\n+    [data block N]\n+    [meta block 1]\n+    ...\n+    [meta block K]\n+    [metaindex block]\n+    [index block]\n+    [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n+    <end_of_file>\n+\n+The file contains internal pointers.  Each such pointer is called\n+a BlockHandle and contains the following information:\n+\n+    offset:   varint64\n+    size:     varint64\n+\n+See [varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)\n+for an explanation of varint64 format.\n+\n+1.  The sequence of key/value pairs in the file are stored in sorted\n+order and partitioned into a sequence of data blocks.  These blocks\n+come one after another at the beginning of the file.  Each data block\n+is formatted according to the code in `block_builder.cc`, and then\n+optionally compressed.\n+\n+2. After the data blocks we store a bunch of meta blocks.  The\n+supported meta block types are described below.  More meta block types\n+may be added in the future.  Each meta block is again formatted using\n+`block_builder.cc` and then optionally compressed.\n+\n+3. A \"metaindex\" block.  It contains one entry for every other meta\n+block where the key is the name of the meta block and the value is a\n+BlockHandle pointing to that meta block.\n+\n+4. An \"index\" block.  This block contains one entry per data block,\n+where the key is a string >= last key in that data block and before\n+the first key in the successive data block.  The value is the\n+BlockHandle for the data block.\n+\n+5. At the very end of the file is a fixed length footer that contains\n+the BlockHandle of the metaindex and index blocks as well as a magic number.\n+\n+        metaindex_handle: char[p];     // Block handle for metaindex\n+        index_handle:     char[q];     // Block handle for index\n+        padding:          char[40-p-q];// zeroed bytes to make fixed length\n+                                       // (40==2*BlockHandle::kMaxEncodedLength)\n+        magic:            fixed64;     // == 0xdb4775248b80fb57 (little-endian)\n+\n+## \"filter\" Meta Block\n+\n+If a `FilterPolicy` was specified when the database was opened, a\n+filter block is stored in each table.  The \"metaindex\" block contains\n+an entry that maps from `filter.<N>` to the BlockHandle for the filter\n+block where `<N>` is the string returned by the filter policy's\n+`Name()` method.\n+\n+The filter block stores a sequence of filters, where filter i contains\n+the output of `FilterPolicy::CreateFilter()` on all keys that are stored\n+in a block whose file offset falls within the range\n+\n+    [ i*base ... (i+1)*base-1 ]\n+\n+Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n+the range `[ 0KB .. 2KB-1 ]`, all of the keys in X and Y will be\n+converted to a filter by calling `FilterPolicy::CreateFilter()`, and the\n+resulting filter will be stored as the first filter in the filter\n+block.\n+\n+The filter block is formatted as follows:\n+\n+    [filter 0]\n+    [filter 1]\n+    [filter 2]\n+    ...\n+    [filter N-1]\n+\n+    [offset of filter 0]                  : 4 bytes\n+    [offset of filter 1]                  : 4 bytes\n+    [offset of filter 2]                  : 4 bytes\n+    ...\n+    [offset of filter N-1]                : 4 bytes\n+\n+    [offset of beginning of offset array] : 4 bytes\n+    lg(base)                              : 1 byte\n+\n+The offset array at the end of the filter block allows efficient\n+mapping from a data block offset to the corresponding filter.\n+\n+## \"stats\" Meta Block\n+\n+This meta block contains a bunch of stats.  The key is the name\n+of the statistic.  The value contains the statistic.\n+\n+TODO(postrelease): record following stats.\n+\n+    data size\n+    index size\n+    key size (uncompressed)\n+    value size (uncompressed)\n+    number of entries\n+    number of data blocks"
      },
      {
        "sha": "ca8f9b4460ad85d9e09f14a959ed47bd2812edb5",
        "filename": "doc/table_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 104,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634ad517037b319147816f1d112b066528e1724a/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634ad517037b319147816f1d112b066528e1724a/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/table_format.txt?ref=634ad517037b319147816f1d112b066528e1724a",
        "patch": "@@ -1,104 +0,0 @@\n-File format\n-===========\n-\n-  <beginning_of_file>\n-  [data block 1]\n-  [data block 2]\n-  ...\n-  [data block N]\n-  [meta block 1]\n-  ...\n-  [meta block K]\n-  [metaindex block]\n-  [index block]\n-  [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n-  <end_of_file>\n-\n-The file contains internal pointers.  Each such pointer is called\n-a BlockHandle and contains the following information:\n-  offset:\t    varint64\n-  size:\t\t    varint64\n-See https://developers.google.com/protocol-buffers/docs/encoding#varints\n-for an explanation of varint64 format.\n-\n-(1) The sequence of key/value pairs in the file are stored in sorted\n-order and partitioned into a sequence of data blocks.  These blocks\n-come one after another at the beginning of the file.  Each data block\n-is formatted according to the code in block_builder.cc, and then\n-optionally compressed.\n-\n-(2) After the data blocks we store a bunch of meta blocks.  The\n-supported meta block types are described below.  More meta block types\n-may be added in the future.  Each meta block is again formatted using\n-block_builder.cc and then optionally compressed.\n-\n-(3) A \"metaindex\" block.  It contains one entry for every other meta\n-block where the key is the name of the meta block and the value is a\n-BlockHandle pointing to that meta block.\n-\n-(4) An \"index\" block.  This block contains one entry per data block,\n-where the key is a string >= last key in that data block and before\n-the first key in the successive data block.  The value is the\n-BlockHandle for the data block.\n-\n-(6) At the very end of the file is a fixed length footer that contains\n-the BlockHandle of the metaindex and index blocks as well as a magic number.\n-       metaindex_handle: char[p];    // Block handle for metaindex\n-       index_handle:     char[q];    // Block handle for index\n-       padding:          char[40-p-q]; // zeroed bytes to make fixed length\n-                                       // (40==2*BlockHandle::kMaxEncodedLength)\n-       magic:            fixed64;    // == 0xdb4775248b80fb57 (little-endian)\n-\n-\"filter\" Meta Block\n--------------------\n-\n-If a \"FilterPolicy\" was specified when the database was opened, a\n-filter block is stored in each table.  The \"metaindex\" block contains\n-an entry that maps from \"filter.<N>\" to the BlockHandle for the filter\n-block where \"<N>\" is the string returned by the filter policy's\n-\"Name()\" method.\n-\n-The filter block stores a sequence of filters, where filter i contains\n-the output of FilterPolicy::CreateFilter() on all keys that are stored\n-in a block whose file offset falls within the range\n-\n-    [ i*base ... (i+1)*base-1 ]\n-\n-Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n-the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be\n-converted to a filter by calling FilterPolicy::CreateFilter(), and the\n-resulting filter will be stored as the first filter in the filter\n-block.\n-\n-The filter block is formatted as follows:\n-\n-     [filter 0]\n-     [filter 1]\n-     [filter 2]\n-     ...\n-     [filter N-1]\n-\n-     [offset of filter 0]                  : 4 bytes\n-     [offset of filter 1]                  : 4 bytes\n-     [offset of filter 2]                  : 4 bytes\n-     ...\n-     [offset of filter N-1]                : 4 bytes\n-\n-     [offset of beginning of offset array] : 4 bytes\n-     lg(base)                              : 1 byte\n-\n-The offset array at the end of the filter block allows efficient\n-mapping from a data block offset to the corresponding filter.\n-\n-\"stats\" Meta Block\n-------------------\n-\n-This meta block contains a bunch of stats.  The key is the name\n-of the statistic.  The value contains the statistic.\n-TODO(postrelease): record following stats.\n-  data size\n-  index size\n-  key size (uncompressed)\n-  value size (uncompressed)\n-  number of entries\n-  number of data blocks"
      },
      {
        "sha": "bfab10a0b725be9ed218783ee8fc98110fa77988",
        "filename": "include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/leveldb/db.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 19;\n+static const int kMinorVersion = 20;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "976e38122aafa88acba169b3fc3506c013a75b61",
        "filename": "include/leveldb/options.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/include/leveldb/options.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/include/leveldb/options.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/leveldb/options.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -112,6 +112,18 @@ struct Options {\n   // Default: 16\n   int block_restart_interval;\n \n+  // Leveldb will write up to this amount of bytes to a file before\n+  // switching to a new one.\n+  // Most clients should leave this parameter alone.  However if your\n+  // filesystem is more efficient with larger files, you could\n+  // consider increasing the value.  The downside will be longer\n+  // compactions and hence longer latency/performance hiccups.\n+  // Another reason to increase this parameter might be when you are\n+  // initially populating a large database.\n+  //\n+  // Default: 2MB\n+  size_t max_file_size;\n+\n   // Compress blocks using the specified compression algorithm.  This\n   // parameter can be changed dynamically.\n   //"
      },
      {
        "sha": "97bd669a5ed6cd319c6b12bdd43bd43f8bab1548",
        "filename": "port/port_example.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_example.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_example.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/port/port_example.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -129,6 +129,12 @@ extern bool Snappy_Uncompress(const char* input_data, size_t input_length,\n // The concatenation of all \"data[0,n-1]\" fragments is the heap profile.\n extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);\n \n+// Extend the CRC to include the first n bytes of buf.\n+//\n+// Returns zero if the CRC cannot be extended using acceleration, else returns\n+// the newly extended CRC value (which may also be zero).\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }  // namespace port\n }  // namespace leveldb\n "
      },
      {
        "sha": "7e8213b22ecaf216067040a818d4cdb786d8ca98",
        "filename": "port/port_posix.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/port/port_posix.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -152,6 +152,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n } // namespace port\n } // namespace leveldb\n "
      },
      {
        "sha": "1e519ba0b64befe92b0a6ca70f290f699151baab",
        "filename": "port/port_posix_sse.cc",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_posix_sse.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_posix_sse.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/port/port_posix_sse.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2016 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A portable implementation of crc32c, optimized to handle\n+// four bytes at a time.\n+//\n+// In a separate source file to allow this accelerated CRC32C function to be\n+// compiled with the appropriate compiler flags to enable x86 SSE 4.2\n+// instructions.\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"port/port.h\"\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+#if defined(_MSC_VER)\n+#include <intrin.h>\n+#elif defined(__GNUC__) && defined(__SSE4_2__)\n+#include <nmmintrin.h>\n+#include <cpuid.h>\n+#endif\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+namespace leveldb {\n+namespace port {\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// Used to fetch a naturally-aligned 32-bit word in little endian byte-order\n+static inline uint32_t LE_LOAD32(const uint8_t *p) {\n+  // SSE is x86 only, so ensured that |p| is always little-endian.\n+  uint32_t word;\n+  memcpy(&word, p, sizeof(word));\n+  return word;\n+}\n+\n+#if defined(_M_X64) || defined(__x86_64__)  // LE_LOAD64 is only used on x64.\n+\n+// Used to fetch a naturally-aligned 64-bit word in little endian byte-order\n+static inline uint64_t LE_LOAD64(const uint8_t *p) {\n+  uint64_t dword;\n+  memcpy(&dword, p, sizeof(dword));\n+  return dword;\n+}\n+\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+\n+static inline bool HaveSSE42() {\n+#if defined(_MSC_VER)\n+  int cpu_info[4];\n+  __cpuid(cpu_info, 1);\n+  return (cpu_info[2] & (1 << 20)) != 0;\n+#elif defined(__GNUC__)\n+  unsigned int eax, ebx, ecx, edx;\n+  __get_cpuid(1, &eax, &ebx, &ecx, &edx);\n+  return (ecx & (1 << 20)) != 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// For further improvements see Intel publication at:\n+// http://download.intel.com/design/intarch/papers/323405.pdf\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {\n+#if !defined(LEVELDB_PLATFORM_POSIX_SSE)\n+  return 0;\n+#else\n+  static bool have = HaveSSE42();\n+  if (!have) {\n+    return 0;\n+  }\n+\n+  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n+  const uint8_t *e = p + size;\n+  uint32_t l = crc ^ 0xffffffffu;\n+\n+#define STEP1 do {                              \\\n+    l = _mm_crc32_u8(l, *p++);                  \\\n+} while (0)\n+#define STEP4 do {                              \\\n+    l = _mm_crc32_u32(l, LE_LOAD32(p));         \\\n+    p += 4;                                     \\\n+} while (0)\n+#define STEP8 do {                              \\\n+    l = _mm_crc32_u64(l, LE_LOAD64(p));         \\\n+    p += 8;                                     \\\n+} while (0)\n+\n+  if (size > 16) {\n+    // Process unaligned bytes\n+    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {\n+      STEP1;\n+    }\n+\n+    // _mm_crc32_u64 is only available on x64.\n+#if defined(_M_X64) || defined(__x86_64__)\n+    // Process 8 bytes at a time\n+    while ((e-p) >= 8) {\n+      STEP8;\n+    }\n+    // Process 4 bytes at a time\n+    if ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#else  // !(defined(_M_X64) || defined(__x86_64__))\n+    // Process 4 bytes at a time\n+    while ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+  }\n+  // Process the last few bytes\n+  while (p != e) {\n+    STEP1;\n+  }\n+#undef STEP8\n+#undef STEP4\n+#undef STEP1\n+  return l ^ 0xffffffffu;\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+}\n+\n+}  // namespace port\n+}  // namespace leveldb"
      },
      {
        "sha": "50090048228389c0595e44a2e0e2c274b3799245",
        "filename": "port/port_win.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/port/port_win.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -168,6 +168,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }\n }\n "
      },
      {
        "sha": "1ed5134170e54c430d8a0318e95ece23235ae1ba",
        "filename": "table/filter_block.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/table/filter_block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/table/filter_block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/table/filter_block.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -9,7 +9,7 @@\n \n namespace leveldb {\n \n-// See doc/table_format.txt for an explanation of the filter block format.\n+// See doc/table_format.md for an explanation of the filter block format.\n \n // Generate new filter every 2KB of data\n static const size_t kFilterBaseLg = 11;"
      },
      {
        "sha": "edd61cfd6fca832ff6e53f50700899fe1196c2ad",
        "filename": "util/crc32c.cc",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/crc32c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/crc32c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/crc32c.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -8,6 +8,8 @@\n #include \"util/crc32c.h\"\n \n #include <stdint.h>\n+\n+#include \"port/port.h\"\n #include \"util/coding.h\"\n \n namespace leveldb {\n@@ -283,7 +285,23 @@ static inline uint32_t LE_LOAD32(const uint8_t *p) {\n   return DecodeFixed32(reinterpret_cast<const char*>(p));\n }\n \n+// Determine if the CPU running this program can accelerate the CRC32C\n+// calculation.\n+static bool CanAccelerateCRC32C() {\n+  // port::AcceleretedCRC32C returns zero when unable to accelerate.\n+  static const char kTestCRCBuffer[] = \"TestCRCBuffer\";\n+  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;\n+  static const uint32_t kTestCRCValue = 0xdcbc59fa;\n+\n+  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;\n+}\n+\n uint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n+  static bool accelerate = CanAccelerateCRC32C();\n+  if (accelerate) {\n+    return port::AcceleratedCRC32C(crc, buf, size);\n+  }\n+\n   const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n   const uint8_t *e = p + size;\n   uint32_t l = crc ^ 0xffffffffu;"
      },
      {
        "sha": "dd852af354c83d7d4839fa1e2a3b55824b4ae43c",
        "filename": "util/env_posix.cc",
        "status": "modified",
        "additions": 136,
        "deletions": 59,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_posix.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -11,28 +11,85 @@\n #include <stdlib.h>\n #include <string.h>\n #include <sys/mman.h>\n+#include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <time.h>\n #include <unistd.h>\n #include <deque>\n+#include <limits>\n #include <set>\n #include \"leveldb/env.h\"\n #include \"leveldb/slice.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n #include \"util/posix_logger.h\"\n+#include \"util/env_posix_test_helper.h\"\n \n namespace leveldb {\n \n namespace {\n \n+static int open_read_only_file_limit = -1;\n+static int mmap_limit = -1;\n+\n static Status IOError(const std::string& context, int err_number) {\n   return Status::IOError(context, strerror(err_number));\n }\n \n+// Helper class to limit resource usage to avoid exhaustion.\n+// Currently used to limit read-only file descriptors and mmap file usage\n+// so that we do not end up running out of file descriptors, virtual memory,\n+// or running into kernel performance problems for very large databases.\n+class Limiter {\n+ public:\n+  // Limit maximum number of resources to |n|.\n+  Limiter(intptr_t n) {\n+    SetAllowed(n);\n+  }\n+\n+  // If another resource is available, acquire it and return true.\n+  // Else return false.\n+  bool Acquire() {\n+    if (GetAllowed() <= 0) {\n+      return false;\n+    }\n+    MutexLock l(&mu_);\n+    intptr_t x = GetAllowed();\n+    if (x <= 0) {\n+      return false;\n+    } else {\n+      SetAllowed(x - 1);\n+      return true;\n+    }\n+  }\n+\n+  // Release a resource acquired by a previous call to Acquire() that returned\n+  // true.\n+  void Release() {\n+    MutexLock l(&mu_);\n+    SetAllowed(GetAllowed() + 1);\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  port::AtomicPointer allowed_;\n+\n+  intptr_t GetAllowed() const {\n+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n+  }\n+\n+  // REQUIRES: mu_ must be held\n+  void SetAllowed(intptr_t v) {\n+    allowed_.Release_Store(reinterpret_cast<void*>(v));\n+  }\n+\n+  Limiter(const Limiter&);\n+  void operator=(const Limiter&);\n+};\n+\n class PosixSequentialFile: public SequentialFile {\n  private:\n   std::string filename_;\n@@ -70,73 +127,51 @@ class PosixSequentialFile: public SequentialFile {\n class PosixRandomAccessFile: public RandomAccessFile {\n  private:\n   std::string filename_;\n+  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.\n   int fd_;\n+  Limiter* limiter_;\n \n  public:\n-  PosixRandomAccessFile(const std::string& fname, int fd)\n-      : filename_(fname), fd_(fd) { }\n-  virtual ~PosixRandomAccessFile() { close(fd_); }\n+  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)\n+      : filename_(fname), fd_(fd), limiter_(limiter) {\n+    temporary_fd_ = !limiter->Acquire();\n+    if (temporary_fd_) {\n+      // Open file on every access.\n+      close(fd_);\n+      fd_ = -1;\n+    }\n+  }\n+\n+  virtual ~PosixRandomAccessFile() {\n+    if (!temporary_fd_) {\n+      close(fd_);\n+      limiter_->Release();\n+    }\n+  }\n \n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n+    int fd = fd_;\n+    if (temporary_fd_) {\n+      fd = open(filename_.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        return IOError(filename_, errno);\n+      }\n+    }\n+\n     Status s;\n-    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n+    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));\n     *result = Slice(scratch, (r < 0) ? 0 : r);\n     if (r < 0) {\n       // An error: return a non-ok status\n       s = IOError(filename_, errno);\n     }\n-    return s;\n-  }\n-};\n-\n-// Helper class to limit mmap file usage so that we do not end up\n-// running out virtual memory or running into kernel performance\n-// problems for very large databases.\n-class MmapLimiter {\n- public:\n-  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n-  MmapLimiter() {\n-    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);\n-  }\n-\n-  // If another mmap slot is available, acquire it and return true.\n-  // Else return false.\n-  bool Acquire() {\n-    if (GetAllowed() <= 0) {\n-      return false;\n-    }\n-    MutexLock l(&mu_);\n-    intptr_t x = GetAllowed();\n-    if (x <= 0) {\n-      return false;\n-    } else {\n-      SetAllowed(x - 1);\n-      return true;\n+    if (temporary_fd_) {\n+      // Close the temporary file descriptor opened earlier.\n+      close(fd);\n     }\n+    return s;\n   }\n-\n-  // Release a slot acquired by a previous call to Acquire() that returned true.\n-  void Release() {\n-    MutexLock l(&mu_);\n-    SetAllowed(GetAllowed() + 1);\n-  }\n-\n- private:\n-  port::Mutex mu_;\n-  port::AtomicPointer allowed_;\n-\n-  intptr_t GetAllowed() const {\n-    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n-  }\n-\n-  // REQUIRES: mu_ must be held\n-  void SetAllowed(intptr_t v) {\n-    allowed_.Release_Store(reinterpret_cast<void*>(v));\n-  }\n-\n-  MmapLimiter(const MmapLimiter&);\n-  void operator=(const MmapLimiter&);\n };\n \n // mmap() based random-access\n@@ -145,12 +180,12 @@ class PosixMmapReadableFile: public RandomAccessFile {\n   std::string filename_;\n   void* mmapped_region_;\n   size_t length_;\n-  MmapLimiter* limiter_;\n+  Limiter* limiter_;\n \n  public:\n   // base[0,length-1] contains the mmapped contents of the file.\n   PosixMmapReadableFile(const std::string& fname, void* base, size_t length,\n-                        MmapLimiter* limiter)\n+                        Limiter* limiter)\n       : filename_(fname), mmapped_region_(base), length_(length),\n         limiter_(limiter) {\n   }\n@@ -231,7 +266,7 @@ class PosixWritableFile : public WritableFile {\n       if (fd < 0) {\n         s = IOError(dir, errno);\n       } else {\n-        if (fsync(fd) < 0) {\n+        if (fsync(fd) < 0 && errno != EINVAL) {\n           s = IOError(dir, errno);\n         }\n         close(fd);\n@@ -333,7 +368,7 @@ class PosixEnv : public Env {\n         mmap_limit_.Release();\n       }\n     } else {\n-      *result = new PosixRandomAccessFile(fname, fd);\n+      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);\n     }\n     return s;\n   }\n@@ -533,10 +568,42 @@ class PosixEnv : public Env {\n   BGQueue queue_;\n \n   PosixLockTable locks_;\n-  MmapLimiter mmap_limit_;\n+  Limiter mmap_limit_;\n+  Limiter fd_limit_;\n };\n \n-PosixEnv::PosixEnv() : started_bgthread_(false) {\n+// Return the maximum number of concurrent mmaps.\n+static int MaxMmaps() {\n+  if (mmap_limit >= 0) {\n+    return mmap_limit;\n+  }\n+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n+  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;\n+  return mmap_limit;\n+}\n+\n+// Return the maximum number of read-only files to keep open.\n+static intptr_t MaxOpenFiles() {\n+  if (open_read_only_file_limit >= 0) {\n+    return open_read_only_file_limit;\n+  }\n+  struct rlimit rlim;\n+  if (getrlimit(RLIMIT_NOFILE, &rlim)) {\n+    // getrlimit failed, fallback to hard-coded default.\n+    open_read_only_file_limit = 50;\n+  } else if (rlim.rlim_cur == RLIM_INFINITY) {\n+    open_read_only_file_limit = std::numeric_limits<int>::max();\n+  } else {\n+    // Allow use of 20% of available file descriptors for read-only files.\n+    open_read_only_file_limit = rlim.rlim_cur / 5;\n+  }\n+  return open_read_only_file_limit;\n+}\n+\n+PosixEnv::PosixEnv()\n+    : started_bgthread_(false),\n+      mmap_limit_(MaxMmaps()),\n+      fd_limit_(MaxOpenFiles()) {\n   PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, NULL));\n   PthreadCall(\"cvar_init\", pthread_cond_init(&bgsignal_, NULL));\n }\n@@ -611,6 +678,16 @@ static pthread_once_t once = PTHREAD_ONCE_INIT;\n static Env* default_env;\n static void InitDefaultEnv() { default_env = new PosixEnv; }\n \n+void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {\n+  assert(default_env == NULL);\n+  open_read_only_file_limit = limit;\n+}\n+\n+void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {\n+  assert(default_env == NULL);\n+  mmap_limit = limit;\n+}\n+\n Env* Env::Default() {\n   pthread_once(&once, InitDefaultEnv);\n   return default_env;"
      },
      {
        "sha": "295f8ae4409f2a156c4e298cce4d6c8311e1e1b1",
        "filename": "util/env_posix_test.cc",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_posix_test.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/env.h\"\n+\n+#include \"port/port.h\"\n+#include \"util/testharness.h\"\n+#include \"util/env_posix_test_helper.h\"\n+\n+namespace leveldb {\n+\n+static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n+\n+class EnvPosixTest {\n+ public:\n+  Env* env_;\n+  EnvPosixTest() : env_(Env::Default()) { }\n+\n+  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {\n+    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);\n+    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);\n+  }\n+};\n+\n+TEST(EnvPosixTest, TestOpenOnRead) {\n+  // Write some test data to a single file that will be opened |n| times.\n+  std::string test_dir;\n+  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n+  std::string test_file = test_dir + \"/open_on_read.txt\";\n+\n+  FILE* f = fopen(test_file.c_str(), \"w\");\n+  ASSERT_TRUE(f != NULL);\n+  const char kFileData[] = \"abcdefghijklmnopqrstuvwxyz\";\n+  fputs(kFileData, f);\n+  fclose(f);\n+\n+  // Open test file some number above the sum of the two limits to force\n+  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.\n+  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;\n+  leveldb::RandomAccessFile* files[kNumFiles] = {0};\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));\n+  }\n+  char scratch;\n+  Slice read_result;\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));\n+    ASSERT_EQ(kFileData[i], read_result[0]);\n+  }\n+  for (int i = 0; i < kNumFiles; i++) {\n+    delete files[i];\n+  }\n+  ASSERT_OK(env_->DeleteFile(test_file));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  // All tests currently run with the same read-only file limits.\n+  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,\n+                                       leveldb::kMMapLimit);\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "038696059826042f57808b58505c7f4339c54337",
        "filename": "util/env_posix_test_helper.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix_test_helper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_posix_test_helper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_posix_test_helper.h?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+#define STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+\n+namespace leveldb {\n+\n+class EnvPosixTest;\n+\n+// A helper for the POSIX Env to facilitate testing.\n+class EnvPosixTestHelper {\n+ private:\n+  friend class EnvPosixTest;\n+\n+  // Set the maximum number of read-only files that will be opened.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyFDLimit(int limit);\n+\n+  // Set the maximum number of read-only files that will be mapped via mmap.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyMMapLimit(int limit);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_"
      },
      {
        "sha": "839ae56a1a49c1b4d60562eca2707d2053ab1236",
        "filename": "util/env_test.cc",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_test.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -10,29 +10,31 @@\n namespace leveldb {\n \n static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n \n-class EnvPosixTest {\n+class EnvTest {\n  private:\n   port::Mutex mu_;\n   std::string events_;\n \n  public:\n   Env* env_;\n-  EnvPosixTest() : env_(Env::Default()) { }\n+  EnvTest() : env_(Env::Default()) { }\n };\n \n static void SetBool(void* ptr) {\n   reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);\n }\n \n-TEST(EnvPosixTest, RunImmediately) {\n+TEST(EnvTest, RunImmediately) {\n   port::AtomicPointer called (NULL);\n   env_->Schedule(&SetBool, &called);\n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   ASSERT_TRUE(called.NoBarrier_Load() != NULL);\n }\n \n-TEST(EnvPosixTest, RunMany) {\n+TEST(EnvTest, RunMany) {\n   port::AtomicPointer last_id (NULL);\n \n   struct CB {\n@@ -59,7 +61,7 @@ TEST(EnvPosixTest, RunMany) {\n   env_->Schedule(&CB::Run, &cb3);\n   env_->Schedule(&CB::Run, &cb4);\n \n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   void* cur = last_id.Acquire_Load();\n   ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));\n }\n@@ -78,7 +80,7 @@ static void ThreadBody(void* arg) {\n   s->mu.Unlock();\n }\n \n-TEST(EnvPosixTest, StartThread) {\n+TEST(EnvTest, StartThread) {\n   State state;\n   state.val = 0;\n   state.num_running = 3;\n@@ -92,7 +94,7 @@ TEST(EnvPosixTest, StartThread) {\n     if (num == 0) {\n       break;\n     }\n-    Env::Default()->SleepForMicroseconds(kDelayMicros);\n+    env_->SleepForMicroseconds(kDelayMicros);\n   }\n   ASSERT_EQ(state.val, 3);\n }"
      },
      {
        "sha": "d32c4e676c3fcd6dd29394298f541832032ef1a7",
        "filename": "util/env_win.cc",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/env_win.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -1,7 +1,7 @@\n // This file contains source that originates from:\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n-// Those files dont' have any explict license headers but the \n+// Those files don't have any explicit license headers but the \n // project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n // as the license.\n #if defined(LEVELDB_PLATFORM_WINDOWS)\n@@ -355,11 +355,13 @@ BOOL Win32SequentialFile::_Init()\n \tToWidePath(_filename, path);\n \t_hFile = CreateFileW(path.c_str(),\n                          GENERIC_READ,\n-                         FILE_SHARE_READ,\n+                         FILE_SHARE_READ | FILE_SHARE_WRITE,\n                          NULL,\n                          OPEN_EXISTING,\n-                         FILE_ATTRIBUTE_NORMAL,\n+                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n                          NULL);\n+    if (_hFile == INVALID_HANDLE_VALUE)\n+        _hFile = NULL;\n     return _hFile ? TRUE : FALSE;\n }\n \n@@ -403,7 +405,7 @@ BOOL Win32RandomAccessFile::_Init( LPCWSTR path )\n {\n     BOOL bRet = FALSE;\n     if(!_hFile)\n-        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,\n+        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,\n         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);\n     if(!_hFile || _hFile == INVALID_HANDLE_VALUE )\n         _hFile = NULL;\n@@ -669,7 +671,7 @@ Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n \tToWidePath(ModifyPath(path), wpath);\n \n     HANDLE file = ::CreateFileW(wpath.c_str(),\n-        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n+        GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n     LARGE_INTEGER li;\n     if(::GetFileSizeEx(file,&li)){\n         *file_size = (uint64_t)li.QuadPart;"
      },
      {
        "sha": "b5e622761357cfa3efb72d01facfd33339d4ce8e",
        "filename": "util/options.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf44e4ca7762742c6c3154447b40869ec9d041db/util/options.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf44e4ca7762742c6c3154447b40869ec9d041db/util/options.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util/options.cc?ref=cf44e4ca7762742c6c3154447b40869ec9d041db",
        "patch": "@@ -21,6 +21,7 @@ Options::Options()\n       block_cache(NULL),\n       block_size(4096),\n       block_restart_interval(16),\n+      max_file_size(2<<20),\n       compression(kSnappyCompression),\n       reuse_logs(false),\n       filter_policy(NULL) {"
      }
    ]
  },
  {
    "sha": "e4030ab4f47065c362901109c74ca8e791c2de0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDAzMGFiNGY0NzA2NWMzNjI5MDExMDljNzRjYThlNzkxYzJkZTBh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:24:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:24:30Z"
      },
      "message": "Update to LevelDB 1.20",
      "tree": {
        "sha": "c1678f5a72d3888ad5e4621073bbe4fa698883b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c1678f5a72d3888ad5e4621073bbe4fa698883b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e4030ab4f47065c362901109c74ca8e791c2de0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4030ab4f47065c362901109c74ca8e791c2de0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e4030ab4f47065c362901109c74ca8e791c2de0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4030ab4f47065c362901109c74ca8e791c2de0a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a"
      },
      {
        "sha": "cf44e4ca7762742c6c3154447b40869ec9d041db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf44e4ca7762742c6c3154447b40869ec9d041db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cf44e4ca7762742c6c3154447b40869ec9d041db"
      }
    ],
    "stats": {
      "total": 2565,
      "additions": 1414,
      "deletions": 1151
    },
    "files": [
      {
        "sha": "f7cc7d736c4f20d6cab6e760d43b76e880b80e95",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -44,6 +44,7 @@ TESTS = \\\n \tutil/cache_test \\\n \tutil/coding_test \\\n \tutil/crc32c_test \\\n+\tutil/env_posix_test \\\n \tutil/env_test \\\n \tutil/hash_test\n \n@@ -121,7 +122,7 @@ SHARED_MEMENVLIB = $(SHARED_OUTDIR)/libmemenv.a\n else\n # Update db.h if you change these.\n SHARED_VERSION_MAJOR = 1\n-SHARED_VERSION_MINOR = 19\n+SHARED_VERSION_MINOR = 20\n SHARED_LIB1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED_LIB2 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR)\n SHARED_LIB3 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR).$(SHARED_VERSION_MINOR)\n@@ -337,6 +338,9 @@ $(STATIC_OUTDIR)/db_test:db/db_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n $(STATIC_OUTDIR)/dbformat_test:db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+$(STATIC_OUTDIR)/env_posix_test:util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n $(STATIC_OUTDIR)/env_test:util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n@@ -412,3 +416,9 @@ $(SHARED_OUTDIR)/%.o: %.cc\n \n $(SHARED_OUTDIR)/%.o: %.c\n \t$(CC) $(CFLAGS) $(PLATFORM_SHARED_CFLAGS) -c $< -o $@\n+\n+$(STATIC_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@\n+\n+$(SHARED_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@"
      },
      {
        "sha": "a010c508585e89ad3aacf50dd3630feb05ac24db",
        "filename": "src/leveldb/README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/README.md?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -16,7 +16,7 @@ Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n   * External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.\n \n # Documentation\n-  [LevelDB library documentation](https://rawgit.com/google/leveldb/master/doc/index.html) is online and bundled with the source code.\n+  [LevelDB library documentation](https://github.com/google/leveldb/blob/master/doc/index.md) is online and bundled with the source code.\n \n \n # Limitations\n@@ -113,29 +113,30 @@ by the one or two disk seeks needed to fetch the data from disk.\n Write performance will be mostly unaffected by whether or not the\n working set fits in memory.\n \n-    readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)\n-    readseq      :       0.476 micros/op;  232.3 MB/s\n-    readreverse  :       0.724 micros/op;  152.9 MB/s\n+    readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)\n+    readseq     :  0.476 micros/op;  232.3 MB/s\n+    readreverse :  0.724 micros/op;  152.9 MB/s\n \n LevelDB compacts its underlying storage data in the background to\n improve read performance.  The results listed above were done\n immediately after a lot of random writes.  The results after\n compactions (which are usually triggered automatically) are better.\n \n-    readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)\n-    readseq      :       0.423 micros/op;  261.8 MB/s\n-    readreverse  :       0.663 micros/op;  166.9 MB/s\n+    readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)\n+    readseq     :  0.423 micros/op;  261.8 MB/s\n+    readreverse :  0.663 micros/op;  166.9 MB/s\n \n Some of the high cost of reads comes from repeated decompression of blocks\n read from disk.  If we supply enough cache to the leveldb so it can hold the\n uncompressed blocks in memory, the read performance improves again:\n \n-    readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n-    readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n+    readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n+    readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n \n ## Repository contents\n \n-See doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.\n+See [doc/index.md](doc/index.md) for more explanation. See\n+[doc/impl.md](doc/impl.md) for a brief overview of the implementation.\n \n The public interface is in include/*.h.  Callers should not include or\n rely on the details of any other header files in this package.  Those\n@@ -148,7 +149,7 @@ Guide to header files:\n * **include/options.h**: Control over the behavior of an entire database,\n and also control over the behavior of individual reads and writes.\n \n-* **include/comparator.h**: Abstraction for user-specified comparison function. \n+* **include/comparator.h**: Abstraction for user-specified comparison function.\n If you want just bytewise comparison of keys, you can use the default\n comparator, but clients can write their own comparator implementations if they\n want custom ordering (e.g. to handle different character encodings, etc.)\n@@ -165,7 +166,7 @@ length into some other byte array.\n * **include/status.h**: Status is returned from many of the public interfaces\n and is used to report success and various kinds of errors.\n \n-* **include/env.h**: \n+* **include/env.h**:\n Abstraction of the OS environment.  A posix implementation of this interface is\n in util/env_posix.cc\n "
      },
      {
        "sha": "4a94715900969161b9f29d41e27f0659c648df10",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -63,6 +63,7 @@ PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n PLATFORM_SHARED_VERSIONED=true\n+PLATFORM_SSEFLAGS=\n \n MEMCMP_FLAG=\n if [ \"$CXX\" = \"g++\" ]; then\n@@ -77,6 +78,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -lpthread -DOS_LINUX -DCYGWIN\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Darwin)\n         PLATFORM=OS_MACOSX\n@@ -85,24 +87,28 @@ case \"$TARGET_OS\" in\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n         PLATFORM_LIBS=\"-lpthread -lrt\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     GNU/kFreeBSD)\n         PLATFORM=OS_KFREEBSD\n@@ -115,31 +121,36 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n         PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         CROSS_COMPILE=true\n         ;;\n     HP-UX)\n         PLATFORM=OS_HPUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         # man ld: +h internal_name\n         PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n@@ -148,6 +159,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         PLATFORM_SHARED_EXT=\n         PLATFORM_SHARED_LDFLAGS=\n         PLATFORM_SHARED_CFLAGS=\n@@ -182,7 +194,7 @@ set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE $PORT_SSE_FILE\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n@@ -213,6 +225,21 @@ EOF\n     fi\n \n     rm -f $CXXOUTPUT 2>/dev/null\n+\n+    # Test if gcc SSE 4.2 is supported\n+    $CXX $CXXFLAGS -x c++ - -o $CXXOUTPUT -msse4.2 2>/dev/null  <<EOF\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        PLATFORM_SSEFLAGS=\"-msse4.2\"\n+    fi\n+\n+    rm -f $CXXOUTPUT 2>/dev/null\n+fi\n+\n+# Use the SSE 4.2 CRC32C intrinsics iff runtime checks indicate compiler supports them.\n+if [ -n \"$PLATFORM_SSEFLAGS\" ]; then\n+    PLATFORM_SSEFLAGS=\"$PLATFORM_SSEFLAGS -DLEVELDB_PLATFORM_POSIX_SSE\"\n fi\n \n PLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\n@@ -225,6 +252,7 @@ echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n echo \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SSEFLAGS=$PLATFORM_SSEFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "3ad19a512b56c92ba4d4ba26d1a8638d12611d57",
        "filename": "src/leveldb/db/db_bench.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 9,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_bench.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -84,6 +84,14 @@ static bool FLAGS_histogram = false;\n // (initialized to default value by \"main\")\n static int FLAGS_write_buffer_size = 0;\n \n+// Number of bytes written to each file.\n+// (initialized to default value by \"main\")\n+static int FLAGS_max_file_size = 0;\n+\n+// Approximate size of user data packed per block (before compression.\n+// (initialized to default value by \"main\")\n+static int FLAGS_block_size = 0;\n+\n // Number of bytes to use as a cache of uncompressed data.\n // Negative means use default settings.\n static int FLAGS_cache_size = -1;\n@@ -109,6 +117,7 @@ static const char* FLAGS_db = NULL;\n namespace leveldb {\n \n namespace {\n+leveldb::Env* g_env = NULL;\n \n // Helper for quickly generating random data.\n class RandomGenerator {\n@@ -186,7 +195,7 @@ class Stats {\n     done_ = 0;\n     bytes_ = 0;\n     seconds_ = 0;\n-    start_ = Env::Default()->NowMicros();\n+    start_ = g_env->NowMicros();\n     finish_ = start_;\n     message_.clear();\n   }\n@@ -204,7 +213,7 @@ class Stats {\n   }\n \n   void Stop() {\n-    finish_ = Env::Default()->NowMicros();\n+    finish_ = g_env->NowMicros();\n     seconds_ = (finish_ - start_) * 1e-6;\n   }\n \n@@ -214,7 +223,7 @@ class Stats {\n \n   void FinishedSingleOp() {\n     if (FLAGS_histogram) {\n-      double now = Env::Default()->NowMicros();\n+      double now = g_env->NowMicros();\n       double micros = now - last_op_finish_;\n       hist_.Add(micros);\n       if (micros > 20000) {\n@@ -404,10 +413,10 @@ class Benchmark {\n     reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n     heap_counter_(0) {\n     std::vector<std::string> files;\n-    Env::Default()->GetChildren(FLAGS_db, &files);\n+    g_env->GetChildren(FLAGS_db, &files);\n     for (size_t i = 0; i < files.size(); i++) {\n       if (Slice(files[i]).starts_with(\"heap-\")) {\n-        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n+        g_env->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n       }\n     }\n     if (!FLAGS_use_existing_db) {\n@@ -589,7 +598,7 @@ class Benchmark {\n       arg[i].shared = &shared;\n       arg[i].thread = new ThreadState(i);\n       arg[i].thread->shared = &shared;\n-      Env::Default()->StartThread(ThreadBody, &arg[i]);\n+      g_env->StartThread(ThreadBody, &arg[i]);\n     }\n \n     shared.mu.Lock();\n@@ -700,9 +709,12 @@ class Benchmark {\n   void Open() {\n     assert(db_ == NULL);\n     Options options;\n+    options.env = g_env;\n     options.create_if_missing = !FLAGS_use_existing_db;\n     options.block_cache = cache_;\n     options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.max_file_size = FLAGS_max_file_size;\n+    options.block_size = FLAGS_block_size;\n     options.max_open_files = FLAGS_open_files;\n     options.filter_policy = filter_policy_;\n     options.reuse_logs = FLAGS_reuse_logs;\n@@ -925,7 +937,7 @@ class Benchmark {\n     char fname[100];\n     snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n     WritableFile* file;\n-    Status s = Env::Default()->NewWritableFile(fname, &file);\n+    Status s = g_env->NewWritableFile(fname, &file);\n     if (!s.ok()) {\n       fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n       return;\n@@ -934,7 +946,7 @@ class Benchmark {\n     delete file;\n     if (!ok) {\n       fprintf(stderr, \"heap profiling not supported\\n\");\n-      Env::Default()->DeleteFile(fname);\n+      g_env->DeleteFile(fname);\n     }\n   }\n };\n@@ -943,6 +955,8 @@ class Benchmark {\n \n int main(int argc, char** argv) {\n   FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n+  FLAGS_max_file_size = leveldb::Options().max_file_size;\n+  FLAGS_block_size = leveldb::Options().block_size;\n   FLAGS_open_files = leveldb::Options().max_open_files;\n   std::string default_db_path;\n \n@@ -973,6 +987,10 @@ int main(int argc, char** argv) {\n       FLAGS_value_size = n;\n     } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_write_buffer_size = n;\n+    } else if (sscanf(argv[i], \"--max_file_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_max_file_size = n;\n+    } else if (sscanf(argv[i], \"--block_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_block_size = n;\n     } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_cache_size = n;\n     } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n@@ -987,9 +1005,11 @@ int main(int argc, char** argv) {\n     }\n   }\n \n+  leveldb::g_env = leveldb::Env::Default();\n+\n   // Choose a location for the test database if none given with --db=<path>\n   if (FLAGS_db == NULL) {\n-      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      leveldb::g_env->GetTestDirectory(&default_db_path);\n       default_db_path += \"/dbbench\";\n       FLAGS_db = default_db_path.c_str();\n   }"
      },
      {
        "sha": "f43ad7679436b312959e5e0487c9313694d83ecc",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -96,6 +96,7 @@ Options SanitizeOptions(const std::string& dbname,\n   result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n   ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n   ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n+  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);\n   ClipToRange(&result.block_size,        1<<10,                       4<<20);\n   if (result.info_log == NULL) {\n     // Open a log file in the same directory as the db"
      },
      {
        "sha": "356e69fca231def5f74b95eaff53f12f42169317",
        "filename": "src/leveldb/db/log_format.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/log_format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/log_format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_format.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -3,7 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n //\n // Log format information shared by reader and writer.\n-// See ../doc/log_format.txt for more detail.\n+// See ../doc/log_format.md for more detail.\n \n #ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n #define STORAGE_LEVELDB_DB_LOG_FORMAT_H_"
      },
      {
        "sha": "b1256f90e1c2bc6f9f6f449029bed9266bbb55b9",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -20,30 +20,39 @@\n \n namespace leveldb {\n \n-static const int kTargetFileSize = 2 * 1048576;\n+static int TargetFileSize(const Options* options) {\n+  return options->max_file_size;\n+}\n \n // Maximum bytes of overlaps in grandparent (i.e., level+2) before we\n // stop building a single file in a level->level+1 compaction.\n-static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;\n+static int64_t MaxGrandParentOverlapBytes(const Options* options) {\n+  return 10 * TargetFileSize(options);\n+}\n \n // Maximum number of bytes in all compacted files.  We avoid expanding\n // the lower level file set of a compaction if it would make the\n // total compaction cover more than this many bytes.\n-static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;\n+static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {\n+  return 25 * TargetFileSize(options);\n+}\n \n-static double MaxBytesForLevel(int level) {\n+static double MaxBytesForLevel(const Options* options, int level) {\n   // Note: the result for level zero is not really used since we set\n   // the level-0 compaction threshold based on number of files.\n-  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n+\n+  // Result for both level-0 and level-1\n+  double result = 10. * 1048576.0;\n   while (level > 1) {\n     result *= 10;\n     level--;\n   }\n   return result;\n }\n \n-static uint64_t MaxFileSizeForLevel(int level) {\n-  return kTargetFileSize;  // We could vary per level to reduce number of files?\n+static uint64_t MaxFileSizeForLevel(const Options* options, int level) {\n+  // We could vary per level to reduce number of files?\n+  return TargetFileSize(options);\n }\n \n static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n@@ -508,7 +517,7 @@ int Version::PickLevelForMemTableOutput(\n         // Check that file does not overlap too many grandparent bytes.\n         GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n         const int64_t sum = TotalFileSize(overlaps);\n-        if (sum > kMaxGrandParentOverlapBytes) {\n+        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {\n           break;\n         }\n       }\n@@ -1027,7 +1036,7 @@ bool VersionSet::ReuseManifest(const std::string& dscname,\n       manifest_type != kDescriptorFile ||\n       !env_->GetFileSize(dscname, &manifest_size).ok() ||\n       // Make new compacted MANIFEST if old one is too big\n-      manifest_size >= kTargetFileSize) {\n+      manifest_size >= TargetFileSize(options_)) {\n     return false;\n   }\n \n@@ -1076,7 +1085,8 @@ void VersionSet::Finalize(Version* v) {\n     } else {\n       // Compute the ratio of current size to size limit.\n       const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n-      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n+      score =\n+          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);\n     }\n \n     if (score > best_score) {\n@@ -1290,7 +1300,7 @@ Compaction* VersionSet::PickCompaction() {\n     level = current_->compaction_level_;\n     assert(level >= 0);\n     assert(level+1 < config::kNumLevels);\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n \n     // Pick the first file that comes after compact_pointer_[level]\n     for (size_t i = 0; i < current_->files_[level].size(); i++) {\n@@ -1307,7 +1317,7 @@ Compaction* VersionSet::PickCompaction() {\n     }\n   } else if (seek_compaction) {\n     level = current_->file_to_compact_level_;\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n     c->inputs_[0].push_back(current_->file_to_compact_);\n   } else {\n     return NULL;\n@@ -1352,7 +1362,8 @@ void VersionSet::SetupOtherInputs(Compaction* c) {\n     const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n     const int64_t expanded0_size = TotalFileSize(expanded0);\n     if (expanded0.size() > c->inputs_[0].size() &&\n-        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n+        inputs1_size + expanded0_size <\n+            ExpandedCompactionByteSizeLimit(options_)) {\n       InternalKey new_start, new_limit;\n       GetRange(expanded0, &new_start, &new_limit);\n       std::vector<FileMetaData*> expanded1;\n@@ -1414,7 +1425,7 @@ Compaction* VersionSet::CompactRange(\n   // and we must not pick one file and drop another older file if the\n   // two files overlap.\n   if (level > 0) {\n-    const uint64_t limit = MaxFileSizeForLevel(level);\n+    const uint64_t limit = MaxFileSizeForLevel(options_, level);\n     uint64_t total = 0;\n     for (size_t i = 0; i < inputs.size(); i++) {\n       uint64_t s = inputs[i]->file_size;\n@@ -1426,17 +1437,17 @@ Compaction* VersionSet::CompactRange(\n     }\n   }\n \n-  Compaction* c = new Compaction(level);\n+  Compaction* c = new Compaction(options_, level);\n   c->input_version_ = current_;\n   c->input_version_->Ref();\n   c->inputs_[0] = inputs;\n   SetupOtherInputs(c);\n   return c;\n }\n \n-Compaction::Compaction(int level)\n+Compaction::Compaction(const Options* options, int level)\n     : level_(level),\n-      max_output_file_size_(MaxFileSizeForLevel(level)),\n+      max_output_file_size_(MaxFileSizeForLevel(options, level)),\n       input_version_(NULL),\n       grandparent_index_(0),\n       seen_key_(false),\n@@ -1453,12 +1464,13 @@ Compaction::~Compaction() {\n }\n \n bool Compaction::IsTrivialMove() const {\n+  const VersionSet* vset = input_version_->vset_;\n   // Avoid a move if there is lots of overlapping grandparent data.\n   // Otherwise, the move could create a parent file that will require\n   // a very expensive merge later on.\n-  return (num_input_files(0) == 1 &&\n-          num_input_files(1) == 0 &&\n-          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n+  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&\n+          TotalFileSize(grandparents_) <=\n+              MaxGrandParentOverlapBytes(vset->options_));\n }\n \n void Compaction::AddInputDeletions(VersionEdit* edit) {\n@@ -1491,8 +1503,9 @@ bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n }\n \n bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n+  const VersionSet* vset = input_version_->vset_;\n   // Scan to find earliest grandparent file that contains key.\n-  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n+  const InternalKeyComparator* icmp = &vset->icmp_;\n   while (grandparent_index_ < grandparents_.size() &&\n       icmp->Compare(internal_key,\n                     grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n@@ -1503,7 +1516,7 @@ bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n   }\n   seen_key_ = true;\n \n-  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n+  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {\n     // Too much overlap for current output; start new output\n     overlapped_bytes_ = 0;\n     return true;"
      },
      {
        "sha": "c4e7ac360b87d842ee9dbc0a2bf80f122a65dad7",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -366,7 +366,7 @@ class Compaction {\n   friend class Version;\n   friend class VersionSet;\n \n-  explicit Compaction(int level);\n+  Compaction(const Options* options, int level);\n \n   int level_;\n   uint64_t max_output_file_size_;"
      },
      {
        "sha": "700c564e433827c311cd8a26896ceaa7c8260818",
        "filename": "src/leveldb/doc/doc.css",
        "status": "removed",
        "additions": 0,
        "deletions": 89,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/doc.css",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/doc.css",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/doc.css?ref=1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "patch": "@@ -1,89 +0,0 @@\n-body {\n-  margin-left: 0.5in;\n-  margin-right: 0.5in;\n-  background: white;\n-  color: black;\n-}\n-\n-h1 {\n-  margin-left: -0.2in;\n-  font-size: 14pt;\n-}\n-h2 {\n-  margin-left: -0in;\n-  font-size: 12pt;\n-}\n-h3 {\n-  margin-left: -0in;\n-}\n-h4 {\n-  margin-left: -0in;\n-}\n-hr {\n-  margin-left: -0in;\n-}\n-\n-/* Definition lists: definition term bold */\n-dt {\n-  font-weight: bold;\n-}\n-\n-address {\n-  text-align: center;\n-}\n-code,samp,var {\n-  color: blue;\n-}\n-kbd {\n-  color: #600000;\n-}\n-div.note p {\n-  float: right;\n-  width: 3in;\n-  margin-right: 0%;\n-  padding: 1px;\n-  border: 2px solid #6060a0;\n-  background-color: #fffff0;\n-}\n-\n-ul {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-ol {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-UL.nobullets {\n-  list-style-type: none;\n-  list-style-image: none;\n-  margin-left: -1em;\n-}\n-\n-p {\n-  margin: 1em 0 1em 0;\n-  padding: 0 0 0 0;\n-}\n-\n-pre {\n-  line-height: 1.3em;\n-  padding: 0.4em 0 0.8em 0;\n-  margin:  0 0 0 0;\n-  border:  0 0 0 0;\n-  color: blue;\n-}\n-\n-.datatable {\n-  margin-left: auto;\n-  margin-right: auto;\n-  margin-top: 2em;\n-  margin-bottom: 2em;\n-  border: 1px solid;\n-}\n-\n-.datatable td,th {\n-  padding: 0 0.5em 0 0.5em;\n-  text-align: right;\n-}"
      },
      {
        "sha": "6a468be0955d921a3e7bad2d55a71989209d06ae",
        "filename": "src/leveldb/doc/impl.html",
        "status": "removed",
        "additions": 0,
        "deletions": 213,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/impl.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/impl.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.html?ref=1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "patch": "@@ -1,213 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb file layout and compactions</title>\n-</head>\n-\n-<body>\n-\n-<h1>Files</h1>\n-\n-The implementation of leveldb is similar in spirit to the\n-representation of a single\n-<a href=\"http://research.google.com/archive/bigtable.html\">\n-Bigtable tablet (section 5.3)</a>.\n-However the organization of the files that make up the representation\n-is somewhat different and is explained below.\n-\n-<p>\n-Each database is represented by a set of files stored in a directory.\n-There are several different types of files as documented below:\n-<p>\n-<h2>Log files</h2>\n-<p>\n-A log file (*.log) stores a sequence of recent updates.  Each update\n-is appended to the current log file.  When the log file reaches a\n-pre-determined size (approximately 4MB by default), it is converted\n-to a sorted table (see below) and a new log file is created for future\n-updates.\n-<p>\n-A copy of the current log file is kept in an in-memory structure (the\n-<code>memtable</code>).  This copy is consulted on every read so that read\n-operations reflect all logged updates.\n-<p>\n-<h2>Sorted tables</h2>\n-<p>\n-A sorted table (*.sst) stores a sequence of entries sorted by key.\n-Each entry is either a value for the key, or a deletion marker for the\n-key.  (Deletion markers are kept around to hide obsolete values\n-present in older sorted tables).\n-<p>\n-The set of sorted tables are organized into a sequence of levels.  The\n-sorted table generated from a log file is placed in a special <code>young</code>\n-level (also called level-0).  When the number of young files exceeds a\n-certain threshold (currently four), all of the young files are merged\n-together with all of the overlapping level-1 files to produce a\n-sequence of new level-1 files (we create a new level-1 file for every\n-2MB of data.)\n-<p>\n-Files in the young level may contain overlapping keys.  However files\n-in other levels have distinct non-overlapping key ranges.  Consider\n-level number L where L >= 1.  When the combined size of files in\n-level-L exceeds (10^L) MB (i.e., 10MB for level-1, 100MB for level-2,\n-...), one file in level-L, and all of the overlapping files in\n-level-(L+1) are merged to form a set of new files for level-(L+1).\n-These merges have the effect of gradually migrating new updates from\n-the young level to the largest level using only bulk reads and writes\n-(i.e., minimizing expensive seeks).\n-\n-<h2>Manifest</h2>\n-<p>\n-A MANIFEST file lists the set of sorted tables that make up each\n-level, the corresponding key ranges, and other important metadata.\n-A new MANIFEST file (with a new number embedded in the file name)\n-is created whenever the database is reopened.  The MANIFEST file is\n-formatted as a log, and changes made to the serving state (as files\n-are added or removed) are appended to this log.\n-<p>\n-<h2>Current</h2>\n-<p>\n-CURRENT is a simple text file that contains the name of the latest\n-MANIFEST file.\n-<p>\n-<h2>Info logs</h2>\n-<p>\n-Informational messages are printed to files named LOG and LOG.old.\n-<p>\n-<h2>Others</h2>\n-<p>\n-Other files used for miscellaneous purposes may also be present\n-(LOCK, *.dbtmp).\n-\n-<h1>Level 0</h1>\n-When the log file grows above a certain size (1MB by default):\n-<ul>\n-<li>Create a brand new memtable and log file and direct future updates here\n-<li>In the background:\n-<ul>\n-<li>Write the contents of the previous memtable to an sstable\n-<li>Discard the memtable\n-<li>Delete the old log file and the old memtable\n-<li>Add the new sstable to the young (level-0) level.\n-</ul>\n-</ul>\n-\n-<h1>Compactions</h1>\n-\n-<p>\n-When the size of level L exceeds its limit, we compact it in a\n-background thread.  The compaction picks a file from level L and all\n-overlapping files from the next level L+1.  Note that if a level-L\n-file overlaps only part of a level-(L+1) file, the entire file at\n-level-(L+1) is used as an input to the compaction and will be\n-discarded after the compaction.  Aside: because level-0 is special\n-(files in it may overlap each other), we treat compactions from\n-level-0 to level-1 specially: a level-0 compaction may pick more than\n-one level-0 file in case some of these files overlap each other.\n-\n-<p>\n-A compaction merges the contents of the picked files to produce a\n-sequence of level-(L+1) files.  We switch to producing a new\n-level-(L+1) file after the current output file has reached the target\n-file size (2MB).  We also switch to a new output file when the key\n-range of the current output file has grown enough to overlap more than\n-ten level-(L+2) files.  This last rule ensures that a later compaction\n-of a level-(L+1) file will not pick up too much data from level-(L+2).\n-\n-<p>\n-The old files are discarded and the new files are added to the serving\n-state.\n-\n-<p>\n-Compactions for a particular level rotate through the key space.  In\n-more detail, for each level L, we remember the ending key of the last\n-compaction at level L.  The next compaction for level L will pick the\n-first file that starts after this key (wrapping around to the\n-beginning of the key space if there is no such file).\n-\n-<p>\n-Compactions drop overwritten values.  They also drop deletion markers\n-if there are no higher numbered levels that contain a file whose range\n-overlaps the current key.\n-\n-<h2>Timing</h2>\n-\n-Level-0 compactions will read up to four 1MB files from level-0, and\n-at worst all the level-1 files (10MB).  I.e., we will read 14MB and\n-write 14MB.\n-\n-<p>\n-Other than the special level-0 compactions, we will pick one 2MB file\n-from level L.  In the worst case, this will overlap ~ 12 files from\n-level L+1 (10 because level-(L+1) is ten times the size of level-L,\n-and another two at the boundaries since the file ranges at level-L\n-will usually not be aligned with the file ranges at level-L+1).  The\n-compaction will therefore read 26MB and write 26MB.  Assuming a disk\n-IO rate of 100MB/s (ballpark range for modern drives), the worst\n-compaction cost will be approximately 0.5 second.\n-\n-<p>\n-If we throttle the background writing to something small, say 10% of\n-the full 100MB/s speed, a compaction may take up to 5 seconds.  If the\n-user is writing at 10MB/s, we might build up lots of level-0 files\n-(~50 to hold the 5*10MB).  This may significantly increase the cost of\n-reads due to the overhead of merging more files together on every\n-read.\n-\n-<p>\n-Solution 1: To reduce this problem, we might want to increase the log\n-switching threshold when the number of level-0 files is large.  Though\n-the downside is that the larger this threshold, the more memory we will\n-need to hold the corresponding memtable.\n-\n-<p>\n-Solution 2: We might want to decrease write rate artificially when the\n-number of level-0 files goes up.\n-\n-<p>\n-Solution 3: We work on reducing the cost of very wide merges.\n-Perhaps most of the level-0 files will have their blocks sitting\n-uncompressed in the cache and we will only need to worry about the\n-O(N) complexity in the merging iterator.\n-\n-<h2>Number of files</h2>\n-\n-Instead of always making 2MB files, we could make larger files for\n-larger levels to reduce the total file count, though at the expense of\n-more bursty compactions.  Alternatively, we could shard the set of\n-files into multiple directories.\n-\n-<p>\n-An experiment on an <code>ext3</code> filesystem on Feb 04, 2011 shows\n-the following timings to do 100K file opens in directories with\n-varying number of files:\n-<table class=\"datatable\">\n-<tr><th>Files in directory</th><th>Microseconds to open a file</th></tr>\n-<tr><td>1000</td><td>9</td>\n-<tr><td>10000</td><td>10</td>\n-<tr><td>100000</td><td>16</td>\n-</table>\n-So maybe even the sharding is not necessary on modern filesystems?\n-\n-<h1>Recovery</h1>\n-\n-<ul>\n-<li> Read CURRENT to find name of the latest committed MANIFEST\n-<li> Read the named MANIFEST file\n-<li> Clean up stale files\n-<li> We could open all sstables here, but it is probably better to be lazy...\n-<li> Convert log chunk to a new level-0 sstable\n-<li> Start directing new writes to a new log file with recovered sequence#\n-</ul>\n-\n-<h1>Garbage collection of files</h1>\n-\n-<code>DeleteObsoleteFiles()</code> is called at the end of every\n-compaction and at the end of recovery.  It finds the names of all\n-files in the database.  It deletes all log files that are not the\n-current log file.  It deletes all table files that are not referenced\n-from some level and are not the output of an active compaction.\n-\n-</body>\n-</html>"
      },
      {
        "sha": "4b13f2a6ba73bd46667eec0e63e6af6e10bad6d4",
        "filename": "src/leveldb/doc/impl.md",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/impl.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/impl.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.md?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,170 @@\n+## Files\n+\n+The implementation of leveldb is similar in spirit to the representation of a\n+single [Bigtable tablet (section 5.3)](http://research.google.com/archive/bigtable.html).\n+However the organization of the files that make up the representation is\n+somewhat different and is explained below.\n+\n+Each database is represented by a set of files stored in a directory. There are\n+several different types of files as documented below:\n+\n+### Log files\n+\n+A log file (*.log) stores a sequence of recent updates. Each update is appended\n+to the current log file. When the log file reaches a pre-determined size\n+(approximately 4MB by default), it is converted to a sorted table (see below)\n+and a new log file is created for future updates.\n+\n+A copy of the current log file is kept in an in-memory structure (the\n+`memtable`). This copy is consulted on every read so that read operations\n+reflect all logged updates.\n+\n+## Sorted tables\n+\n+A sorted table (*.ldb) stores a sequence of entries sorted by key. Each entry is\n+either a value for the key, or a deletion marker for the key. (Deletion markers\n+are kept around to hide obsolete values present in older sorted tables).\n+\n+The set of sorted tables are organized into a sequence of levels. The sorted\n+table generated from a log file is placed in a special **young** level (also\n+called level-0). When the number of young files exceeds a certain threshold\n+(currently four), all of the young files are merged together with all of the\n+overlapping level-1 files to produce a sequence of new level-1 files (we create\n+a new level-1 file for every 2MB of data.)\n+\n+Files in the young level may contain overlapping keys. However files in other\n+levels have distinct non-overlapping key ranges. Consider level number L where\n+L >= 1. When the combined size of files in level-L exceeds (10^L) MB (i.e., 10MB\n+for level-1, 100MB for level-2, ...), one file in level-L, and all of the\n+overlapping files in level-(L+1) are merged to form a set of new files for\n+level-(L+1). These merges have the effect of gradually migrating new updates\n+from the young level to the largest level using only bulk reads and writes\n+(i.e., minimizing expensive seeks).\n+\n+### Manifest\n+\n+A MANIFEST file lists the set of sorted tables that make up each level, the\n+corresponding key ranges, and other important metadata. A new MANIFEST file\n+(with a new number embedded in the file name) is created whenever the database\n+is reopened. The MANIFEST file is formatted as a log, and changes made to the\n+serving state (as files are added or removed) are appended to this log.\n+\n+### Current\n+\n+CURRENT is a simple text file that contains the name of the latest MANIFEST\n+file.\n+\n+### Info logs\n+\n+Informational messages are printed to files named LOG and LOG.old.\n+\n+### Others\n+\n+Other files used for miscellaneous purposes may also be present (LOCK, *.dbtmp).\n+\n+## Level 0\n+\n+When the log file grows above a certain size (1MB by default):\n+Create a brand new memtable and log file and direct future updates here\n+In the background:\n+Write the contents of the previous memtable to an sstable\n+Discard the memtable\n+Delete the old log file and the old memtable\n+Add the new sstable to the young (level-0) level.\n+\n+## Compactions\n+\n+When the size of level L exceeds its limit, we compact it in a background\n+thread. The compaction picks a file from level L and all overlapping files from\n+the next level L+1. Note that if a level-L file overlaps only part of a\n+level-(L+1) file, the entire file at level-(L+1) is used as an input to the\n+compaction and will be discarded after the compaction.  Aside: because level-0\n+is special (files in it may overlap each other), we treat compactions from\n+level-0 to level-1 specially: a level-0 compaction may pick more than one\n+level-0 file in case some of these files overlap each other.\n+\n+A compaction merges the contents of the picked files to produce a sequence of\n+level-(L+1) files. We switch to producing a new level-(L+1) file after the\n+current output file has reached the target file size (2MB). We also switch to a\n+new output file when the key range of the current output file has grown enough\n+to overlap more than ten level-(L+2) files.  This last rule ensures that a later\n+compaction of a level-(L+1) file will not pick up too much data from\n+level-(L+2).\n+\n+The old files are discarded and the new files are added to the serving state.\n+\n+Compactions for a particular level rotate through the key space. In more detail,\n+for each level L, we remember the ending key of the last compaction at level L.\n+The next compaction for level L will pick the first file that starts after this\n+key (wrapping around to the beginning of the key space if there is no such\n+file).\n+\n+Compactions drop overwritten values. They also drop deletion markers if there\n+are no higher numbered levels that contain a file whose range overlaps the\n+current key.\n+\n+### Timing\n+\n+Level-0 compactions will read up to four 1MB files from level-0, and at worst\n+all the level-1 files (10MB). I.e., we will read 14MB and write 14MB.\n+\n+Other than the special level-0 compactions, we will pick one 2MB file from level\n+L. In the worst case, this will overlap ~ 12 files from level L+1 (10 because\n+level-(L+1) is ten times the size of level-L, and another two at the boundaries\n+since the file ranges at level-L will usually not be aligned with the file\n+ranges at level-L+1). The compaction will therefore read 26MB and write 26MB.\n+Assuming a disk IO rate of 100MB/s (ballpark range for modern drives), the worst\n+compaction cost will be approximately 0.5 second.\n+\n+If we throttle the background writing to something small, say 10% of the full\n+100MB/s speed, a compaction may take up to 5 seconds. If the user is writing at\n+10MB/s, we might build up lots of level-0 files (~50 to hold the 5*10MB). This\n+may significantly increase the cost of reads due to the overhead of merging more\n+files together on every read.\n+\n+Solution 1: To reduce this problem, we might want to increase the log switching\n+threshold when the number of level-0 files is large. Though the downside is that\n+the larger this threshold, the more memory we will need to hold the\n+corresponding memtable.\n+\n+Solution 2: We might want to decrease write rate artificially when the number of\n+level-0 files goes up.\n+\n+Solution 3: We work on reducing the cost of very wide merges. Perhaps most of\n+the level-0 files will have their blocks sitting uncompressed in the cache and\n+we will only need to worry about the O(N) complexity in the merging iterator.\n+\n+### Number of files\n+\n+Instead of always making 2MB files, we could make larger files for larger levels\n+to reduce the total file count, though at the expense of more bursty\n+compactions.  Alternatively, we could shard the set of files into multiple\n+directories.\n+\n+An experiment on an ext3 filesystem on Feb 04, 2011 shows the following timings\n+to do 100K file opens in directories with varying number of files:\n+\n+\n+| Files in directory | Microseconds to open a file |\n+|-------------------:|----------------------------:|\n+|               1000 |                           9 |\n+|              10000 |                          10 |\n+|             100000 |                          16 |\n+\n+So maybe even the sharding is not necessary on modern filesystems?\n+\n+## Recovery\n+\n+* Read CURRENT to find name of the latest committed MANIFEST\n+* Read the named MANIFEST file\n+* Clean up stale files\n+* We could open all sstables here, but it is probably better to be lazy...\n+* Convert log chunk to a new level-0 sstable\n+* Start directing new writes to a new log file with recovered sequence#\n+\n+## Garbage collection of files\n+\n+`DeleteObsoleteFiles()` is called at the end of every compaction and at the end\n+of recovery. It finds the names of all files in the database. It deletes all log\n+files that are not the current log file. It deletes all table files that are not\n+referenced from some level and are not the output of an active compaction."
      },
      {
        "sha": "2155192581e7b79784564f190a47138ae29461f0",
        "filename": "src/leveldb/doc/index.html",
        "status": "removed",
        "additions": 0,
        "deletions": 549,
        "changes": 549,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.html?ref=1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "patch": "@@ -1,549 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb</title>\n-</head>\n-\n-<body>\n-<h1>Leveldb</h1>\n-<address>Jeff Dean, Sanjay Ghemawat</address>\n-<p>\n-The <code>leveldb</code> library provides a persistent key value store.  Keys and\n-values are arbitrary byte arrays.  The keys are ordered within the key\n-value store according to a user-specified comparator function.\n-\n-<p>\n-<h1>Opening A Database</h1>\n-<p>\n-A <code>leveldb</code> database has a name which corresponds to a file system\n-directory.  All of the contents of database are stored in this\n-directory.  The following example shows how to open a database,\n-creating it if necessary:\n-<p>\n-<pre>\n-  #include &lt;cassert&gt;\n-  #include \"leveldb/db.h\"\n-\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  assert(status.ok());\n-  ...\n-</pre>\n-If you want to raise an error if the database already exists, add\n-the following line before the <code>leveldb::DB::Open</code> call:\n-<pre>\n-  options.error_if_exists = true;\n-</pre>\n-<h1>Status</h1>\n-<p>\n-You may have noticed the <code>leveldb::Status</code> type above.  Values of this\n-type are returned by most functions in <code>leveldb</code> that may encounter an\n-error.  You can check if such a result is ok, and also print an\n-associated error message:\n-<p>\n-<pre>\n-   leveldb::Status s = ...;\n-   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;\n-</pre>\n-<h1>Closing A Database</h1>\n-<p>\n-When you are done with a database, just delete the database object.\n-Example:\n-<p>\n-<pre>\n-  ... open the db as described above ...\n-  ... do something with db ...\n-  delete db;\n-</pre>\n-<h1>Reads And Writes</h1>\n-<p>\n-The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to\n-modify/query the database.  For example, the following code\n-moves the value stored under key1 to key2.\n-<pre>\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);\n-  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);\n-</pre>\n-\n-<h1>Atomic Updates</h1>\n-<p>\n-Note that if the process dies after the Put of key2 but before the\n-delete of key1, the same value may be left stored under multiple keys.\n-Such problems can be avoided by using the <code>WriteBatch</code> class to\n-atomically apply a set of updates:\n-<p>\n-<pre>\n-  #include \"leveldb/write_batch.h\"\n-  ...\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) {\n-    leveldb::WriteBatch batch;\n-    batch.Delete(key1);\n-    batch.Put(key2, value);\n-    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);\n-  }\n-</pre>\n-The <code>WriteBatch</code> holds a sequence of edits to be made to the database,\n-and these edits within the batch are applied in order.  Note that we\n-called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,\n-we do not end up erroneously dropping the value entirely.\n-<p>\n-Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to\n-speed up bulk updates by placing lots of individual mutations into the\n-same batch.\n-\n-<h1>Synchronous Writes</h1>\n-By default, each write to <code>leveldb</code> is asynchronous: it\n-returns after pushing the write from the process into the operating\n-system.  The transfer from operating system memory to the underlying\n-persistent storage happens asynchronously.  The <code>sync</code> flag\n-can be turned on for a particular write to make the write operation\n-not return until the data being written has been pushed all the way to\n-persistent storage.  (On Posix systems, this is implemented by calling\n-either <code>fsync(...)</code> or <code>fdatasync(...)</code> or\n-<code>msync(..., MS_SYNC)</code> before the write operation returns.)\n-<pre>\n-  leveldb::WriteOptions write_options;\n-  write_options.sync = true;\n-  db-&gt;Put(write_options, ...);\n-</pre>\n-Asynchronous writes are often more than a thousand times as fast as\n-synchronous writes.  The downside of asynchronous writes is that a\n-crash of the machine may cause the last few updates to be lost.  Note\n-that a crash of just the writing process (i.e., not a reboot) will not\n-cause any loss since even when <code>sync</code> is false, an update\n-is pushed from the process memory into the operating system before it\n-is considered done.\n-\n-<p>\n-Asynchronous writes can often be used safely.  For example, when\n-loading a large amount of data into the database you can handle lost\n-updates by restarting the bulk load after a crash.  A hybrid scheme is\n-also possible where every Nth write is synchronous, and in the event\n-of a crash, the bulk load is restarted just after the last synchronous\n-write finished by the previous run.  (The synchronous write can update\n-a marker that describes where to restart on a crash.)\n-\n-<p>\n-<code>WriteBatch</code> provides an alternative to asynchronous writes.\n-Multiple updates may be placed in the same <code>WriteBatch</code> and\n-applied together using a synchronous write (i.e.,\n-<code>write_options.sync</code> is set to true).  The extra cost of\n-the synchronous write will be amortized across all of the writes in\n-the batch.\n-\n-<p>\n-<h1>Concurrency</h1>\n-<p>\n-A database may only be opened by one process at a time.\n-The <code>leveldb</code> implementation acquires a lock from the\n-operating system to prevent misuse.  Within a single process, the\n-same <code>leveldb::DB</code> object may be safely shared by multiple\n-concurrent threads.  I.e., different threads may write into or fetch\n-iterators or call <code>Get</code> on the same database without any\n-external synchronization (the leveldb implementation will\n-automatically do the required synchronization).  However other objects\n-(like Iterator and WriteBatch) may require external synchronization.\n-If two threads share such an object, they must protect access to it\n-using their own locking protocol.  More details are available in\n-the public header files.\n-<p>\n-<h1>Iteration</h1>\n-<p>\n-The following example demonstrates how to print all key,value pairs\n-in a database.\n-<p>\n-<pre>\n-  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; \": \"  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;\n-  }\n-  assert(it-&gt;status().ok());  // Check for any errors found during the scan\n-  delete it;\n-</pre>\n-The following variation shows how to process just the keys in the\n-range <code>[start,limit)</code>:\n-<p>\n-<pre>\n-  for (it-&gt;Seek(start);\n-       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;\n-       it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-You can also process entries in reverse order.  (Caveat: reverse\n-iteration may be somewhat slower than forward iteration.)\n-<p>\n-<pre>\n-  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {\n-    ...\n-  }\n-</pre>\n-<h1>Snapshots</h1>\n-<p>\n-Snapshots provide consistent read-only views over the entire state of\n-the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate\n-that a read should operate on a particular version of the DB state.\n-If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an\n-implicit snapshot of the current state.\n-<p>\n-Snapshots are created by the DB::GetSnapshot() method:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.snapshot = db-&gt;GetSnapshot();\n-  ... apply some updates to db ...\n-  leveldb::Iterator* iter = db-&gt;NewIterator(options);\n-  ... read using iter to view the state when the snapshot was created ...\n-  delete iter;\n-  db-&gt;ReleaseSnapshot(options.snapshot);\n-</pre>\n-Note that when a snapshot is no longer needed, it should be released\n-using the DB::ReleaseSnapshot interface.  This allows the\n-implementation to get rid of state that was being maintained just to\n-support reading as of that snapshot.\n-<h1>Slice</h1>\n-<p>\n-The return value of the <code>it->key()</code> and <code>it->value()</code> calls above\n-are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple\n-structure that contains a length and a pointer to an external byte\n-array.  Returning a <code>Slice</code> is a cheaper alternative to returning a\n-<code>std::string</code> since we do not need to copy potentially large keys and\n-values.  In addition, <code>leveldb</code> methods do not return null-terminated\n-C-style strings since <code>leveldb</code> keys and values are allowed to\n-contain '\\0' bytes.\n-<p>\n-C++ strings and null-terminated C-style strings can be easily converted\n-to a Slice:\n-<p>\n-<pre>\n-   leveldb::Slice s1 = \"hello\";\n-\n-   std::string str(\"world\");\n-   leveldb::Slice s2 = str;\n-</pre>\n-A Slice can be easily converted back to a C++ string:\n-<pre>\n-   std::string str = s1.ToString();\n-   assert(str == std::string(\"hello\"));\n-</pre>\n-Be careful when using Slices since it is up to the caller to ensure that\n-the external byte array into which the Slice points remains live while\n-the Slice is in use.  For example, the following is buggy:\n-<p>\n-<pre>\n-   leveldb::Slice slice;\n-   if (...) {\n-     std::string str = ...;\n-     slice = str;\n-   }\n-   Use(slice);\n-</pre>\n-When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the\n-backing storage for <code>slice</code> will disappear.\n-<p>\n-<h1>Comparators</h1>\n-<p>\n-The preceding examples used the default ordering function for key,\n-which orders bytes lexicographically.  You can however supply a custom\n-comparator when opening a database.  For example, suppose each\n-database key consists of two numbers and we should sort by the first\n-number, breaking ties by the second number.  First, define a proper\n-subclass of <code>leveldb::Comparator</code> that expresses these rules:\n-<p>\n-<pre>\n-  class TwoPartComparator : public leveldb::Comparator {\n-   public:\n-    // Three-way comparison function:\n-    //   if a &lt; b: negative result\n-    //   if a &gt; b: positive result\n-    //   else: zero result\n-    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {\n-      int a1, a2, b1, b2;\n-      ParseKey(a, &amp;a1, &amp;a2);\n-      ParseKey(b, &amp;b1, &amp;b2);\n-      if (a1 &lt; b1) return -1;\n-      if (a1 &gt; b1) return +1;\n-      if (a2 &lt; b2) return -1;\n-      if (a2 &gt; b2) return +1;\n-      return 0;\n-    }\n-\n-    // Ignore the following methods for now:\n-    const char* Name() const { return \"TwoPartComparator\"; }\n-    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }\n-    void FindShortSuccessor(std::string*) const { }\n-  };\n-</pre>\n-Now create a database using this custom comparator:\n-<p>\n-<pre>\n-  TwoPartComparator cmp;\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  options.comparator = &amp;cmp;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  ...\n-</pre>\n-<h2>Backwards compatibility</h2>\n-<p>\n-The result of the comparator's <code>Name</code> method is attached to the\n-database when it is created, and is checked on every subsequent\n-database open.  If the name changes, the <code>leveldb::DB::Open</code> call will\n-fail.  Therefore, change the name if and only if the new key format\n-and comparison function are incompatible with existing databases, and\n-it is ok to discard the contents of all existing databases.\n-<p>\n-You can however still gradually evolve your key format over time with\n-a little bit of pre-planning.  For example, you could store a version\n-number at the end of each key (one byte should suffice for most uses).\n-When you wish to switch to a new key format (e.g., adding an optional\n-third part to the keys processed by <code>TwoPartComparator</code>),\n-(a) keep the same comparator name (b) increment the version number\n-for new keys (c) change the comparator function so it uses the\n-version numbers found in the keys to decide how to interpret them.\n-<p>\n-<h1>Performance</h1>\n-<p>\n-Performance can be tuned by changing the default values of the\n-types defined in <code>include/leveldb/options.h</code>.\n-\n-<p>\n-<h2>Block size</h2>\n-<p>\n-<code>leveldb</code> groups adjacent keys together into the same block and such a\n-block is the unit of transfer to and from persistent storage.  The\n-default block size is approximately 4096 uncompressed bytes.\n-Applications that mostly do bulk scans over the contents of the\n-database may wish to increase this size.  Applications that do a lot\n-of point reads of small values may wish to switch to a smaller block\n-size if performance measurements indicate an improvement.  There isn't\n-much benefit in using blocks smaller than one kilobyte, or larger than\n-a few megabytes.  Also note that compression will be more effective\n-with larger block sizes.\n-<p>\n-<h2>Compression</h2>\n-<p>\n-Each block is individually compressed before being written to\n-persistent storage.  Compression is on by default since the default\n-compression method is very fast, and is automatically disabled for\n-uncompressible data.  In rare cases, applications may want to disable\n-compression entirely, but should only do so if benchmarks show a\n-performance improvement:\n-<p>\n-<pre>\n-  leveldb::Options options;\n-  options.compression = leveldb::kNoCompression;\n-  ... leveldb::DB::Open(options, name, ...) ....\n-</pre>\n-<h2>Cache</h2>\n-<p>\n-The contents of the database are stored in a set of files in the\n-filesystem and each file stores a sequence of compressed blocks.  If\n-<code>options.cache</code> is non-NULL, it is used to cache frequently used\n-uncompressed block contents.\n-<p>\n-<pre>\n-  #include \"leveldb/cache.h\"\n-\n-  leveldb::Options options;\n-  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n-  leveldb::DB* db;\n-  leveldb::DB::Open(options, name, &db);\n-  ... use the db ...\n-  delete db\n-  delete options.cache;\n-</pre>\n-Note that the cache holds uncompressed data, and therefore it should\n-be sized according to application level data sizes, without any\n-reduction from compression.  (Caching of compressed blocks is left to\n-the operating system buffer cache, or any custom <code>Env</code>\n-implementation provided by the client.)\n-<p>\n-When performing a bulk read, the application may wish to disable\n-caching so that the data processed by the bulk read does not end up\n-displacing most of the cached contents.  A per-iterator option can be\n-used to achieve this:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.fill_cache = false;\n-  leveldb::Iterator* it = db-&gt;NewIterator(options);\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-<h2>Key Layout</h2>\n-<p>\n-Note that the unit of disk transfer and caching is a block.  Adjacent\n-keys (according to the database sort order) will usually be placed in\n-the same block.  Therefore the application can improve its performance\n-by placing keys that are accessed together near each other and placing\n-infrequently used keys in a separate region of the key space.\n-<p>\n-For example, suppose we are implementing a simple file system on top\n-of <code>leveldb</code>.  The types of entries we might wish to store are:\n-<p>\n-<pre>\n-   filename -&gt; permission-bits, length, list of file_block_ids\n-   file_block_id -&gt; data\n-</pre>\n-We might want to prefix <code>filename</code> keys with one letter (say '/') and the\n-<code>file_block_id</code> keys with a different letter (say '0') so that scans\n-over just the metadata do not force us to fetch and cache bulky file\n-contents.\n-<p>\n-<h2>Filters</h2>\n-<p>\n-Because of the way <code>leveldb</code> data is organized on disk,\n-a single <code>Get()</code> call may involve multiple reads from disk.\n-The optional <code>FilterPolicy</code> mechanism can be used to reduce\n-the number of disk reads substantially.\n-<pre>\n-   leveldb::Options options;\n-   options.filter_policy = NewBloomFilterPolicy(10);\n-   leveldb::DB* db;\n-   leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-   ... use the database ...\n-   delete db;\n-   delete options.filter_policy;\n-</pre>\n-The preceding code associates a\n-<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a>\n-based filtering policy with the database.  Bloom filter based\n-filtering relies on keeping some number of bits of data in memory per\n-key (in this case 10 bits per key since that is the argument we passed\n-to NewBloomFilterPolicy).  This filter will reduce the number of unnecessary\n-disk reads needed for <code>Get()</code> calls by a factor of\n-approximately a 100.  Increasing the bits per key will lead to a\n-larger reduction at the cost of more memory usage.  We recommend that\n-applications whose working set does not fit in memory and that do a\n-lot of random reads set a filter policy.\n-<p>\n-If you are using a custom comparator, you should ensure that the filter\n-policy you are using is compatible with your comparator.  For example,\n-consider a comparator that ignores trailing spaces when comparing keys.\n-<code>NewBloomFilterPolicy</code> must not be used with such a comparator.\n-Instead, the application should provide a custom filter policy that\n-also ignores trailing spaces.  For example:\n-<pre>\n-  class CustomFilterPolicy : public leveldb::FilterPolicy {\n-   private:\n-    FilterPolicy* builtin_policy_;\n-   public:\n-    CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) { }\n-    ~CustomFilterPolicy() { delete builtin_policy_; }\n-\n-    const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n-\n-    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      std::vector&lt;Slice&gt; trimmed(n);\n-      for (int i = 0; i &lt; n; i++) {\n-        trimmed[i] = RemoveTrailingSpaces(keys[i]);\n-      }\n-      return builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);\n-    }\n-\n-    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      return builtin_policy_-&gt;KeyMayMatch(RemoveTrailingSpaces(key), filter);\n-    }\n-  };\n-</pre>\n-<p>\n-Advanced applications may provide a filter policy that does not use\n-a bloom filter but uses some other mechanism for summarizing a set\n-of keys.  See <code>leveldb/filter_policy.h</code> for detail.\n-<p>\n-<h1>Checksums</h1>\n-<p>\n-<code>leveldb</code> associates checksums with all data it stores in the file system.\n-There are two separate controls provided over how aggressively these\n-checksums are verified:\n-<p>\n-<ul>\n-<li> <code>ReadOptions::verify_checksums</code> may be set to true to force\n-  checksum verification of all data that is read from the file system on\n-  behalf of a particular read.  By default, no such verification is\n-  done.\n-<p>\n-<li> <code>Options::paranoid_checks</code> may be set to true before opening a\n-  database to make the database implementation raise an error as soon as\n-  it detects an internal corruption.  Depending on which portion of the\n-  database has been corrupted, the error may be raised when the database\n-  is opened, or later by another database operation.  By default,\n-  paranoid checking is off so that the database can be used even if\n-  parts of its persistent storage have been corrupted.\n-<p>\n-  If a database is corrupted (perhaps it cannot be opened when\n-  paranoid checking is turned on), the <code>leveldb::RepairDB</code> function\n-  may be used to recover as much of the data as possible\n-<p>\n-</ul>\n-<h1>Approximate Sizes</h1>\n-<p>\n-The <code>GetApproximateSizes</code> method can used to get the approximate\n-number of bytes of file system space used by one or more key ranges.\n-<p>\n-<pre>\n-   leveldb::Range ranges[2];\n-   ranges[0] = leveldb::Range(\"a\", \"c\");\n-   ranges[1] = leveldb::Range(\"x\", \"z\");\n-   uint64_t sizes[2];\n-   leveldb::Status s = db-&gt;GetApproximateSizes(ranges, 2, sizes);\n-</pre>\n-The preceding call will set <code>sizes[0]</code> to the approximate number of\n-bytes of file system space used by the key range <code>[a..c)</code> and\n-<code>sizes[1]</code> to the approximate number of bytes used by the key range\n-<code>[x..z)</code>.\n-<p>\n-<h1>Environment</h1>\n-<p>\n-All file operations (and other operating system calls) issued by the\n-<code>leveldb</code> implementation are routed through a <code>leveldb::Env</code> object.\n-Sophisticated clients may wish to provide their own <code>Env</code>\n-implementation to get better control.  For example, an application may\n-introduce artificial delays in the file IO paths to limit the impact\n-of <code>leveldb</code> on other activities in the system.\n-<p>\n-<pre>\n-  class SlowEnv : public leveldb::Env {\n-    .. implementation of the Env interface ...\n-  };\n-\n-  SlowEnv env;\n-  leveldb::Options options;\n-  options.env = &amp;env;\n-  Status s = leveldb::DB::Open(options, ...);\n-</pre>\n-<h1>Porting</h1>\n-<p>\n-<code>leveldb</code> may be ported to a new platform by providing platform\n-specific implementations of the types/methods/functions exported by\n-<code>leveldb/port/port.h</code>.  See <code>leveldb/port/port_example.h</code> for more\n-details.\n-<p>\n-In addition, the new platform may need a new default <code>leveldb::Env</code>\n-implementation.  See <code>leveldb/util/env_posix.h</code> for an example.\n-\n-<h1>Other Information</h1>\n-\n-<p>\n-Details about the <code>leveldb</code> implementation may be found in\n-the following documents:\n-<ul>\n-<li> <a href=\"impl.html\">Implementation notes</a>\n-<li> <a href=\"table_format.txt\">Format of an immutable Table file</a>\n-<li> <a href=\"log_format.txt\">Format of a log file</a>\n-</ul>\n-\n-</body>\n-</html>"
      },
      {
        "sha": "be8569692bb054676bf451e06a8dd4980c32edca",
        "filename": "src/leveldb/doc/index.md",
        "status": "added",
        "additions": 523,
        "deletions": 0,
        "changes": 523,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/index.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/index.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.md?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,523 @@\n+leveldb\n+=======\n+\n+_Jeff Dean, Sanjay Ghemawat_\n+\n+The leveldb library provides a persistent key value store. Keys and values are\n+arbitrary byte arrays.  The keys are ordered within the key value store\n+according to a user-specified comparator function.\n+\n+## Opening A Database\n+\n+A leveldb database has a name which corresponds to a file system directory. All\n+of the contents of database are stored in this directory. The following example\n+shows how to open a database, creating it if necessary:\n+\n+```c++\n+#include <cassert>\n+#include \"leveldb/db.h\"\n+\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+assert(status.ok());\n+...\n+```\n+\n+If you want to raise an error if the database already exists, add the following\n+line before the `leveldb::DB::Open` call:\n+\n+```c++\n+options.error_if_exists = true;\n+```\n+\n+## Status\n+\n+You may have noticed the `leveldb::Status` type above. Values of this type are\n+returned by most functions in leveldb that may encounter an error. You can check\n+if such a result is ok, and also print an associated error message:\n+\n+```c++\n+leveldb::Status s = ...;\n+if (!s.ok()) cerr << s.ToString() << endl;\n+```\n+\n+## Closing A Database\n+\n+When you are done with a database, just delete the database object. Example:\n+\n+```c++\n+... open the db as described above ...\n+... do something with db ...\n+delete db;\n+```\n+\n+## Reads And Writes\n+\n+The database provides Put, Delete, and Get methods to modify/query the database.\n+For example, the following code moves the value stored under key1 to key2.\n+\n+```c++\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) s = db->Put(leveldb::WriteOptions(), key2, value);\n+if (s.ok()) s = db->Delete(leveldb::WriteOptions(), key1);\n+```\n+\n+## Atomic Updates\n+\n+Note that if the process dies after the Put of key2 but before the delete of\n+key1, the same value may be left stored under multiple keys. Such problems can\n+be avoided by using the `WriteBatch` class to atomically apply a set of updates:\n+\n+```c++\n+#include \"leveldb/write_batch.h\"\n+...\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) {\n+  leveldb::WriteBatch batch;\n+  batch.Delete(key1);\n+  batch.Put(key2, value);\n+  s = db->Write(leveldb::WriteOptions(), &batch);\n+}\n+```\n+\n+The `WriteBatch` holds a sequence of edits to be made to the database, and these\n+edits within the batch are applied in order. Note that we called Delete before\n+Put so that if key1 is identical to key2, we do not end up erroneously dropping\n+the value entirely.\n+\n+Apart from its atomicity benefits, `WriteBatch` may also be used to speed up\n+bulk updates by placing lots of individual mutations into the same batch.\n+\n+## Synchronous Writes\n+\n+By default, each write to leveldb is asynchronous: it returns after pushing the\n+write from the process into the operating system. The transfer from operating\n+system memory to the underlying persistent storage happens asynchronously. The\n+sync flag can be turned on for a particular write to make the write operation\n+not return until the data being written has been pushed all the way to\n+persistent storage. (On Posix systems, this is implemented by calling either\n+`fsync(...)` or `fdatasync(...)` or `msync(..., MS_SYNC)` before the write\n+operation returns.)\n+\n+```c++\n+leveldb::WriteOptions write_options;\n+write_options.sync = true;\n+db->Put(write_options, ...);\n+```\n+\n+Asynchronous writes are often more than a thousand times as fast as synchronous\n+writes. The downside of asynchronous writes is that a crash of the machine may\n+cause the last few updates to be lost. Note that a crash of just the writing\n+process (i.e., not a reboot) will not cause any loss since even when sync is\n+false, an update is pushed from the process memory into the operating system\n+before it is considered done.\n+\n+Asynchronous writes can often be used safely. For example, when loading a large\n+amount of data into the database you can handle lost updates by restarting the\n+bulk load after a crash. A hybrid scheme is also possible where every Nth write\n+is synchronous, and in the event of a crash, the bulk load is restarted just\n+after the last synchronous write finished by the previous run. (The synchronous\n+write can update a marker that describes where to restart on a crash.)\n+\n+`WriteBatch` provides an alternative to asynchronous writes. Multiple updates\n+may be placed in the same WriteBatch and applied together using a synchronous\n+write (i.e., `write_options.sync` is set to true). The extra cost of the\n+synchronous write will be amortized across all of the writes in the batch.\n+\n+## Concurrency\n+\n+A database may only be opened by one process at a time. The leveldb\n+implementation acquires a lock from the operating system to prevent misuse.\n+Within a single process, the same `leveldb::DB` object may be safely shared by\n+multiple concurrent threads. I.e., different threads may write into or fetch\n+iterators or call Get on the same database without any external synchronization\n+(the leveldb implementation will automatically do the required synchronization).\n+However other objects (like Iterator and `WriteBatch`) may require external\n+synchronization. If two threads share such an object, they must protect access\n+to it using their own locking protocol. More details are available in the public\n+header files.\n+\n+## Iteration\n+\n+The following example demonstrates how to print all key,value pairs in a\n+database.\n+\n+```c++\n+leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions());\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  cout << it->key().ToString() << \": \"  << it->value().ToString() << endl;\n+}\n+assert(it->status().ok());  // Check for any errors found during the scan\n+delete it;\n+```\n+\n+The following variation shows how to process just the keys in the range\n+[start,limit):\n+\n+```c++\n+for (it->Seek(start);\n+   it->Valid() && it->key().ToString() < limit;\n+   it->Next()) {\n+  ...\n+}\n+```\n+\n+You can also process entries in reverse order. (Caveat: reverse iteration may be\n+somewhat slower than forward iteration.)\n+\n+```c++\n+for (it->SeekToLast(); it->Valid(); it->Prev()) {\n+  ...\n+}\n+```\n+\n+## Snapshots\n+\n+Snapshots provide consistent read-only views over the entire state of the\n+key-value store.  `ReadOptions::snapshot` may be non-NULL to indicate that a\n+read should operate on a particular version of the DB state. If\n+`ReadOptions::snapshot` is NULL, the read will operate on an implicit snapshot\n+of the current state.\n+\n+Snapshots are created by the `DB::GetSnapshot()` method:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.snapshot = db->GetSnapshot();\n+... apply some updates to db ...\n+leveldb::Iterator* iter = db->NewIterator(options);\n+... read using iter to view the state when the snapshot was created ...\n+delete iter;\n+db->ReleaseSnapshot(options.snapshot);\n+```\n+\n+Note that when a snapshot is no longer needed, it should be released using the\n+`DB::ReleaseSnapshot` interface. This allows the implementation to get rid of\n+state that was being maintained just to support reading as of that snapshot.\n+\n+## Slice\n+\n+The return value of the `it->key()` and `it->value()` calls above are instances\n+of the `leveldb::Slice` type. Slice is a simple structure that contains a length\n+and a pointer to an external byte array. Returning a Slice is a cheaper\n+alternative to returning a `std::string` since we do not need to copy\n+potentially large keys and values. In addition, leveldb methods do not return\n+null-terminated C-style strings since leveldb keys and values are allowed to\n+contain `'\\0'` bytes.\n+\n+C++ strings and null-terminated C-style strings can be easily converted to a\n+Slice:\n+\n+```c++\n+leveldb::Slice s1 = \"hello\";\n+\n+std::string str(\"world\");\n+leveldb::Slice s2 = str;\n+```\n+\n+A Slice can be easily converted back to a C++ string:\n+\n+```c++\n+std::string str = s1.ToString();\n+assert(str == std::string(\"hello\"));\n+```\n+\n+Be careful when using Slices since it is up to the caller to ensure that the\n+external byte array into which the Slice points remains live while the Slice is\n+in use. For example, the following is buggy:\n+\n+```c++\n+leveldb::Slice slice;\n+if (...) {\n+  std::string str = ...;\n+  slice = str;\n+}\n+Use(slice);\n+```\n+\n+When the if statement goes out of scope, str will be destroyed and the backing\n+storage for slice will disappear.\n+\n+## Comparators\n+\n+The preceding examples used the default ordering function for key, which orders\n+bytes lexicographically. You can however supply a custom comparator when opening\n+a database.  For example, suppose each database key consists of two numbers and\n+we should sort by the first number, breaking ties by the second number. First,\n+define a proper subclass of `leveldb::Comparator` that expresses these rules:\n+\n+```c++\n+class TwoPartComparator : public leveldb::Comparator {\n+ public:\n+  // Three-way comparison function:\n+  //   if a < b: negative result\n+  //   if a > b: positive result\n+  //   else: zero result\n+  int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const {\n+    int a1, a2, b1, b2;\n+    ParseKey(a, &a1, &a2);\n+    ParseKey(b, &b1, &b2);\n+    if (a1 < b1) return -1;\n+    if (a1 > b1) return +1;\n+    if (a2 < b2) return -1;\n+    if (a2 > b2) return +1;\n+    return 0;\n+  }\n+\n+  // Ignore the following methods for now:\n+  const char* Name() const { return \"TwoPartComparator\"; }\n+  void FindShortestSeparator(std::string*, const leveldb::Slice&) const {}\n+  void FindShortSuccessor(std::string*) const {}\n+};\n+```\n+\n+Now create a database using this custom comparator:\n+\n+```c++\n+TwoPartComparator cmp;\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+options.comparator = &cmp;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+...\n+```\n+\n+### Backwards compatibility\n+\n+The result of the comparator's Name method is attached to the database when it\n+is created, and is checked on every subsequent database open. If the name\n+changes, the `leveldb::DB::Open` call will fail. Therefore, change the name if\n+and only if the new key format and comparison function are incompatible with\n+existing databases, and it is ok to discard the contents of all existing\n+databases.\n+\n+You can however still gradually evolve your key format over time with a little\n+bit of pre-planning. For example, you could store a version number at the end of\n+each key (one byte should suffice for most uses). When you wish to switch to a\n+new key format (e.g., adding an optional third part to the keys processed by\n+`TwoPartComparator`), (a) keep the same comparator name (b) increment the\n+version number for new keys (c) change the comparator function so it uses the\n+version numbers found in the keys to decide how to interpret them.\n+\n+## Performance\n+\n+Performance can be tuned by changing the default values of the types defined in\n+`include/leveldb/options.h`.\n+\n+### Block size\n+\n+leveldb groups adjacent keys together into the same block and such a block is\n+the unit of transfer to and from persistent storage. The default block size is\n+approximately 4096 uncompressed bytes.  Applications that mostly do bulk scans\n+over the contents of the database may wish to increase this size. Applications\n+that do a lot of point reads of small values may wish to switch to a smaller\n+block size if performance measurements indicate an improvement. There isn't much\n+benefit in using blocks smaller than one kilobyte, or larger than a few\n+megabytes. Also note that compression will be more effective with larger block\n+sizes.\n+\n+### Compression\n+\n+Each block is individually compressed before being written to persistent\n+storage. Compression is on by default since the default compression method is\n+very fast, and is automatically disabled for uncompressible data. In rare cases,\n+applications may want to disable compression entirely, but should only do so if\n+benchmarks show a performance improvement:\n+\n+```c++\n+leveldb::Options options;\n+options.compression = leveldb::kNoCompression;\n+... leveldb::DB::Open(options, name, ...) ....\n+```\n+\n+### Cache\n+\n+The contents of the database are stored in a set of files in the filesystem and\n+each file stores a sequence of compressed blocks. If options.cache is non-NULL,\n+it is used to cache frequently used uncompressed block contents.\n+\n+```c++\n+#include \"leveldb/cache.h\"\n+\n+leveldb::Options options;\n+options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n+leveldb::DB* db;\n+leveldb::DB::Open(options, name, &db);\n+... use the db ...\n+delete db\n+delete options.cache;\n+```\n+\n+Note that the cache holds uncompressed data, and therefore it should be sized\n+according to application level data sizes, without any reduction from\n+compression. (Caching of compressed blocks is left to the operating system\n+buffer cache, or any custom Env implementation provided by the client.)\n+\n+When performing a bulk read, the application may wish to disable caching so that\n+the data processed by the bulk read does not end up displacing most of the\n+cached contents. A per-iterator option can be used to achieve this:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.fill_cache = false;\n+leveldb::Iterator* it = db->NewIterator(options);\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  ...\n+}\n+```\n+\n+### Key Layout\n+\n+Note that the unit of disk transfer and caching is a block. Adjacent keys\n+(according to the database sort order) will usually be placed in the same block.\n+Therefore the application can improve its performance by placing keys that are\n+accessed together near each other and placing infrequently used keys in a\n+separate region of the key space.\n+\n+For example, suppose we are implementing a simple file system on top of leveldb.\n+The types of entries we might wish to store are:\n+\n+    filename -> permission-bits, length, list of file_block_ids\n+    file_block_id -> data\n+\n+We might want to prefix filename keys with one letter (say '/') and the\n+`file_block_id` keys with a different letter (say '0') so that scans over just\n+the metadata do not force us to fetch and cache bulky file contents.\n+\n+### Filters\n+\n+Because of the way leveldb data is organized on disk, a single `Get()` call may\n+involve multiple reads from disk. The optional FilterPolicy mechanism can be\n+used to reduce the number of disk reads substantially.\n+\n+```c++\n+leveldb::Options options;\n+options.filter_policy = NewBloomFilterPolicy(10);\n+leveldb::DB* db;\n+leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+... use the database ...\n+delete db;\n+delete options.filter_policy;\n+```\n+\n+The preceding code associates a Bloom filter based filtering policy with the\n+database.  Bloom filter based filtering relies on keeping some number of bits of\n+data in memory per key (in this case 10 bits per key since that is the argument\n+we passed to `NewBloomFilterPolicy`). This filter will reduce the number of\n+unnecessary disk reads needed for Get() calls by a factor of approximately\n+a 100. Increasing the bits per key will lead to a larger reduction at the cost\n+of more memory usage. We recommend that applications whose working set does not\n+fit in memory and that do a lot of random reads set a filter policy.\n+\n+If you are using a custom comparator, you should ensure that the filter policy\n+you are using is compatible with your comparator. For example, consider a\n+comparator that ignores trailing spaces when comparing keys.\n+`NewBloomFilterPolicy` must not be used with such a comparator. Instead, the\n+application should provide a custom filter policy that also ignores trailing\n+spaces. For example:\n+\n+```c++\n+class CustomFilterPolicy : public leveldb::FilterPolicy {\n+ private:\n+  FilterPolicy* builtin_policy_;\n+\n+ public:\n+  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) {}\n+  ~CustomFilterPolicy() { delete builtin_policy_; }\n+\n+  const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n+\n+  void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    // Use builtin bloom filter code after removing trailing spaces\n+    std::vector<Slice> trimmed(n);\n+    for (int i = 0; i < n; i++) {\n+      trimmed[i] = RemoveTrailingSpaces(keys[i]);\n+    }\n+    return builtin_policy_->CreateFilter(&trimmed[i], n, dst);\n+  }\n+};\n+```\n+\n+Advanced applications may provide a filter policy that does not use a bloom\n+filter but uses some other mechanism for summarizing a set of keys. See\n+`leveldb/filter_policy.h` for detail.\n+\n+## Checksums\n+\n+leveldb associates checksums with all data it stores in the file system. There\n+are two separate controls provided over how aggressively these checksums are\n+verified:\n+\n+`ReadOptions::verify_checksums` may be set to true to force checksum\n+verification of all data that is read from the file system on behalf of a\n+particular read.  By default, no such verification is done.\n+\n+`Options::paranoid_checks` may be set to true before opening a database to make\n+the database implementation raise an error as soon as it detects an internal\n+corruption. Depending on which portion of the database has been corrupted, the\n+error may be raised when the database is opened, or later by another database\n+operation. By default, paranoid checking is off so that the database can be used\n+even if parts of its persistent storage have been corrupted.\n+\n+If a database is corrupted (perhaps it cannot be opened when paranoid checking\n+is turned on), the `leveldb::RepairDB` function may be used to recover as much\n+of the data as possible\n+\n+## Approximate Sizes\n+\n+The `GetApproximateSizes` method can used to get the approximate number of bytes\n+of file system space used by one or more key ranges.\n+\n+```c++\n+leveldb::Range ranges[2];\n+ranges[0] = leveldb::Range(\"a\", \"c\");\n+ranges[1] = leveldb::Range(\"x\", \"z\");\n+uint64_t sizes[2];\n+leveldb::Status s = db->GetApproximateSizes(ranges, 2, sizes);\n+```\n+\n+The preceding call will set `sizes[0]` to the approximate number of bytes of\n+file system space used by the key range `[a..c)` and `sizes[1]` to the\n+approximate number of bytes used by the key range `[x..z)`.\n+\n+## Environment\n+\n+All file operations (and other operating system calls) issued by the leveldb\n+implementation are routed through a `leveldb::Env` object. Sophisticated clients\n+may wish to provide their own Env implementation to get better control.\n+For example, an application may introduce artificial delays in the file IO\n+paths to limit the impact of leveldb on other activities in the system.\n+\n+```c++\n+class SlowEnv : public leveldb::Env {\n+  ... implementation of the Env interface ...\n+};\n+\n+SlowEnv env;\n+leveldb::Options options;\n+options.env = &env;\n+Status s = leveldb::DB::Open(options, ...);\n+```\n+\n+## Porting\n+\n+leveldb may be ported to a new platform by providing platform specific\n+implementations of the types/methods/functions exported by\n+`leveldb/port/port.h`.  See `leveldb/port/port_example.h` for more details.\n+\n+In addition, the new platform may need a new default `leveldb::Env`\n+implementation.  See `leveldb/util/env_posix.h` for an example.\n+\n+## Other Information\n+\n+Details about the leveldb implementation may be found in the following\n+documents:\n+\n+1. [Implementation notes](impl.md)\n+2. [Format of an immutable Table file](table_format.md)\n+3. [Format of a log file](log_format.md)"
      },
      {
        "sha": "f32cb5d7dac482e71a103f85b1a2667b92e6120e",
        "filename": "src/leveldb/doc/log_format.md",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/log_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/log_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.md?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,75 @@\n+leveldb Log format\n+==================\n+The log file contents are a sequence of 32KB blocks.  The only exception is that\n+the tail of the file may contain a partial block.\n+\n+Each block consists of a sequence of records:\n+\n+    block := record* trailer?\n+    record :=\n+      checksum: uint32     // crc32c of type and data[] ; little-endian\n+      length: uint16       // little-endian\n+      type: uint8          // One of FULL, FIRST, MIDDLE, LAST\n+      data: uint8[length]\n+\n+A record never starts within the last six bytes of a block (since it won't fit).\n+Any leftover bytes here form the trailer, which must consist entirely of zero\n+bytes and must be skipped by readers.\n+\n+Aside: if exactly seven bytes are left in the current block, and a new non-zero\n+length record is added, the writer must emit a FIRST record (which contains zero\n+bytes of user data) to fill up the trailing seven bytes of the block and then\n+emit all of the user data in subsequent blocks.\n+\n+More types may be added in the future.  Some Readers may skip record types they\n+do not understand, others may report that some data was skipped.\n+\n+    FULL == 1\n+    FIRST == 2\n+    MIDDLE == 3\n+    LAST == 4\n+\n+The FULL record contains the contents of an entire user record.\n+\n+FIRST, MIDDLE, LAST are types used for user records that have been split into\n+multiple fragments (typically because of block boundaries).  FIRST is the type\n+of the first fragment of a user record, LAST is the type of the last fragment of\n+a user record, and MIDDLE is the type of all interior fragments of a user\n+record.\n+\n+Example: consider a sequence of user records:\n+\n+    A: length 1000\n+    B: length 97270\n+    C: length 8000\n+\n+**A** will be stored as a FULL record in the first block.\n+\n+**B** will be split into three fragments: first fragment occupies the rest of\n+the first block, second fragment occupies the entirety of the second block, and\n+the third fragment occupies a prefix of the third block.  This will leave six\n+bytes free in the third block, which will be left empty as the trailer.\n+\n+**C** will be stored as a FULL record in the fourth block.\n+\n+----\n+\n+## Some benefits over the recordio format:\n+\n+1. We do not need any heuristics for resyncing - just go to next block boundary\n+   and scan.  If there is a corruption, skip to the next block.  As a\n+   side-benefit, we do not get confused when part of the contents of one log\n+   file are embedded as a record inside another log file.\n+\n+2. Splitting at approximate boundaries (e.g., for mapreduce) is simple: find the\n+   next block boundary and skip records until we hit a FULL or FIRST record.\n+\n+3. We do not need extra buffering for large records.\n+\n+## Some downsides compared to recordio format:\n+\n+1. No packing of tiny records.  This could be fixed by adding a new record type,\n+   so it is a shortcoming of the current implementation, not necessarily the\n+   format.\n+\n+2. No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "4cca5ef6ead327bc4c55d8941528f656fa68166c",
        "filename": "src/leveldb/doc/log_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 75,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.txt?ref=1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "patch": "@@ -1,75 +0,0 @@\n-The log file contents are a sequence of 32KB blocks.  The only\n-exception is that the tail of the file may contain a partial block.\n-\n-Each block consists of a sequence of records:\n-   block := record* trailer?\n-   record :=\n-\tchecksum: uint32\t// crc32c of type and data[] ; little-endian\n-\tlength: uint16\t\t// little-endian\n-\ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n-\tdata: uint8[length]\n-\n-A record never starts within the last six bytes of a block (since it\n-won't fit).  Any leftover bytes here form the trailer, which must\n-consist entirely of zero bytes and must be skipped by readers.\n-\n-Aside: if exactly seven bytes are left in the current block, and a new\n-non-zero length record is added, the writer must emit a FIRST record\n-(which contains zero bytes of user data) to fill up the trailing seven\n-bytes of the block and then emit all of the user data in subsequent\n-blocks.\n-\n-More types may be added in the future.  Some Readers may skip record\n-types they do not understand, others may report that some data was\n-skipped.\n-\n-FULL == 1\n-FIRST == 2\n-MIDDLE == 3\n-LAST == 4\n-\n-The FULL record contains the contents of an entire user record.\n-\n-FIRST, MIDDLE, LAST are types used for user records that have been\n-split into multiple fragments (typically because of block boundaries).\n-FIRST is the type of the first fragment of a user record, LAST is the\n-type of the last fragment of a user record, and MIDDLE is the type of\n-all interior fragments of a user record.\n-\n-Example: consider a sequence of user records:\n-   A: length 1000\n-   B: length 97270\n-   C: length 8000\n-A will be stored as a FULL record in the first block.\n-\n-B will be split into three fragments: first fragment occupies the rest\n-of the first block, second fragment occupies the entirety of the\n-second block, and the third fragment occupies a prefix of the third\n-block.  This will leave six bytes free in the third block, which will\n-be left empty as the trailer.\n-\n-C will be stored as a FULL record in the fourth block.\n-\n-===================\n-\n-Some benefits over the recordio format:\n-\n-(1) We do not need any heuristics for resyncing - just go to next\n-block boundary and scan.  If there is a corruption, skip to the next\n-block.  As a side-benefit, we do not get confused when part of the\n-contents of one log file are embedded as a record inside another log\n-file.\n-\n-(2) Splitting at approximate boundaries (e.g., for mapreduce) is\n-simple: find the next block boundary and skip records until we\n-hit a FULL or FIRST record.\n-\n-(3) We do not need extra buffering for large records.\n-\n-Some downsides compared to recordio format:\n-\n-(1) No packing of tiny records.  This could be fixed by adding a new\n-record type, so it is a shortcoming of the current implementation,\n-not necessarily the format.\n-\n-(2) No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "5fe7e72411b828ddc3453754d451fe357626382e",
        "filename": "src/leveldb/doc/table_format.md",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/table_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/doc/table_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.md?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,107 @@\n+leveldb File format\n+===================\n+\n+    <beginning_of_file>\n+    [data block 1]\n+    [data block 2]\n+    ...\n+    [data block N]\n+    [meta block 1]\n+    ...\n+    [meta block K]\n+    [metaindex block]\n+    [index block]\n+    [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n+    <end_of_file>\n+\n+The file contains internal pointers.  Each such pointer is called\n+a BlockHandle and contains the following information:\n+\n+    offset:   varint64\n+    size:     varint64\n+\n+See [varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)\n+for an explanation of varint64 format.\n+\n+1.  The sequence of key/value pairs in the file are stored in sorted\n+order and partitioned into a sequence of data blocks.  These blocks\n+come one after another at the beginning of the file.  Each data block\n+is formatted according to the code in `block_builder.cc`, and then\n+optionally compressed.\n+\n+2. After the data blocks we store a bunch of meta blocks.  The\n+supported meta block types are described below.  More meta block types\n+may be added in the future.  Each meta block is again formatted using\n+`block_builder.cc` and then optionally compressed.\n+\n+3. A \"metaindex\" block.  It contains one entry for every other meta\n+block where the key is the name of the meta block and the value is a\n+BlockHandle pointing to that meta block.\n+\n+4. An \"index\" block.  This block contains one entry per data block,\n+where the key is a string >= last key in that data block and before\n+the first key in the successive data block.  The value is the\n+BlockHandle for the data block.\n+\n+5. At the very end of the file is a fixed length footer that contains\n+the BlockHandle of the metaindex and index blocks as well as a magic number.\n+\n+        metaindex_handle: char[p];     // Block handle for metaindex\n+        index_handle:     char[q];     // Block handle for index\n+        padding:          char[40-p-q];// zeroed bytes to make fixed length\n+                                       // (40==2*BlockHandle::kMaxEncodedLength)\n+        magic:            fixed64;     // == 0xdb4775248b80fb57 (little-endian)\n+\n+## \"filter\" Meta Block\n+\n+If a `FilterPolicy` was specified when the database was opened, a\n+filter block is stored in each table.  The \"metaindex\" block contains\n+an entry that maps from `filter.<N>` to the BlockHandle for the filter\n+block where `<N>` is the string returned by the filter policy's\n+`Name()` method.\n+\n+The filter block stores a sequence of filters, where filter i contains\n+the output of `FilterPolicy::CreateFilter()` on all keys that are stored\n+in a block whose file offset falls within the range\n+\n+    [ i*base ... (i+1)*base-1 ]\n+\n+Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n+the range `[ 0KB .. 2KB-1 ]`, all of the keys in X and Y will be\n+converted to a filter by calling `FilterPolicy::CreateFilter()`, and the\n+resulting filter will be stored as the first filter in the filter\n+block.\n+\n+The filter block is formatted as follows:\n+\n+    [filter 0]\n+    [filter 1]\n+    [filter 2]\n+    ...\n+    [filter N-1]\n+\n+    [offset of filter 0]                  : 4 bytes\n+    [offset of filter 1]                  : 4 bytes\n+    [offset of filter 2]                  : 4 bytes\n+    ...\n+    [offset of filter N-1]                : 4 bytes\n+\n+    [offset of beginning of offset array] : 4 bytes\n+    lg(base)                              : 1 byte\n+\n+The offset array at the end of the filter block allows efficient\n+mapping from a data block offset to the corresponding filter.\n+\n+## \"stats\" Meta Block\n+\n+This meta block contains a bunch of stats.  The key is the name\n+of the statistic.  The value contains the statistic.\n+\n+TODO(postrelease): record following stats.\n+\n+    data size\n+    index size\n+    key size (uncompressed)\n+    value size (uncompressed)\n+    number of entries\n+    number of data blocks"
      },
      {
        "sha": "ca8f9b4460ad85d9e09f14a959ed47bd2812edb5",
        "filename": "src/leveldb/doc/table_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 104,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a/src/leveldb/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.txt?ref=1b708f2cf3e6e6a17c5b6dbf2909a2ed2e35755a",
        "patch": "@@ -1,104 +0,0 @@\n-File format\n-===========\n-\n-  <beginning_of_file>\n-  [data block 1]\n-  [data block 2]\n-  ...\n-  [data block N]\n-  [meta block 1]\n-  ...\n-  [meta block K]\n-  [metaindex block]\n-  [index block]\n-  [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n-  <end_of_file>\n-\n-The file contains internal pointers.  Each such pointer is called\n-a BlockHandle and contains the following information:\n-  offset:\t    varint64\n-  size:\t\t    varint64\n-See https://developers.google.com/protocol-buffers/docs/encoding#varints\n-for an explanation of varint64 format.\n-\n-(1) The sequence of key/value pairs in the file are stored in sorted\n-order and partitioned into a sequence of data blocks.  These blocks\n-come one after another at the beginning of the file.  Each data block\n-is formatted according to the code in block_builder.cc, and then\n-optionally compressed.\n-\n-(2) After the data blocks we store a bunch of meta blocks.  The\n-supported meta block types are described below.  More meta block types\n-may be added in the future.  Each meta block is again formatted using\n-block_builder.cc and then optionally compressed.\n-\n-(3) A \"metaindex\" block.  It contains one entry for every other meta\n-block where the key is the name of the meta block and the value is a\n-BlockHandle pointing to that meta block.\n-\n-(4) An \"index\" block.  This block contains one entry per data block,\n-where the key is a string >= last key in that data block and before\n-the first key in the successive data block.  The value is the\n-BlockHandle for the data block.\n-\n-(6) At the very end of the file is a fixed length footer that contains\n-the BlockHandle of the metaindex and index blocks as well as a magic number.\n-       metaindex_handle: char[p];    // Block handle for metaindex\n-       index_handle:     char[q];    // Block handle for index\n-       padding:          char[40-p-q]; // zeroed bytes to make fixed length\n-                                       // (40==2*BlockHandle::kMaxEncodedLength)\n-       magic:            fixed64;    // == 0xdb4775248b80fb57 (little-endian)\n-\n-\"filter\" Meta Block\n--------------------\n-\n-If a \"FilterPolicy\" was specified when the database was opened, a\n-filter block is stored in each table.  The \"metaindex\" block contains\n-an entry that maps from \"filter.<N>\" to the BlockHandle for the filter\n-block where \"<N>\" is the string returned by the filter policy's\n-\"Name()\" method.\n-\n-The filter block stores a sequence of filters, where filter i contains\n-the output of FilterPolicy::CreateFilter() on all keys that are stored\n-in a block whose file offset falls within the range\n-\n-    [ i*base ... (i+1)*base-1 ]\n-\n-Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n-the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be\n-converted to a filter by calling FilterPolicy::CreateFilter(), and the\n-resulting filter will be stored as the first filter in the filter\n-block.\n-\n-The filter block is formatted as follows:\n-\n-     [filter 0]\n-     [filter 1]\n-     [filter 2]\n-     ...\n-     [filter N-1]\n-\n-     [offset of filter 0]                  : 4 bytes\n-     [offset of filter 1]                  : 4 bytes\n-     [offset of filter 2]                  : 4 bytes\n-     ...\n-     [offset of filter N-1]                : 4 bytes\n-\n-     [offset of beginning of offset array] : 4 bytes\n-     lg(base)                              : 1 byte\n-\n-The offset array at the end of the filter block allows efficient\n-mapping from a data block offset to the corresponding filter.\n-\n-\"stats\" Meta Block\n-------------------\n-\n-This meta block contains a bunch of stats.  The key is the name\n-of the statistic.  The value contains the statistic.\n-TODO(postrelease): record following stats.\n-  data size\n-  index size\n-  key size (uncompressed)\n-  value size (uncompressed)\n-  number of entries\n-  number of data blocks"
      },
      {
        "sha": "bfab10a0b725be9ed218783ee8fc98110fa77988",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 19;\n+static const int kMinorVersion = 20;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "976e38122aafa88acba169b3fc3506c013a75b61",
        "filename": "src/leveldb/include/leveldb/options.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/include/leveldb/options.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/include/leveldb/options.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/options.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -112,6 +112,18 @@ struct Options {\n   // Default: 16\n   int block_restart_interval;\n \n+  // Leveldb will write up to this amount of bytes to a file before\n+  // switching to a new one.\n+  // Most clients should leave this parameter alone.  However if your\n+  // filesystem is more efficient with larger files, you could\n+  // consider increasing the value.  The downside will be longer\n+  // compactions and hence longer latency/performance hiccups.\n+  // Another reason to increase this parameter might be when you are\n+  // initially populating a large database.\n+  //\n+  // Default: 2MB\n+  size_t max_file_size;\n+\n   // Compress blocks using the specified compression algorithm.  This\n   // parameter can be changed dynamically.\n   //"
      },
      {
        "sha": "97bd669a5ed6cd319c6b12bdd43bd43f8bab1548",
        "filename": "src/leveldb/port/port_example.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_example.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_example.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_example.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -129,6 +129,12 @@ extern bool Snappy_Uncompress(const char* input_data, size_t input_length,\n // The concatenation of all \"data[0,n-1]\" fragments is the heap profile.\n extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);\n \n+// Extend the CRC to include the first n bytes of buf.\n+//\n+// Returns zero if the CRC cannot be extended using acceleration, else returns\n+// the newly extended CRC value (which may also be zero).\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }  // namespace port\n }  // namespace leveldb\n "
      },
      {
        "sha": "7e8213b22ecaf216067040a818d4cdb786d8ca98",
        "filename": "src/leveldb/port/port_posix.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -152,6 +152,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n } // namespace port\n } // namespace leveldb\n "
      },
      {
        "sha": "1e519ba0b64befe92b0a6ca70f290f699151baab",
        "filename": "src/leveldb/port/port_posix_sse.cc",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_posix_sse.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_posix_sse.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix_sse.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2016 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A portable implementation of crc32c, optimized to handle\n+// four bytes at a time.\n+//\n+// In a separate source file to allow this accelerated CRC32C function to be\n+// compiled with the appropriate compiler flags to enable x86 SSE 4.2\n+// instructions.\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"port/port.h\"\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+#if defined(_MSC_VER)\n+#include <intrin.h>\n+#elif defined(__GNUC__) && defined(__SSE4_2__)\n+#include <nmmintrin.h>\n+#include <cpuid.h>\n+#endif\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+namespace leveldb {\n+namespace port {\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// Used to fetch a naturally-aligned 32-bit word in little endian byte-order\n+static inline uint32_t LE_LOAD32(const uint8_t *p) {\n+  // SSE is x86 only, so ensured that |p| is always little-endian.\n+  uint32_t word;\n+  memcpy(&word, p, sizeof(word));\n+  return word;\n+}\n+\n+#if defined(_M_X64) || defined(__x86_64__)  // LE_LOAD64 is only used on x64.\n+\n+// Used to fetch a naturally-aligned 64-bit word in little endian byte-order\n+static inline uint64_t LE_LOAD64(const uint8_t *p) {\n+  uint64_t dword;\n+  memcpy(&dword, p, sizeof(dword));\n+  return dword;\n+}\n+\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+\n+static inline bool HaveSSE42() {\n+#if defined(_MSC_VER)\n+  int cpu_info[4];\n+  __cpuid(cpu_info, 1);\n+  return (cpu_info[2] & (1 << 20)) != 0;\n+#elif defined(__GNUC__)\n+  unsigned int eax, ebx, ecx, edx;\n+  __get_cpuid(1, &eax, &ebx, &ecx, &edx);\n+  return (ecx & (1 << 20)) != 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// For further improvements see Intel publication at:\n+// http://download.intel.com/design/intarch/papers/323405.pdf\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {\n+#if !defined(LEVELDB_PLATFORM_POSIX_SSE)\n+  return 0;\n+#else\n+  static bool have = HaveSSE42();\n+  if (!have) {\n+    return 0;\n+  }\n+\n+  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n+  const uint8_t *e = p + size;\n+  uint32_t l = crc ^ 0xffffffffu;\n+\n+#define STEP1 do {                              \\\n+    l = _mm_crc32_u8(l, *p++);                  \\\n+} while (0)\n+#define STEP4 do {                              \\\n+    l = _mm_crc32_u32(l, LE_LOAD32(p));         \\\n+    p += 4;                                     \\\n+} while (0)\n+#define STEP8 do {                              \\\n+    l = _mm_crc32_u64(l, LE_LOAD64(p));         \\\n+    p += 8;                                     \\\n+} while (0)\n+\n+  if (size > 16) {\n+    // Process unaligned bytes\n+    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {\n+      STEP1;\n+    }\n+\n+    // _mm_crc32_u64 is only available on x64.\n+#if defined(_M_X64) || defined(__x86_64__)\n+    // Process 8 bytes at a time\n+    while ((e-p) >= 8) {\n+      STEP8;\n+    }\n+    // Process 4 bytes at a time\n+    if ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#else  // !(defined(_M_X64) || defined(__x86_64__))\n+    // Process 4 bytes at a time\n+    while ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+  }\n+  // Process the last few bytes\n+  while (p != e) {\n+    STEP1;\n+  }\n+#undef STEP8\n+#undef STEP4\n+#undef STEP1\n+  return l ^ 0xffffffffu;\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+}\n+\n+}  // namespace port\n+}  // namespace leveldb"
      },
      {
        "sha": "50090048228389c0595e44a2e0e2c274b3799245",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -168,6 +168,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }\n }\n "
      },
      {
        "sha": "1ed5134170e54c430d8a0318e95ece23235ae1ba",
        "filename": "src/leveldb/table/filter_block.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/table/filter_block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/table/filter_block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -9,7 +9,7 @@\n \n namespace leveldb {\n \n-// See doc/table_format.txt for an explanation of the filter block format.\n+// See doc/table_format.md for an explanation of the filter block format.\n \n // Generate new filter every 2KB of data\n static const size_t kFilterBaseLg = 11;"
      },
      {
        "sha": "edd61cfd6fca832ff6e53f50700899fe1196c2ad",
        "filename": "src/leveldb/util/crc32c.cc",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/crc32c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/crc32c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -8,6 +8,8 @@\n #include \"util/crc32c.h\"\n \n #include <stdint.h>\n+\n+#include \"port/port.h\"\n #include \"util/coding.h\"\n \n namespace leveldb {\n@@ -283,7 +285,23 @@ static inline uint32_t LE_LOAD32(const uint8_t *p) {\n   return DecodeFixed32(reinterpret_cast<const char*>(p));\n }\n \n+// Determine if the CPU running this program can accelerate the CRC32C\n+// calculation.\n+static bool CanAccelerateCRC32C() {\n+  // port::AcceleretedCRC32C returns zero when unable to accelerate.\n+  static const char kTestCRCBuffer[] = \"TestCRCBuffer\";\n+  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;\n+  static const uint32_t kTestCRCValue = 0xdcbc59fa;\n+\n+  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;\n+}\n+\n uint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n+  static bool accelerate = CanAccelerateCRC32C();\n+  if (accelerate) {\n+    return port::AcceleratedCRC32C(crc, buf, size);\n+  }\n+\n   const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n   const uint8_t *e = p + size;\n   uint32_t l = crc ^ 0xffffffffu;"
      },
      {
        "sha": "dd852af354c83d7d4839fa1e2a3b55824b4ae43c",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 136,
        "deletions": 59,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -11,28 +11,85 @@\n #include <stdlib.h>\n #include <string.h>\n #include <sys/mman.h>\n+#include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <time.h>\n #include <unistd.h>\n #include <deque>\n+#include <limits>\n #include <set>\n #include \"leveldb/env.h\"\n #include \"leveldb/slice.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n #include \"util/posix_logger.h\"\n+#include \"util/env_posix_test_helper.h\"\n \n namespace leveldb {\n \n namespace {\n \n+static int open_read_only_file_limit = -1;\n+static int mmap_limit = -1;\n+\n static Status IOError(const std::string& context, int err_number) {\n   return Status::IOError(context, strerror(err_number));\n }\n \n+// Helper class to limit resource usage to avoid exhaustion.\n+// Currently used to limit read-only file descriptors and mmap file usage\n+// so that we do not end up running out of file descriptors, virtual memory,\n+// or running into kernel performance problems for very large databases.\n+class Limiter {\n+ public:\n+  // Limit maximum number of resources to |n|.\n+  Limiter(intptr_t n) {\n+    SetAllowed(n);\n+  }\n+\n+  // If another resource is available, acquire it and return true.\n+  // Else return false.\n+  bool Acquire() {\n+    if (GetAllowed() <= 0) {\n+      return false;\n+    }\n+    MutexLock l(&mu_);\n+    intptr_t x = GetAllowed();\n+    if (x <= 0) {\n+      return false;\n+    } else {\n+      SetAllowed(x - 1);\n+      return true;\n+    }\n+  }\n+\n+  // Release a resource acquired by a previous call to Acquire() that returned\n+  // true.\n+  void Release() {\n+    MutexLock l(&mu_);\n+    SetAllowed(GetAllowed() + 1);\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  port::AtomicPointer allowed_;\n+\n+  intptr_t GetAllowed() const {\n+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n+  }\n+\n+  // REQUIRES: mu_ must be held\n+  void SetAllowed(intptr_t v) {\n+    allowed_.Release_Store(reinterpret_cast<void*>(v));\n+  }\n+\n+  Limiter(const Limiter&);\n+  void operator=(const Limiter&);\n+};\n+\n class PosixSequentialFile: public SequentialFile {\n  private:\n   std::string filename_;\n@@ -70,73 +127,51 @@ class PosixSequentialFile: public SequentialFile {\n class PosixRandomAccessFile: public RandomAccessFile {\n  private:\n   std::string filename_;\n+  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.\n   int fd_;\n+  Limiter* limiter_;\n \n  public:\n-  PosixRandomAccessFile(const std::string& fname, int fd)\n-      : filename_(fname), fd_(fd) { }\n-  virtual ~PosixRandomAccessFile() { close(fd_); }\n+  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)\n+      : filename_(fname), fd_(fd), limiter_(limiter) {\n+    temporary_fd_ = !limiter->Acquire();\n+    if (temporary_fd_) {\n+      // Open file on every access.\n+      close(fd_);\n+      fd_ = -1;\n+    }\n+  }\n+\n+  virtual ~PosixRandomAccessFile() {\n+    if (!temporary_fd_) {\n+      close(fd_);\n+      limiter_->Release();\n+    }\n+  }\n \n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n+    int fd = fd_;\n+    if (temporary_fd_) {\n+      fd = open(filename_.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        return IOError(filename_, errno);\n+      }\n+    }\n+\n     Status s;\n-    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n+    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));\n     *result = Slice(scratch, (r < 0) ? 0 : r);\n     if (r < 0) {\n       // An error: return a non-ok status\n       s = IOError(filename_, errno);\n     }\n-    return s;\n-  }\n-};\n-\n-// Helper class to limit mmap file usage so that we do not end up\n-// running out virtual memory or running into kernel performance\n-// problems for very large databases.\n-class MmapLimiter {\n- public:\n-  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n-  MmapLimiter() {\n-    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);\n-  }\n-\n-  // If another mmap slot is available, acquire it and return true.\n-  // Else return false.\n-  bool Acquire() {\n-    if (GetAllowed() <= 0) {\n-      return false;\n-    }\n-    MutexLock l(&mu_);\n-    intptr_t x = GetAllowed();\n-    if (x <= 0) {\n-      return false;\n-    } else {\n-      SetAllowed(x - 1);\n-      return true;\n+    if (temporary_fd_) {\n+      // Close the temporary file descriptor opened earlier.\n+      close(fd);\n     }\n+    return s;\n   }\n-\n-  // Release a slot acquired by a previous call to Acquire() that returned true.\n-  void Release() {\n-    MutexLock l(&mu_);\n-    SetAllowed(GetAllowed() + 1);\n-  }\n-\n- private:\n-  port::Mutex mu_;\n-  port::AtomicPointer allowed_;\n-\n-  intptr_t GetAllowed() const {\n-    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n-  }\n-\n-  // REQUIRES: mu_ must be held\n-  void SetAllowed(intptr_t v) {\n-    allowed_.Release_Store(reinterpret_cast<void*>(v));\n-  }\n-\n-  MmapLimiter(const MmapLimiter&);\n-  void operator=(const MmapLimiter&);\n };\n \n // mmap() based random-access\n@@ -145,12 +180,12 @@ class PosixMmapReadableFile: public RandomAccessFile {\n   std::string filename_;\n   void* mmapped_region_;\n   size_t length_;\n-  MmapLimiter* limiter_;\n+  Limiter* limiter_;\n \n  public:\n   // base[0,length-1] contains the mmapped contents of the file.\n   PosixMmapReadableFile(const std::string& fname, void* base, size_t length,\n-                        MmapLimiter* limiter)\n+                        Limiter* limiter)\n       : filename_(fname), mmapped_region_(base), length_(length),\n         limiter_(limiter) {\n   }\n@@ -231,7 +266,7 @@ class PosixWritableFile : public WritableFile {\n       if (fd < 0) {\n         s = IOError(dir, errno);\n       } else {\n-        if (fsync(fd) < 0) {\n+        if (fsync(fd) < 0 && errno != EINVAL) {\n           s = IOError(dir, errno);\n         }\n         close(fd);\n@@ -333,7 +368,7 @@ class PosixEnv : public Env {\n         mmap_limit_.Release();\n       }\n     } else {\n-      *result = new PosixRandomAccessFile(fname, fd);\n+      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);\n     }\n     return s;\n   }\n@@ -533,10 +568,42 @@ class PosixEnv : public Env {\n   BGQueue queue_;\n \n   PosixLockTable locks_;\n-  MmapLimiter mmap_limit_;\n+  Limiter mmap_limit_;\n+  Limiter fd_limit_;\n };\n \n-PosixEnv::PosixEnv() : started_bgthread_(false) {\n+// Return the maximum number of concurrent mmaps.\n+static int MaxMmaps() {\n+  if (mmap_limit >= 0) {\n+    return mmap_limit;\n+  }\n+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n+  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;\n+  return mmap_limit;\n+}\n+\n+// Return the maximum number of read-only files to keep open.\n+static intptr_t MaxOpenFiles() {\n+  if (open_read_only_file_limit >= 0) {\n+    return open_read_only_file_limit;\n+  }\n+  struct rlimit rlim;\n+  if (getrlimit(RLIMIT_NOFILE, &rlim)) {\n+    // getrlimit failed, fallback to hard-coded default.\n+    open_read_only_file_limit = 50;\n+  } else if (rlim.rlim_cur == RLIM_INFINITY) {\n+    open_read_only_file_limit = std::numeric_limits<int>::max();\n+  } else {\n+    // Allow use of 20% of available file descriptors for read-only files.\n+    open_read_only_file_limit = rlim.rlim_cur / 5;\n+  }\n+  return open_read_only_file_limit;\n+}\n+\n+PosixEnv::PosixEnv()\n+    : started_bgthread_(false),\n+      mmap_limit_(MaxMmaps()),\n+      fd_limit_(MaxOpenFiles()) {\n   PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, NULL));\n   PthreadCall(\"cvar_init\", pthread_cond_init(&bgsignal_, NULL));\n }\n@@ -611,6 +678,16 @@ static pthread_once_t once = PTHREAD_ONCE_INIT;\n static Env* default_env;\n static void InitDefaultEnv() { default_env = new PosixEnv; }\n \n+void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {\n+  assert(default_env == NULL);\n+  open_read_only_file_limit = limit;\n+}\n+\n+void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {\n+  assert(default_env == NULL);\n+  mmap_limit = limit;\n+}\n+\n Env* Env::Default() {\n   pthread_once(&once, InitDefaultEnv);\n   return default_env;"
      },
      {
        "sha": "295f8ae4409f2a156c4e298cce4d6c8311e1e1b1",
        "filename": "src/leveldb/util/env_posix_test.cc",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/env.h\"\n+\n+#include \"port/port.h\"\n+#include \"util/testharness.h\"\n+#include \"util/env_posix_test_helper.h\"\n+\n+namespace leveldb {\n+\n+static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n+\n+class EnvPosixTest {\n+ public:\n+  Env* env_;\n+  EnvPosixTest() : env_(Env::Default()) { }\n+\n+  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {\n+    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);\n+    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);\n+  }\n+};\n+\n+TEST(EnvPosixTest, TestOpenOnRead) {\n+  // Write some test data to a single file that will be opened |n| times.\n+  std::string test_dir;\n+  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n+  std::string test_file = test_dir + \"/open_on_read.txt\";\n+\n+  FILE* f = fopen(test_file.c_str(), \"w\");\n+  ASSERT_TRUE(f != NULL);\n+  const char kFileData[] = \"abcdefghijklmnopqrstuvwxyz\";\n+  fputs(kFileData, f);\n+  fclose(f);\n+\n+  // Open test file some number above the sum of the two limits to force\n+  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.\n+  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;\n+  leveldb::RandomAccessFile* files[kNumFiles] = {0};\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));\n+  }\n+  char scratch;\n+  Slice read_result;\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));\n+    ASSERT_EQ(kFileData[i], read_result[0]);\n+  }\n+  for (int i = 0; i < kNumFiles; i++) {\n+    delete files[i];\n+  }\n+  ASSERT_OK(env_->DeleteFile(test_file));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  // All tests currently run with the same read-only file limits.\n+  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,\n+                                       leveldb::kMMapLimit);\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "038696059826042f57808b58505c7f4339c54337",
        "filename": "src/leveldb/util/env_posix_test_helper.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix_test_helper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_posix_test_helper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test_helper.h?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+#define STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+\n+namespace leveldb {\n+\n+class EnvPosixTest;\n+\n+// A helper for the POSIX Env to facilitate testing.\n+class EnvPosixTestHelper {\n+ private:\n+  friend class EnvPosixTest;\n+\n+  // Set the maximum number of read-only files that will be opened.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyFDLimit(int limit);\n+\n+  // Set the maximum number of read-only files that will be mapped via mmap.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyMMapLimit(int limit);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_"
      },
      {
        "sha": "839ae56a1a49c1b4d60562eca2707d2053ab1236",
        "filename": "src/leveldb/util/env_test.cc",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_test.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -10,29 +10,31 @@\n namespace leveldb {\n \n static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n \n-class EnvPosixTest {\n+class EnvTest {\n  private:\n   port::Mutex mu_;\n   std::string events_;\n \n  public:\n   Env* env_;\n-  EnvPosixTest() : env_(Env::Default()) { }\n+  EnvTest() : env_(Env::Default()) { }\n };\n \n static void SetBool(void* ptr) {\n   reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);\n }\n \n-TEST(EnvPosixTest, RunImmediately) {\n+TEST(EnvTest, RunImmediately) {\n   port::AtomicPointer called (NULL);\n   env_->Schedule(&SetBool, &called);\n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   ASSERT_TRUE(called.NoBarrier_Load() != NULL);\n }\n \n-TEST(EnvPosixTest, RunMany) {\n+TEST(EnvTest, RunMany) {\n   port::AtomicPointer last_id (NULL);\n \n   struct CB {\n@@ -59,7 +61,7 @@ TEST(EnvPosixTest, RunMany) {\n   env_->Schedule(&CB::Run, &cb3);\n   env_->Schedule(&CB::Run, &cb4);\n \n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   void* cur = last_id.Acquire_Load();\n   ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));\n }\n@@ -78,7 +80,7 @@ static void ThreadBody(void* arg) {\n   s->mu.Unlock();\n }\n \n-TEST(EnvPosixTest, StartThread) {\n+TEST(EnvTest, StartThread) {\n   State state;\n   state.val = 0;\n   state.num_running = 3;\n@@ -92,7 +94,7 @@ TEST(EnvPosixTest, StartThread) {\n     if (num == 0) {\n       break;\n     }\n-    Env::Default()->SleepForMicroseconds(kDelayMicros);\n+    env_->SleepForMicroseconds(kDelayMicros);\n   }\n   ASSERT_EQ(state.val, 3);\n }"
      },
      {
        "sha": "d32c4e676c3fcd6dd29394298f541832032ef1a7",
        "filename": "src/leveldb/util/env_win.cc",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_win.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -1,7 +1,7 @@\n // This file contains source that originates from:\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n-// Those files dont' have any explict license headers but the \n+// Those files don't have any explicit license headers but the \n // project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n // as the license.\n #if defined(LEVELDB_PLATFORM_WINDOWS)\n@@ -355,11 +355,13 @@ BOOL Win32SequentialFile::_Init()\n \tToWidePath(_filename, path);\n \t_hFile = CreateFileW(path.c_str(),\n                          GENERIC_READ,\n-                         FILE_SHARE_READ,\n+                         FILE_SHARE_READ | FILE_SHARE_WRITE,\n                          NULL,\n                          OPEN_EXISTING,\n-                         FILE_ATTRIBUTE_NORMAL,\n+                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n                          NULL);\n+    if (_hFile == INVALID_HANDLE_VALUE)\n+        _hFile = NULL;\n     return _hFile ? TRUE : FALSE;\n }\n \n@@ -403,7 +405,7 @@ BOOL Win32RandomAccessFile::_Init( LPCWSTR path )\n {\n     BOOL bRet = FALSE;\n     if(!_hFile)\n-        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,\n+        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,\n         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);\n     if(!_hFile || _hFile == INVALID_HANDLE_VALUE )\n         _hFile = NULL;\n@@ -669,7 +671,7 @@ Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n \tToWidePath(ModifyPath(path), wpath);\n \n     HANDLE file = ::CreateFileW(wpath.c_str(),\n-        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n+        GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n     LARGE_INTEGER li;\n     if(::GetFileSizeEx(file,&li)){\n         *file_size = (uint64_t)li.QuadPart;"
      },
      {
        "sha": "b5e622761357cfa3efb72d01facfd33339d4ce8e",
        "filename": "src/leveldb/util/options.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/options.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4030ab4f47065c362901109c74ca8e791c2de0a/src/leveldb/util/options.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/options.cc?ref=e4030ab4f47065c362901109c74ca8e791c2de0a",
        "patch": "@@ -21,6 +21,7 @@ Options::Options()\n       block_cache(NULL),\n       block_size(4096),\n       block_restart_interval(16),\n+      max_file_size(2<<20),\n       compression(kSnappyCompression),\n       reuse_logs(false),\n       filter_policy(NULL) {"
      }
    ]
  },
  {
    "sha": "2424989e4f681a71273c0cc729e38eef30452456",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDI0OTg5ZTRmNjgxYTcxMjczYzBjYzcyOWUzOGVlZjMwNDUyNDU2",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-04-13T17:09:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:25:36Z"
      },
      "message": "leveldb: enable runtime-detected crc32 instructions",
      "tree": {
        "sha": "91610ae6228b9b0f57f1db5a354328d77d29754a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91610ae6228b9b0f57f1db5a354328d77d29754a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2424989e4f681a71273c0cc729e38eef30452456",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2424989e4f681a71273c0cc729e38eef30452456",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2424989e4f681a71273c0cc729e38eef30452456",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2424989e4f681a71273c0cc729e38eef30452456/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e4030ab4f47065c362901109c74ca8e791c2de0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4030ab4f47065c362901109c74ca8e791c2de0a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e4030ab4f47065c362901109c74ca8e791c2de0a"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 25,
      "deletions": 4
    },
    "files": [
      {
        "sha": "31074d77202f120d54f0a7c86c660d70de8fd4ec",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -236,6 +236,12 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[CXXFLAGS=\"$CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n+\n+  # Check for optional instruction set support. Enabling these does _not_ imply that all code will\n+  # be compiled with them, rather that specific objects/libs may use them after checking for runtime\n+  # compatibility.\n+  AX_CHECK_COMPILE_FLAG([-msse4.2],[[enable_sse42=yes; SSE42_CXXFLAGS=\"-msse4.2\"]],,[[$CXXFLAG_WERROR]])\n+\n fi\n CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n@@ -1114,6 +1120,7 @@ AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n+AM_CONDITIONAL([ENABLE_SSE42],[test x$enable_sse42 = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1146,6 +1153,7 @@ AC_SUBST(HARDENED_CPPFLAGS)\n AC_SUBST(HARDENED_LDFLAGS)\n AC_SUBST(PIC_FLAGS)\n AC_SUBST(PIE_FLAGS)\n+AC_SUBST(SSE42_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n AC_SUBST(USE_QRCODE)"
      },
      {
        "sha": "a8b018a65b6e82a7951ecc913541ed5ba70d259d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -380,6 +380,7 @@ bitcoind_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n "
      },
      {
        "sha": "2b1f70b25bc4588d26470216dc9c07d0b4b5c676",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -39,6 +39,7 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE)"
      },
      {
        "sha": "b61088ef3a6ef6340a391419874339530ab37fc5",
        "filename": "src/Makefile.leveldb.include",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.leveldb.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.leveldb.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.leveldb.include?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -4,12 +4,15 @@\n \n LIBLEVELDB_INT = leveldb/libleveldb.a\n LIBMEMENV_INT  = leveldb/libmemenv.a\n+LIBLEVELDB_SSE42_INT  = leveldb/libleveldb_sse42.a\n \n EXTRA_LIBRARIES += $(LIBLEVELDB_INT)\n EXTRA_LIBRARIES += $(LIBMEMENV_INT)\n+EXTRA_LIBRARIES += $(LIBLEVELDB_SSE42_INT)\n \n LIBLEVELDB += $(LIBLEVELDB_INT)\n LIBMEMENV += $(LIBMEMENV_INT)\n+LIBLEVELDB_SSE42 = $(LIBLEVELDB_SSE42_INT)\n \n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include\n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/helpers/memenv\n@@ -135,3 +138,11 @@ leveldb_libmemenv_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n leveldb_libmemenv_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n leveldb_libmemenv_a_SOURCES =  leveldb/helpers/memenv/memenv.cc\n leveldb_libmemenv_a_SOURCES += leveldb/helpers/memenv/memenv.h\n+\n+leveldb_libleveldb_sse42_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n+leveldb_libleveldb_sse42_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n+if ENABLE_SSE42\n+leveldb_libleveldb_sse42_a_CPPFLAGS += -DLEVELDB_PLATFORM_POSIX_SSE\n+leveldb_libleveldb_sse42_a_CXXFLAGS += $(SSE42_CXXFLAGS)\n+endif\n+leveldb_libleveldb_sse42_a_SOURCES =  leveldb/port/port_posix_sse.cc"
      },
      {
        "sha": "e4b64c1ca79c3e6ab98e9c5d3662b9c3f9a315bb",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -407,7 +407,7 @@ endif\n if ENABLE_ZMQ\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "02f30bc9527b10ade4e91c36a1da2141539908a6",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -60,7 +60,7 @@ if ENABLE_ZMQ\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n-  $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n+  $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "cc255563f19ab3a2dd0304978f80d003016af83f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2424989e4f681a71273c0cc729e38eef30452456/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=2424989e4f681a71273c0cc729e38eef30452456",
        "patch": "@@ -97,8 +97,8 @@ endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n-test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n+test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n+  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)"
      }
    ]
  },
  {
    "sha": "3ee3d04374894ad56ac00b654aef70d70fe6466e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZWUzZDA0Mzc0ODk0YWQ1NmFjMDBiNjU0YWVmNzBkNzBmZTY0NjZl",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-06-09T20:20:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-10T02:25:36Z"
      },
      "message": "Add extra LevelDB source to Makefile",
      "tree": {
        "sha": "ad062c10da836ea70738ec0d732da86a12a32588",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad062c10da836ea70738ec0d732da86a12a32588"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ee3d04374894ad56ac00b654aef70d70fe6466e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ee3d04374894ad56ac00b654aef70d70fe6466e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3ee3d04374894ad56ac00b654aef70d70fe6466e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ee3d04374894ad56ac00b654aef70d70fe6466e/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2424989e4f681a71273c0cc729e38eef30452456",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2424989e4f681a71273c0cc729e38eef30452456",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2424989e4f681a71273c0cc729e38eef30452456"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ac38141f43d747b26e4a77fae86d32be5cda0836",
        "filename": "src/Makefile.leveldb.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ee3d04374894ad56ac00b654aef70d70fe6466e/src/Makefile.leveldb.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ee3d04374894ad56ac00b654aef70d70fe6466e/src/Makefile.leveldb.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.leveldb.include?ref=3ee3d04374894ad56ac00b654aef70d70fe6466e",
        "patch": "@@ -77,6 +77,7 @@ leveldb_libleveldb_a_SOURCES += leveldb/table/merger.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/format.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/iterator_wrapper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/crc32c.h\n+leveldb_libleveldb_a_SOURCES += leveldb/util/env_posix_test_helper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/arena.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/random.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/posix_logger.h"
      }
    ]
  }
]