[
  {
    "sha": "4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzZkNDFiOGI2NTNlZjkwNjM5YjFhMzJmNmFhYjBiYjFjZWY5MGM1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-10-10T21:07:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-10-11T21:25:50Z"
      },
      "message": "Refactor/encapsulate chain globals into a CChain class",
      "tree": {
        "sha": "3e29135e08fa64984cd47fdfeda42d55e7e51ad8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3e29135e08fa64984cd47fdfeda42d55e7e51ad8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c74b6c3d8fcc1750fa0861ae851b353a7f3495d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c74b6c3d8fcc1750fa0861ae851b353a7f3495d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c74b6c3d8fcc1750fa0861ae851b353a7f3495d2"
      }
    ],
    "stats": {
      "total": 430,
      "additions": 217,
      "deletions": 213
    },
    "files": [
      {
        "sha": "dcd65198c3dc06b7222d4d65e7afb90f1e4c8665",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -116,7 +116,7 @@ void Shutdown()\n     {\n         LOCK(cs_main);\n         if (pwalletMain)\n-            pwalletMain->SetBestChain(CBlockLocator(pindexBest));\n+            pwalletMain->SetBestChain(CBlockLocator(chainActive.Tip()));\n         if (pblocktree)\n             pblocktree->Flush();\n         if (pcoinsTip)\n@@ -766,7 +766,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && pindexGenesisBlock == NULL)\n+                if (!mapBlockIndex.empty() && chainActive.Genesis() == NULL)\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n \n                 // Initialize the block index (no-op if non-empty database was already loaded)\n@@ -912,34 +912,34 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 strErrors << _(\"Cannot write default address\") << \"\\n\";\n         }\n \n-        pwalletMain->SetBestChain(CBlockLocator(pindexBest));\n+        pwalletMain->SetBestChain(CBlockLocator(chainActive.Tip()));\n     }\n \n     LogPrintf(\"%s\", strErrors.str().c_str());\n     LogPrintf(\" wallet      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n     RegisterWallet(pwalletMain);\n \n-    CBlockIndex *pindexRescan = pindexBest;\n+    CBlockIndex *pindexRescan = chainActive.Tip();\n     if (GetBoolArg(\"-rescan\", false))\n-        pindexRescan = pindexGenesisBlock;\n+        pindexRescan = chainActive.Genesis();\n     else\n     {\n         CWalletDB walletdb(strWalletFile);\n         CBlockLocator locator;\n         if (walletdb.ReadBestBlock(locator))\n             pindexRescan = locator.GetBlockIndex();\n         else\n-            pindexRescan = pindexGenesisBlock;\n+            pindexRescan = chainActive.Genesis();\n     }\n-    if (pindexBest && pindexBest != pindexRescan)\n+    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n     {\n         uiInterface.InitMessage(_(\"Rescanning...\"));\n-        LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n+        LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n         nStart = GetTimeMillis();\n         pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n         LogPrintf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n-        pwalletMain->SetBestChain(CBlockLocator(pindexBest));\n+        pwalletMain->SetBestChain(CBlockLocator(chainActive.Tip()));\n         nWalletDBUpdated++;\n     }\n \n@@ -985,7 +985,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     //// debug print\n     LogPrintf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n-    LogPrintf(\"nBestHeight = %d\\n\",                   nBestHeight);\n+    LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n     LogPrintf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n     LogPrintf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n     LogPrintf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);"
      },
      {
        "sha": "d0cf3f8eb237eb158c892ed9d56d84cf65768d86",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 96,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -32,13 +32,8 @@ CTxMemPool mempool;\n unsigned int nTransactionsUpdated = 0;\n \n map<uint256, CBlockIndex*> mapBlockIndex;\n-std::vector<CBlockIndex*> vBlockIndexByHeight;\n-CBlockIndex* pindexGenesisBlock = NULL;\n-int nBestHeight = -1;\n-uint256 nBestChainWork = 0;\n+CChain chainActive;\n uint256 nBestInvalidWork = 0;\n-uint256 hashBestChain = 0;\n-CBlockIndex* pindexBest = NULL;\n set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain all CBlockIndex*'s that have validness >=BLOCK_VALID_TRANSACTIONS, and must contain those who aren't failed\n int64 nTimeBestReceived = 0;\n int nScriptCheckThreads = 0;\n@@ -173,14 +168,22 @@ void static ResendWalletTransactions()\n // Registration of network node signals.\n //\n \n+int static GetHeight()\n+{\n+    LOCK(cs_main);\n+    return chainActive.Height();\n+}\n+\n void RegisterNodeSignals(CNodeSignals& nodeSignals)\n {\n+    nodeSignals.GetHeight.connect(&GetHeight);\n     nodeSignals.ProcessMessages.connect(&ProcessMessages);\n     nodeSignals.SendMessages.connect(&SendMessages);\n }\n \n void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n {\n+    nodeSignals.GetHeight.disconnect(&GetHeight);\n     nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n     nodeSignals.SendMessages.disconnect(&SendMessages);\n }\n@@ -225,7 +228,7 @@ int CBlockLocator::GetDistanceBack()\n         if (mi != mapBlockIndex.end())\n         {\n             CBlockIndex* pindex = (*mi).second;\n-            if (pindex->IsInMainChain())\n+            if (chainActive.Contains(pindex))\n                 return nDistance;\n         }\n         nDistance += nStep;\n@@ -244,11 +247,11 @@ CBlockIndex *CBlockLocator::GetBlockIndex()\n         if (mi != mapBlockIndex.end())\n         {\n             CBlockIndex* pindex = (*mi).second;\n-            if (pindex->IsInMainChain())\n+            if (chainActive.Contains(pindex))\n                 return pindex;\n         }\n     }\n-    return pindexGenesisBlock;\n+    return chainActive.Genesis();\n }\n \n uint256 CBlockLocator::GetBlockHash()\n@@ -260,7 +263,7 @@ uint256 CBlockLocator::GetBlockHash()\n         if (mi != mapBlockIndex.end())\n         {\n             CBlockIndex* pindex = (*mi).second;\n-            if (pindex->IsInMainChain())\n+            if (chainActive.Contains(pindex))\n                 return hash;\n         }\n     }\n@@ -275,6 +278,19 @@ int CBlockLocator::GetHeight()\n     return pindex->nHeight;\n }\n \n+CBlockIndex *CChain::SetTip(CBlockIndex *pindex) {\n+    if (pindex == NULL) {\n+        std::vector<CBlockIndex*>().swap(vChain);\n+        return NULL;\n+    }\n+    vChain.resize(pindex->nHeight + 1);\n+    while (pindex && vChain[pindex->nHeight] != pindex) {\n+        vChain[pindex->nHeight] = pindex;\n+        pindex = pindex->pprev;\n+    }\n+    return pindex;\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // CCoinsView implementations\n@@ -517,7 +533,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64 nBlockTime)\n     if (tx.nLockTime == 0)\n         return true;\n     if (nBlockHeight == 0)\n-        nBlockHeight = nBestHeight;\n+        nBlockHeight = chainActive.Height();\n     if (nBlockTime == 0)\n         nBlockTime = GetAdjustedTime();\n     if ((int64)tx.nLockTime < ((int64)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n@@ -644,7 +660,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n     if (pblock == NULL) {\n         CCoins coins;\n         if (pcoinsTip->GetCoins(GetHash(), coins)) {\n-            CBlockIndex *pindex = FindBlockByHeight(coins.nHeight);\n+            CBlockIndex *pindex = chainActive[coins.nHeight];\n             if (pindex) {\n                 if (!ReadBlockFromDisk(blockTmp, pindex))\n                     return 0;\n@@ -678,10 +694,10 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n     if (mi == mapBlockIndex.end())\n         return 0;\n     CBlockIndex* pindex = (*mi).second;\n-    if (!pindex || !pindex->IsInMainChain())\n+    if (!pindex || !chainActive.Contains(pindex))\n         return 0;\n \n-    return pindexBest->nHeight - pindex->nHeight + 1;\n+    return chainActive.Height() - pindex->nHeight + 1;\n }\n \n \n@@ -1078,7 +1094,7 @@ int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n     if (mi == mapBlockIndex.end())\n         return 0;\n     CBlockIndex* pindex = (*mi).second;\n-    if (!pindex || !pindex->IsInMainChain())\n+    if (!pindex || !chainActive.Contains(pindex))\n         return 0;\n \n     // Make sure the merkle branch connects to this block\n@@ -1090,7 +1106,7 @@ int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n     }\n \n     pindexRet = pindex;\n-    return pindexBest->nHeight - pindex->nHeight + 1;\n+    return chainActive.Height() - pindex->nHeight + 1;\n }\n \n \n@@ -1173,7 +1189,7 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n                     nHeight = coins.nHeight;\n             }\n             if (nHeight > 0)\n-                pindexSlow = FindBlockByHeight(nHeight);\n+                pindexSlow = chainActive[nHeight];\n         }\n     }\n \n@@ -1203,14 +1219,6 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n // CBlock and CBlockIndex\n //\n \n-static CBlockIndex* pblockindexFBBHLast;\n-CBlockIndex* FindBlockByHeight(int nHeight)\n-{\n-    if (nHeight >= (int)vBlockIndexByHeight.size())\n-        return NULL;\n-    return vBlockIndexByHeight[nHeight];\n-}\n-\n bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n {\n     // Open history file to append\n@@ -1404,17 +1412,17 @@ int GetNumBlocksOfPeers()\n \n bool IsInitialBlockDownload()\n {\n-    if (pindexBest == NULL || fImporting || fReindex || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n+    if (fImporting || fReindex || chainActive.Height() < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n     static int64 nLastUpdate;\n     static CBlockIndex* pindexLastBest;\n-    if (pindexBest != pindexLastBest)\n+    if (chainActive.Tip() != pindexLastBest)\n     {\n-        pindexLastBest = pindexBest;\n+        pindexLastBest = chainActive.Tip();\n         nLastUpdate = GetTime();\n     }\n     return (GetTime() - nLastUpdate < 10 &&\n-            pindexBest->GetBlockTime() < GetTime() - 24 * 60 * 60);\n+            chainActive.Tip()->GetBlockTime() < GetTime() - 24 * 60 * 60);\n }\n \n bool fLargeWorkForkFound = false;\n@@ -1430,10 +1438,10 @@ void CheckForkWarningConditions()\n \n     // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n     // of our head, drop it\n-    if (pindexBestForkTip && nBestHeight - pindexBestForkTip->nHeight >= 72)\n+    if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)\n         pindexBestForkTip = NULL;\n \n-    if (pindexBestForkTip || nBestInvalidWork > nBestChainWork + (pindexBest->GetBlockWork() * 6).getuint256())\n+    if (pindexBestForkTip || nBestInvalidWork > chainActive.Tip()->nChainWork + (chainActive.Tip()->GetBlockWork() * 6).getuint256())\n     {\n         if (!fLargeWorkForkFound)\n         {\n@@ -1470,7 +1478,7 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n {\n     // If we are on a fork that is sufficiently large, set a warning flag\n     CBlockIndex* pfork = pindexNewForkTip;\n-    CBlockIndex* plonger = pindexBest;\n+    CBlockIndex* plonger = chainActive.Tip();\n     while (pfork && pfork != plonger)\n     {\n         while (plonger && plonger->nHeight > pfork->nHeight)\n@@ -1489,7 +1497,7 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     // the 7-block condition and from this always have the most-likely-to-cause-warning fork\n     if (pfork && (!pindexBestForkTip || (pindexBestForkTip && pindexNewForkTip->nHeight > pindexBestForkTip->nHeight)) &&\n             pindexNewForkTip->nChainWork - pfork->nChainWork > (pfork->GetBlockWork() * 7).getuint256() &&\n-            nBestHeight - pindexNewForkTip->nHeight < 72)\n+            chainActive.Height() - pindexNewForkTip->nHeight < 72)\n     {\n         pindexBestForkTip = pindexNewForkTip;\n         pindexBestForkBase = pfork;\n@@ -1511,8 +1519,8 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n       log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n       pindexNew->GetBlockTime()).c_str());\n     LogPrintf(\"InvalidChainFound:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      hashBestChain.ToString().c_str(), nBestHeight, log(nBestChainWork.getdouble())/log(2.0),\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n+      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0),\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n     CheckForkWarningConditions();\n }\n \n@@ -1521,7 +1529,7 @@ void static InvalidBlockFound(CBlockIndex *pindex) {\n     pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n     setBlockIndexValid.erase(pindex);\n     InvalidChainFound(pindex);\n-    if (pindex->GetNextInMainChain()) {\n+    if (chainActive.Next(pindex)) {\n         CValidationState stateDummy;\n         ConnectBestBlock(stateDummy); // reorganise away from the failed block\n     }\n@@ -1538,7 +1546,7 @@ bool ConnectBestBlock(CValidationState &state) {\n             pindexNewBest = *it;\n         }\n \n-        if (pindexNewBest == pindexBest || (pindexBest && pindexNewBest->nChainWork == pindexBest->nChainWork))\n+        if (pindexNewBest == chainActive.Tip() || (chainActive.Tip() && pindexNewBest->nChainWork == chainActive.Tip()->nChainWork))\n             return true; // nothing to do\n \n         // check ancestry\n@@ -1558,10 +1566,10 @@ bool ConnectBestBlock(CValidationState &state) {\n                 break;\n             }\n \n-            if (pindexBest == NULL || pindexTest->nChainWork > pindexBest->nChainWork)\n+            if (chainActive.Tip() == NULL || pindexTest->nChainWork > chainActive.Tip()->nChainWork)\n                 vAttach.push_back(pindexTest);\n \n-            if (pindexTest->pprev == NULL || pindexTest->GetNextInMainChain()) {\n+            if (pindexTest->pprev == NULL || chainActive.Next(pindexTest)) {\n                 reverse(vAttach.begin(), vAttach.end());\n                 BOOST_FOREACH(CBlockIndex *pindexSwitch, vAttach) {\n                     boost::this_thread::interruption_point();\n@@ -1881,7 +1889,6 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     // (its coinbase is unspendable)\n     if (block.GetHash() == Params().HashGenesisBlock()) {\n         view.SetBestBlock(pindex);\n-        pindexGenesisBlock = pindex;\n         return true;\n     }\n \n@@ -2129,9 +2136,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     // Proceed by updating the memory structures.\n \n     // Register new best chain\n-    vBlockIndexByHeight.resize(pindexNew->nHeight + 1);\n-    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n-        vBlockIndexByHeight[pindex->nHeight] = pindex;\n+    chainActive.SetTip(pindexNew);\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect) {\n@@ -2157,23 +2162,18 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     }\n \n     // New best block\n-    hashBestChain = pindexNew->GetBlockHash();\n-    pindexBest = pindexNew;\n-    pblockindexFBBHLast = NULL;\n-    nBestHeight = pindexBest->nHeight;\n-    nBestChainWork = pindexNew->nChainWork;\n     nTimeBestReceived = GetTime();\n     nTransactionsUpdated++;\n     LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n-      hashBestChain.ToString().c_str(), nBestHeight, log(nBestChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str(),\n-      Checkpoints::GuessVerificationProgress(pindexBest));\n+      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str(),\n+      Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n \n     // Check the version of the last 100 blocks to see if we need to upgrade:\n     if (!fIsInitialDownload)\n     {\n         int nUpgraded = 0;\n-        const CBlockIndex* pindex = pindexBest;\n+        const CBlockIndex* pindex = chainActive.Tip();\n         for (int i = 0; i < 100 && pindex != NULL; i++)\n         {\n             if (pindex->nVersion > CBlock::CURRENT_VERSION)\n@@ -2191,7 +2191,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n \n     if (!fIsInitialDownload && !strCmd.empty())\n     {\n-        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n+        boost::replace_all(strCmd, \"%s\", chainActive.Tip()->GetBlockHash().GetHex());\n         boost::thread t(runCommand, strCmd); // thread runs free\n     }\n \n@@ -2233,7 +2233,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     if (!ConnectBestBlock(state))\n         return false;\n \n-    if (pindexNew == pindexBest)\n+    if (pindexNew == chainActive.Tip())\n     {\n         // Clear fork warning if its no longer applicable\n         CheckForkWarningConditions();\n@@ -2482,11 +2482,11 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n \n     // Relay inventory, but don't relay old inventory during initial block download\n     int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n+    if (chainActive.Tip()->GetBlockHash() == hash)\n     {\n         LOCK(cs_vNodes);\n         BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n+            if (chainActive.Height() > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                 pnode->PushInventory(CInv(MSG_BLOCK, hash));\n     }\n \n@@ -2505,6 +2505,18 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n     return (nFound >= nRequired);\n }\n \n+int64 CBlockIndex::GetMedianTime() const\n+{\n+    const CBlockIndex* pindex = this;\n+    for (int i = 0; i < nMedianTimeSpan/2; i++)\n+    {\n+        if (!chainActive.Next(pindex))\n+            return GetBlockTime();\n+        pindex = chainActive.Next(pindex);\n+    }\n+    return pindex->GetMedianTimePast();\n+}\n+\n void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n {\n     // Filter out duplicate requests\n@@ -2530,7 +2542,7 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n         return error(\"ProcessBlock() : CheckBlock FAILED\");\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    if (pcheckpoint && pblock->hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n         int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n@@ -2561,7 +2573,7 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n             mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n \n             // Ask this guy to fill in what we're missing\n-            PushGetBlocks(pfrom, pindexBest, GetOrphanRoot(pblock2));\n+            PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(pblock2));\n         }\n         return true;\n     }\n@@ -2875,48 +2887,39 @@ bool static LoadBlockIndexDB()\n     LogPrintf(\"LoadBlockIndexDB(): transaction index %s\\n\", fTxIndex ? \"enabled\" : \"disabled\");\n \n     // Load hashBestChain pointer to end of best chain\n-    pindexBest = pcoinsTip->GetBestBlock();\n-    if (pindexBest == NULL)\n+    chainActive.SetTip(pcoinsTip->GetBestBlock());\n+    if (chainActive.Tip() == NULL)\n         return true;\n-    hashBestChain = pindexBest->GetBlockHash();\n-    nBestHeight = pindexBest->nHeight;\n-    nBestChainWork = pindexBest->nChainWork;\n \n     // register best chain\n-    CBlockIndex *pindex = pindexBest;\n-    vBlockIndexByHeight.resize(pindexBest->nHeight + 1);\n-    while(pindex != NULL) {\n-         vBlockIndexByHeight[pindex->nHeight] = pindex;\n-         pindex = pindex->pprev;\n-    }\n     LogPrintf(\"LoadBlockIndexDB(): hashBestChain=%s  height=%d date=%s\\n\",\n-        hashBestChain.ToString().c_str(), nBestHeight,\n-        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n+        chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(),\n+        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n \n     return true;\n }\n \n bool VerifyDB(int nCheckLevel, int nCheckDepth)\n {\n-    if (pindexBest == NULL || pindexBest->pprev == NULL)\n+    if (chainActive.Tip() == NULL || chainActive.Tip()->pprev == NULL)\n         return true;\n \n     // Verify blocks in the best chain\n     if (nCheckDepth <= 0)\n         nCheckDepth = 1000000000; // suffices until the year 19000\n-    if (nCheckDepth > nBestHeight)\n-        nCheckDepth = nBestHeight;\n+    if (nCheckDepth > chainActive.Height())\n+        nCheckDepth = chainActive.Height();\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n     CCoinsViewCache coins(*pcoinsTip, true);\n-    CBlockIndex* pindexState = pindexBest;\n+    CBlockIndex* pindexState = chainActive.Tip();\n     CBlockIndex* pindexFailure = NULL;\n     int nGoodTransactions = 0;\n     CValidationState state;\n-    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n+    for (CBlockIndex* pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         boost::this_thread::interruption_point();\n-        if (pindex->nHeight < nBestHeight-nCheckDepth)\n+        if (pindex->nHeight < chainActive.Height()-nCheckDepth)\n             break;\n         CBlock block;\n         // check level 0: read from disk\n@@ -2948,14 +2951,14 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n         }\n     }\n     if (pindexFailure)\n-        return error(\"VerifyDB() : *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", pindexBest->nHeight - pindexFailure->nHeight + 1, nGoodTransactions);\n+        return error(\"VerifyDB() : *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n \n     // check level 4: try reconnecting blocks\n     if (nCheckLevel >= 4) {\n         CBlockIndex *pindex = pindexState;\n-        while (pindex != pindexBest) {\n+        while (pindex != chainActive.Tip()) {\n             boost::this_thread::interruption_point();\n-            pindex = pindex->GetNextInMainChain();\n+            pindex = chainActive.Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex))\n                 return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n@@ -2964,7 +2967,7 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n         }\n     }\n \n-    LogPrintf(\"No coin database inconsistencies in last %i blocks (%i transactions)\\n\", pindexBest->nHeight - pindexState->nHeight, nGoodTransactions);\n+    LogPrintf(\"No coin database inconsistencies in last %i blocks (%i transactions)\\n\", chainActive.Height() - pindexState->nHeight, nGoodTransactions);\n \n     return true;\n }\n@@ -2973,12 +2976,8 @@ void UnloadBlockIndex()\n {\n     mapBlockIndex.clear();\n     setBlockIndexValid.clear();\n-    pindexGenesisBlock = NULL;\n-    nBestHeight = 0;\n-    nBestChainWork = 0;\n+    chainActive.SetTip(NULL);\n     nBestInvalidWork = 0;\n-    hashBestChain = 0;\n-    pindexBest = NULL;\n }\n \n bool LoadBlockIndex()\n@@ -2992,7 +2991,7 @@ bool LoadBlockIndex()\n \n bool InitBlockIndex() {\n     // Check whether we're already initialized\n-    if (pindexGenesisBlock != NULL)\n+    if (chainActive.Genesis() != NULL)\n         return true;\n \n     // Use the provided setting for -txindex in the new database\n@@ -3038,7 +3037,7 @@ void PrintBlockTree()\n     }\n \n     vector<pair<int, CBlockIndex*> > vStack;\n-    vStack.push_back(make_pair(0, pindexGenesisBlock));\n+    vStack.push_back(make_pair(0, chainActive.Genesis()));\n \n     int nPrevCol = 0;\n     while (!vStack.empty())\n@@ -3081,7 +3080,7 @@ void PrintBlockTree()\n         vector<CBlockIndex*>& vNext = mapNext[pindex];\n         for (unsigned int i = 0; i < vNext.size(); i++)\n         {\n-            if (vNext[i]->GetNextInMainChain())\n+            if (chainActive.Next(vNext[i]))\n             {\n                 swap(vNext[0], vNext[i]);\n                 break;\n@@ -3328,7 +3327,7 @@ void static ProcessGetData(CNode* pfrom)\n                         // and we want it right after the last block so they don't\n                         // wait for other stuff first.\n                         vector<CInv> vInv;\n-                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n+                        vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n                         pfrom->PushMessage(\"inv\", vInv);\n                         pfrom->hashContinue = 0;\n                     }\n@@ -3610,7 +3609,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 if (!fImporting && !fReindex)\n                     pfrom->AskFor(inv);\n             } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                PushGetBlocks(pfrom, pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n+                PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n             } else if (nInv == nLastBlock) {\n                 // In case we are on a very long side-chain, it is possible that we already have\n                 // the last block in an inv bundle sent in response to getblocks. Try to detect\n@@ -3658,10 +3657,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Send the rest of the chain\n         if (pindex)\n-            pindex = pindex->GetNextInMainChain();\n+            pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n         LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str(), nLimit);\n-        for (; pindex; pindex = pindex->GetNextInMainChain())\n+        for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n@@ -3701,14 +3700,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             // Find the last block the caller has in the main chain\n             pindex = locator.GetBlockIndex();\n             if (pindex)\n-                pindex = pindex->GetNextInMainChain();\n+                pindex = chainActive.Next(pindex);\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n         int nLimit = 2000;\n         LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str());\n-        for (; pindex; pindex = pindex->GetNextInMainChain())\n+        for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n@@ -4097,7 +4096,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // Start block sync\n         if (pto->fStartSync && !fImporting && !fReindex) {\n             pto->fStartSync = false;\n-            PushGetBlocks(pto, pindexBest, uint256(0));\n+            PushGetBlocks(pto, chainActive.Tip(), uint256(0));\n         }\n \n         // Resend wallet transactions that haven't gotten in a block yet"
      },
      {
        "sha": "46d629044ae5b3c09ea51af5aadcf7e095e15907",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 53,
        "deletions": 30,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -74,14 +74,8 @@ extern CScript COINBASE_FLAGS;\n \n extern CCriticalSection cs_main;\n extern std::map<uint256, CBlockIndex*> mapBlockIndex;\n-extern std::vector<CBlockIndex*> vBlockIndexByHeight;\n extern std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n-extern CBlockIndex* pindexGenesisBlock;\n-extern int nBestHeight;\n-extern uint256 nBestChainWork;\n extern uint256 nBestInvalidWork;\n-extern uint256 hashBestChain;\n-extern CBlockIndex* pindexBest;\n extern unsigned int nTransactionsUpdated;\n extern uint64 nLastBlockTx;\n extern uint64 nLastBlockSize;\n@@ -153,8 +147,6 @@ void UnloadBlockIndex();\n bool VerifyDB(int nCheckLevel, int nCheckDepth);\n /** Print the loaded block tree */\n void PrintBlockTree();\n-/** Find a block by height in the currently-connected chain */\n-CBlockIndex* FindBlockByHeight(int nHeight);\n /** Process protocol messages received from a given node */\n bool ProcessMessages(CNode* pfrom);\n /** Send queued protocol messages to be sent to a give node */\n@@ -819,15 +811,6 @@ class CBlockIndex\n         return (CBigNum(1)<<256) / (bnTarget+1);\n     }\n \n-    bool IsInMainChain() const\n-    {\n-        return nHeight < (int)vBlockIndexByHeight.size() && vBlockIndexByHeight[nHeight] == this;\n-    }\n-\n-    CBlockIndex *GetNextInMainChain() const {\n-        return nHeight+1 >= (int)vBlockIndexByHeight.size() ? NULL : vBlockIndexByHeight[nHeight+1];\n-    }\n-\n     bool CheckIndex() const\n     {\n         return CheckProofOfWork(GetBlockHash(), nBits);\n@@ -849,17 +832,7 @@ class CBlockIndex\n         return pbegin[(pend - pbegin)/2];\n     }\n \n-    int64 GetMedianTime() const\n-    {\n-        const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan/2; i++)\n-        {\n-            if (!pindex->GetNextInMainChain())\n-                return GetBlockTime();\n-            pindex = pindex->GetNextInMainChain();\n-        }\n-        return pindex->GetMedianTimePast();\n-    }\n+    int64 GetMedianTime() const;\n \n     /**\n      * Returns true if there are nRequired or more blocks of minVersion or above\n@@ -870,8 +843,8 @@ class CBlockIndex\n \n     std::string ToString() const\n     {\n-        return strprintf(\"CBlockIndex(pprev=%p, pnext=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, GetNextInMainChain(), nHeight,\n+        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n+            pprev, nHeight,\n             hashMerkleRoot.ToString().c_str(),\n             GetBlockHash().ToString().c_str());\n     }\n@@ -1011,9 +984,59 @@ class CValidationState {\n     }\n };\n \n+/** An in-memory indexed chain of blocks. */\n+class CChain {\n+private:\n+    std::vector<CBlockIndex*> vChain;\n \n+public:\n+    /** Returns the index entry for the genesis block of this chain, or NULL if none. */\n+    CBlockIndex *Genesis() const {\n+        return vChain.size() > 0 ? vChain[0] : NULL;\n+    }\n \n+    /** Returns the index entry for the tip of this chain, or NULL if none. */\n+    CBlockIndex *Tip() const {\n+        return vChain.size() > 0 ? vChain[vChain.size() - 1] : NULL;\n+    }\n+\n+    /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */\n+    CBlockIndex *operator[](int nHeight) const {\n+        if (nHeight < 0 || nHeight >= (int)vChain.size())\n+            return NULL;\n+        return vChain[nHeight];\n+    }\n+\n+    /** Compare two chains efficiently. */\n+    friend bool operator==(const CChain &a, const CChain &b) {\n+        return a.vChain.size() == b.vChain.size() &&\n+               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n+    }\n+\n+    /** Efficiently check whether a block is present in this chain. */\n+    bool Contains(const CBlockIndex *pindex) const {\n+        return (*this)[pindex->nHeight] == pindex;\n+    }\n+\n+    /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */\n+    CBlockIndex *Next(const CBlockIndex *pindex) const {\n+        if (Contains(pindex))\n+            return (*this)[pindex->nHeight + 1];\n+        else\n+            return NULL;\n+    }\n+\n+    /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n+    int Height() const {\n+        return vChain.size() - 1;\n+    }\n+\n+    /** Set/initialize a chain with a given tip. Returns the forking point. */\n+    CBlockIndex *SetTip(CBlockIndex *pindex);\n+};\n \n+/** The currently-connected chain of blocks. */\n+extern CChain chainActive;\n \n \n "
      },
      {
        "sha": "e9c1d9aff9ba8902e818e83ec521711ced37342b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -176,7 +176,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n     int64 nFees = 0;\n     {\n         LOCK2(cs_main, mempool.cs);\n-        CBlockIndex* pindexPrev = pindexBest;\n+        CBlockIndex* pindexPrev = chainActive.Tip();\n         CCoinsViewCache view(*pcoinsTip, true);\n \n         // Priority order to process transactions\n@@ -467,7 +467,7 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n     // Found a solution\n     {\n         LOCK(cs_main);\n-        if (pblock->hashPrevBlock != hashBestChain)\n+        if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())\n             return error(\"BitcoinMiner : generated block is stale\");\n \n         // Remove key from key pool\n@@ -510,7 +510,7 @@ void static BitcoinMiner(CWallet *pwallet)\n         // Create new block\n         //\n         unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n-        CBlockIndex* pindexPrev = pindexBest;\n+        CBlockIndex* pindexPrev = chainActive.Tip();\n \n         auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n         if (!pblocktemplate.get())\n@@ -613,7 +613,7 @@ void static BitcoinMiner(CWallet *pwallet)\n                 break;\n             if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                 break;\n-            if (pindexPrev != pindexBest)\n+            if (pindexPrev != chainActive.Tip())\n                 break;\n \n             // Update nTime every few seconds"
      },
      {
        "sha": "4f77f42f9a8cf5f29cd221f4f999932a73388413",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -540,6 +540,8 @@ void CNode::Cleanup()\n \n void CNode::PushVersion()\n {\n+    int nBestHeight = g_signals.GetHeight().get_value_or(0);\n+\n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n@@ -1467,6 +1469,8 @@ void static StartSync(const vector<CNode*> &vNodes) {\n     CNode *pnodeNewSync = NULL;\n     double dBestScore = 0;\n \n+    int nBestHeight = g_signals.GetHeight().get_value_or(0);\n+\n     // Iterate over all nodes\n     BOOST_FOREACH(CNode* pnode, vNodes) {\n         // check preconditions for allowing a sync"
      },
      {
        "sha": "2bee21201824c7a1509b7d09351dcb85e745d0be",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -28,7 +28,6 @@ static const unsigned int MAX_INV_SZ = 50000;\n \n class CNode;\n class CBlockIndex;\n-extern int nBestHeight;\n \n \n \n@@ -52,6 +51,7 @@ void SocketSendData(CNode *pnode);\n // Signals for message handling\n struct CNodeSignals\n {\n+    boost::signals2::signal<int ()> GetHeight;\n     boost::signals2::signal<bool (CNode*)> ProcessMessages;\n     boost::signals2::signal<bool (CNode*, bool)> SendMessages;\n };"
      },
      {
        "sha": "af96f11bf263997220fb9c6b78be7644603eb7b6",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -42,7 +42,7 @@ int ClientModel::getNumConnections() const\n \n int ClientModel::getNumBlocks() const\n {\n-    return nBestHeight;\n+    return chainActive.Height();\n }\n \n int ClientModel::getNumBlocksAtStartup()\n@@ -53,8 +53,8 @@ int ClientModel::getNumBlocksAtStartup()\n \n QDateTime ClientModel::getLastBlockDate() const\n {\n-    if (pindexBest)\n-        return QDateTime::fromTime_t(pindexBest->GetBlockTime());\n+    if (chainActive.Tip())\n+        return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n     else if(!isTestNet())\n         return QDateTime::fromTime_t(1231006505); // Genesis block's time\n     else\n@@ -63,7 +63,7 @@ QDateTime ClientModel::getLastBlockDate() const\n \n double ClientModel::getVerificationProgress() const\n {\n-    return Checkpoints::GuessVerificationProgress(pindexBest);\n+    return Checkpoints::GuessVerificationProgress(chainActive.Tip());\n }\n \n void ClientModel::updateTimer()"
      },
      {
        "sha": "93fc8cab225515d1997a119b7d0c586ff2acd31d",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -17,7 +17,7 @@ QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n     if (!IsFinalTx(wtx))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n-            return tr(\"Open for %n more block(s)\", \"\", wtx.nLockTime - nBestHeight + 1);\n+            return tr(\"Open for %n more block(s)\", \"\", wtx.nLockTime - chainActive.Height() + 1);\n         else\n             return tr(\"Open until %1\").arg(GUIUtil::dateTimeStr(wtx.nLockTime));\n     }"
      },
      {
        "sha": "162908a9a4f5b8517416913812cca0bb55cc6952",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -160,14 +160,14 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n         idx);\n     status.confirmed = wtx.IsConfirmed();\n     status.depth = wtx.GetDepthInMainChain();\n-    status.cur_num_blocks = nBestHeight;\n+    status.cur_num_blocks = chainActive.Height();\n \n     if (!IsFinalTx(wtx))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n         {\n             status.status = TransactionStatus::OpenUntilBlock;\n-            status.open_for = wtx.nLockTime - nBestHeight + 1;\n+            status.open_for = wtx.nLockTime - chainActive.Height() + 1;\n         }\n         else\n         {\n@@ -221,7 +221,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n-    return status.cur_num_blocks != nBestHeight;\n+    return status.cur_num_blocks != chainActive.Height();\n }\n \n QString TransactionRecord::getTxID() const"
      },
      {
        "sha": "6f7a5933ab7fdab74bf785112fe84a9143472723",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -250,9 +250,9 @@ void TransactionTableModel::updateTransaction(const QString &hash, int status)\n \n void TransactionTableModel::updateConfirmations()\n {\n-    if(nBestHeight != cachedNumBlocks)\n+    if(chainActive.Height() != cachedNumBlocks)\n     {\n-        cachedNumBlocks = nBestHeight;\n+        cachedNumBlocks = chainActive.Height();\n         // Blocks came in since last poll.\n         // Invalidate status (number of confirmations) and (possibly) description\n         //  for all rows. Qt is smart enough to only actually request the data for the"
      },
      {
        "sha": "099fbe8dc360374d0d0d4ba30e4fef09b205751e",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -73,10 +73,10 @@ void WalletModel::updateStatus()\n \n void WalletModel::pollBalanceChanged()\n {\n-    if(nBestHeight != cachedNumBlocks)\n+    if(chainActive.Height() != cachedNumBlocks)\n     {\n         // Balance and number of transactions might have changed\n-        cachedNumBlocks = nBestHeight;\n+        cachedNumBlocks = chainActive.Height();\n         checkBalanceChanged();\n     }\n }"
      },
      {
        "sha": "957241d6a08e71f209252ed00e626d284e4a82e4",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -17,10 +17,10 @@ double GetDifficulty(const CBlockIndex* blockindex)\n     // minimum difficulty = 1.0.\n     if (blockindex == NULL)\n     {\n-        if (pindexBest == NULL)\n+        if (chainActive.Tip() == NULL)\n             return 1.0;\n         else\n-            blockindex = pindexBest;\n+            blockindex = chainActive.Tip();\n     }\n \n     int nShift = (blockindex->nBits >> 24) & 0xff;\n@@ -66,7 +66,7 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n \n     if (blockindex->pprev)\n         result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n-    CBlockIndex *pnext = blockindex->GetNextInMainChain();\n+    CBlockIndex *pnext = chainActive.Next(blockindex);\n     if (pnext)\n         result.push_back(Pair(\"nextblockhash\", pnext->GetBlockHash().GetHex()));\n     return result;\n@@ -80,7 +80,7 @@ Value getblockcount(const Array& params, bool fHelp)\n             \"getblockcount\\n\"\n             \"Returns the number of blocks in the longest block chain.\");\n \n-    return nBestHeight;\n+    return chainActive.Height();\n }\n \n Value getbestblockhash(const Array& params, bool fHelp)\n@@ -90,7 +90,7 @@ Value getbestblockhash(const Array& params, bool fHelp)\n             \"getbestblockhash\\n\"\n             \"Returns the hash of the best (tip) block in the longest block chain.\");\n \n-    return hashBestChain.GetHex();\n+    return chainActive.Tip()->GetBlockHash().GetHex();\n }\n \n Value getdifficulty(const Array& params, bool fHelp)\n@@ -145,11 +145,11 @@ Value getblockhash(const Array& params, bool fHelp)\n             \"Returns hash of block in best-block-chain at <index>.\");\n \n     int nHeight = params[0].get_int();\n-    if (nHeight < 0 || nHeight > nBestHeight)\n+    if (nHeight < 0 || nHeight > chainActive.Height())\n         throw runtime_error(\"Block number out of range.\");\n \n-    CBlockIndex* pblockindex = FindBlockByHeight(nHeight);\n-    return pblockindex->phashBlock->GetHex();\n+    CBlockIndex* pblockindex = chainActive[nHeight];\n+    return pblockindex->GetBlockHash().GetHex();\n }\n \n Value getblock(const Array& params, bool fHelp)"
      },
      {
        "sha": "61cd07d507b56c88dce63ab50ea8edd17b9bbfdc",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -102,7 +102,7 @@ Value importprivkey(const Array& params, bool fHelp)\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n \n         if (fRescan) {\n-            pwalletMain->ScanForWalletTransactions(pindexGenesisBlock, true);\n+            pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n             pwalletMain->ReacceptWalletTransactions();\n         }\n     }\n@@ -124,7 +124,7 @@ Value importwallet(const Array& params, bool fHelp)\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n \n-    int64 nTimeBegin = pindexBest->nTime;\n+    int64 nTimeBegin = chainActive.Tip()->nTime;\n \n     bool fGood = true;\n \n@@ -175,11 +175,11 @@ Value importwallet(const Array& params, bool fHelp)\n     }\n     file.close();\n \n-    CBlockIndex *pindex = pindexBest;\n+    CBlockIndex *pindex = chainActive.Tip();\n     while (pindex && pindex->pprev && pindex->nTime > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n-    LogPrintf(\"Rescanning last %i blocks\\n\", pindexBest->nHeight - pindex->nHeight + 1);\n+    LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n     pwalletMain->ScanForWalletTransactions(pindex);\n     pwalletMain->ReacceptWalletTransactions();\n     pwalletMain->MarkDirty();\n@@ -243,8 +243,8 @@ Value dumpwallet(const Array& params, bool fHelp)\n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n     file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", nBestHeight, hashBestChain.ToString().c_str());\n-    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(pindexBest->nTime).c_str());\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString().c_str());\n+    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->nTime).c_str());\n     file << \"\\n\";\n     for (std::vector<std::pair<int64, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;"
      },
      {
        "sha": "f123c3a9e04272dc3b1d2a736a76345762e18230",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -37,10 +37,7 @@ void ShutdownRPCMining()\n // or from the last difficulty change if 'lookup' is nonpositive.\n // If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n Value GetNetworkHashPS(int lookup, int height) {\n-    CBlockIndex *pb = pindexBest;\n-\n-    if (height >= 0 && height < nBestHeight)\n-        pb = FindBlockByHeight(height);\n+    CBlockIndex *pb = chainActive[height];\n \n     if (pb == NULL || !pb->nHeight)\n         return 0;\n@@ -148,7 +145,7 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"Returns an object containing mining-related information.\");\n \n     Object obj;\n-    obj.push_back(Pair(\"blocks\",           (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n     obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n     obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n@@ -192,10 +189,10 @@ Value getwork(const Array& params, bool fHelp)\n         static CBlockIndex* pindexPrev;\n         static int64 nStart;\n         static CBlockTemplate* pblocktemplate;\n-        if (pindexPrev != pindexBest ||\n+        if (pindexPrev != chainActive.Tip() ||\n             (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n         {\n-            if (pindexPrev != pindexBest)\n+            if (pindexPrev != chainActive.Tip())\n             {\n                 // Deallocate old blocks since they're obsolete now\n                 mapNewBlock.clear();\n@@ -209,7 +206,7 @@ Value getwork(const Array& params, bool fHelp)\n \n             // Store the pindexBest used before CreateNewBlock, to avoid races\n             nTransactionsUpdatedLast = nTransactionsUpdated;\n-            CBlockIndex* pindexPrevNew = pindexBest;\n+            CBlockIndex* pindexPrevNew = chainActive.Tip();\n             nStart = GetTime();\n \n             // Create new block\n@@ -328,15 +325,15 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     static CBlockIndex* pindexPrev;\n     static int64 nStart;\n     static CBlockTemplate* pblocktemplate;\n-    if (pindexPrev != pindexBest ||\n+    if (pindexPrev != chainActive.Tip() ||\n         (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n     {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = NULL;\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = nTransactionsUpdated;\n-        CBlockIndex* pindexPrevNew = pindexBest;\n+        CBlockIndex* pindexPrevNew = chainActive.Tip();\n         nStart = GetTime();\n \n         // Create new block"
      },
      {
        "sha": "5384b65906a87e5b116594ef98e81ac4a8280569",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -87,9 +87,9 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n         if (mi != mapBlockIndex.end() && (*mi).second)\n         {\n             CBlockIndex* pindex = (*mi).second;\n-            if (pindex->IsInMainChain())\n+            if (chainActive.Contains(pindex))\n             {\n-                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n+                entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                 entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n             }"
      },
      {
        "sha": "433cc8b73526d47079749f26a5b3153b131e82e8",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 19,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -76,7 +76,7 @@ Value getinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n         obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n     }\n-    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n     obj.push_back(Pair(\"timeoffset\",    (boost::int64_t)GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n@@ -1180,7 +1180,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n     }\n \n-    int depth = pindex ? (1 + nBestHeight - pindex->nHeight) : -1;\n+    int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n \n     Array transactions;\n \n@@ -1192,23 +1192,8 @@ Value listsinceblock(const Array& params, bool fHelp)\n             ListTransactions(tx, \"*\", 0, true, transactions);\n     }\n \n-    uint256 lastblock;\n-\n-    if (target_confirms == 1)\n-    {\n-        lastblock = hashBestChain;\n-    }\n-    else\n-    {\n-        int target_height = pindexBest->nHeight + 1 - target_confirms;\n-\n-        CBlockIndex *block;\n-        for (block = pindexBest;\n-             block && block->nHeight > target_height;\n-             block = block->pprev)  { }\n-\n-        lastblock = block ? block->GetBlockHash() : 0;\n-    }\n+    CBlockIndex *pblockLast = chainActive[chainActive.Height() + 1 - target_confirms];\n+    uint256 lastblock = pblockLast ? pblockLast->GetBlockHash() : 0;\n \n     Object ret;\n     ret.push_back(Pair(\"transactions\", transactions));"
      },
      {
        "sha": "67165760b21979a6d454c577e4950f9c6335d039",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -65,10 +65,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n         pblock->nVersion = 1;\n-        pblock->nTime = pindexBest->GetMedianTimePast()+1;\n+        pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n         pblock->vtx[0].vin[0].scriptSig = CScript();\n         pblock->vtx[0].vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n-        pblock->vtx[0].vin[0].scriptSig.push_back(pindexBest->nHeight);\n+        pblock->vtx[0].vin[0].scriptSig.push_back(chainActive.Height());\n         pblock->vtx[0].vout[0].scriptPubKey = CScript();\n         if (txFirst.size() < 2)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n@@ -193,14 +193,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.clear();\n \n     // subsidy changing\n-    int nHeight = pindexBest->nHeight;\n-    pindexBest->nHeight = 209999;\n+    int nHeight = chainActive.Height();\n+    chainActive.Tip()->nHeight = 209999;\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n-    pindexBest->nHeight = 210000;\n+    chainActive.Tip()->nHeight = 210000;\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n-    pindexBest->nHeight = nHeight;\n+    chainActive.Tip()->nHeight = nHeight;\n \n     BOOST_FOREACH(CTransaction *tx, txFirst)\n         delete tx;"
      },
      {
        "sha": "24ee8ec3e82f9f198f42c504d597f80327c40be4",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -223,10 +223,6 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 pindexNew->nStatus        = diskindex.nStatus;\n                 pindexNew->nTx            = diskindex.nTx;\n \n-                // Watch for genesis block\n-                if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == Params().HashGenesisBlock())\n-                    pindexGenesisBlock = pindexNew;\n-\n                 if (!pindexNew->CheckIndex())\n                     return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n "
      },
      {
        "sha": "0f0ce7e6314a1384700d409c62a2d60ccb755255",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=4c6d41b8b653ef90639b1a32f6aab0bb1cef90c5",
        "patch": "@@ -799,7 +799,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n             // no need to read and scan block, if block was created before\n             // our wallet birthday (as adjusted for block time variability)\n             if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n-                pindex = pindex->GetNextInMainChain();\n+                pindex = chainActive.Next(pindex);\n                 continue;\n             }\n \n@@ -810,7 +810,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n                 if (AddToWalletIfInvolvingMe(tx.GetHash(), tx, &block, fUpdate))\n                     ret++;\n             }\n-            pindex = pindex->GetNextInMainChain();\n+            pindex = chainActive.Next(pindex);\n         }\n     }\n     return ret;\n@@ -864,7 +864,7 @@ void CWallet::ReacceptWalletTransactions()\n         if (fMissing)\n         {\n             // TODO: optimize this to scan just part of the block chain?\n-            if (ScanForWalletTransactions(pindexGenesisBlock))\n+            if (ScanForWalletTransactions(chainActive.Genesis()))\n                 fRepeat = true;  // Found missing transactions: re-do re-accept.\n         }\n     }\n@@ -1933,7 +1933,7 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64> &mapKeyBirth) const {\n             mapKeyBirth[it->first] = it->second.nCreateTime;\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n+    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganised; use a 144-block safety margin\n     std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n     std::set<CKeyID> setKeys;\n     GetKeys(setKeys);\n@@ -1953,7 +1953,7 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64> &mapKeyBirth) const {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = (*it).second;\n         std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n-        if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n+        if (blit != mapBlockIndex.end() && chainActive.Contains(blit->second)) {\n             // ... which are already in a block\n             int nHeight = blit->second->nHeight;\n             BOOST_FOREACH(const CTxOut &txout, wtx.vout) {"
      }
    ]
  }
]