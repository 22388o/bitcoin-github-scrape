[
  {
    "sha": "1f2c267135ba5a93a8a36d78a307bf4da384d0af",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZjJjMjY3MTM1YmE1YTkzYThhMzZkNzhhMzA3YmY0ZGEzODRkMGFm",
    "commit": {
      "author": {
        "name": "Midnight Magic",
        "email": "midnightmagic@users.noreply.github.com",
        "date": "2015-01-06T15:07:58Z"
      },
      "committer": {
        "name": "Midnight Magic",
        "email": "midnightmagic@users.noreply.github.com",
        "date": "2015-01-06T15:07:58Z"
      },
      "message": "secp256k1 benchmarking programs now accept parameters\n-c will vary the loop counter\n-i will vary the iterations per-loop\n-w will change the WINDOW_G table size setting at runtime (primary reason for patch)",
      "tree": {
        "sha": "39a19eae835b7761c6b3d8d40cd0f51c8cc2c372",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/39a19eae835b7761c6b3d8d40cd0f51c8cc2c372"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f2c267135ba5a93a8a36d78a307bf4da384d0af",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "bad_email",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\niQQcBAABAgAGBQJUq/poAAoJECjfJyTyQdjuymEgAJSjVx06C3BDmSq4r/EyJn3U\nDWg5w23YvoBZo6lmhr4Rd3HZQwdcE88X+gKXPMnjS4hu5X52yjx4fP3Q4F9XkZHW\nvXjbCcIYuTwsRVyiERnblcpPHjNm3J/eth/OHlcfXW9vK4gL/bUuci+sW8ilNwnq\nbFP21XUOStMU8ffCYzImFqge4+MgG4VF1aqbmLY/x80zTQ9ZMWwRtBbp67WVTvgP\n+775vM/rnLaCJLIbkYQmgEa5IqRuiXjNIQkI5oKaZg/N2uhs7WUu6Nl1AqQ0ODAQ\nCfBKCG6bGgkXCa3MgXoEq2kPz/WphHfyWbRW+onDxH/awc/ydbP9bSFRBoHnjY0X\nNUsqHYxO0uhqp4wd0bDO30n8ftywWOHGfaAg8R+mz1S0DvLb/feYVhXLSvXC/bA/\nU991xQkoB1STVs3Ks9MiGBP/RpDmksAquYptFTaCBrSEjz53wDSMiJrHJ/syCLFc\nK2gfUBt+2WbOT/Iq/I8l6A5+13oCaUgFl4WWhTsuamI6ohub4+voHJntTerx04x0\n9oVMqJ5W9dFdAbYVPS5H9GDs3kL2zR3xwqeaNDDU1cuaupshquCpUTybFMsOYC1C\n4oTh+mxj5RqanbZ5+JbFvU2rpOJoJODNZ//xMyEGJ1oNbj5h6sYy8KpEXHxn6d31\n0TJc57QbJDfJbU+LZdAyZ1KfAPxATmNzEX0gT7Rr9XUZKa9Boklx9kLotzcJPpYI\nn0odlyok2uIOn/xxzURHSAcogf7W5J6AX+pqgSrgK5H1c5bjc0QGZfn6QPrfqv87\nJjxLvK899E7RwHFAn3YJv+l7CDN237utxlB74aHBZnBEFL8Lsn/Y0+pbqGMA/Er7\nQbjhX+kWALnMcfR7H9a39KmMaqH6aBcCRdWxy9jnft62L53+6VcZEcBDjWfxKrn+\nm7KpAUggIWRUrLrCuZfb/CcvbolWH2+YmtZEMyAXEcp1bdzvE/5UyKldTSdPcwA6\ncB1PLP4W/A8X2iGPfVUaFjT7rzvFAlfN5R8GLqa5xC4lwgMiGRiIW93j2YwCQYGI\nJFVrZLroHRT1C8Nd21qSe3cdjmMlpOKK8A842ZI0jiTPIeLF2E7AHKRB6N7ceq+/\nJ5fHFH3Tf3zRbDCBVAsM+vtdttfkD5J7j/E4MKhJlMcDQ3SEz31sr9p2fuMJJDF5\nxMoYQ/QNA7+FhYACvJ5K2bxF0dyfXgZIQek4/F22vPB6ML7QnmIexTzevAt/MWlH\nQKkX/C8G+nEqEhyKycDrog1qIvnychEIZyJmfQCLmzxyM+2/Z9WNWbxlr8k5B6YD\nmgSk3tOnTVbQFPvJCoeM7D3IYLMumMQBJtkSMIaFuJIiXatr8hbtO/TVqjlA4kQ=\n=igcX\n-----END PGP SIGNATURE-----",
        "payload": "tree 39a19eae835b7761c6b3d8d40cd0f51c8cc2c372\nparent a89b8371d6243242c2bb75a6005e7b4584ea6e6d\nauthor Midnight Magic <midnightmagic@users.noreply.github.com> 1420556878 -0800\ncommitter Midnight Magic <midnightmagic@users.noreply.github.com> 1420556878 -0800\n\nsecp256k1 benchmarking programs now accept parameters\n-c will vary the loop counter\n-i will vary the iterations per-loop\n-w will change the WINDOW_G table size setting at runtime (primary reason for patch)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f2c267135ba5a93a8a36d78a307bf4da384d0af",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1f2c267135ba5a93a8a36d78a307bf4da384d0af",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f2c267135ba5a93a8a36d78a307bf4da384d0af/comments",
    "author": {
      "login": "midnightmagic",
      "id": 607777,
      "node_id": "MDQ6VXNlcjYwNzc3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/607777?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/midnightmagic",
      "html_url": "https://github.com/midnightmagic",
      "followers_url": "https://api.github.com/users/midnightmagic/followers",
      "following_url": "https://api.github.com/users/midnightmagic/following{/other_user}",
      "gists_url": "https://api.github.com/users/midnightmagic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/midnightmagic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/midnightmagic/subscriptions",
      "organizations_url": "https://api.github.com/users/midnightmagic/orgs",
      "repos_url": "https://api.github.com/users/midnightmagic/repos",
      "events_url": "https://api.github.com/users/midnightmagic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/midnightmagic/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "midnightmagic",
      "id": 607777,
      "node_id": "MDQ6VXNlcjYwNzc3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/607777?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/midnightmagic",
      "html_url": "https://github.com/midnightmagic",
      "followers_url": "https://api.github.com/users/midnightmagic/followers",
      "following_url": "https://api.github.com/users/midnightmagic/following{/other_user}",
      "gists_url": "https://api.github.com/users/midnightmagic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/midnightmagic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/midnightmagic/subscriptions",
      "organizations_url": "https://api.github.com/users/midnightmagic/orgs",
      "repos_url": "https://api.github.com/users/midnightmagic/repos",
      "events_url": "https://api.github.com/users/midnightmagic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/midnightmagic/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a89b8371d6243242c2bb75a6005e7b4584ea6e6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a89b8371d6243242c2bb75a6005e7b4584ea6e6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a89b8371d6243242c2bb75a6005e7b4584ea6e6d"
      }
    ],
    "stats": {
      "total": 194,
      "additions": 163,
      "deletions": 31
    },
    "files": [
      {
        "sha": "0b20d11c3d776ebc266e4cacf90abe1d769697f7",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -60,7 +60,7 @@ bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_sign_LDFLAGS = -static\n bench_inv_SOURCES = src/bench_inv.c\n-bench_inv_LDADD = $(SECP_LIBS)\n+bench_inv_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_inv_LDFLAGS = -static\n bench_inv_CPPFLAGS = $(SECP_INCLUDES)\n endif"
      },
      {
        "sha": "3af676421af228ec10412f544250124fc1dc14e9",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -51,6 +51,10 @@ extern \"C\" {\n  *  secp256k1_start() returns, all other functions are thread-safe.\n  */\n void secp256k1_start(unsigned int flags);\n+#ifndef SECP256K1_PRIMARY\n+extern unsigned int ecmult_impl_windowG;\n+#endif\n+\n \n /** Free all memory associated with this library. After this, no\n  *  functions can be called anymore, except secp256k1_start()"
      },
      {
        "sha": "e294fe4ee0e3f1ebecdb5a65f34806c8eb2d0b9e",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -17,21 +17,21 @@ static double gettimedouble(void) {\n     return tv.tv_usec * 0.000001 + tv.tv_sec;\n }\n \n-void run_benchmark(void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+void run_benchmark(void (*benchmark)(void*,int), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iters) {\n     double min = HUGE_VAL;\n     double sum = 0.0;\n     double max = 0.0;\n     for (int i = 0; i < count; i++) {\n         if (setup) setup(data);\n         double begin = gettimedouble();\n-        benchmark(data);\n+        benchmark(data, iters);\n         double total = gettimedouble() - begin;\n         if (teardown) teardown(data);\n         if (total < min) min = total;\n         if (total > max) max = total;\n         sum += total;\n     }\n-    printf(\"min %.3fus / avg %.3fus / max %.3fus\\n\", min * 1000000.0 / iter, (sum / count) * 1000000.0 / iter, max * 1000000.0 / iter);\n+    printf(\"min %.3fus / avg %.3fus / max %.3fus\\n\", min * 1000000.0 / iters, (sum / count) * 1000000.0 / iters, max * 1000000.0 / iters);\n }\n \n #endif"
      },
      {
        "sha": "c6807c245004ff77bf5b7cdd6c1bf00e6527123a",
        "filename": "src/secp256k1/src/bench_inv.c",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_inv.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_inv.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_inv.c?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -4,6 +4,10 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n #include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <getopt.h>\n \n #include \"include/secp256k1.h\"\n \n@@ -32,20 +36,43 @@ void bench_inv_setup(void* arg) {\n     secp256k1_scalar_set_b32(&data->x, init, NULL);\n }\n \n-void bench_inv(void* arg) {\n+void bench_inv(void* arg, int iters) {\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n-    for (int i=0; i<20000; i++) {\n+    for (int i=0; i<iters; i++) {\n         secp256k1_scalar_inverse(&data->x, &data->x);\n         secp256k1_scalar_add(&data->x, &data->x, &data->base);\n     }\n }\n \n-int main(void) {\n+int main(int argc, char **argv) {\n+    int iters=20000; int count=10;\n+    int oa;\n+    while ((oa = getopt(argc, argv, \"c:i:w:\")) != -1) {\n+        switch (oa) {\n+        case 'c':\n+            count=atoi(optarg);\n+            ( count<0 || count > 5000 ) ? (printf(\"Count %d out of sane bounds. Resetting to 10.\\n\",count),(count=10)):0x0;\n+            break;\n+        case 'i':\n+            iters=atoi(optarg);\n+            ( iters<0 || iters > 200000 ) ? (printf(\"Iterations %d out of sane bounds. Resetting to 20000.\\n\",iters),iters=20000):0x0;\n+            break;\n+        case 'w':\n+            ecmult_impl_windowG=atoi(optarg);\n+            ( ecmult_impl_windowG<2 || ecmult_impl_windowG > 30) ? (printf(\"WINDOW_G cache %d out of sane bounds. Resetting to 16.\\n\",ecmult_impl_windowG),ecmult_impl_windowG=16):0x0;\n+            break;\n+        case '?':\n+            printf(\"Missing argument to %c.\", (char)optopt);\n+        default:\n+            return 1;\n+        }\n+    }\n+\n     secp256k1_ge_start();\n \n     bench_inv_t data;\n-    run_benchmark(bench_inv, bench_inv_setup, NULL, &data, 10, 20000);\n+    run_benchmark(bench_inv, bench_inv_setup, NULL, &data, count, iters);\n \n     secp256k1_ge_stop();\n     return 0;"
      },
      {
        "sha": "875837ba7522ae0f553e8ee440dee80ede15e7ff",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -4,6 +4,10 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <getopt.h>\n+\n #include \"include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n@@ -13,11 +17,11 @@ typedef struct {\n     unsigned char sig[64];\n } bench_recover_t;\n \n-void bench_recover(void* arg) {\n+void bench_recover(void* arg, int iters) {\n     bench_recover_t *data = (bench_recover_t*)arg;\n \n     unsigned char pubkey[33];\n-    for (int i=0; i<20000; i++) {\n+    for (int i=0; i<iters; i++) {\n         int pubkeylen = 33;\n         CHECK(secp256k1_ecdsa_recover_compact(data->msg, data->sig, pubkey, &pubkeylen, 1, i % 2));\n         for (int j = 0; j < 32; j++) {\n@@ -35,11 +39,34 @@ void bench_recover_setup(void* arg) {\n     for (int i = 0; i < 64; i++) data->sig[i] = 65 + i;\n }\n \n-int main(void) {\n+int main(int argc, char **argv) {\n+    int iters=20000; int count=10;\n+    int oa;\n+    while ((oa = getopt(argc, argv, \"c:i:w:\")) != -1) {\n+        switch (oa) {\n+        case 'c':\n+            count=atoi(optarg);\n+            ( count<0 || count > 5000 ) ? (printf(\"Count %d out of sane bounds. Resetting to 10.\\n\",count),(count=10)):0x0;\n+            break;\n+        case 'i':\n+            iters=atoi(optarg);\n+            ( iters<0 || iters > 200000 ) ? (printf(\"Iterations %d out of sane bounds. Resetting to 20000.\\n\",iters),iters=20000):0x0;\n+            break;\n+        case 'w':\n+            ecmult_impl_windowG=atoi(optarg);\n+            ( ecmult_impl_windowG<2 || ecmult_impl_windowG > 30) ? (printf(\"WINDOW_G cache %d out of sane bounds. Resetting to 16.\\n\",ecmult_impl_windowG),ecmult_impl_windowG=16):0x0;\n+            break;\n+        case '?':\n+            printf(\"Missing argument to %c.\", (char)optopt);\n+        default:\n+            return 1;\n+        }\n+    }\n+\n     secp256k1_start(SECP256K1_START_VERIFY);\n \n     bench_recover_t data;\n-    run_benchmark(bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n+    run_benchmark(bench_recover, bench_recover_setup, NULL, &data, count, iters);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "c2dc3a18f8a00207b64221590775d2df08542946",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 33,
        "deletions": 4,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -4,6 +4,12 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <getopt.h>\n+\n #include \"include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n@@ -22,11 +28,11 @@ static void bench_sign_setup(void* arg) {\n     for (int i = 0; i < 32; i++) data->key[i] = i + 65;\n }\n \n-static void bench_sign(void* arg) {\n+static void bench_sign(void* arg, int iters) {\n     bench_sign_t *data = (bench_sign_t*)arg;\n \n     unsigned char sig[64];\n-    for (int i=0; i<20000; i++) {\n+    for (int i=0; i<iters; i++) {\n         int recid = 0;\n         CHECK(secp256k1_ecdsa_sign_compact(data->msg, sig, data->key, data->nonce, &recid));\n         for (int j = 0; j < 32; j++) {\n@@ -37,11 +43,34 @@ static void bench_sign(void* arg) {\n     }\n }\n \n-int main(void) {\n+int main(int argc, char **argv) {\n+    int iters=20000; int count=10;\n+    int oa;\n+    while ((oa = getopt(argc, argv, \"c:i:w:\")) != -1) {\n+        switch (oa) {\n+        case 'c':\n+            count=atoi(optarg);\n+            ( count<0 || count > 5000 ) ? (printf(\"Count %d out of sane bounds. Resetting to 10.\\n\",count),(count=10)):0x0;\n+            break;\n+        case 'i':\n+            iters=atoi(optarg);\n+            ( iters<0 || iters > 200000 ) ? (printf(\"Iterations %d out of sane bounds. Resetting to 20000.\\n\",iters),iters=20000):0x0;\n+            break;\n+        case 'w':\n+            ecmult_impl_windowG=atoi(optarg);\n+            ( ecmult_impl_windowG<2 || ecmult_impl_windowG > 30) ? (printf(\"WINDOW_G cache %d out of sane bounds. Resetting to 16.\\n\",ecmult_impl_windowG),ecmult_impl_windowG=16):0x0;\n+            break;\n+        case '?':\n+            printf(\"Missing argument to %c.\", (char)optopt);\n+        default:\n+            return 1;\n+        }\n+    }\n+\n     secp256k1_start(SECP256K1_START_SIGN);\n \n     bench_sign_t data;\n-    run_benchmark(bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n+    run_benchmark(bench_sign, bench_sign_setup, NULL, &data, count, iters);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "715d5bf2e2747c4e151ea25413fb9a0668cb69e0",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 30,
        "deletions": 4,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -6,6 +6,9 @@\n \n #include <stdio.h>\n #include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <getopt.h>\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n@@ -21,10 +24,10 @@ typedef struct {\n     int pubkeylen;\n } benchmark_verify_t;\n \n-static void benchmark_verify(void* arg) {\n+static void benchmark_verify(void* arg, int iters) {\n     benchmark_verify_t* data = (benchmark_verify_t*)arg;\n \n-    for (int i=0; i<20000; i++) {\n+    for (int i=0; i<iters; i++) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n@@ -35,7 +38,30 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n-int main(void) {\n+int main(int argc, char **argv) {\n+    int iters=20000; int count=10;\n+    int oa;\n+    while ((oa = getopt(argc, argv, \"c:i:w:\")) != -1) {\n+        switch (oa) {\n+        case 'c':\n+            count=atoi(optarg);\n+            ( count<0 || count > 5000 ) ? (printf(\"Count %d out of sane bounds. Resetting to 10.\\n\",count),(count=10)):0x0;\n+            break;\n+        case 'i':\n+            iters=atoi(optarg);\n+            ( iters<0 || iters > 200000 ) ? (printf(\"Iterations %d out of sane bounds. Resetting to 20000.\\n\",iters),iters=20000):0x0;\n+            break;\n+        case 'w':\n+            ecmult_impl_windowG=atoi(optarg);\n+            ( ecmult_impl_windowG<2 || ecmult_impl_windowG > 30) ? (printf(\"WINDOW_G cache %d out of sane bounds. Resetting to 16.\\n\",ecmult_impl_windowG),ecmult_impl_windowG=16):0x0;\n+            break;\n+        case '?':\n+            printf(\"Missing argument to %c.\", (char)optopt);\n+        default:\n+            return 1;\n+        }\n+    }\n+\n     secp256k1_start(SECP256K1_START_VERIFY | SECP256K1_START_SIGN);\n \n     benchmark_verify_t data;\n@@ -48,7 +74,7 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_create(data.pubkey, &data.pubkeylen, data.key, 1));\n \n-    run_benchmark(benchmark_verify, NULL, NULL, &data, 10, 20000);\n+    run_benchmark(benchmark_verify, NULL, NULL, &data, count, iters);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "4b4ac7966391dbb414fdb19d1fb0eff265dc4d0e",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 11,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -24,6 +24,14 @@\n #define WINDOW_G 16\n #endif\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+unsigned int ecmult_impl_windowG=WINDOW_G;\n+#ifdef __cplusplus\n+}\n+#endif\n+\n /** Fill a table 'pre' with precomputed odd multiples of a. W determines the size of the table.\n  *  pre will contains the values [1*a,3*a,5*a,...,(2^(w-1)-1)*a], so it needs place for\n  *  2^(w-2) entries.\n@@ -75,20 +83,23 @@ static void secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const sec\n \n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_t pre_g[ECMULT_TABLE_SIZE(WINDOW_G)];    /* odd multiples of the generator */\n+    secp256k1_ge_t *pre_g;    /* odd multiples of the generator */\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ge_t pre_g_128[ECMULT_TABLE_SIZE(WINDOW_G)]; /* odd multiples of 2^128*generator */\n+    secp256k1_ge_t *pre_g_128; /* odd multiples of 2^128*generator */\n #endif\n } secp256k1_ecmult_consts_t;\n \n static const secp256k1_ecmult_consts_t *secp256k1_ecmult_consts = NULL;\n \n static void secp256k1_ecmult_start(void) {\n+\n     if (secp256k1_ecmult_consts != NULL)\n         return;\n \n     /* Allocate the precomputation table. */\n     secp256k1_ecmult_consts_t *ret = (secp256k1_ecmult_consts_t*)checked_malloc(sizeof(secp256k1_ecmult_consts_t));\n+    secp256k1_ge_t *getret = (secp256k1_ge_t*)checked_malloc(sizeof(secp256k1_ge_t)*ECMULT_TABLE_SIZE(ecmult_impl_windowG));\n+    ret->pre_g = getret;\n \n     /* get the generator */\n     const secp256k1_ge_t *g = &secp256k1_ge_consts->g;\n@@ -102,9 +113,9 @@ static void secp256k1_ecmult_start(void) {\n #endif\n \n     /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g, &gj, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g, &gj, ecmult_impl_windowG);\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g_128, &g_128j, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g_128, &g_128j, ecmult_impl_windowG);\n #endif\n \n     /* Set the global pointer to the precomputation table. */\n@@ -117,7 +128,13 @@ static void secp256k1_ecmult_stop(void) {\n \n     secp256k1_ecmult_consts_t *c = (secp256k1_ecmult_consts_t*)secp256k1_ecmult_consts;\n     secp256k1_ecmult_consts = NULL;\n-    free(c);\n+\n+    secp256k1_ge_t *d = c->pre_g;\n+    if (c->pre_g != NULL) {\n+        c->pre_g = NULL;\n+    }\n+\n+    free(c); free(d);\n }\n \n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n@@ -199,12 +216,12 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n     secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n \n     /* Build wnaf representation for ng_1 and ng_128 */\n-    int wnaf_ng_1[129];   int bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   WINDOW_G);\n-    int wnaf_ng_128[129]; int bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, WINDOW_G);\n+    int wnaf_ng_1[129];   int bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   ecmult_impl_windowG);\n+    int wnaf_ng_128[129]; int bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, ecmult_impl_windowG);\n     if (bits_ng_1 > bits) bits = bits_ng_1;\n     if (bits_ng_128 > bits) bits = bits_ng_128;\n #else\n-    int wnaf_ng[257];     int bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     ng,      WINDOW_G);\n+    int wnaf_ng[257];     int bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     ng,      ecmult_impl_windowG);\n     if (bits_ng > bits) bits = bits_ng;\n #endif\n \n@@ -225,11 +242,11 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, ecmult_impl_windowG);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g_128, n, ecmult_impl_windowG);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #else\n@@ -238,7 +255,7 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng && (n = wnaf_ng[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, ecmult_impl_windowG);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #endif"
      },
      {
        "sha": "f4e789ceaf0b24b2331597ee16ce6d187e0f7acc",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2c267135ba5a93a8a36d78a307bf4da384d0af/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=1f2c267135ba5a93a8a36d78a307bf4da384d0af",
        "patch": "@@ -6,7 +6,9 @@\n \n #define SECP256K1_BUILD (1)\n \n+#define SECP256K1_PRIMARY (1)\n #include \"include/secp256k1.h\"\n+#undef SECP256K1_PRIMARY\n \n #include \"util.h\"\n #include \"num_impl.h\""
      }
    ]
  }
]