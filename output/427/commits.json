[
  {
    "sha": "027134dedd32a789c5b62d81a464c4eb264848f2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjcxMzRkZWRkMzJhNzg5YzViNjJkODFhNDY0YzRlYjI2NDg0OGYy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-23T14:36:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-26T17:56:08Z"
      },
      "message": "IPv6 support\n\nThis commit introduces IPv6 support (selectable at compile time),\n\nGeneral changes (even when IPv6 support is not compiled in):\n* Valid, routable IPv6 addresses are stored and forwarded\n* Name lookups are done using the general getaddrinfo() call\n* The detection system for the local address is improved.\n  (addresses are classified according to their 'reachability',\n  and the most reachable local address encountered is used).\n* The rule that no two connections to addresses within the same\n  /16 should be attempted, was generalized by defining address\n  groups:\n  * IPv4 addresses are grouped in /16 blocks\n  * IPv6 addresses are grouped in /32 blocks\n  * Tunneled IPv6 addresses use the encapsulated IPv4 address\n    (teredo, 6to4, SIIT, well-known prefix)\n* Hostnames can be given using the \"[host]:port\" format.\n* Support for the \"checkorder\" message was removed (obsolete,\n  and not worth porting)\n\nBehaviour changes when IPv6 support is enabled:\n* DNS lookups also return IPv6 matches\n* The listening socket is bound to the IPv6 ANY address (::/128)\n  instead of the IPv4 ANY address (0.0.0.0)\n* Connections to non-IPv4 addresses are attempted, using IPv6\n  sockets (connections to IPv4 addresses still use IPv4 sockets)\n* A local IPv6 address is used instead of an IPv4 one if no\n  routable IPv4 address is available. In this case, it is not\n  advertized through IRC (obsolete).\n\nInternal changes:\n* CAddress's \"ip\" and \"port\" fields are made private. To inspect them,\n  use GetSockAddrIPv4(), GetSockAddrIPv6() and GetPort().\n* CAddress's \"vchReserved\" field was removed, in favor of a full\n  16-byte \"ip\" field. The serialized format is unchanged.\n* The IsLocal() and IsRoutable() calls have been extended to\n  support IPv6 address classes (including documentation IP's, private\n  networks, auto configuration, and unique local addresses)\n* IP addresses are never passed as ints anymore, but as CAddresses.\n* No IRC nickname format is defined for IPv6 - IPv6 addresses are\n  expected to be propagated using DNS seeding and the P2P network.\n\nInspired by Luke Dashjr's earlier IPv6 patch.",
      "tree": {
        "sha": "5b3ba2a9f2ef55d5dcb3a71604fbf2441304aa83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b3ba2a9f2ef55d5dcb3a71604fbf2441304aa83"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/027134dedd32a789c5b62d81a464c4eb264848f2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/027134dedd32a789c5b62d81a464c4eb264848f2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/027134dedd32a789c5b62d81a464c4eb264848f2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/027134dedd32a789c5b62d81a464c4eb264848f2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aa7c5e7ceb87d0309349b89c1ad5e388cf6828a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa7c5e7ceb87d0309349b89c1ad5e388cf6828a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aa7c5e7ceb87d0309349b89c1ad5e388cf6828a4"
      }
    ],
    "stats": {
      "total": 777,
      "additions": 582,
      "deletions": 195
    },
    "files": [
      {
        "sha": "250508d7696f9d6c42554f6f818fce795f160f00",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -11,7 +11,7 @@\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT\n #endif\n-#define _WIN32_WINNT 0x0500\n+#define _WIN32_WINNT 0x0501\n #ifdef _WIN32_IE\n #undef _WIN32_IE\n #endif"
      },
      {
        "sha": "a2c7ff4e8fdf3d8a1daab282418c1e818d35bfc4",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 14,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -28,9 +28,13 @@ struct ircaddr\n \n string EncodeAddress(const CAddress& addr)\n {\n+    if (!addr.IsIPv4())\n+        return \"\";\n+\n+    struct sockaddr_in ip = addr.GetSockAddrIPv4();\n     struct ircaddr tmp;\n-    tmp.ip    = addr.ip;\n-    tmp.port  = addr.port;\n+    tmp.ip    = ip.sin_addr.s_addr;\n+    tmp.port  = ip.sin_port;\n \n     vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n     return string(\"u\") + EncodeBase58Check(vch);\n@@ -47,7 +51,10 @@ bool DecodeAddress(string str, CAddress& addr)\n         return false;\n     memcpy(&tmp, &vch[0], sizeof(tmp));\n \n-    addr = CAddress(tmp.ip, ntohs(tmp.port), NODE_NETWORK);\n+    struct sockaddr_in ip;\n+    ip.sin_addr.s_addr = tmp.ip;\n+    ip.sin_port = tmp.port;\n+    addr = CAddress(&ip, NODE_NETWORK);\n     return true;\n }\n \n@@ -203,7 +210,7 @@ bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n     }\n }\n \n-bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n+bool GetIPFromIRC(SOCKET hSocket, string strMyName, CAddress &addrRet)\n {\n     Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n \n@@ -226,10 +233,9 @@ bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n     printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n     if (fUseProxy)\n         return false;\n-    CAddress addr(strHost, 0, true);\n-    if (!addr.IsValid())\n+    addrRet = CAddress(strHost, 0, true);\n+    if (!addrRet.IsValid())\n         return false;\n-    ipRet = addr.ip;\n \n     return true;\n }\n@@ -263,7 +269,7 @@ void ThreadIRCSeed2(void* parg)\n     int nErrorWait = 10;\n     int nRetryWait = 10;\n     bool fNameInUse = false;\n-    bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n+    bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n \n     while (!fShutdown)\n     {\n@@ -278,7 +284,7 @@ void ThreadIRCSeed2(void* parg)\n         }\n \n         SOCKET hSocket;\n-        if (!ConnectSocket(addrConnect, hSocket))\n+        if (!addrConnect.ConnectSocket(hSocket))\n         {\n             printf(\"IRC connect failed\\n\");\n             nErrorWait = nErrorWait * 11 / 10;\n@@ -300,7 +306,7 @@ void ThreadIRCSeed2(void* parg)\n         }\n \n         string strMyName;\n-        if (addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n+        if (addrLocalHost.IsIPv4() && addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n             strMyName = EncodeAddress(addrLocalHost);\n         else\n             strMyName = strprintf(\"x%u\", GetRand(1000000000));\n@@ -330,16 +336,19 @@ void ThreadIRCSeed2(void* parg)\n \n         // Get our external IP from the IRC server and re-nick before joining the channel\n         CAddress addrFromIRC;\n-        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n+        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n         {\n             printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n             if (!fUseProxy && addrFromIRC.IsRoutable())\n             {\n                 // IRC lets you to re-nick\n                 fGotExternalIP = true;\n-                addrLocalHost.ip = addrFromIRC.ip;\n-                strMyName = EncodeAddress(addrLocalHost);\n-                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+                GotLocalAddress(addrFromIRC);\n+                if (addrLocalHost.IsIPv4())\n+                {\n+                    strMyName = EncodeAddress(addrLocalHost);\n+                    Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+                }\n             }\n         }\n         "
      },
      {
        "sha": "f4e8c1ff021467f78bfeac2f6cb422c9180bc869",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 33,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -1823,7 +1823,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n-        AddTimeData(pfrom->addr.ip, nTime);\n+        AddTimeData(pfrom->addr.GetKey(), nTime);\n \n         // Change version\n         if (pfrom->nVersion >= 209)\n@@ -1904,9 +1904,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         {\n             if (fShutdown)\n                 return true;\n-            // ignore IPv6 for now, since it isn't implemented anyway\n-            if (!addr.IsIPv4())\n-                continue;\n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n             AddAddress(addr, 2 * 60 * 60, &addrDB);\n@@ -1921,8 +1918,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     static uint256 hashSalt;\n                     if (hashSalt == 0)\n                         RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n-                    uint256 hashRand = hashSalt ^ (((int64)addr.ip)<<32) ^ ((GetTime()+addr.ip)/(24*60*60));\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                    uint256 nIp = addr.GetIPAsUint256();\n+                    uint256 hashRand = hashSalt;\n+                    hashRand ^= nIp;\n+                    int64 nNum = 0;\n+                    memcpy(&nNum, &hashRand, 8);\n+                    nNum += GetTime();\n+                    nNum /= 24*60*60;\n+                    hashRand ^= nNum;\n                     multimap<uint256, CNode*> mapMix;\n                     BOOST_FOREACH(CNode* pnode, vNodes)\n                     {\n@@ -2194,33 +2197,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     }\n \n \n-    else if (strCommand == \"checkorder\")\n-    {\n-        uint256 hashReply;\n-        vRecv >> hashReply;\n-\n-        if (!GetBoolArg(\"-allowreceivebyip\"))\n-        {\n-            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n-            return true;\n-        }\n-\n-        CWalletTx order;\n-        vRecv >> order;\n-\n-        /// we have a chance to check the order here\n-\n-        // Keep giving the same key to the same ip until they use it\n-        if (!mapReuseKey.count(pfrom->addr.ip))\n-            mapReuseKey[pfrom->addr.ip] = pwalletMain->GetOrReuseKeyFromPool();\n-\n-        // Send back approval of order and pubkey to use\n-        CScript scriptPubKey;\n-        scriptPubKey << mapReuseKey[pfrom->addr.ip] << OP_CHECKSIG;\n-        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n-    }\n-\n-\n     else if (strCommand == \"reply\")\n     {\n         uint256 hashReply;"
      },
      {
        "sha": "e2ea31ddee66ff7f3775a7d50804405e8a69f80a",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -10,7 +10,7 @@ WXLIBS=$(shell wx-config --libs)\n \n USE_UPNP:=0\n \n-DEFS=-DNOPCH -DFOURWAYSSE2 -DUSE_SSL\n+DEFS=-DNOPCH -DFOURWAYSSE2 -DUSE_SSL -DUSE_IPV6\n \n # for boost 1.37, add -mt to the boost libraries\n LIBS= \\"
      },
      {
        "sha": "4ceb36cc938f6189fea9ea43950750181fa3413e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 260,
        "deletions": 88,
        "changes": 348,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -88,24 +88,115 @@ void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n }\n \n \n+// get canonical identifier of an address' group\n+// no two connections will be attempted to addresses with the same group\n+vector<unsigned char> CAddress::GetGroup() const\n+{\n+    std::vector<unsigned char> vchRet;\n+    int nClass = 0; // 0=IPv6, 1=IPv4, 255=unroutable\n+    int nStartByte = 0;\n+    int nBits = 16;\n \n+    // for unroutable addresses, each address is considered different\n+    if (!IsRoutable())\n+    {\n+        nClass = 255;\n+        nBits = 128;\n+    }\n+    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n+    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n+    {\n+        nClass = 1;\n+        nStartByte = 12;\n+    }\n+    // for 6to4 tunneled addresses, use the encapsulated IPv4 address\n+    else if (Is6to4())\n+    {\n+        nClass = 1;\n+        nStartByte = 2;\n+    }\n+    // for Teredo-tunneled IPv6 addresses, use the encapsulated IPv4 address\n+    else if (IsRFC4380())\n+    {\n+        vchRet.push_back(1);\n+        vchRet.push_back(GetByte(3) ^ 0xFF);\n+        vchRet.push_back(GetByte(2) ^ 0xFF);\n+        return vchRet;\n+    }\n+    // for he.net, use /36 groups\n+    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+        nBits = 36;\n+    // for the rest of the IPv6 network, use /32 groups\n+    else\n+        nBits = 32;\n \n+    vchRet.push_back(nClass);\n+    while (nBits >= 8)\n+    {\n+        vchRet.push_back(GetByte(15 - nStartByte));\n+        nStartByte++;\n+        nBits -= 8;\n+    }\n+    if (nBits > 0)\n+        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n \n-bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout)\n+    return vchRet;\n+}\n+\n+\n+bool CAddress::ConnectSocket(SOCKET& hSocketRet, int nTimeout) const\n {\n+    bool fProxy = (fUseProxy && IsRoutable());\n+    struct sockaddr_storage sockaddr;\n+    int nFamily = 0;\n+    size_t nSockaddrLen = 0;\n+    if (fProxy && !IsIPv4())\n+    {\n+         // TODO: implement IPv6 proxying\n+         // for now, just fail\n+         return false;\n+    }\n+\n+    if ((!fProxy && IsIPv4()) || (fProxy && addrProxy.IsIPv4()))\n+    {\n+        struct sockaddr_in sockaddrI;\n+        if (fProxy)\n+            sockaddrI = addrProxy.GetSockAddrIPv4();\n+        else\n+            sockaddrI = GetSockAddrIPv4();\n+        memcpy(&sockaddr, &sockaddrI, sizeof(sockaddrI));\n+        nSockaddrLen = sizeof(sockaddrI);\n+        nFamily = AF_INET;\n+    }\n+    else\n+    {\n+#ifdef USE_IPV6\n+        struct sockaddr_in6 sockaddrI;\n+        if (fProxy)\n+            sockaddrI = addrProxy.GetSockAddrIPv6();\n+        else\n+            sockaddrI = GetSockAddrIPv6();\n+        memcpy(&sockaddr, &sockaddrI, sizeof(sockaddrI));\n+        nSockaddrLen = sizeof(sockaddrI);\n+        nFamily = AF_INET6;\n+#else\n+        // IPv6 is not compiled in, just fail\n+        return false;\n+#endif\n+    }\n+\n+\n     hSocketRet = INVALID_SOCKET;\n \n-    SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    SOCKET hSocket = socket(nFamily, SOCK_STREAM, IPPROTO_TCP);\n     if (hSocket == INVALID_SOCKET)\n         return false;\n #ifdef BSD\n     int set = 1;\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n #endif\n \n-    bool fProxy = (fUseProxy && addrConnect.IsRoutable());\n-    struct sockaddr_in sockaddr = (fProxy ? addrProxy.GetSockAddr() : addrConnect.GetSockAddr());\n-\n #ifdef __WXMSW__\n     u_long fNonblock = 1;\n     if (ioctlsocket(hSocket, FIONBIO, &fNonblock) == SOCKET_ERROR)\n@@ -119,7 +210,7 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout\n     }\n \n \n-    if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n+    if (connect(hSocket, (struct sockaddr*)&sockaddr, nSockaddrLen) == SOCKET_ERROR)\n     {\n         // WSAEINVAL is here because some legacy version of winsock uses it\n         if (WSAGetLastError() == WSAEINPROGRESS || WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINVAL)\n@@ -168,7 +259,7 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout\n         else\n #endif\n         {\n-            printf(\"connect() failed: %i\\n\",WSAGetLastError());\n+            printf(\"connect() failed: %s\\n\",strerror(WSAGetLastError()));\n             closesocket(hSocket);\n             return false;\n         }\n@@ -191,12 +282,12 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout\n         return false;\n     }\n \n-    if (fProxy)\n+    if (fProxy && IsIPv4())\n     {\n-        printf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n+        printf(\"proxy connecting %s\\n\", ToString().c_str());\n         char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n-        memcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n-        memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n+        memcpy(pszSocks4IP + 2, &port, 2);\n+        memcpy(pszSocks4IP + 4, &ip[12], 4); // ugly: extract IPv4 part\n         char* pszSocks4 = pszSocks4IP;\n         int nSize = sizeof(pszSocks4IP);\n \n@@ -219,7 +310,7 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout\n                 printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n             return false;\n         }\n-        printf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n+        printf(\"proxy connected %s\\n\", ToString().c_str());\n     }\n \n     hSocketRet = hSocket;\n@@ -255,35 +346,63 @@ bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMa\n             if (port < 0 || port > USHRT_MAX)\n                 port = USHRT_MAX;\n         }\n+        else\n+        {\n+            if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n+            {\n+                pszHost = psz+1;\n+                psz[strlen(psz)-1] = 0;\n+            }\n+        }\n     }\n \n-    unsigned int addrIP = inet_addr(pszHost);\n-    if (addrIP != INADDR_NONE)\n-    {\n-        // valid IP address passed\n-        vaddr.push_back(CAddress(addrIP, port, nServices));\n-        return true;\n-    }\n-\n-    if (!fAllowLookup)\n+    struct addrinfo aiHint = {};\n+    aiHint.ai_socktype = SOCK_STREAM;\n+    aiHint.ai_protocol = IPPROTO_TCP;\n+#ifdef __WXMSW__\n+#  ifdef USE_IPV6\n+    aiHint.ai_family = AF_UNSPEC;\n+    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n+#  else\n+    aiHint.ai_family = AF_INET;\n+    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n+#  endif\n+#else\n+#  ifdef USE_IPV6\n+    aiHint.ai_family = AF_INET6;\n+    aiHint.ai_flags = AI_ADDRCONFIG | AI_V4MAPPED | AI_ALL | (fAllowLookup ? 0 : AI_NUMERICHOST);\n+#  else\n+    aiHint.ai_family = AF_INET;\n+    aiHint.ai_flags = AI_ADDRCONFIG | (fAllowLookup ? 0 : AI_NUMERICHOST);\n+#  endif\n+#endif\n+    struct addrinfo *aiRes = NULL;\n+    int nErr = getaddrinfo(pszHost, NULL, &aiHint, &aiRes);\n+    if (nErr)\n         return false;\n \n-    struct hostent* phostent = gethostbyname(pszHost);\n-    if (!phostent)\n-        return false;\n+    struct addrinfo *aiTrav = aiRes;\n+    while (aiTrav != NULL)\n+    {\n+        if (aiTrav->ai_family == AF_INET)\n+        {\n+            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n+            vaddr.push_back(CAddress(&((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr, port, nServices));\n+        }\n \n-    if (phostent->h_addrtype != AF_INET)\n-        return false;\n+#ifdef USE_IPV6\n+        if (aiTrav->ai_family == AF_INET6)\n+        {\n+            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n+            vaddr.push_back(CAddress(&((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr, port, nServices));\n+        }\n+#endif\n \n-    char** ppAddr = phostent->h_addr_list;\n-    while (*ppAddr != NULL && vaddr.size() != nMaxSolutions)\n-    {\n-        CAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n-        if (addr.IsValid())\n-            vaddr.push_back(addr);\n-        ppAddr++;\n+        aiTrav = aiTrav->ai_next;\n     }\n \n+    freeaddrinfo(aiRes);\n+\n     return (vaddr.size() > 0);\n }\n \n@@ -297,10 +416,10 @@ bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLooku\n     return fRet;\n }\n \n-bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, unsigned int& ipRet)\n+bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, CAddress& addressRet)\n {\n     SOCKET hSocket;\n-    if (!ConnectSocket(addrConnect, hSocket))\n+    if (!addrConnect.ConnectSocket(hSocket))\n         return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n \n     send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n@@ -333,9 +452,8 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n                 strLine.resize(strLine.size()-1);\n             CAddress addr(strLine,0,true);\n             printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n-            if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n+            if (!addr.IsValid() || !addr.IsRoutable())\n                 return false;\n-            ipRet = addr.ip;\n             return true;\n         }\n     }\n@@ -344,7 +462,7 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n }\n \n // We now get our external IP from the IRC server first and only use this as a backup\n-bool GetMyExternalIP(unsigned int& ipRet)\n+bool GetMyExternalIP(CAddress& ipRet)\n {\n     CAddress addrConnect;\n     const char* pszGet;\n@@ -362,7 +480,7 @@ bool GetMyExternalIP(unsigned int& ipRet)\n         //  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n         if (nHost == 1)\n         {\n-            addrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n+            addrConnect = CAddress(\"91.198.22.70\", 80); // checkip.dyndns.org\n \n             if (nLookup == 1)\n             {\n@@ -420,10 +538,11 @@ void ThreadGetMyExternalIP(void* parg)\n     }\n \n     // Fallback in case IRC fails to get it\n-    if (GetMyExternalIP(addrLocalHost.ip))\n+    CAddress addr;\n+    if (GetMyExternalIP(addr))\n     {\n         printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n-        if (addrLocalHost.IsRoutable())\n+        if (GotLocalAddress(addr) && addrLocalHost.IsRoutable())\n         {\n             // If we already connected to a few before we had our IP, go back and addr them.\n             // setAddrKnown automatically filters any duplicate sends.\n@@ -444,7 +563,7 @@ bool AddAddress(CAddress addr, int64 nTimePenalty, CAddrDB *pAddrDB)\n {\n     if (!addr.IsRoutable())\n         return false;\n-    if (addr.ip == addrLocalHost.ip)\n+    if (CompareIP(addr, addrLocalHost) == 0)\n         return false;\n     addr.nTime = max((int64)0, (int64)addr.nTime - nTimePenalty);\n     CRITICAL_BLOCK(cs_mapAddresses)\n@@ -617,35 +736,35 @@ void CNode::CancelSubscribe(unsigned int nChannel)\n \n \n \n-CNode* FindNode(unsigned int ip)\n+CNode* FindNode(CAddress addr)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n         BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (pnode->addr.ip == ip)\n+            if (pnode->addr == addr)\n                 return (pnode);\n     }\n     return NULL;\n }\n \n-CNode* FindNode(CAddress addr)\n+CNode* FindNodeByIP(CAddress addr)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n         BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (pnode->addr == addr)\n+            if (CompareIP(pnode->addr, addr) == 0)\n                 return (pnode);\n     }\n     return NULL;\n }\n \n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n {\n-    if (addrConnect.ip == addrLocalHost.ip)\n+    if (CompareIP(addrConnect, addrLocalHost) == 0)\n         return NULL;\n \n     // Look for an existing connection\n-    CNode* pnode = FindNode(addrConnect.ip);\n+    CNode* pnode = FindNodeByIP(addrConnect);\n     if (pnode)\n     {\n         if (nTimeout != 0)\n@@ -666,7 +785,7 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n \n     // Connect\n     SOCKET hSocket;\n-    if (ConnectSocket(addrConnect, hSocket))\n+    if (addrConnect.ConnectSocket(hSocket))\n     {\n         /// debug print\n         printf(\"connected %s\\n\", addrConnect.ToString().c_str());\n@@ -675,10 +794,10 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n #ifdef __WXMSW__\n         u_long nOne = 1;\n         if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n-            printf(\"ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n+            printf(\"ConnectNode() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n #else\n         if (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n-            printf(\"ConnectSocket() : fcntl nonblocking setting failed, error %d\\n\", errno);\n+            printf(\"ConnectNode() : fcntl nonblocking setting failed, error %d\\n\", errno);\n #endif\n \n         // Add node\n@@ -875,10 +994,14 @@ void ThreadSocketHandler2(void* parg)\n         //\n         if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n         {\n+#ifdef USE_IPV6\n+            struct sockaddr_in6 sockaddr;\n+#else\n             struct sockaddr_in sockaddr;\n+#endif\n             socklen_t len = sizeof(sockaddr);\n             SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n-            CAddress addr(sockaddr);\n+            CAddress addr(&sockaddr);\n             int nInbound = 0;\n \n             CRITICAL_BLOCK(cs_vNodes)\n@@ -1175,7 +1298,11 @@ void DNSAddressSeed()\n             {\n                 BOOST_FOREACH (CAddress& addr, vaddr)\n                 {\n-                    if (addr.GetByte(3) != 127)\n+#ifdef USE_IPV6\n+                    if (addr.IsValid() && addr.IsRoutable())\n+#else\n+                    if (addr.IsValid() && addr.IsIPv4() && addr.IsRoutable())\n+#endif\n                     {\n                         addr.nTime = 0;\n                         AddAddress(addr, 0, &addrDB);\n@@ -1328,15 +1455,16 @@ void ThreadOpenConnections2(void* parg)\n         {\n             // Add seed nodes if IRC isn't working\n             static bool fSeedUsed;\n-            bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n+            bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n             if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n             {\n                 for (int i = 0; i < ARRAYLEN(pnSeed); i++)\n                 {\n                     // It'll only connect to one or two seed nodes because once it connects,\n                     // it'll get a pile of addresses with newer timestamps.\n-                    CAddress addr;\n-                    addr.ip = pnSeed[i];\n+                    struct in_addr ip;\n+                    ip.s_addr = pnSeed[i];\n+                    CAddress addr(&ip);\n                     addr.nTime = 0;\n                     AddAddress(addr);\n                 }\n@@ -1353,19 +1481,29 @@ void ThreadOpenConnections2(void* parg)\n                     nSeedDisconnected = GetTime();\n                     CRITICAL_BLOCK(cs_vNodes)\n                         BOOST_FOREACH(CNode* pnode, vNodes)\n-                            if (setSeed.count(pnode->addr.ip))\n-                                pnode->fDisconnect = true;\n+                        {\n+                            if (pnode->addr.IsIPv4())\n+                            {\n+                                sockaddr_in addr = pnode->addr.GetSockAddrIPv4();\n+                                if (setSeed.count(addr.sin_addr.s_addr))\n+                                    pnode->fDisconnect = true;\n+                            }\n+                        }\n                 }\n \n                 // Keep setting timestamps to 0 so they won't reconnect\n                 if (GetTime() - nSeedDisconnected < 60 * 60)\n                 {\n                     BOOST_FOREACH(PAIRTYPE(const vector<unsigned char>, CAddress)& item, mapAddresses)\n                     {\n-                        if (setSeed.count(item.second.ip) && item.second.nTime != 0)\n+                        if (item.second.IsIPv4() && item.second.nTime != 0)\n                         {\n-                            item.second.nTime = 0;\n-                            CAddrDB().WriteAddress(item.second);\n+                            sockaddr_in addr = item.second.GetSockAddrIPv4();\n+                            if (setSeed.count(addr.sin_addr.s_addr))\n+                            {\n+                                item.second.nTime = 0;\n+                                CAddrDB().WriteAddress(item.second);\n+                            }\n                         }\n                     }\n                 }\n@@ -1379,26 +1517,26 @@ void ThreadOpenConnections2(void* parg)\n         CAddress addrConnect;\n         int64 nBest = INT64_MIN;\n \n-        // Only connect to one address per a.b.?.? range.\n+        // Only connect to one address per group (a.b.0.0/16 for IPv4)\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n-        set<unsigned int> setConnected;\n+        set<vector<unsigned char> > setConnected;\n         CRITICAL_BLOCK(cs_vNodes)\n             BOOST_FOREACH(CNode* pnode, vNodes)\n-                setConnected.insert(pnode->addr.ip & 0x0000ffff);\n+                setConnected.insert(pnode->addr.GetGroup());\n \n         CRITICAL_BLOCK(cs_mapAddresses)\n         {\n             BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n             {\n                 const CAddress& addr = item.second;\n-                if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n+                if (!addr.IsValid() || setConnected.count(addr.GetGroup()))\n                     continue;\n                 int64 nSinceLastSeen = GetAdjustedTime() - addr.nTime;\n                 int64 nSinceLastTry = GetAdjustedTime() - addr.nLastTry;\n \n                 // Randomize the order in a deterministic way, putting the standard port first\n-                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n-                if (addr.port != htons(GetDefaultPort()))\n+                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.GetRandomized()) % (2 * 60 * 60);\n+                if (addr.GetPort() != GetDefaultPort())\n                     nRandomizer += 2 * 60 * 60;\n \n                 // Last seen  Base retry frequency\n@@ -1453,7 +1591,7 @@ bool OpenNetworkConnection(const CAddress& addrConnect)\n     //\n     if (fShutdown)\n         return false;\n-    if (addrConnect.ip == addrLocalHost.ip || !addrConnect.IsIPv4() || FindNode(addrConnect.ip))\n+    if (!CompareIP(addrConnect, addrLocalHost) || FindNodeByIP(addrConnect))\n         return false;\n \n     vnThreadsRunning[1]--;\n@@ -1553,9 +1691,10 @@ void ThreadMessageHandler2(void* parg)\n \n bool BindListenPort(string& strError)\n {\n+    unsigned short port = GetListenPort();\n     strError = \"\";\n     int nOne = 1;\n-    addrLocalHost.port = htons(GetListenPort());\n+    addrLocalHost.SetPort(port);\n \n #ifdef __WXMSW__\n     // Initialize Windows Sockets\n@@ -1570,7 +1709,11 @@ bool BindListenPort(string& strError)\n #endif\n \n     // Create socket for listening for incoming connections\n+#ifdef USE_IPV6\n+    hListenSocket = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n+#else\n     hListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+#endif\n     if (hListenSocket == INVALID_SOCKET)\n     {\n         strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n@@ -1603,22 +1746,38 @@ bool BindListenPort(string& strError)\n \n     // The sockaddr_in structure specifies the address family,\n     // IP address, and port for the socket that is being bound\n-    struct sockaddr_in sockaddr;\n+#ifdef USE_IPV6\n+    struct sockaddr_in6 sockaddr = {};\n+    memset(&sockaddr, 0, sizeof(sockaddr));\n+    sockaddr.sin6_family = AF_INET6;\n+    struct in6_addr addr = IN6ADDR_ANY_INIT;\n+    sockaddr.sin6_addr = addr;   // bind to all IPs on this computer\n+    sockaddr.sin6_port = htons(port);\n+#  ifdef __WXMSW__\n+    int nProtLevel = 10 /* PROTECTION_LEVEL_UNRESTRICTED */;\n+    int nParameterId = 23 /* IPV6_PROTECTION_LEVEl */;\n+    // this call is allowed to fail\n+    setsockopt(hListenSocket, IPPROTO_IPV6, nParameterId, (const char*)&nProtLevel, sizeof(int));\n+#  endif\n+#else\n+    struct sockaddr_in sockaddr = {};\n     memset(&sockaddr, 0, sizeof(sockaddr));\n     sockaddr.sin_family = AF_INET;\n-    sockaddr.sin_addr.s_addr = INADDR_ANY; // bind to all IPs on this computer\n-    sockaddr.sin_port = htons(GetListenPort());\n+    sockaddr.sin_addr.s_addr = INADDR_ANY;   // bind to all IPs on this computer\n+    sockaddr.sin_port = htons(port);\n+#endif\n+\n     if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n-            strError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), ntohs(sockaddr.sin_port));\n+            strError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), (int)port);\n         else\n-            strError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", ntohs(sockaddr.sin_port), nErr);\n+            strError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", (int)port, nErr);\n         printf(\"%s\\n\", strError.c_str());\n         return false;\n     }\n-    printf(\"Bound to port %d\\n\", ntohs(sockaddr.sin_port));\n+    printf(\"Bound to port %d\\n\", (int)port);\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n@@ -1631,6 +1790,23 @@ bool BindListenPort(string& strError)\n     return true;\n }\n \n+bool GotLocalAddress(const CAddress &addr)\n+{\n+#ifndef USE_IPV6\n+    if (!addr.IsIPv4())\n+        return false;\n+#endif\n+    int nOldReachability = addrLocalHost.GetReachability();\n+    int nNewReachability = addr.GetReachability();\n+    if (nNewReachability > nOldReachability)\n+    {\n+        addrLocalHost = addr;\n+        addrLocalHost.nServices = nLocalServices;\n+        return true;\n+    }\n+    return false;\n+}\n+\n void StartNode(void* parg)\n {\n     if (pnodeLocalHost == NULL)\n@@ -1644,11 +1820,7 @@ void StartNode(void* parg)\n         vector<CAddress> vaddr;\n         if (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n             BOOST_FOREACH (const CAddress &addr, vaddr)\n-                if (addr.GetByte(3) != 127)\n-                {\n-                    addrLocalHost = addr;\n-                    break;\n-                }\n+                GotLocalAddress(addr);\n     }\n #else\n     // Get local host ip\n@@ -1668,20 +1840,20 @@ void StartNode(void* parg)\n                 if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n                     printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n \n-                // Take the first IP that isn't loopback 127.x.x.x\n-                CAddress addr(*(unsigned int*)&s4->sin_addr, GetListenPort(), nLocalServices);\n-                if (addr.IsValid() && addr.GetByte(3) != 127)\n-                {\n-                    addrLocalHost = addr;\n-                    break;\n-                }\n+                CAddress addr(&s4->sin_addr, GetListenPort(), nLocalServices);\n+                GotLocalAddress(addr);\n             }\n+#ifdef USE_IPV6\n             else if (ifa->ifa_addr->sa_family == AF_INET6)\n             {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n                     printf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n+\n+                CAddress addr(&s6->sin6_addr, GetListenPort(), nLocalServices);\n+                GotLocalAddress(addr);\n             }\n+#endif\n         }\n         freeifaddrs(myaddrs);\n     }\n@@ -1691,7 +1863,7 @@ void StartNode(void* parg)\n     if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n     {\n         // Proxies can't take incoming connections\n-        addrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n+        addrLocalHost = CAddress();\n         printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n     }\n     else"
      },
      {
        "sha": "8c2a2b46efde01ee33d0cf4e354a1a233b24f626",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 280,
        "deletions": 50,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -10,6 +10,8 @@\n \n #ifndef __WXMSW__\n #include <arpa/inet.h>\n+#else\n+#include <ws2tcpip.h>\n #endif\n \n class CMessageHeader;\n@@ -36,11 +38,11 @@ enum\n \n \n \n-bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout=nConnectTimeout);\n bool Lookup(const char *pszName, std::vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n bool GetMyExternalIP(unsigned int& ipRet);\n bool AddAddress(CAddress addr, int64 nTimePenalty=0, CAddrDB *pAddrDB=NULL);\n+bool GotLocalAddress(const CAddress &addr);\n void AddressCurrentlyConnected(const CAddress& addr);\n CNode* FindNode(unsigned int ip);\n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout=0);\n@@ -151,37 +153,58 @@ static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0\n \n class CAddress\n {\n+private:\n+    // TCP/IP port in network byte order\n+    uint16_t port;\n+\n+    // IPv6 address (possibly containing an IPv4 mapped address)\n+    unsigned char ip[16];\n+\n public:\n     uint64 nServices;\n-    unsigned char pchReserved[12];\n-    unsigned int ip;\n-    unsigned short port;\n \n     // disk and network only\n     unsigned int nTime;\n \n     // memory only\n     unsigned int nLastTry;\n \n-    CAddress()\n+\n+    // portIn is in network byte order\n+    void Init(struct in_addr* pipv4Addr, unsigned short portIn, uint64 nServicesIn=NODE_NETWORK)\n     {\n         Init();\n+        if (pipv4Addr != NULL)\n+        {\n+            memcpy(ip,    pchIPv4, 12);\n+            memcpy(ip+12, pipv4Addr, 4);\n+        }\n+        port = portIn;\n+        nServices = nServicesIn;\n     }\n \n-    CAddress(unsigned int ipIn, unsigned short portIn=0, uint64 nServicesIn=NODE_NETWORK)\n+    void Init(struct sockaddr_in* paddr, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        ip = ipIn;\n-        port = htons(portIn == 0 ? GetDefaultPort() : portIn);\n-        nServices = nServicesIn;\n+        Init(&paddr->sin_addr, paddr->sin_port, nServicesIn);\n     }\n \n-    explicit CAddress(const struct sockaddr_in& sockaddr, uint64 nServicesIn=NODE_NETWORK)\n+    CAddress()\n     {\n         Init();\n-        ip = sockaddr.sin_addr.s_addr;\n-        port = sockaddr.sin_port;\n-        nServices = nServicesIn;\n+    }\n+\n+    // construct an IPv4 address - portIn is in host byte order\n+    CAddress(struct in_addr* pipv4Addr, unsigned short portIn=0, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        if (portIn == 0)\n+            portIn = GetDefaultPort();\n+        Init(pipv4Addr, htons(portIn), nServicesIn);\n+    }\n+\n+    // construct an IPv4 address - portIn is in host byte order\n+    CAddress(struct sockaddr_in* paddr, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        Init(paddr, nServicesIn);\n     }\n \n     explicit CAddress(const char* pszIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n@@ -211,8 +234,7 @@ class CAddress\n     void Init()\n     {\n         nServices = NODE_NETWORK;\n-        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n-        ip = INADDR_NONE;\n+        memset(ip, 0, 16);\n         port = htons(GetDefaultPort());\n         nTime = 100000000;\n         nLastTry = 0;\n@@ -227,43 +249,51 @@ class CAddress\n         if ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n             READWRITE(nTime);\n         READWRITE(nServices);\n-        READWRITE(FLATDATA(pchReserved)); // for IPv6\n-        READWRITE(ip);\n+        READWRITE(FLATDATA(ip));\n         READWRITE(port);\n     )\n \n+    bool ConnectSocket(SOCKET& hSocketRet, int nTimeout=nConnectTimeout) const;\n+\n+    int inline GetPort() const\n+    {\n+        return ntohs(port);\n+    }\n+\n+    void SetPort(unsigned short portIn)\n+    {\n+        port = htons(portIn);\n+    }\n+\n     friend inline bool operator==(const CAddress& a, const CAddress& b)\n     {\n-        return (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &&\n-                a.ip   == b.ip &&\n+        return (memcmp(a.ip, b.ip, sizeof(a.ip)) == 0 &&\n                 a.port == b.port);\n     }\n \n+    friend inline int CompareIP(const CAddress& a, const CAddress& b)\n+    {\n+        return memcmp(a.ip, b.ip, sizeof(a.ip));\n+    }\n+\n     friend inline bool operator!=(const CAddress& a, const CAddress& b)\n     {\n         return (!(a == b));\n     }\n \n     friend inline bool operator<(const CAddress& a, const CAddress& b)\n     {\n-        int ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));\n+        int ret = memcmp(a.ip, b.ip, sizeof(a.ip));\n         if (ret < 0)\n             return true;\n-        else if (ret == 0)\n-        {\n-            if (ntohl(a.ip) < ntohl(b.ip))\n-                return true;\n-            else if (a.ip == b.ip)\n-                return ntohs(a.port) < ntohs(b.port);\n-        }\n         return false;\n     }\n \n     std::vector<unsigned char> GetKey() const\n     {\n         CDataStream ss;\n         ss.reserve(18);\n-        ss << FLATDATA(pchReserved) << ip << port;\n+        ss << FLATDATA(ip) << port;\n \n         #if defined(_MSC_VER) && _MSC_VER < 1300\n         return std::vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);\n@@ -272,73 +302,200 @@ class CAddress\n         #endif\n     }\n \n-    struct sockaddr_in GetSockAddr() const\n+    uint256 GetIPAsUint256() const\n+    {\n+       uint256 uint256 = 0;\n+       memcpy(&uint256, ip, 16);\n+       return uint256;\n+    }\n+\n+    struct sockaddr_in GetSockAddrIPv4() const\n     {\n         struct sockaddr_in sockaddr;\n         memset(&sockaddr, 0, sizeof(sockaddr));\n         sockaddr.sin_family = AF_INET;\n-        sockaddr.sin_addr.s_addr = ip;\n+        memcpy(&sockaddr.sin_addr.s_addr, ip+12, 4);\n         sockaddr.sin_port = port;\n         return sockaddr;\n     }\n \n+    // IPv4-mapped addresses (::ffff:0:0/96)\n     bool IsIPv4() const\n     {\n-        return (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);\n+        return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n     }\n \n+    // IPv4 private networks (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)\n     bool IsRFC1918() const\n     {\n-      return IsIPv4() && (GetByte(3) == 10 ||\n-        (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 &&\n-          (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+        return IsIPv4() && (GetByte(3) == 10 ||\n+            (GetByte(3) == 192 && GetByte(2) == 168) ||\n+            (GetByte(3) == 172 &&\n+                (GetByte(2) >= 16 && GetByte(2) <= 31)));\n     }\n \n+    // IPv4 auto configuration (169.254.x.x)\n     bool IsRFC3927() const\n     {\n-      return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+        return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+    }\n+\n+    // IPv6 documentation address (2001:db8::/32)\n+    bool IsRFC3849() const\n+    {\n+        return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+    }\n+\n+    // 6to4 tunneling (2002::/16)\n+    bool Is6to4() const\n+    {\n+        return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+    }\n+\n+    // IPv6 Well-known prefix (64:ff9b::/96)\n+    bool IsRFC6052() const\n+    {\n+        static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+        return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+    }\n+\n+    // IPv6 Teredo tunneling (2001::/32)\n+    bool IsRFC4380() const\n+    {\n+        return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+    }\n+\n+    // IPv6 stateless auto configuration (fe80::/64)\n+    bool IsRFC4862() const\n+    {\n+        static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+        return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+    }\n+\n+    // IPv6 unique local address (fc00::/7)\n+    bool IsRFC4193() const\n+    {\n+        return ((GetByte(15) & 0xFE) == 0xFC);\n     }\n \n+    // IPv4-translated addresses (::ffff:0:0:0/96)\n+    bool IsRFC6145() const\n+    {\n+        static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+        return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+    }\n+\n+    // IPv6 and IPv4 loopback addresses\n     bool IsLocal() const\n     {\n-      return IsIPv4() && (GetByte(3) == 127 ||\n-          GetByte(3) == 0);\n+        // IPv4 loopback\n+       if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+           return true;\n+\n+       // IPv6 loopback (::1/128)\n+       static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n+       if (memcmp(ip, pchLocal, 16) == 0)\n+           return true;\n+\n+       return false;\n     }\n \n     bool IsRoutable() const\n     {\n-        return IsValid() &&\n-            !(IsRFC1918() || IsRFC3927() || IsLocal());\n+        return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || IsRFC4193() || IsLocal());\n+    }\n+\n+    bool IsMulticast() const\n+    {\n+        return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n+               || (GetByte(15) == 0xFF);\n     }\n \n     bool IsValid() const\n     {\n+        if (port == htons(USHRT_MAX))\n+            return false;\n+\n         // Clean up 3-byte shifted addresses caused by garbage in size field\n         // of addr messages from versions before 0.2.9 checksum.\n         // Two consecutive addr messages look like this:\n         // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n         // so if the first length field is garbled, it reads the second batch\n         // of addr misaligned by 3 bytes.\n-        if (memcmp(pchReserved, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+        if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+            return false;\n+\n+        // unspecified IPv6 address (::/128)\n+        unsigned char ipNone[16] = {};\n+        if (memcmp(ip, ipNone, 16) == 0)\n+            return false;\n+\n+        // documentation IPv6 address\n+        if (IsRFC3849())\n             return false;\n \n-        return (ip != 0 && ip != INADDR_NONE && port != htons(USHRT_MAX));\n+        if (IsIPv4())\n+        {\n+            // INADDR_NONE\n+            uint32_t ipNone = INADDR_NONE;\n+            if (memcmp(ip+12, &ipNone, 4) == 0)\n+                return false;\n+\n+            // 0\n+            ipNone = 0;\n+            if (memcmp(ip+12, &ipNone, 4) == 0)\n+                return false;\n+        }\n+\n+        return true;\n     }\n \n     unsigned char GetByte(int n) const\n     {\n-        return ((unsigned char*)&ip)[3-n];\n+        return ip[15-n];\n+    }\n+\n+    std::vector<unsigned char> GetGroup() const;\n+\n+    int64 GetRandomized() const\n+    {\n+        if (IsIPv4())\n+        {\n+            // reconstruct ip in reversed-byte order\n+            // (the original definition of the randomizer used network-order integers on little endian architecture)\n+            int64 ip = GetByte(0) << 24 + GetByte(1) << 16 + GetByte(2) << 8 + GetByte(3);\n+            return ip * 7789;\n+        }\n+\n+        // for IPv6 addresses, use separate multipliers for each byte\n+        // these numbers are from the hexadecimal expansion of 3/Pi:\n+        static const int64 nByteMult[16] = \n+            {0xF4764525, 0x75661FBE, 0xFA3B03BA, 0xEFCF4CA1, 0x4913E065, 0xDA655862, 0xFD7A1581, 0xCE19A812,\n+             0x92B6A557, 0x6374BC50, 0x096DC65F, 0x0EBA5B2B, 0x7D2CE0AB, 0x09BE7ADE, 0x5CC350EF, 0xC618E6C7};\n+        int64 nRet = 0;\n+        for (int n=0; n<16; n++)\n+            nRet += nByteMult[n]*GetByte(n);\n+        return nRet;\n     }\n \n     std::string ToStringIPPort() const\n     {\n-        return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n+        if (IsIPv4())\n+            return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n+        else\n+            return \"[\" + ToStringIP() + strprintf(\"]:%u\", ntohs(port));\n     }\n \n     std::string ToStringIP() const\n     {\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+        if (IsIPv4())\n+            return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+        else\n+            return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                             GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+                             GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+                             GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+                             GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n     }\n \n     std::string ToStringPort() const\n@@ -348,13 +505,86 @@ class CAddress\n \n     std::string ToString() const\n     {\n-        return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n+        return ToStringIPPort();\n     }\n \n     void print() const\n     {\n         printf(\"CAddress(%s)\\n\", ToString().c_str());\n     }\n+\n+    // 0 - invalid\n+    // 1 - local ipv6\n+    // 2 - local ipv4\n+    // 3 - unroutable ipv6\n+    // 4 - unroutable ipv4\n+    // 5 - routable tunneled ipv6 (teredo)\n+    // 6 - routable tunneled ipv6 (6to4, well-known prefix)\n+    // 7 - routable ipv6\n+    // 8 - routable ipv4\n+    int GetReachability() const\n+    {\n+        if (!IsValid())\n+            return 0;\n+        if (!IsIPv4() && IsLocal())\n+            return 1;\n+        if (IsLocal())\n+            return 2;\n+        if (!IsIPv4() && !IsRoutable())\n+            return 3;\n+        if (!IsRoutable())\n+            return 4;\n+        if (IsRFC4380())\n+            return 5;\n+        if (Is6to4() || IsRFC6052())\n+            return 6;\n+        if (!IsIPv4())\n+            return 7;\n+        return 8;\n+    }\n+\n+#ifdef USE_IPV6\n+    // portIn is in network byte order\n+    void Init(struct in6_addr* pipv6Addr, unsigned short portIn, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        Init();\n+        if (pipv6Addr != NULL)\n+            memcpy(ip, pipv6Addr, 16);\n+        port = portIn;\n+        nServices  = nServicesIn;\n+    }\n+\n+    void Init(struct sockaddr_in6* paddr, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        Init(&paddr->sin6_addr, paddr->sin6_port, nServicesIn);\n+    }\n+\n+    // construct an IPv6 address - portIn is in host byte order\n+    CAddress(struct in6_addr* pipv6Addr, unsigned short portIn=0, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        if (portIn == 0)\n+            portIn = GetDefaultPort();\n+        Init(pipv6Addr, htons(portIn), nServicesIn);\n+    }\n+\n+    // construct an IPv6 address - portIn is in host byte order\n+    CAddress(struct sockaddr_in6* paddr, uint64 nServicesIn=NODE_NETWORK)\n+    {\n+        Init(paddr, nServicesIn);\n+    }\n+\n+    struct sockaddr_in6 GetSockAddrIPv6() const\n+    {\n+        struct sockaddr_in6 sockaddr;\n+        memset(&sockaddr, 0, sizeof(sockaddr));\n+        sockaddr.sin6_family = AF_INET6;\n+        memcpy(&sockaddr.sin6_addr.s6_addr, ip, 16);\n+        sockaddr.sin6_port = port;\n+        return sockaddr;\n+    }\n+#endif\n+\n+\n };\n \n \n@@ -1021,7 +1251,7 @@ inline void RelayMessage<>(const CInv& inv, const CDataStream& ss)\n //\n // Templates for the publish and subscription system.\n // The object being published as T& obj needs to have:\n-//   a set<unsigned int> setSources member\n+//   a set<CAddress> setSources member\n //   specializations of AdvertInsert and AdvertErase\n // Currently implemented for CTable and CProduct.\n //\n@@ -1030,7 +1260,7 @@ template<typename T>\n void AdvertStartPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops, T& obj)\n {\n     // Add to sources\n-    obj.setSources.insert(pfrom->addr.ip);\n+    obj.setSources.insert(pfrom->addr);\n \n     if (!AdvertInsert(obj))\n         return;\n@@ -1059,7 +1289,7 @@ template<typename T>\n void AdvertRemoveSource(CNode* pfrom, unsigned int nChannel, unsigned int nHops, T& obj)\n {\n     // Remove a source\n-    obj.setSources.erase(pfrom->addr.ip);\n+    obj.setSources.erase(pfrom->addr);\n \n     // If no longer supported by any sources, cancel it\n     if (obj.setSources.empty())"
      },
      {
        "sha": "e5bf2afaa5c05a0845813c4a8f7731501ede33bb",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -1935,12 +1935,12 @@ CAddress COptionsDialog::GetProxyAddr()\n {\n     // Be careful about byte order, addr.ip and addr.port are big endian\n     CAddress addr(m_textCtrlProxyIP->GetValue() + \":\" + m_textCtrlProxyPort->GetValue());\n-    if (addr.ip == INADDR_NONE)\n-        addr.ip = addrProxy.ip;\n+    if (!addr.IsValid())\n+        addr = addrProxy;\n     int nPort = atoi(m_textCtrlProxyPort->GetValue());\n-    addr.port = htons(nPort);\n+    addr.SetPort(nPort);\n     if (nPort <= 0 || nPort > USHRT_MAX)\n-        addr.port = addrProxy.port;\n+        addr.SetPort(addrProxy.GetPort());\n     return addr;\n }\n "
      },
      {
        "sha": "20b978faa1f08b7714a25d4cc6edcfece98c0be4",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -826,13 +826,13 @@ int64 GetAdjustedTime()\n     return GetTime() + nTimeOffset;\n }\n \n-void AddTimeData(unsigned int ip, int64 nTime)\n+void AddTimeData(const vector<unsigned char>& vchIp, int64 nTime)\n {\n     int64 nOffsetSample = nTime - GetTime();\n \n     // Ignore duplicates\n-    static set<unsigned int> setKnown;\n-    if (!setKnown.insert(ip).second)\n+    static set<vector<unsigned char> > setKnown;\n+    if (!setKnown.insert(vchIp).second)\n         return;\n \n     // Add data"
      },
      {
        "sha": "761a9cd3818707722dffbb988a210c1495e04c66",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/027134dedd32a789c5b62d81a464c4eb264848f2/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/027134dedd32a789c5b62d81a464c4eb264848f2/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=027134dedd32a789c5b62d81a464c4eb264848f2",
        "patch": "@@ -207,7 +207,7 @@ int GetRandInt(int nMax);\n uint64 GetRand(uint64 nMax);\n int64 GetTime();\n int64 GetAdjustedTime();\n-void AddTimeData(unsigned int ip, int64 nTime);\n+void AddTimeData(const std::vector<unsigned char> &vchIp, int64 nTime);\n std::string FormatFullVersion();\n \n "
      }
    ]
  },
  {
    "sha": "aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYWM1YjUyZjViNzFjMGU1MGQyNGM3NTdlNjY3YmQ1ZTc5MzNlNmRl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-26T16:58:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-26T18:08:08Z"
      },
      "message": "multilocal",
      "tree": {
        "sha": "c93db721a89580a134d682e98ee04761f4f9a839",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c93db721a89580a134d682e98ee04761f4f9a839"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "027134dedd32a789c5b62d81a464c4eb264848f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/027134dedd32a789c5b62d81a464c4eb264848f2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/027134dedd32a789c5b62d81a464c4eb264848f2"
      }
    ],
    "stats": {
      "total": 254,
      "additions": 155,
      "deletions": 99
    },
    "files": [
      {
        "sha": "da79c8b7b7e9d8686e9a3320be04a2e883014494",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -710,7 +710,7 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n             {\n                 string strAddress;\n                 ssKey >> strAddress;\n-                ssValue >> pwallet->mapAddressBook[strAddress];\n+                ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress)];\n             }\n             else if (strType == \"tx\")\n             {"
      },
      {
        "sha": "4296de00c7a9fb6127a9031ac64c9847a9c32508",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 23,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -15,8 +15,10 @@ bool fGotExternalIP = false;\n \n void ThreadIRCSeed2(void* parg);\n \n-\n-\n+// dummy address that can be used as argument to\n+// GetLocalAddress(), forcing it to return an IPv4\n+// address\n+static const CAddress addrIRCDummy(\"127.0.0.1\");\n \n #pragma pack(push, 1)\n struct ircaddr\n@@ -271,27 +273,29 @@ void ThreadIRCSeed2(void* parg)\n     bool fNameInUse = false;\n     bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n \n+    vector<CAddress> vaddrIRC;\n+    if (!fTOR)\n+        Lookup(\"irc.lfnet.org\", vaddrIRC, 0, -1, true, 6667);\n+    vaddrIRC.push_back(CAddress(\"92.243.23.21\", 6667)); // irc.lfnet.org\n+    int nIndex = 0;\n+\n     while (!fShutdown)\n     {\n-        //CAddress addrConnect(\"216.155.130.130:6667\"); // chat.freenode.net\n-        CAddress addrConnect(\"92.243.23.21\", 6667); // irc.lfnet.org\n-        if (!fTOR)\n-        {\n-            //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n-            CAddress addrIRC(\"irc.lfnet.org\", 6667, true);\n-            if (addrIRC.IsValid())\n-                addrConnect = addrIRC;\n-        }\n-\n         SOCKET hSocket;\n-        if (!addrConnect.ConnectSocket(hSocket))\n+        if (!vaddrIRC[nIndex].ConnectSocket(hSocket))\n         {\n             printf(\"IRC connect failed\\n\");\n-            nErrorWait = nErrorWait * 11 / 10;\n-            if (Wait(nErrorWait += 60))\n-                continue;\n+            nIndex++;\n+            if (nIndex == vaddrIRC.size())\n+            {\n+                nErrorWait = nErrorWait * 11 / 10;\n+                if (Wait(nErrorWait += 60))\n+                    continue;\n+                else\n+                    return;\n+            }\n             else\n-                return;\n+                continue;\n         }\n \n         if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n@@ -306,8 +310,9 @@ void ThreadIRCSeed2(void* parg)\n         }\n \n         string strMyName;\n-        if (addrLocalHost.IsIPv4() && addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n-            strMyName = EncodeAddress(addrLocalHost);\n+        const CAddress *paddrLocal = GetLocalAddress(addrIRCDummy);\n+        if (!fUseProxy && !fNameInUse && paddrLocal)\n+            strMyName = EncodeAddress(*paddrLocal);\n         else\n             strMyName = strprintf(\"x%u\", GetRand(1000000000));\n \n@@ -343,15 +348,16 @@ void ThreadIRCSeed2(void* parg)\n             {\n                 // IRC lets you to re-nick\n                 fGotExternalIP = true;\n-                GotLocalAddress(addrFromIRC);\n-                if (addrLocalHost.IsIPv4())\n+                AddLocalAddress(addrFromIRC);\n+                const CAddress *paddrLocal = GetLocalAddress(addrIRCDummy);\n+                if (paddrLocal)\n                 {\n-                    strMyName = EncodeAddress(addrLocalHost);\n+                    strMyName = EncodeAddress(*paddrLocal);\n                     Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n                 }\n             }\n         }\n-        \n+\n         if (fTestNet) {\n             Send(hSocket, \"JOIN #bitcoinTEST\\r\");\n             Send(hSocket, \"WHO #bitcoinTEST\\r\");"
      },
      {
        "sha": "80606e5ba3a597891951f7b3d00f34b75ed545e3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -1835,9 +1835,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (!pfrom->fInbound)\n         {\n             // Advertise our address\n-            if (addrLocalHost.IsRoutable() && !fUseProxy)\n+            const CAddress *paddrLocal = GetLocalAddress(pfrom->addr);\n+            if (paddrLocal && !fUseProxy)\n             {\n-                CAddress addr(addrLocalHost);\n+                CAddress addr(*paddrLocal);\n                 addr.nTime = GetAdjustedTime();\n                 pfrom->PushAddress(addr);\n             }\n@@ -2400,9 +2401,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     pnode->setAddrKnown.clear();\n \n                     // Rebroadcast our address\n-                    if (addrLocalHost.IsRoutable() && !fUseProxy)\n+                    const CAddress *paddrLocal = GetLocalAddress(pnode->addr);\n+                    if (paddrLocal && !fUseProxy)\n                     {\n-                        CAddress addr(addrLocalHost);\n+                        CAddress addr(*paddrLocal);\n                         addr.nTime = GetAdjustedTime();\n                         pnode->PushAddress(addr);\n                     }"
      },
      {
        "sha": "b3974246559f0a786b6901f30ed27aa572d9d5e0",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 42,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -48,7 +48,8 @@ bool OpenNetworkConnection(const CAddress& addrConnect);\n bool fClient = false;\n bool fAllowDNS = false;\n uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);\n-CAddress addrLocalHost(\"0.0.0.0\", 0, false, nLocalServices);\n+CCriticalSection cs_vaddrLocalHost;\n+set<CAddress> vaddrLocalHost;\n CNode* pnodeLocalHost = NULL;\n uint64 nLocalHostNonce = 0;\n array<int, 10> vnThreadsRunning;\n@@ -147,6 +148,7 @@ vector<unsigned char> CAddress::GetGroup() const\n \n bool CAddress::ConnectSocket(SOCKET& hSocketRet, int nTimeout) const\n {\n+    printf(\"Attempting connect to %s\\n\", ToString().c_str());\n     bool fProxy = (fUseProxy && IsRoutable());\n     struct sockaddr_storage sockaddr;\n     int nFamily = 0;\n@@ -369,8 +371,8 @@ bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMa\n #  endif\n #else\n #  ifdef USE_IPV6\n-    aiHint.ai_family = AF_INET6;\n-    aiHint.ai_flags = AI_ADDRCONFIG | AI_V4MAPPED | AI_ALL | (fAllowLookup ? 0 : AI_NUMERICHOST);\n+    aiHint.ai_family = AF_UNSPEC;\n+    aiHint.ai_flags = AI_ADDRCONFIG | (fAllowLookup ? 0 : AI_NUMERICHOST);\n #  else\n     aiHint.ai_family = AF_INET;\n     aiHint.ai_flags = AI_ADDRCONFIG | (fAllowLookup ? 0 : AI_NUMERICHOST);\n@@ -541,17 +543,8 @@ void ThreadGetMyExternalIP(void* parg)\n     CAddress addr;\n     if (GetMyExternalIP(addr))\n     {\n-        printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n-        if (GotLocalAddress(addr) && addrLocalHost.IsRoutable())\n-        {\n-            // If we already connected to a few before we had our IP, go back and addr them.\n-            // setAddrKnown automatically filters any duplicate sends.\n-            CAddress addr(addrLocalHost);\n-            addr.nTime = GetAdjustedTime();\n-            CRITICAL_BLOCK(cs_vNodes)\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                    pnode->PushAddress(addr);\n-        }\n+        printf(\"GetMyExternalIP() returned %s\\n\", addr.ToStringIP().c_str());\n+        AddLocalAddress(addr);\n     }\n }\n \n@@ -563,7 +556,7 @@ bool AddAddress(CAddress addr, int64 nTimePenalty, CAddrDB *pAddrDB)\n {\n     if (!addr.IsRoutable())\n         return false;\n-    if (CompareIP(addr, addrLocalHost) == 0)\n+    if (IsLocalAddress(addr))\n         return false;\n     addr.nTime = max((int64)0, (int64)addr.nTime - nTimePenalty);\n     CRITICAL_BLOCK(cs_mapAddresses)\n@@ -760,7 +753,7 @@ CNode* FindNodeByIP(CAddress addr)\n \n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n {\n-    if (CompareIP(addrConnect, addrLocalHost) == 0)\n+    if (IsLocalAddress(addrConnect))\n         return NULL;\n \n     // Look for an existing connection\n@@ -1591,7 +1584,7 @@ bool OpenNetworkConnection(const CAddress& addrConnect)\n     //\n     if (fShutdown)\n         return false;\n-    if (!CompareIP(addrConnect, addrLocalHost) || FindNodeByIP(addrConnect))\n+    if (IsLocalAddress(addrConnect) || FindNodeByIP(addrConnect))\n         return false;\n \n     vnThreadsRunning[1]--;\n@@ -1694,7 +1687,6 @@ bool BindListenPort(string& strError)\n     unsigned short port = GetListenPort();\n     strError = \"\";\n     int nOne = 1;\n-    addrLocalHost.SetPort(port);\n \n #ifdef __WXMSW__\n     // Initialize Windows Sockets\n@@ -1790,21 +1782,70 @@ bool BindListenPort(string& strError)\n     return true;\n }\n \n-bool GotLocalAddress(const CAddress &addr)\n+bool AllowIncomingConnections()\n+{\n+    // Proxies can't take incoming connections\n+    if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n+        return false;\n+    return true;\n+}\n+\n+const CAddress* GetLocalAddress(const CAddress &addrPartner)\n {\n+    CRITICAL_BLOCK(cs_vaddrLocalHost)\n+        return addrPartner.SelectCompatible(vaddrLocalHost);\n+}\n+\n+bool IsLocalAddress(const CAddress &addr)\n+{\n+    // possible optimization: set port to GetListenPort() and use .count()?\n+    CRITICAL_BLOCK(cs_vaddrLocalHost)\n+        for (set<CAddress>::const_iterator mi = vaddrLocalHost.begin(); mi != vaddrLocalHost.end(); mi++)\n+            if (CompareIP(*mi, addr) == 0)\n+                return true;\n+    return false;\n+}\n+\n+bool AddLocalAddress(const CAddress &addr)\n+{\n+    if (!AllowIncomingConnections())\n+        return false;\n+\n+    if (!addr.IsValid() || !addr.IsRoutable())\n+        return false;\n+\n #ifndef USE_IPV6\n     if (!addr.IsIPv4())\n         return false;\n #endif\n-    int nOldReachability = addrLocalHost.GetReachability();\n-    int nNewReachability = addr.GetReachability();\n-    if (nNewReachability > nOldReachability)\n+\n+    CAddress addrNew(addr);\n+    addrNew.SetPort(GetListenPort());\n+    addrNew.nServices = nLocalServices;\n+\n+    CRITICAL_BLOCK(cs_vaddrLocalHost)\n     {\n-        addrLocalHost = addr;\n-        addrLocalHost.nServices = nLocalServices;\n-        return true;\n+        if (vaddrLocalHost.count(addrNew))\n+            return false;\n+        vaddrLocalHost.insert(addrNew);\n     }\n-    return false;\n+\n+    printf(\"Added local address %s\\n\",addrNew.ToString().c_str());\n+\n+    // If we already connected to a few before we had our IP, go back and addr them.\n+    // setAddrKnown automatically filters any duplicate sends.\n+    CRITICAL_BLOCK(cs_vNodes)\n+        BOOST_FOREACH(CNode* pnode, vNodes)\n+        {\n+            if (addr.GetReachability(&pnode->addr))\n+            {\n+                CAddress addrPush(addrNew);\n+                addrPush.nTime = GetAdjustedTime();\n+                pnode->PushAddress(addrPush);\n+            }\n+        }\n+\n+    return true;\n }\n \n void StartNode(void* parg)\n@@ -1820,7 +1861,7 @@ void StartNode(void* parg)\n         vector<CAddress> vaddr;\n         if (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n             BOOST_FOREACH (const CAddress &addr, vaddr)\n-                GotLocalAddress(addr);\n+                AddLocalAddress(addr);\n     }\n #else\n     // Get local host ip\n@@ -1840,8 +1881,8 @@ void StartNode(void* parg)\n                 if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n                     printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n \n-                CAddress addr(&s4->sin_addr, GetListenPort(), nLocalServices);\n-                GotLocalAddress(addr);\n+                CAddress addr(&s4->sin_addr);\n+                AddLocalAddress(addr);\n             }\n #ifdef USE_IPV6\n             else if (ifa->ifa_addr->sa_family == AF_INET6)\n@@ -1850,26 +1891,16 @@ void StartNode(void* parg)\n                 if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n                     printf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n \n-                CAddress addr(&s6->sin6_addr, GetListenPort(), nLocalServices);\n-                GotLocalAddress(addr);\n+                CAddress addr(&s6->sin6_addr);\n+                AddLocalAddress(addr);\n             }\n #endif\n         }\n         freeifaddrs(myaddrs);\n     }\n #endif\n-    printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n-\n-    if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n-    {\n-        // Proxies can't take incoming connections\n-        addrLocalHost = CAddress();\n-        printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n-    }\n-    else\n-    {\n+    if (AllowIncomingConnections())\n         CreateThread(ThreadGetMyExternalIP, NULL);\n-    }\n \n     //\n     // Start threads"
      },
      {
        "sha": "6b87725640d480fef46b3c4644957170c78d112d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 46,
        "deletions": 28,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -42,7 +42,9 @@ bool Lookup(const char *pszName, std::vector<CAddress>& vaddr, int nServices, in\n bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n bool GetMyExternalIP(unsigned int& ipRet);\n bool AddAddress(CAddress addr, int64 nTimePenalty=0, CAddrDB *pAddrDB=NULL);\n-bool GotLocalAddress(const CAddress &addr);\n+bool AddLocalAddress(const CAddress &addr);\n+bool IsLocalAddress(const CAddress &addr);\n+const CAddress* GetLocalAddress(const CAddress &addrPartner);\n void AddressCurrentlyConnected(const CAddress& addr);\n CNode* FindNode(unsigned int ip);\n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout=0);\n@@ -301,7 +303,6 @@ class CAddress\n         return std::vector<unsigned char>(ss.begin(), ss.end());\n         #endif\n     }\n-\n     uint256 GetIPAsUint256() const\n     {\n        uint256 uint256 = 0;\n@@ -513,36 +514,47 @@ class CAddress\n         printf(\"CAddress(%s)\\n\", ToString().c_str());\n     }\n \n-    // 0 - invalid\n-    // 1 - local ipv6\n-    // 2 - local ipv4\n-    // 3 - unroutable ipv6\n-    // 4 - unroutable ipv4\n-    // 5 - routable tunneled ipv6 (teredo)\n-    // 6 - routable tunneled ipv6 (6to4, well-known prefix)\n-    // 7 - routable ipv6\n-    // 8 - routable ipv4\n-    int GetReachability() const\n+    // for IPv6 partners:        for unknown/Teredo partners:      for IPv4 partners:\n+    // 0 - unroutable            // 0 - unroutable                 // 0 - unroutable\n+    // 1 - teredo                // 1 - teredo                     // 1 - ipv4\n+    // 2 - tunneled ipv6         // 2 - tunneled ipv6\n+    // 3 - ipv4                  // 3 - ipv6\n+    // 4 - ipv6                  // 4 - ipv4\n+    int GetReachability(const CAddress *paddrPartner = NULL) const\n     {\n-        if (!IsValid())\n+        if (!IsValid() || !IsRoutable())\n             return 0;\n-        if (!IsIPv4() && IsLocal())\n-            return 1;\n-        if (IsLocal())\n-            return 2;\n-        if (!IsIPv4() && !IsRoutable())\n-            return 3;\n-        if (!IsRoutable())\n-            return 4;\n+        if (paddrPartner && paddrPartner->IsIPv4())\n+            return IsIPv4() ? 1 : 0;\n         if (IsRFC4380())\n-            return 5;\n+            return 1;\n         if (Is6to4() || IsRFC6052())\n-            return 6;\n-        if (!IsIPv4())\n-            return 7;\n-        return 8;\n+            return 2;\n+        bool fRealIPv6 = paddrPartner && !paddrPartner->IsRFC4380() && paddrPartner->IsValid() && paddrPartner->IsRoutable();\n+        if (fRealIPv6)\n+            return IsIPv4() ? 3 : 4;\n+        else\n+            return IsIPv4() ? 4 : 3;\n     }\n \n+    const CAddress* SelectCompatible(const std::set<CAddress>& setAddr) const\n+    {\n+        const CAddress* paddrBest = NULL;\n+        int nBestScore = 0;\n+        for (std::set<CAddress>::const_iterator mi = setAddr.begin(); mi != setAddr.end(); mi++)\n+        {\n+            int nScore = (*mi).GetReachability(this);\n+            if (nScore > nBestScore)\n+            {\n+                paddrBest = &(*mi);\n+                nBestScore = nScore;\n+            }\n+        }\n+        return paddrBest;\n+    }\n+\n+\n+\n #ifdef USE_IPV6\n     // portIn is in network byte order\n     void Init(struct in6_addr* pipv6Addr, unsigned short portIn, uint64 nServicesIn=NODE_NETWORK)\n@@ -703,7 +715,7 @@ class CRequestTracker\n extern bool fClient;\n extern bool fAllowDNS;\n extern uint64 nLocalServices;\n-extern CAddress addrLocalHost;\n+extern std::set<CAddress> vaddrLocalHost;\n extern CNode* pnodeLocalHost;\n extern uint64 nLocalHostNonce;\n extern boost::array<int, 10> vnThreadsRunning;\n@@ -979,7 +991,13 @@ class CNode\n         /// when NTP implemented, change to just nTime = GetAdjustedTime()\n         int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n         CAddress addrYou = (fUseProxy ? CAddress(\"0.0.0.0\") : addr);\n-        CAddress addrMe = (fUseProxy ? CAddress(\"0.0.0.0\") : addrLocalHost);\n+        CAddress addrMe(\"0.0.0.0\");\n+        if (!fUseProxy)\n+        {\n+            const CAddress *paddrMe = GetLocalAddress(addr);\n+            if (paddrMe)\n+                addrMe = *paddrMe;\n+        }\n         RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n         PushMessage(\"version\", VERSION, nLocalServices, nTime, addrYou, addrMe,\n                     nLocalHostNonce, std::string(pszSubVer), nBestHeight);"
      },
      {
        "sha": "ad14fffcdbd87d836c74d3aeb5b3b8ee9ab74c44",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aac5b52f5b71c0e50d24c757e667bd5e7933e6de/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=aac5b52f5b71c0e50d24c757e667bd5e7933e6de",
        "patch": "@@ -1141,7 +1141,6 @@ bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* ke\n     return false;\n }\n \n-\n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     if (keystore)"
      }
    ]
  }
]