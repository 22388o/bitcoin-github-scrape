[
  {
    "sha": "0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYWE4OWMwOGZmMjcxZjM0MjcxZTZmZDJlYjFlZjA0YWZkYmNhYjNh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-03-18T22:47:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-03-21T04:09:02Z"
      },
      "message": "Prevent stuck block download in large reorganisations\n\nIn cases of very large reorganisations (hundreds of blocks), a situation\nmay appear where an 'inv' is sent as response to a 'getblocks', but the\nlast block mentioned in the inv is already known to the receiver node.\nHowever, the supplying node uses a request for this last block as a\ntrigger to send the rest of the inv blocks. If it never comes, the block\nchain download is stuck.\n\nThis commit makes the receiver node always request the last inv'ed block,\neven if it is already known, to prevent this problem.",
      "tree": {
        "sha": "17b2e6f8bbee2e4adebda41107c4d554eb020266",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17b2e6f8bbee2e4adebda41107c4d554eb020266"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a",
      "comment_count": 8,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef142365392f57b6d6d0c54186dc7f2fc9242bec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef142365392f57b6d6d0c54186dc7f2fc9242bec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef142365392f57b6d6d0c54186dc7f2fc9242bec"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 8,
      "deletions": 3
    },
    "files": [
      {
        "sha": "0ba68593615c6c90d96c65af4f7e70c5765e5622",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0aa89c08ff271f34271e6fd2eb1ef04afdbcab3a",
        "patch": "@@ -2357,8 +2357,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         CTxDB txdb(\"r\");\n-        BOOST_FOREACH(const CInv& inv, vInv)\n+        for (int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n+            const CInv &inv = vInv[nInv];\n+\n             if (fShutdown)\n                 return true;\n             pfrom->AddInventoryKnown(inv);\n@@ -2367,9 +2369,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             if (fDebug)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n-            if (!fAlreadyHave)\n+            // Always request the last block in an inv bundle (even if we already have it), as it is the\n+            // trigger for the other side to send further invs. If we are stuck on a (very long) side chain,\n+            // this is necessary to connect earlier received orphan blocks to the chain again.\n+            if (!fAlreadyHave || (inv.type == MSG_BLOCK && nInv==vInv.size()-1))\n                 pfrom->AskFor(inv);\n-            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))\n+            if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))\n                 pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n \n             // Track requests for our stuff"
      }
    ]
  }
]