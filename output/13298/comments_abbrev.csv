gmaxwell,2018-05-21T19:19:22Z,"I'm glad to see someone working on this!\n\nOne prior proposal was to put _all_ inbound into one timing bucket, and keep per-peer timing for each outbound with the rationale that the attacker doesn't control our outbounds but could potentially control any inbounds.\n\nIf we found that to be too slow we could quantize inbound network groups into a small number of buckets (e.g. 4, by computing  ",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-390754861,390754861,
skeees,2018-05-21T20:13:28Z,"Maybe I'm missing something, but what would be the downside of having a single next send across all outbound peers if propagation latency isn't a huge issue? It seems like delay by net group is moving in that direction",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-390768509,390768509,
sipa,2018-05-21T20:37:03Z,"We assume that outgoing connections are less likely to be (significantly) under attacker control, due to them being self-selected, and addrman having built-in precautions against eclipse attacks (cc @EthanHeilman). Giving different peers a synchronized timer results increases bandwidth spikes, which isn't so much a concern for tx propagation, but may interfere with block propagation if they coinci",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-390774816,390774816,
naumenkogs,2018-05-21T20:57:37Z,"@gmaxwell thanks for the feedback.\n\nI like the idea of turning it into a small number of buckets.\nI think that 8 buckets may be fine considering current load (should not cause significant spikes in bandwidth).\n\nPlease let me know if you see a better estimation for a reasonable number of buckets.",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-390780413,390780413,
gmaxwell,2018-05-21T21:38:29Z,"@skeees Putting all in one will result in more spiky bandwidth usage (e.g. you hit your queue then use a bunch of bandwidth transmitting to everyone at once),  and I _believe_ but lack a rigorous analysis that we get more privacy for a given amount of average delay if the transactions diffuse randomly in the network to hide where they originated from, at least if we assume the target doesn't send ",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-390790891,390790891,
sdaftuar,2018-05-25T17:05:40Z,"I've been looking at this paper ""Deanonymization in the Bitcoin P2P Network"" (https://papers.nips.cc/paper/6735-deanonymization-in-the-bitcoin-p2p-network.pdf).  It's got some ideas for how to think about an adversary's strategies with respect to detecting the first node on a network to relay a new transaction.\n\nIt seems to me there are a couple different kinds of adversaries to consider -- (a",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-392121209,392121209,
sipa,2018-05-25T20:52:15Z,"@sdaftuar Do you think there would be reasons to increase the number of groups when there are more connections? Clearly for small numbers of connections the concern about bandwidth spikes doesn't exist, but if a node has 1000 connections, perhaps it does.",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-392184018,392184018,
gmaxwell,2018-05-25T21:32:18Z,"@sdaftuar  The suggestion I was leaning towards making but couldn't justify strongly was to multiply the  interval for inbound peers by 2 and have 4 groups-- so that each of the 4 groups gets serviced 4x less often than a outbound peer .     This would make an inbound oriented attacker get as much information from their inbound attack as being a attacker on a single outbound connection. \n\nI wo",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-392192843,392192843,
sipa,2018-05-28T01:46:37Z,"> Well the attacker decides to connect to you, so naively doing that would be foolish since he could just get more information that way.\n\nUh, of course. Ignore my suggestion.\n\n> The suggestion I was leaning towards making but couldn't justify strongly was to multiply the interval for inbound peers by 2 and have 4 groups-- so that each of the 4 groups gets serviced 4x less often than a outb",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-392397988,392397988,
sdaftuar,2018-06-06T02:20:57Z,"I've been doing some more simulations on this recently.  I still don't have good results for the graph-aware estimators that (in theory) should be pretty powerful.  But I did want to share a couple other results on the first spy estimator:\n\nFirst my previously reported simulations were more optimistic than I realized, because I was just modeling the effect of limiting the number of connections",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-394918763,394918763,
naumenkogs,2018-06-07T18:13:56Z,"I've run a simulation to figure out how accurate might be a simple first-time spy under different conditions.\n\nI've used a network of 1000 nodes only (random graphs, 8 outgoing connections), so you can consider the results as upper bound comparing to the real Bitcoin network. (cause more nodes will introduce noise)\n500 simulations.\n\nI've considered an attacker that connects to all of the",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-395515242,395515242,
naumenkogs,2018-06-14T01:21:16Z,"I've measured how R affects propagation delay. From my measurements, it looks like the difference is within 25-40% for R=2 comparing to R=4 (I think that's a lot, but probably acceptable for now), and the distribution of values (50% 75% 99% 100%) is similar for different number of buckets as well as different R. \n\nAnother point I've found is *number of buckets itself does not affect propagatio",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-397137042,397137042,
naumenkogs,2018-06-14T17:36:45Z,"I was also wondering *what if an attacker has control over 1 of 8 outgoing connections per each peer in the network*.\n\nIn this case, modifying R does not make any difference: success rate is 37-40% for 1 or 2 bucket scenario (worst case for a spy) for R=2, 4, 8. Success rate for R=8 grows a bit slower with number of buckets comparing  to R = 2, but not significantly (~5-10%).\n\nHaving less ",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-397377622,397377622,
naumenkogs,2018-07-03T19:36:53Z,"Here are my results on spikes.\n\n### Meta\n\nThe graph represents the distribution of times when a random public-IP node in the network sends INVs to its peers.\n\nI used 1 tx/s for simulation (to get real bandwidth numbers below I believe we should multiply by 3 as this would be closer to the current tx rate, the bandwidth numbers presented in this message are already multiplied by 3), 500",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-402269863,402269863,
naumenkogs,2018-07-07T00:03:58Z,"[Here](https://docs.google.com/spreadsheets/d/1N6rhUfQv4gz_mwzmN5m5FKyc1xYGrzKT04Zw0LGK8gQ/edit#gid=0) are my experimental results on propagation delay.\n\nThis was discussed on bitcoin irc with @gmaxwell and @sipa.\n\nAt first, the fact that number of buckets does not matter much was questioned. You can see precise results now. 1 bucket comparing to 8 is 20-25% worse for 50% coverage, and 5-1",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-403173553,403173553,
gmaxwell,2018-07-10T15:45:02Z,"Anyone oppose changing this to 1 bucket? it would let you simplify the code. e.g. I think the map could be eliminated, etc... just the shared inbound peer state. I think the 18kb/s spikes are okay, we'll do much worse when a compact-block-cold peer requests a block from us...",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-403870717,403870717,
gmaxwell,2018-07-12T22:12:28Z,"ACK.  Though if you change it again you might want to rename the function to *Inbound instead of *To  since it no longer takes a To argument.  If you do, you should brace the if per the developer notes-- multi-line ifs should always be braced.  (My ACK applies with or without these changes).",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404667133,404667133,
gmaxwell,2018-07-13T18:07:58Z,re-ACK,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404910523,404910523,
jamesob,2018-07-13T18:56:00Z,"utACK https://github.com/bitcoin/bitcoin/pull/13298/commits/efa0092979691492218e90c80e366957cb6b97db\n\nShould the PR description be updated to clarify that we're going with a 1-bucket approach? I had to wade through the comment thread to verify that was the intent.",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404922734,404922734,
sipa,2018-07-13T21:28:50Z,utACK 2a361eb7d5832ec7e7dabccfb32dcbf815fad049; just nits.,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404958839,404958839,
jamesob,2018-07-13T21:58:22Z,utACK https://github.com/bitcoin/bitcoin/commit/2a361eb7d5832ec7e7dabccfb32dcbf815fad049,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404964421,404964421,
gmaxwell,2018-07-13T21:58:42Z,re-ACK,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404964498,404964498,
sdaftuar,2018-07-13T23:11:54Z,"utACK, sorry I let this slip, I have a bunch of simulation results that I had been meaning to revisit and summarize here (and I haven't had a chance to really go through @naumenkogs's latest results) but my short thought is that 1 bucket for inbound peers is probably the right answer and at any rate this is a substantial improvement compared with current behavior.\n\nACK'ing now so that we can g",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-404976005,404976005,
sipa,2018-07-14T20:51:47Z,re-utACK d45b344ffd46b0226449cbd46cdaff9577402cf0,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-405049101,405049101,
gmaxwell,2018-07-15T09:42:00Z,re-ACK,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-405079349,405079349,
jimpo,2018-07-16T16:25:37Z,utACK d45b344,https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-405305020,405305020,
Empact,2018-07-16T20:01:29Z,"Looks like github is having some issues, but this has been merged in: f8d470e24606297dab95e30b1d39ff664fbda31d",https://github.com/bitcoin/bitcoin/pull/13298#issuecomment-405363664,405363664,
gmaxwell,2018-05-21T19:21:21Z,I think for IPv6 this could be a slightly far-fetched memory exhaustion DOS.,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189687756,189687756,src/net.cpp
Empact,2018-05-21T20:47:59Z,"`const CNode*`, alternatively pass the net_group",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189709300,189709300,src/net.h
Empact,2018-05-21T20:48:00Z,nit: `include <map>`,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189709307,189709307,src/net.h
sipa,2018-05-21T22:37:27Z,"I think it's suboptimal to put knowledge of the actual scheduling policy in net; it belongs more in net_processing (the `INVENTORY_BROADCAST_INTERVAL` and `NETWORK_GROUP_BUCKETS` should move there as well, I think).\n\nHow about passing a boolean `per_group` in, or saying that when `net_group = 0` there is no grouping to be done? Then you can keep the decision logic in net_processing, and keep t",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189733029,189733029,src/net.cpp
sipa,2018-05-21T23:45:15Z,I think this needs to be inverted.,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189743568,189743568,src/net_processing.cpp
sipa,2018-05-21T23:47:47Z,"Without the interval size in the map, the correctness of this function depends on there only being a single interval (which is the case now, so no problem). It would be good to document that in the net.h definition, or change it.",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r189743885,189743885,src/net.cpp
jimpo,2018-06-03T17:49:03Z,I believe these can all go in `net_processing.cpp` instead of the header file.,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r192597487,192597487,src/net_processing.h
jimpo,2018-06-03T18:03:08Z,"Since that is the case, maybe `average_interval_seconds` should be removed as a parameter and just use the `INVENTORY_BROADCAST_INTERVAL` constant directly.",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r192597834,192597834,src/net.cpp
jimpo,2018-06-03T18:08:04Z,"For the sake of encapsulation, I think you can put more of this logic into `int64_t CConnman::PoissonNextSendTo(int64_t now, CNode* node)`, including the check on `fInbound` and the half delay comment.",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r192597938,192597938,src/net_processing.cpp
sipa,2018-07-05T19:57:16Z,"@jimpo Does this comment still apply? `CConnman::PoissonNextSendTo` doesn't take a `CNode*` argument anymore, and I think it's better separation to keep the logic for determining the interval separate from the logic for computing the next send.",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r200472200,200472200,src/net_processing.cpp
jimpo,2018-07-05T21:17:55Z,@naumenkogs This has not been addressed.,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r200492629,200492629,src/net_processing.h
jimpo,2018-07-05T21:24:18Z,"I'd still prefer a separate method for these four lines `CConnman::PoissonNextSendTo(int64_t now, CNode* node)`. Certainly having the separate `PoissonNextSend` which actually computes the interval is a good idea (which already exists), but `CConnman::PoissonNextSendTo` as defined currently just does the interval caching by netgroup. I find the interface weird and I don't understand the split betw",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r200494066,200494066,src/net_processing.cpp
jamesob,2018-07-13T18:51:25Z,(comment addressed AFAICT),https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202442333,202442333,src/net_processing.cpp
sipa,2018-07-13T18:56:22Z,"Given that you're reading from the atomic variable multiple times here, there is a risk that it was updated by two threads in parallel, resulting in two different timestamps being returned from this function - which would break the independence of sends between nodes.\n\nThis is a highly unlikely event, and it may even be impossible for now (due to limited threading in the network handing code).",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202443594,202443594,src/net.cpp
instagibbs,2018-07-13T19:28:38Z,mu-nit: use `m_` prefix for member variable,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202450918,202450918,src/net.h
Empact,2018-07-13T20:33:28Z,"nit: non-standard indentation here and elsewhere, clang-format will fix",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202465475,202465475,src/net.cpp
Empact,2018-07-13T20:42:06Z,"Agree with @jimpo, [these can](https://github.com/bitcoin/bitcoin/pull/13298/commits/efa0092979691492218e90c80e366957cb6b97db#r192597487) move to net_processing.cpp",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202467552,202467552,src/net_processing.h
Empact,2018-07-13T20:49:01Z,mu-nit: this comment would be slightly more relevant in the else block,https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202469090,202469090,src/net_processing.cpp
sipa,2018-07-13T21:27:48Z,"Agree, and additionally they can become `constexpr`.",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202477167,202477167,src/net_processing.h
sipa,2018-07-14T02:39:42Z,"This sounds a bit contradictory: if there is a theoretical possibility, then it is not impossible.\n\nPerhaps you can say ""If this function were called from multiple threads simultaneously it would possible that both update the next send variable, and return a different result to their caller. This is not possible in practice as only the net processing thread invokes this function.""?",https://github.com/bitcoin/bitcoin/pull/13298#discussion_r202503644,202503644,src/net.cpp
