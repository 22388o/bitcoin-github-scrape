[
  {
    "sha": "87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4N2NiZGI4YjQxZWVlNDA2NzAyM2NmYTBkOWQ2ODcyMmRhNzRhNWVi",
    "commit": {
      "author": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2015-04-17T12:19:21Z"
      },
      "committer": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2015-10-30T13:07:30Z"
      },
      "message": "Globals: Explicit Consensus::Params arg for main:\n\n-CheckBlockIndex\n-DisconnectTip\n-GetTransaction\n-InvalidateBlock\n-ProcessGetData\n-ReadBlockFromDisk",
      "tree": {
        "sha": "2da5f329b57e2b9624db73407ec70fca187f0888",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2da5f329b57e2b9624db73407ec70fca187f0888"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "725539ea03769416d3502feeb4dfcbec3fbb7ae0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/725539ea03769416d3502feeb4dfcbec3fbb7ae0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/725539ea03769416d3502feeb4dfcbec3fbb7ae0"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 52,
      "deletions": 45
    },
    "files": [
      {
        "sha": "4470cd73365aed5b29360b12b38e337755c3eb23",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 29,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -92,7 +92,7 @@ void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n  * in the last Consensus::Params::nMajorityWindow blocks, starting at pstart and going backwards.\n  */\n static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams);\n-static void CheckBlockIndex();\n+static void CheckBlockIndex(const Consensus::Params& consensusParams);\n \n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n@@ -998,7 +998,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n }\n \n /** Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock */\n-bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock, bool fAllowSlow)\n+bool GetTransaction(const uint256 &hash, CTransaction &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)\n {\n     CBlockIndex *pindexSlow = NULL;\n \n@@ -1044,7 +1044,7 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n \n     if (pindexSlow) {\n         CBlock block;\n-        if (ReadBlockFromDisk(block, pindexSlow)) {\n+        if (ReadBlockFromDisk(block, pindexSlow, consensusParams)) {\n             BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n                 if (tx.GetHash() == hash) {\n                     txOut = tx;\n@@ -1089,7 +1089,7 @@ bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHea\n     return true;\n }\n \n-bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos)\n+bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams)\n {\n     block.SetNull();\n \n@@ -1107,15 +1107,15 @@ bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos)\n     }\n \n     // Check the header\n-    if (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus()))\n+    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n         return error(\"ReadBlockFromDisk: Errors in block header at %s\", pos.ToString());\n \n     return true;\n }\n \n-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n+bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n {\n-    if (!ReadBlockFromDisk(block, pindex->GetBlockPos()))\n+    if (!ReadBlockFromDisk(block, pindex->GetBlockPos(), consensusParams))\n         return false;\n     if (block.GetHash() != pindex->GetBlockHash())\n         return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n@@ -2064,13 +2064,14 @@ void static UpdateTip(CBlockIndex *pindexNew) {\n }\n \n /** Disconnect chainActive's tip. You want to manually re-limit mempool size after this */\n-bool static DisconnectTip(CValidationState &state) {\n+bool static DisconnectTip(CValidationState& state, const Consensus::Params& consensusParams)\n+{\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n     mempool.check(pcoinsTip);\n     // Read block from disk.\n     CBlock block;\n-    if (!ReadBlockFromDisk(block, pindexDelete))\n+    if (!ReadBlockFromDisk(block, pindexDelete, consensusParams))\n         return AbortNode(state, \"Failed to read block\");\n     // Apply the block atomically to the chain state.\n     int64_t nStart = GetTimeMicros();\n@@ -2125,13 +2126,14 @@ static int64_t nTimePostConnect = 0;\n  * corresponding to pindexNew, to bypass loading it again from disk.\n  */\n bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, const CBlock *pblock) {\n+    const CChainParams& chainparams = Params();\n     assert(pindexNew->pprev == chainActive.Tip());\n     mempool.check(pcoinsTip);\n     // Read block from disk.\n     int64_t nTime1 = GetTimeMicros();\n     CBlock block;\n     if (!pblock) {\n-        if (!ReadBlockFromDisk(block, pindexNew))\n+        if (!ReadBlockFromDisk(block, pindexNew, chainparams.GetConsensus()))\n             return AbortNode(state, \"Failed to read block\");\n         pblock = &block;\n     }\n@@ -2257,6 +2259,7 @@ static void PruneBlockIndexCandidates() {\n  * pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n  */\n static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMostWork, const CBlock *pblock) {\n+    const CChainParams& chainparams = Params();\n     AssertLockHeld(cs_main);\n     bool fInvalidFound = false;\n     const CBlockIndex *pindexOldTip = chainActive.Tip();\n@@ -2265,7 +2268,7 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n     while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n-        if (!DisconnectTip(state))\n+        if (!DisconnectTip(state, chainparams.GetConsensus()))\n             return false;\n         fBlocksDisconnected = true;\n     }\n@@ -2333,7 +2336,7 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n     CBlockIndex *pindexNewTip = NULL;\n     CBlockIndex *pindexMostWork = NULL;\n-    const CChainParams& chainParams = Params();\n+    const CChainParams& chainparams = Params();\n     do {\n         boost::this_thread::interruption_point();\n \n@@ -2360,7 +2363,7 @@ bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n             // Relay inventory, but don't relay old inventory during initial block download.\n             int nBlockEstimate = 0;\n             if (fCheckpointsEnabled)\n-                nBlockEstimate = Checkpoints::GetTotalBlocksEstimate(chainParams.Checkpoints());\n+                nBlockEstimate = Checkpoints::GetTotalBlocksEstimate(chainparams.Checkpoints());\n             {\n                 LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n@@ -2372,7 +2375,7 @@ bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n             uiInterface.NotifyBlockTip(hashNewTip);\n         }\n     } while(pindexMostWork != chainActive.Tip());\n-    CheckBlockIndex();\n+    CheckBlockIndex(chainparams.GetConsensus());\n \n     // Write changes periodically to disk, after relay.\n     if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC)) {\n@@ -2382,7 +2385,8 @@ bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n     return true;\n }\n \n-bool InvalidateBlock(CValidationState& state, CBlockIndex *pindex) {\n+bool InvalidateBlock(CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex *pindex)\n+{\n     AssertLockHeld(cs_main);\n \n     // Mark the block itself as invalid.\n@@ -2397,7 +2401,7 @@ bool InvalidateBlock(CValidationState& state, CBlockIndex *pindex) {\n         setBlockIndexCandidates.erase(pindexWalk);\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n-        if (!DisconnectTip(state)) {\n+        if (!DisconnectTip(state, consensusParams)) {\n             return false;\n         }\n     }\n@@ -2899,6 +2903,7 @@ static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned\n \n bool ProcessNewBlock(CValidationState &state, const CNode* pfrom, const CBlock* pblock, bool fForceProcessing, CDiskBlockPos *dbp)\n {\n+    const CChainParams& chainparams = Params();\n     // Preliminary checks\n     bool checked = CheckBlock(*pblock, state);\n \n@@ -2916,7 +2921,7 @@ bool ProcessNewBlock(CValidationState &state, const CNode* pfrom, const CBlock*\n         if (pindex && pfrom) {\n             mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n         }\n-        CheckBlockIndex();\n+        CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret)\n             return error(\"%s: AcceptBlock FAILED\", __func__);\n     }\n@@ -3248,6 +3253,7 @@ CVerifyDB::~CVerifyDB()\n \n bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth)\n {\n+    const CChainParams& chainparams = Params();\n     LOCK(cs_main);\n     if (chainActive.Tip() == NULL || chainActive.Tip()->pprev == NULL)\n         return true;\n@@ -3272,7 +3278,7 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n             break;\n         CBlock block;\n         // check level 0: read from disk\n-        if (!ReadBlockFromDisk(block, pindex))\n+        if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n             return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 1: verify block validity\n         if (nCheckLevel >= 1 && !CheckBlock(block, state))\n@@ -3312,7 +3318,7 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n             uiInterface.ShowProgress(_(\"Verifying blocks...\"), std::max(1, std::min(99, 100 - (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * 50))));\n             pindex = chainActive.Next(pindex);\n             CBlock block;\n-            if (!ReadBlockFromDisk(block, pindex))\n+            if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             if (!ConnectBlock(block, state, pindex, coins))\n                 return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -3485,7 +3491,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n                     while (range.first != range.second) {\n                         std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n-                        if (ReadBlockFromDisk(block, it->second))\n+                        if (ReadBlockFromDisk(block, it->second, chainparams.GetConsensus()))\n                         {\n                             LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n                                     head.ToString());\n@@ -3512,9 +3518,8 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n     return nLoaded > 0;\n }\n \n-void static CheckBlockIndex()\n+void static CheckBlockIndex(const Consensus::Params& consensusParams)\n {\n-    const Consensus::Params& consensusParams = Params().GetConsensus();\n     if (!fCheckBlockIndex) {\n         return;\n     }\n@@ -3796,7 +3801,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     return true;\n }\n \n-void static ProcessGetData(CNode* pfrom)\n+void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n \n@@ -3851,7 +3856,7 @@ void static ProcessGetData(CNode* pfrom)\n                 {\n                     // Send block from disk\n                     CBlock block;\n-                    if (!ReadBlockFromDisk(block, (*mi).second))\n+                    if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n                         pfrom->PushMessage(\"block\", block);\n@@ -4243,7 +4248,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             LogPrint(\"net\", \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n-        ProcessGetData(pfrom);\n+        ProcessGetData(pfrom, chainparams.GetConsensus());\n     }\n \n \n@@ -4509,7 +4514,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256());\n         }\n \n-        CheckBlockIndex();\n+        CheckBlockIndex(chainparams.GetConsensus());\n     }\n \n     else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n@@ -4793,6 +4798,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n // requires LOCK(cs_vRecvMsg)\n bool ProcessMessages(CNode* pfrom)\n {\n+    const CChainParams& chainparams = Params();\n     //if (fDebug)\n     //    LogPrintf(\"%s(%u messages)\\n\", __func__, pfrom->vRecvMsg.size());\n \n@@ -4807,7 +4813,7 @@ bool ProcessMessages(CNode* pfrom)\n     bool fOk = true;\n \n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(pfrom);\n+        ProcessGetData(pfrom, chainparams.GetConsensus());\n \n     // this maintains the order of responses\n     if (!pfrom->vRecvGetData.empty()) return fOk;\n@@ -4834,15 +4840,15 @@ bool ProcessMessages(CNode* pfrom)\n         it++;\n \n         // Scan for message start\n-        if (memcmp(msg.hdr.pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE) != 0) {\n+        if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), MESSAGE_START_SIZE) != 0) {\n             LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->id);\n             fOk = false;\n             break;\n         }\n \n         // Read header\n         CMessageHeader& hdr = msg.hdr;\n-        if (!hdr.IsValid(Params().MessageStart()))\n+        if (!hdr.IsValid(chainparams.MessageStart()))\n         {\n             LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n             continue;"
      },
      {
        "sha": "f3c5dac1a3346431c4f16ce8398c634c89f5608d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -189,7 +189,7 @@ bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core */\n std::string GetWarnings(const std::string& strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n+bool GetTransaction(const uint256 &hash, CTransaction &tx, const Consensus::Params& params, uint256 &hashBlock, bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n bool ActivateBestChain(CValidationState &state, const CBlock *pblock = NULL);\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n@@ -350,9 +350,8 @@ class CScriptCheck\n \n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);\n-bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos);\n-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n-\n+bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n+bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);\n \n /** Functions for validating blocks and updating the block tree */\n \n@@ -378,8 +377,7 @@ bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex\n \n /** Store block on disk. If dbp is non-NULL, the file is known to already reside on disk */\n bool AcceptBlock(const CBlock& block, CValidationState& state, CBlockIndex **pindex, bool fRequested, CDiskBlockPos* dbp);\n-bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n-\n+bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex **ppindex= NULL);\n \n \n class CBlockFileInfo\n@@ -448,7 +446,7 @@ class CVerifyDB {\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n \n /** Mark a block as invalid. */\n-bool InvalidateBlock(CValidationState& state, CBlockIndex *pindex);\n+bool InvalidateBlock(CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex *pindex);\n \n /** Remove invalidity status from a block and its descendants. */\n bool ReconsiderBlock(CValidationState& state, CBlockIndex *pindex);"
      },
      {
        "sha": "5d69542a913b5d62c2ff94d65a95970c361d2e3b",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"chain.h\"\n+#include \"chainparams.h\"\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"main.h\"\n@@ -223,7 +224,7 @@ static bool rest_block(HTTPRequest* req,\n         if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n-        if (!ReadBlockFromDisk(block, pblockindex))\n+        if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n     }\n \n@@ -360,7 +361,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n \n     CTransaction tx;\n     uint256 hashBlock = uint256();\n-    if (!GetTransaction(hash, tx, hashBlock, true))\n+    if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n         return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n \n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "685d66d2d9f6ac9478edb75113f44bce11cead38",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -405,7 +405,7 @@ UniValue getblock(const UniValue& params, bool fHelp)\n     if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Block not available (pruned data)\");\n \n-    if(!ReadBlockFromDisk(block, pblockindex))\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n \n     if (!fVerbose)\n@@ -824,7 +824,7 @@ UniValue invalidateblock(const UniValue& params, bool fHelp)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n \n         CBlockIndex* pblockindex = mapBlockIndex[hash];\n-        InvalidateBlock(state, pblockindex);\n+        InvalidateBlock(state, Params().GetConsensus(), pblockindex);\n     }\n \n     if (state.IsValid()) {"
      },
      {
        "sha": "11d9a6f2bbd2824b20245663e03b6dd8a3f8cacb",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -186,7 +186,7 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n \n     CTransaction tx;\n     uint256 hashBlock;\n-    if (!GetTransaction(hash, tx, hashBlock, true))\n+    if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n \n     string strHex = EncodeHexTx(tx);\n@@ -256,15 +256,15 @@ UniValue gettxoutproof(const UniValue& params, bool fHelp)\n     if (pblockindex == NULL)\n     {\n         CTransaction tx;\n-        if (!GetTransaction(oneTxid, tx, hashBlock, false) || hashBlock.IsNull())\n+        if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n         if (!mapBlockIndex.count(hashBlock))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\n         pblockindex = mapBlockIndex[hashBlock];\n     }\n \n     CBlock block;\n-    if(!ReadBlockFromDisk(block, pblockindex))\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n \n     unsigned int ntxFound = 0;"
      },
      {
        "sha": "e81b1daf526fd2f5c235686bc8a469c9f1100560",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -1078,7 +1078,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false) - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n \n             CBlock block;\n-            ReadBlockFromDisk(block, pindex);\n+            ReadBlockFromDisk(block, pindex, Params().GetConsensus());\n             BOOST_FOREACH(CTransaction& tx, block.vtx)\n             {\n                 if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))"
      },
      {
        "sha": "ac788843ebdeda99d5160ccf7cf6584ffe873ec4",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87cbdb8b41eee4067023cfa0d9d68722da74a5eb/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=87cbdb8b41eee4067023cfa0d9d68722da74a5eb",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"chainparams.h\"\n #include \"zmqpublishnotifier.h\"\n #include \"main.h\"\n #include \"util.h\"\n@@ -142,11 +143,12 @@ bool CZMQPublishRawBlockNotifier::NotifyBlock(const CBlockIndex *pindex)\n {\n     LogPrint(\"zmq\", \"Publish raw block %s\\n\", pindex->GetBlockHash().GetHex());\n \n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n     {\n         LOCK(cs_main);\n         CBlock block;\n-        if(!ReadBlockFromDisk(block, pindex))\n+        if(!ReadBlockFromDisk(block, pindex, consensusParams))\n         {\n             zmqError(\"Can't read block from disk\");\n             return false;"
      }
    ]
  }
]