[
  {
    "sha": "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNjM5YzNiNzZjM2YyYjc0NjA2ZjYyZWNkM2NhNzI1MTU0ZTI3ZjFi",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-16T08:35:45Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-19T05:05:21Z"
      },
      "message": "tests: Add fuzzing harness for versionbits",
      "tree": {
        "sha": "47ba32a48a5f10937c7a04e9cac2e2f7029be80a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47ba32a48a5f10937c7a04e9cac2e2f7029be80a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1639c3b76c3f2b74606f62ecd3ca725154e27f1b/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3b408d21e0938b08ef8dfc79b45508421638988c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b408d21e0938b08ef8dfc79b45508421638988c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3b408d21e0938b08ef8dfc79b45508421638988c"
      }
    ],
    "stats": {
      "total": 348,
      "additions": 347,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7ed0eafb14ec0c22e4e14b593b0b62c3c2cb1af6",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1639c3b76c3f2b74606f62ecd3ca725154e27f1b/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1639c3b76c3f2b74606f62ecd3ca725154e27f1b/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
        "patch": "@@ -298,7 +298,8 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/tx_in.cpp \\\n  test/fuzz/tx_out.cpp \\\n  test/fuzz/txrequest.cpp \\\n- test/fuzz/validation_load_mempool.cpp\n+ test/fuzz/validation_load_mempool.cpp \\\n+ test/fuzz/versionbits.cpp\n endif # ENABLE_FUZZ_BINARY\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "a898e2782db5141622a36391eabfbf8de5a6011a",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "added",
        "additions": 345,
        "deletions": 0,
        "changes": 345,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1639c3b76c3f2b74606f62ecd3ca725154e27f1b/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1639c3b76c3f2b74606f62ecd3ca725154e27f1b/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
        "patch": "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);\n+    assert(exp_since <= prev_next_height);\n+\n+    // mine (period-1) blocks and check state\n+    for (int b = 1; b < period; ++b) {\n+        const bool signal = (signalling_mask >> (b % 32)) & 1;\n+        if (signal) ++blocks_sig;\n+\n+        CBlockIndex* current_block = blocks.mine_block(signal);\n+\n+        // verify that signalling attempt was interpreted correctly\n+        assert(checker.Condition(current_block) == signal);\n+\n+        // state and since don't change within the period\n+        const ThresholdState state = checker.GetStateFor(current_block);\n+        const int since = checker.GetStateSinceHeightFor(current_block);\n+        assert(state == exp_state);\n+        assert(since == exp_since);\n+\n+        // GetStateStatistics may crash when state is not STARTED\n+        if (state != ThresholdState::STARTED) continue;\n+\n+        // check that after mining this block stats change as expected\n+        const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+        assert(stats.period == period);\n+        assert(stats.threshold == threshold);\n+        assert(stats.elapsed == b);\n+        assert(stats.count == last_stats.count + (signal ? 1 : 0));\n+        assert(stats.possible == (stats.count + period >= stats.elapsed + threshold));\n+        last_stats = stats;\n+    }\n+\n+    if (exp_state == ThresholdState::STARTED) {\n+        // double check that stats.possible is sane\n+        if (blocks_sig >= threshold - 1) assert(last_stats.possible);\n+    }\n+\n+    // mine the final block\n+    bool signal = (signalling_mask >> (period % 32)) & 1;\n+    if (signal) ++blocks_sig;\n+    CBlockIndex* current_block = blocks.mine_block(signal);\n+    assert(checker.Condition(current_block) == signal);\n+\n+    // GetStateStatistics is safe on a period boundary\n+    // and has progressed to a new period\n+    const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+    assert(stats.period == period);\n+    assert(stats.threshold == threshold);\n+    assert(stats.elapsed == 0);\n+    assert(stats.count == 0);\n+    assert(stats.possible == true);\n+\n+    // More interesting is whether the state changed.\n+    const ThresholdState state = checker.GetStateFor(current_block);\n+    const int since = checker.GetStateSinceHeightFor(current_block);\n+\n+    // since is straightforward:\n+    assert(since % period == 0);\n+    assert(0 <= since && since <= current_block->nHeight + 1);\n+    if (state == exp_state) {\n+        assert(since == exp_since);\n+    } else {\n+        assert(since == current_block->nHeight + 1);\n+    }\n+\n+    // state is where everything interesting is\n+    switch (state) {\n+    case ThresholdState::DEFINED:\n+        assert(since == 0);\n+        assert(exp_state == ThresholdState::DEFINED);\n+        assert(current_block->GetMedianTimePast() < checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        break;\n+    case ThresholdState::STARTED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        if (exp_state == ThresholdState::STARTED) {\n+            assert(blocks_sig < threshold);\n+        } else {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        }\n+        break;\n+    case ThresholdState::LOCKED_IN:\n+        assert(exp_state == ThresholdState::STARTED);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        assert(blocks_sig >= threshold);\n+        break;\n+    case ThresholdState::ACTIVE:\n+        assert(exp_state == ThresholdState::ACTIVE || exp_state == ThresholdState::LOCKED_IN);\n+        break;\n+    case ThresholdState::FAILED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_end);\n+        assert(exp_state != ThresholdState::LOCKED_IN && exp_state != ThresholdState::ACTIVE);\n+        break;\n+    default:\n+        assert(false);\n+    }\n+\n+    if (blocks.size() >= max_periods * period) {\n+        // we chose the timeout (and block times) so that by the time we have this many blocks it's all over\n+        assert(state == ThresholdState::ACTIVE || state == ThresholdState::FAILED);\n+    }\n+\n+    // \"always active\" has additional restrictions\n+    if (always_active_test) {\n+        assert(state == ThresholdState::ACTIVE);\n+        assert(exp_state == ThresholdState::ACTIVE);\n+        assert(since == 0);\n+    } else {\n+        // except for always active, the initial state is always DEFINED\n+        assert(since > 0 || state == ThresholdState::DEFINED);\n+        assert(exp_since > 0 || exp_state == ThresholdState::DEFINED);\n+    }\n+\n+    // \"never active\" does too\n+    if (never_active_test) {\n+        assert(state == ThresholdState::FAILED);\n+        assert(since == period);\n+        if (exp_since == 0) {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        } else {\n+            assert(exp_state == ThresholdState::FAILED);\n+        }\n+    }\n+}"
      }
    ]
  }
]