[
  {
    "sha": "0232c07c822b2eb3ef2910962db75b0e6e91a54b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjMyYzA3YzgyMmIyZWIzZWYyOTEwOTYyZGI3NWIwZTZlOTFhNTRi",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-12T21:38:43Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "message": "CheckQueue: Add size constants to validation.{h,cpp}.\nUpdate code to pass MAX_SCRIPTCHECKS_PER_BLOCK to CCheckQueueControl",
      "tree": {
        "sha": "ad92a0ab88e06cf051e6a16254358674608b8c34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad92a0ab88e06cf051e6a16254358674608b8c34"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5114f8113627791b871c88998bd5a3d36961c241",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5114f8113627791b871c88998bd5a3d36961c241",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5114f8113627791b871c88998bd5a3d36961c241"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 30,
      "deletions": 18
    },
    "files": [
      {
        "sha": "8c5fe3345d6ac270371b59a30e491f8a7351e462",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -35,7 +35,7 @@ static void CCheckQueueSpeed(benchmark::State& state)\n        tg.create_thread([&]{queue.Thread();});\n     }\n     while (state.KeepRunning()) {\n-        CCheckQueueControl<FakeJobNoWork> control(&queue);\n+        CCheckQueueControl<FakeJobNoWork> control(&queue, MAX_SCRIPTCHECKS_PER_BLOCK);\n \n         // We call Add a number of times to simulate the behavior of adding\n         // a block of transactions at once.\n@@ -84,7 +84,7 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     while (state.KeepRunning()) {\n         // Make insecure_rand here so that each iteration is identical.\n         FastRandomContext insecure_rand(true);\n-        CCheckQueueControl<PrevectorJob> control(&queue);\n+        CCheckQueueControl<PrevectorJob> control(&queue, MAX_SCRIPTCHECKS_PER_BLOCK);\n         std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n         for (auto& vChecks : vBatches) {\n             vChecks.reserve(BATCH_SIZE);"
      },
      {
        "sha": "215d93767e7d8ac9710d13dbf272627b032f8b05",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -181,7 +181,7 @@ class CCheckQueueControl\n     CCheckQueueControl() = delete;\n     CCheckQueueControl(const CCheckQueueControl&) = delete;\n     CCheckQueueControl& operator=(const CCheckQueueControl&) = delete;\n-    explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn) : pqueue(pqueueIn), fDone(false)\n+    explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn, const unsigned int size) : pqueue(pqueueIn), fDone(false)\n     {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {"
      },
      {
        "sha": "0cf7ded952323d3cf6cb0ae6171a88816bdef8b7",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -158,7 +158,7 @@ void Correct_Queue_range(std::vector<size_t> range)\n     for (auto i : range) {\n         size_t total = i;\n         FakeCheckCheckCompletion::n_calls = 0;\n-        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n         while (total) {\n             vChecks.resize(std::min(total, (size_t) GetRand(10)));\n             total -= vChecks.size();\n@@ -195,17 +195,19 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n {\n     std::vector<size_t> range;\n-    range.push_back(100000);\n+    range.push_back(MAX_SCRIPTCHECKS_PER_BLOCK);\n     Correct_Queue_range(range);\n }\n /** Test that random numbers of checks are correct\n  */\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n {\n     std::vector<size_t> range;\n-    range.reserve(100000/1000);\n-    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+    range.reserve(MAX_SCRIPTCHECKS_PER_BLOCK/1000);\n+    for (size_t i = 2; i < MAX_SCRIPTCHECKS_PER_BLOCK;\n+            i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)MAX_SCRIPTCHECKS_PER_BLOCK) - i)))) {\n         range.push_back(i);\n+    }\n     Correct_Queue_range(range);\n }\n \n@@ -221,7 +223,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n     }\n \n     for (size_t i = 0; i < 1001; ++i) {\n-        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n         size_t remaining = i;\n         while (remaining) {\n             size_t r = GetRand(10);\n@@ -254,7 +256,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n \n     for (auto times = 0; times < 10; ++times) {\n         for (bool end_fails : {true, false}) {\n-            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n             {\n                 std::vector<FailingCheck> vChecks;\n                 vChecks.resize(100, false);\n@@ -281,10 +283,10 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n \n     }\n \n-    size_t COUNT = 100000;\n+    size_t COUNT = MAX_SCRIPTCHECKS_PER_BLOCK;\n     size_t total = COUNT;\n     {\n-        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        CCheckQueueControl<UniqueCheck> control(queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n         while (total) {\n             size_t r = GetRand(10);\n             std::vector<UniqueCheck> vChecks;\n@@ -318,7 +320,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n     for (size_t i = 0; i < 1000; ++i) {\n         size_t total = i;\n         {\n-            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            CCheckQueueControl<MemoryCheck> control(queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n             while (total) {\n                 size_t r = GetRand(10);\n                 std::vector<MemoryCheck> vChecks;\n@@ -348,7 +350,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n         tg.create_thread([&]{queue->Thread();});\n     }\n     std::thread t0([&]() {\n-        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n         std::vector<FrozenCleanupCheck> vChecks(1);\n         // Freezing can't be the default initialized behavior given how the queue\n         // swaps in default initialized Checks (otherwise freezing destructor\n@@ -389,7 +391,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n         for (size_t i = 0; i < 3; ++i) {\n             tg.create_thread(\n                     [&]{\n-                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    CCheckQueueControl<FakeCheck> control(queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n                     // While sleeping, no other thread should execute to this point\n                     auto observed = ++nThreads;\n                     MilliSleep(10);\n@@ -410,7 +412,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n         {\n             std::unique_lock<std::mutex> l(m);\n             tg.create_thread([&]{\n-                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    CCheckQueueControl<FakeCheck> control(queue.get(), MAX_SCRIPTCHECKS_PER_BLOCK);\n                     std::unique_lock<std::mutex> ll(m);\n                     has_lock = true;\n                     cv.notify_one();"
      },
      {
        "sha": "8bf63766286efb032770e2267a89e3e72f3e8205",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -464,7 +464,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     PrecomputedTransactionData txdata(tx);\n     boost::thread_group threadGroup;\n     CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n-    CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue);\n+    CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue, MAX_SCRIPTCHECKS_PER_BLOCK);\n \n     for (int i=0; i<20; i++)\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));"
      },
      {
        "sha": "2b10b92f1d8acab63e285a8adebaf4387196efdf",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -9,7 +9,6 @@\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n-#include \"consensus/consensus.h\"\n #include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n@@ -1834,7 +1833,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     CBlockUndo blockundo;\n \n-    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n+    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL, MAX_SCRIPTCHECKS_PER_BLOCK);\n \n     std::vector<int> prevheights;\n     CAmount nFees = 0;"
      },
      {
        "sha": "7674ce046955a3488305bd68bf4da892da233d8b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0232c07c822b2eb3ef2910962db75b0e6e91a54b/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "patch": "@@ -17,6 +17,7 @@\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n+#include \"consensus/consensus.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -150,6 +151,16 @@ struct BlockHasher\n     size_t operator()(const uint256& hash) const { return hash.GetCheapHash(); }\n };\n \n+\n+/** The minimum serialized size of a CTxIn even with an empty scriptSig */\n+static const unsigned int MIN_TXIN_SERIALIZED_SIZE = 41;\n+/** The maximum number of scriptchecks which an input can generate */\n+static const unsigned int MAX_SCRIPTCHECKS_PER_TXIN = 1;\n+/** The maximum number of possible inputs included a block */\n+static const unsigned int MAX_TXINS_PER_BLOCK = MAX_BLOCK_BASE_SIZE/MIN_TXIN_SERIALIZED_SIZE;\n+/** The maximum number of scriptchecks which could be created */\n+static const unsigned int MAX_SCRIPTCHECKS_PER_BLOCK = MAX_TXINS_PER_BLOCK * MAX_SCRIPTCHECKS_PER_TXIN;\n+\n extern CScript COINBASE_FLAGS;\n extern CCriticalSection cs_main;\n extern CTxMemPool mempool;"
      }
    ]
  },
  {
    "sha": "12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmU5Y2Q0NzJkNDFhY2ZkYTVlMWFlZDVlNTJmYTdjYzQ3YjE3MDYz",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-12T20:33:53Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "message": "CheckQueue: Make the checkqueue's checks \"memory-stable\". Before this commit,\nchecks were stored in three separate vectors. First, a vector was made locally\nto pass to a call to CCheckQueueControl::Add. In that call, checks were added to\nthe main CCheckQueue memory, then each thread had to locally (per batch) put the\ncheck into a new, local vector. This means the location of the Check moved 2\ntimes. In this patch, the check is created in a buffer associated with the\nCCheckQueueControl. Instead of moving the check, a counter is incremented to\nkeep track of which threads have claimed which checks.\n\nAlso updates benchmark to use new in-place CheckQueue API",
      "tree": {
        "sha": "d32cc1d8e970fbf4d8eb5537fa4d061dd1717d8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d32cc1d8e970fbf4d8eb5537fa4d061dd1717d8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0232c07c822b2eb3ef2910962db75b0e6e91a54b"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 99,
      "deletions": 77
    },
    "files": [
      {
        "sha": "a358dce46b9a25e9dd19b6cc06689c5686909e79",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 17,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "patch": "@@ -20,6 +20,7 @@ static const size_t BATCHES = 101;\n static const size_t BATCH_SIZE = 30;\n static const int PREVECTOR_SIZE = 28;\n static const int QUEUE_BATCH_SIZE = 128;\n+static const int QUEUE_SIZE = BATCHES*BATCH_SIZE*5;\n static void CCheckQueueSpeed(benchmark::State& state)\n {\n     struct FakeJobNoWork {\n@@ -35,20 +36,16 @@ static void CCheckQueueSpeed(benchmark::State& state)\n        tg.create_thread([&]{queue.Thread();});\n     }\n     while (state.KeepRunning()) {\n-        CCheckQueueControl<FakeJobNoWork> control(&queue, MAX_SCRIPTCHECKS_PER_BLOCK);\n+        CCheckQueueControl<FakeJobNoWork> control(&queue, QUEUE_SIZE);\n \n         // We call Add a number of times to simulate the behavior of adding\n         // a block of transactions at once.\n \n-        std::vector<std::vector<FakeJobNoWork>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n-            vChecks.resize(BATCH_SIZE);\n-        }\n-        for (auto& vChecks : vBatches) {\n-            // We can't make vChecks in the inner loop because we want to measure\n-            // the cost of getting the memory to each thread and we might get the same\n-            // memory\n-            control.Add(vChecks);\n+        for (size_t x = 0; x < BATCHES; ++x) {\n+            for (size_t y = 0; y < BATCH_SIZE; ++y) {\n+                control.Add();\n+            }\n+            control.Flush(BATCH_SIZE);\n         }\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity\n@@ -84,13 +81,12 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     while (state.KeepRunning()) {\n         // Make insecure_rand here so that each iteration is identical.\n         FastRandomContext insecure_rand(true);\n-        CCheckQueueControl<PrevectorJob> control(&queue, MAX_SCRIPTCHECKS_PER_BLOCK);\n-        std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n-            vChecks.reserve(BATCH_SIZE);\n-            for (size_t x = 0; x < BATCH_SIZE; ++x)\n-                vChecks.emplace_back(insecure_rand);\n-            control.Add(vChecks);\n+        CCheckQueueControl<PrevectorJob> control(&queue, QUEUE_SIZE);\n+        for (size_t x = 0; x < BATCHES; ++x) {\n+            for (size_t y = 0; y < BATCH_SIZE; ++y) {\n+                control.Add(insecure_rand);\n+            }\n+            control.Flush(BATCH_SIZE);\n         }\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity"
      },
      {
        "sha": "f664a9a53534e25946867f9766b17aec2d7ef1bf",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 52,
        "deletions": 28,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "patch": "@@ -41,7 +41,6 @@ class CCheckQueue\n \n     //! The queue of elements to be processed.\n     //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-    std::vector<T> queue;\n \n     //! The number of workers (including the master) that are idle.\n     int nIdle;\n@@ -69,8 +68,7 @@ class CCheckQueue\n     bool Loop(bool fMaster = false)\n     {\n         boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        std::vector<T> vChecks;\n-        vChecks.reserve(nBatchSize);\n+        typename std::vector<T>::iterator checks_iterator;\n         unsigned int nNow = 0;\n         bool fOk = true;\n         do {\n@@ -88,7 +86,7 @@ class CCheckQueue\n                     nTotal++;\n                 }\n                 // logically, the do loop starts here\n-                while (queue.empty()) {\n+                while (check_mem_top == check_mem_bottom) { // while (empty)\n                     if ((fMaster || fQuit) && nTodo == 0) {\n                         nTotal--;\n                         bool fRet = fAllOk;\n@@ -107,22 +105,19 @@ class CCheckQueue\n                 //   all workers finish approximately simultaneously.\n                 // * Try to account for idle jobs which will instantly start helping.\n                 // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n-                vChecks.resize(nNow);\n-                for (unsigned int i = 0; i < nNow; i++) {\n-                    // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n-                    // queue to the local batch vector instead of copying.\n-                    vChecks[i].swap(queue.back());\n-                    queue.pop_back();\n-                }\n+                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n+                checks_iterator = check_mem_bottom;\n+                std::advance(check_mem_bottom, nNow);\n                 // Check whether we need to do work at all\n                 fOk = fAllOk;\n             }\n             // execute work\n-            BOOST_FOREACH (T& check, vChecks)\n-                if (fOk)\n-                    fOk = check();\n-            vChecks.clear();\n+            for (unsigned int i = 0; i < nNow && fOk; i++) {\n+                fOk = (*checks_iterator)();\n+                auto t = T();\n+                checks_iterator->swap(t);\n+                std::advance(checks_iterator, 1);\n+            }\n         } while (true);\n     }\n \n@@ -145,18 +140,25 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n+    typename std::vector<T>::iterator check_mem;\n+    typename std::vector<T>::iterator check_mem_top;\n+    typename std::vector<T>::iterator check_mem_bottom;\n+    void Setup(typename std::vector<T>::iterator check_mem_in) \n+    {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        check_mem = check_mem_in;\n+        check_mem_top = check_mem_in;\n+        check_mem_bottom = check_mem_in;\n+    }\n     //! Add a batch of checks to the queue\n-    void Add(std::vector<T>& vChecks)\n+    void Add(size_t size)\n     {\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH (T& check, vChecks) {\n-            queue.push_back(T());\n-            check.swap(queue.back());\n-        }\n-        nTodo += vChecks.size();\n-        if (vChecks.size() == 1)\n+        check_mem_top += size;\n+        nTodo += size;\n+        if (size == 1)\n             condWorker.notify_one();\n-        else if (vChecks.size() > 1)\n+        else if (size > 1)\n             condWorker.notify_all();\n     }\n \n@@ -174,18 +176,21 @@ template <typename T>\n class CCheckQueueControl\n {\n private:\n-    CCheckQueue<T> * const pqueue;\n+    std::vector<T> check_mem;\n+    CCheckQueue<T>* pqueue;\n     bool fDone;\n \n public:\n     CCheckQueueControl() = delete;\n     CCheckQueueControl(const CCheckQueueControl&) = delete;\n     CCheckQueueControl& operator=(const CCheckQueueControl&) = delete;\n-    explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn, const unsigned int size) : pqueue(pqueueIn), fDone(false)\n+    explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn, const unsigned int size) : check_mem(), pqueue(pqueueIn), fDone(false)\n     {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {\n             ENTER_CRITICAL_SECTION(pqueue->ControlMutex);\n+            check_mem.reserve(size);\n+            pqueue->Setup(check_mem.begin());\n         }\n     }\n \n@@ -200,8 +205,27 @@ class CCheckQueueControl\n \n     void Add(std::vector<T>& vChecks)\n     {\n-        if (pqueue != NULL)\n-            pqueue->Add(vChecks);\n+        if (pqueue != NULL) {\n+            auto s = vChecks.size();\n+            for (T& x : vChecks) {\n+                check_mem.emplace_back();\n+                check_mem.back().swap(x);\n+            }\n+            pqueue->Add(s);\n+        }\n+    }\n+    template<typename ... Args>\n+    void Add(Args && ... args)\n+    {\n+        if (pqueue != NULL) {\n+            check_mem.emplace_back(std::forward<Args>(args)...);\n+        }\n+    }\n+    void Flush(size_t s)\n+    {\n+        if (pqueue != NULL) {\n+            pqueue->Add(s);\n+        }\n     }\n \n     ~CCheckQueueControl()"
      },
      {
        "sha": "f0c5f70b1c770df26326675de1e9036ae214abf0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 31,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "patch": "@@ -1388,16 +1388,13 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, CCheckQueueControl<CScriptCheck> *pCheckQueueControl)\n {\n     if (!tx.IsCoinBase())\n     {\n         if (!Consensus::CheckTxInputs(tx, state, inputs, GetSpendHeight(inputs)))\n             return false;\n \n-        if (pvChecks)\n-            pvChecks->reserve(tx.vin.size());\n-\n         // The first loop above does all the inexpensive checks.\n         // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n         // Helps prevent CPU exhaustion attacks.\n@@ -1414,33 +1411,37 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check(*coins, tx, i, flags, cacheStore, &txdata);\n-                if (pvChecks) {\n-                    pvChecks->push_back(CScriptCheck());\n-                    check.swap(pvChecks->back());\n-                } else if (!check()) {\n-                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n-                        // Check whether the failure was caused by a\n-                        // non-mandatory script verification check, such as\n-                        // non-standard DER encodings or non-null dummy\n-                        // arguments; if so, don't trigger DoS protection to\n-                        // avoid splitting the network between upgraded and\n-                        // non-upgraded nodes.\n-                        CScriptCheck check2(*coins, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n-                        if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                if (pCheckQueueControl) {\n+                    pCheckQueueControl->Add(*coins, tx, i, flags, cacheStore, &txdata);\n+                } else {\n+                    CScriptCheck check(*coins, tx, i, flags, cacheStore, &txdata);\n+                    if (!check()) {\n+                        if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n+                            // Check whether the failure was caused by a\n+                            // non-mandatory script verification check, such as\n+                            // non-standard DER encodings or non-null dummy\n+                            // arguments; if so, don't trigger DoS protection to\n+                            // avoid splitting the network between upgraded and\n+                            // non-upgraded nodes.\n+                            CScriptCheck check2(*coins, tx, i,\n+                                    flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n+                            if (check2())\n+                                return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                        }\n+                        // Failures of other flags indicate a transaction that is\n+                        // invalid in new blocks, e.g. a invalid P2SH. We DoS ban\n+                        // such nodes as they are not following the protocol. That\n+                        // said during an upgrade careful thought should be taken\n+                        // as to the correct behavior - we may want to continue\n+                        // peering with non-upgraded nodes even after soft-fork\n+                        // super-majority signaling has occurred.\n+                        return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n-                    // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. a invalid P2SH. We DoS ban\n-                    // such nodes as they are not following the protocol. That\n-                    // said during an upgrade careful thought should be taken\n-                    // as to the correct behavior - we may want to continue\n-                    // peering with non-upgraded nodes even after soft-fork\n-                    // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n+            if (pCheckQueueControl) {\n+                pCheckQueueControl->Flush(tx.vin.size());\n+            }\n         }\n     }\n \n@@ -1885,12 +1886,10 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         {\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n-            std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &control : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n-            control.Add(vChecks);\n         }\n \n         CTxUndo undoDummy;"
      },
      {
        "sha": "386953a16dff4a65c32c47b9ee3dd4f668719372",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12e9cd472d41acfda5e1aed5e52fa7cc47b17063/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "patch": "@@ -45,6 +45,9 @@ class CValidationInterface;\n class CValidationState;\n struct ChainTxData;\n \n+template <typename T>\n+class CCheckQueueControl;\n+\n struct PrecomputedTransactionData;\n struct LockPoints;\n \n@@ -378,7 +381,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+                 unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, CCheckQueueControl<CScriptCheck> *pCheckQueueControl = NULL);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      }
    ]
  },
  {
    "sha": "39397bb40cc0ead65a131492376d6a219c99c8d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTM5N2JiNDBjYzBlYWQ2NWExMzE0OTIzNzZkNmEyMTljOTljOGQy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-13T00:51:19Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "message": "CheckQueue: This commit refactors the CheckQueue to be written \"lock free\" style\nto improve the concurrency on multicore machines.  In effect, it eliminates the\nuse of any \"critical section\" during block validation.",
      "tree": {
        "sha": "850bf96cf8ed3fdd85cc875ce9dab845764b5f66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/850bf96cf8ed3fdd85cc875ce9dab845764b5f66"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39397bb40cc0ead65a131492376d6a219c99c8d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39397bb40cc0ead65a131492376d6a219c99c8d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39397bb40cc0ead65a131492376d6a219c99c8d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39397bb40cc0ead65a131492376d6a219c99c8d2/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12e9cd472d41acfda5e1aed5e52fa7cc47b17063"
      }
    ],
    "stats": {
      "total": 175,
      "additions": 94,
      "deletions": 81
    },
    "files": [
      {
        "sha": "ea6be0167629c5b6c4cbd90faebdef9b04e4a9e2",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 94,
        "deletions": 81,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39397bb40cc0ead65a131492376d6a219c99c8d2/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39397bb40cc0ead65a131492376d6a219c99c8d2/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=39397bb40cc0ead65a131492376d6a219c99c8d2",
        "patch": "@@ -16,7 +16,7 @@\n template <typename T>\n class CCheckQueueControl;\n \n-/** \n+/**\n  * Queue for verifications that have to be performed.\n   * The verifications are represented by a type T, which must provide an\n   * operator(), returning a bool.\n@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise\n+                // the master thread might exit and we'd double free pT\n+                fAllOk &= fOk;\n             }\n-        } while (true);\n+        }\n     }\n \n public:\n     //! Mutex to ensure only one concurrent CCheckQueueControl\n     boost::mutex ControlMutex;\n \n     //! Create a new check queue\n-    CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n+    CCheckQueue(unsigned int nBatchSizeIn) :  fAllOk(1), nAwake(0), fMasterPresent(false),  fQuit(false), nBatchSize(nBatchSizeIn), check_mem(nullptr), check_mem_bot(0), check_mem_top(0) {}\n \n     //! Worker thread\n     void Thread()\n@@ -140,26 +149,22 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n-    typename std::vector<T>::iterator check_mem;\n-    typename std::vector<T>::iterator check_mem_top;\n-    typename std::vector<T>::iterator check_mem_bottom;\n-    void Setup(typename std::vector<T>::iterator check_mem_in) \n+    //! Setup is called once per batch to point the CheckQueue to the\n+    // checks & restart the counters.\n+    void Setup(T* check_mem_in)\n     {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n         check_mem = check_mem_in;\n-        check_mem_top = check_mem_in;\n-        check_mem_bottom = check_mem_in;\n+        check_mem_top = 0;\n+        check_mem_bot = 0;\n+        fMasterPresent = true;\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        condWorker.notify_all();\n     }\n+\n     //! Add a batch of checks to the queue\n     void Add(size_t size)\n     {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n         check_mem_top += size;\n-        nTodo += size;\n-        if (size == 1)\n-            condWorker.notify_one();\n-        else if (size > 1)\n-            condWorker.notify_all();\n     }\n \n     ~CCheckQueue()\n@@ -168,7 +173,7 @@ class CCheckQueue\n \n };\n \n-/** \n+/**\n  * RAII-style controller object for a CCheckQueue that guarantees the passed\n  * queue is finished before continuing.\n  */\n@@ -190,7 +195,7 @@ class CCheckQueueControl\n         if (pqueue != NULL) {\n             ENTER_CRITICAL_SECTION(pqueue->ControlMutex);\n             check_mem.reserve(size);\n-            pqueue->Setup(check_mem.begin());\n+            pqueue->Setup(check_mem.data());\n         }\n     }\n \n@@ -203,6 +208,8 @@ class CCheckQueueControl\n         return fRet;\n     }\n \n+    //! Deprecated. emplacement Add + Flush are the preferred method for adding\n+    // checks to the queue.\n     void Add(std::vector<T>& vChecks)\n     {\n         if (pqueue != NULL) {\n@@ -214,13 +221,19 @@ class CCheckQueueControl\n             pqueue->Add(s);\n         }\n     }\n+\n+    //! Add directly constructs a check on the Controller's memory\n+    // Checks created via emplacement Add won't be executed\n+    // until a subsequent Flush call.\n     template<typename ... Args>\n     void Add(Args && ... args)\n     {\n         if (pqueue != NULL) {\n             check_mem.emplace_back(std::forward<Args>(args)...);\n         }\n     }\n+\n+    //! FLush is called to inform the worker of new jobs\n     void Flush(size_t s)\n     {\n         if (pqueue != NULL) {"
      }
    ]
  }
]