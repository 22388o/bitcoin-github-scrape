[
  {
    "sha": "c6aaecfd2169d7784796fb3f5fe9542141747995",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmFhZWNmZDIxNjlkNzc4NDc5NmZiM2Y1ZmU5NTQyMTQxNzQ3OTk1",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-27T19:01:57Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-27T19:01:57Z"
      },
      "message": "IsReachable is the inverse of IsLimited (DRY)",
      "tree": {
        "sha": "0de6d0f707ee29a038843ae1c5550666d1917b8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0de6d0f707ee29a038843ae1c5550666d1917b8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6aaecfd2169d7784796fb3f5fe9542141747995",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6aaecfd2169d7784796fb3f5fe9542141747995",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6aaecfd2169d7784796fb3f5fe9542141747995",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6aaecfd2169d7784796fb3f5fe9542141747995/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86e0a33f5c382513d5179e3fdf158baf952d7e2f"
      }
    ],
    "stats": {
      "total": 618,
      "additions": 304,
      "deletions": 314
    },
    "files": [
      {
        "sha": "d66d2c96ee9bd30b2b6bde6d35e97e297feaea90",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 212,
        "deletions": 309,
        "changes": 521,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6aaecfd2169d7784796fb3f5fe9542141747995/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6aaecfd2169d7784796fb3f5fe9542141747995/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c6aaecfd2169d7784796fb3f5fe9542141747995",
        "patch": "@@ -14,8 +14,8 @@\n #include <consensus/consensus.h>\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n-#include <primitives/transaction.h>\n #include <netbase.h>\n+#include <primitives/transaction.h>\n #include <scheduler.h>\n #include <ui_interface.h>\n #include <util/strencodings.h>\n@@ -65,15 +65,15 @@\n \n /** Used to pass flags to the Bind() function */\n enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n+    BF_NONE = 0,\n+    BF_EXPLICIT = (1U << 0),\n     BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n+    BF_WHITELIST = (1U << 2),\n };\n \n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n-static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n+static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL;       // SHA256(\"netgroup\")[0:8]\n static const uint64_t RANDOMIZER_ID_LOCALHOSTNONCE = 0xd93e69e2bbfa5735ULL; // SHA256(\"localhostnonce\")[0:8]\n //\n // Global state variables\n@@ -100,7 +100,7 @@ unsigned short GetListenPort()\n }\n \n // find 'best' local address for a particular peer\n-bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n+bool GetLocal(CService& addr, const CNetAddr* paddrPeer)\n {\n     if (!fListen)\n         return false;\n@@ -109,12 +109,10 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     int nBestReachability = -1;\n     {\n         LOCK(cs_mapLocalHost);\n-        for (const auto& entry : mapLocalHost)\n-        {\n+        for (const auto& entry : mapLocalHost) {\n             int nScore = entry.second.nScore;\n             int nReachability = entry.first.GetReachabilityFrom(paddrPeer);\n-            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n-            {\n+            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore)) {\n                 addr = CService(entry.first, entry.second.nPort);\n                 nBestReachability = nReachability;\n                 nBestScore = nScore;\n@@ -125,13 +123,13 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n }\n \n //! Convert the pnSeed6 array into usable address objects.\n-static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn)\n+static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6>& vSeedsIn)\n {\n     // It'll only connect to one or two seed nodes because once it connects,\n     // it'll get a pile of addresses with newer timestamps.\n     // Seed nodes are given a random 'last seen time' of between one and two\n     // weeks ago.\n-    const int64_t nOneWeek = 7*24*60*60;\n+    const int64_t nOneWeek = 7 * 24 * 60 * 60;\n     std::vector<CAddress> vSeedsOut;\n     vSeedsOut.reserve(vSeedsIn.size());\n     FastRandomContext rng;\n@@ -149,12 +147,11 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // Otherwise, return the unroutable 0.0.0.0 but filled in with\n // the normal parameters, since the IP may be changed to a useful\n // one by discovery.\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n+CAddress GetLocalAddress(const CNetAddr* paddrPeer, ServiceFlags nLocalServices)\n {\n-    CAddress ret(CService(CNetAddr(),GetListenPort()), nLocalServices);\n+    CAddress ret(CService(CNetAddr(), GetListenPort()), nLocalServices);\n     CService addr;\n-    if (GetLocal(addr, paddrPeer))\n-    {\n+    if (GetLocal(addr, paddrPeer)) {\n         ret = CAddress(addr, nLocalServices);\n     }\n     ret.nTime = GetAdjustedTime();\n@@ -170,18 +167,17 @@ static int GetnScore(const CService& addr)\n }\n \n // Is our peer's addrLocal potentially useful as an external IP source?\n-bool IsPeerAddrLocalGood(CNode *pnode)\n+bool IsPeerAddrLocalGood(CNode* pnode)\n {\n     CService addrLocal = pnode->GetAddrLocal();\n     return fDiscover && pnode->addr.IsRoutable() && addrLocal.IsRoutable() &&\n            !IsLimited(addrLocal.GetNetwork());\n }\n \n // pushes our own address to a peer\n-void AdvertiseLocal(CNode *pnode)\n+void AdvertiseLocal(CNode* pnode)\n {\n-    if (fListen && pnode->fSuccessfullyConnected)\n-    {\n+    if (fListen && pnode->fSuccessfullyConnected) {\n         CAddress addrLocal = GetLocalAddress(&pnode->addr, pnode->GetLocalServices());\n         if (gArgs.GetBoolArg(\"-addrmantest\", false)) {\n             // use IPv4 loopback during addrmantest\n@@ -192,12 +188,10 @@ void AdvertiseLocal(CNode *pnode)\n         // address than we do.\n         FastRandomContext rng;\n         if (IsPeerAddrLocalGood(pnode) && (!addrLocal.IsRoutable() ||\n-             rng.randbits((GetnScore(addrLocal) > LOCAL_MANUAL) ? 3 : 1) == 0))\n-        {\n+                                              rng.randbits((GetnScore(addrLocal) > LOCAL_MANUAL) ? 3 : 1) == 0)) {\n             addrLocal.SetIP(pnode->GetAddrLocal());\n         }\n-        if (addrLocal.IsRoutable() || gArgs.GetBoolArg(\"-addrmantest\", false))\n-        {\n+        if (addrLocal.IsRoutable() || gArgs.GetBoolArg(\"-addrmantest\", false)) {\n             LogPrint(BCLog::NET, \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n             pnode->PushAddress(addrLocal, rng);\n         }\n@@ -221,7 +215,7 @@ bool AddLocal(const CService& addr, int nScore)\n     {\n         LOCK(cs_mapLocalHost);\n         bool fAlready = mapLocalHost.count(addr) > 0;\n-        LocalServiceInfo &info = mapLocalHost[addr];\n+        LocalServiceInfo& info = mapLocalHost[addr];\n         if (!fAlready || nScore >= info.nScore) {\n             info.nScore = nScore + (fAlready ? 1 : 0);\n             info.nPort = addr.GetPort();\n@@ -231,7 +225,7 @@ bool AddLocal(const CService& addr, int nScore)\n     return true;\n }\n \n-bool AddLocal(const CNetAddr &addr, int nScore)\n+bool AddLocal(const CNetAddr& addr, int nScore)\n {\n     return AddLocal(CService(addr, GetListenPort()), nScore);\n }\n@@ -258,7 +252,7 @@ bool IsLimited(enum Network net)\n     return vfLimited[net];\n }\n \n-bool IsLimited(const CNetAddr &addr)\n+bool IsLimited(const CNetAddr& addr)\n {\n     return IsLimited(addr.GetNetwork());\n }\n@@ -286,23 +280,21 @@ bool IsLocal(const CService& addr)\n /** check whether a given network is one we can probably connect to */\n bool IsReachable(enum Network net)\n {\n-    LOCK(cs_mapLocalHost);\n-    return !vfLimited[net];\n+    return !IsLimited(net);\n }\n \n /** check whether a given address is in a network we can probably connect to */\n bool IsReachable(const CNetAddr& addr)\n {\n-    enum Network net = addr.GetNetwork();\n-    return IsReachable(net);\n+    return IsReachable(addr.GetNetwork());\n }\n \n \n CNode* CConnman::FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n     for (CNode* pnode : vNodes) {\n-      if (static_cast<CNetAddr>(pnode->addr) == ip) {\n+        if (static_cast<CNetAddr>(pnode->addr) == ip) {\n             return pnode;\n         }\n     }\n@@ -368,16 +360,15 @@ static CAddress GetBindAddress(SOCKET sock)\n     return addr_bind;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection)\n+CNode* CConnman::ConnectNode(CAddress addrConnect, const char* pszDest, bool fCountFailure, bool manual_connection)\n {\n     if (pszDest == nullptr) {\n         if (IsLocal(addrConnect))\n             return nullptr;\n \n         // Look for an existing connection\n         CNode* pnode = FindNode(static_cast<CService>(addrConnect));\n-        if (pnode)\n-        {\n+        if (pnode) {\n             LogPrintf(\"Failed to open new connection, already connected\\n\");\n             return nullptr;\n         }\n@@ -386,13 +377,13 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n-        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n+        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime) / 3600.0);\n \n     // Resolve\n     const int default_port = Params().GetDefaultPort();\n     if (pszDest) {\n         std::vector<CService> resolved;\n-        if (Lookup(pszDest, resolved,  default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\n+        if (Lookup(pszDest, resolved, default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\n             addrConnect = CAddress(resolved[GetRand(resolved.size())], NODE_NONE);\n             if (!addrConnect.IsValid()) {\n                 LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\\n\", addrConnect.ToString(), pszDest);\n@@ -404,8 +395,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             // name catch this early.\n             LOCK(cs_vNodes);\n             CNode* pnode = FindNode(static_cast<CService>(addrConnect));\n-            if (pnode)\n-            {\n+            if (pnode) {\n                 pnode->MaybeSetAddrName(std::string(pszDest));\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\n                 return nullptr;\n@@ -488,8 +478,7 @@ void CNode::CloseSocketDisconnect()\n {\n     fDisconnect = true;\n     LOCK(cs_hSocket);\n-    if (hSocket != INVALID_SOCKET)\n-    {\n+    if (hSocket != INVALID_SOCKET) {\n         LogPrint(BCLog::NET, \"disconnecting peer=%d\\n\", id);\n         CloseSocket(hSocket);\n     }\n@@ -503,7 +492,7 @@ void CConnman::ClearBanned()\n         setBannedIsDirty = true;\n     }\n     DumpBanlist(); //store banlist to disk\n-    if(clientInterface)\n+    if (clientInterface)\n         clientInterface->BannedListChanged();\n }\n \n@@ -525,8 +514,7 @@ bool CConnman::IsBanned(CSubNet subnet)\n {\n     LOCK(cs_setBanned);\n     banmap_t::iterator i = setBanned.find(subnet);\n-    if (i != setBanned.end())\n-    {\n+    if (i != setBanned.end()) {\n         CBanEntry banEntry = (*i).second;\n         if (GetTime() < banEntry.nBanUntil) {\n             return true;\n@@ -535,31 +523,31 @@ bool CConnman::IsBanned(CSubNet subnet)\n     return false;\n }\n \n-void CConnman::Ban(const CNetAddr& addr, const BanReason &banReason, int64_t bantimeoffset, bool sinceUnixEpoch) {\n+void CConnman::Ban(const CNetAddr& addr, const BanReason& banReason, int64_t bantimeoffset, bool sinceUnixEpoch)\n+{\n     CSubNet subNet(addr);\n     Ban(subNet, banReason, bantimeoffset, sinceUnixEpoch);\n }\n \n-void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t bantimeoffset, bool sinceUnixEpoch) {\n+void CConnman::Ban(const CSubNet& subNet, const BanReason& banReason, int64_t bantimeoffset, bool sinceUnixEpoch)\n+{\n     CBanEntry banEntry(GetTime());\n     banEntry.banReason = banReason;\n-    if (bantimeoffset <= 0)\n-    {\n+    if (bantimeoffset <= 0) {\n         bantimeoffset = gArgs.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME);\n         sinceUnixEpoch = false;\n     }\n-    banEntry.nBanUntil = (sinceUnixEpoch ? 0 : GetTime() )+bantimeoffset;\n+    banEntry.nBanUntil = (sinceUnixEpoch ? 0 : GetTime()) + bantimeoffset;\n \n     {\n         LOCK(cs_setBanned);\n         if (setBanned[subNet].nBanUntil < banEntry.nBanUntil) {\n             setBanned[subNet] = banEntry;\n             setBannedIsDirty = true;\n-        }\n-        else\n+        } else\n             return;\n     }\n-    if(clientInterface)\n+    if (clientInterface)\n         clientInterface->BannedListChanged();\n     {\n         LOCK(cs_vNodes);\n@@ -568,37 +556,39 @@ void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t ba\n                 pnode->fDisconnect = true;\n         }\n     }\n-    if(banReason == BanReasonManuallyAdded)\n+    if (banReason == BanReasonManuallyAdded)\n         DumpBanlist(); //store banlist to disk immediately if user requested ban\n }\n \n-bool CConnman::Unban(const CNetAddr &addr) {\n+bool CConnman::Unban(const CNetAddr& addr)\n+{\n     CSubNet subNet(addr);\n     return Unban(subNet);\n }\n \n-bool CConnman::Unban(const CSubNet &subNet) {\n+bool CConnman::Unban(const CSubNet& subNet)\n+{\n     {\n         LOCK(cs_setBanned);\n         if (!setBanned.erase(subNet))\n             return false;\n         setBannedIsDirty = true;\n     }\n-    if(clientInterface)\n+    if (clientInterface)\n         clientInterface->BannedListChanged();\n     DumpBanlist(); //store banlist to disk immediately\n     return true;\n }\n \n-void CConnman::GetBanned(banmap_t &banMap)\n+void CConnman::GetBanned(banmap_t& banMap)\n {\n     LOCK(cs_setBanned);\n     // Sweep the banlist so expired bans are not returned\n     SweepBanned();\n     banMap = setBanned; //create a thread safe copy\n }\n \n-void CConnman::SetBanned(const banmap_t &banMap)\n+void CConnman::SetBanned(const banmap_t& banMap)\n {\n     LOCK(cs_setBanned);\n     setBanned = banMap;\n@@ -612,23 +602,20 @@ void CConnman::SweepBanned()\n     {\n         LOCK(cs_setBanned);\n         banmap_t::iterator it = setBanned.begin();\n-        while(it != setBanned.end())\n-        {\n+        while (it != setBanned.end()) {\n             CSubNet subNet = (*it).first;\n             CBanEntry banEntry = (*it).second;\n-            if(now > banEntry.nBanUntil)\n-            {\n+            if (now > banEntry.nBanUntil) {\n                 setBanned.erase(it++);\n                 setBannedIsDirty = true;\n                 notifyUI = true;\n                 LogPrint(BCLog::NET, \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, subNet.ToString());\n-            }\n-            else\n+            } else\n                 ++it;\n         }\n     }\n     // update UI\n-    if(notifyUI && clientInterface) {\n+    if (notifyUI && clientInterface) {\n         clientInterface->BannedListChanged();\n     }\n }\n@@ -646,32 +633,37 @@ void CConnman::SetBannedSetDirty(bool dirty)\n }\n \n \n-bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n+bool CConnman::IsWhitelistedRange(const CNetAddr& addr)\n+{\n     for (const CSubNet& subnet : vWhitelistedRange) {\n         if (subnet.Match(addr))\n             return true;\n     }\n     return false;\n }\n \n-std::string CNode::GetAddrName() const {\n+std::string CNode::GetAddrName() const\n+{\n     LOCK(cs_addrName);\n     return addrName;\n }\n \n-void CNode::MaybeSetAddrName(const std::string& addrNameIn) {\n+void CNode::MaybeSetAddrName(const std::string& addrNameIn)\n+{\n     LOCK(cs_addrName);\n     if (addrName.empty()) {\n         addrName = addrNameIn;\n     }\n }\n \n-CService CNode::GetAddrLocal() const {\n+CService CNode::GetAddrLocal() const\n+{\n     LOCK(cs_addrLocal);\n     return addrLocal;\n }\n \n-void CNode::SetAddrLocal(const CService& addrLocalIn) {\n+void CNode::SetAddrLocal(const CService& addrLocalIn)\n+{\n     LOCK(cs_addrLocal);\n     if (addrLocal.IsValid()) {\n         error(\"Addr local already set for node: %i. Refusing to change from %s to %s\", id, addrLocal.ToString(), addrLocalIn.ToString());\n@@ -682,7 +674,7 @@ void CNode::SetAddrLocal(const CService& addrLocalIn) {\n \n #undef X\n #define X(name) stats.name = name\n-void CNode::copyStats(CNodeStats &stats)\n+void CNode::copyStats(CNodeStats& stats)\n {\n     stats.nodeid = this->GetId();\n     X(nServices);\n@@ -734,7 +726,7 @@ void CNode::copyStats(CNodeStats &stats)\n \n     // Raw ping time is in microseconds, but show it to user as whole seconds (Bitcoin users should be well used to small numbers with many decimal places by now :)\n     stats.dPingTime = (((double)nPingUsecTime) / 1e6);\n-    stats.dMinPing  = (((double)nMinPingUsecTime) / 1e6);\n+    stats.dMinPing = (((double)nMinPingUsecTime) / 1e6);\n     stats.dPingWait = (((double)nPingUsecWait) / 1e6);\n \n     // Leave string empty if addrLocal invalid (not filled in yet)\n@@ -743,15 +735,14 @@ void CNode::copyStats(CNodeStats &stats)\n }\n #undef X\n \n-bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete)\n+bool CNode::ReceiveMsgBytes(const char* pch, unsigned int nBytes, bool& complete)\n {\n     complete = false;\n     int64_t nTimeMicros = GetTimeMicros();\n     LOCK(cs_vRecv);\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n         if (vRecvMsg.empty() ||\n             vRecvMsg.back().complete())\n@@ -778,7 +769,6 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n         nBytes -= handled;\n \n         if (msg.complete()) {\n-\n             //store received bytes per message command\n             //to prevent a memory DOS, only allow valid commands\n             mapMsgCmdSize::iterator i = mapRecvBytesPerMsgCmd.find(msg.hdr.pchCommand);\n@@ -822,7 +812,7 @@ int CNode::GetSendVersion() const\n }\n \n \n-int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n+int CNetMessage::readHeader(const char* pch, unsigned int nBytes)\n {\n     // copy data to temporary parsing buffer\n     unsigned int nRemaining = 24 - nHdrPos;\n@@ -838,8 +828,7 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n     // deserialize to CMessageHeader\n     try {\n         hdrbuf >> hdr;\n-    }\n-    catch (const std::exception&) {\n+    } catch (const std::exception&) {\n         return -1;\n     }\n \n@@ -853,7 +842,7 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n     return nCopy;\n }\n \n-int CNetMessage::readData(const char *pch, unsigned int nBytes)\n+int CNetMessage::readData(const char* pch, unsigned int nBytes)\n {\n     unsigned int nRemaining = hdr.nMessageSize - nDataPos;\n     unsigned int nCopy = std::min(nRemaining, nBytes);\n@@ -878,13 +867,13 @@ const uint256& CNetMessage::GetMessageHash() const\n     return data_hash;\n }\n \n-size_t CConnman::SocketSendData(CNode *pnode) const EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_vSend)\n+size_t CConnman::SocketSendData(CNode* pnode) const EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_vSend)\n {\n     auto it = pnode->vSendMsg.begin();\n     size_t nSentSize = 0;\n \n     while (it != pnode->vSendMsg.end()) {\n-        const auto &data = *it;\n+        const auto& data = *it;\n         assert(data.size() > pnode->nSendOffset);\n         int nBytes = 0;\n         {\n@@ -911,8 +900,7 @@ size_t CConnman::SocketSendData(CNode *pnode) const EXCLUSIVE_LOCKS_REQUIRED(pno\n             if (nBytes < 0) {\n                 // error\n                 int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                {\n+                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n                     LogPrintf(\"socket send error %s\\n\", NetworkErrorString(nErr));\n                     pnode->CloseSocketDisconnect();\n                 }\n@@ -930,8 +918,7 @@ size_t CConnman::SocketSendData(CNode *pnode) const EXCLUSIVE_LOCKS_REQUIRED(pno\n     return nSentSize;\n }\n \n-struct NodeEvictionCandidate\n-{\n+struct NodeEvictionCandidate {\n     NodeId id;\n     int64_t nTimeConnected;\n     int64_t nMinPingUsecTime;\n@@ -944,29 +931,30 @@ struct NodeEvictionCandidate\n     uint64_t nKeyedNetGroup;\n };\n \n-static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n {\n     return a.nMinPingUsecTime > b.nMinPingUsecTime;\n }\n \n-static bool ReverseCompareNodeTimeConnected(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+static bool ReverseCompareNodeTimeConnected(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n {\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n-static bool CompareNetGroupKeyed(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b) {\n+static bool CompareNetGroupKeyed(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n+{\n     return a.nKeyedNetGroup < b.nKeyedNetGroup;\n }\n \n-static bool CompareNodeBlockTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+static bool CompareNodeBlockTime(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n {\n     // There is a fall-through here because it is common for a node to have many peers which have not yet relayed a block.\n     if (a.nLastBlockTime != b.nLastBlockTime) return a.nLastBlockTime < b.nLastBlockTime;\n     if (a.fRelevantServices != b.fRelevantServices) return b.fRelevantServices;\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n-static bool CompareNodeTXTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+static bool CompareNodeTXTime(const NodeEvictionCandidate& a, const NodeEvictionCandidate& b)\n {\n     // There is a fall-through here because it is common for a node to have more than a few peers that have not yet relayed txn.\n     if (a.nLastTXTime != b.nLastTXTime) return a.nLastTXTime < b.nLastTXTime;\n@@ -977,8 +965,8 @@ static bool CompareNodeTXTime(const NodeEvictionCandidate &a, const NodeEviction\n \n \n //! Sort an array by the specified comparator, then erase the last K elements.\n-template<typename T, typename Comparator>\n-static void EraseLastKElements(std::vector<T> &elements, Comparator comparator, size_t k)\n+template <typename T, typename Comparator>\n+static void EraseLastKElements(std::vector<T>& elements, Comparator comparator, size_t k)\n {\n     std::sort(elements.begin(), elements.end(), comparator);\n     size_t eraseSize = std::min(k, elements.size());\n@@ -1008,9 +996,9 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             LOCK(node->cs_filter);\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n-                                               node->nLastBlockTime, node->nLastTXTime,\n-                                               HasAllDesirableServiceFlags(node->nServices),\n-                                               node->fRelayTxes, node->pfilter != nullptr, node->addr, node->nKeyedNetGroup};\n+                node->nLastBlockTime, node->nLastTXTime,\n+                HasAllDesirableServiceFlags(node->nServices),\n+                node->fRelayTxes, node->pfilter != nullptr, node->addr, node->nKeyedNetGroup};\n             vEvictionCandidates.push_back(candidate);\n         }\n     }\n@@ -1040,9 +1028,9 @@ bool CConnman::AttemptToEvictConnection()\n     uint64_t naMostConnections;\n     unsigned int nMostConnections = 0;\n     int64_t nMostConnectionsTime = 0;\n-    std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapNetGroupNodes;\n-    for (const NodeEvictionCandidate &node : vEvictionCandidates) {\n-        std::vector<NodeEvictionCandidate> &group = mapNetGroupNodes[node.nKeyedNetGroup];\n+    std::map<uint64_t, std::vector<NodeEvictionCandidate>> mapNetGroupNodes;\n+    for (const NodeEvictionCandidate& node : vEvictionCandidates) {\n+        std::vector<NodeEvictionCandidate>& group = mapNetGroupNodes[node.nKeyedNetGroup];\n         group.push_back(node);\n         int64_t grouptime = group[0].nTimeConnected;\n \n@@ -1068,7 +1056,8 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n+void CConnman::AcceptConnection(const ListenSocket& hListenSocket)\n+{\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n     SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n@@ -1090,8 +1079,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n         }\n     }\n \n-    if (hSocket == INVALID_SOCKET)\n-    {\n+    if (hSocket == INVALID_SOCKET) {\n         int nErr = WSAGetLastError();\n         if (nErr != WSAEWOULDBLOCK)\n             LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n@@ -1104,8 +1092,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n         return;\n     }\n \n-    if (!IsSelectableSocket(hSocket))\n-    {\n+    if (!IsSelectableSocket(hSocket)) {\n         LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n@@ -1115,15 +1102,13 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     // on all platforms.  Set it again here just to be sure.\n     SetSocketNoDelay(hSocket);\n \n-    if (IsBanned(addr) && !whitelisted)\n-    {\n+    if (IsBanned(addr) && !whitelisted) {\n         LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }\n \n-    if (nInbound >= nMaxInbound)\n-    {\n+    if (nInbound >= nMaxInbound) {\n         if (!AttemptToEvictConnection()) {\n             // No connection to evict, disconnect the new connection\n             LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");\n@@ -1166,10 +1151,8 @@ void CConnman::DisconnectNodes()\n \n         // Disconnect unused nodes\n         std::vector<CNode*> vNodesCopy = vNodes;\n-        for (CNode* pnode : vNodesCopy)\n-        {\n-            if (pnode->fDisconnect)\n-            {\n+        for (CNode* pnode : vNodesCopy) {\n+            if (pnode->fDisconnect) {\n                 // remove from vNodes\n                 vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n@@ -1188,8 +1171,7 @@ void CConnman::DisconnectNodes()\n     {\n         // Delete disconnected nodes\n         std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-        for (CNode* pnode : vNodesDisconnectedCopy)\n-        {\n+        for (CNode* pnode : vNodesDisconnectedCopy) {\n             // wait until threads are done using it\n             if (pnode->GetRefCount() <= 0) {\n                 bool fDelete = false;\n@@ -1218,40 +1200,30 @@ void CConnman::NotifyNumConnectionsChanged()\n         LOCK(cs_vNodes);\n         vNodesSize = vNodes.size();\n     }\n-    if(vNodesSize != nPrevNodeCount) {\n+    if (vNodesSize != nPrevNodeCount) {\n         nPrevNodeCount = vNodesSize;\n-        if(clientInterface)\n+        if (clientInterface)\n             clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n     }\n }\n \n-void CConnman::InactivityCheck(CNode *pnode)\n+void CConnman::InactivityCheck(CNode* pnode)\n {\n     int64_t nTime = GetSystemTimeInSeconds();\n-    if (nTime - pnode->nTimeConnected > m_peer_connect_timeout)\n-    {\n-        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n-        {\n+    if (nTime - pnode->nTimeConnected > m_peer_connect_timeout) {\n+        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0) {\n             LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d from %d\\n\", m_peer_connect_timeout, pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n             pnode->fDisconnect = true;\n-        }\n-        else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n-        {\n+        } else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL) {\n             LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n             pnode->fDisconnect = true;\n-        }\n-        else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n-        {\n+        } else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90 * 60)) {\n             LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n             pnode->fDisconnect = true;\n-        }\n-        else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n-        {\n+        } else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros()) {\n             LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n             pnode->fDisconnect = true;\n-        }\n-        else if (!pnode->fSuccessfullyConnected)\n-        {\n+        } else if (!pnode->fSuccessfullyConnected) {\n             LogPrint(BCLog::NET, \"version handshake timeout from %d\\n\", pnode->GetId());\n             pnode->fDisconnect = true;\n         }\n@@ -1264,7 +1236,7 @@ void CConnman::SocketHandler()\n     // Find which sockets have data to receive\n     //\n     struct timeval timeout;\n-    timeout.tv_sec  = 0;\n+    timeout.tv_sec = 0;\n     timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n \n     fd_set fdsetRecv;\n@@ -1284,8 +1256,7 @@ void CConnman::SocketHandler()\n \n     {\n         LOCK(cs_vNodes);\n-        for (CNode* pnode : vNodes)\n-        {\n+        for (CNode* pnode : vNodes) {\n             // Implement the following logic:\n             // * If there is data to send, select() for sending data. As this only\n             //   happens when optimistic write failed, we choose to first drain the\n@@ -1323,32 +1294,28 @@ void CConnman::SocketHandler()\n     }\n \n     int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+        &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n     if (interruptNet)\n         return;\n \n-    if (nSelect == SOCKET_ERROR)\n-    {\n-        if (have_fds)\n-        {\n+    if (nSelect == SOCKET_ERROR) {\n+        if (have_fds) {\n             int nErr = WSAGetLastError();\n             LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n             for (unsigned int i = 0; i <= hSocketMax; i++)\n                 FD_SET(i, &fdsetRecv);\n         }\n         FD_ZERO(&fdsetSend);\n         FD_ZERO(&fdsetError);\n-        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec / 1000)))\n             return;\n     }\n \n     //\n     // Accept new connections\n     //\n-    for (const ListenSocket& hListenSocket : vhListenSocket)\n-    {\n-        if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n-        {\n+    for (const ListenSocket& hListenSocket : vhListenSocket) {\n+        if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv)) {\n             AcceptConnection(hListenSocket);\n         }\n     }\n@@ -1363,8 +1330,7 @@ void CConnman::SocketHandler()\n         for (CNode* pnode : vNodesCopy)\n             pnode->AddRef();\n     }\n-    for (CNode* pnode : vNodesCopy)\n-    {\n+    for (CNode* pnode : vNodesCopy) {\n         if (interruptNet)\n             return;\n \n@@ -1382,8 +1348,7 @@ void CConnman::SocketHandler()\n             sendSet = FD_ISSET(pnode->hSocket, &fdsetSend);\n             errorSet = FD_ISSET(pnode->hSocket, &fdsetError);\n         }\n-        if (recvSet || errorSet)\n-        {\n+        if (recvSet || errorSet) {\n             // typical socket buffer is 8K-64K\n             char pchBuf[0x10000];\n             int nBytes = 0;\n@@ -1393,8 +1358,7 @@ void CConnman::SocketHandler()\n                     continue;\n                 nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n             }\n-            if (nBytes > 0)\n-            {\n+            if (nBytes > 0) {\n                 bool notify = false;\n                 if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n                     pnode->CloseSocketDisconnect();\n@@ -1415,21 +1379,16 @@ void CConnman::SocketHandler()\n                     }\n                     WakeMessageHandler();\n                 }\n-            }\n-            else if (nBytes == 0)\n-            {\n+            } else if (nBytes == 0) {\n                 // socket closed gracefully\n                 if (!pnode->fDisconnect) {\n                     LogPrint(BCLog::NET, \"socket closed\\n\");\n                 }\n                 pnode->CloseSocketDisconnect();\n-            }\n-            else if (nBytes < 0)\n-            {\n+            } else if (nBytes < 0) {\n                 // error\n                 int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                {\n+                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n                     if (!pnode->fDisconnect)\n                         LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n                     pnode->CloseSocketDisconnect();\n@@ -1440,8 +1399,7 @@ void CConnman::SocketHandler()\n         //\n         // Send\n         //\n-        if (sendSet)\n-        {\n+        if (sendSet) {\n             LOCK(pnode->cs_vSend);\n             size_t nBytes = SocketSendData(pnode);\n             if (nBytes) {\n@@ -1460,8 +1418,7 @@ void CConnman::SocketHandler()\n \n void CConnman::ThreadSocketHandler()\n {\n-    while (!interruptNet)\n-    {\n+    while (!interruptNet) {\n         DisconnectNodes();\n         NotifyNumConnectionsChanged();\n         SocketHandler();\n@@ -1478,19 +1435,15 @@ void CConnman::WakeMessageHandler()\n }\n \n \n-\n-\n-\n-\n #ifdef USE_UPNP\n static CThreadInterrupt g_upnp_interrupt;\n static std::thread g_upnp_thread;\n static void ThreadMapPort()\n {\n     std::string port = strprintf(\"%u\", GetListenPort());\n-    const char * multicastif = nullptr;\n-    const char * minissdpdpath = nullptr;\n-    struct UPNPDev * devlist = nullptr;\n+    const char* multicastif = nullptr;\n+    const char* minissdpdpath = nullptr;\n+    struct UPNPDev* devlist = nullptr;\n     char lanaddr[64];\n \n #ifndef UPNPDISCOVER_SUCCESS\n@@ -1511,24 +1464,20 @@ static void ThreadMapPort()\n     int r;\n \n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n-    if (r == 1)\n-    {\n+    if (r == 1) {\n         if (fDiscover) {\n             char externalIPAddress[40];\n             r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n-            if(r != UPNPCOMMAND_SUCCESS)\n+            if (r != UPNPCOMMAND_SUCCESS)\n                 LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n-            else\n-            {\n-                if(externalIPAddress[0])\n-                {\n+            else {\n+                if (externalIPAddress[0]) {\n                     CNetAddr resolved;\n-                    if(LookupHost(externalIPAddress, resolved, false)) {\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n                         LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString().c_str());\n                         AddLocal(resolved, LOCAL_UPNP);\n                     }\n-                }\n-                else\n+                } else\n                     LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n             }\n         }\n@@ -1539,28 +1488,29 @@ static void ThreadMapPort()\n #ifndef UPNPDISCOVER_SUCCESS\n             /* miniupnpc 1.5 */\n             r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n+                port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n #else\n             /* miniupnpc 1.6 */\n             r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+                port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n #endif\n \n-            if(r!=UPNPCOMMAND_SUCCESS)\n+            if (r != UPNPCOMMAND_SUCCESS)\n                 LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                     port, port, lanaddr, r, strupnperror(r));\n             else\n                 LogPrintf(\"UPnP Port Mapping successful.\\n\");\n-        }\n-        while(g_upnp_interrupt.sleep_for(std::chrono::minutes(20)));\n+        } while (g_upnp_interrupt.sleep_for(std::chrono::minutes(20)));\n \n         r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n         LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n-        freeUPNPDevlist(devlist); devlist = nullptr;\n+        freeUPNPDevlist(devlist);\n+        devlist = nullptr;\n         FreeUPNPUrls(&urls);\n     } else {\n         LogPrintf(\"No valid UPnP IGDs found\\n\");\n-        freeUPNPDevlist(devlist); devlist = nullptr;\n+        freeUPNPDevlist(devlist);\n+        devlist = nullptr;\n         if (r != 0)\n             FreeUPNPUrls(&urls);\n     }\n@@ -1576,14 +1526,14 @@ void StartMapPort()\n \n void InterruptMapPort()\n {\n-    if(g_upnp_thread.joinable()) {\n+    if (g_upnp_thread.joinable()) {\n         g_upnp_interrupt();\n     }\n }\n \n void StopMapPort()\n {\n-    if(g_upnp_thread.joinable()) {\n+    if (g_upnp_thread.joinable()) {\n         g_upnp_thread.join();\n         g_upnp_interrupt.reset();\n     }\n@@ -1605,10 +1555,6 @@ void StopMapPort()\n #endif\n \n \n-\n-\n-\n-\n void CConnman::ThreadDNSAddressSeed()\n {\n     // goal: only query DNS seeds if address need is acute\n@@ -1631,12 +1577,12 @@ void CConnman::ThreadDNSAddressSeed()\n         }\n     }\n \n-    const std::vector<std::string> &vSeeds = Params().DNSSeeds();\n+    const std::vector<std::string>& vSeeds = Params().DNSSeeds();\n     int found = 0;\n \n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-    for (const std::string &seed : vSeeds) {\n+    for (const std::string& seed : vSeeds) {\n         if (interruptNet) {\n             return;\n         }\n@@ -1652,13 +1598,11 @@ void CConnman::ThreadDNSAddressSeed()\n                 continue;\n             }\n             unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed\n-            if (LookupHost(host.c_str(), vIPs, nMaxIPs, true))\n-            {\n-                for (const CNetAddr& ip : vIPs)\n-                {\n-                    int nOneDay = 24*3600;\n+            if (LookupHost(host.c_str(), vIPs, nMaxIPs, true)) {\n+                for (const CNetAddr& ip : vIPs) {\n+                    int nOneDay = 24 * 3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);\n-                    addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n+                    addr.nTime = GetTime() - 3 * nOneDay - GetRand(4 * nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n@@ -1675,16 +1619,6 @@ void CConnman::ThreadDNSAddressSeed()\n }\n \n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n void CConnman::DumpAddresses()\n {\n     int64_t nStart = GetTimeMillis();\n@@ -1693,7 +1627,7 @@ void CConnman::DumpAddresses()\n     adb.Write(addrman);\n \n     LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+        addrman.size(), GetTimeMillis() - nStart);\n }\n \n void CConnman::DumpData()\n@@ -1753,17 +1687,13 @@ int CConnman::GetExtraOutboundCount()\n void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n {\n     // Connect to specific addresses\n-    if (!connect.empty())\n-    {\n-        for (int64_t nLoop = 0;; nLoop++)\n-        {\n+    if (!connect.empty()) {\n+        for (int64_t nLoop = 0;; nLoop++) {\n             ProcessOneShot();\n-            for (const std::string& strAddr : connect)\n-            {\n+            for (const std::string& strAddr : connect) {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, nullptr, strAddr.c_str(), false, false, true);\n-                for (int i = 0; i < 10 && i < nLoop; i++)\n-                {\n+                for (int i = 0; i < 10 && i < nLoop; i++) {\n                     if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))\n                         return;\n                 }\n@@ -1777,9 +1707,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n     int64_t nStart = GetTime();\n \n     // Minimum time before next feeler connection (in microseconds).\n-    int64_t nNextFeeler = PoissonNextSend(nStart*1000*1000, FEELER_INTERVAL);\n-    while (!interruptNet)\n-    {\n+    int64_t nNextFeeler = PoissonNextSend(nStart * 1000 * 1000, FEELER_INTERVAL);\n+    while (!interruptNet) {\n         ProcessOneShot();\n \n         if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))\n@@ -1808,7 +1737,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n \n         // Only connect out to one peer per network group (/16 for IPv4).\n         int nOutbound = 0;\n-        std::set<std::vector<unsigned char> > setConnected;\n+        std::set<std::vector<unsigned char>> setConnected;\n         {\n             LOCK(cs_vNodes);\n             for (const CNode* pnode : vNodes) {\n@@ -1852,8 +1781,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n \n         int64_t nANow = GetAdjustedTime();\n         int nTries = 0;\n-        while (!interruptNet)\n-        {\n+        while (!interruptNet) {\n             CAddrInfo addr = addrman.SelectTriedCollision();\n \n             // SelectTriedCollision returns an invalid address if it is empty.\n@@ -1897,7 +1825,6 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         }\n \n         if (addrConnect.IsValid()) {\n-\n             if (fFeeler) {\n                 // Add small amount of random noise before connection to avoid synchronization.\n                 int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);\n@@ -1967,8 +1894,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n \n void CConnman::ThreadOpenAddedConnections()\n {\n-    while (true)\n-    {\n+    while (true) {\n         CSemaphoreGrant grant(*semAddnode);\n         std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();\n         bool tried = false;\n@@ -1993,7 +1919,7 @@ void CConnman::ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool manual_connection)\n+void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* pszDest, bool fOneShot, bool fFeeler, bool manual_connection)\n {\n     //\n     // Initiate outbound network connection\n@@ -2034,8 +1960,7 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n \n void CConnman::ThreadMessageHandler()\n {\n-    while (!flagInterruptMsgProc)\n-    {\n+    while (!flagInterruptMsgProc) {\n         std::vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n@@ -2047,8 +1972,7 @@ void CConnman::ThreadMessageHandler()\n \n         bool fMoreWork = false;\n \n-        for (CNode* pnode : vNodesCopy)\n-        {\n+        for (CNode* pnode : vNodesCopy) {\n             if (pnode->fDisconnect)\n                 continue;\n \n@@ -2082,28 +2006,22 @@ void CConnman::ThreadMessageHandler()\n }\n \n \n-\n-\n-\n-\n-bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, bool fWhitelisted)\n+bool CConnman::BindListenPort(const CService& addrBind, std::string& strError, bool fWhitelisted)\n {\n     strError = \"\";\n     int nOne = 1;\n \n     // Create socket for listening for incoming connections\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n+    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n         strError = strprintf(\"Error: Bind address family for %s not supported\", addrBind.ToString());\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n     SOCKET hListenSocket = CreateSocket(addrBind);\n-    if (hListenSocket == INVALID_SOCKET)\n-    {\n+    if (hListenSocket == INVALID_SOCKET) {\n         strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n@@ -2125,8 +2043,7 @@ bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, b\n #endif\n     }\n \n-    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n-    {\n+    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR) {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n             strError = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), addrBind.ToString(), _(PACKAGE_NAME));\n@@ -2139,8 +2056,7 @@ bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, b\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n-    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n-    {\n+    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR) {\n         strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         CloseSocket(hListenSocket);\n@@ -2163,13 +2079,10 @@ void Discover()\n #ifdef WIN32\n     // Get local host IP\n     char pszHostName[256] = \"\";\n-    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n-    {\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR) {\n         std::vector<CNetAddr> vaddr;\n-        if (LookupHost(pszHostName, vaddr, 0, true))\n-        {\n-            for (const CNetAddr &addr : vaddr)\n-            {\n+        if (LookupHost(pszHostName, vaddr, 0, true)) {\n+            for (const CNetAddr& addr : vaddr) {\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());\n             }\n@@ -2178,23 +2091,18 @@ void Discover()\n #elif (HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS)\n     // Get local host ip\n     struct ifaddrs* myaddrs;\n-    if (getifaddrs(&myaddrs) == 0)\n-    {\n-        for (struct ifaddrs* ifa = myaddrs; ifa != nullptr; ifa = ifa->ifa_next)\n-        {\n+    if (getifaddrs(&myaddrs) == 0) {\n+        for (struct ifaddrs* ifa = myaddrs; ifa != nullptr; ifa = ifa->ifa_next) {\n             if (ifa->ifa_addr == nullptr) continue;\n             if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n             if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n             if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n-            if (ifa->ifa_addr->sa_family == AF_INET)\n-            {\n+            if (ifa->ifa_addr->sa_family == AF_INET) {\n                 struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                 CNetAddr addr(s4->sin_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());\n-            }\n-            else if (ifa->ifa_addr->sa_family == AF_INET6)\n-            {\n+            } else if (ifa->ifa_addr->sa_family == AF_INET6) {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 CNetAddr addr(s6->sin6_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n@@ -2241,7 +2149,8 @@ NodeId CConnman::GetNewNodeId()\n }\n \n \n-bool CConnman::Bind(const CService &addr, unsigned int flags) {\n+bool CConnman::Bind(const CService& addr, unsigned int flags)\n+{\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n         return false;\n     std::string strError;\n@@ -2254,7 +2163,8 @@ bool CConnman::Bind(const CService &addr, unsigned int flags) {\n     return true;\n }\n \n-bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds) {\n+bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds)\n+{\n     bool fBound = false;\n     for (const auto& addrBind : binds) {\n         fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n@@ -2322,9 +2232,9 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n     CBanDB bandb;\n     banmap_t banmap;\n     if (bandb.Read(banmap)) {\n-        SetBanned(banmap); // thread save setter\n+        SetBanned(banmap);        // thread save setter\n         SetBannedSetDirty(false); // no need to write down, just read data\n-        SweepBanned(); // sweep out unused entries\n+        SweepBanned();            // sweep out unused entries\n \n         LogPrint(BCLog::NET, \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n             banmap.size(), GetTimeMillis() - nStart);\n@@ -2361,15 +2271,15 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n     }\n \n     // Send and receive from sockets, accept connections\n-    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, \"net\", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));\n+    threadSocketHandler = std::thread(&TraceThread<std::function<void()>>, \"net\", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));\n \n     if (!gArgs.GetBoolArg(\"-dnsseed\", true))\n         LogPrintf(\"DNS seeding disabled\\n\");\n     else\n-        threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, \"dnsseed\", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));\n+        threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()>>, \"dnsseed\", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));\n \n     // Initiate outbound connections from -addnode\n-    threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, \"addcon\", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));\n+    threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()>>, \"addcon\", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));\n \n     if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {\n         if (clientInterface) {\n@@ -2380,10 +2290,10 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n         return false;\n     }\n     if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())\n-        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));\n+        threadOpenConnections = std::thread(&TraceThread<std::function<void()>>, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));\n \n     // Process messages\n-    threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, \"msghand\", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));\n+    threadMessageHandler = std::thread(&TraceThread<std::function<void()>>, \"msghand\", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));\n \n     // Dump network addresses\n     scheduler.scheduleEvery(std::bind(&CConnman::DumpData, this), DUMP_ADDRESSES_INTERVAL * 1000);\n@@ -2403,8 +2313,7 @@ class CNetCleanup\n         WSACleanup();\n #endif\n     }\n-}\n-instance_of_cnetcleanup;\n+} instance_of_cnetcleanup;\n \n void CConnman::Interrupt()\n {\n@@ -2418,13 +2327,13 @@ void CConnman::Interrupt()\n     InterruptSocks5(true);\n \n     if (semOutbound) {\n-        for (int i=0; i<(nMaxOutbound + nMaxFeeler); i++) {\n+        for (int i = 0; i < (nMaxOutbound + nMaxFeeler); i++) {\n             semOutbound->post();\n         }\n     }\n \n     if (semAddnode) {\n-        for (int i=0; i<nMaxAddnode; i++) {\n+        for (int i = 0; i < nMaxAddnode; i++) {\n             semAddnode->post();\n         }\n     }\n@@ -2443,8 +2352,7 @@ void CConnman::Stop()\n     if (threadSocketHandler.joinable())\n         threadSocketHandler.join();\n \n-    if (fAddressesInitialized)\n-    {\n+    if (fAddressesInitialized) {\n         DumpData();\n         fAddressesInitialized = false;\n     }\n@@ -2458,10 +2366,10 @@ void CConnman::Stop()\n                 LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n     // clean up some globals (to help leak detection)\n-    for (CNode *pnode : vNodes) {\n+    for (CNode* pnode : vNodes) {\n         DeleteNode(pnode);\n     }\n-    for (CNode *pnode : vNodesDisconnected) {\n+    for (CNode* pnode : vNodesDisconnected) {\n         DeleteNode(pnode);\n     }\n     vNodes.clear();\n@@ -2476,7 +2384,7 @@ void CConnman::DeleteNode(CNode* pnode)\n     assert(pnode);\n     bool fUpdateConnectionTime = false;\n     m_msgproc->FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n-    if(fUpdateConnectionTime) {\n+    if (fUpdateConnectionTime) {\n         addrman.Connected(pnode->addr);\n     }\n     delete pnode;\n@@ -2493,7 +2401,7 @@ size_t CConnman::GetAddressCount() const\n     return addrman.size();\n }\n \n-void CConnman::SetServices(const CService &addr, ServiceFlags nServices)\n+void CConnman::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     addrman.SetServices(addr, nServices);\n }\n@@ -2527,7 +2435,7 @@ bool CConnman::AddNode(const std::string& strNode)\n bool CConnman::RemoveAddedNode(const std::string& strNode)\n {\n     LOCK(cs_vAddedNodes);\n-    for(std::vector<std::string>::iterator it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n+    for (std::vector<std::string>::iterator it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n         if (strNode == *it) {\n             vAddedNodes.erase(it);\n             return true;\n@@ -2575,7 +2483,7 @@ bool CConnman::DisconnectNode(const std::string& strNode)\n bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(cs_vNodes);\n-    for(CNode* pnode : vNodes) {\n+    for (CNode* pnode : vNodes) {\n         if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n             return true;\n@@ -2596,8 +2504,7 @@ void CConnman::RecordBytesSent(uint64_t bytes)\n     nTotalBytesSent += bytes;\n \n     uint64_t now = GetTime();\n-    if (nMaxOutboundCycleStartTime + nMaxOutboundTimeframe < now)\n-    {\n+    if (nMaxOutboundCycleStartTime + nMaxOutboundTimeframe < now) {\n         // timeframe expired, reset cycle\n         nMaxOutboundCycleStartTime = now;\n         nMaxOutboundTotalBytesSentInCycle = 0;\n@@ -2642,8 +2549,7 @@ uint64_t CConnman::GetMaxOutboundTimeLeftInCycle()\n void CConnman::SetMaxOutboundTimeframe(uint64_t timeframe)\n {\n     LOCK(cs_totalBytesSent);\n-    if (nMaxOutboundTimeframe != timeframe)\n-    {\n+    if (nMaxOutboundTimeframe != timeframe) {\n         // reset measure-cycle in case of changing\n         // the timeframe\n         nMaxOutboundCycleStartTime = GetTime();\n@@ -2657,15 +2563,13 @@ bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit)\n     if (nMaxOutboundLimit == 0)\n         return false;\n \n-    if (historicalBlockServingLimit)\n-    {\n+    if (historicalBlockServingLimit) {\n         // keep a large enough buffer to at least relay each block once\n         uint64_t timeLeftInCycle = GetMaxOutboundTimeLeftInCycle();\n         uint64_t buffer = timeLeftInCycle / 600 * MAX_BLOCK_SERIALIZED_SIZE;\n         if (buffer >= nMaxOutboundLimit || nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit - buffer)\n             return true;\n-    }\n-    else if (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit)\n+    } else if (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit)\n         return true;\n \n     return false;\n@@ -2709,19 +2613,18 @@ int CConnman::GetBestHeight() const\n \n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n \n-CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string& addrNameIn, bool fInboundIn) :\n-    nTimeConnected(GetSystemTimeInSeconds()),\n-    addr(addrIn),\n-    addrBind(addrBindIn),\n-    fInbound(fInboundIn),\n-    nKeyedNetGroup(nKeyedNetGroupIn),\n-    addrKnown(5000, 0.001),\n-    filterInventoryKnown(50000, 0.000001),\n-    id(idIn),\n-    nLocalHostNonce(nLocalHostNonceIn),\n-    nLocalServices(nLocalServicesIn),\n-    nMyStartingHeight(nMyStartingHeightIn),\n-    nSendVersion(0)\n+CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, bool fInboundIn) : nTimeConnected(GetSystemTimeInSeconds()),\n+                                                                                                                                                                                                                                                                 addr(addrIn),\n+                                                                                                                                                                                                                                                                 addrBind(addrBindIn),\n+                                                                                                                                                                                                                                                                 fInbound(fInboundIn),\n+                                                                                                                                                                                                                                                                 nKeyedNetGroup(nKeyedNetGroupIn),\n+                                                                                                                                                                                                                                                                 addrKnown(5000, 0.001),\n+                                                                                                                                                                                                                                                                 filterInventoryKnown(50000, 0.000001),\n+                                                                                                                                                                                                                                                                 id(idIn),\n+                                                                                                                                                                                                                                                                 nLocalHostNonce(nLocalHostNonceIn),\n+                                                                                                                                                                                                                                                                 nLocalServices(nLocalServicesIn),\n+                                                                                                                                                                                                                                                                 nMyStartingHeight(nMyStartingHeightIn),\n+                                                                                                                                                                                                                                                                 nSendVersion(0)\n {\n     nServices = NODE_NONE;\n     hSocket = hSocketIn;\n@@ -2737,7 +2640,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fWhitelisted = false;\n     fOneShot = false;\n     m_manual_connection = false;\n-    fClient = false; // set by version message\n+    fClient = false;        // set by version message\n     m_limited_node = false; // set by version message\n     fFeeler = false;\n     fSuccessfullyConnected = false;\n@@ -2771,7 +2674,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fPauseSend = false;\n     nProcessQueueSize = 0;\n \n-    for (const std::string &msg : getAllNetMessageTypes())\n+    for (const std::string& msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n@@ -2803,7 +2706,7 @@ void CNode::AskFor(const CInv& inv)\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n-    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, FormatISO8601Time(nRequestTime/1000000), id);\n+    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, FormatISO8601Time(nRequestTime / 1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;\n@@ -2830,7 +2733,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n@@ -2868,7 +2771,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n     CNode* found = nullptr;\n     LOCK(cs_vNodes);\n     for (auto&& pnode : vNodes) {\n-        if(pnode->GetId() == id) {\n+        if (pnode->GetId() == id) {\n             found = pnode;\n             break;\n         }"
      },
      {
        "sha": "7794da4ca537304494e71f178554230464bd5c1e",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 5,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6aaecfd2169d7784796fb3f5fe9542141747995/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6aaecfd2169d7784796fb3f5fe9542141747995/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=c6aaecfd2169d7784796fb3f5fe9542141747995",
        "patch": "@@ -2,15 +2,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <addrman.h>\n-#include <test/test_bitcoin.h>\n-#include <string>\n #include <boost/test/unit_test.hpp>\n+#include <chainparams.h>\n #include <hash.h>\n-#include <serialize.h>\n-#include <streams.h>\n #include <net.h>\n #include <netbase.h>\n-#include <chainparams.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <string>\n+#include <test/test_bitcoin.h>\n #include <util/system.h>\n \n #include <memory>\n@@ -227,4 +227,91 @@ BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n     BOOST_CHECK(1);\n }\n \n+\n+BOOST_AUTO_TEST_CASE(LimitedAndReachable_Network)\n+{\n+    SetLimited(NET_IPV4, true);\n+    SetLimited(NET_IPV6, true);\n+    SetLimited(NET_ONION, true);\n+\n+    BOOST_CHECK_EQUAL(IsLimited(NET_IPV4), true);\n+    BOOST_CHECK_EQUAL(IsLimited(NET_IPV6), true);\n+    BOOST_CHECK_EQUAL(IsLimited(NET_ONION), true);\n+\n+    BOOST_CHECK_EQUAL(IsReachable(NET_IPV4), false);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_IPV6), false);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_ONION), false);\n+\n+\n+    SetLimited(NET_IPV4, false);\n+    SetLimited(NET_IPV6, false);\n+    SetLimited(NET_ONION, false);\n+\n+    BOOST_CHECK_EQUAL(IsLimited(NET_IPV4), false);\n+    BOOST_CHECK_EQUAL(IsLimited(NET_IPV6), false);\n+    BOOST_CHECK_EQUAL(IsLimited(NET_ONION), false);\n+\n+    BOOST_CHECK_EQUAL(IsReachable(NET_IPV4), true);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_IPV6), true);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_ONION), true);\n+}\n+\n+BOOST_AUTO_TEST_CASE(LimitedAndReachable_NetworkCaseUnroutableAndInternal)\n+{\n+    BOOST_CHECK_EQUAL(IsLimited(NET_UNROUTABLE), false);\n+    BOOST_CHECK_EQUAL(IsLimited(NET_INTERNAL), false);\n+\n+    BOOST_CHECK_EQUAL(IsReachable(NET_UNROUTABLE), true);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_INTERNAL), true);\n+\n+    SetLimited(NET_UNROUTABLE, true);\n+    SetLimited(NET_INTERNAL, true);\n+\n+    BOOST_CHECK_EQUAL(IsLimited(NET_UNROUTABLE), false); // Ignored for both networks\n+    BOOST_CHECK_EQUAL(IsLimited(NET_INTERNAL), false);\n+\n+    BOOST_CHECK_EQUAL(IsReachable(NET_UNROUTABLE), true);\n+    BOOST_CHECK_EQUAL(IsReachable(NET_INTERNAL), true);\n+}\n+\n+CNetAddr UtilBuildAddress(unsigned char p1, unsigned char p2, unsigned char p3, unsigned char p4)\n+{\n+    unsigned char ip[] = {p1, p2, p3, p4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    return CNetAddr(sa.sin_addr);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(LimitedAndReachable_CNetAddr)\n+{\n+    CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, 0x001); // 1.1.1.1\n+\n+    SetLimited(NET_IPV4, false);\n+    BOOST_CHECK_EQUAL(IsLimited(addr), false);\n+    BOOST_CHECK_EQUAL(IsReachable(addr), true);\n+\n+    SetLimited(NET_IPV4, true);\n+    BOOST_CHECK_EQUAL(IsLimited(addr), true);\n+    BOOST_CHECK_EQUAL(IsReachable(addr), false);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(LocalAddress_BasicLifecycle)\n+{\n+    CService addr = CService(UtilBuildAddress(0x002, 0x001, 0x001, 0x001), 1000); // 2.1.1.1:1000\n+\n+    SetLimited(NET_IPV4, false);\n+\n+    BOOST_CHECK_EQUAL(IsLocal(addr), false);\n+    BOOST_CHECK_EQUAL(AddLocal(addr, 1000), true);\n+    BOOST_CHECK_EQUAL(IsLocal(addr), true);\n+\n+    RemoveLocal(addr);\n+    BOOST_CHECK_EQUAL(IsLocal(addr), false);\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNDkyYzI2M2ZlMGFjOTRkMGUzYjdlYWRjMGQ2NGUxNGZlZTk1ZDJh",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-27T19:23:53Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-27T19:23:53Z"
      },
      "message": "Stateful value have to be resetted",
      "tree": {
        "sha": "051eb023253b4ae2c78173af410395f365bbb49a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/051eb023253b4ae2c78173af410395f365bbb49a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6aaecfd2169d7784796fb3f5fe9542141747995",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6aaecfd2169d7784796fb3f5fe9542141747995",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6aaecfd2169d7784796fb3f5fe9542141747995"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c5b1dc12e3a50c9114774700034bfd0f2f027dd",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=d492c263fe0ac94d0e3b7eadc0d64e14fee95d2a",
        "patch": "@@ -296,6 +296,8 @@ BOOST_AUTO_TEST_CASE(LimitedAndReachable_CNetAddr)\n     SetLimited(NET_IPV4, true);\n     BOOST_CHECK_EQUAL(IsLimited(addr), true);\n     BOOST_CHECK_EQUAL(IsReachable(addr), false);\n+\n+    SetLimited(NET_IPV4, false); // have to reset this, because this is stateful.\n }\n \n "
      }
    ]
  }
]