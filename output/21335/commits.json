[
  {
    "sha": "6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NDc0YzlmMWVkNDcyZDdiYTRiNDM5MWRjNDQ1NWM0MWY1MTYzYzI4",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-02-18T22:45:02Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T13:59:55Z"
      },
      "message": "Add minisketch dependency",
      "tree": {
        "sha": "27bfd90dafb35ba464374ad7b7c3a7a1a6dc3865",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27bfd90dafb35ba464374ad7b7c3a7a1a6dc3865"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9307c588d0bedda484487af89f215109d150a598",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9307c588d0bedda484487af89f215109d150a598",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9307c588d0bedda484487af89f215109d150a598"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 37,
      "deletions": 21
    },
    "files": [
      {
        "sha": "ffa2fa65d4796b9adcb580aee8745d0122c58d76",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -205,6 +205,7 @@ LCOV_FILTER_PATTERN = \\\n \t-p \"src/bench/\" \\\n \t-p \"src/univalue\" \\\n \t-p \"src/crypto/ctaes\" \\\n+\t-p \"src/minisketch\" \\\n \t-p \"src/secp256k1\" \\\n \t-p \"depends\"\n "
      },
      {
        "sha": "e606ecdc0845ea13f748368c69bd53c78ade9faf",
        "filename": "ci/lint/06_script.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/ci/lint/06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/ci/lint/06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/06_script.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -17,6 +17,7 @@ export COMMIT_RANGE\n # check with -r to not have to fetch all the remotes.\n test/lint/git-subtree-check.sh src/crypto/ctaes\n test/lint/git-subtree-check.sh src/secp256k1\n+test/lint/git-subtree-check.sh src/minisketch\n test/lint/git-subtree-check.sh src/univalue\n test/lint/git-subtree-check.sh src/leveldb\n test/lint/git-subtree-check.sh src/crc32c"
      },
      {
        "sha": "04d80be222447821fdb45c049a3e782e065d9a06",
        "filename": "ci/test/06_script_b.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/ci/test/06_script_b.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/ci/test/06_script_b.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/06_script_b.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -9,13 +9,15 @@ export LC_ALL=C.UTF-8\n if [[ $HOST = *-mingw32 ]]; then\n   # Generate all binaries, so that they can be wrapped\n   DOCKER_EXEC make $MAKEJOBS -C src/secp256k1 VERBOSE=1\n+  DOCKER_EXEC make $MAKEJOBS -C src/minisketch VERBOSE=1\n   DOCKER_EXEC make $MAKEJOBS -C src/univalue VERBOSE=1\n   DOCKER_EXEC \"${BASE_ROOT_DIR}/ci/test/wrap-wine.sh\"\n fi\n \n if [ -n \"$QEMU_USER_CMD\" ]; then\n   # Generate all binaries, so that they can be wrapped\n   DOCKER_EXEC make $MAKEJOBS -C src/secp256k1 VERBOSE=1\n+  DOCKER_EXEC make $MAKEJOBS -C src/minisketch VERBOSE=1\n   DOCKER_EXEC make $MAKEJOBS -C src/univalue VERBOSE=1\n   DOCKER_EXEC \"${BASE_ROOT_DIR}/ci/test/wrap-qemu.sh\"\n fi"
      },
      {
        "sha": "3a847c4ef8aa1456e3d558f2b7e8ca40fe486295",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -1880,7 +1880,7 @@ if test x$need_bundled_univalue = xyes; then\n fi\n \n ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"\n-AC_CONFIG_SUBDIRS([src/secp256k1])\n+AC_CONFIG_SUBDIRS([src/secp256k1 src/minisketch])\n \n AC_OUTPUT\n "
      },
      {
        "sha": "6cb15aefdf79afea948559fc5df15c56bf307e1c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 14,
        "deletions": 6,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -6,7 +6,7 @@\n print-%:\n \t@echo '$*' = '$($*)'\n \n-DIST_SUBDIRS = secp256k1 univalue\n+DIST_SUBDIRS = secp256k1 minisketch univalue\n \n AM_LDFLAGS = $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS) $(GPROF_LDFLAGS) $(SANITIZER_LDFLAGS)\n AM_CXXFLAGS = $(DEBUG_CXXFLAGS) $(HARDENED_CXXFLAGS) $(WARN_CXXFLAGS) $(NOWARN_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS) $(SANITIZER_CXXFLAGS)\n@@ -24,7 +24,7 @@ else\n LIBUNIVALUE = $(UNIVALUE_LIBS)\n endif\n \n-BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/secp256k1/include $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)\n+BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/secp256k1/include -I$(srcdir)/minisketch/include $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)\n \n BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n \n@@ -36,6 +36,7 @@ LIBBITCOIN_UTIL=libbitcoin_util.a\n LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n+LIBMINISKETCH=minisketch/libminisketch.la\n \n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n@@ -65,6 +66,10 @@ endif\n $(LIBSECP256K1): $(wildcard secp256k1/src/*.h) $(wildcard secp256k1/src/*.c) $(wildcard secp256k1/include/*)\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n \n+$(LIBMINISKETCH): $(wildcard minisketch/src/*.h) $(wildcard minisketch/src/*.c) $(wildcard minisketch/include/*)\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n+\n+\n # Make is not made aware of per-object dependencies to avoid limiting building parallelization\n # But to build the less dependent modules first, we manually select their order here:\n EXTRA_LIBRARIES += \\\n@@ -622,7 +627,8 @@ bitcoin_bin_ldadd = \\\n   $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n-  $(LIBSECP256K1)\n+  $(LIBSECP256K1) \\\n+  $(LIBMINISKETCH)\n \n bitcoin_bin_ldadd += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(SQLITE_LIBS)\n \n@@ -673,7 +679,8 @@ bitcoin_tx_LDADD = \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n-  $(LIBSECP256K1)\n+  $(LIBSECP256K1) \\\n+  $(LIBMINISKETCH)\n \n bitcoin_tx_LDADD += $(BOOST_LIBS)\n #\n@@ -721,8 +728,8 @@ if GLIBC_BACK_COMPAT\n endif\n \n libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n-libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\n+libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1) $(LIBMINISKETCH)\n+libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -I$(srcdir)/minisketch/include -DBUILD_BITCOIN_INTERNAL\n libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n endif\n@@ -768,6 +775,7 @@ $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n \n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n+\t-$(MAKE) -C minisketch clean\n \t-$(MAKE) -C univalue clean\n \t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\n \t-rm -f config.h"
      },
      {
        "sha": "37d0312c62c8e1b29b1d54ce453c03a4c0315ee4",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -61,6 +61,7 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1) \\\n+  $(LIBMINISKETCH) \\\n   $(LIBUNIVALUE) \\\n   $(EVENT_PTHREADS_LIBS) \\\n   $(EVENT_LIBS)"
      },
      {
        "sha": "58c4a3aaf36a10762213774205e24d5fe0ab205c",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -325,7 +325,7 @@ if ENABLE_ZMQ\n bitcoin_qt_ldadd += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n bitcoin_qt_ldadd += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n+  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) $(LIBMINISKETCH) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n bitcoin_qt_ldflags = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n bitcoin_qt_libtoolflags = $(AM_LIBTOOLFLAGS) --tag CXX"
      },
      {
        "sha": "113930607ddb0a91424647dbb9738c79c5d0a901",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -55,7 +55,7 @@ qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n-  $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n+  $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) $(LIBMINISKETCH) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)"
      },
      {
        "sha": "d362214aff31319feee1b1f8eb0cc4de569cb776",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -49,6 +49,7 @@ FUZZ_SUITE_LD_COMMON = \\\n  $(BOOST_LIBS) \\\n  $(LIBMEMENV) \\\n  $(LIBSECP256K1) \\\n+ $(LIBMINISKETCH) \\\n  $(EVENT_LIBS) \\\n  $(EVENT_PTHREADS_LIBS)\n \n@@ -181,7 +182,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n \n test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n-  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n+  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(LIBMINISKETCH) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n test_test_bitcoin_LDADD += $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS)\n@@ -336,6 +337,7 @@ if ENABLE_BENCH\n endif\n endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C minisketch check\n if EMBEDDED_UNIVALUE\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C univalue check\n endif"
      },
      {
        "sha": "aef22be6605813376324153c623f08d68defb5fa",
        "filename": "test/lint/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/README.md?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -27,6 +27,7 @@ Usage: test/lint/git-subtree-check.sh [-r] DIR [COMMIT]\n To do a full check with `-r`, make sure that you have fetched the upstream repository branch in which the subtree is\n maintained:\n * for `src/secp256k1`: https://github.com/bitcoin-core/secp256k1.git (branch master)\n+* for `src/minisketch`: https://github.com/sipa/minisketch.git (branch master)\n * for `src/leveldb`: https://github.com/bitcoin-core/leveldb.git (branch bitcoin-fork)\n * for `src/univalue`: https://github.com/bitcoin-core/univalue.git (branch master)\n * for `src/crypto/ctaes`: https://github.com/bitcoin-core/ctaes.git (branch master)"
      },
      {
        "sha": "49b3cfd6ab7e5bba57948bc5194f20631f34e00e",
        "filename": "test/lint/extended-lint-cppcheck.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/extended-lint-cppcheck.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/extended-lint-cppcheck.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/extended-lint-cppcheck.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -74,7 +74,7 @@ function join_array {\n \n ENABLED_CHECKS_REGEXP=$(join_array \"|\" \"${ENABLED_CHECKS[@]}\")\n IGNORED_WARNINGS_REGEXP=$(join_array \"|\" \"${IGNORED_WARNINGS[@]}\")\n-WARNINGS=$(git ls-files -- \"*.cpp\" \"*.h\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" | \\\n+WARNINGS=$(git ls-files -- \"*.cpp\" \"*.h\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/minisketch/\" \":(exclude)src/univalue/\" | \\\n     xargs cppcheck --enable=all -j \"$(getconf _NPROCESSORS_ONLN)\" --language=c++ --std=c++17 --template=gcc -D__cplusplus -DCLIENT_VERSION_BUILD -DCLIENT_VERSION_IS_RELEASE -DCLIENT_VERSION_MAJOR -DCLIENT_VERSION_MINOR -DCOPYRIGHT_YEAR -DDEBUG -I src/ -q 2>&1 | sort -u | \\\n     grep -E \"${ENABLED_CHECKS_REGEXP}\" | \\\n     grep -vE \"${IGNORED_WARNINGS_REGEXP}\")"
      },
      {
        "sha": "5876cd171780639b358b5e136efe9a08e555ee95",
        "filename": "test/lint/lint-filenames.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-filenames.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-filenames.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-filenames.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -12,7 +12,7 @@ export LC_ALL=C\n EXIT_CODE=0\n OUTPUT=$(git ls-files --full-name -- \"*.[cC][pP][pP]\" \"*.[hH]\" \"*.[pP][yY]\" \"*.[sS][hH]\" | \\\n     grep -vE '^[a-z0-9_./-]+$' | \\\n-    grep -vE '^src/(secp256k1/|univalue/|test/fuzz/FuzzedDataProvider.h)')\n+    grep -vE '^src/(secp256k1/|minisketch/|univalue/|test/fuzz/FuzzedDataProvider.h)')\n \n if [[ ${OUTPUT} != \"\" ]]; then\n     echo \"Use only lowercase alphanumerics (a-z0-9), underscores (_), hyphens (-) and dots (.)\""
      },
      {
        "sha": "d98f12b1a1b3af8b281b223befe508dd24148173",
        "filename": "test/lint/lint-format-strings.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-format-strings.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-format-strings.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-format-strings.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -34,7 +34,7 @@ if ! python3 -m doctest test/lint/lint-format-strings.py; then\n fi\n for S in \"${FUNCTION_NAMES_AND_NUMBER_OF_LEADING_ARGUMENTS[@]}\"; do\n     IFS=\",\" read -r FUNCTION_NAME SKIP_ARGUMENTS <<< \"${S}\"\n-    for MATCHING_FILE in $(git grep --full-name -l \"${FUNCTION_NAME}\" -- \"*.c\" \"*.cpp\" \"*.h\" | sort | grep -vE \"^src/(leveldb|secp256k1|tinyformat|univalue|test/fuzz/strprintf.cpp)\"); do\n+    for MATCHING_FILE in $(git grep --full-name -l \"${FUNCTION_NAME}\" -- \"*.c\" \"*.cpp\" \"*.h\" | sort | grep -vE \"^src/(leveldb|secp256k1|minisketch|tinyformat|univalue|test/fuzz/strprintf.cpp)\"); do\n         MATCHING_FILES+=(\"${MATCHING_FILE}\")\n     done\n     if ! test/lint/lint-format-strings.py --skip-arguments \"${SKIP_ARGUMENTS}\" \"${FUNCTION_NAME}\" \"${MATCHING_FILES[@]}\"; then"
      },
      {
        "sha": "dd52c382be79c2464734df0e3230d55da63b67bd",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -10,7 +10,7 @@ export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n \n-REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|bench/nanobench.h|univalue/)\"\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|minisketch/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|bench/nanobench.h|univalue/)\"\n \n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")"
      },
      {
        "sha": "e9893558e4e729bd19ee3a023ab512d1b5a72339",
        "filename": "test/lint/lint-includes.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-includes.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -9,7 +9,7 @@\n # Check includes: Check for duplicate includes. Enforce bracket syntax includes.\n \n export LC_ALL=C\n-IGNORE_REGEXP=\"/(leveldb|secp256k1|univalue|crc32c)/\"\n+IGNORE_REGEXP=\"/(leveldb|secp256k1|minisketch|univalue|crc32c)/\"\n \n # cd to root folder of git repo for git ls-files to work properly\n cd \"$(dirname $0)/../..\" || exit 1"
      },
      {
        "sha": "921d02cd7cdf23c984b302918cac6495b96af33f",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -58,7 +58,7 @@ KNOWN_VIOLATIONS=(\n     \"src/util/system.cpp:.*atoi\"\n )\n \n-REGEXP_IGNORE_EXTERNAL_DEPENDENCIES=\"^src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+REGEXP_IGNORE_EXTERNAL_DEPENDENCIES=\"^src/(crypto/ctaes/|leveldb/|secp256k1/|minisketch/|tinyformat.h|univalue/)\"\n \n LOCALE_DEPENDENT_FUNCTIONS=(\n     alphasort    # LC_COLLATE (via strcoll)"
      },
      {
        "sha": "bd6b6ce05c49a130470ddab5dc37f8274cc8c4be",
        "filename": "test/lint/lint-shell-locale.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-shell-locale.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-shell-locale.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shell-locale.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -12,7 +12,7 @@\n export LC_ALL=C\n \n EXIT_CODE=0\n-for SHELL_SCRIPT in $(git ls-files -- \"*.sh\" | grep -vE \"src/(secp256k1|univalue)/\"); do\n+for SHELL_SCRIPT in $(git ls-files -- \"*.sh\" | grep -vE \"src/(secp256k1|minisketch|univalue)/\"); do\n     if grep -q \"# This script is intentionally locale dependent by not setting \\\"export LC_ALL=C\\\"\" \"${SHELL_SCRIPT}\"; then\n         continue\n     fi"
      },
      {
        "sha": "7ab19e7b03588b4ddef202387dbe627957642446",
        "filename": "test/lint/lint-shell.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-shell.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-shell.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shell.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -29,7 +29,7 @@ fi\n SHELLCHECK_CMD=(shellcheck --external-sources --check-sourced)\n EXCLUDE=\"--exclude=$(IFS=','; echo \"${disabled[*]}\")\"\n SOURCED_FILES=$(git ls-files | xargs gawk '/^# shellcheck shell=/ {print FILENAME} {nextfile}')  # Check shellcheck directive used for sourced files\n-if ! \"${SHELLCHECK_CMD[@]}\" \"$EXCLUDE\" $SOURCED_FILES $(git ls-files -- '*.sh' | grep -vE 'src/(leveldb|secp256k1|univalue)/'); then\n+if ! \"${SHELLCHECK_CMD[@]}\" \"$EXCLUDE\" $SOURCED_FILES $(git ls-files -- '*.sh' | grep -vE 'src/(leveldb|secp256k1|minisketch|univalue)/'); then\n     EXIT_CODE=1\n fi\n "
      },
      {
        "sha": "3534c6624269065cb6b3f5d2a22f12a7851927da",
        "filename": "test/lint/lint-spelling.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-spelling.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-spelling.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-spelling.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -15,6 +15,6 @@ if ! command -v codespell > /dev/null; then\n fi\n \n IGNORE_WORDS_FILE=test/lint/lint-spelling.ignore-words.txt\n-if ! codespell --check-filenames --disable-colors --quiet-level=7 --ignore-words=${IGNORE_WORDS_FILE} $(git ls-files -- \":(exclude)build-aux/m4/\" \":(exclude)contrib/seeds/*.txt\" \":(exclude)depends/\" \":(exclude)doc/release-notes/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/qt/locale/\" \":(exclude)src/qt/*.qrc\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)contrib/gitian-keys/keys.txt\"); then\n+if ! codespell --check-filenames --disable-colors --quiet-level=7 --ignore-words=${IGNORE_WORDS_FILE} $(git ls-files -- \":(exclude)build-aux/m4/\" \":(exclude)contrib/seeds/*.txt\" \":(exclude)depends/\" \":(exclude)doc/release-notes/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/qt/locale/\" \":(exclude)src/qt/*.qrc\" \":(exclude)src/secp256k1/\" \":(exclude)src/minisketch/\" \":(exclude)src/univalue/\" \":(exclude)contrib/gitian-keys/keys.txt\"); then\n     echo \"^ Warning: codespell identified likely spelling errors. Any false positives? Add them to the list of ignored words in ${IGNORE_WORDS_FILE}\"\n fi"
      },
      {
        "sha": "7967a212e7dca136fe9c6cc1270cf44fbd6c2e25",
        "filename": "test/lint/lint-whitespace.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-whitespace.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6474c9f1ed472d7ba4b4391dc4455c41f5163c28/test/lint/lint-whitespace.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-whitespace.sh?ref=6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "patch": "@@ -33,14 +33,14 @@ if [ -z \"${COMMIT_RANGE}\" ]; then\n fi\n \n showdiff() {\n-  if ! git diff -U0 \"${COMMIT_RANGE}\" -- \".\" \":(exclude)depends/patches/\" \":(exclude)contrib/guix/patches/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\" \":(exclude)src/qt/locale/\"; then\n+  if ! git diff -U0 \"${COMMIT_RANGE}\" -- \".\" \":(exclude)depends/patches/\" \":(exclude)contrib/guix/patches/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/minisketch/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\" \":(exclude)src/qt/locale/\"; then\n     echo \"Failed to get a diff\"\n     exit 1\n   fi\n }\n \n showcodediff() {\n-  if ! git diff -U0 \"${COMMIT_RANGE}\" -- *.cpp *.h *.md *.py *.sh \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\" \":(exclude)src/qt/locale/\"; then\n+  if ! git diff -U0 \"${COMMIT_RANGE}\" -- *.cpp *.h *.md *.py *.sh \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/secp256k1/\" \":(exclude)src/minisketch/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\" \":(exclude)src/qt/locale/\"; then\n     echo \"Failed to get a diff\"\n     exit 1\n   fi"
      }
    ]
  },
  {
    "sha": "0a495a213bbc56bc4e90070e9081371ec6ea1da7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTQ5NWEyMTNiYmM1NmJjNGU5MDA3MGU5MDgxMzcxZWM2ZWExZGE3",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T14:00:46Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T14:00:46Z"
      },
      "message": "Squashed 'src/minisketch/' content from commit 80481500c\n\ngit-subtree-dir: src/minisketch\ngit-subtree-split: 80481500cdb3328adab751db30a3fa7e76fe1147",
      "tree": {
        "sha": "6506becfd6de2237f05e8756259ef100bc6df4e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6506becfd6de2237f05e8756259ef100bc6df4e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a495a213bbc56bc4e90070e9081371ec6ea1da7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a495a213bbc56bc4e90070e9081371ec6ea1da7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a495a213bbc56bc4e90070e9081371ec6ea1da7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a495a213bbc56bc4e90070e9081371ec6ea1da7/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 6419,
      "additions": 6419,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4320413c6e666caca54d45f45d8003bb89e177b4",
        "filename": ".gitignore",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,36 @@\n+*.o\n+*.lo\n+*.la\n+*.dll\n+*.dylib\n+*.so.*\n+.*\n+*.a\n+*~\n+\n+Makefile\n+Makefile.in\n+aclocal.m4\n+autom4te.cache/\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n+config.log\n+config.status\n+configure\n+libtool\n+stamp-h1\n+\n+test-exhaust\n+test-exhaust-verify\n+bench"
      },
      {
        "sha": "b25e3caee3580d8bfcef225792e35b7641a5f401",
        "filename": "LICENSE",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/LICENSE?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
      },
      {
        "sha": "fc2d4a10ba3a23555dde8fd1f53af01df73d2d6d",
        "filename": "Makefile.am",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,93 @@\n+ACLOCAL_AMFLAGS = -I build-aux/m4\n+AM_CXXFLAGS = $(WARN_CXXFLAGS) $(NOWARN_CXXFLAGS)\n+\n+include sources.mk\n+\n+include_HEADERS = $(MINISKETCH_DIST_HEADERS_INT)\n+noinst_HEADERS = $(MINISKETCH_LIB_HEADERS_INT) $(MINISKETCH_FIELD_GENERIC_HEADERS_INT) $(MINISKETCH_FIELD_CLMUL_HEADERS_INT)\n+\n+LIBMINISKETCH = libminisketch.la\n+LIBMINISKETCH_FIELD_GENERIC = libminisketch_field_generic.la\n+if ENABLE_CLMUL\n+LIBMINISKETCH_FIELD_CLMUL = libminisketch_field_clmul.la\n+endif\n+if USE_TESTS\n+LIBMINISKETCH_VERIFY=libminisketch_verify.la\n+LIBMINISKETCH_FIELD_GENERIC_VERIFY=libminisketch_field_generic_verify.la\n+if ENABLE_CLMUL\n+LIBMINISKETCH_FIELD_CLMUL_VERIFY=libminisketch_field_clmul_verify.la\n+endif\n+endif\n+\n+lib_LTLIBRARIES =\n+lib_LTLIBRARIES +=  $(LIBMINISKETCH)\n+\n+noinst_LTLIBRARIES =\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_GENERIC)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_GENERIC_VERIFY)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_CLMUL)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_CLMUL_VERIFY)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_VERIFY)\n+\n+# Release libs\n+libminisketch_field_generic_la_SOURCES = $(MINISKETCH_FIELD_GENERIC_SOURCES_INT)\n+libminisketch_field_generic_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+\n+libminisketch_field_clmul_la_SOURCES = $(MINISKETCH_FIELD_CLMUL_SOURCES_INT)\n+libminisketch_field_clmul_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+libminisketch_field_clmul_la_CXXFLAGS = $(AM_CXXFLAGS) $(CLMUL_CXXFLAGS)\n+\n+libminisketch_la_SOURCES = $(MINISKETCH_LIB_SOURCES_INT)\n+libminisketch_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+libminisketch_la_LIBADD = $(LIBMINISKETCH_FIELD_CLMUL) $(LIBMINISKETCH_FIELD_GENERIC)\n+\n+# Libs with extra verification checks\n+libminisketch_field_generic_verify_la_SOURCES = $(MINISKETCH_FIELD_GENERIC_SOURCES_INT)\n+libminisketch_field_generic_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+\n+libminisketch_field_clmul_verify_la_SOURCES = $(MINISKETCH_FIELD_CLMUL_SOURCES_INT)\n+libminisketch_field_clmul_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+libminisketch_field_clmul_verify_la_CXXFLAGS = $(AM_CXXFLAGS) $(CLMUL_CXXFLAGS)\n+\n+libminisketch_verify_la_SOURCES = $(MINISKETCH_LIB_SOURCES_INT)\n+libminisketch_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+libminisketch_verify_la_LIBADD = $(LIBMINISKETCH_FIELD_CLMUL_VERIFY) $(LIBMINISKETCH_FIELD_GENERIC_VERIFY)\n+\n+noinst_PROGRAMS =\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench\n+endif\n+if USE_TESTS\n+noinst_PROGRAMS += test-exhaust test-exhaust-verify\n+TESTS = test-exhaust test-exhaust-verify\n+endif\n+\n+bench_SOURCES = $(MINISKETCH_BENCH_SOURCES_INT)\n+bench_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+bench_LDADD = $(LIBMINISKETCH)\n+bench_LDFLAGS = $(AM_LDFLAGS) -static\n+\n+test_exhaust_SOURCES = $(MINISKETCH_TEST_SOURCES_INT)\n+test_exhaust_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+test_exhaust_CXXFLAGS = $(AM_CXXFLAGS) $(PTHREAD_CFLAGS)\n+test_exhaust_LDADD = $(LIBMINISKETCH)\n+test_exhaust_LDFLAGS = $(AM_LDFLAGS) $(PTHREAD_CFLAGS) -static\n+\n+test_exhaust_verify_SOURCES = $(MINISKETCH_TEST_SOURCES_INT)\n+test_exhaust_verify_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+test_exhaust_verify_CXXFLAGS = $(AM_CXXFLAGS) $(PTHREAD_CFLAGS)\n+test_exhaust_verify_LDADD = $(LIBMINISKETCH_VERIFY)\n+test_exhaust_verify_LDFLAGS = $(AM_LDFLAGS) $(PTHREAD_CFLAGS) -static\n+\n+EXTRA_DIST=\n+EXTRA_DIST += LICENSE\n+EXTRA_DIST += README.md\n+EXTRA_DIST += doc/example.c\n+EXTRA_DIST += doc/gen_params.sage\n+EXTRA_DIST += doc/math.md\n+EXTRA_DIST += doc/moduli.md\n+EXTRA_DIST += doc/plot_bits.png\n+EXTRA_DIST += doc/plot_capacity.png\n+EXTRA_DIST += doc/plot_diff.png\n+EXTRA_DIST += doc/plot_size.png\n+EXTRA_DIST += doc/protocoltips.md"
      },
      {
        "sha": "ba6011e8063a17084bc6bde04cacc022115e6be9",
        "filename": "README.md",
        "status": "added",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,210 @@\n+# Minisketch: a library for [BCH](https://en.wikipedia.org/wiki/BCH_code)-based set reconciliation\n+<img align=\"right\" src=\"https://people.xiph.org/~greg/minisketch-vs.png\" />\n+\n+`libminisketch` is an optimized standalone MIT-licensed library with C API for constructing and decoding *set sketches*, which can be used for compact set reconciliation and other applications.\n+It is an implementation of the PinSketch<sup>[[1]](#myfootnote1)</sup> algorithm. An explanation of the algorithm can be found [here](doc/math.md).\n+\n+## Sketches for set reconciliation\n+\n+Sketches, as produced by this library, can be seen as \"set checksums\" with two peculiar properties:\n+* Sketches have a predetermined capacity, and when the number of elements in the set is not higher than the capacity, `libminisketch` will always recover the entire set from the sketch. A sketch of *b*-bit elements with capacity *c* can be stored in *bc* bits.\n+* The sketches of two sets can be combined by adding them (XOR) to obtain a sketch of the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) between the two sets (*i.e.*, all elements that occur in one but not both input sets).\n+\n+This makes them appropriate for a very bandwidth-efficient set reconciliation protocol. If Alice and Bob each have a set of elements, and they suspect that the sets largely but not entirely overlap,\n+they can use the following protocol to let both parties learn all the elements:\n+* Alice and Bob both compute a sketch of their set elements.\n+* Alice sends her sketch to Bob.\n+* Bob combines the two sketches, and obtains a sketch of the symmetric difference.\n+* Bob tries to recover the elements from the difference sketch.\n+* Bob sends every element in the difference that he has to Alice.\n+\n+This will always succeed when the size of the difference (elements that Alice has but Bob doesn't plus elements that Bob has but Alice doesn't) does not exceed the\n+capacity of the sketch that Alice sent. The interesting part is that this works regardless of the actual set sizes\u2014only the difference matters.\n+\n+If the elements are large, it may be preferable to compute the sketches over *hashes* of the set elements. In that case an additional step is added to the protocol, where Bob also sends the hash\n+of every element he does not have to Alice, who responds with the requested elements.\n+\n+The doc/ directory has additional [tips for designing reconciliation protocols using libminisketch](doc/protocoltips.md).\n+\n+## Evaluation\n+\n+<img src=\"doc/plot_capacity.png\" width=\"432\" height=\"324\" /> <img src=\"doc/plot_diff.png\" width=\"432\" height=\"324\" />\n+\n+<img src=\"doc/plot_size.png\" width=\"432\" height=\"324\" /> <img src=\"doc/plot_bits.png\" width=\"432\" height=\"324\" />\n+\n+**The first graph** above shows a benchmark of `libminisketch` against three other set reconciliation algorithms/implementations. The benchmarks were performed using a single core on a system with an Intel Core i7-7820HQ CPU with clock speed locked at 2.4 GHz. The diagram shows the time needed for merging of two sketches and decoding the result. The creation of a sketch on the same machine takes around 5 ns per capacity and per set element. The other implementations are:\n+* [`pinsketch`](https://www.cs.bu.edu/~reyzin/code/fuzzy.html), the original PinSketch implementation.\n+* [`cpisync`](https://github.com/trachten/cpisync), a software project which implements a number of set reconciliation algorithms and protocols. The included benchmark analyzes the non-probabilistic version of the original CPISync algorithm<sup>[[5]](#myfootnote5)</sup> only.\n+* A high-performance custom IBLT implementation using 4 hash functions and 32-bit checksums.\n+\n+For the largest sizes currently of interest to the authors, such as a set of capacity 4096 with 1024 differences, `libminisketch` is forty-nine times faster than `pinsketch` and over eight thousand times faster than `cpisync`. `libminisketch` is fast enough on realistic set sizes for use on high-traffic network servers where computational resources are limited.\n+\n+Even where performance is latency-limited, small minisketches can be fast enough to improve performance. On the above i7-7820HQ, a set of 2500 30-bit entries with a difference of 20 elements can be communicated in less time with a minisketch than sending the raw set so long as the communications bandwidth is 1 gigabit per second or less; an eight-element difference can be communicated in better than one-fifth the time on a gigabit link.\n+\n+**The second graph** above shows the performance of the same algorithms on the same system, but this time keeping the capacity constant at 128, while varying the number of differences to reconcile between 1 and 128. It shows how `cpisync`'s reconciliation speed is mostly dependent on capacity, while `pinsketch`/`libminisketch` are more dependent on number of differences.\n+\n+**The third graph** above shows the size overhead of a typical IBLT scheme over the other algorithms (which are near-optimal bandwidth), for various levels of failure probability. IBLT takes tens of times the bandwidth of `libminisketch` sketches when the set difference size is small and the required failure rate is low.\n+\n+**The fourth graph** above shows the effect of the field size on speed in `libminisketch`. The three lines correspond to:\n+* CLMUL 64-bit: Intel Core i7-7820HQ system at 2.4 GHz\n+* Generic 64-bit: POWER9 CP9M06 system at 2.8 GHz (Talos II)\n+* Generic 32-bit: Cortex-A53 at 1.2 GHz (Raspberry Pi 3B)\n+\n+It shows how CLMUL implementations are faster for certain fields (specifically, field sizes for which an irreducible polynomial of the form *x<sup>b</sup> + x + 1* over *GF(2)* exists, and to a lesser extent, fields which are a multiple of 8 bits). It also shows how (for now) a significant performance drop exists for fields larger than 32 bits on 32-bit platforms. Note that the three lines are not at the same scale (the Raspberry Pi 3B is around 10x slower for 32-bit fields than the Core i7; the POWER9 is around 1.3x slower).\n+\n+Below we compare the PinSketch algorithm (which `libminisketch` is an implementation of) with other set reconciliation algorithms:\n+\n+| Algorithm                                             | Sketch size               | Decode success | Decoding complexity | Difference type | Secure sketch |\n+| ----------------------------------------------------- | ------------------------- | ---------------| ------------------- | --------------- | ------------- |\n+| CPISync<sup>[[2]](#myfootnote2)</sup>                 | *(b+1)c*                  | Always         | *O(n<sup>3</sup>)*  | Both            | Yes           |\n+| PinSketch<sup>[[1]](#myfootnote1)</sup>               | *bc*                      | Always         | *O(n<sup>2</sup>)*  | Symmetric only  | Yes           |\n+| IBLT<sup>[[6]](#myfootnote1)[[7]](#myfootnote1)</sup> | *&alpha;bc* (see graph 3) | Probabilistic  | *O(n)*              | Depends         | No            |\n+\n+* **Sketch size:** This column shows the size in bits of a sketch designed for reconciling *c* different *b*-bit elements. PinSketch and CPISync have a near-optimal<sup>[[11]](#myfootnote11)</sup> communication overhead, which in practice means the sketch size is very close (or equal to) *bc* bits. That is the same size as would be needed to transfer the elements of the difference naively (which is remarkable, as the difference isn't even known by the sender). For IBLT there is an overhead factor *&alpha;*, which depends on various design parameters, but is often between *2* and *10*.\n+* **Decode success:** Whenever a sketch is designed with a capacity not lower than the actual difference size, CPISync and PinSketch guarantee that decoding of the difference will always succeed. IBLT always has a chance of failure, though that chance can be made arbitrarily small by increasing the communication overhead.\n+* **Decoding complexity:** The space savings achieved by near-optimal algorithms come at a cost in performance, as their asymptotic decode complexity is quadratic or cubic, while IBLT is linear. This means that using near-optimal algorithms can be too expensive for applications where the difference is sufficiently large.\n+* **Difference type:** PinSketch can only compute the symmetric difference from a merged sketch, while CPISync and IBLT can distinguish which side certain elements were missing on. When the decoder has access to one of the sets, this generally doesn't matter, as he can look up each of the elements in the symmetric difference with one of the sets.\n+* **Secure sketch:** Whether the sketch satisfies the definition of a secure sketch<sup>[[1]](#myfootnote1)</sup>, which implies a minimal amount about a set can be extracted from a sketch by anyone who does not know most of the elements already. This makes the algorithm appropriate for applications like fingerprint authentication.\n+\n+## Building\n+\n+The build system is very rudimentary for now, and [improvements](https://github.com/sipa/minisketch/pulls) are welcome.\n+\n+The following may work and produce a `libminisketch.a` file you can link against:\n+\n+```bash\n+git clone https://github.com/sipa/minisketch\n+cd minisketch/src\n+make\n+```\n+\n+## Usage\n+\n+In this section Alice and Bob are trying to find the difference between their sets.\n+Alice has the set *[3000 ... 3009]*, while Bob has *[3002 ... 3011]*.\n+\n+First, Alice creates a sketch:\n+\n+```c\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"../include/minisketch.h\"\n+int main(void) {\n+\n+  minisketch *sketch_a = minisketch_create(12, 0, 4);\n+```\n+\n+The arguments are:\n+* The field size *b*, which specifies the size of the elements being reconciled. With a field size *b*, the supported range of set elements is the integers from *1* to *2<sup>b</sub>* *- 1*, inclusive. Note that elements cannot be zero.\n+* The implementation number. Implementation *0* is always supported, but more efficient algorithms may be available on some hardware. The serialized form of a sketch is independent of the implementation, so different implementations can interoperate.\n+* The capacity *c*, which specifies how many differences the resulting sketch can reconcile.\n+\n+Then Alice adds her elements to her sketch. Note that adding the same element a second time removes it again, as sketches have set semantics, not multiset semantics.\n+\n+```c\n+  for (int i = 3000; i < 3010; ++i) {\n+    minisketch_add_uint64(sketch_a, i);\n+  }\n+```\n+\n+The next step is serializing the sketch into a byte array:\n+\n+```c\n+  size_t sersize = minisketch_serialized_size(sketch_a);\n+  assert(sersize == 12 * 4 / 8); // 4 12-bit values is 6 bytes.\n+  unsigned char *buffer_a = malloc(sersize);\n+  minisketch_serialize(sketch_a, buffer_a);\n+  minisketch_destroy(sketch_a);\n+```\n+\n+The contents of the buffer can then be submitted to Bob, who can create his own sketch:\n+\n+```c\n+  minisketch *sketch_b = minisketch_create(12, 0, 4); // Bob's own sketch\n+  for (int i = 3002; i < 3012; ++i) {\n+    minisketch_add_uint64(sketch_b, i);\n+  }\n+```\n+\n+After Bob receives Alice's serialized sketch, he can reconcile:\n+\n+```c\n+  sketch_a = minisketch_create(12, 0, 4);     // Alice's sketch\n+  minisketch_deserialize(sketch_a, buffer_a); // Load Alice's sketch\n+  free(buffer_a);\n+\n+  // Merge the elements from sketch_a into sketch_b. The result is a sketch_b\n+  // which contains all elements that occurred in Alice's or Bob's sets, but not\n+  // in both.\n+  minisketch_merge(sketch_b, sketch_a);\n+\n+  uint64_t differences[4];\n+  ssize_t num_differences = minisketch_decode(sketch_b, 4, differences);\n+  minisketch_destroy(sketch_a);\n+  minisketch_destroy(sketch_b);\n+  if (num_differences < 0) {\n+    printf(\"More than 4 differences!\\n\");\n+  } else {\n+    ssize_t i;\n+    for (i = 0; i < num_differences; ++i) {\n+      printf(\"%u is in only one of the two sets\\n\", (unsigned)differences[i]);\n+    }\n+  }\n+}\n+```\n+\n+In this example Bob would see output such as:\n+\n+```\n+$ gcc -std=c99 -Wall -Wextra -o example ./doc/example.c -Lsrc/ -lminisketch -lstdc++ && ./example\n+3000 is in only one of the two sets\n+3011 is in only one of the two sets\n+3001 is in only one of the two sets\n+3010 is in only one of the two sets\n+```\n+\n+The order of the output is arbitrary and will differ on different runs of minisketch_decode().\n+\n+## Applications\n+\n+Communications efficient set reconciliation has been proposed to optimize Bitcoin transaction distribution<sup>[[8]](#myfootnote8)</sup>, which would allow Bitcoin nodes to have many more peers while reducing bandwidth usage. It could also be used for Bitcoin block distribution<sup>[[9]](#myfootnote9)</sup>, particularly for very low bandwidth links such as satellite.  A similar approach (CPISync) is used by PGP SKS keyservers to synchronize their databases efficiently. Secure sketches can also be used as helper data to reliably extract a consistent cryptographic key from fuzzy biometric data while leaking minimal information<sup>[[1]](#myfootnote1)</sup>. They can be combined with [dcnets](https://en.wikipedia.org/wiki/Dining_cryptographers_problem) to create cryptographic multiparty anonymous communication<sup>[[10]](#myfootnote10)</sup>. \n+\n+## Implementation notes\n+\n+`libminisketch` is written in C++11, but has a [C API](include/minisketch.h) for compatibility reasons.\n+\n+Specific algorithms and optimizations used:\n+* Finite field implementations:\n+  * A generic implementation using C unsigned integer bit operations, and one using the [CLMUL instruction](https://en.wikipedia.org/wiki/CLMUL_instruction_set) where available. The latter has specializations for different classes of fields that permit optimizations (those with trinomial irreducible polynomials, and those whose size is a multiple of 8 bits).\n+  * Precomputed tables for (repeated) squaring, and for solving equations of the form *x<sup>2</sup> + x = a*<sup>[[2]](#myfootnote2)</sup>.\n+  * Inverses are computed using an [exponentiation ladder](https://en.wikipedia.org/w/index.php?title=Exponentiation_by_squaring&oldid=868883860)<sup>[[12]](#myfootnote12)</sup> on systems where multiplications are relatively fast, and using an [extended GCD algorithm](https://en.wikipedia.org/w/index.php?title=Extended_Euclidean_algorithm&oldid=865802511#Computing_multiplicative_inverses_in_modular_structures) otherwise.\n+  * Repeated multiplications are accelerated using runtime precomputations on systems where multiplications are relatively slow.\n+  * The serialization of field elements always represents them as bits that are coefficients of the lowest-weight (using lexicographic order as tie breaker) irreducible polynomials over *GF(2)* (see [this list](doc/moduli.md)), but for some implementations they are converted to a different representation internally.\n+* The sketch algorithms are specialized for each separate field implementation, permitting inlining and specific optimizations while avoiding dynamic allocations and branching costs.\n+* Decoding of sketches uses the [Berlekamp-Massey algorithm](https://en.wikipedia.org/w/index.php?title=Berlekamp%E2%80%93Massey_algorithm&oldid=870768940)<sup>[[3]](#myfootnote3)</sup> to compute the characteristic polynomial.\n+* Finding the roots of polynomials is done using the Berlekamp trace algorithm with explicit formula for quadratic polynomials<sup>[[4]](#myfootnote4)</sup>. The root finding is randomized to prevent adversarial inputs that intentionally trigger worst-case decode time.\n+* A (possibly) novel optimization combines a test for unique roots with the Berlekamp trace algorithm.\n+\n+Some improvements that are still TODO:\n+* Explicit formulas for the roots of polynomials of higher degree than 2\n+* Subquadratic multiplication and modulus algorithms\n+* The [Half-GCD algorithm](http://mathworld.wolfram.com/Half-GCD.html) for faster GCDs\n+* An interface for incremental decoding: most of the computation in most failed decodes can be reused when attempting to decode a longer sketch of the same set\n+* Platform specific optimizations for platforms other than x86\n+* Avoid using slow uint64_t for calculations on 32-bit hosts\n+* Optional IBLT / Hybrid and set entropy coder under the same interface\n+\n+## References\n+\n+* <a name=\"myfootnote1\">[1]</a> Dodis, Ostrovsky, Reyzin and Smith. *Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data.* SIAM Journal on Computing, volume 38, number 1, pages 97-139, 2008). [[URL]](http://eprint.iacr.org/2003/235) [[PDF]](https://eprint.iacr.org/2003/235.pdf)\n+* <a name=\"myfootnote5\">[5]</a> A. Trachtenberg, D. Starobinski and S. Agarwal. *Fast PDA synchronization using characteristic polynomial interpolation.* Proceedings, Twenty-First Annual Joint Conference of the IEEE Computer and Communications Societies, New York, NY, USA, 2002, pp. 1510-1519 vol.3. [[PDF]](https://pdfs.semanticscholar.org/43da/2070b6b7b2320a1fed2fd5e70e87332c9c5e.pdf)\n+* <a name=\"myfootnote2\">[2]</a> Cherly, J\u00f8rgen, Luis Gallardo, Leonid Vaserstein, and Ethel Wheland. *Solving quadratic equations over polynomial rings of characteristic two.* Publicacions Matem\u00e0tiques (1998): 131-142. [[PDF]](https://www.raco.cat/index.php/PublicacionsMatematiques/article/viewFile/37927/40412)\n+* <a name=\"myfootnote3\">[3]</a> J. Massey. *Shift-register synthesis and BCH decoding.* IEEE Transactions on Information Theory, vol. 15, no. 1, pp. 122-127, January 1969. [[PDF]](http://crypto.stanford.edu/~mironov/cs359/massey.pdf)\n+* <a name=\"myfootnote4\">[4]</a> Bhaskar Biswas, Vincent Herbert. *Efficient Root Finding of Polynomials over Fields of Characteristic 2.* 2009. hal-00626997. [[URL]](https://hal.archives-ouvertes.fr/hal-00626997) [[PDF]](https://hal.archives-ouvertes.fr/hal-00626997/document)\n+* <a name=\"myfootnote6\">[6]</a> Eppstein, David, Michael T. Goodrich, Frank Uyeda, and George Varghese. *What's the difference?: efficient set reconciliation without prior context.* ACM SIGCOMM Computer Communication Review, vol. 41, no. 4, pp. 218-229. ACM, 2011. [[PDF]](https://www.ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf)\n+* <a name=\"myfootnote7\">[7]</a> Goodrich, Michael T. and Michael Mitzenmacher. *Invertible bloom lookup tables.* 2011 49th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2011): 792-799. [[PDF]](https://arxiv.org/pdf/1101.2245.pdf)\n+* <a name=\"myfootnote8\">[8]</a> Maxwell, Gregory F. *[Blocksonly mode BW savings, the limits of efficient block xfer, and better relay](https://bitcointalk.org/index.php?topic=1377345.0)* Bitcointalk 2016, *[Technical notes on mempool synchronizing relay](https://people.xiph.org/~greg/mempool_sync_relay.txt)* #bitcoin-wizards 2016.\n+* <a name=\"myfootnote9\">[9]</a> Maxwell, Gregory F. *[Block network coding](https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding)* Bitcoin Wiki 2014, *[Technical notes on efficient block xfer](https://people.xiph.org/~greg/efficient.block.xfer.txt)* #bitcoin-wizards 2015.\n+* <a name=\"myfootnote10\">[10]</a> Ruffing, Tim, Moreno-Sanchez, Pedro, Aniket, Kate, *P2P Mixing and Unlinkable Bitcoin Transactions* NDSS Symposium 2017 [[URL]](https://eprint.iacr.org/2016/824) [[PDF]](https://eprint.iacr.org/2016/824.pdf)\n+* <a name=\"myfootnote11\">[11]</a> Y. Misky, A. Trachtenberg, R. Zippel. *Set Reconciliation with Nearly Optimal Communication Complexity.* Cornell University, 2000. [[URL]](https://ecommons.cornell.edu/handle/1813/5803) [[PDF]](https://ecommons.cornell.edu/bitstream/handle/1813/5803/2000-1813.pdf)\n+* <a name=\"myfootnote12\">[12]</a> Itoh, Toshiya, and Shigeo Tsujii. \"A fast algorithm for computing multiplicative inverses in GF (2m) using normal bases.\" Information and computation 78, no. 3 (1988): 171-177. [[URL]](https://www.sciencedirect.com/science/article/pii/0890540188900247)"
      },
      {
        "sha": "27417daf7691513da832eae5541b6c5bee091551",
        "filename": "autogen.sh",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+# Copyright (c) 2013-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+set -e\n+srcdir=\"$(dirname $0)\"\n+cd \"$srcdir\"\n+if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE=\"`which glibtoolize 2>/dev/null`\"; then\n+  LIBTOOLIZE=\"${GLIBTOOLIZE}\"\n+  export LIBTOOLIZE\n+fi\n+which autoreconf >/dev/null || \\\n+  (echo \"configuration failed, please install autoconf first\" && exit 1)\n+autoreconf --install --force --warnings=all"
      },
      {
        "sha": "ca3639715e7243fa4343eb2e7f3de53927cc9d4a",
        "filename": "build-aux/m4/ax_check_compile_flag.m4",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_check_compile_flag.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_check_compile_flag.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_check_compile_flag.m4?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,74 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])\n+#\n+# DESCRIPTION\n+#\n+#   Check whether the given FLAG works with the current language's compiler\n+#   or gives an error.  (Warnings, however, are ignored)\n+#\n+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on\n+#   success/failure.\n+#\n+#   If EXTRA-FLAGS is defined, it is added to the current language's default\n+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with\n+#   the flags: \"CFLAGS EXTRA-FLAGS FLAG\".  This can for example be used to\n+#   force the compiler to issue an error when a bad flag is given.\n+#\n+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.\n+#\n+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this\n+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>\n+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 4\n+\n+AC_DEFUN([AX_CHECK_COMPILE_FLAG],\n+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF\n+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl\n+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [\n+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS\n+  _AC_LANG_PREFIX[]FLAGS=\"$[]_AC_LANG_PREFIX[]FLAGS $4 $1\"\n+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],\n+    [AS_VAR_SET(CACHEVAR,[yes])],\n+    [AS_VAR_SET(CACHEVAR,[no])])\n+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])\n+AS_VAR_IF(CACHEVAR,yes,\n+  [m4_default([$2], :)],\n+  [m4_default([$3], :)])\n+AS_VAR_POPDEF([CACHEVAR])dnl\n+])dnl AX_CHECK_COMPILE_FLAGS"
      },
      {
        "sha": "ca1d5ee2b6d1ae107504d4ab433bc5f6fd629f61",
        "filename": "build-aux/m4/ax_check_preproc_flag.m4",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_check_preproc_flag.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_check_preproc_flag.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_check_preproc_flag.m4?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,74 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_check_preproc_flag.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CHECK_PREPROC_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])\n+#\n+# DESCRIPTION\n+#\n+#   Check whether the given FLAG works with the current language's\n+#   preprocessor or gives an error.  (Warnings, however, are ignored)\n+#\n+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on\n+#   success/failure.\n+#\n+#   If EXTRA-FLAGS is defined, it is added to the preprocessor's default\n+#   flags when the check is done.  The check is thus made with the flags:\n+#   \"CPPFLAGS EXTRA-FLAGS FLAG\".  This can for example be used to force the\n+#   preprocessor to issue an error when a bad flag is given.\n+#\n+#   INPUT gives an alternative input source to AC_PREPROC_IFELSE.\n+#\n+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this\n+#   macro in sync with AX_CHECK_{COMPILE,LINK}_FLAG.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>\n+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 4\n+\n+AC_DEFUN([AX_CHECK_PREPROC_FLAG],\n+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF\n+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]cppflags_$4_$1])dnl\n+AC_CACHE_CHECK([whether _AC_LANG preprocessor accepts $1], CACHEVAR, [\n+  ax_check_save_flags=$CPPFLAGS\n+  CPPFLAGS=\"$CPPFLAGS $4 $1\"\n+  AC_PREPROC_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],\n+    [AS_VAR_SET(CACHEVAR,[yes])],\n+    [AS_VAR_SET(CACHEVAR,[no])])\n+  CPPFLAGS=$ax_check_save_flags])\n+AS_VAR_IF(CACHEVAR,yes,\n+  [m4_default([$2], :)],\n+  [m4_default([$3], :)])\n+AS_VAR_POPDEF([CACHEVAR])dnl\n+])dnl AX_CHECK_PREPROC_FLAGS"
      },
      {
        "sha": "f147cee3b117f80b22544976385e267b26f46dd9",
        "filename": "build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "status": "added",
        "additions": 568,
        "deletions": 0,
        "changes": 568,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_cxx_compile_stdcxx.m4?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,568 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])\n+#\n+# DESCRIPTION\n+#\n+#   Check for baseline language coverage in the compiler for the specified\n+#   version of the C++ standard.  If necessary, add switches to CXX and\n+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)\n+#   or '14' (for the C++14 standard).\n+#\n+#   The second argument, if specified, indicates whether you insist on an\n+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.\n+#   -std=c++11).  If neither is specified, you get whatever works, with\n+#   preference for an extended mode.\n+#\n+#   The third argument, if specified 'mandatory' or if left unspecified,\n+#   indicates that baseline support for the specified C++ standard is\n+#   required and that the macro should error out if no mode with that\n+#   support is found.  If specified 'optional', then configuration proceeds\n+#   regardless, after defining HAVE_CXX${VERSION} if and only if a\n+#   supporting mode is found.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>\n+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>\n+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>\n+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>\n+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>\n+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved.  This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 4\n+\n+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro\n+dnl  (serial version number 13).\n+\n+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n+  m4_if([$1], [11], [],\n+        [$1], [14], [],\n+        [$1], [17], [m4_fatal([support for C++17 not yet implemented in AX_CXX_COMPILE_STDCXX])],\n+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$2], [], [],\n+        [$2], [ext], [],\n+        [$2], [noext], [],\n+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],\n+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])\n+  m4_if([$4], [], [ax_cxx_compile_cxx$1_try_default=true],\n+        [$4], [default], [ax_cxx_compile_cxx$1_try_default=true],\n+        [$4], [nodefault], [ax_cxx_compile_cxx$1_try_default=false],\n+        [m4_fatal([invalid fourth argument `$4' to AX_CXX_COMPILE_STDCXX])])\n+  AC_LANG_PUSH([C++])dnl\n+  ac_success=no\n+\n+  m4_if([$4], [nodefault], [], [dnl\n+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,\n+  ax_cv_cxx_compile_cxx$1,\n+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+    [ax_cv_cxx_compile_cxx$1=yes],\n+    [ax_cv_cxx_compile_cxx$1=no])])\n+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then\n+    ac_success=yes\n+  fi])\n+\n+  m4_if([$2], [noext], [], [dnl\n+  if test x$ac_success = xno; then\n+    for switch in -std=gnu++$1 -std=gnu++0x; do\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                     $cachevar,\n+        [ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+          [eval $cachevar=yes],\n+          [eval $cachevar=no])\n+         CXX=\"$ac_save_CXX\"])\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi])\n+\n+  m4_if([$2], [ext], [], [dnl\n+  if test x$ac_success = xno; then\n+    dnl HP's aCC needs +std=c++11 according to:\n+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf\n+    dnl Cray's crayCC needs \"-h std=c++11\"\n+    for switch in -std=c++$1 -std=c++0x +std=c++$1 \"-h std=c++$1\"; do\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                     $cachevar,\n+        [ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+          [eval $cachevar=yes],\n+          [eval $cachevar=no])\n+         CXX=\"$ac_save_CXX\"])\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi])\n+  AC_LANG_POP([C++])\n+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX$1=0\n+    AC_MSG_NOTICE([No compiler with C++$1 support was found])\n+  else\n+    HAVE_CXX$1=1\n+    AC_DEFINE(HAVE_CXX$1,1,\n+              [define if the compiler supports basic C++$1 syntax])\n+  fi\n+  AC_SUBST(HAVE_CXX$1)\n+])\n+\n+\n+dnl  Test body for checking C++11 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+)\n+\n+\n+dnl  Test body for checking C++14 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14\n+)\n+\n+\n+dnl  Tests for new features in C++11\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+]])\n+\n+\n+dnl  Tests for new features in C++14\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[\n+\n+// If the compiler admits that it is not ready for C++14, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201402L\n+\n+#error \"This is not a C++14 compiler\"\n+\n+#else\n+\n+namespace cxx14\n+{\n+\n+  namespace test_polymorphic_lambdas\n+  {\n+\n+    int\n+    test()\n+    {\n+      const auto lambda = [](auto&&... args){\n+        const auto istiny = [](auto x){\n+          return (sizeof(x) == 1UL) ? 1 : 0;\n+        };\n+        const int aretiny[] = { istiny(args)... };\n+        return aretiny[0];\n+      };\n+      return lambda(1, 1L, 1.0f, '1');\n+    }\n+\n+  }\n+\n+  namespace test_binary_literals\n+  {\n+\n+    constexpr auto ivii = 0b0000000000101010;\n+    static_assert(ivii == 42, \"wrong value\");\n+\n+  }\n+\n+  namespace test_generalized_constexpr\n+  {\n+\n+    template < typename CharT >\n+    constexpr unsigned long\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      auto length = 0UL;\n+      for (auto p = s; *p; ++p)\n+        ++length;\n+      return length;\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"x\") == 1UL, \"\");\n+    static_assert(strlen_c(\"test\") == 4UL, \"\");\n+    static_assert(strlen_c(\"another\\0test\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_lambda_init_capture\n+  {\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      const auto lambda1 = [a = x](int b){ return a + b; };\n+      const auto lambda2 = [a = lambda1(x)](){ return a; };\n+      return lambda2();\n+    }\n+\n+  }\n+\n+  namespace test_digit_seperators\n+  {\n+\n+    constexpr auto ten_million = 100'000'000;\n+    static_assert(ten_million == 100000000, \"\");\n+\n+  }\n+\n+  namespace test_return_type_deduction\n+  {\n+\n+    auto f(int& x) { return x; }\n+    decltype(auto) g(int& x) { return x; }\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static constexpr auto value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static constexpr auto value = true;\n+    };\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      static_assert(is_same<int, decltype(f(x))>::value, \"\");\n+      static_assert(is_same<int&, decltype(g(x))>::value, \"\");\n+      return x;\n+    }\n+\n+  }\n+\n+}  // namespace cxx14\n+\n+#endif  // __cplusplus >= 201402L\n+\n+]])"
      },
      {
        "sha": "4c4051ea376f720faf21a4705c66604fe444c958",
        "filename": "build-aux/m4/ax_pthread.m4",
        "status": "added",
        "additions": 485,
        "deletions": 0,
        "changes": 485,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_pthread.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/build-aux/m4/ax_pthread.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_pthread.m4?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,485 @@\n+# ===========================================================================\n+#        http://www.gnu.org/software/autoconf-archive/ax_pthread.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])\n+#\n+# DESCRIPTION\n+#\n+#   This macro figures out how to build C programs using POSIX threads. It\n+#   sets the PTHREAD_LIBS output variable to the threads library and linker\n+#   flags, and the PTHREAD_CFLAGS output variable to any special C compiler\n+#   flags that are needed. (The user can also force certain compiler\n+#   flags/libs to be tested by setting these environment variables.)\n+#\n+#   Also sets PTHREAD_CC to any special C compiler that is needed for\n+#   multi-threaded programs (defaults to the value of CC otherwise). (This\n+#   is necessary on AIX to use the special cc_r compiler alias.)\n+#\n+#   NOTE: You are assumed to not only compile your program with these flags,\n+#   but also to link with them as well. For example, you might link with\n+#   $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS $LIBS\n+#\n+#   If you are only building threaded programs, you may wish to use these\n+#   variables in your default LIBS, CFLAGS, and CC:\n+#\n+#     LIBS=\"$PTHREAD_LIBS $LIBS\"\n+#     CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+#     CC=\"$PTHREAD_CC\"\n+#\n+#   In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute constant\n+#   has a nonstandard name, this macro defines PTHREAD_CREATE_JOINABLE to\n+#   that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).\n+#\n+#   Also HAVE_PTHREAD_PRIO_INHERIT is defined if pthread is found and the\n+#   PTHREAD_PRIO_INHERIT symbol is defined when compiling with\n+#   PTHREAD_CFLAGS.\n+#\n+#   ACTION-IF-FOUND is a list of shell commands to run if a threads library\n+#   is found, and ACTION-IF-NOT-FOUND is a list of commands to run it if it\n+#   is not found. If ACTION-IF-FOUND is not specified, the default action\n+#   will define HAVE_PTHREAD.\n+#\n+#   Please let the authors know if this macro fails on any platform, or if\n+#   you have any other suggestions or comments. This macro was based on work\n+#   by SGJ on autoconf scripts for FFTW (http://www.fftw.org/) (with help\n+#   from M. Frigo), as well as ac_pthread and hb_pthread macros posted by\n+#   Alejandro Forero Cuervo to the autoconf macro repository. We are also\n+#   grateful for the helpful feedback of numerous users.\n+#\n+#   Updated for Autoconf 2.68 by Daniel Richard G.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>\n+#   Copyright (c) 2011 Daniel Richard G. <skunk@iSKUNK.ORG>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 23\n+\n+AU_ALIAS([ACX_PTHREAD], [AX_PTHREAD])\n+AC_DEFUN([AX_PTHREAD], [\n+AC_REQUIRE([AC_CANONICAL_HOST])\n+AC_REQUIRE([AC_PROG_CC])\n+AC_REQUIRE([AC_PROG_SED])\n+AC_LANG_PUSH([C])\n+ax_pthread_ok=no\n+\n+# We used to check for pthread.h first, but this fails if pthread.h\n+# requires special compiler flags (e.g. on Tru64 or Sequent).\n+# It gets checked for in the link test anyway.\n+\n+# First of all, check if the user has set any of the PTHREAD_LIBS,\n+# etcetera environment variables, and if threads linking works using\n+# them:\n+if test \"x$PTHREAD_CFLAGS$PTHREAD_LIBS\" != \"x\"; then\n+        ax_pthread_save_CC=\"$CC\"\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        AS_IF([test \"x$PTHREAD_CC\" != \"x\"], [CC=\"$PTHREAD_CC\"])\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+        AC_MSG_CHECKING([for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS])\n+        AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_join])], [ax_pthread_ok=yes])\n+        AC_MSG_RESULT([$ax_pthread_ok])\n+        if test \"x$ax_pthread_ok\" = \"xno\"; then\n+                PTHREAD_LIBS=\"\"\n+                PTHREAD_CFLAGS=\"\"\n+        fi\n+        CC=\"$ax_pthread_save_CC\"\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+fi\n+\n+# We must check for the threads library under a number of different\n+# names; the ordering is very important because some systems\n+# (e.g. DEC) have both -lpthread and -lpthreads, where one of the\n+# libraries is broken (non-POSIX).\n+\n+# Create a list of thread flags to try.  Items starting with a \"-\" are\n+# C compiler flags, and other items are library names, except for \"none\"\n+# which indicates that we try without any flags at all, and \"pthread-config\"\n+# which is a program returning the flags for the Pth emulation library.\n+\n+ax_pthread_flags=\"pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config\"\n+\n+# The ordering *is* (sometimes) important.  Some notes on the\n+# individual items follow:\n+\n+# pthreads: AIX (must check this before -lpthread)\n+# none: in case threads are in libc; should be tried before -Kthread and\n+#       other compiler flags to prevent continual compiler warnings\n+# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)\n+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64\n+#           (Note: HP C rejects this with \"bad form for `-t' option\")\n+# -pthreads: Solaris/gcc (Note: HP C also rejects)\n+# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it\n+#      doesn't hurt to check since this sometimes defines pthreads and\n+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which\n+#      is present but should not be used directly; and before -mthreads,\n+#      because the compiler interprets this as \"-mt\" + \"-hreads\")\n+# -mthreads: Mingw32/gcc, Lynx/gcc\n+# pthread: Linux, etcetera\n+# --thread-safe: KAI C++\n+# pthread-config: use pthread-config program (for GNU Pth library)\n+\n+case $host_os in\n+\n+        freebsd*)\n+\n+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)\n+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)\n+\n+        ax_pthread_flags=\"-kthread lthread $ax_pthread_flags\"\n+        ;;\n+\n+        hpux*)\n+\n+        # From the cc(1) man page: \"[-mt] Sets various -D flags to enable\n+        # multi-threading and also sets -lpthread.\"\n+\n+        ax_pthread_flags=\"-mt -pthread pthread $ax_pthread_flags\"\n+        ;;\n+\n+        openedition*)\n+\n+        # IBM z/OS requires a feature-test macro to be defined in order to\n+        # enable POSIX threads at all, so give the user a hint if this is\n+        # not set. (We don't define these ourselves, as they can affect\n+        # other portions of the system API in unpredictable ways.)\n+\n+        AC_EGREP_CPP([AX_PTHREAD_ZOS_MISSING],\n+            [\n+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)\n+             AX_PTHREAD_ZOS_MISSING\n+#            endif\n+            ],\n+            [AC_MSG_WARN([IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support.])])\n+        ;;\n+\n+        solaris*)\n+\n+        # On Solaris (at least, for some versions), libc contains stubbed\n+        # (non-functional) versions of the pthreads routines, so link-based\n+        # tests will erroneously succeed. (N.B.: The stubs are missing\n+        # pthread_cleanup_push, or rather a function called by this macro,\n+        # so we could check for that, but who knows whether they'll stub\n+        # that too in a future libc.)  So we'll check first for the\n+        # standard Solaris way of linking pthreads (-mt -lpthread).\n+\n+        ax_pthread_flags=\"-mt,pthread pthread $ax_pthread_flags\"\n+        ;;\n+esac\n+\n+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)\n+\n+AS_IF([test \"x$GCC\" = \"xyes\"],\n+      [ax_pthread_flags=\"-pthread -pthreads $ax_pthread_flags\"])\n+\n+# The presence of a feature test macro requesting re-entrant function\n+# definitions is, on some systems, a strong hint that pthreads support is\n+# correctly enabled\n+\n+case $host_os in\n+        darwin* | hpux* | linux* | osf* | solaris*)\n+        ax_pthread_check_macro=\"_REENTRANT\"\n+        ;;\n+\n+        aix*)\n+        ax_pthread_check_macro=\"_THREAD_SAFE\"\n+        ;;\n+\n+        *)\n+        ax_pthread_check_macro=\"--\"\n+        ;;\n+esac\n+AS_IF([test \"x$ax_pthread_check_macro\" = \"x--\"],\n+      [ax_pthread_check_cond=0],\n+      [ax_pthread_check_cond=\"!defined($ax_pthread_check_macro)\"])\n+\n+# Are we compiling with Clang?\n+\n+AC_CACHE_CHECK([whether $CC is Clang],\n+    [ax_cv_PTHREAD_CLANG],\n+    [ax_cv_PTHREAD_CLANG=no\n+     # Note that Autoconf sets GCC=yes for Clang as well as GCC\n+     if test \"x$GCC\" = \"xyes\"; then\n+        AC_EGREP_CPP([AX_PTHREAD_CC_IS_CLANG],\n+            [/* Note: Clang 2.7 lacks __clang_[a-z]+__ */\n+#            if defined(__clang__) && defined(__llvm__)\n+             AX_PTHREAD_CC_IS_CLANG\n+#            endif\n+            ],\n+            [ax_cv_PTHREAD_CLANG=yes])\n+     fi\n+    ])\n+ax_pthread_clang=\"$ax_cv_PTHREAD_CLANG\"\n+\n+ax_pthread_clang_warning=no\n+\n+# Clang needs special handling, because older versions handle the -pthread\n+# option in a rather... idiosyncratic way\n+\n+if test \"x$ax_pthread_clang\" = \"xyes\"; then\n+\n+        # Clang takes -pthread; it has never supported any other flag\n+\n+        # (Note 1: This will need to be revisited if a system that Clang\n+        # supports has POSIX threads in a separate library.  This tends not\n+        # to be the way of modern systems, but it's conceivable.)\n+\n+        # (Note 2: On some systems, notably Darwin, -pthread is not needed\n+        # to get POSIX threads support; the API is always present and\n+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But\n+        # -pthread does define _REENTRANT, and while the Darwin headers\n+        # ignore this macro, third-party headers might not.)\n+\n+        PTHREAD_CFLAGS=\"-pthread\"\n+        PTHREAD_LIBS=\n+\n+        ax_pthread_ok=yes\n+\n+        # However, older versions of Clang make a point of warning the user\n+        # that, in an invocation where only linking and no compilation is\n+        # taking place, the -pthread option has no effect (\"argument unused\n+        # during compilation\").  They expect -pthread to be passed in only\n+        # when source code is being compiled.\n+        #\n+        # Problem is, this is at odds with the way Automake and most other\n+        # C build frameworks function, which is that the same flags used in\n+        # compilation (CFLAGS) are also used in linking.  Many systems\n+        # supported by AX_PTHREAD require exactly this for POSIX threads\n+        # support, and in fact it is often not straightforward to specify a\n+        # flag that is used only in the compilation phase and not in\n+        # linking.  Such a scenario is extremely rare in practice.\n+        #\n+        # Even though use of the -pthread flag in linking would only print\n+        # a warning, this can be a nuisance for well-run software projects\n+        # that build with -Werror.  So if the active version of Clang has\n+        # this misfeature, we search for an option to squash it.\n+\n+        AC_CACHE_CHECK([whether Clang needs flag to prevent \"argument unused\" warning when linking with -pthread],\n+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG],\n+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown\n+             # Create an alternate version of $ac_link that compiles and\n+             # links in two steps (.c -> .o, .o -> exe) instead of one\n+             # (.c -> exe), because the warning occurs only in the second\n+             # step\n+             ax_pthread_save_ac_link=\"$ac_link\"\n+             ax_pthread_sed='s/conftest\\.\\$ac_ext/conftest.$ac_objext/g'\n+             ax_pthread_link_step=`$as_echo \"$ac_link\" | sed \"$ax_pthread_sed\"`\n+             ax_pthread_2step_ac_link=\"($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)\"\n+             ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do\n+                AS_IF([test \"x$ax_pthread_try\" = \"xunknown\"], [break])\n+                CFLAGS=\"-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS\"\n+                ac_link=\"$ax_pthread_save_ac_link\"\n+                AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],\n+                    [ac_link=\"$ax_pthread_2step_ac_link\"\n+                     AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],\n+                         [break])\n+                    ])\n+             done\n+             ac_link=\"$ax_pthread_save_ac_link\"\n+             CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+             AS_IF([test \"x$ax_pthread_try\" = \"x\"], [ax_pthread_try=no])\n+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=\"$ax_pthread_try\"\n+            ])\n+\n+        case \"$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG\" in\n+                no | unknown) ;;\n+                *) PTHREAD_CFLAGS=\"$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS\" ;;\n+        esac\n+\n+fi # $ax_pthread_clang = yes\n+\n+if test \"x$ax_pthread_ok\" = \"xno\"; then\n+for ax_pthread_try_flag in $ax_pthread_flags; do\n+\n+        case $ax_pthread_try_flag in\n+                none)\n+                AC_MSG_CHECKING([whether pthreads work without any flags])\n+                ;;\n+\n+                -mt,pthread)\n+                AC_MSG_CHECKING([whether pthreads work with -mt -lpthread])\n+                PTHREAD_CFLAGS=\"-mt\"\n+                PTHREAD_LIBS=\"-lpthread\"\n+                ;;\n+\n+                -*)\n+                AC_MSG_CHECKING([whether pthreads work with $ax_pthread_try_flag])\n+                PTHREAD_CFLAGS=\"$ax_pthread_try_flag\"\n+                ;;\n+\n+                pthread-config)\n+                AC_CHECK_PROG([ax_pthread_config], [pthread-config], [yes], [no])\n+                AS_IF([test \"x$ax_pthread_config\" = \"xno\"], [continue])\n+                PTHREAD_CFLAGS=\"`pthread-config --cflags`\"\n+                PTHREAD_LIBS=\"`pthread-config --ldflags` `pthread-config --libs`\"\n+                ;;\n+\n+                *)\n+                AC_MSG_CHECKING([for the pthreads library -l$ax_pthread_try_flag])\n+                PTHREAD_LIBS=\"-l$ax_pthread_try_flag\"\n+                ;;\n+        esac\n+\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+\n+        # Check for various functions.  We must include pthread.h,\n+        # since some functions may be macros.  (On the Sequent, we\n+        # need a special flag -Kthread to make this header compile.)\n+        # We check for pthread_join because it is in -lpthread on IRIX\n+        # while pthread_create is in libc.  We check for pthread_attr_init\n+        # due to DEC craziness with -lpthreads.  We check for\n+        # pthread_cleanup_push because it is one of the few pthread\n+        # functions on Solaris that doesn't have a non-functional libc stub.\n+        # We try pthread_create on general principles.\n+\n+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>\n+#                       if $ax_pthread_check_cond\n+#                        error \"$ax_pthread_check_macro must be defined\"\n+#                       endif\n+                        static void routine(void *a) { a = 0; }\n+                        static void *start_routine(void *a) { return a; }],\n+                       [pthread_t th; pthread_attr_t attr;\n+                        pthread_create(&th, 0, start_routine, 0);\n+                        pthread_join(th, 0);\n+                        pthread_attr_init(&attr);\n+                        pthread_cleanup_push(routine, 0);\n+                        pthread_cleanup_pop(0) /* ; */])],\n+            [ax_pthread_ok=yes],\n+            [])\n+\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+\n+        AC_MSG_RESULT([$ax_pthread_ok])\n+        AS_IF([test \"x$ax_pthread_ok\" = \"xyes\"], [break])\n+\n+        PTHREAD_LIBS=\"\"\n+        PTHREAD_CFLAGS=\"\"\n+done\n+fi\n+\n+# Various other checks:\n+if test \"x$ax_pthread_ok\" = \"xyes\"; then\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+\n+        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.\n+        AC_CACHE_CHECK([for joinable pthread attribute],\n+            [ax_cv_PTHREAD_JOINABLE_ATTR],\n+            [ax_cv_PTHREAD_JOINABLE_ATTR=unknown\n+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do\n+                 AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],\n+                                                 [int attr = $ax_pthread_attr; return attr /* ; */])],\n+                                [ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break],\n+                                [])\n+             done\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_JOINABLE_ATTR\" != \"xunknown\" && \\\n+               test \"x$ax_cv_PTHREAD_JOINABLE_ATTR\" != \"xPTHREAD_CREATE_JOINABLE\" && \\\n+               test \"x$ax_pthread_joinable_attr_defined\" != \"xyes\"],\n+              [AC_DEFINE_UNQUOTED([PTHREAD_CREATE_JOINABLE],\n+                                  [$ax_cv_PTHREAD_JOINABLE_ATTR],\n+                                  [Define to necessary symbol if this constant\n+                                   uses a non-standard name on your system.])\n+               ax_pthread_joinable_attr_defined=yes\n+              ])\n+\n+        AC_CACHE_CHECK([whether more special flags are required for pthreads],\n+            [ax_cv_PTHREAD_SPECIAL_FLAGS],\n+            [ax_cv_PTHREAD_SPECIAL_FLAGS=no\n+             case $host_os in\n+             solaris*)\n+             ax_cv_PTHREAD_SPECIAL_FLAGS=\"-D_POSIX_PTHREAD_SEMANTICS\"\n+             ;;\n+             esac\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_SPECIAL_FLAGS\" != \"xno\" && \\\n+               test \"x$ax_pthread_special_flags_added\" != \"xyes\"],\n+              [PTHREAD_CFLAGS=\"$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS\"\n+               ax_pthread_special_flags_added=yes])\n+\n+        AC_CACHE_CHECK([for PTHREAD_PRIO_INHERIT],\n+            [ax_cv_PTHREAD_PRIO_INHERIT],\n+            [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <pthread.h>]],\n+                                             [[int i = PTHREAD_PRIO_INHERIT;]])],\n+                            [ax_cv_PTHREAD_PRIO_INHERIT=yes],\n+                            [ax_cv_PTHREAD_PRIO_INHERIT=no])\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_PRIO_INHERIT\" = \"xyes\" && \\\n+               test \"x$ax_pthread_prio_inherit_defined\" != \"xyes\"],\n+              [AC_DEFINE([HAVE_PTHREAD_PRIO_INHERIT], [1], [Have PTHREAD_PRIO_INHERIT.])\n+               ax_pthread_prio_inherit_defined=yes\n+              ])\n+\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+\n+        # More AIX lossage: compile with *_r variant\n+        if test \"x$GCC\" != \"xyes\"; then\n+            case $host_os in\n+                aix*)\n+                AS_CASE([\"x/$CC\"],\n+                    [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],\n+                    [#handle absolute path differently from PATH based program lookup\n+                     AS_CASE([\"x$CC\"],\n+                         [x/*],\n+                         [AS_IF([AS_EXECUTABLE_P([${CC}_r])],[PTHREAD_CC=\"${CC}_r\"])],\n+                         [AC_CHECK_PROGS([PTHREAD_CC],[${CC}_r],[$CC])])])\n+                ;;\n+            esac\n+        fi\n+fi\n+\n+test -n \"$PTHREAD_CC\" || PTHREAD_CC=\"$CC\"\n+\n+AC_SUBST([PTHREAD_LIBS])\n+AC_SUBST([PTHREAD_CFLAGS])\n+AC_SUBST([PTHREAD_CC])\n+\n+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:\n+if test \"x$ax_pthread_ok\" = \"xyes\"; then\n+        ifelse([$1],,[AC_DEFINE([HAVE_PTHREAD],[1],[Define if you have POSIX threads libraries and header files.])],[$1])\n+        :\n+else\n+        ax_pthread_ok=no\n+        $2\n+fi\n+AC_LANG_POP\n+])dnl AX_PTHREAD"
      },
      {
        "sha": "71bda3d8f0befb08cda53f2a5bf531810ac09cd9",
        "filename": "configure.ac",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,102 @@\n+AC_INIT([minisketch], [0.0.1], [http://github.com/sipa/minisketch/])\n+\n+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n+\n+AC_PREREQ(2.60)\n+AC_CONFIG_SRCDIR([src/minisketch.cpp])\n+AC_CONFIG_AUX_DIR([build-aux])\n+AC_CONFIG_MACRO_DIR([build-aux/m4])\n+AM_INIT_AUTOMAKE([subdir-objects foreign])\n+\n+LT_INIT\n+LT_LANG([C++])\n+AC_LANG([C++])\n+\n+AC_PATH_PROG(CCACHE,ccache)\n+\n+AC_ARG_ENABLE([ccache],\n+  [AS_HELP_STRING([--disable-ccache],\n+  [do not use ccache for building (default is to use if found)])],\n+  [use_ccache=$enableval],\n+  [use_ccache=auto])\n+\n+AC_ARG_ENABLE(tests,\n+    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    [use_tests=$enableval],\n+    [use_tests=yes])\n+\n+AC_ARG_ENABLE(benchmark,\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is no)]),\n+    [use_benchmark=$enableval],\n+    [use_benchmark=no])\n+\n+dnl Check for pthread compile/link requirements\n+AX_PTHREAD\n+\n+AX_CHECK_COMPILE_FLAG([-Werror],[CXXFLAG_WERROR=\"-Werror\"],[CXXFLAG_WERROR=\"\"])\n+\n+AX_CXX_COMPILE_STDCXX([11], [noext], [mandatory], [nodefault])\n+enable_clmul=\n+AX_CHECK_COMPILE_FLAG([-mpclmul],[[enable_clmul=yes]],,[[$CXXFLAG_WERROR]])\n+if test x$enable_clmul = xyes; then\n+  CLMUL_CXXFLAGS=\"-mpclmul\"\n+  AC_DEFINE(HAVE_CLMUL, 1, [Define this symbol if clmul instructions can be used])\n+fi\n+\n+\n+AC_MSG_CHECKING(for working clz builtins)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [\n+  unsigned a = __builtin_clz(1);\n+  unsigned long b = __builtin_clzl(1);\n+  unsigned long long c = __builtin_clzll(1);\n+  ])],\n+  [\n+    AC_DEFINE(HAVE_CLZ, 1, [Define this symbol if clz builtins are present and working])\n+    AC_MSG_RESULT(yes)\n+  ],[\n+    AC_MSG_RESULT(no)\n+  ]\n+)\n+\n+AX_CHECK_COMPILE_FLAG([-Wall],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wall\"],,[[$CXXFLAG_WERROR]])\n+## Some compilers (gcc) ignore unknown -Wno-* options, but warn about all\n+## unknown options if any other warning is produced. Test the -Wfoo case, and\n+## set the -Wno-foo case if it works.\n+AX_CHECK_COMPILE_FLAG([-Wshift-count-overflow],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-shift-count-overflow\"],,[[$CXXFLAG_WERROR]])\n+\n+if test \"x$use_ccache\" != \"xno\"; then\n+  AC_MSG_CHECKING(if ccache should be used)\n+  if test x$CCACHE = x; then\n+    if test \"x$use_ccache\" = \"xyes\"; then\n+      AC_MSG_ERROR([ccache not found.]);\n+    else\n+      use_ccache=no\n+    fi\n+  else\n+    use_ccache=yes\n+    CC=\"$ac_cv_path_CCACHE $CC\"\n+    CXX=\"$ac_cv_path_CCACHE $CXX\"\n+  fi\n+  AC_MSG_RESULT($use_ccache)\n+fi\n+if test \"x$use_ccache\" = \"xyes\"; then\n+    AX_CHECK_COMPILE_FLAG([-Qunused-arguments],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Qunused-arguments\"],,[[$CXXFLAG_WERROR]])\n+fi\n+\n+VERIFY_DEFINES=-DMINISKETCH_VERIFY\n+RELEASE_DEFINES=\n+\n+AC_CONFIG_FILES([\n+    Makefile\n+])\n+\n+AC_SUBST(CLMUL_CXXFLAGS)\n+AC_SUBST(WARN_CXXFLAGS)\n+AC_SUBST(NOWARN_CXXFLAGS)\n+AC_SUBST(VERIFY_DEFINES)\n+AC_SUBST(RELEASE_DEFINES)\n+AM_CONDITIONAL([ENABLE_CLMUL],[test x$enable_clmul = xyes])\n+AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n+AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AC_OUTPUT\n+"
      },
      {
        "sha": "7279165845efc230d9781cecf99107231722ffbc",
        "filename": "doc/example.c",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/example.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/example.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/example.c?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,51 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"../include/minisketch.h\"\n+\n+int main(void) {\n+\n+  minisketch *sketch_a = minisketch_create(12, 0, 4);\n+\n+  for (int i = 3000; i < 3010; ++i) {\n+    minisketch_add_uint64(sketch_a, i);\n+  }\n+\n+  size_t sersize = minisketch_serialized_size(sketch_a);\n+  assert(sersize == 12 * 4 / 8); // 4 12-bit values is 6 bytes.\n+  unsigned char *buffer_a = malloc(sersize);\n+  minisketch_serialize(sketch_a, buffer_a);\n+  minisketch_destroy(sketch_a);\n+\n+  minisketch *sketch_b = minisketch_create(12, 0, 4); // Bob's own sketch\n+  for (int i = 3002; i < 3012; ++i) {\n+    minisketch_add_uint64(sketch_b, i);\n+  }\n+\n+  sketch_a = minisketch_create(12, 0, 4);     // Alice's sketch\n+  minisketch_deserialize(sketch_a, buffer_a); // Load Alice's sketch\n+  free(buffer_a);\n+\n+  // Merge the elements from sketch_a into sketch_b. The result is a sketch_b\n+  // which contains all elements that occurred in Alice's or Bob's sets, but not\n+  // in both.\n+  minisketch_merge(sketch_b, sketch_a);\n+\n+  uint64_t differences[4];\n+  ssize_t num_differences = minisketch_decode(sketch_b, 4, differences);\n+  minisketch_destroy(sketch_a);\n+  minisketch_destroy(sketch_b);\n+  if (num_differences < 0) {\n+    printf(\"More than 4 differences!\\n\");\n+  } else {\n+    ssize_t i;\n+    for (i = 0; i < num_differences; ++i) {\n+      printf(\"%u is in only one of the two sets\\n\", (unsigned)differences[i]);\n+    }\n+  }\n+}"
      },
      {
        "sha": "d1e75a6e2912ed2f1989d96e4c5922a42c16bb74",
        "filename": "doc/gen_basefpbits.sage",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/gen_basefpbits.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/gen_basefpbits.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gen_basefpbits.sage?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,78 @@\n+# Require exact values up to\n+FPBITS = 256\n+\n+# Overkill accuracy\n+F = RealField(400)\n+\n+def BaseFPBits(bits, capacity):\n+    return bits * capacity - int(ceil(F(log(sum(binomial(2**bits - 1, i) for i in range(capacity+1)), 2))))\n+\n+def Log2Factorial(capacity):\n+    return int(floor(log(factorial(capacity), 2)))\n+\n+print(\"uint64_t BaseFPBits(uint32_t bits, uint32_t capacity) {\")\n+print(\"    // Correction table for low bits/capacities\")\n+TBLS={}\n+FARS={}\n+SKIPS={}\n+for bits in range(1, 32):\n+    TBL = []\n+    for capacity in range(1, min(2**bits, FPBITS)):\n+        exact = BaseFPBits(bits, capacity)\n+        approx = Log2Factorial(capacity)\n+        TBL.append((exact, approx))\n+    MIN = 10000000000\n+    while len(TBL) and ((TBL[-1][0] == TBL[-1][1]) or (TBL[-1][0] >= FPBITS and TBL[-1][1] >= FPBITS)):\n+        MIN = min(MIN, TBL[-1][0] - TBL[-1][1])\n+        TBL.pop()\n+    while len(TBL) and (TBL[-1][0] - TBL[-1][1] == MIN):\n+        TBL.pop()\n+    SKIP = 0\n+    while SKIP < len(TBL) and TBL[SKIP][0] == TBL[SKIP][1]:\n+        SKIP += 1\n+    DIFFS = [TBL[i][0] - TBL[i][1] for i in range(SKIP, len(TBL))]\n+    if len(DIFFS) > 0 and len(DIFFS) * Integer(max(DIFFS)).nbits() > 64:\n+        print(\"    static constexpr uint8_t ADD%i[] = {%s};\" % (bits, \", \".join((\"%i\" % (TBL[i][0] - TBL[i][1])) for i in range(SKIP, len(TBL)))))\n+    TBLS[bits] = DIFFS\n+    FARS[bits] = MIN\n+    SKIPS[bits] = SKIP\n+print(\"\")\n+print(\"    if (capacity == 0) return 0;\")\n+print(\"    uint64_t ret = 0;\")\n+print(\"    if (bits < 32 && capacity >= (1U << bits)) {\")\n+print(\"        ret = uint64_t{bits} * (capacity - (1U << bits) + 1);\")\n+print(\"        capacity = (1U << bits) - 1;\")\n+print(\"    }\")\n+print(\"    ret += Log2Factorial(capacity);\")\n+print(\"    switch (bits) {\")\n+for bits in sorted(TBLS.keys()):\n+    if len(TBLS[bits]) == 0:\n+        continue\n+    width = Integer(max(TBLS[bits])).nbits()\n+    if len(TBLS[bits]) == 1:\n+        add = \"%i\" % TBLS[bits][0]\n+    elif len(TBLS[bits]) * width <= 64:\n+        code = sum((2**(width*i) * TBLS[bits][i]) for i in range(len(TBLS[bits])))\n+        if width == 1:\n+            add = \"(0x%x >> (capacity - %i)) & 1\" % (code, 1 + SKIPS[bits])\n+        else:\n+            add = \"(0x%x >> %i * (capacity - %i)) & %i\" % (code, width, 1 + SKIPS[bits], 2**width - 1)\n+    else:\n+        add = \"ADD%i[capacity - %i]\" % (bits, 1 + SKIPS[bits])\n+    if len(TBLS[bits]) + SKIPS[bits] == 2**bits - 1:\n+        print(\"        case %i: return ret + (capacity <= %i ? 0 : %s);\" % (bits, SKIPS[bits], add))\n+    else:\n+        print(\"        case %i: return ret + (capacity <= %i ? 0 : capacity > %i ? %i : %s);\" % (bits, SKIPS[bits], len(TBLS[bits]) + SKIPS[bits], FARS[bits], add))\n+print(\"        default: return ret;\")\n+print(\"    }\")\n+print(\"}\")\n+\n+print(\"void TestBaseFPBits() {\")\n+print(\"    static constexpr uint16_t TBL[20][100] = {%s};\" % (\", \".join(\"{\" + \", \".join((\"%i\" % BaseFPBits(bits, capacity)) for capacity in range(0, 100)) + \"}\" for bits in range(1, 21))))\n+print(\"    for (int bits = 1; bits <= 20; ++bits) {\")\n+print(\"        for (int capacity = 0; capacity < 100; ++capacity) {\")\n+print(\"        uint64_t computed = BaseFPBits(bits, capacity), exact = TBL[bits - 1][capacity];\")\n+print(\"            CHECK(exact == computed || (exact >= 256 && computed >= 256));\")\n+print(\"        }\")\n+print(\"    }\")\n+print(\"}\")"
      },
      {
        "sha": "afab49778bc4245356bd0a61f4bf89062e7336f0",
        "filename": "doc/gen_params.sage",
        "status": "added",
        "additions": 326,
        "deletions": 0,
        "changes": 326,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/gen_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/gen_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gen_params.sage?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,326 @@\n+#!/usr/bin/env sage\n+r\"\"\"\n+Generate finite field parameters for minisketch.\n+\n+This script selects the finite fields used by minisketch\n+ for various sizes and generates the required tables for\n+ the implementation.\n+\n+The output (after formatting) can be found in src/fields/*.cpp.\n+\n+\"\"\"\n+B.<b> = GF(2)\n+P.<p> = B[]\n+\n+def apply_map(m, v):\n+    r = 0\n+    i = 0\n+    while v != 0:\n+        if (v & 1):\n+            r ^^= m[i]\n+        i += 1\n+        v >>= 1\n+    return r\n+\n+def recurse_moduli(acc, maxweight, maxdegree):\n+    for pos in range(maxweight, maxdegree + 1, 1):\n+        poly = acc + p^pos\n+        if maxweight == 1:\n+            if poly.is_irreducible():\n+                return (pos, poly)\n+        else:\n+            (deg, ret) = recurse_moduli(poly, maxweight - 1, pos - 1)\n+            if ret is not None:\n+                return (pos, ret)\n+    return (None, None)\n+\n+def compute_moduli(bits):\n+    # Return all optimal irreducible polynomials for GF(2^bits)\n+    # The result is a list of tuples (weight, degree of second-highest nonzero coefficient, polynomial)\n+    maxdegree = bits - 1\n+    result = []\n+    for weight in range(1, bits, 2):\n+        deg, res = None, None\n+        while True:\n+            ret = recurse_moduli(p^bits + 1, weight, maxdegree)\n+            if ret[0] is not None:\n+                (deg, res) = ret\n+                maxdegree = deg - 1\n+            else:\n+                break\n+        if res is not None:\n+            result.append((weight + 2, deg, res))\n+    return result\n+\n+def bits_to_int(vals):\n+    ret = 0\n+    base = 1\n+    for val in vals:\n+        ret += Integer(val) * base\n+        base *= 2\n+    return ret\n+\n+def sqr_table(f, bits, n=1):\n+    ret = []\n+    for i in range(bits):\n+        ret.append((f^(2^n*i)).integer_representation())\n+    return ret\n+\n+# Compute x**(2**n)\n+def pow2(x, n):\n+    for i in range(n):\n+        x = x**2\n+    return x\n+\n+def qrt_table(F, f, bits):\n+    # Table for solving x2 + x = a\n+    # This implements the technique from https://www.raco.cat/index.php/PublicacionsMatematiques/article/viewFile/37927/40412, Lemma 1\n+    for i in range(bits):\n+        if (f**i).trace() != 0:\n+            u = f**i\n+    ret = []\n+    for i in range(0, bits):\n+        d = f^i\n+        y = sum(pow2(d, j) * sum(pow2(u, k) for k in range(j)) for j in range(1, bits))\n+        ret.append(y.integer_representation() ^^ (y.integer_representation() & 1))\n+    return ret\n+\n+def conv_tables(F, NF, bits):\n+    # Generate a F(2) linear projection that maps elements from one field\n+    #  to an isomorphic field with a different modulus.\n+    f = F.gen()\n+    fp = f.minimal_polynomial()\n+    assert(fp == F.modulus())\n+    nfp = fp.change_ring(NF)\n+    nf = sorted(nfp.roots(multiplicities=False))[0]\n+    ret = []\n+    matrepr = [[B(0) for x in range(bits)] for y in range(bits)]\n+    for i in range(bits):\n+        val = (nf**i).integer_representation()\n+        ret.append(val)\n+        for j in range(bits):\n+            matrepr[j][i] = B((val >> j) & 1)\n+    mat = Matrix(matrepr).inverse().transpose()\n+    ret2 = []\n+    for i in range(bits):\n+        ret2.append(bits_to_int(mat[i]))\n+\n+    for t in range(100):\n+        f1a = F.random_element()\n+        f1b = F.random_element()\n+        f1r = f1a * f1b\n+        f2a = NF.fetch_int(apply_map(ret, f1a.integer_representation()))\n+        f2b = NF.fetch_int(apply_map(ret, f1b.integer_representation()))\n+        f2r = NF.fetch_int(apply_map(ret, f1r.integer_representation()))\n+        f2s = f2a * f2b\n+        assert(f2r == f2s)\n+\n+    for t in range(100):\n+        f2a = NF.random_element()\n+        f2b = NF.random_element()\n+        f2r = f2a * f2b\n+        f1a = F.fetch_int(apply_map(ret2, f2a.integer_representation()))\n+        f1b = F.fetch_int(apply_map(ret2, f2b.integer_representation()))\n+        f1r = F.fetch_int(apply_map(ret2, f2r.integer_representation()))\n+        f1s = f1a * f1b\n+        assert(f1r == f1s)\n+\n+    return (ret, ret2)\n+\n+def fmt(i,typ):\n+    if i == 0:\n+        return \"0\"\n+    else:\n+        return \"0x%x\" % i\n+\n+def lintranstype(typ, bits, maxtbl):\n+    gsize = min(maxtbl, bits)\n+    array_size = (bits + gsize - 1) // gsize\n+    bits_list = []\n+    total = 0\n+    for i in range(array_size):\n+        rsize = (bits - total + array_size - i - 1) // (array_size - i)\n+        total += rsize\n+        bits_list.append(rsize)\n+    return \"RecLinTrans<%s, %s>\" % (typ, \", \".join(\"%i\" % x for x in bits_list))\n+\n+INT=0\n+CLMUL=1\n+CLMUL_TRI=2\n+MD=3\n+\n+def print_modulus_md(mod):\n+    ret = \"\"\n+    pos = mod.degree()\n+    for c in reversed(list(mod)):\n+        if c:\n+            if ret:\n+                ret += \" + \"\n+            if pos == 0:\n+                ret += \"1\"\n+            elif pos == 1:\n+                ret += \"x\"\n+            else:\n+                ret += \"x<sup>%i</sup>\" % pos\n+        pos -= 1\n+    return ret\n+\n+def pick_modulus(bits, style):\n+    # Choose the lexicographicly-first lowest-weight modulus\n+    #  optionally subject to implementation specific constraints.\n+    moduli = compute_moduli(bits)\n+    if style == INT or style == MD:\n+        multi_sqr = False\n+        need_trans = False\n+    elif style == CLMUL:\n+        # Fast CLMUL reduction requires that bits + the highest\n+        #  set bit are less than 66.\n+        moduli = filter(lambda x: bits+x[1] <= 66, moduli) + moduli\n+        multi_sqr = True\n+        need_trans = True\n+        if not moduli or moduli[0][2].change_ring(ZZ)(2) == 3 + 2**bits:\n+            # For modulus 3, CLMUL_TRI is obviously better.\n+            return None\n+    elif style == CLMUL_TRI:\n+        moduli = filter(lambda x: bits+x[1] <= 66, moduli) + moduli\n+        moduli = filter(lambda x: x[0] == 3, moduli)\n+        multi_sqr = True\n+        need_trans = True\n+    else:\n+        assert(False)\n+    if not moduli:\n+        return None\n+    return moduli[0][2]\n+\n+def print_result(bits, style):\n+    if style == INT:\n+        multi_sqr = False\n+        need_trans = False\n+        table_id = \"%i\" % bits\n+    elif style == MD:\n+        pass\n+    elif style == CLMUL:\n+        multi_sqr = True\n+        need_trans = True\n+        table_id = \"%i\" % bits\n+    elif style == CLMUL_TRI:\n+        multi_sqr = True\n+        need_trans = True\n+        table_id = \"TRI%i\" % bits\n+    else:\n+        assert(False)\n+\n+    nmodulus = pick_modulus(bits, INT)\n+    modulus = pick_modulus(bits, style)\n+    if modulus is None:\n+        return\n+\n+    if style == MD:\n+        print(\"* *%s*\" % print_modulus_md(modulus))\n+        return\n+\n+    if bits > 32:\n+        typ = \"uint64_t\"\n+    elif bits > 16:\n+        typ = \"uint32_t\"\n+    elif bits > 8:\n+        typ = \"uint16_t\"\n+    else:\n+        typ = \"uint8_t\"\n+\n+    ttyp = lintranstype(typ, bits, 4)\n+    rtyp = lintranstype(typ, bits, 6)\n+\n+    F.<f> = GF(2**bits, modulus=modulus)\n+\n+    include_table = True\n+    if style != INT and style != CLMUL:\n+        cmodulus = pick_modulus(bits, CLMUL)\n+        if cmodulus == modulus:\n+            include_table = False\n+            table_id = \"%i\" % bits\n+\n+    if include_table:\n+        print(\"typedef %s StatTable%s;\" % (rtyp, table_id))\n+        rtyp = \"StatTable%s\" % table_id\n+        if (style == INT):\n+            print(\"typedef %s DynTable%s;\" % (ttyp, table_id))\n+            ttyp = \"DynTable%s\" % table_id\n+\n+    if need_trans:\n+        if modulus != nmodulus:\n+            # If the bitstream modulus is not the best modulus for\n+            #  this implementation a conversion table will be needed.\n+            ctyp = rtyp\n+            NF.<nf> = GF(2**bits, modulus=nmodulus)\n+            ctables = conv_tables(NF, F, bits)\n+            loadtbl = \"&LOAD_TABLE_%s\" % table_id\n+            savetbl = \"&SAVE_TABLE_%s\" % table_id\n+            if include_table:\n+                print(\"constexpr %s LOAD_TABLE_%s({%s});\" % (ctyp, table_id, \", \".join([fmt(x,typ) for x in ctables[0]])))\n+                print(\"constexpr %s SAVE_TABLE_%s({%s});\" % (ctyp, table_id, \", \".join([fmt(x,typ) for x in ctables[1]])))\n+        else:\n+            ctyp = \"IdTrans\"\n+            loadtbl = \"&ID_TRANS\"\n+            savetbl = \"&ID_TRANS\"\n+    else:\n+        assert(modulus == nmodulus)\n+\n+    if include_table:\n+        print(\"constexpr %s SQR_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 1)])))\n+    if multi_sqr:\n+        # Repeated squaring is a linearised polynomial so in F(2^n) it is\n+        #  F(2) linear and can be computed by a simple bit-matrix.\n+        # Repeated squaring is especially useful in powering ladders such as\n+        #  for inversion.\n+        sqr2 = \"nullptr\"\n+        sqr4 = \"nullptr\"\n+        sqr8 = \"nullptr\"\n+        sqr16 = \"nullptr\"\n+        if ((bits - 1) >= 4):\n+            if include_table:\n+                print(\"constexpr %s SQR2_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 2)])))\n+            sqr2 = \"&SQR2_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 8):\n+            if include_table:\n+                print(\"constexpr %s SQR4_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 4)])))\n+            sqr4 = \"&SQR4_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 16):\n+            if include_table:\n+                print(\"constexpr %s SQR8_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 8)])))\n+            sqr8 = \"&SQR8_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 32):\n+            if include_table:\n+                print(\"constexpr %s SQR16_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 16)])))\n+            sqr16 = \"&SQR16_TABLE_%s\" % table_id\n+    if include_table:\n+        print(\"constexpr %s QRT_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in qrt_table(F, f, bits)])))\n+\n+    modulus_weight = modulus.hamming_weight()\n+    modulus_degree = (modulus - p**bits).degree()\n+    modulus_int = (modulus - p**bits).change_ring(ZZ)(2)\n+\n+    lfsr = \"\"\n+\n+    if style == INT:\n+        print(\"typedef Field<%s, %i, %i, %s, %s, &SQR_TABLE_%s, &QRT_TABLE_%s%s> Field%i;\" % (typ, bits, modulus_int, rtyp, ttyp, table_id, table_id, lfsr, bits))\n+    elif style == CLMUL:\n+        print(\"typedef Field<%s, %i, %i, %s, &SQR_TABLE_%s, %s, %s, %s, %s, &QRT_TABLE_%s, %s, %s, %s%s> Field%i;\" % (typ, bits, modulus_int, rtyp, table_id, sqr2, sqr4, sqr8, sqr16, table_id, ctyp, loadtbl, savetbl, lfsr, bits))\n+    elif style == CLMUL_TRI:\n+        print(\"typedef FieldTri<%s, %i, %i, %s, &SQR_TABLE_%s, %s, %s, %s, %s, &QRT_TABLE_%s, %s, %s, %s> FieldTri%i;\" % (typ, bits, modulus_degree, rtyp, table_id, sqr2, sqr4, sqr8, sqr16, table_id, ctyp, loadtbl, savetbl, bits))\n+    else:\n+        assert(False)\n+\n+for bits in range(2, 65):\n+    print(\"// %i bit field\" % bits)\n+    print_result(bits, INT)\n+    print(\"\")\n+\n+for bits in range(2, 65):\n+    print(\"// %i bit field\" % bits)\n+    print_result(bits, CLMUL)\n+    print_result(bits, CLMUL_TRI)\n+    print(\"\")\n+\n+for bits in range(2, 65):\n+    print_result(bits, MD)"
      },
      {
        "sha": "afc6d66c57b68323d189546f407b55b4a25f6a83",
        "filename": "doc/log2_factorial.sage",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/log2_factorial.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/log2_factorial.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/log2_factorial.sage?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,85 @@\n+import bisect\n+\n+INPUT_BITS = 32\n+TABLE_BITS = 5\n+INT_BITS = 64\n+EXACT_FPBITS = 256\n+\n+F = RealField(100) # overkill\n+\n+def BestOverApproxInvLog2(mulof, maxd):\n+    \"\"\"\n+    Compute denominator of an approximation of 1/log(2).\n+\n+    Specifically, find the value of d (<= maxd, and a multiple of mulof)\n+    such that ceil(d/log(2))/d is the best approximation of 1/log(2).\n+    \"\"\"\n+    dist=1\n+    best=0\n+    # Precomputed denominators that lead to good approximations of 1/log(2)\n+    for d in [1, 2, 9, 70, 131, 192, 445, 1588, 4319, 11369, 18419, 25469, 287209, 836158, 3057423, 8336111, 21950910, 35565709, 49180508, 161156323, 273132138, 385107953, 882191721]:\n+        kd = lcm(mulof, d)\n+        if kd <= maxd:\n+            n = ceil(kd / log(2))\n+            dis = F((n / kd) - 1 / log(2))\n+            if dis < dist:\n+                dist = dis\n+                best = kd\n+    return best\n+\n+\n+LOG2_TABLE = []\n+A = 0\n+B = 0\n+C = 0\n+D = 0\n+K = 0\n+\n+def Setup(k):\n+    global LOG2_TABLE, A, B, C, D, K\n+    K = k\n+    LOG2_TABLE = []\n+    for i in range(2 ** TABLE_BITS):\n+        LOG2_TABLE.append(int(floor(F(K * log(1 + i / 2**TABLE_BITS, 2)))))\n+\n+    # Maximum for (2*x+1)*LogK2(x)\n+    max_T = (2^(INPUT_BITS + 1) - 1) * (INPUT_BITS*K - 1)\n+    # Maximum for A\n+    max_A = (2^INT_BITS - 1) // max_T\n+    D = BestOverApproxInvLog2(2 * K, max_A * 2 * K)\n+    A = D // (2 * K)\n+    B = int(ceil(F(D/log(2))))\n+    C = int(floor(F(D*log(2*pi,2)/2)))\n+\n+def LogK2(n):\n+    assert(n >= 1 and n < (1 << INPUT_BITS))\n+    bits = Integer(n).nbits()\n+    return K * (bits - 1) + LOG2_TABLE[((n << (INPUT_BITS - bits)) >> (INPUT_BITS - TABLE_BITS - 1)) - 2**TABLE_BITS]\n+\n+def Log2Fact(n):\n+    # Use formula (A*(2*x+1)*LogK2(x) - B*x + C) / D\n+    return (A*(2*n+1)*LogK2(n) - B*n + C) // D + (n < 3)\n+\n+RES = [int(F(log(factorial(i),2))) for i in range(EXACT_FPBITS * 10)]\n+\n+best_worst_ratio = 0\n+\n+for K in range(1, 10000):\n+    Setup(K)\n+    assert(LogK2(1) == 0)\n+    assert(LogK2(2) == K)\n+    assert(LogK2(4) == 2 * K)\n+    good = True\n+    worst_ratio = 1\n+    for i in range(1, EXACT_FPBITS * 10):\n+        exact = RES[i]\n+        approx = Log2Fact(i)\n+        if not (approx <= exact and ((approx == exact) or (approx >= EXACT_FPBITS and exact >= EXACT_FPBITS))):\n+            good = False\n+            break\n+        if worst_ratio * exact > approx:\n+            worst_ratio = approx / exact\n+    if good and worst_ratio > best_worst_ratio:\n+        best_worst_ratio = worst_ratio\n+        print(\"Formula: (%i*(2*x+1)*floor(%i*log2(x)) - %i*x + %i) / %i; log(max_ratio)=%f\" % (A, K, B, C, D, RR(-log(worst_ratio))))\n+        print(\"LOG2K_TABLE: %r\" % LOG2_TABLE)"
      },
      {
        "sha": "cf46f193ab84397613d3883ebfebf3125e2e7843",
        "filename": "doc/math.md",
        "status": "added",
        "additions": 117,
        "deletions": 0,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/math.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/math.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/math.md?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,117 @@\n+# The mathematics of Minisketch sketches\n+\n+This is an unconventional mathematical overview of the PinSketch algorithm without references to coding theory<sup>[[1]](#myfootnote1)</sup>.\n+\n+## Set sketches\n+\n+A sketch, for the purpose of this description, can be seen as a \"set checksum\" with two peculiar properties:\n+\n+* Sketches have a predetermined capacity, and when the number of elements in the set is not higher than the capacity, minisketch will always recover the entire set from the sketch. A sketch of *b*-bit elements with capacity *c* can be stored in *bc* bits.\n+* The sketches of two sets can be combined by adding them (XOR) to obtain a sketch of the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) between the two sets (*i.e.*, all elements that occur in one but not both input sets).\n+\n+This overview explains how sets can be converted into a sketch and how a set can be recovered from a sketch. \n+\n+## From field elements to sketches\n+\n+**Data entries as field elements**\n+\n+Every integer in the range *[1...2<sup>b</sup>-1]* (the acceptable data elements for a Minisketch sketch with field size *b*) can be mapped to a nonzero field element of *GF(2<sup>b</sup>)*. In this [finite field](https://en.wikipedia.org/wiki/Finite_field), we can add and multiply elements together, with many of the expected properties for those operations. Addition (and subtraction!) of field elements corresponds to bitwise XOR of the integers they correspond to, though multiplication is more involved.\n+\n+**Sets as power series**\n+\n+We define a function *S* which maps field elements *m* to the following [formal power series](https://en.wikipedia.org/wiki/Formal_power_series) (similar to a polynomial, except there can be an infinite number of terms, and we don't care about concepts like convergence as we're never going to actually evaluate it for a specific value of *x*):\n+\n+* *S(m) = 1 + mx + m<sup>2</sup>x<sup>2</sup> + m<sup>3</sup>x<sup>3</sup> + ...*.\n+\n+We then extend this function to operate on sets of field elements, by adding together the images of every set element. If *M = {m<sub>1</sub>, m<sub>2</sub>, ... }*:\n+\n+* *S(M) = S({m<sub>1</sub>,m<sub>2</sub>,...}) = S(m<sub>1</sub>) + S(m<sub>2</sub>) + ... = (1 + 1 + ...) + (m<sub>1</sub> + m<sub>2</sub> + ...)x + (m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ...)x<sup>2</sup> + (m<sub>1</sub><sup>3</sup> + ...*\n+\n+Because in our field addition corresponds to XOR of integers, it holds for every *a* that *a + a = 0*. This carries over to the *S* function, meaning that *S(a) + S(a) = 0* for every *a*. This means that the coefficients of these power series have the second of the properties we\n+desire from a sketch, namely that an efficient operation exists to\n+combine two sketches such that the result is a sketch of the symmetric\n+difference of the sets. It holds that\n+*S({m<sub>1</sub>,m<sub>2</sub>}) + S({m<sub>2</sub>,m<sub>3</sub>}) = S(m<sub>1</sub>) + (S(m<sub>2</sub>) + S(m<sub>2</sub>)) + S(m<sub>3</sub>) = S(m<sub>1</sub>) + S(m<sub>3</sub>) = S({m<sub>1</sub>,m<sub>3</sub>})*. The question is whether we can also efficiently recover the elements from their power series' coefficients.\n+\n+**An infinity of coefficients is hard**\n+\n+To make reasoning about these power series easier, notice that the series for a single element is in fact a [geometric series](https://en.wikipedia.org/wiki/Geometric_series). If we were working over real numbers rather than a finite field and *|mx| < 1*, it would converge to *(1 - mx)<sup>-1</sup>*. Convergence has no meaning in formal power series, however it is still the case that:\n+\n+* *(1 - mx) S(m) = 1*\n+\n+You can verify this by seeing that every coefficient except the constant one gets cancelled out by the multiplication. This can be generalized to the series for multiple set elements. For two elements we have:\n+\n+* *(1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) S({m<sub>1</sub>,m<sub>2</sub>}) = (1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (S(m<sub>1</sub>) + S(m<sub>2</sub>)) = (1 - m<sub>2</sub>x) + (1 - m<sub>1</sub>x)*\n+\n+And for three:\n+\n+* *(1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (1 - m<sub>3</sub>x) S({m<sub>1</sub>,m<sub>2</sub>,m<sub>3</sub>}) = (1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (1 - m<sub>3</sub>x) (S(m<sub>1</sub>) + S(m<sub>2</sub>) + S(m<sub>3</sub>)) = (1 - m<sub>2</sub>x)(1 - m<sub>3</sub>x) + (1 - m<sub>1</sub>x)(1 - m<sub>3</sub>x) + (1 - m<sub>1</sub>x)(1 - m<sub>2</sub>x)*\n+\n+In each case, we notice that multiplying *S(M)* with *(1 - m<sub>i</sub>x)* for each element *m<sub>i</sub> &isin; M* results in a polynomial of degree *n-1*.\n+\n+**Solving for the set elements**\n+\n+The above insight lets us build a solver that extracts the set elements from the coefficients of a power series. If we can find a polynomial *L* that is the product of *n* different *(1 - m<sub>i</sub>x)* factors for various values of *m<sub>i</sub>*, such that *P = S(M)L* is an *n-1* degree polynomial, then those values *m<sub>i</sub>* are the elements of *M*.\n+\n+The coefficients of *P* are nontrivial expressions of the set elements themselves. However, we can just focus on the coefficients of degree *n* and higher in *P*, as those are all 0. Let *s<sub>i</sub>* be the coefficients of *S(M)*, and *l<sub>i</sub>* the coefficients of L. In other words, *S(M) = s<sub>0</sub> + s<sub>1</sub>x + s<sub>2</sub>x<sup>2</sup> + s<sub>3</sub>x<sup>3</sup> + ...* and *L = l<sub>0</sub> + l<sub>1</sub>x + l<sub>2</sub>x<sup>2</sup> + l<sub>3</sub>x<sup>3</sup> + ... + l<sub>n</sub>x<sup>n</sup>*. Note that *l<sub>0</sub> = 1*, as it is the product of all the *1* terms in the *(1 - m<sub>i</sub>x)* factors.\n+\n+Here are the equations for the coefficients of *S(M)L* of degree *n+1* through *2n*:\n+* *s<sub>n+1</sub> + s<sub>n+0</sub>l<sub>1</sub> + s<sub>n-1</sub>l<sub>2</sub> + s<sub>n-2</sub>l<sub>3</sub> + ... + s<sub>1</sub>l<sub>n</sub> = 0*\n+* *s<sub>n+2</sub> + s<sub>n+1</sub>l<sub>1</sub> + s<sub>n+0</sub>l<sub>2</sub> + s<sub>n-1</sub>l<sub>3</sub> + ... + s<sub>2</sub>l<sub>n</sub> = 0*\n+* *s<sub>n+3</sub> + s<sub>n+2</sub>l<sub>1</sub> + s<sub>n+1</sub>l<sub>2</sub> + s<sub>n+0</sub>l<sub>3</sub> + ... + s<sub>3</sub>l<sub>n</sub> = 0*\n+* ...\n+* *s<sub>2n</sub> + s<sub>2n-1</sub>l<sub>1</sub> + s<sub>2n-2</sub>l<sub>2</sub> + s<sub>2n-3</sub>l<sub>3</sub> + ... + s<sub>n</sub>l<sub>n</sub> = 0*\n+\n+These are *n* linear equations with *n* unknowns (the *l<sub>i<sub>*\n+values, for *i=1..n*), which can be solved using [Gaussian elimination](https://en.wikipedia.org/wiki/Gaussian_elimination). After doing so,\n+we have the coefficients of *L*, which can then be [factored](https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields)\n+into first degree factors of the form *(1 - m<sub>i</sub>x)*. The resulting *m* values are our set elements.\n+\n+**Putting it all together**\n+\n+Interestingly, only *2n* coefficients of *S(M)* were needed for solving\n+the set of equations above. This means we have our answer: the\n+coefficients *1* through *2n* of *S(M)*, or the list\n+*[m<sub>1</sub> + m<sub>2</sub> + ..., m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ..., ..., m<sub>1</sub><sup>2n</sup> + m<sub>2</sub><sup>2n</sup> + ...]*\n+functions as a sketch, satisfying the two properties we want:\n+\n+* Sketches can be combined to form the sketch of their symmetric difference, by simply pairwise adding the list elements together.\n+* With *2n* list elements we can efficiently recover *n* elements from a sketch.\n+\n+**Capacity and difference**\n+\n+The approach above only works when the number of elements *n* in the sketch is known. Of course we want to support cases where only an upper bound on the number of elements in the sketch is known, the capacity *c*. Given that we can reconstruct a set of size *c* from a sketch with *2c* terms, we should be able to reconstruct a set of size *n* too as long as *n &le; c*. This is simply a matter of trying to solve the above set of equations assuming values of *n* that count down from *c* until a solution is found for one. This is known as the [Peterson-Gorenstein-Zierler algorithm](https://en.wikipedia.org/wiki/BCH_code#Peterson%E2%80%93Gorenstein%E2%80%93Zierler_algorithm).\n+\n+## Optimizations\n+\n+**Halving the sketch size**\n+\n+We can in fact only include the odd terms in the sketch, and reconstruct the even ones before solving the equation to find *L*. This means the size of a sketch becomes just *c* field elements, the same size as would be needed to send its contents naively.\n+\n+To see how this is possible, we need the [Frobenius endomorphism](https://en.wikipedia.org/wiki/Frobenius_endomorphism), which in short states that in fields where *x + x = 0* it holds that *(x + y)<sup>2</sup> = x<sup>2</sup> + y<sup>2</sup>* for every *x* and *y* (the dream of every high school math student!). This means that:\n+\n+* *s<sub>2</sub> = m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ... = (m<sub>1</sub> + m<sub>2</sub> + ...)<sup>2</sup> = s<sub>1</sub><sup>2</sup>*.\n+* *s<sub>4</sub> = m<sub>1</sub><sup>4</sup> + m<sub>2</sub><sup>4</sup> + ... = (m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ...)<sup>2</sup> = s<sub>2</sub><sup>2</sup>*.\n+* *s<sub>6</sub> = m<sub>1</sub><sup>6</sup> + m<sub>2</sub><sup>6</sup> + ... = (m<sub>1</sub><sup>3</sup> + m<sub>2</sub><sup>3</sup> + ...)<sup>2</sup> = s<sub>3</sub><sup>2</sup>*.\n+* ...\n+\n+In other words, we only need to send *s<sub>1</sub>, s<sub>3</sub>, s<sub>5</sub>, ..., s<sub>2n-1</sub>* to recover all *2n* *s<sub>i</sub>* values, and proceed with reconstruction.\n+\n+**Quadratic performance rather than cubic**\n+\n+Using Gaussian elimination to solve the set of equations above for the *l<sub>i</sub>* values requires *O(n<sup>3</sup>)* field operations. However, due to the special structure in the equations (look at the repeated *s<sub>i</sub>* values), it can be solved in *O(n<sup>2</sup>)* time using a number of techniques, including the [Berlekamp-Massey algorithm](https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm) (BM).\n+\n+**Roots instead of factorization**\n+\n+As explained above, the polynomial *L* can be factored into *(1 - m<sub>i</sub>x)* factors, where the values *m<sub>i</sub>* are the set elements. However, since we know that a decodable sketch must result in a polynomial that is fully factorizable into degree-*1* factors, we can instead use a more efficient root-finding algorithm rather than a factorization algorithm. As the root of each *(1 - m<sub>i</sub>x)* factor is *m<sub>i</sub><sup>-1</sup>*, we conclude that the set elements are in fact the inverses of the roots of *L*.\n+\n+**Avoiding inversions**\n+\n+As inversions are a relatively expensive operation, it would be useful to avoid them.\n+\n+Say that we're trying to find the inverses of the roots of *L = 1 + l<sub>1</sub>x + l<sub>2</sub>x<sup>2</sup> + ... + l<sub>n</sub>x<sup>n</sup>*, then we're really interested in the solutions *y* for *1 + l<sub>1</sub>y<sup>-1</sup> + l<sub>2</sub>y<sup>-2</sup> + ... + l<sub>n</sub>y<sup>-n</sup> = 0*. By multiplying both sides in the equations with *y<sup>n</sup>*, we find *l<sub>n</sub> + l<sub>n-1</sub>y + l<sub>n-2</sub>y<sup>2</sup> + ... + y<sup>n</sup> = 0*.\n+\n+In other words, we can find the inverses of the roots of *L* by instead factoring the polynomial with the coefficients of *L* in reverse order.\n+\n+* <a name=\"myfootnote1\">[1]</a> For those familiar with coding theory: PinSketch communicates a set difference by encoding the set members as errors in a binary [BCH](https://en.wikipedia.org/wiki/BCH_code) codeword 2<sup>bits</sup> in size and sends the syndromes.\n+  The linearity of the syndromes provides all the properties needed for a sketch. Sketch decoding is simply finding the error locations. Decode is much faster than an ordinary BCH decoder for such a large codeword because the need to take a discrete log is avoided by storing the set in the roots directly instead of in an exponent (logically permuting the bits of the codeword)."
      },
      {
        "sha": "379ac481b336f843528ce92c3a4b969843e7a833",
        "filename": "doc/moduli.md",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/moduli.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/moduli.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/moduli.md?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,65 @@\n+These are the irreducible polynomials over *GF(2)* used to represent field elements:\n+\n+* *x<sup>2</sup> + x + 1*\n+* *x<sup>3</sup> + x + 1*\n+* *x<sup>4</sup> + x + 1*\n+* *x<sup>5</sup> + x<sup>2</sup> + 1*\n+* *x<sup>6</sup> + x + 1*\n+* *x<sup>7</sup> + x + 1*\n+* *x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>9</sup> + x + 1*\n+* *x<sup>10</sup> + x<sup>3</sup> + 1*\n+* *x<sup>11</sup> + x<sup>2</sup> + 1*\n+* *x<sup>12</sup> + x<sup>3</sup> + 1*\n+* *x<sup>13</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>14</sup> + x<sup>5</sup> + 1*\n+* *x<sup>15</sup> + x + 1*\n+* *x<sup>16</sup> + x<sup>5</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>17</sup> + x<sup>3</sup> + 1*\n+* *x<sup>18</sup> + x<sup>3</sup> + 1*\n+* *x<sup>19</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>20</sup> + x<sup>3</sup> + 1*\n+* *x<sup>21</sup> + x<sup>2</sup> + 1*\n+* *x<sup>22</sup> + x + 1*\n+* *x<sup>23</sup> + x<sup>5</sup> + 1*\n+* *x<sup>24</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>25</sup> + x<sup>3</sup> + 1*\n+* *x<sup>26</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>27</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>28</sup> + x + 1*\n+* *x<sup>29</sup> + x<sup>2</sup> + 1*\n+* *x<sup>30</sup> + x + 1*\n+* *x<sup>31</sup> + x<sup>3</sup> + 1*\n+* *x<sup>32</sup> + x<sup>7</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>33</sup> + x<sup>10</sup> + 1*\n+* *x<sup>34</sup> + x<sup>7</sup> + 1*\n+* *x<sup>35</sup> + x<sup>2</sup> + 1*\n+* *x<sup>36</sup> + x<sup>9</sup> + 1*\n+* *x<sup>37</sup> + x<sup>6</sup> + x<sup>4</sup> + x + 1*\n+* *x<sup>38</sup> + x<sup>6</sup> + x<sup>5</sup> + x + 1*\n+* *x<sup>39</sup> + x<sup>4</sup> + 1*\n+* *x<sup>40</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>3</sup> + 1*\n+* *x<sup>41</sup> + x<sup>3</sup> + 1*\n+* *x<sup>42</sup> + x<sup>7</sup> + 1*\n+* *x<sup>43</sup> + x<sup>6</sup> + x<sup>4</sup> + x<sup>3</sup> + 1*\n+* *x<sup>44</sup> + x<sup>5</sup> + 1*\n+* *x<sup>45</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>46</sup> + x + 1*\n+* *x<sup>47</sup> + x<sup>5</sup> + 1*\n+* *x<sup>48</sup> + x<sup>5</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>49</sup> + x<sup>9</sup> + 1*\n+* *x<sup>50</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>51</sup> + x<sup>6</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>52</sup> + x<sup>3</sup> + 1*\n+* *x<sup>53</sup> + x<sup>6</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>54</sup> + x<sup>9</sup> + 1*\n+* *x<sup>55</sup> + x<sup>7</sup> + 1*\n+* *x<sup>56</sup> + x<sup>7</sup> + x<sup>4</sup> + x<sup>2</sup> + 1*\n+* *x<sup>57</sup> + x<sup>4</sup> + 1*\n+* *x<sup>58</sup> + x<sup>19</sup> + 1*\n+* *x<sup>59</sup> + x<sup>7</sup> + x<sup>4</sup> + x<sup>2</sup> + 1*\n+* *x<sup>60</sup> + x + 1*\n+* *x<sup>61</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>62</sup> + x<sup>29</sup> + 1*\n+* *x<sup>63</sup> + x + 1*\n+* *x<sup>64</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*"
      },
      {
        "sha": "6e907d6b20c0d88e38283ba0d66dd177070a2986",
        "filename": "doc/plot_bits.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_bits.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_bits.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/plot_bits.png?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7"
      },
      {
        "sha": "b4f760da367bdb440587916b2256363e4823e31e",
        "filename": "doc/plot_capacity.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_capacity.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_capacity.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/plot_capacity.png?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7"
      },
      {
        "sha": "08ab6a86b96d41abf056d91ca7162e22e69e3237",
        "filename": "doc/plot_diff.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_diff.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_diff.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/plot_diff.png?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7"
      },
      {
        "sha": "b21921776a7a9321acd4d1a2b01f455e864e93f7",
        "filename": "doc/plot_size.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_size.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/plot_size.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/plot_size.png?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7"
      },
      {
        "sha": "610407ebc226935902480a42c1c1faed07e3e2bc",
        "filename": "doc/protocoltips.md",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/protocoltips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/doc/protocoltips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/protocoltips.md?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,30 @@\n+# Tips for designing protocols using `libminisketch`\n+\n+Sending a sketch is less efficient than just sending your whole set with efficient entropy coding if the number of differences is larger than *log<sub>2</sub>( 2<sup>b</sup> choose set_size ) / b*.\n+\n+In most applications your set can be hashed to entries just large enough to make the probability of collision negligible. This can be a considerable speedup and bandwidth savings.  Short hashes (<128 bits) should be salted with an unpredictable value to prevent malicious inputs from intentionally causing collisions. Salting also allows an entry missed due to a collision to be reconciled on a later run with a different salt. Pre-hashing may not be possible in some applications, such as where there is only one-way communication, where the confidentiality of entry origin matters, or where security depends on the total absence of collisions.\n+\n+Some element sizes are faster to decode than others; see the benchmarks in the readme.\n+\n+Almost all the computational burden of reconciliation is in minisketch_decode(). Denial-of-service attacks can be mitigated by arranging protocol flow so that a party requests a sketch and decodes it rather than a construction where the participants will decode unsolicited sketches. Decode times can be constrained by limiting sketch capacity or via the max_count argument to minisketch_decode().\n+\n+In most cases you don't actually know the size of the set difference in advance, but often you know a lower bound on it (the difference in set sizes).\n+\n+* There are difference size estimation techniques such as min-wise hashing<sup>[[1]](#myfootnote1)</sup> or random projections<sup>[[2]](#myfootnote2)</sup>, but complex estimators can end up using more bandwidth than they save.\n+\n+* It may be useful to always overestimate the sketch size needed to amortize communications overheads (*e.g.* packet headers, round trip delays).\n+\n+* If the total data sent would end up leaving you better off having just sent the whole set, per above, then you can send the set in response to a failure but leave out as many elements as the size of the previously sent sketch. The receiver can decode the partial set and use the data they already have to complete it, reducing bandwidth waste.\n+\n+* Additional elements can be sent for a sketch as few as one at a time with little decode cost until enough data is received to decode.  This is most easily implemented by always computing the largest sketch size and sending it incrementally as needed.\n+\n+* Because sketches are linear you can adaptively subdivide to decode an overfull set. The sender uses a hash function to select approximately half their set members and sends a sketch of those members. The receiver can do the same and combine the result with the initially sent sketch to get two sketches with roughly half the number of members and attempt to decode them. Repeat recursively on failure. This adaptive subdivision procedure makes decode time essentially linear at the cost of communications inefficiency.  Minisketches can also be used as the cells in an IBLT for similar reasons.\n+\n+Less efficient reconciliation techniques like IBLT or adaptive subdivision, or overheads like complex estimators effectively lower the threshold where sending the whole set efficiently would use less bandwidth.\n+\n+When the number of differences is more than 2<sup>b/2-1</sup> an alternative sketch encoding is possible that is somewhat smaller, but requires a table of size 2<sup>b</sup>; contact the authors if you have an application where that might be useful.\n+\n+## References\n+\n+* <a name=\"myfootnote1\">[1]</a> Broder, A. *On the Resemblance and Containment of Documents* Proceedings of the Compression and Complexity of Sequences 1997 [[PDF]](https://www.cs.princeton.edu/courses/archive/spring13/cos598C/broder97resemblance.pdf)\n+* <a name=\"myfootnote2\">[2]</a> Feigenbaum, Joan and Kannan, Sampath and Strauss, Martin J. and Viswanathan, Mahesh. *An Approximate L1-Difference Algorithm for  Massive Data Streams* SIAM J. Comput. 2003 [[PDF]](http://www.cs.yale.edu/homes/jf/FKSV1.pdf)"
      },
      {
        "sha": "2b991d3956ead97b48c9f25a3740615a2788c7cc",
        "filename": "include/minisketch.h",
        "status": "added",
        "additions": 319,
        "deletions": 0,
        "changes": 319,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/include/minisketch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/include/minisketch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/minisketch.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,319 @@\n+#ifndef _MINISKETCH_H_\n+#define _MINISKETCH_H_ 1\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#ifdef __cplusplus\n+#  if __cplusplus >= 201103L\n+#    include <memory>\n+#    include <vector>\n+#    include <cassert>\n+#    if __cplusplus >= 201703L\n+#      include <optional>\n+#    endif // __cplusplus >= 201703L\n+#  endif // __cplusplus >= 201103L\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/** Opaque type for decoded sketches. */\n+typedef struct minisketch minisketch;\n+\n+/** Determine whether support for elements of `bits` bits was compiled in. */\n+int minisketch_bits_supported(uint32_t bits);\n+\n+/** Determine the maximum number of implementations available.\n+ *\n+ * Multiple implementations may be available for a given element size, with\n+ * different performance characteristics on different hardware.\n+ *\n+ * Each implementation is identified by a number from 0 to the output of this\n+ * function call, inclusive. Note that not every combination of implementation\n+ * and element size may exist (see further).\n+*/\n+uint32_t minisketch_implementation_max(void);\n+\n+/** Determine if the a combination of bits and implementation number is available.\n+ *\n+ * Returns 1 if it is, 0 otherwise.\n+ */\n+int minisketch_implementation_supported(uint32_t bits, uint32_t implementation);\n+\n+/** Construct a sketch for a given element size, implementation and capacity.\n+ *\n+ * If the combination of `bits` and `implementation` is unavailable, or if\n+ * `capacity` is 0, NULL is returned. If minisketch_implementation_supported\n+ * returns 1 for the specified bits and implementation, this will always succeed\n+ * (except when allocation fails).\n+ *\n+ * If the result is not NULL, it must be destroyed using minisketch_destroy.\n+ */\n+minisketch* minisketch_create(uint32_t bits, uint32_t implementation, size_t capacity);\n+\n+/** Get the element size of a sketch in bits. */\n+uint32_t minisketch_bits(const minisketch* sketch);\n+\n+/** Get the capacity of a sketch. */\n+size_t minisketch_capacity(const minisketch* sketch);\n+\n+/** Get the implementation of a sketch. */\n+uint32_t minisketch_implementation(const minisketch* sketch);\n+\n+/** Set the seed for randomizing algorithm choices to a fixed value.\n+ *\n+ * By default, sketches are initialized with a random seed. This is important\n+ * to avoid scenarios where an attacker could force worst-case behavior.\n+ *\n+ * This function initializes the seed to a user-provided value (any 64-bit\n+ * integer is acceptable, regardless of field size).\n+ *\n+ * When seed is -1, a fixed internal value with predictable behavior is\n+ * used. It is only intended for testing.\n+ */\n+void minisketch_set_seed(minisketch* sketch, uint64_t seed);\n+\n+/** Clone a sketch.\n+ *\n+ * The result must be destroyed using minisketch_destroy.\n+ */\n+minisketch* minisketch_clone(const minisketch* sketch);\n+\n+/** Destroy a sketch.\n+ *\n+ * The pointer that was passed in may not be used anymore afterwards.\n+ */\n+void minisketch_destroy(minisketch* sketch);\n+\n+/** Compute the size in bytes for serializing a given sketch. */\n+size_t minisketch_serialized_size(const minisketch* sketch);\n+\n+/** Serialize a sketch to bytes. */\n+void minisketch_serialize(const minisketch* sketch, unsigned char* output);\n+\n+/** Deserialize a sketch from bytes. */\n+void minisketch_deserialize(minisketch* sketch, const unsigned char* input);\n+\n+/** Add an element to a sketch.\n+ * \n+ * If the element to be added is too large for the sketch, the most significant\n+ * bits of the element are dropped. More precisely, if the element size of\n+ * `sketch` is b bits, then this function adds the unsigned integer represented\n+ * by the b least significant bits of `element` to `sketch`.\n+ * \n+ * If the element to be added is 0 (after potentially dropping the most significant\n+ * bits), then this function is a no-op. Sketches cannot contain an element with\n+ * the value 0.\n+ */\n+void minisketch_add_uint64(minisketch* sketch, uint64_t element);\n+\n+/** Merge the elements of another sketch into this sketch.\n+ *\n+ * After merging, `sketch` will contain every element that existed in one but not\n+ * both of the input sketches. It can be seen as an exclusive or operation on\n+ * the set elements.  If the capacity of `other_sketch` is lower than `sketch`'s,\n+ * merging reduces the capacity of `sketch` to that of `other_sketch`.\n+ *\n+ * This function returns the capacity of `sketch` after merging has been performed\n+ * (where this capacity is at least 1), or 0 to indicate that merging has failed because\n+ * the two input sketches differ in their element size or implementation. If 0 is\n+ * returned, `sketch` (and its capacity) have not been modified.\n+ *\n+ * It is also possible to perform this operation directly on the serializations\n+ * of two sketches with the same element size and capacity by performing a bitwise XOR\n+ * of the serializations.\n+ */\n+size_t minisketch_merge(minisketch* sketch, const minisketch* other_sketch);\n+\n+/** Decode a sketch.\n+ *\n+ * `output` is a pointer to an array of `max_element` uint64_t's, which will be\n+ * filled with the elements in this sketch.\n+ *\n+ * The return value is the number of decoded elements, or -1 if decoding failed.\n+ */\n+ssize_t minisketch_decode(const minisketch* sketch, size_t max_elements, uint64_t* output);\n+\n+/** Compute the capacity needed to achieve a certain rate of false positives.\n+ *\n+ * A sketch with capacity c and no more than c elements can always be decoded\n+ * correctly. However, if it has more than c elements, or contains just random\n+ * bytes, it is possible that it will still decode, but the result will be\n+ * nonsense. This can be counteracted by increasing the capacity slightly.\n+ *\n+ * Given a field size bits, an intended number of elements that can be decoded\n+ * max_elements, and a false positive probability of 1 in 2**fpbits, this\n+ * function computes the necessary capacity. It is only guaranteed to be\n+ * accurate up to fpbits=256.\n+ */\n+size_t minisketch_compute_capacity(uint32_t bits, size_t max_elements, uint32_t fpbits);\n+\n+/** Compute what max_elements can be decoded for a certain rate of false positives.\n+ *\n+ * This is the inverse operation of minisketch_compute_capacity. It determines,\n+ * given a field size bits, a capacity of a sketch, and an acceptable false\n+ * positive probability of 1 in 2**fpbits, what the maximum allowed\n+ * max_elements value is. If no value of max_elements would give the desired\n+ * false positive probability, 0 is returned.\n+ *\n+ * Note that this is not an exact inverse of minisketch_compute_capacity. For\n+ * example, with bits=32, fpbits=16, and max_elements=8,\n+ * minisketch_compute_capacity will return 9, as capacity 8 would only have a\n+ * false positive chance of 1 in 2^15.3. Increasing the capacity to 9 however\n+ * decreases the fp chance to 1 in 2^47.3, enough for max_elements=9 (with fp\n+ * chance of 1 in 2^18.5). Therefore, minisketch_compute_max_elements with\n+ * capacity=9 will return 9.\n+ */\n+size_t minisketch_compute_max_elements(uint32_t bits, size_t capacity, uint32_t fpbits);\n+\n+#ifdef __cplusplus\n+}\n+\n+#if __cplusplus >= 201103L\n+/** Simple RAII C++11 wrapper around the minisketch API. */\n+class Minisketch\n+{\n+    struct Deleter\n+    {\n+        void operator()(minisketch* ptr) const\n+        {\n+            minisketch_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<minisketch, Deleter> m_minisketch;\n+\n+public:\n+    /** See minisketch_bits_supported(). */\n+    static bool BitsSupported(uint32_t bits) noexcept { return minisketch_bits_supported(bits); }\n+\n+    /** minisketch_implementation_supported(). */\n+    static bool ImplementationSupported(uint32_t bits, uint32_t implementation) noexcept { return minisketch_implementation_supported(bits, implementation); }\n+\n+    /** See minisketch_implementation_max(). */\n+    static uint32_t MaxImplementation() noexcept { return minisketch_implementation_max(); }\n+\n+    /** See minisketch_compute_capacity(). */\n+    static size_t ComputeCapacity(uint32_t bits, size_t max_elements, uint32_t fpbits) noexcept { return minisketch_compute_capacity(bits, max_elements, fpbits); }\n+\n+    /** See minisketch_compute_max_elements(). */\n+    static size_t ComputeMaxElements(uint32_t bits, size_t capacity, uint32_t fpbits) noexcept { return minisketch_compute_max_elements(bits, capacity, fpbits); }\n+\n+    /** Construct a clone of the specified sketch. */\n+    Minisketch(const Minisketch& sketch) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_clone(sketch.m_minisketch.get()));\n+    }\n+\n+    /** Make this Minisketch a clone of the specified one. */\n+    Minisketch& operator=(const Minisketch& sketch) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_clone(sketch.m_minisketch.get()));\n+        return *this;\n+    }\n+\n+    explicit operator bool() const noexcept { return bool{m_minisketch}; }\n+\n+    Minisketch() noexcept = default;\n+    Minisketch(Minisketch&&) noexcept = default;\n+    Minisketch& operator=(Minisketch&&) noexcept = default;\n+\n+    /** Construct a Minisketch object with the specified parameters. */\n+    Minisketch(uint32_t bits, uint32_t implementation, size_t capacity) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_create(bits, implementation, capacity));\n+    }\n+\n+    /** Create a Minisketch object sufficiently large for the specified number of elements at given fpbits. */\n+    static Minisketch CreateFP(uint32_t bits, uint32_t implementation, size_t max_elements, uint32_t fpbits) noexcept\n+    {\n+        return Minisketch(bits, implementation, ComputeCapacity(bits, max_elements, fpbits));\n+    }\n+\n+    /** See minisketch_get_bits(). */\n+    uint32_t GetBits() const noexcept { return minisketch_bits(m_minisketch.get()); }\n+\n+    /** See minisketch_get_capacity(). */\n+    size_t GetCapacity() const noexcept { return minisketch_capacity(m_minisketch.get()); }\n+\n+    /** See minisketch_get_implementation(). */\n+    uint32_t GetImplementation() const noexcept { return minisketch_implementation(m_minisketch.get()); }\n+\n+    /** See minisketch_set_seed(). */\n+    Minisketch& SetSeed(uint64_t seed) noexcept\n+    {\n+        minisketch_set_seed(m_minisketch.get(), seed);\n+        return *this;\n+    }\n+\n+    /** See miniksetch_add_element(). */\n+    Minisketch& Add(uint64_t element) noexcept\n+    {\n+        minisketch_add_uint64(m_minisketch.get(), element);\n+        return *this;\n+    }\n+\n+    /** See minisketch_merge(). */\n+    Minisketch& Merge(const Minisketch& sketch) noexcept\n+    {\n+        minisketch_merge(m_minisketch.get(), sketch.m_minisketch.get());\n+        return *this;\n+    }\n+\n+    /** Decode this sketch into the result vector, up to as many elements as the vector's size permits. */\n+    bool Decode(std::vector<uint64_t>& result) const\n+    {\n+        ssize_t ret = minisketch_decode(m_minisketch.get(), result.size(), result.data());\n+        if (ret == -1) return false;\n+        result.resize(ret);\n+        return true;\n+    }\n+\n+    /** See minisketch_serialized_size(). */\n+    size_t GetSerializedSize() const noexcept { return minisketch_serialized_size(m_minisketch.get()); }\n+\n+    /** Serialize the sketch as a byte vector. */\n+    std::vector<unsigned char> Serialize() const\n+    {\n+        std::vector<unsigned char> result(GetSerializedSize());\n+        minisketch_serialize(m_minisketch.get(), result.data());\n+        return result;\n+    }\n+\n+    /** Deserialize into this sketch from an object containing its bytes (which has data() and size() members). */\n+    template<typename T>\n+    Minisketch& Deserialize(\n+        const T& obj,\n+        typename std::enable_if<\n+            std::is_convertible<typename std::remove_pointer<decltype(obj.data())>::type (*)[], const unsigned char (*)[]>::value &&\n+            std::is_convertible<decltype(obj.size()), std::size_t>::value,\n+            std::nullptr_t\n+        >::type = nullptr) noexcept\n+    {\n+        assert(GetSerializedSize() == obj.size());\n+        minisketch_deserialize(m_minisketch.get(), obj.data());\n+        return *this;\n+    }\n+\n+#if __cplusplus >= 201703L\n+    /** C++17 only: decode up to a specified number of elements into an optional vector. */\n+    std::optional<std::vector<uint64_t>> Decode(size_t max_elements) const\n+    {\n+        std::vector<uint64_t> result(max_elements);\n+        ssize_t ret = minisketch_decode(m_minisketch.get(), max_elements, result.data());\n+        if (ret == -1) return {};\n+        result.resize(ret);\n+        return std::move(result);\n+    }\n+\n+    /** C++17 only: similar to Decode(), but with specified false positive probability. */\n+    std::optional<std::vector<uint64_t>> DecodeFP(uint32_t fpbits) const\n+    {\n+        return Decode(ComputeMaxElements(GetBits(), GetCapacity(), fpbits));\n+    }\n+#endif // __cplusplus >= 201703L\n+};\n+#endif // __cplusplus >= 201103L\n+#endif // __cplusplus\n+\n+#endif  // _MINISKETCH_H_"
      },
      {
        "sha": "ac4ff0db8fc66d405fea79acf41374a59fe4b2bf",
        "filename": "sources.mk",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/sources.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/sources.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sources.mk?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,54 @@\n+# - All variables are namespaced with MINISKETCH_ to avoid colliding with\n+#     downstream makefiles.\n+# - All Variables ending in _HEADERS or _SOURCES confuse automake, so the\n+#     _INT postfix is applied.\n+# - Convenience variables, for example a MINISKETCH_FIELDS_DIR should not be used\n+#     as they interfere with automatic dependency generation\n+# - The %reldir% is the relative path from the Makefile.am. This allows\n+#   downstreams to use these variables without having to manually account for\n+#   the path change.\n+\n+MINISKETCH_DIST_HEADERS_INT =\n+MINISKETCH_DIST_HEADERS_INT += %reldir%/include/minisketch.h\n+\n+MINISKETCH_LIB_HEADERS_INT =\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/int_utils.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/lintrans.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/sketch.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/sketch_impl.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/util.h\n+\n+MINISKETCH_LIB_SOURCES_INT =\n+MINISKETCH_LIB_SOURCES_INT += %reldir%/src/minisketch.cpp\n+\n+MINISKETCH_FIELD_GENERIC_HEADERS_INT =\n+MINISKETCH_FIELD_GENERIC_HEADERS_INT += %reldir%/src/fields/generic_common_impl.h\n+\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT =\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_1byte.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_2bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_3bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_4bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_5bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_6bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_7bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_8bytes.cpp\n+\n+MINISKETCH_FIELD_CLMUL_HEADERS_INT =\n+MINISKETCH_FIELD_CLMUL_HEADERS_INT += %reldir%/src/fields/clmul_common_impl.h\n+\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT =\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_1byte.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_2bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_3bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_4bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_5bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_6bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_7bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_8bytes.cpp\n+\n+MINISKETCH_BENCH_SOURCES_INT =\n+MINISKETCH_BENCH_SOURCES_INT += %reldir%/src/bench.cpp\n+\n+MINISKETCH_TEST_SOURCES_INT =\n+MINISKETCH_TEST_SOURCES_INT += %reldir%/src/test-exhaust.cpp"
      },
      {
        "sha": "f55944a448a41c074b6809e0a99bfd6e629bbf87",
        "filename": "src/bench.cpp",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,122 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <chrono>\n+#include <random>\n+#include <set>\n+#include <algorithm>\n+\n+int main(int argc, char** argv) {\n+    if (argc < 1 || argc > 4) {\n+        printf(\"Usage: %s [syndromes=150] [errors=syndromes] [iters=10]\\n\", argv[0]);\n+        return 1;\n+    }\n+    int syndromes = argc > 1 ? strtoul(argv[1], NULL, 10) : 150;\n+    int errors = argc > 2 ? strtoul(argv[2], NULL, 10) : syndromes;\n+    int iters = argc > 3 ? strtoul(argv[3], NULL, 10) : 10;\n+    if (syndromes < 0 || syndromes > 1000000) {\n+        printf(\"Number of syndromes (%i) out of range 0..1000000\\n\", syndromes);\n+        return 1;\n+    }\n+    if (errors < 0) {\n+        printf(\"Number of errors (%i) is negative(%i)\\n\", errors, syndromes);\n+        return 1;\n+    }\n+    if (iters < 0 || iters > 1000000000) {\n+        printf(\"Number of iterations (%i) out of range 0..1000000000\\n\", iters);\n+        return 1;\n+    }\n+    uint32_t max_impl = minisketch_implementation_max();\n+    for (int bits = 2; bits <= 64; ++bits) {\n+        if (errors > pow(2.0, bits - 1)) continue;\n+        if (!minisketch_bits_supported(bits)) continue;\n+        printf(\"recover[ms]\\t% 3i\\t\", bits);\n+        for (uint32_t impl = 0; impl <= max_impl; ++impl) {\n+            std::vector<minisketch*> states;\n+            std::vector<uint64_t> roots(2 * syndromes);\n+            std::random_device rng;\n+            std::uniform_int_distribution<uint64_t> dist(1, (uint64_t(1) << bits) - 1);\n+            states.resize(iters);\n+            std::vector<double> benches;\n+            benches.reserve(iters);\n+            for (int i = 0; i < iters; ++i) {\n+                states[i] = minisketch_create(bits, impl, syndromes);\n+                if (!states[i]) break;\n+                std::set<uint64_t> done;\n+                for (int j = 0; j < errors; ++j) {\n+                    uint64_t r;\n+                    do {\n+                        r = dist(rng);\n+                    } while (done.count(r));\n+                    done.insert(r);\n+                    minisketch_add_uint64(states[i], r);\n+                }\n+            }\n+            if (!states[0]) {\n+                printf(\"         -\\t\");\n+            } else {\n+                double total = 0.0;\n+                for (auto& state : states) {\n+                    auto start = std::chrono::steady_clock::now();\n+                    minisketch_decode(state, 2 * syndromes, roots.data());\n+                    auto stop = std::chrono::steady_clock::now();\n+                    std::chrono::duration<double> dur(stop - start);\n+                    total += dur.count();\n+                    benches.push_back(dur.count());\n+                }\n+                std::sort(benches.begin(), benches.end());\n+                printf(\"% 10.5f\\t\", benches[0] * 1000.0);\n+            }\n+            for (auto& state : states) {\n+                minisketch_destroy(state);\n+            }\n+        }\n+        printf(\"\\n\");\n+        printf(\"create[ns]\\t% 3i\\t\", bits);\n+        for (uint32_t impl = 0; impl <= max_impl; ++impl) {\n+            std::vector<minisketch*> states;\n+            std::random_device rng;\n+            std::uniform_int_distribution<uint64_t> dist;\n+            std::vector<uint64_t> data;\n+            data.resize(errors * 10);\n+            states.resize(iters);\n+            std::vector<double> benches;\n+            benches.reserve(iters);\n+            for (int i = 0; i < iters; ++i) {\n+                states[i] = minisketch_create(bits, impl, syndromes);\n+            }\n+            for (size_t i = 0; i < data.size(); ++i) {\n+                data[i] = dist(rng);\n+            }\n+            if (!states[0]) {\n+                printf(\"         -\\t\");\n+            } else {\n+                double total = 0.0;\n+                for (auto& state : states) {\n+                    auto start = std::chrono::steady_clock::now();\n+                    for (auto val : data) {\n+                        minisketch_add_uint64(state, val);\n+                    }\n+                    auto stop = std::chrono::steady_clock::now();\n+                    std::chrono::duration<double> dur(stop - start);\n+                    total += dur.count();\n+                    benches.push_back(dur.count());\n+                }\n+                std::sort(benches.begin(), benches.end());\n+                printf(\"% 10.5f\\t\", benches[0] * 1000000000.0 / data.size() / syndromes);\n+            }\n+            for (auto& state : states) {\n+                minisketch_destroy(state);\n+            }\n+        }\n+        printf(\"\\n\");\n+    }\n+    return 0;\n+}"
      },
      {
        "sha": "44ebb3e94c3f152c56c05770a02a722012fe5306",
        "filename": "src/false_positives.h",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/false_positives.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/false_positives.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/false_positives.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,110 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FALSE_POSITIVES_H_\n+#define _MINISKETCH_FALSE_POSITIVES_H_\n+\n+#include \"util.h\"\n+\n+#include \"int_utils.h\"\n+\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** Compute floor(log2(x!)), exactly up to x=57; an underestimate up to x=2^32-1. */\n+uint64_t Log2Factorial(uint32_t x) {\n+    //! Values of floor(106*log2(1 + i/32)) for i=0..31\n+    static constexpr uint8_t T[32] = {\n+        0, 4, 9, 13, 18, 22, 26, 30, 34, 37, 41, 45, 48, 52, 55, 58, 62, 65, 68,\n+        71, 74, 77, 80, 82, 85, 88, 90, 93, 96, 98, 101, 103\n+    };\n+    int bits = CountBits(x, 32);\n+    // Compute an (under)estimate of floor(106*log2(x)).\n+    // This works by relying on floor(log2(x)) = countbits(x)-1, and adding\n+    // precision using the top 6 bits of x (the highest one of which is always\n+    // one).\n+    unsigned l2_106 = 106 * (bits - 1) + T[((x << (32 - bits)) >> 26) & 31];\n+    // Based on Stirling approximation for log2(x!):\n+    //   log2(x!) = log(x!) / log(2)\n+    //            = ((x + 1/2) * log(x) - x + log(2*pi)/2 + ...) / log(2)\n+    //            = (x + 1/2) * log2(x) - x/log(2) + log2(2*pi)/2 + ...\n+    //            = 1/2*(2*x+1)*log2(x) - (1/log(2))*x + log2(2*pi)/2 + ...\n+    //            = 1/212*(2*x+1)*(106*log2(x)) + (-1/log(2))*x + log2(2*pi)/2 + ...\n+    // where 418079/88632748 is exactly 1/212\n+    //       -127870026/88632748 is slightly less than -1/log(2)\n+    //       117504694/88632748 is less than log2(2*pi)/2\n+    // A correction term is only needed for x < 3.\n+    //\n+    // See doc/log2_factorial.sage for how these constants were obtained.\n+    return (418079 * (2 * uint64_t{x} + 1) * l2_106 - 127870026 * uint64_t{x} + 117504694 + 88632748 * (x < 3)) / 88632748;\n+}\n+\n+/** Compute floor(log2(2^(bits * capacity) / sum((2^bits - 1) choose k, k=0..capacity))), for bits>1\n+ *\n+ * See doc/gen_basefpbits.sage for how the tables were obtained. */\n+uint64_t BaseFPBits(uint32_t bits, uint32_t capacity) {\n+    // Correction table for low bits/capacities\n+    static constexpr uint8_t ADD5[] = {1, 1, 1, 1, 2, 2, 2, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12};\n+    static constexpr uint8_t ADD6[] = {1, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 8, 8, 10, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 23, 24, 24, 24, 24};\n+    static constexpr uint8_t ADD7[] = {1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 7, 8, 9, 9, 9, 10, 11, 11, 12, 12, 13, 13, 15, 15, 15, 16, 17, 17, 18, 19, 20, 20};\n+    static constexpr uint8_t ADD8[] = {1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 3, 4, 4, 5, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 9, 9};\n+    static constexpr uint8_t ADD9[] = {1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 3, 4, 3, 3, 4, 4, 4, 4};\n+\n+    if (capacity == 0) return 0;\n+    uint64_t ret = 0;\n+    if (bits < 32 && capacity >= (1U << bits)) {\n+        ret = uint64_t{bits} * (capacity - (1U << bits) + 1);\n+        capacity = (1U << bits) - 1;\n+    }\n+    ret += Log2Factorial(capacity);\n+    switch (bits) {\n+        case 2: return ret + (capacity <= 2 ? 0 : 1);\n+        case 3: return ret + (capacity <= 2 ? 0 : (0x2a5 >> 2 * (capacity - 3)) & 3);\n+        case 4: return ret + (capacity <= 3 ? 0 : (0xb6d91a449 >> 3 * (capacity - 4)) & 7);\n+        case 5: return ret + (capacity <= 4 ? 0 : ADD5[capacity - 5]);\n+        case 6: return ret + (capacity <= 4 ? 0 : capacity > 54 ? 25 : ADD6[capacity - 5]);\n+        case 7: return ret + (capacity <= 4 ? 0 : capacity > 57 ? 21 : ADD7[capacity - 5]);\n+        case 8: return ret + (capacity <= 9 ? 0 : capacity > 56 ? 10 : ADD8[capacity - 10]);\n+        case 9: return ret + (capacity <= 11 ? 0 : capacity > 54 ? 5 : ADD9[capacity - 12]);\n+        case 10: return ret + (capacity <= 21 ? 0 : capacity > 50 ? 2 : (0x1a6665545555041 >> 2 * (capacity - 22)) & 3);\n+        case 11: return ret + (capacity <= 21 ? 0 : capacity > 45 ? 1 : (0x5b3dc1 >> (capacity - 22)) & 1);\n+        case 12: return ret + (capacity <= 21 ? 0 : capacity > 57 ? 0 : (0xe65522041 >> (capacity - 22)) & 1);\n+        case 13: return ret + (capacity <= 27 ? 0 : capacity > 55 ? 0 : (0x8904081 >> (capacity - 28)) & 1);\n+        case 14: return ret + (capacity <= 47 ? 0 : capacity > 48 ? 0 : 1);\n+        default: return ret;\n+    }\n+}\n+\n+size_t ComputeCapacity(uint32_t bits, size_t max_elements, uint32_t fpbits) {\n+    if (bits == 0) return 0;\n+    uint64_t base_fpbits = BaseFPBits(bits, max_elements);\n+    // The fpbits provided by the base max_elements==capacity case are sufficient.\n+    if (base_fpbits >= fpbits) return max_elements;\n+    // Otherwise, increment capacity by ceil(fpbits / bits) beyond that.\n+    return max_elements + (fpbits - base_fpbits + bits - 1) / bits;\n+}\n+\n+size_t ComputeMaxElements(uint32_t bits, size_t capacity, uint32_t fpbits) {\n+    if (bits == 0) return 0;\n+    // Start with max_elements=capacity, and decrease max_elements until the corresponding capacity is capacity.\n+    size_t max_elements = capacity;\n+    while (true) {\n+        size_t capacity_for_max_elements = ComputeCapacity(bits, max_elements, fpbits);\n+        CHECK_SAFE(capacity_for_max_elements >= capacity);\n+        if (capacity_for_max_elements <= capacity) return max_elements;\n+        size_t adjust = capacity_for_max_elements - capacity;\n+        // Decrementing max_elements by N will at most decrement the corresponding capacity by N.\n+        // As the observed capacity is adjust too high, we can safely decrease max_elements by adjust.\n+        // If that brings us into negative max_elements territory, no solution exists and we return 0.\n+        if (max_elements < adjust) return 0;\n+        max_elements -= adjust;\n+    }\n+}\n+\n+}  // namespace\n+\n+#endif"
      },
      {
        "sha": "5fe60f7f5a434125e53c8a37270486ee1cb92a5f",
        "filename": "src/fields/clmul_1byte.cpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_1byte.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_1byte.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_1byte.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,87 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 2 bit field\n+typedef RecLinTrans<uint8_t, 2> StatTableTRI2;\n+constexpr StatTableTRI2 SQR_TABLE_TRI2({0x1, 0x3});\n+constexpr StatTableTRI2 QRT_TABLE_TRI2({0x2, 0});\n+typedef FieldTri<uint8_t, 2, 1, StatTableTRI2, &SQR_TABLE_TRI2, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI2, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri2;\n+\n+// 3 bit field\n+typedef RecLinTrans<uint8_t, 3> StatTableTRI3;\n+constexpr StatTableTRI3 SQR_TABLE_TRI3({0x1, 0x4, 0x6});\n+constexpr StatTableTRI3 QRT_TABLE_TRI3({0, 0x4, 0x6});\n+typedef FieldTri<uint8_t, 3, 1, StatTableTRI3, &SQR_TABLE_TRI3, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI3, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri3;\n+\n+// 4 bit field\n+typedef RecLinTrans<uint8_t, 4> StatTableTRI4;\n+constexpr StatTableTRI4 SQR_TABLE_TRI4({0x1, 0x4, 0x3, 0xc});\n+constexpr StatTableTRI4 QRT_TABLE_TRI4({0x6, 0xa, 0x8, 0});\n+typedef FieldTri<uint8_t, 4, 1, StatTableTRI4, &SQR_TABLE_TRI4, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI4, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri4;\n+\n+// 5 bit field\n+typedef RecLinTrans<uint8_t, 5> StatTable5;\n+constexpr StatTable5 SQR_TABLE_5({0x1, 0x4, 0x10, 0xa, 0xd});\n+constexpr StatTable5 SQR2_TABLE_5({0x1, 0x10, 0xd, 0xe, 0x1b});\n+constexpr StatTable5 QRT_TABLE_5({0x14, 0x8, 0xa, 0, 0xe});\n+typedef Field<uint8_t, 5, 5, StatTable5, &SQR_TABLE_5, &SQR2_TABLE_5, nullptr, nullptr, nullptr, &QRT_TABLE_5, IdTrans, &ID_TRANS, &ID_TRANS> Field5;\n+typedef FieldTri<uint8_t, 5, 2, RecLinTrans<uint8_t, 5>, &SQR_TABLE_5, &SQR2_TABLE_5, nullptr, nullptr, nullptr, &QRT_TABLE_5, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri5;\n+\n+// 6 bit field\n+typedef RecLinTrans<uint8_t, 6> StatTableTRI6;\n+constexpr StatTableTRI6 SQR_TABLE_TRI6({0x1, 0x4, 0x10, 0x3, 0xc, 0x30});\n+constexpr StatTableTRI6 SQR2_TABLE_TRI6({0x1, 0x10, 0xc, 0x5, 0x13, 0x3c});\n+constexpr StatTableTRI6 QRT_TABLE_TRI6({0x3a, 0x26, 0x24, 0x14, 0x20, 0});\n+typedef FieldTri<uint8_t, 6, 1, StatTableTRI6, &SQR_TABLE_TRI6, &SQR2_TABLE_TRI6, nullptr, nullptr, nullptr, &QRT_TABLE_TRI6, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri6;\n+\n+// 7 bit field\n+typedef RecLinTrans<uint8_t, 4, 3> StatTableTRI7;\n+constexpr StatTableTRI7 SQR_TABLE_TRI7({0x1, 0x4, 0x10, 0x40, 0x6, 0x18, 0x60});\n+constexpr StatTableTRI7 SQR2_TABLE_TRI7({0x1, 0x10, 0x6, 0x60, 0x14, 0x46, 0x78});\n+constexpr StatTableTRI7 QRT_TABLE_TRI7({0, 0x14, 0x16, 0x72, 0x12, 0x40, 0x7a});\n+typedef FieldTri<uint8_t, 7, 1, StatTableTRI7, &SQR_TABLE_TRI7, &SQR2_TABLE_TRI7, nullptr, nullptr, nullptr, &QRT_TABLE_TRI7, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri7;\n+\n+// 8 bit field\n+typedef RecLinTrans<uint8_t, 4, 4> StatTable8;\n+constexpr StatTable8 SQR_TABLE_8({0x1, 0x4, 0x10, 0x40, 0x1b, 0x6c, 0xab, 0x9a});\n+constexpr StatTable8 SQR2_TABLE_8({0x1, 0x10, 0x1b, 0xab, 0x5e, 0x97, 0xb3, 0xc5});\n+constexpr StatTable8 QRT_TABLE_8({0xbc, 0x2a, 0x28, 0x86, 0x2c, 0xde, 0x8e, 0});\n+typedef Field<uint8_t, 8, 27, StatTable8, &SQR_TABLE_8, &SQR2_TABLE_8, nullptr, nullptr, nullptr, &QRT_TABLE_8, IdTrans, &ID_TRANS, &ID_TRANS> Field8;\n+\n+}\n+\n+Sketch* ConstructClMul1Byte(int bits, int implementation) {\n+    switch (bits) {\n+    case 5: return new SketchImpl<Field5>(implementation, 5);\n+    case 8: return new SketchImpl<Field8>(implementation, 8);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri1Byte(int bits, int implementation) {\n+    switch (bits) {\n+    case 2: return new SketchImpl<FieldTri2>(implementation, 2);\n+    case 3: return new SketchImpl<FieldTri3>(implementation, 3);\n+    case 4: return new SketchImpl<FieldTri4>(implementation, 4);\n+    case 5: return new SketchImpl<FieldTri5>(implementation, 5);\n+    case 6: return new SketchImpl<FieldTri6>(implementation, 6);\n+    case 7: return new SketchImpl<FieldTri7>(implementation, 7);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "4329c221a1d6a215a466c9723dabf918736ef183",
        "filename": "src/fields/clmul_2bytes.cpp",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_2bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_2bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_2bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,112 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 9 bit field\n+typedef RecLinTrans<uint16_t, 5, 4> StatTableTRI9;\n+constexpr StatTableTRI9 SQR_TABLE_TRI9({0x1, 0x4, 0x10, 0x40, 0x100, 0x6, 0x18, 0x60, 0x180});\n+constexpr StatTableTRI9 SQR2_TABLE_TRI9({0x1, 0x10, 0x100, 0x18, 0x180, 0x14, 0x140, 0x1e, 0x1e0});\n+constexpr StatTableTRI9 SQR4_TABLE_TRI9({0x1, 0x180, 0x1e0, 0x198, 0x1fe, 0x80, 0xa0, 0x88, 0xaa});\n+constexpr StatTableTRI9 QRT_TABLE_TRI9({0, 0x4e, 0x4c, 0x1aa, 0x48, 0x22, 0x1a2, 0x100, 0x58});\n+typedef FieldTri<uint16_t, 9, 1, StatTableTRI9, &SQR_TABLE_TRI9, &SQR2_TABLE_TRI9, &SQR4_TABLE_TRI9, nullptr, nullptr, &QRT_TABLE_TRI9, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri9;\n+\n+// 10 bit field\n+typedef RecLinTrans<uint16_t, 5, 5> StatTable10;\n+constexpr StatTable10 SQR_TABLE_10({0x1, 0x4, 0x10, 0x40, 0x100, 0x9, 0x24, 0x90, 0x240, 0x112});\n+constexpr StatTable10 SQR2_TABLE_10({0x1, 0x10, 0x100, 0x24, 0x240, 0x41, 0x19, 0x190, 0x136, 0x344});\n+constexpr StatTable10 SQR4_TABLE_10({0x1, 0x240, 0x136, 0x141, 0x35d, 0x18, 0x265, 0x2e6, 0x227, 0x36b});\n+constexpr StatTable10 QRT_TABLE_10({0xec, 0x86, 0x84, 0x30e, 0x80, 0x3c2, 0x306, 0, 0x90, 0x296});\n+typedef Field<uint16_t, 10, 9, StatTable10, &SQR_TABLE_10, &SQR2_TABLE_10, &SQR4_TABLE_10, nullptr, nullptr, &QRT_TABLE_10, IdTrans, &ID_TRANS, &ID_TRANS> Field10;\n+typedef FieldTri<uint16_t, 10, 3, RecLinTrans<uint16_t, 5, 5>, &SQR_TABLE_10, &SQR2_TABLE_10, &SQR4_TABLE_10, nullptr, nullptr, &QRT_TABLE_10, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri10;\n+\n+// 11 bit field\n+typedef RecLinTrans<uint16_t, 6, 5> StatTable11;\n+constexpr StatTable11 SQR_TABLE_11({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0xa, 0x28, 0xa0, 0x280, 0x205});\n+constexpr StatTable11 SQR2_TABLE_11({0x1, 0x10, 0x100, 0xa, 0xa0, 0x205, 0x44, 0x440, 0x428, 0x2a8, 0x291});\n+constexpr StatTable11 SQR4_TABLE_11({0x1, 0xa0, 0x428, 0x1a, 0x645, 0x3a9, 0x144, 0x2d5, 0x9e, 0x4e7, 0x649});\n+constexpr StatTable11 QRT_TABLE_11({0x734, 0x48, 0x4a, 0x1de, 0x4e, 0x35e, 0x1d6, 0x200, 0x5e, 0, 0x37e});\n+typedef Field<uint16_t, 11, 5, StatTable11, &SQR_TABLE_11, &SQR2_TABLE_11, &SQR4_TABLE_11, nullptr, nullptr, &QRT_TABLE_11, IdTrans, &ID_TRANS, &ID_TRANS> Field11;\n+typedef FieldTri<uint16_t, 11, 2, RecLinTrans<uint16_t, 6, 5>, &SQR_TABLE_11, &SQR2_TABLE_11, &SQR4_TABLE_11, nullptr, nullptr, &QRT_TABLE_11, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri11;\n+\n+// 12 bit field\n+typedef RecLinTrans<uint16_t, 6, 6> StatTable12;\n+constexpr StatTable12 SQR_TABLE_12({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x9, 0x24, 0x90, 0x240, 0x900, 0x412});\n+constexpr StatTable12 SQR2_TABLE_12({0x1, 0x10, 0x100, 0x9, 0x90, 0x900, 0x41, 0x410, 0x124, 0x249, 0x482, 0x804});\n+constexpr StatTable12 SQR4_TABLE_12({0x1, 0x90, 0x124, 0x8, 0x480, 0x920, 0x40, 0x412, 0x924, 0x200, 0x82, 0x904});\n+constexpr StatTable12 QRT_TABLE_12({0x48, 0xc10, 0xc12, 0x208, 0xc16, 0xd82, 0x200, 0x110, 0xc06, 0, 0xda2, 0x5a4});\n+typedef Field<uint16_t, 12, 9, StatTable12, &SQR_TABLE_12, &SQR2_TABLE_12, &SQR4_TABLE_12, nullptr, nullptr, &QRT_TABLE_12, IdTrans, &ID_TRANS, &ID_TRANS> Field12;\n+typedef FieldTri<uint16_t, 12, 3, RecLinTrans<uint16_t, 6, 6>, &SQR_TABLE_12, &SQR2_TABLE_12, &SQR4_TABLE_12, nullptr, nullptr, &QRT_TABLE_12, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri12;\n+\n+// 13 bit field\n+typedef RecLinTrans<uint16_t, 5, 4, 4> StatTable13;\n+constexpr StatTable13 SQR_TABLE_13({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x36, 0xd8, 0x360, 0xd80, 0x161b, 0x185a});\n+constexpr StatTable13 SQR2_TABLE_13({0x1, 0x10, 0x100, 0x1000, 0xd8, 0xd80, 0x185a, 0x514, 0x1176, 0x17b8, 0x1b75, 0x17ff, 0x1f05});\n+constexpr StatTable13 SQR4_TABLE_13({0x1, 0xd8, 0x1176, 0x1f05, 0xd96, 0x18e8, 0x68, 0xbdb, 0x1a61, 0x1af2, 0x1a37, 0x3b9, 0x1440});\n+constexpr StatTable13 QRT_TABLE_13({0xcfc, 0x1500, 0x1502, 0x382, 0x1506, 0x149c, 0x38a, 0x118, 0x1516, 0, 0x14bc, 0x100e, 0x3ca});\n+typedef Field<uint16_t, 13, 27, StatTable13, &SQR_TABLE_13, &SQR2_TABLE_13, &SQR4_TABLE_13, nullptr, nullptr, &QRT_TABLE_13, IdTrans, &ID_TRANS, &ID_TRANS> Field13;\n+\n+// 14 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 4> StatTable14;\n+constexpr StatTable14 SQR_TABLE_14({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x442, 0x1108});\n+constexpr StatTable14 SQR2_TABLE_14({0x1, 0x10, 0x100, 0x1000, 0x84, 0x840, 0x442, 0x401, 0x31, 0x310, 0x3100, 0x118c, 0x1844, 0x486});\n+constexpr StatTable14 SQR4_TABLE_14({0x1, 0x84, 0x31, 0x1844, 0x501, 0x15ce, 0x3552, 0x3101, 0x8c5, 0x3a5, 0x1cf3, 0xd74, 0xc8a, 0x3411});\n+constexpr StatTable14 QRT_TABLE_14({0x13f2, 0x206, 0x204, 0x3e06, 0x200, 0x1266, 0x3e0e, 0x114, 0x210, 0, 0x1246, 0x2848, 0x3e4e, 0x2258});\n+typedef Field<uint16_t, 14, 33, StatTable14, &SQR_TABLE_14, &SQR2_TABLE_14, &SQR4_TABLE_14, nullptr, nullptr, &QRT_TABLE_14, IdTrans, &ID_TRANS, &ID_TRANS> Field14;\n+typedef FieldTri<uint16_t, 14, 5, RecLinTrans<uint16_t, 5, 5, 4>, &SQR_TABLE_14, &SQR2_TABLE_14, &SQR4_TABLE_14, nullptr, nullptr, &QRT_TABLE_14, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri14;\n+\n+// 15 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 5> StatTableTRI15;\n+constexpr StatTableTRI15 SQR_TABLE_TRI15({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000});\n+constexpr StatTableTRI15 SQR2_TABLE_TRI15({0x1, 0x10, 0x100, 0x1000, 0x6, 0x60, 0x600, 0x6000, 0x14, 0x140, 0x1400, 0x4006, 0x78, 0x780, 0x7800});\n+constexpr StatTableTRI15 SQR4_TABLE_TRI15({0x1, 0x6, 0x14, 0x78, 0x110, 0x660, 0x1540, 0x7f80, 0x106, 0x614, 0x1478, 0x7910, 0x1666, 0x7554, 0x3ffe});\n+constexpr StatTableTRI15 QRT_TABLE_TRI15({0, 0x114, 0x116, 0x428, 0x112, 0x137a, 0x420, 0x6d62, 0x102, 0x73a, 0x135a, 0x6460, 0x460, 0x4000, 0x6de2});\n+typedef FieldTri<uint16_t, 15, 1, StatTableTRI15, &SQR_TABLE_TRI15, &SQR2_TABLE_TRI15, &SQR4_TABLE_TRI15, nullptr, nullptr, &QRT_TABLE_TRI15, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri15;\n+\n+// 16 bit field\n+typedef RecLinTrans<uint16_t, 6, 5, 5> StatTable16;\n+constexpr StatTable16 SQR_TABLE_16({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x2b, 0xac, 0x2b0, 0xac0, 0x2b00, 0xac00, 0xb056, 0xc10e});\n+constexpr StatTable16 SQR2_TABLE_16({0x1, 0x10, 0x100, 0x1000, 0x2b, 0x2b0, 0x2b00, 0xb056, 0x445, 0x4450, 0x45ac, 0x5a6c, 0xa647, 0x657e, 0x571a, 0x7127});\n+constexpr StatTable16 SQR4_TABLE_16({0x1, 0x2b, 0x445, 0xa647, 0x12a1, 0xf69d, 0x7f07, 0x9825, 0x6fad, 0x399d, 0xb515, 0xd7d1, 0x3fb4, 0x4b06, 0xe4df, 0x93c7});\n+constexpr StatTable16 QRT_TABLE_16({0x732, 0x72b8, 0x72ba, 0x7e96, 0x72be, 0x78b2, 0x7e9e, 0x8cba, 0x72ae, 0xfa24, 0x7892, 0x5892, 0x7ede, 0xbec6, 0x8c3a, 0});\n+typedef Field<uint16_t, 16, 43, StatTable16, &SQR_TABLE_16, &SQR2_TABLE_16, &SQR4_TABLE_16, nullptr, nullptr, &QRT_TABLE_16, IdTrans, &ID_TRANS, &ID_TRANS> Field16;\n+\n+}\n+\n+Sketch* ConstructClMul2Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 10: return new SketchImpl<Field10>(implementation, 10);\n+    case 11: return new SketchImpl<Field11>(implementation, 11);\n+    case 12: return new SketchImpl<Field12>(implementation, 12);\n+    case 13: return new SketchImpl<Field13>(implementation, 13);\n+    case 14: return new SketchImpl<Field14>(implementation, 14);\n+    case 16: return new SketchImpl<Field16>(implementation, 16);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri2Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 9: return new SketchImpl<FieldTri9>(implementation, 9);\n+    case 10: return new SketchImpl<FieldTri10>(implementation, 10);\n+    case 11: return new SketchImpl<FieldTri11>(implementation, 11);\n+    case 12: return new SketchImpl<FieldTri12>(implementation, 12);\n+    case 14: return new SketchImpl<FieldTri14>(implementation, 14);\n+    case 15: return new SketchImpl<FieldTri15>(implementation, 15);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "23d29f7b50084d043ab1d557a8c9a7c5ab0982f2",
        "filename": "src/fields/clmul_3bytes.cpp",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_3bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_3bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_3bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,122 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 17 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5> StatTable17;\n+constexpr StatTable17 SQR_TABLE_17({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x8012});\n+constexpr StatTable17 SQR2_TABLE_17({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x48, 0x480, 0x4800, 0x8012, 0x104, 0x1040, 0x10400, 0x4048, 0x492, 0x4920, 0x9212, 0x12104});\n+constexpr StatTable17 SQR4_TABLE_17({0x1, 0x10000, 0x8012, 0x4048, 0x12104, 0x1480, 0x5840, 0x14d20, 0x19202, 0x8112, 0x44c8, 0x13144, 0x5da0, 0x15850, 0x1cd7a, 0x1d34e, 0x1a484});\n+constexpr StatTable17 SQR8_TABLE_17({0x1, 0x1a484, 0x1f24a, 0x1d572, 0x1eec4, 0x15448, 0xf9de, 0x9af0, 0x1ab78, 0x6048, 0xdc9a, 0x1eb24, 0x2ef4, 0x7c5e, 0x170b2, 0x16c1a, 0xa660});\n+constexpr StatTable17 QRT_TABLE_17({0, 0x4c3e, 0x4c3c, 0x1a248, 0x4c38, 0x428, 0x1a240, 0x1b608, 0x4c28, 0x206, 0x408, 0x4000, 0x1a200, 0x18006, 0x1b688, 0x14d2e, 0x4d28});\n+typedef Field<uint32_t, 17, 9, StatTable17, &SQR_TABLE_17, &SQR2_TABLE_17, &SQR4_TABLE_17, &SQR8_TABLE_17, nullptr, &QRT_TABLE_17, IdTrans, &ID_TRANS, &ID_TRANS> Field17;\n+typedef FieldTri<uint32_t, 17, 3, RecLinTrans<uint32_t, 6, 6, 5>, &SQR_TABLE_17, &SQR2_TABLE_17, &SQR4_TABLE_17, &SQR8_TABLE_17, nullptr, &QRT_TABLE_17, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri17;\n+\n+// 18 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6> StatTable18;\n+constexpr StatTable18 SQR_TABLE_18({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x10012});\n+constexpr StatTable18 SQR2_TABLE_18({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x24, 0x240, 0x2400, 0x24000, 0x41, 0x410, 0x4100, 0x1009, 0x10090, 0x924, 0x9240, 0x12412, 0x24104});\n+constexpr StatTable18 SQR4_TABLE_18({0x1, 0x10000, 0x24000, 0x1009, 0x12412, 0x124, 0x201, 0x10480, 0x24820, 0x241, 0x10410, 0x24924, 0x8, 0x12, 0x20024, 0x8048, 0x12082, 0x920});\n+constexpr StatTable18 SQR8_TABLE_18({0x1, 0x12082, 0x20904, 0x1000, 0x92, 0x904, 0x240, 0x12012, 0x4104, 0x41, 0x10080, 0x4924, 0x1009, 0x2412, 0x24804, 0x9240, 0x12410, 0x20});\n+constexpr StatTable18 QRT_TABLE_18({0x9208, 0x422, 0x420, 0x8048, 0x424, 0x68b0, 0x8040, 0x30086, 0x434, 0x1040, 0x6890, 0x30ca2, 0x8000, 0x32896, 0x30006, 0, 0x534, 0x20532});\n+typedef Field<uint32_t, 18, 9, StatTable18, &SQR_TABLE_18, &SQR2_TABLE_18, &SQR4_TABLE_18, &SQR8_TABLE_18, nullptr, &QRT_TABLE_18, IdTrans, &ID_TRANS, &ID_TRANS> Field18;\n+typedef FieldTri<uint32_t, 18, 3, RecLinTrans<uint32_t, 6, 6, 6>, &SQR_TABLE_18, &SQR2_TABLE_18, &SQR4_TABLE_18, &SQR8_TABLE_18, nullptr, &QRT_TABLE_18, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri18;\n+\n+// 19 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 4> StatTable19;\n+constexpr StatTable19 SQR_TABLE_19({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x3804e, 0x6011f});\n+constexpr StatTable19 SQR2_TABLE_19({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x4e, 0x4e0, 0x4e00, 0x4e000, 0x6011f, 0x1054, 0x10540, 0x544e, 0x544e0, 0x44f76, 0x4f658, 0x7649f, 0x6481a, 0x48004});\n+constexpr StatTable19 SQR4_TABLE_19({0x1, 0x10000, 0x4e000, 0x544e, 0x7649f, 0x15f0, 0x5afa, 0x35b7d, 0x17dca, 0x7390f, 0x151ae, 0x3902b, 0x41e9c, 0x7f117, 0x23ec7, 0x62c2f, 0x5e852, 0x69238, 0x775c});\n+constexpr StatTable19 SQR8_TABLE_19({0x1, 0x5e852, 0x394a3, 0x29f41, 0x618e5, 0x4210, 0x7add9, 0x31105, 0x5d098, 0x7bb13, 0x44f00, 0x966, 0x11ae6, 0x70901, 0x664bf, 0x67449, 0x3d2bf, 0x4cbf9, 0x54e0c});\n+constexpr StatTable19 QRT_TABLE_19({0x5d6b0, 0x2f476, 0x2f474, 0x1d6a2, 0x2f470, 0x42a, 0x1d6aa, 0x1060, 0x2f460, 0x19e92, 0x40a, 0x1da98, 0x1d6ea, 0x28c78, 0x10e0, 0xf56a, 0x2f560, 0, 0x19c92});\n+typedef Field<uint32_t, 19, 39, StatTable19, &SQR_TABLE_19, &SQR2_TABLE_19, &SQR4_TABLE_19, &SQR8_TABLE_19, nullptr, &QRT_TABLE_19, IdTrans, &ID_TRANS, &ID_TRANS> Field19;\n+\n+// 20 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5> StatTable20;\n+constexpr StatTable20 SQR_TABLE_20({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x40012});\n+constexpr StatTable20 SQR2_TABLE_20({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x9, 0x90, 0x900, 0x9000, 0x90000, 0x41, 0x410, 0x4100, 0x41000, 0x10024, 0x249, 0x2490, 0x24900, 0x49012, 0x90104});\n+constexpr StatTable20 SQR4_TABLE_20({0x1, 0x10000, 0x9000, 0x4100, 0x2490, 0x1001, 0x10900, 0x9410, 0x4349, 0x92594, 0x91, 0x10041, 0x19024, 0x4d112, 0x2599, 0x91091, 0x51941, 0x3dd34, 0x5d34b, 0x9b494});\n+constexpr StatTable20 SQR8_TABLE_20({0x1, 0x51941, 0x880b5, 0x66d0, 0x46103, 0x19025, 0x45a49, 0x8a4b4, 0x80b45, 0x81f9f, 0xb081, 0x41040, 0xd19f5, 0xc11be, 0x4634b, 0xd8d70, 0x11027, 0xf8651, 0x141fa, 0xdc63});\n+constexpr StatTable20 QRT_TABLE_20({0xc5dea, 0xc0110, 0xc0112, 0xe11de, 0xc0116, 0x24814, 0xe11d6, 0x20080, 0xc0106, 0xfe872, 0x24834, 0xe4106, 0xe1196, 0x1d9a4, 0x20000, 0x31190, 0xc0006, 0, 0xfea72, 0x7ea74});\n+typedef Field<uint32_t, 20, 9, StatTable20, &SQR_TABLE_20, &SQR2_TABLE_20, &SQR4_TABLE_20, &SQR8_TABLE_20, nullptr, &QRT_TABLE_20, IdTrans, &ID_TRANS, &ID_TRANS> Field20;\n+typedef FieldTri<uint32_t, 20, 3, RecLinTrans<uint32_t, 5, 5, 5, 5>, &SQR_TABLE_20, &SQR2_TABLE_20, &SQR4_TABLE_20, &SQR8_TABLE_20, nullptr, &QRT_TABLE_20, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri20;\n+\n+// 21 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5> StatTable21;\n+constexpr StatTable21 SQR_TABLE_21({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x80005});\n+constexpr StatTable21 SQR2_TABLE_21({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x28, 0x280, 0x2800, 0x28000, 0x80005, 0x44, 0x440, 0x4400, 0x44000, 0x4000a, 0xaa, 0xaa0, 0xaa00, 0xaa000, 0xa0011});\n+constexpr StatTable21 SQR4_TABLE_21({0x1, 0x10000, 0x2800, 0x440, 0xaa, 0xa0011, 0x101000, 0x28280, 0x4444, 0x40aaa, 0xaa101, 0x128, 0x8002d, 0xc4005, 0x4ea00, 0xba10, 0x101290, 0x1282c4, 0x6c44e, 0xeeeaa, 0xbaaa1});\n+constexpr StatTable21 SQR8_TABLE_21({0x1, 0x101290, 0xc412d, 0x1ab101, 0x986d1, 0x1c6cc5, 0x3aa8c, 0x14b0fe, 0x1e7301, 0xb491d, 0x10d23e, 0xa4015, 0x4c2fa, 0xce8e5, 0xadfd9, 0xf110, 0x5220c, 0xf225f, 0xb8bdb, 0x159467, 0xc0df9});\n+constexpr StatTable21 QRT_TABLE_21({0x1bd5fc, 0xbc196, 0xbc194, 0x74b96, 0xbc190, 0x1048, 0x74b9e, 0x672c8, 0xbc180, 0x4080, 0x1068, 0xc8200, 0x74bde, 0x64280, 0x67248, 0xc4280, 0xbc080, 0x80000, 0x4280, 0, 0x1468});\n+typedef Field<uint32_t, 21, 5, StatTable21, &SQR_TABLE_21, &SQR2_TABLE_21, &SQR4_TABLE_21, &SQR8_TABLE_21, nullptr, &QRT_TABLE_21, IdTrans, &ID_TRANS, &ID_TRANS> Field21;\n+typedef FieldTri<uint32_t, 21, 2, RecLinTrans<uint32_t, 6, 5, 5, 5>, &SQR_TABLE_21, &SQR2_TABLE_21, &SQR4_TABLE_21, &SQR8_TABLE_21, nullptr, &QRT_TABLE_21, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri21;\n+\n+// 22 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5> StatTableTRI22;\n+constexpr StatTableTRI22 SQR_TABLE_TRI22({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000});\n+constexpr StatTableTRI22 SQR2_TABLE_TRI22({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x100003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000});\n+constexpr StatTableTRI22 SQR4_TABLE_TRI22({0x1, 0x10000, 0xc00, 0x50, 0x100003, 0x3c000, 0x1100, 0xcc, 0xc0005, 0x55000, 0x3fc0, 0x101, 0x1000c, 0xc0c00, 0x5050, 0x1003c3, 0x3c011, 0x111100, 0xcccc, 0xc0555, 0x15503f, 0x3fffc0});\n+constexpr StatTableTRI22 SQR8_TABLE_TRI22({0x1, 0x3c011, 0x3ec1, 0x101103, 0x14503e, 0x28282, 0xd0009, 0x1d9c, 0xcc598, 0x25c81, 0x47304, 0xc0004, 0x3cc41, 0xcf758, 0x11415f, 0x1d11f7, 0x128280, 0x1b9027, 0x1070ce, 0x10eb5e, 0x5c0ec, 0x2097e0});\n+constexpr StatTableTRI22 QRT_TABLE_TRI22({0x210d16, 0x104a, 0x1048, 0x4088, 0x104c, 0x200420, 0x4080, 0x492dc, 0x105c, 0x1a67f0, 0x200400, 0x21155c, 0x40c0, 0x20346c, 0x4925c, 0x1af7ac, 0x115c, 0x2274ac, 0x1a65f0, 0x2a65f0, 0x200000, 0});\n+typedef FieldTri<uint32_t, 22, 1, StatTableTRI22, &SQR_TABLE_TRI22, &SQR2_TABLE_TRI22, &SQR4_TABLE_TRI22, &SQR8_TABLE_TRI22, nullptr, &QRT_TABLE_TRI22, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri22;\n+\n+// 23 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5> StatTable23;\n+constexpr StatTable23 SQR_TABLE_23({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x80042, 0x200108});\n+constexpr StatTable23 SQR2_TABLE_23({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x42, 0x420, 0x4200, 0x42000, 0x420000, 0x200108, 0x1004, 0x10040, 0x100400, 0x4042, 0x40420, 0x404200, 0x42108, 0x421080, 0x210908, 0x109004, 0x90002});\n+constexpr StatTable23 SQR4_TABLE_23({0x1, 0x10000, 0x4200, 0x1004, 0x40420, 0x210908, 0x52, 0x520000, 0x142400, 0x52148, 0x494202, 0x10c204, 0x1104, 0x40462, 0x630908, 0x100452, 0x562108, 0x1d2402, 0x57348, 0x495626, 0x34c72c, 0x21584e, 0x4614b0});\n+constexpr StatTable23 SQR8_TABLE_23({0x1, 0x562108, 0x662840, 0x5304, 0x6d3842, 0x738f46, 0x50472, 0x6ff79e, 0x7cf204, 0x436274, 0x3e4bde, 0x42a93e, 0x147704, 0x6c3810, 0x28bff4, 0x78815c, 0x7ab4b0, 0x62852a, 0x255b30, 0x5653d0, 0x1afd36, 0x5f118, 0x601dd4});\n+constexpr StatTable23 QRT_TABLE_23({0, 0x1040, 0x1042, 0x43056, 0x1046, 0x121d76, 0x4305e, 0x40a0, 0x1056, 0x15176, 0x121d56, 0x7ee1f6, 0x4301e, 0x40000, 0x4020, 0x4f0be, 0x1156, 0x7cf0a0, 0x15376, 0x1ee9e8, 0x121956, 0x3ac9f6, 0x7ee9f6});\n+typedef Field<uint32_t, 23, 33, StatTable23, &SQR_TABLE_23, &SQR2_TABLE_23, &SQR4_TABLE_23, &SQR8_TABLE_23, nullptr, &QRT_TABLE_23, IdTrans, &ID_TRANS, &ID_TRANS> Field23;\n+typedef FieldTri<uint32_t, 23, 5, RecLinTrans<uint32_t, 6, 6, 6, 5>, &SQR_TABLE_23, &SQR2_TABLE_23, &SQR4_TABLE_23, &SQR8_TABLE_23, nullptr, &QRT_TABLE_23, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri23;\n+\n+// 24 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6> StatTable24;\n+constexpr StatTable24 SQR_TABLE_24({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0xb0001b, 0xc0005a});\n+constexpr StatTable24 SQR2_TABLE_24({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1b, 0x1b0, 0x1b00, 0x1b000, 0x1b0000, 0xb0001b, 0x145, 0x1450, 0x14500, 0x145000, 0x45001b, 0x5001dc, 0x1db7, 0x1db70, 0x1db700, 0xdb701b, 0xb7011f, 0x701105});\n+constexpr StatTable24 SQR4_TABLE_24({0x1, 0x10000, 0x1b00, 0x145, 0x45001b, 0x1db700, 0x11011, 0x111ab0, 0xb1aa5e, 0x51450e, 0x96db7, 0xb7c60f, 0x1a1a, 0x1a015e, 0x5f5e1b, 0x1ceef2, 0xf30ca2, 0xabbdb4, 0xba1aff, 0xf0bf5e, 0x579fc9, 0xce3da9, 0xa2c07f, 0x71dd40});\n+constexpr StatTable24 SQR8_TABLE_24({0x1, 0xf30ca2, 0x573345, 0xb0a14e, 0xafd77d, 0x1419b, 0xb616a2, 0xba7db, 0xbe1560, 0xe0d0a3, 0x15bf5, 0x1056dd, 0xa29845, 0xf83d32, 0x13e0e9, 0xe2d8d3, 0xa10841, 0x57ac5a, 0x1c432f, 0x57044e, 0x454fba, 0x2bb37c, 0xf50fa, 0x85d5b9});\n+constexpr StatTable24 QRT_TABLE_24({0x104e, 0xaf42a8, 0xaf42aa, 0xb78186, 0xaf42ae, 0x4090, 0xb7818e, 0x4a37c, 0xaf42be, 0x3688c0, 0x40b0, 0x80080e, 0xb781ce, 0xaf2232, 0x4a3fc, 0x856a82, 0xaf43be, 0x29c970, 0x368ac0, 0x968ace, 0x44b0, 0x77d570, 0x80000e, 0});\n+typedef Field<uint32_t, 24, 27, StatTable24, &SQR_TABLE_24, &SQR2_TABLE_24, &SQR4_TABLE_24, &SQR8_TABLE_24, nullptr, &QRT_TABLE_24, IdTrans, &ID_TRANS, &ID_TRANS> Field24;\n+\n+}\n+\n+Sketch* ConstructClMul3Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 17: return new SketchImpl<Field17>(implementation, 17);\n+    case 18: return new SketchImpl<Field18>(implementation, 18);\n+    case 19: return new SketchImpl<Field19>(implementation, 19);\n+    case 20: return new SketchImpl<Field20>(implementation, 20);\n+    case 21: return new SketchImpl<Field21>(implementation, 21);\n+    case 23: return new SketchImpl<Field23>(implementation, 23);\n+    case 24: return new SketchImpl<Field24>(implementation, 24);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri3Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 17: return new SketchImpl<FieldTri17>(implementation, 17);\n+    case 18: return new SketchImpl<FieldTri18>(implementation, 18);\n+    case 20: return new SketchImpl<FieldTri20>(implementation, 20);\n+    case 21: return new SketchImpl<FieldTri21>(implementation, 21);\n+    case 22: return new SketchImpl<FieldTri22>(implementation, 22);\n+    case 23: return new SketchImpl<FieldTri23>(implementation, 23);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "c7615aae53eab180e28b02a30574f9385d340d93",
        "filename": "src/fields/clmul_4bytes.cpp",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_4bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_4bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_4bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,118 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 25 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5, 5> StatTable25;\n+constexpr StatTable25 SQR_TABLE_25({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x800012});\n+constexpr StatTable25 SQR2_TABLE_25({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x48, 0x480, 0x4800, 0x48000, 0x480000, 0x800012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x400048, 0x492, 0x4920, 0x49200, 0x492000, 0x920012, 0x1200104});\n+constexpr StatTable25 SQR4_TABLE_25({0x1, 0x10000, 0x480, 0x800012, 0x104000, 0x4920, 0x1200104, 0x1001000, 0x48048, 0x481040, 0x410448, 0x492492, 0x930002, 0x580, 0x1800012, 0x14c000, 0x5960, 0x160014c, 0x1493000, 0x58058, 0x5814c0, 0xc14c5a, 0x596596, 0x1974922, 0x1249684});\n+constexpr StatTable25 SQR8_TABLE_25({0x1, 0x5960, 0x1411448, 0x1860922, 0x1d814d2, 0x1cdede8, 0x1e15e16, 0x1b79686, 0xfdf116, 0x1efe4c8, 0x1b839a8, 0x10ced66, 0xae05ce, 0x1459400, 0xa29fa6, 0x85e4d2, 0x7eecee, 0x183a96, 0x1eb2fa8, 0xede876, 0xf6e440, 0x1f7140a, 0xd07d7c, 0x10e4ea2, 0x1222a54});\n+constexpr StatTable25 QRT_TABLE_25({0, 0x482110, 0x482112, 0x1b3c3e6, 0x482116, 0x4960ae, 0x1b3c3ee, 0x4088, 0x482106, 0x58a726, 0x49608e, 0x5ce52e, 0x1b3c3ae, 0x2006, 0x4008, 0x1c1a8, 0x482006, 0x1e96488, 0x58a526, 0x400000, 0x49648e, 0x1800006, 0x5ced2e, 0xb3d3a8, 0x1b3d3ae});\n+typedef Field<uint32_t, 25, 9, StatTable25, &SQR_TABLE_25, &SQR2_TABLE_25, &SQR4_TABLE_25, &SQR8_TABLE_25, nullptr, &QRT_TABLE_25, IdTrans, &ID_TRANS, &ID_TRANS> Field25;\n+typedef FieldTri<uint32_t, 25, 3, RecLinTrans<uint32_t, 5, 5, 5, 5, 5>, &SQR_TABLE_25, &SQR2_TABLE_25, &SQR4_TABLE_25, &SQR8_TABLE_25, nullptr, &QRT_TABLE_25, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri25;\n+\n+// 26 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5> StatTable26;\n+constexpr StatTable26 SQR_TABLE_26({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x2c0001b, 0x300005a});\n+constexpr StatTable26 SQR2_TABLE_26({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x6c, 0x6c0, 0x6c00, 0x6c000, 0x6c0000, 0x2c0001b, 0x145, 0x1450, 0x14500, 0x145000, 0x1450000, 0x500077, 0x100076b, 0x76dc, 0x76dc0, 0x76dc00, 0x36dc01b, 0x2dc011f, 0x1c01105});\n+constexpr StatTable26 SQR4_TABLE_26({0x1, 0x10000, 0x6c0, 0x2c0001b, 0x145000, 0x76dc, 0x2dc011f, 0x1101100, 0x106ac6c, 0x6ad515, 0x1145127, 0x121b6dc, 0x2da1d0f, 0x10007c1, 0x3c7c01b, 0x128290, 0x29062e0, 0x2ee8d68, 0x167abcd, 0x3cabbce, 0x3c7a862, 0x6b83ce, 0x3cf5620, 0x229b787, 0x38a6b0f, 0x3071ade});\n+constexpr StatTable26 SQR8_TABLE_26({0x1, 0x29062e0, 0x2b2942d, 0x34ab63, 0x3bddebb, 0x7b1823, 0x58b9ae, 0x391720e, 0x1385e18, 0x3891746, 0x13069c5, 0x2dfd089, 0x12a35ff, 0x3e534f, 0x172c6a2, 0x55338f, 0x3887137, 0x3f45b03, 0x164a695, 0x2c7e7ef, 0x29c907d, 0x636c85, 0x3db4007, 0x97e7ff, 0x3cbfe55, 0x31c0d96});\n+constexpr StatTable26 QRT_TABLE_26({0x217b530, 0x2ae82a8, 0x2ae82aa, 0x2001046, 0x2ae82ae, 0x2de032e, 0x200104e, 0x70c10c, 0x2ae82be, 0x20151f2, 0x2de030e, 0xbc1400, 0x200100e, 0x178570, 0x70c18c, 0x2ae4232, 0x2ae83be, 0x211d742, 0x20153f2, 0x21f54f2, 0x2de070e, 0x5e0700, 0xbc1c00, 0x3abb97e, 0x200000e, 0});\n+typedef Field<uint32_t, 26, 27, StatTable26, &SQR_TABLE_26, &SQR2_TABLE_26, &SQR4_TABLE_26, &SQR8_TABLE_26, nullptr, &QRT_TABLE_26, IdTrans, &ID_TRANS, &ID_TRANS> Field26;\n+\n+// 27 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5> StatTable27;\n+constexpr StatTable27 SQR_TABLE_27({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x380004e, 0x600011f});\n+constexpr StatTable27 SQR2_TABLE_27({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x4e, 0x4e0, 0x4e00, 0x4e000, 0x4e0000, 0x4e00000, 0x600011f, 0x1054, 0x10540, 0x105400, 0x1054000, 0x54004e, 0x54004e0, 0x4004f76, 0x4f658, 0x4f6580, 0x4f65800, 0x765811f, 0x658101a, 0x5810004});\n+constexpr StatTable27 SQR4_TABLE_27({0x1, 0x10000, 0x4e0, 0x4e00000, 0x105400, 0x4004f76, 0x765811f, 0x1001110, 0x114e04e, 0x4abe54, 0x6551445, 0x45e212e, 0x13ccbdc, 0x3d805ef, 0x5e10100, 0x114b0e0, 0xe4bf22, 0x721c505, 0x51b3ba8, 0x3bf04d5, 0x4dabba0, 0x3b0aa45, 0x24a80cb, 0xc3d4b0, 0x4b34626, 0x6372e18, 0x6028c1b});\n+constexpr StatTable27 SQR8_TABLE_27({0x1, 0xe4bf22, 0x430cb3c, 0x73b7225, 0x6526539, 0x3c278e3, 0x4724a6e, 0x48b39b4, 0x1dbf7de, 0x106508, 0x3564785, 0x33ae33f, 0x61d6685, 0x6adaca3, 0x2786b6f, 0x4e76784, 0x869f42, 0x466b048, 0x415e00e, 0x46c3c9a, 0x73ffd91, 0x49002e0, 0x3734fed, 0x3c04a43, 0x191d3ee, 0xe828b9, 0xfab68c});\n+constexpr StatTable27 QRT_TABLE_27({0x6bf0530, 0x2be4496, 0x2be4494, 0x2bf0522, 0x2be4490, 0x1896cca, 0x2bf052a, 0x408a, 0x2be4480, 0x368ae72, 0x1896cea, 0x18d2ee0, 0x2bf056a, 0x1c76d6a, 0x400a, 0x336e9f8, 0x2be4580, 0x36baf12, 0x368ac72, 0x430360, 0x18968ea, 0x34a6b80, 0x18d26e0, 0xbf1560, 0x2bf156a, 0, 0x1c74d6a});\n+typedef Field<uint32_t, 27, 39, StatTable27, &SQR_TABLE_27, &SQR2_TABLE_27, &SQR4_TABLE_27, &SQR8_TABLE_27, nullptr, &QRT_TABLE_27, IdTrans, &ID_TRANS, &ID_TRANS> Field27;\n+\n+// 28 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5, 5> StatTableTRI28;\n+constexpr StatTableTRI28 SQR_TABLE_TRI28({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000});\n+constexpr StatTableTRI28 SQR2_TABLE_TRI28({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x3, 0x30, 0x300, 0x3000, 0x30000, 0x300000, 0x3000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0xf, 0xf0, 0xf00, 0xf000, 0xf0000, 0xf00000, 0xf000000});\n+constexpr StatTableTRI28 SQR4_TABLE_TRI28({0x1, 0x10000, 0x30, 0x300000, 0x500, 0x5000000, 0xf000, 0x11, 0x110000, 0x330, 0x3300000, 0x5500, 0x500000f, 0xff000, 0x101, 0x1010000, 0x3030, 0x300005, 0x50500, 0x50000f0, 0xf0f000, 0x1111, 0x1110003, 0x33330, 0x3300055, 0x555500, 0x5000fff, 0xffff000});\n+constexpr StatTableTRI28 SQR8_TABLE_TRI28({0x1, 0x3030, 0x5000500, 0xf0e111, 0x3210000, 0x6300faa, 0x40ef10e, 0x501, 0xf0c030, 0x5110630, 0x395b444, 0x621010e, 0x6010f9b, 0x13bc4cb, 0x110001, 0x3303065, 0xff50f, 0xf0e120, 0x3243530, 0x330fabb, 0x5ec232c, 0x511050e, 0x3c1c064, 0x2ec60a, 0x3954175, 0x7c5c43d, 0x20acba, 0x943bc43});\n+constexpr StatTableTRI28 QRT_TABLE_TRI28({0x121d57a, 0x40216, 0x40214, 0x8112578, 0x40210, 0x10110, 0x8112570, 0x12597ec, 0x40200, 0x6983e00, 0x10130, 0x972b99c, 0x8112530, 0x8002000, 0x125976c, 0x815a76c, 0x40300, 0x936b29c, 0x6983c00, 0x97bb8ac, 0x10530, 0x9103000, 0x972b19c, 0xf6384ac, 0x8113530, 0x4113530, 0x8000000, 0});\n+typedef FieldTri<uint32_t, 28, 1, StatTableTRI28, &SQR_TABLE_TRI28, &SQR2_TABLE_TRI28, &SQR4_TABLE_TRI28, &SQR8_TABLE_TRI28, nullptr, &QRT_TABLE_TRI28, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri28;\n+\n+// 29 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 5> StatTable29;\n+constexpr StatTable29 SQR_TABLE_29({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x8000005});\n+constexpr StatTable29 SQR2_TABLE_29({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x28, 0x280, 0x2800, 0x28000, 0x280000, 0x2800000, 0x8000005, 0x44, 0x440, 0x4400, 0x44000, 0x440000, 0x4400000, 0x400000a, 0xaa, 0xaa0, 0xaa00, 0xaa000, 0xaa0000, 0xaa00000, 0xa000011});\n+constexpr StatTable29 SQR4_TABLE_29({0x1, 0x10000, 0x28, 0x280000, 0x440, 0x4400000, 0xaa00, 0xa000011, 0x101000, 0x10000280, 0x2828000, 0x4444, 0x444000a, 0xaaaa0, 0xaa00101, 0x1000100, 0x1002800, 0x8002805, 0x8044005, 0x440aa, 0xaa00aa, 0xaa1010, 0x10101010, 0x10128280, 0x28282c4, 0x2c44444, 0x4444eaa, 0xeaaaaaa, 0xaaba001});\n+constexpr StatTable29 SQR8_TABLE_29({0x1, 0x1002800, 0x4680000, 0xae50ba, 0x2822a00, 0x14545eba, 0x110aed64, 0xc6eeaaf, 0x4ee00a0, 0x10aba290, 0x1bd6efc1, 0x8222b29, 0x1c791ebf, 0x174e85da, 0x1cc66c7f, 0x29292c4, 0x2886c20, 0xea04467, 0xc0eeb87, 0xccd4115, 0x16d5fa2e, 0x1cf8fe75, 0xe45a4e1, 0x19018b3f, 0x1d64778, 0x2e0bdf8, 0xa1bd96b, 0xff5b70e, 0x14d89770});\n+constexpr StatTable29 QRT_TABLE_29({0x1b8351dc, 0xb87135e, 0xb87135c, 0xda7b35e, 0xb871358, 0x621a116, 0xda7b356, 0x40200, 0xb871348, 0xc9e2620, 0x621a136, 0x478b16, 0xda7b316, 0x6762e20, 0x40280, 0x6202000, 0xb871248, 0x627a316, 0xc9e2420, 0xcd1ad36, 0x621a536, 0x760e20, 0x478316, 0xa760e20, 0xda7a316, 0x8000000, 0x6760e20, 0, 0x44280});\n+typedef Field<uint32_t, 29, 5, StatTable29, &SQR_TABLE_29, &SQR2_TABLE_29, &SQR4_TABLE_29, &SQR8_TABLE_29, nullptr, &QRT_TABLE_29, IdTrans, &ID_TRANS, &ID_TRANS> Field29;\n+typedef FieldTri<uint32_t, 29, 2, RecLinTrans<uint32_t, 6, 6, 6, 6, 5>, &SQR_TABLE_29, &SQR2_TABLE_29, &SQR4_TABLE_29, &SQR8_TABLE_29, nullptr, &QRT_TABLE_29, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri29;\n+\n+// 30 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 6> StatTableTRI30;\n+constexpr StatTableTRI30 SQR_TABLE_TRI30({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000});\n+constexpr StatTableTRI30 SQR2_TABLE_TRI30({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0xc00000, 0xc000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x10000003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000, 0x3c00000, 0x3c000000});\n+constexpr StatTableTRI30 SQR4_TABLE_TRI30({0x1, 0x10000, 0xc, 0xc0000, 0x50, 0x500000, 0x3c0, 0x3c00000, 0x1100, 0x11000000, 0xcc00, 0xc000005, 0x55000, 0x1000003f, 0x3fc000, 0x101, 0x1010000, 0xc0c, 0xc0c0000, 0x5050, 0x10500003, 0x3c3c0, 0x3c00011, 0x111100, 0x110000cc, 0xcccc00, 0xc000555, 0x5555000, 0x10003fff, 0x3fffc000});\n+constexpr StatTableTRI30 SQR8_TABLE_TRI30({0x1, 0x1010000, 0xc000c, 0xc0c5050, 0x390, 0x13900012, 0x12c012c0, 0x121ddddd, 0x54100, 0x1003f33, 0xc3f0d04, 0x9555558, 0xd379000, 0x105d3fa2, 0x1d615e9e, 0x1101, 0x100100cc, 0xc0ccc09, 0x5590505, 0x3a9390, 0x3913fec, 0x13fedfcd, 0x121ddd8c, 0x11544103, 0x2cc3cff, 0x3e24c45, 0x9558bc8, 0x3a7958b, 0x1e98b158, 0x29d629e9});\n+constexpr StatTableTRI30 QRT_TABLE_TRI30({0x2159df4a, 0x109134a, 0x1091348, 0x10114, 0x109134c, 0x3a203420, 0x1011c, 0x20004080, 0x109135c, 0x2005439c, 0x3a203400, 0x100400, 0x1015c, 0x3eb21930, 0x20004000, 0x20504c00, 0x109125c, 0x3b2b276c, 0x2005419c, 0x210450c0, 0x3a203000, 0x3e93186c, 0x100c00, 0x3aa23530, 0x1115c, 0x6b3286c, 0x3eb23930, 0xeb23930, 0x20000000, 0});\n+typedef FieldTri<uint32_t, 30, 1, StatTableTRI30, &SQR_TABLE_TRI30, &SQR2_TABLE_TRI30, &SQR4_TABLE_TRI30, &SQR8_TABLE_TRI30, nullptr, &QRT_TABLE_TRI30, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri30;\n+\n+// 31 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5> StatTable31;\n+constexpr StatTable31 SQR_TABLE_31({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x20000012});\n+constexpr StatTable31 SQR2_TABLE_31({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x12, 0x120, 0x1200, 0x12000, 0x120000, 0x1200000, 0x12000000, 0x20000012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x10400000, 0x4000012, 0x40000120, 0x1248, 0x12480, 0x124800, 0x1248000, 0x12480000, 0x24800012, 0x48000104});\n+constexpr StatTable31 SQR4_TABLE_31({0x1, 0x10000, 0x12, 0x120000, 0x104, 0x1040000, 0x1248, 0x12480000, 0x10010, 0x100012, 0x120120, 0x1200104, 0x1041040, 0x10401248, 0x12492480, 0x24810002, 0x112, 0x1120000, 0x1304, 0x13040000, 0x11648, 0x16480012, 0x134810, 0x48100116, 0x1121120, 0x11201304, 0x13053040, 0x3041165a, 0x16596492, 0x64934922, 0x49248016});\n+constexpr StatTable31 SQR8_TABLE_31({0x1, 0x112, 0x10104, 0x1131648, 0x10002, 0x1120224, 0x106021a, 0x146e3f86, 0x16, 0x174c, 0x161658, 0x175b1130, 0x16002c, 0x174c2e98, 0x16742dfc, 0x3f877966, 0x114, 0x10768, 0x1151050, 0x66b75b2, 0x1140228, 0x76a0ec2, 0x127a33da, 0x79648102, 0x1738, 0x1665f0, 0x172f64e0, 0x73cc668c, 0x17382e70, 0x65dccaac, 0x4abf956e});\n+constexpr StatTable31 QRT_TABLE_31({0, 0x10110, 0x10112, 0x15076e, 0x10116, 0x117130e, 0x150766, 0x4743fa0, 0x10106, 0x1121008, 0x117132e, 0x176b248e, 0x150726, 0x172a2c88, 0x4743f20, 0x7eb81e86, 0x10006, 0x20008, 0x1121208, 0x56b2c8e, 0x117172e, 0x133f1bae, 0x176b2c8e, 0x7f2a0c8e, 0x151726, 0x10000000, 0x172a0c88, 0x60000006, 0x4747f20, 0x3eb89e80, 0x7eb89e86});\n+typedef Field<uint32_t, 31, 9, StatTable31, &SQR_TABLE_31, &SQR2_TABLE_31, &SQR4_TABLE_31, &SQR8_TABLE_31, nullptr, &QRT_TABLE_31, IdTrans, &ID_TRANS, &ID_TRANS> Field31;\n+typedef FieldTri<uint32_t, 31, 3, RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_31, &SQR2_TABLE_31, &SQR4_TABLE_31, &SQR8_TABLE_31, nullptr, &QRT_TABLE_31, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri31;\n+\n+// 32 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5, 5> StatTable32;\n+constexpr StatTable32 SQR_TABLE_32({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x8d, 0x234, 0x8d0, 0x2340, 0x8d00, 0x23400, 0x8d000, 0x234000, 0x8d0000, 0x2340000, 0x8d00000, 0x23400000, 0x8d000000, 0x3400011a, 0xd0000468, 0x40001037});\n+constexpr StatTable32 SQR2_TABLE_32({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x8d, 0x8d0, 0x8d00, 0x8d000, 0x8d0000, 0x8d00000, 0x8d000000, 0xd0000468, 0x4051, 0x40510, 0x405100, 0x4051000, 0x40510000, 0x5100234, 0x51002340, 0x100236b9, 0x236b1d, 0x236b1d0, 0x236b1d00, 0x36b1d11a, 0x6b1d1037, 0xb1d1005e, 0x1d10001f, 0xd100017d});\n+constexpr StatTable32 SQR4_TABLE_32({0x1, 0x10000, 0x8d, 0x8d0000, 0x4051, 0x40510000, 0x236b1d, 0x6b1d1037, 0x10001101, 0x1109d000, 0xd00859e5, 0x59881468, 0x144737e8, 0x37e2c4e3, 0xc4f9a67a, 0xa61d8c55, 0x8c010001, 0x41dc8d, 0xdc8d23cd, 0x23a60c51, 0xc41630e, 0x63087fcd, 0x7ffe7368, 0x735580f6, 0x80cd8e29, 0x8e6fe311, 0xe350f32b, 0xf35edc90, 0xdced0bd6, 0xbbd3eb1, 0x3eb4a621, 0xa63f6bc4});\n+constexpr StatTable32 SQR8_TABLE_32({0x1, 0x8c010001, 0x6b9010bb, 0x7faf6b, 0xc4da8d37, 0xc10ab646, 0x445f546c, 0xe389129e, 0xd8aa2d3e, 0x85249468, 0xd599253f, 0x458976f9, 0xc9c86411, 0xccc2f34b, 0xa79e37dc, 0x9068e3c4, 0x3a30447f, 0x674c3398, 0x94f38a7, 0x402d3532, 0x116fffc7, 0x1c6b5ba2, 0xcd6a32e4, 0x49067a77, 0xa7f6a61e, 0x3cc3746, 0xeebe962e, 0x599276e1, 0x7b5fa4d9, 0x2aa3ce1, 0x990f8767, 0x1c3b66cb});\n+constexpr StatTable32 QRT_TABLE_32({0x54fd1264, 0xc26fcd64, 0xc26fcd66, 0x238a7462, 0xc26fcd62, 0x973bccaa, 0x238a746a, 0x77766712, 0xc26fcd72, 0xc1bdd556, 0x973bcc8a, 0x572a094c, 0x238a742a, 0xb693be84, 0x77766792, 0x9555c03e, 0xc26fcc72, 0x568419f8, 0xc1bdd756, 0x96c3d2ca, 0x973bc88a, 0x54861fdc, 0x572a014c, 0xb79badc4, 0x238a642a, 0xb9b99fe0, 0xb6939e84, 0xc519fa86, 0x77762792, 0, 0x9555403e, 0x377627ba});\n+typedef Field<uint32_t, 32, 141, StatTable32, &SQR_TABLE_32, &SQR2_TABLE_32, &SQR4_TABLE_32, &SQR8_TABLE_32, nullptr, &QRT_TABLE_32, IdTrans, &ID_TRANS, &ID_TRANS> Field32;\n+\n+}\n+\n+Sketch* ConstructClMul4Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 25: return new SketchImpl<Field25>(implementation, 25);\n+    case 26: return new SketchImpl<Field26>(implementation, 26);\n+    case 27: return new SketchImpl<Field27>(implementation, 27);\n+    case 29: return new SketchImpl<Field29>(implementation, 29);\n+    case 31: return new SketchImpl<Field31>(implementation, 31);\n+    case 32: return new SketchImpl<Field32>(implementation, 32);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri4Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 25: return new SketchImpl<FieldTri25>(implementation, 25);\n+    case 28: return new SketchImpl<FieldTri28>(implementation, 28);\n+    case 29: return new SketchImpl<FieldTri29>(implementation, 29);\n+    case 30: return new SketchImpl<FieldTri30>(implementation, 30);\n+    case 31: return new SketchImpl<FieldTri31>(implementation, 31);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "305c9cdff74c4c0aca5c99c1d79e5bc7718b83f4",
        "filename": "src/fields/clmul_5bytes.cpp",
        "status": "added",
        "additions": 130,
        "deletions": 0,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_5bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_5bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_5bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,130 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 33 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5> StatTable33;\n+constexpr StatTable33 SQR_TABLE_33({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x802, 0x2008, 0x8020, 0x20080, 0x80200, 0x200800, 0x802000, 0x2008000, 0x8020000, 0x20080000, 0x80200000, 0x800401, 0x2001004, 0x8004010, 0x20010040, 0x80040100});\n+constexpr StatTable33 SQR2_TABLE_33({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x2008, 0x20080, 0x200800, 0x2008000, 0x20080000, 0x800401, 0x8004010, 0x80040100, 0x400004, 0x4000040, 0x40000400, 0x4802, 0x48020, 0x480200, 0x4802000, 0x48020000, 0x80200802, 0x2009024, 0x20090240, 0x902001, 0x9020010, 0x90200100, 0x102000004, 0x20002048});\n+constexpr StatTable33 SQR4_TABLE_33({0x1, 0x10000, 0x100000000, 0x2008000, 0x80040100, 0x4802, 0x48020000, 0x902001, 0x20002048, 0x20081000, 0x10400004, 0x248820, 0x88204812, 0x49020410, 0x4822081, 0x20880641, 0x6000044, 0x480300, 0x3009024, 0x90220180, 0xa00c11, 0xc104050, 0x40482608, 0x2688b024, 0xb0690344, 0x102248834, 0x8a30c912, 0xc8062518, 0x24886803, 0x684a0244, 0x294a025, 0xa020294a, 0x280a1010});\n+constexpr StatTable33 SQR8_TABLE_33({0x1, 0x6000044, 0x280a1010, 0x122ac8e75, 0x83209926, 0x4a7a8a1, 0xcada863d, 0x6f2ab824, 0x6b4a8654, 0x70484bd6, 0x164c04e0b, 0x2fbc1617, 0xe095e5a3, 0xeaf7847d, 0xe5625e26, 0xa6aaa3e5, 0xc0164126, 0xd06217c0, 0x1ae58d21, 0xa8600250, 0xbaf87951, 0x8e12c19a, 0xa9b413b9, 0xb75ef087, 0x17e9214d9, 0x85968f33, 0x1e299478f, 0x92bc9a0f, 0x1975d642, 0x11af0b3f1, 0x4e86ee77, 0xe75f4726, 0x38026cce});\n+constexpr StatTable33 SQR16_TABLE_33({0x1, 0x185df5e91, 0x193fb40eb, 0xd464f9e4, 0x1ba2d73a6, 0x1d9288c5e, 0x5de03a49, 0x1869ea37b, 0x13faaf379, 0x195d1a8f5, 0x6afd5625, 0xf9d75bab, 0xaf44fe50, 0x101034b9e, 0xcc889caf, 0x5ec7455, 0x7d232a66, 0x17dcfe2c3, 0x1c66ff8d0, 0x17107e836, 0x1939cdead, 0x9852afa0, 0x1b946909a, 0x1846638c5, 0xdd5fa94c, 0x1cb2600fe, 0x19241c856, 0x15fe05ccd, 0xc9f9a425, 0x89e0f463, 0x37b01b39, 0xab0410e0, 0x1ace4ca03});\n+constexpr StatTable33 QRT_TABLE_33({0xba504dd4, 0x1e2798ef2, 0x1e2798ef0, 0x6698a4ec, 0x1e2798ef4, 0x1c7f1bef0, 0x6698a4e4, 0x16da1b384, 0x1e2798ee4, 0x661ca6ec, 0x1c7f1bed0, 0x1483b87a6, 0x6698a4a4, 0x800000, 0x16da1b304, 0x1a185101c, 0x1e2798fe4, 0xaa400954, 0x661ca4ec, 0x667caeec, 0x1c7f1bad0, 0x400800, 0x1483b8fa6, 0, 0x6698b4a4, 0x1c61da4b8, 0x802000, 0x16e5dadec, 0x16da1f304, 0x62fc8eec, 0x1a185901c, 0x1661da5ec, 0x1e2788fe4});\n+typedef Field<uint64_t, 33, 1025, StatTable33, &SQR_TABLE_33, &SQR2_TABLE_33, &SQR4_TABLE_33, &SQR8_TABLE_33, &SQR16_TABLE_33, &QRT_TABLE_33, IdTrans, &ID_TRANS, &ID_TRANS> Field33;\n+typedef FieldTri<uint64_t, 33, 10, RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_33, &SQR2_TABLE_33, &SQR4_TABLE_33, &SQR8_TABLE_33, &SQR16_TABLE_33, &QRT_TABLE_33, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri33;\n+\n+// 34 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5> StatTable34;\n+constexpr StatTable34 SQR_TABLE_34({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x10000102, 0x40000408, 0x100001020});\n+constexpr StatTable34 SQR2_TABLE_34({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x204, 0x2040, 0x20400, 0x204000, 0x2040000, 0x20400000, 0x204000000, 0x40000408, 0x4001, 0x40010, 0x400100, 0x4001000, 0x40010000, 0x100081, 0x1000810, 0x10008100, 0x100081000, 0x810204, 0x8102040, 0x81020400, 0x10204102, 0x102041020, 0x20410004, 0x204100040, 0x41000008});\n+constexpr StatTable34 SQR4_TABLE_34({0x1, 0x10000, 0x100000000, 0x204000, 0x40000408, 0x4001000, 0x10008100, 0x81020400, 0x204100040, 0x304, 0x3040000, 0x6041, 0x60410000, 0x1000c1010, 0x10304183, 0x4181020c, 0x102042060, 0x20400001, 0x50010, 0x100100081, 0xa14204, 0x142041428, 0x14001001, 0x10038500, 0x385020400, 0x204704140, 0x41000f1c, 0xf143040, 0x3041e145, 0x1e1430410, 0x3042c5050, 0x5030448b, 0x4481120c, 0x112048120});\n+constexpr StatTable34 SQR8_TABLE_34({0x1, 0x102042060, 0x4481120c, 0x1523455ab, 0x307081050, 0x21410f1c, 0x275d0e309, 0x3f676408a, 0x143a54d38, 0x304100344, 0x181774550, 0x1003cd092, 0x3f36b6421, 0x164d51695, 0x3e7c7f2ab, 0x9309b234, 0x354f8d24c, 0x1f5431410, 0x142012478, 0xc5225409, 0x14033f3cf, 0x123bd530c, 0x1100ee58, 0x35490c368, 0x2e1f3dcba, 0x2018108d2, 0x3c61a735d, 0xbf8fa918, 0x282ab07ea, 0x19c32af, 0x175e54c02, 0x2e4dfe2bb, 0x3374ab928, 0x3124a055});\n+constexpr StatTable34 SQR16_TABLE_34({0x1, 0x3448e6f02, 0x352590eb9, 0xb173da17, 0x264977d39, 0x172d45e48, 0x1e026e5d6, 0x357b54017, 0x2925d27a4, 0x1f6a32696, 0x2f49f220c, 0x3a7383d9e, 0x28111d79b, 0x5580fcf1, 0x276ede679, 0x175b379f8, 0x34d67b66, 0xc7019416, 0x3f3d9d59f, 0x2a7c2c032, 0x2b3482ba7, 0x177cd0128, 0x1d6f4bd2e, 0x31647a632, 0x41353027, 0x56292eea, 0x2733c0501, 0x6d7ed066, 0x2f3db9a75, 0x3225bc5cc, 0x3f22da089, 0xd0a7588e, 0xb60b22d1, 0xc2fddb7e});\n+constexpr StatTable34 QRT_TABLE_34({0x2f973a1f6, 0x40202, 0x40200, 0x348102060, 0x40204, 0x8000420, 0x348102068, 0x1092195c8, 0x40214, 0x3f6881b6e, 0x8000400, 0x3f810383e, 0x348102028, 0x340002068, 0x109219548, 0x24015a774, 0x40314, 0x3f050343e, 0x3f688196e, 0x3f81c3a3a, 0x8000000, 0x24031a560, 0x3f810303e, 0xb08c1a12, 0x348103028, 0xb2881906, 0x340000068, 0, 0x10921d548, 0x2e131e576, 0x240152774, 0x18921d55e, 0x50314, 0x14015271c});\n+typedef Field<uint64_t, 34, 129, StatTable34, &SQR_TABLE_34, &SQR2_TABLE_34, &SQR4_TABLE_34, &SQR8_TABLE_34, &SQR16_TABLE_34, &QRT_TABLE_34, IdTrans, &ID_TRANS, &ID_TRANS> Field34;\n+typedef FieldTri<uint64_t, 34, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5>, &SQR_TABLE_34, &SQR2_TABLE_34, &SQR4_TABLE_34, &SQR8_TABLE_34, &SQR16_TABLE_34, &QRT_TABLE_34, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri34;\n+\n+// 35 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5> StatTable35;\n+constexpr StatTable35 SQR_TABLE_35({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x28000000, 0xa0000000, 0x280000000, 0x200000005});\n+constexpr StatTable35 SQR2_TABLE_35({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0xa, 0xa0, 0xa00, 0xa000, 0xa0000, 0xa00000, 0xa000000, 0xa0000000, 0x200000005, 0x44, 0x440, 0x4400, 0x44000, 0x440000, 0x4400000, 0x44000000, 0x440000000, 0x400000028, 0x2a8, 0x2a80, 0x2a800, 0x2a8000, 0x2a80000, 0x2a800000, 0x2a8000000, 0x280000011});\n+constexpr StatTable35 SQR4_TABLE_35({0x1, 0x10000, 0x100000000, 0xa000, 0xa0000000, 0x4400, 0x44000000, 0x2a80, 0x2a800000, 0x1010, 0x10100000, 0xa0a, 0xa0a0000, 0x200000445, 0x4444000, 0x4400002a8, 0x2aaa800, 0x2a8000101, 0x1000100, 0x10000a0, 0xa000a0, 0xa00044, 0x440044, 0x400440028, 0x4002a8028, 0x2802a8011, 0x280101011, 0x1010100a, 0x100a0a0a, 0x20a0a0a05, 0x20a044445, 0x444444440, 0x44442aaa8, 0x2aaaaaaa8, 0x2aaa90001});\n+constexpr StatTable35 SQR8_TABLE_35({0x1, 0x2aaa800, 0x44442aaa8, 0x6400006ed, 0x64e4e4e45, 0x14544000, 0x8a145454, 0x2000034df, 0x49a749a36, 0xaa0a0000, 0x10aa0aaa, 0x1ba1a, 0x393a91ba, 0x3febaaaa9, 0x285105155, 0xa0ad9ad4, 0x269ce8d3b, 0x4de74f4e6, 0x42aaa8028, 0x4002aeea8, 0x400e46eec, 0x544e4006c, 0x145440144, 0x2abede545, 0x44309e74c, 0xa74eeda4, 0x64444ee49, 0x1aa1aaaa, 0x2b90bb1b1, 0x393902109, 0x16bc47bb2, 0x271ad1511, 0x6c8f98767, 0x69d3aa74c, 0x27790dc3b});\n+constexpr StatTable35 SQR16_TABLE_35({0x1, 0x4c80f98a4, 0x763684437, 0x5a1cc86a0, 0x38922db8, 0x71755e12d, 0x2ca94c627, 0x388a2bc7f, 0x406596de0, 0x1818c6958, 0x174a92efe, 0x1a80c764e, 0x2f23eacbf, 0xd611ea8, 0x64d783fd5, 0x4fdfe0798, 0x31459de8d, 0x62c889d99, 0x9c419962, 0x2d8d865b3, 0x1ac7e7ffc, 0x38a0c12f3, 0x9fbc1076, 0x6f76d3b89, 0x6e472c757, 0x5f240de42, 0x10176ecc0, 0x20c1cef8, 0x8f77f91c, 0x3f6e533b9, 0x62017c147, 0x5ce81e2fa, 0x371fe4ad9, 0x2552b5046, 0xc3f3696c});\n+constexpr StatTable35 QRT_TABLE_35({0x5c2038114, 0x2bf547ee8, 0x2bf547eea, 0x2bf1074e8, 0x2bf547eee, 0x1883d0736, 0x2bf1074e0, 0x100420, 0x2bf547efe, 0x400800, 0x1883d0716, 0x5e90e4a0, 0x2bf1074a0, 0x4e70ac20, 0x1004a0, 0x2f060c880, 0x2bf547ffe, 0x37d55fffe, 0x400a00, 0x3372573de, 0x1883d0316, 0x700c20, 0x5e90eca0, 0x10604880, 0x2bf1064a0, 0x18f35377e, 0x4e708c20, 0x33f557ffe, 0x1044a0, 0x1bf557ffe, 0x2f0604880, 0x200000000, 0x2bf557ffe, 0, 0x37d57fffe});\n+typedef Field<uint64_t, 35, 5, StatTable35, &SQR_TABLE_35, &SQR2_TABLE_35, &SQR4_TABLE_35, &SQR8_TABLE_35, &SQR16_TABLE_35, &QRT_TABLE_35, IdTrans, &ID_TRANS, &ID_TRANS> Field35;\n+typedef FieldTri<uint64_t, 35, 2, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_35, &SQR2_TABLE_35, &SQR4_TABLE_35, &SQR8_TABLE_35, &SQR16_TABLE_35, &QRT_TABLE_35, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri35;\n+\n+// 36 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6> StatTable36;\n+constexpr StatTable36 SQR_TABLE_36({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x10000402, 0x40001008, 0x100004020, 0x400010080});\n+constexpr StatTable36 SQR2_TABLE_36({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x201, 0x2010, 0x20100, 0x201000, 0x2010000, 0x20100000, 0x201000000, 0x10000402, 0x100004020, 0x40001, 0x400010, 0x4000100, 0x40001000, 0x400010000, 0x100804, 0x1008040, 0x10080400, 0x100804000, 0x8040201, 0x80402010, 0x804020100, 0x40200008, 0x402000080, 0x20000004, 0x200000040, 0x2, 0x20});\n+constexpr StatTable36 SQR4_TABLE_36({0x1, 0x10000, 0x100000000, 0x201000, 0x10000402, 0x4000100, 0x1008040, 0x80402010, 0x20000004, 0x200, 0x2000000, 0x4020, 0x40200000, 0x80002, 0x800020000, 0x201008000, 0x80400010, 0x4, 0x40000, 0x400000000, 0x804000, 0x40001008, 0x10000400, 0x4020100, 0x201008040, 0x80000010, 0x800, 0x8000000, 0x10080, 0x100800000, 0x200008, 0x80402, 0x804020000, 0x201000040, 0x10, 0x100000});\n+constexpr StatTable36 SQR8_TABLE_36({0x1, 0x80400010, 0x804020000, 0x201008, 0x2000080, 0x20000804, 0x1008000, 0x402, 0x800000, 0x200, 0x80000010, 0x804020100, 0x40201000, 0x400010000, 0x100004, 0x201000000, 0x80400, 0x100000000, 0x40000, 0x10, 0x804000100, 0x40201008, 0x2010080, 0x20000800, 0x200008040, 0x10080000, 0x4020, 0x8000000, 0x2000, 0x800000100, 0x40200008, 0x402010000, 0x100804, 0x1000040, 0x10000402, 0x804000});\n+constexpr StatTable36 SQR16_TABLE_36({0x1, 0x402000000, 0x100800020, 0x201000, 0x10080402, 0x800000000, 0x1008040, 0x400000, 0x20000800, 0x200, 0x400010080, 0x100000020, 0x40200000, 0x10080002, 0x20100, 0x201008000, 0x80000000, 0x100804, 0x40000, 0x2000080, 0x20, 0x40001008, 0x10000002, 0x4020000, 0x201008040, 0x2010, 0x20100800, 0x8000000, 0x400010000, 0x4000, 0x200008, 0x2, 0x804000000, 0x201000040, 0x402000, 0x20100804});\n+constexpr StatTable36 QRT_TABLE_36({0x40200, 0x8b0526186, 0x8b0526184, 0x240001000, 0x8b0526180, 0xcb6894d94, 0x240001008, 0xdb6880c22, 0x8b0526190, 0x8000200, 0xcb6894db4, 0x500424836, 0x240001048, 0x406cb2834, 0xdb6880ca2, 0x241200008, 0x8b0526090, 0xdb05021a6, 0x8000000, 0xdb01829b2, 0xcb68949b4, 0x1001000, 0x500424036, 0x106116406, 0x240000048, 0xcb29968a4, 0x406cb0834, 0, 0xdb6884ca2, 0x110010516, 0x241208008, 0x430434520, 0x8b0536090, 0x41208040, 0xdb05221a6, 0xb6884d14});\n+typedef Field<uint64_t, 36, 513, StatTable36, &SQR_TABLE_36, &SQR2_TABLE_36, &SQR4_TABLE_36, &SQR8_TABLE_36, &SQR16_TABLE_36, &QRT_TABLE_36, IdTrans, &ID_TRANS, &ID_TRANS> Field36;\n+typedef FieldTri<uint64_t, 36, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_36, &SQR2_TABLE_36, &SQR4_TABLE_36, &SQR8_TABLE_36, &SQR16_TABLE_36, &QRT_TABLE_36, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri36;\n+\n+// 37 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 5, 5, 5, 5, 5> StatTable37;\n+constexpr StatTable37 SQR_TABLE_37({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0xa6, 0x298, 0xa60, 0x2980, 0xa600, 0x29800, 0xa6000, 0x298000, 0xa60000, 0x2980000, 0xa600000, 0x29800000, 0xa6000000, 0x298000000, 0xa60000000, 0x980000053, 0x60000011f, 0x180000047c});\n+constexpr StatTable37 SQR2_TABLE_37({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x298, 0x2980, 0x29800, 0x298000, 0x2980000, 0x29800000, 0x298000000, 0x980000053, 0x180000047c, 0x4414, 0x44140, 0x441400, 0x4414000, 0x44140000, 0x441400000, 0x4140000a6, 0x140000ac6, 0x140000ac60, 0xac43e, 0xac43e0, 0xac43e00, 0xac43e000, 0xac43e0000, 0xc43e0011f, 0x43e00101a, 0x3e0010106, 0x1e00101033});\n+constexpr StatTable37 SQR4_TABLE_37({0x1, 0x10000, 0x100000000, 0x29800, 0x298000000, 0x44140, 0x441400000, 0xac43e, 0xac43e0000, 0x1e00101033, 0x1010011000, 0x11029a980, 0x9a982b1d3, 0x2b1c45014, 0x4501005f2, 0x1005f8ef80, 0x18efa98941, 0x9897de117, 0x1de10002ad, 0x2990398, 0x190398047c, 0x180443dee4, 0x3ded94ac6, 0x194ac071fa, 0x71c56e1a, 0x56e1adff2, 0x1adffa1690, 0x1a16a9ab31, 0x9ab0957cf, 0x957d85468, 0x18547edba2, 0x1edb9fc515, 0x1fc526c1a4, 0x6c1956aab, 0x156aa5b9d4, 0x5b9f59def, 0x159de6d961});\n+constexpr StatTable37 SQR8_TABLE_37({0x1, 0x18efa98941, 0x1fc526c1a4, 0x11352e16c4, 0xba7aa5340, 0x17346e075f, 0xe91c746aa, 0xe560ac1bd, 0xa4544c5d9, 0x11bd3c631f, 0xd70c4b63c, 0xfe77d107c, 0x10548e5288, 0x1183954fb3, 0x19b3aa4bb, 0x782a2943c, 0x1c19ba61de, 0x6ad01fe38, 0xa22701577, 0xb96546ca0, 0x1d7c6c8b9c, 0xffef807e2, 0x16fcc14dc2, 0x110cc4e83c, 0xc3a35629a, 0x1062330476, 0xb2e5d1de1, 0x1ca4e3d229, 0x67826b51b, 0xe7e4c36e7, 0x59f1ac963, 0x12777f22c6, 0x13963d623a, 0x9e305ac92, 0x219b91d13, 0x175bebeb0d, 0xc6b7b5572});\n+constexpr StatTable37 SQR16_TABLE_37({0x1, 0xcb88f2f8b, 0x1a2a0be7af, 0xb93048ada, 0x113ed92190, 0xc95a18e2b, 0x1e1cd4a85b, 0x19584a1a66, 0x1b947c28c2, 0x1b52b48e27, 0xe64e7b169, 0x14a256d011, 0xda657196d, 0x1947c1dcb4, 0x18b2fa3851, 0xae3d4171a, 0x658f1f4b9, 0x91852c314, 0x69346cf8e, 0x8224bf36c, 0x1086c810ed, 0x10419bc782, 0x57d6a4e36, 0xfbb31a43e, 0x18b502de05, 0x786795174, 0x1de0f1b7f3, 0x1d456b87dc, 0x1aabb2f3bc, 0xc5b80ef0c, 0x1ce4fd7543, 0x7ca740ca1, 0x29eaec26a, 0x1eb0b42043, 0xca3b2b17, 0x3453101c1, 0x1714c59187});\n+constexpr StatTable37 QRT_TABLE_37({0xa3c62e7ba, 0xdc7a0c16a, 0xdc7a0c168, 0x12f7484546, 0xdc7a0c16c, 0xa9803a20, 0x12f748454e, 0xda07064a4, 0xdc7a0c17c, 0x123908de8e, 0xa9803a00, 0x122a888a8e, 0x12f748450e, 0x6790add8, 0xda0706424, 0x12e0a0384c, 0xdc7a0c07c, 0xcb28a2c2, 0x123908dc8e, 0xd09f85e86, 0xa9803e00, 0x124d682b6e, 0x122a88828e, 0x1738711a, 0x12f748550e, 0x73035b8, 0x67908dd8, 0xa0702438, 0xda0702424, 0xe0a0b860, 0x12e0a0b84c, 0x1c7a1c060, 0xdc7a1c07c, 0, 0xcb2aa2c2, 0x100000002c, 0x12390cdc8e});\n+typedef Field<uint64_t, 37, 83, StatTable37, &SQR_TABLE_37, &SQR2_TABLE_37, &SQR4_TABLE_37, &SQR8_TABLE_37, &SQR16_TABLE_37, &QRT_TABLE_37, IdTrans, &ID_TRANS, &ID_TRANS> Field37;\n+\n+// 38 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5> StatTable38;\n+constexpr StatTable38 SQR_TABLE_38({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x2300000063, 0xc0000014a, 0x3000000528});\n+constexpr StatTable38 SQR2_TABLE_38({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x18c, 0x18c0, 0x18c00, 0x18c000, 0x18c0000, 0x18c00000, 0x18c000000, 0x18c0000000, 0xc0000014a, 0x1405, 0x14050, 0x140500, 0x1405000, 0x14050000, 0x140500000, 0x1405000000, 0x500001ef, 0x500001ef0, 0x100001ef63, 0x1ef7bc, 0x1ef7bc0, 0x1ef7bc00, 0x1ef7bc000, 0x1ef7bc0000, 0x2f7bc00129, 0x37bc00112d, 0x3bc0011027, 0x3c00110022});\n+constexpr StatTable38 SQR4_TABLE_38({0x1, 0x10000, 0x100000000, 0x18c00, 0x18c000000, 0x14050, 0x140500000, 0x100001ef63, 0x1ef7bc000, 0x3bc0011027, 0x110001100, 0x110194c0, 0x194c0194c, 0x194d5455, 0xd5455154f, 0x151544a193, 0x4a18c631f, 0xc6319c6ca, 0x19c6c00014, 0x18c8d, 0x18c8d0000, 0xd00014096, 0x1409ddc00, 0x1ddc01efc6, 0x1efd5ab90, 0x15ab9110e1, 0x1110fe85b2, 0x3e85ab5465, 0x2b5445c97a, 0x5c9450993, 0x50994148f, 0x141488b12a, 0x8b134ee36, 0x34ee3a8ecc, 0x3a8ee3edc8, 0x23edeef7ed, 0x2ef7de8bf9, 0x1e8bc14041});\n+constexpr StatTable38 SQR8_TABLE_38({0x1, 0x4a18c631f, 0x8b134ee36, 0x10b5c9474c, 0x3330e98ecb, 0x939897650, 0xd74b026b9, 0x860251dd9, 0x3afbe829b4, 0x3ae6afc308, 0x239ecafe00, 0x2acbc94749, 0x3a5770e19e, 0x4052e180b, 0x321fa15712, 0x3a8a4869ef, 0x1948598082, 0x3b1bd98542, 0xc1deb9112, 0x1b5c9242e, 0x338ba58e8b, 0x8abe06d20, 0x145bb1d2a9, 0x1d6e10fbf0, 0x197d522629, 0x2ff1bbe50d, 0xcc1594a16, 0xc94db1b03, 0x3b20e51c56, 0x101d1e5d07, 0x19472478f7, 0x269635a968, 0x2fd4a35802, 0x1b63e116b6, 0x19fdf9d22a, 0x2ef0e4d419, 0x3e80f730f4, 0x29869b04b9});\n+constexpr StatTable38 SQR16_TABLE_38({0x1, 0x3f5fe2afaa, 0x4216541b5, 0x33b362f56a, 0x9d630d7e1, 0x11127694c1, 0x3f8daab2d6, 0x153ca20edc, 0x22a747a3de, 0xc6ab16040, 0x19cc9a7e37, 0x449d96001, 0x45a7e7c46, 0x36d11561ce, 0x114b93f52a, 0x42a87f1b3, 0x23112a30bc, 0x400df9212, 0x3aca9544df, 0x140c4b0bcf, 0x2ae2efa6d3, 0x2f7051159c, 0x19cca2f62e, 0x102023d8c0, 0xccc793f0b, 0x2ff4789b55, 0x339e4cd9ba, 0x2b02ab5052, 0x8c1b5db82, 0x2e461e4e32, 0xd93541605, 0x1acf12087, 0x33b88dca2b, 0x1e91723c8b, 0xd81047b2b, 0x2e5e54b97c, 0x85bb507d8, 0x2145b1864b});\n+constexpr StatTable38 QRT_TABLE_38({0x34b0ac6430, 0x2223262fa, 0x2223262f8, 0x35554405fe, 0x2223262fc, 0x355514098a, 0x35554405f6, 0x400840, 0x2223262ec, 0x1777726532, 0x35551409aa, 0x15c06fc0, 0x35554405b6, 0x1f5303fec, 0x4008c0, 0x236a21030, 0x2223263ec, 0x1a9008c00, 0x1777726732, 0x3692c60ab6, 0x3555140daa, 0x15556007ee, 0x15c067c0, 0x14a0b030f2, 0x35554415b6, 0x227c06d168, 0x1f5301fec, 0x16c3928fc2, 0x4048c0, 0x3a942c4c0, 0x236a29030, 0x1636a2902e, 0x2223363ec, 0x3a6e898276, 0x1a9028c00, 0x6de74eb2c, 0x1777766732, 0});\n+typedef Field<uint64_t, 38, 99, StatTable38, &SQR_TABLE_38, &SQR2_TABLE_38, &SQR4_TABLE_38, &SQR8_TABLE_38, &SQR16_TABLE_38, &QRT_TABLE_38, IdTrans, &ID_TRANS, &ID_TRANS> Field38;\n+\n+// 39 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5> StatTable39;\n+constexpr StatTable39 SQR_TABLE_39({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x800000011, 0x2000000044});\n+constexpr StatTable39 SQR2_TABLE_39({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x22, 0x220, 0x2200, 0x22000, 0x220000, 0x2200000, 0x22000000, 0x220000000, 0x2200000000, 0x2000000044, 0x404, 0x4040, 0x40400, 0x404000, 0x4040000, 0x40400000, 0x404000000, 0x4040000000, 0x400000088, 0x4000000880, 0x8888, 0x88880, 0x888800, 0x8888000, 0x88880000, 0x888800000, 0x888000011, 0x880000101, 0x800001001});\n+constexpr StatTable39 SQR4_TABLE_39({0x1, 0x10000, 0x100000000, 0x2200, 0x22000000, 0x404, 0x4040000, 0x400000088, 0x888800, 0x888000011, 0x100010, 0x1000100000, 0x1000022000, 0x220022000, 0x220004040, 0x40404040, 0x4040400880, 0x4008888880, 0x888888101, 0x881000001, 0x122, 0x1220000, 0x2200000022, 0x260400, 0x2604000000, 0x48c88, 0x48c880000, 0x800009889, 0x98881000, 0x810001221, 0x12201220, 0x2012200264, 0x2002604264, 0x6042604044, 0x604048c8c4, 0x48c8c8c880, 0x48c8898881, 0x988888881, 0x888802201});\n+constexpr StatTable39 SQR8_TABLE_39({0x1, 0x4040400880, 0x2002604264, 0xaa8022011, 0x810049ea9, 0x100100010, 0xc04008101, 0x644048ea4c, 0x18c1764441, 0x60f8e8526c, 0x22000122, 0x48c88989a3, 0xae0032001, 0x2a7aeafae5, 0x6a76641225, 0x2036245242, 0x3e9ab0308b, 0x1c49f6fe41, 0x681b069e2d, 0x4edee8cae5, 0x898c04, 0x660daa8880, 0x69cae9ccc1, 0x4881320991, 0xd06280001, 0x1cc8c8e3d9, 0x445fc65628, 0x4c889a8a49, 0x300b8caeec, 0x50d842fc94, 0x1811acb89d, 0x9d22101c, 0x2025aa407e, 0x20370a744a, 0x3cf77cb80b, 0x54a13e66e7, 0x34c17e2e04, 0x5c19fe54c1, 0x6a72cc767d});\n+constexpr StatTable39 SQR16_TABLE_39({0x1, 0x37214861ce, 0x689e897065, 0x5678d6ee60, 0x619da834c4, 0x28352752d3, 0x14fed69ec6, 0x5b3d4aa637, 0x682fb8da4d, 0x2ce48c5615, 0x1591ac539c, 0x72d4fbcd0, 0x346b547296, 0x1e7065d419, 0x4e6eb48571, 0x26615d4c2c, 0x60d1c6122e, 0x78d0e2a2eb, 0x52bb3e2980, 0x3c2592d0ab, 0x701ba76b58, 0x5fdf53b685, 0x57cfd2d120, 0x75559e4344, 0x3837a46907, 0x15f961a4ce, 0x397b9a03e9, 0x5a8dd4ab69, 0x3a6ab3356f, 0x215d39c25e, 0x5bbaf82443, 0x6759e3c88c, 0x3c0b862ca1, 0x37eec7e79e, 0x6ce865e38, 0x4a56a338c0, 0x5684636aee, 0x325a019126, 0x24f18a4ef6});\n+constexpr StatTable39 QRT_TABLE_39({0x66b02a408c, 0x100420, 0x100422, 0x14206080, 0x100426, 0x5dccefab1c, 0x14206088, 0x9fc11e5b6, 0x100436, 0x5466bea62a, 0x5dccefab3c, 0x9aa110536, 0x142060c8, 0x54739ed6e2, 0x9fc11e536, 0xe7a82c080, 0x100536, 0x4002000, 0x5466bea42a, 0x6a4022000, 0x5dccefaf3c, 0x9e8118536, 0x9aa110d36, 0x5680e080, 0x142070c8, 0x7d293c5b6, 0x54739ef6e2, 0x8d680e080, 0x9fc11a536, 0x6d282c080, 0xe7a824080, 0x800000000, 0x110536, 0x2d680e080, 0x4022000, 0, 0x5466baa42a, 0x46b03a44aa, 0x6a40a2000});\n+typedef Field<uint64_t, 39, 17, StatTable39, &SQR_TABLE_39, &SQR2_TABLE_39, &SQR4_TABLE_39, &SQR8_TABLE_39, &SQR16_TABLE_39, &QRT_TABLE_39, IdTrans, &ID_TRANS, &ID_TRANS> Field39;\n+typedef FieldTri<uint64_t, 39, 4, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_39, &SQR2_TABLE_39, &SQR4_TABLE_39, &SQR8_TABLE_39, &SQR16_TABLE_39, &QRT_TABLE_39, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri39;\n+\n+// 40 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5> StatTable40;\n+constexpr StatTable40 SQR_TABLE_40({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x39, 0xe4, 0x390, 0xe40, 0x3900, 0xe400, 0x39000, 0xe4000, 0x390000, 0xe40000, 0x3900000, 0xe400000, 0x39000000, 0xe4000000, 0x390000000, 0xe40000000, 0x3900000000, 0xe400000000, 0x900000004b, 0x400000015e});\n+constexpr StatTable40 SQR2_TABLE_40({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x39, 0x390, 0x3900, 0x39000, 0x390000, 0x3900000, 0x39000000, 0x390000000, 0x3900000000, 0x900000004b, 0x541, 0x5410, 0x54100, 0x541000, 0x5410000, 0x54100000, 0x541000000, 0x5410000000, 0x41000000dd, 0x1000000d34, 0xd379, 0xd3790, 0xd37900, 0xd379000, 0xd3790000, 0xd37900000, 0xd379000000, 0x3790000115, 0x790000111b, 0x900001111f});\n+constexpr StatTable40 SQR4_TABLE_40({0x1, 0x10000, 0x100000000, 0x3900, 0x39000000, 0x541, 0x5410000, 0x41000000dd, 0xd37900, 0xd379000000, 0x111001, 0x1110010000, 0x10003aa90, 0x3aa903900, 0x903900511a, 0x51051541, 0x515410de9, 0x410de9de4d, 0xe9de437815, 0x437801010e, 0x101000038, 0x383939, 0x3839390000, 0x3900057d41, 0x57d444100, 0x444100d6e5, 0xd6ebaa79, 0xebaa7911c6, 0x7911d2791a, 0xd2791102a9, 0x1102b82901, 0xb82902a972, 0x2a96bfed1, 0x6bfed16851, 0xd16859f42e, 0x59f43f61a8, 0x3f61a43794, 0xa43791de59, 0x91de42401f, 0x424000390e});\n+constexpr StatTable40 SQR8_TABLE_40({0x1, 0x515410de9, 0x2a96bfed1, 0x13ba41ea90, 0x45bffe2b75, 0x5836900, 0x3887d7e690, 0xd34b688712, 0xc7a3d51557, 0xd1151ada71, 0x51442a740, 0x41cc5cbdb6, 0xc61a5701e9, 0x8757946d91, 0xa99e8b9e65, 0x80a0aca777, 0xc242b5c0e9, 0x6826eccb25, 0xad687ebd2d, 0xad5c69d802, 0x7ed2f8390, 0x51fa78eedf, 0xc0718c96f6, 0xaf4672a8c2, 0xc67436f2fd, 0x56ddb12767, 0x535afb0326, 0xbce1edda33, 0xef36202f0f, 0x45d13015ec, 0x104ab11aef, 0xef96c86d49, 0xc1b790bfc9, 0x2fa610e77f, 0x2a10a27d6e, 0xca5bb10773, 0xfdaf2b4642, 0xb3b4b7e20d, 0xe8bbe4d22e, 0xf9986bd2df});\n+constexpr StatTable40 SQR16_TABLE_40({0x1, 0xe88450a7de, 0x3a0a56c3e8, 0x1684757d36, 0xc7f40bf3e9, 0x38aa7009c0, 0x2b6f129659, 0xd1e0fc42e5, 0x96150bc554, 0x9774ef4cc1, 0xd34eebf74d, 0x2d183441ec, 0xeedf6d1c78, 0x3f93c5d217, 0xb924305809, 0xc383bb7c14, 0x3f242bb94e, 0x9313556f6b, 0x2f5e1ecc6b, 0x2e7f9df195, 0xac8b882870, 0xd14f457f55, 0xf9f936148d, 0x719190770, 0x6838b41a21, 0xb95ff30106, 0xc1527dd1c5, 0xe858b5f9b6, 0x9368a791c2, 0x7de23878af, 0x95c610d398, 0xed0edcb032, 0x9548a680b0, 0xc133469e7b, 0x68c96ccbb2, 0x7773231ebb, 0xbd5ef4207c, 0xdf8bd59374, 0xb862414268, 0xfa62b39e42});\n+constexpr StatTable40 QRT_TABLE_40({0x624b3cecc, 0xbc5c3f4c6, 0xbc5c3f4c4, 0xde1603e2c, 0xbc5c3f4c0, 0xaabec06cea, 0xde1603e24, 0x6cd9f724c2, 0xbc5c3f4d0, 0xcde1743818, 0xaabec06cca, 0xa138c314ca, 0xde1603e64, 0xaafc00f01a, 0x6cd9f72442, 0xcdca11bb4, 0xbc5c3f5d0, 0xa00002001a, 0xcde1743a18, 0xdf1407b90, 0xaabec068ca, 0xc043b482c8, 0xa138c31cca, 0xcb86977e3c, 0xde1602e64, 0x604596a326, 0xaafc00d01a, 0xcc1c165d0, 0x6cd9f76442, 0x673c94da26, 0xcdca19bb4, 0x67c0940a26, 0xbc5c2f5d0, 0xa4dca19bae, 0xa00000001a, 0x1bc5c2f5d0, 0xcde1703a18, 0, 0xdf1487b90, 0x8df1487b8a});\n+typedef Field<uint64_t, 40, 57, StatTable40, &SQR_TABLE_40, &SQR2_TABLE_40, &SQR4_TABLE_40, &SQR8_TABLE_40, &SQR16_TABLE_40, &QRT_TABLE_40, IdTrans, &ID_TRANS, &ID_TRANS> Field40;\n+\n+}\n+\n+Sketch* ConstructClMul5Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 33: return new SketchImpl<Field33>(implementation, 33);\n+    case 34: return new SketchImpl<Field34>(implementation, 34);\n+    case 35: return new SketchImpl<Field35>(implementation, 35);\n+    case 36: return new SketchImpl<Field36>(implementation, 36);\n+    case 37: return new SketchImpl<Field37>(implementation, 37);\n+    case 38: return new SketchImpl<Field38>(implementation, 38);\n+    case 39: return new SketchImpl<Field39>(implementation, 39);\n+    case 40: return new SketchImpl<Field40>(implementation, 40);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri5Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 33: return new SketchImpl<FieldTri33>(implementation, 33);\n+    case 34: return new SketchImpl<FieldTri34>(implementation, 34);\n+    case 35: return new SketchImpl<FieldTri35>(implementation, 35);\n+    case 36: return new SketchImpl<FieldTri36>(implementation, 36);\n+    case 39: return new SketchImpl<FieldTri39>(implementation, 39);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "239fef3e2182e56b63435f8d7fe7a94b92ccd5e6",
        "filename": "src/fields/clmul_6bytes.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_6bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_6bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_6bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 41 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5> StatTable41;\n+constexpr StatTable41 SQR_TABLE_41({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x120000000, 0x480000000, 0x1200000000, 0x4800000000, 0x12000000000, 0x8000000012});\n+constexpr StatTable41 SQR2_TABLE_41({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x48, 0x480, 0x4800, 0x48000, 0x480000, 0x4800000, 0x48000000, 0x480000000, 0x4800000000, 0x8000000012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x10400000, 0x104000000, 0x1040000000, 0x10400000000, 0x4000000048, 0x492, 0x4920, 0x49200, 0x492000, 0x4920000, 0x49200000, 0x492000000, 0x4920000000, 0x9200000012, 0x12000000104});\n+constexpr StatTable41 SQR4_TABLE_41({0x1, 0x10000, 0x100000000, 0x480, 0x4800000, 0x8000000012, 0x104000, 0x1040000000, 0x4920, 0x49200000, 0x12000000104, 0x1001000, 0x10010000000, 0x48048, 0x480480000, 0x4800001040, 0x10410400, 0x4104000048, 0x492492, 0x4924920000, 0x9200010002, 0x100000100, 0x1000480, 0x10004800000, 0x8000048012, 0x480104000, 0x1040001040, 0x10404920, 0x4049200048, 0x12000492104, 0x4921001000, 0x10010010010, 0x100148048, 0x1480480480, 0x4804805840, 0x8058410412, 0x410410414c, 0x10414d2492, 0x14d24924920, 0x9249259202, 0x12592000004});\n+constexpr StatTable41 SQR8_TABLE_41({0x1, 0x10410400, 0x100148048, 0x13040000104, 0x11044801040, 0x924da49202, 0x9680490002, 0x82510514c, 0x8481485932, 0xc83144d832, 0x134d34d6db6, 0x18010048012, 0x165db20004c, 0x4800597052, 0x10131135cd0, 0xcd6cc30d32, 0x160586101cc, 0x15c64969da8, 0x179715681cc, 0x12f3c0ffc74, 0xc7dd3dd3ce, 0x10014c968, 0x1b040048116, 0x35d6801044, 0xda4deda6d0, 0x1de94c85852, 0x1083500114c, 0xc4c9685dfa, 0x18515c6d592, 0x17de69aed7e, 0x16c6c8a6c6c, 0x165cfe1044c, 0xdb004cf018, 0x7075031c98, 0x1d9a90b0d72, 0x1bb2485caee, 0x1cbe4dfd48a, 0x1f1540b7400, 0xc62bc7fd02, 0x147b5103f2e, 0x390ee8bcc6});\n+constexpr StatTable41 SQR16_TABLE_41({0x1, 0x61deee38fe, 0xe00adae2e, 0x1ea53eaa95a, 0x503e540566, 0xabc8e7f89a, 0x1bf760d86ac, 0x94cce9c722, 0x15c8006ee5c, 0x7aba20c1da, 0x12662a9603e, 0x5fe76acec4, 0x1e6beca9e42, 0x1efc8f7a000, 0x165997c6d7e, 0xee947a07ee, 0xd9bd741142, 0xaa304566c0, 0x5fe336e356, 0x11f1021b80c, 0xd34e5a1674, 0x99ed56b9dc, 0x9afae0eca, 0x1a5830b390e, 0x1be1a63eb7e, 0x141e77e141c, 0xee3be92168, 0xa93823d65c, 0x18a59f4b19c, 0xce69942af6, 0x3f7b319c0e, 0xba83a4a7b4, 0x7da4b6fcde, 0x17f79268f10, 0x1222602d048, 0x1b4b2f326b8, 0x159abff0786, 0xb35534a7a2, 0x84bbc48050, 0x173d5cbf330, 0x2897dd6f58});\n+constexpr StatTable41 QRT_TABLE_41({0, 0x1599a5e0b0, 0x1599a5e0b2, 0x105c119e0, 0x1599a5e0b6, 0x1a2030452a6, 0x105c119e8, 0x1a307c55b2e, 0x1599a5e0a6, 0x1ee3f47bc8e, 0x1a203045286, 0x400808, 0x105c119a8, 0x1a3038573a6, 0x1a307c55bae, 0x4d2882a520, 0x1599a5e1a6, 0x1ffbaa0b720, 0x1ee3f47be8e, 0x4d68c22528, 0x1a203045686, 0x200006, 0x400008, 0x1b79a21b200, 0x105c109a8, 0x1ef3886a526, 0x1a3038553a6, 0x1b692209200, 0x1a307c51bae, 0x5d99a4e1a6, 0x4d28822520, 0x185e109ae, 0x1599a4e1a6, 0x4e3f43be88, 0x1ffbaa2b720, 0x4000000000, 0x1ee3f43be8e, 0x18000000006, 0x4d68ca2528, 0xa203145680, 0x1a203145686});\n+typedef Field<uint64_t, 41, 9, StatTable41, &SQR_TABLE_41, &SQR2_TABLE_41, &SQR4_TABLE_41, &SQR8_TABLE_41, &SQR16_TABLE_41, &QRT_TABLE_41, IdTrans, &ID_TRANS, &ID_TRANS> Field41;\n+typedef FieldTri<uint64_t, 41, 3, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_41, &SQR2_TABLE_41, &SQR4_TABLE_41, &SQR8_TABLE_41, &SQR16_TABLE_41, &QRT_TABLE_41, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri41;\n+\n+// 42 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6> StatTable42;\n+constexpr StatTable42 SQR_TABLE_42({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x810000000, 0x2040000000, 0x8100000000, 0x20400000000, 0x1000000102, 0x4000000408, 0x10000001020});\n+constexpr StatTable42 SQR2_TABLE_42({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x204, 0x2040, 0x20400, 0x204000, 0x2040000, 0x20400000, 0x204000000, 0x2040000000, 0x20400000000, 0x4000000408, 0x4001, 0x40010, 0x400100, 0x4001000, 0x40010000, 0x400100000, 0x4001000000, 0x10000081, 0x100000810, 0x1000008100, 0x10000081000, 0x810204, 0x8102040, 0x81020400, 0x810204000, 0x8102040000, 0x1020400102, 0x10204001020, 0x2040010004, 0x20400100040, 0x4001000008});\n+constexpr StatTable42 SQR4_TABLE_42({0x1, 0x10000, 0x100000000, 0x2040, 0x20400000, 0x4000000408, 0x4001000, 0x10000081, 0x810204, 0x8102040000, 0x20400100040, 0x1000000100, 0x1020400, 0x10204000000, 0x200001, 0x2000010000, 0x100040800, 0x408002040, 0x20408002, 0x4080020408, 0x204000020, 0x204001, 0x2040010000, 0x100040010, 0x400102040, 0x1020408100, 0x4081020008, 0x10200000020, 0x80, 0x800000, 0x8000000000, 0x102000, 0x1020000000, 0x20008, 0x200080000, 0x800004080, 0x40810200, 0x8102000810, 0x20008000040, 0x8102, 0x81020000, 0x10200001020});\n+constexpr StatTable42 SQR8_TABLE_42({0x1, 0x100040800, 0x1020000000, 0x10200001000, 0x2040810000, 0x408102040, 0x4080000408, 0x10000000, 0x8002040810, 0x20008000, 0x10200080000, 0x40000004, 0x20408000040, 0x4000020000, 0x204000, 0x8002040010, 0x408102, 0x200081020, 0x40810000, 0x2000, 0x81000408, 0x4001, 0x2040010, 0x1020008002, 0x10204081020, 0x800004, 0x20000000000, 0x4081000400, 0x10000081, 0x100040010, 0x8102, 0x10000000020, 0x40010200, 0x408000000, 0x4080000400, 0x810204000, 0x102040810, 0x1020000102, 0x4000000, 0x2000810204, 0x8002000, 0x4080020000});\n+constexpr StatTable42 SQR16_TABLE_42({0x1, 0x40800204, 0x2000800, 0x20008002040, 0x408100, 0x20000, 0x10004081020, 0x10000081, 0x40010204, 0x8102000000, 0x400000000, 0x1020008102, 0x1020408, 0x204081020, 0x200001, 0x10200, 0x102000010, 0x20408100000, 0x1020408002, 0x4000020000, 0x204000000, 0x204001, 0x2000800004, 0x8100000010, 0x400102000, 0x8002, 0x4080020000, 0x10000001000, 0x80, 0x2040010200, 0x100040000, 0x400100040, 0x20408000, 0x1000000, 0x204080020, 0x800004080, 0x2000810200, 0x8100000810, 0x20000000000, 0x1000408002, 0x81020400, 0x10204081000});\n+constexpr StatTable42 QRT_TABLE_42({0x810200080, 0x120810806, 0x120810804, 0x1068c1a1000, 0x120810800, 0x34005023008, 0x1068c1a1008, 0x800004080, 0x120810810, 0x162818a10, 0x34005023028, 0x42408a14, 0x1068c1a1048, 0x1001040, 0x800004000, 0xb120808906, 0x120810910, 0x34000020068, 0x162818810, 0x68c021400, 0x34005023428, 0x10004000, 0x42408214, 0x162418214, 0x1068c1a0048, 0xb002018116, 0x1003040, 0x10008180448, 0x800000000, 0x62c08b04, 0xb120800906, 0x2408d1a3060, 0x120800910, 0x34401003028, 0x34000000068, 0, 0x162858810, 0xa042058116, 0x68c0a1400, 0x8162858806, 0x34005123428, 0x3068c0a1468});\n+typedef Field<uint64_t, 42, 129, StatTable42, &SQR_TABLE_42, &SQR2_TABLE_42, &SQR4_TABLE_42, &SQR8_TABLE_42, &SQR16_TABLE_42, &QRT_TABLE_42, IdTrans, &ID_TRANS, &ID_TRANS> Field42;\n+typedef FieldTri<uint64_t, 42, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_42, &SQR2_TABLE_42, &SQR4_TABLE_42, &SQR8_TABLE_42, &SQR16_TABLE_42, &QRT_TABLE_42, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri42;\n+\n+// 43 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5, 5> StatTable43;\n+constexpr StatTable43 SQR_TABLE_43({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0xb2, 0x2c8, 0xb20, 0x2c80, 0xb200, 0x2c800, 0xb2000, 0x2c8000, 0xb20000, 0x2c80000, 0xb200000, 0x2c800000, 0xb2000000, 0x2c8000000, 0xb20000000, 0x2c80000000, 0xb200000000, 0x2c800000000, 0x32000000059, 0x4800000013d, 0x20000000446});\n+constexpr StatTable43 SQR2_TABLE_43({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0xb2, 0xb20, 0xb200, 0xb2000, 0xb20000, 0xb200000, 0xb2000000, 0xb20000000, 0xb200000000, 0x32000000059, 0x20000000446, 0x4504, 0x45040, 0x450400, 0x4504000, 0x45040000, 0x450400000, 0x4504000000, 0x45040000000, 0x504000002c8, 0x4000002efa, 0x4000002efa0, 0x2ef8c8, 0x2ef8c80, 0x2ef8c800, 0x2ef8c8000, 0x2ef8c80000, 0x2ef8c800000, 0x6f8c800013d, 0x78c80001025, 0xc800010117, 0x48000101129});\n+constexpr StatTable43 SQR4_TABLE_43({0x1, 0x10000, 0x100000000, 0xb20, 0xb200000, 0x32000000059, 0x450400, 0x4504000000, 0x4000002efa0, 0x2ef8c8000, 0x78c80001025, 0x10110010, 0x11001000b2, 0x1000b2b920, 0xb2b920b200, 0x120b204545f, 0x20454554046, 0x45540506efa, 0x506ed4df68, 0x6d4df6a79f5, 0x76a79c80133, 0x1c801010007, 0x101000b2100, 0xb210b2b20, 0x10b2b204504, 0x320450f655d, 0x50f654106c8, 0x54106efcb4c, 0x6efcb696320, 0x369631c93e1, 0x31c93ff9d8c, 0x3ff9d91a2a2, 0x591a2b9839b, 0x2b983b98dd4, 0x3b98dc651b0, 0x5c651a971e9, 0x1a971c9c0ba, 0x1c9c0b5853e, 0xb585322d78, 0x5322d7c6430, 0x57c6416617d, 0x4166159c82c, 0x159c8000b6c});\n+constexpr StatTable43 SQR8_TABLE_43({0x1, 0x20454554046, 0x591a2b9839b, 0x722ff9f6fe9, 0x6a269c1eb12, 0xa3ce9f234e, 0x4d9ba8aae0b, 0x392cf0cf99b, 0x465f8594525, 0x4f9c1fb1524, 0x3b1a1dd441c, 0x381edd42255, 0x37a599424b, 0x554caee8670, 0x5335bb91d81, 0x69288c8a1a3, 0x3df2b6e68e5, 0x75330d31d56, 0x51a604b090c, 0x32e0d5a7ca3, 0x41eb9d4896e, 0x633e2855c9f, 0x4780d70e32f, 0x73b0cd728c3, 0x16627402bad, 0x4418f2a818a, 0x5cdd06cf7e5, 0x2a8da97a3ae, 0x446864a8976, 0x5a7bcbd45ea, 0x4034a4b8b04, 0x6bdaac9c5fa, 0x18769ce3a67, 0x560278257c, 0x41c06d6b64c, 0x69f6f61bd4b, 0x16cc45f84fd, 0x53f6b42f0f0, 0x6cac3d234f3, 0x1f94e8f24d5, 0x319342c7148, 0x8685bca86d, 0x6b694a6ea66});\n+constexpr StatTable43 SQR16_TABLE_43({0x1, 0x1ce77599049, 0x191715250a, 0xc1573d8dff, 0x118e73ab5e4, 0x4b6a83225fe, 0x72b4bc8e0f5, 0x4a4b2b6bb02, 0x66daf4741e9, 0x50baba19898, 0x5eb38771912, 0x6fb458aad3c, 0x5ce3b10bde9, 0x5575f3498f0, 0x5f075aa8a0a, 0x41d0aa8ee20, 0x609e3c78c28, 0xe2e45a8018, 0x523ac062837, 0x738388a569d, 0x6616ec46da9, 0x1a75cc16d96, 0x49b0b43bbc3, 0x400416b3c9a, 0x25813f41ffe, 0x309fdb9d0bc, 0x489f45b2cbf, 0xa141f4f88e, 0x739e0d11fb3, 0x44971f51cc0, 0x6490576e60e, 0x6c6674c5355, 0x6978126a4e1, 0x3d04eae5a5, 0x312eed633f2, 0x1de4b98d6b9, 0x118a106fb0a, 0x26dae025f4, 0x5c179312ebb, 0x75870ef1921, 0x60e9fed95c0, 0x209ab92427a, 0x1c5014a1937});\n+constexpr StatTable43 QRT_TABLE_43({0x2bccc2d6f6c, 0x4bccc2d6f54, 0x4bccc2d6f56, 0x7cc7bc61df0, 0x4bccc2d6f52, 0x7d13b404b10, 0x7cc7bc61df8, 0x37456e9ac5a, 0x4bccc2d6f42, 0x4e042c6a6, 0x7d13b404b30, 0x4a56de9ef4c, 0x7cc7bc61db8, 0x14bc18d8e, 0x37456e9acda, 0x7c89f84fb1e, 0x4bccc2d6e42, 0x7ffae40d210, 0x4e042c4a6, 0x366f45dd06, 0x7d13b404f30, 0x496fcaf8cca, 0x4a56de9e74c, 0x370b62b6af4, 0x7cc7bc60db8, 0x1498185a8, 0x14bc1ad8e, 0x7e602c46a98, 0x37456e9ecda, 0x36ccc2c6e74, 0x7c89f847b1e, 0x7e27d06d516, 0x4bccc2c6e42, 0x7f93302c396, 0x7ffae42d210, 0x3dd3440706, 0x4e046c4a6, 0x78bbc09da36, 0x366f4ddd06, 0, 0x7d13b504f30, 0x8bbc09da00, 0x496fc8f8cca});\n+typedef Field<uint64_t, 43, 89, StatTable43, &SQR_TABLE_43, &SQR2_TABLE_43, &SQR4_TABLE_43, &SQR8_TABLE_43, &SQR16_TABLE_43, &QRT_TABLE_43, IdTrans, &ID_TRANS, &ID_TRANS> Field43;\n+\n+// 44 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5> StatTable44;\n+constexpr StatTable44 SQR_TABLE_44({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x8400, 0x21000, 0x84000, 0x210000, 0x840000, 0x2100000, 0x8400000, 0x21000000, 0x84000000, 0x210000000, 0x840000000, 0x2100000000, 0x8400000000, 0x21000000000, 0x84000000000, 0x10000000042, 0x40000000108});\n+constexpr StatTable44 SQR2_TABLE_44({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x21, 0x210, 0x2100, 0x21000, 0x210000, 0x2100000, 0x21000000, 0x210000000, 0x2100000000, 0x21000000000, 0x10000000042, 0x401, 0x4010, 0x40100, 0x401000, 0x4010000, 0x40100000, 0x401000000, 0x4010000000, 0x40100000000, 0x1000000084, 0x10000000840, 0x8421, 0x84210, 0x842100, 0x8421000, 0x84210000, 0x842100000, 0x8421000000, 0x84210000000, 0x42100000108, 0x21000001004, 0x10000010002});\n+constexpr StatTable44 SQR4_TABLE_44({0x1, 0x10000, 0x100000000, 0x210, 0x2100000, 0x21000000000, 0x40100, 0x401000000, 0x10000000840, 0x8421000, 0x84210000000, 0x100001, 0x1000010000, 0x100002100, 0x21000210, 0x10002100042, 0x21000401000, 0x4010040100, 0x401008421, 0x10084210840, 0x42108421108, 0x84211000010, 0x10000000001, 0x31000, 0x310000000, 0x611, 0x6110000, 0x61100000000, 0xc4310, 0xc43100000, 0x31000001844, 0x18421100, 0x84211000021, 0x10000310001, 0x3100031000, 0x310006110, 0x61100611, 0x110061100c6, 0x61100c43100, 0xc4310c4310, 0x10c43118423, 0x31184210844, 0x42108421218, 0x84212100010});\n+constexpr StatTable44 SQR8_TABLE_44({0x1, 0x21000401000, 0x84211000021, 0xa521000, 0x42108421719, 0x311e5310e55, 0x10401008c61, 0x3210031000, 0x10c43058522, 0x74110050101, 0xf5312e97201, 0x42108421109, 0x21061501611, 0x94311002961, 0xf59421000, 0x52d4b56923a, 0x201e5300e54, 0x71501c8fe71, 0xb6002131043, 0xb5e4c168432, 0xb320f5619ae, 0xf5000f97201, 0x10c43118422, 0x24010451100, 0x942113d4330, 0x8421a521001, 0x6310e130719, 0xf72fc731c6c, 0x4ae739631, 0x70008417e4d, 0x20ca6358b77, 0x64110094a51, 0xd4002e97200, 0xf7f5a13853a, 0xb12664417f6, 0x843322d6860, 0xf7c4100194d, 0x7382d17842b, 0xf67fd71a10c, 0x6efcca4b731, 0xf4e5901ea2d, 0xcb8278a46, 0xa32050401ee, 0xb7218bb6518});\n+constexpr StatTable44 SQR16_TABLE_44({0x1, 0xc6cdb660138, 0x13de5a69a7b, 0x80bcafe7981, 0x60eb6f976d1, 0x677fbef6cce, 0x1549bb4cdec, 0x3b1ddf6859, 0xc01b8da28a6, 0xf3e11efbf8c, 0xd3e6faf8ee3, 0xa3dbc5712c8, 0x72361d7ca84, 0xe59e509337d, 0x15fca12a6f4, 0x33ce445498c, 0x44406de91fb, 0x9784b690571, 0xb0fb81753af, 0xb53a7c2c977, 0x34fbd3dba9b, 0xc758c22e647, 0xd5ff69aa469, 0x41e6d42b47d, 0xa4d1a3d02e7, 0x365db54ae9f, 0xd2293b8770b, 0xf1bf95c7746, 0x337fbe1d950, 0x726879e26a7, 0xa4be5ec2171, 0x7080da9df82, 0x7560017ce2, 0xd03997e34ae, 0x27ad4309a78, 0xb7b0ead892b, 0xf45bedb915d, 0xc4f0e25a52c, 0xe774a9d7fe8, 0xece6c1d7a26, 0xf20ea9ab655, 0x159bb624dc2, 0x12f2780b45f, 0x840cc52f19d});\n+constexpr StatTable44 QRT_TABLE_44({0xf05334f4f6e, 0x4002016, 0x4002014, 0xf04350e6246, 0x4002010, 0x4935b379a26, 0xf04350e624e, 0xf84250c228e, 0x4002000, 0xf04300e521e, 0x4935b379a06, 0xb966838dd48, 0xf04350e620e, 0xf7b8b80feda, 0xf84250c220e, 0xf972e097d5e, 0x4002100, 0x8000020000, 0xf04300e501e, 0x430025000, 0x4935b379e06, 0xf976a09dc5e, 0xb966838d548, 0xf84218c029a, 0xf04350e720e, 0x4925f36bf06, 0xf7b8b80deda, 0xb047d3ee758, 0xf84250c620e, 0xf80350e720e, 0xf972e09fd5e, 0x8091825284, 0x4012100, 0x9015063210, 0x8000000000, 0xff31a028c5e, 0xf04300a501e, 0x44340b7100, 0x4300a5000, 0, 0x4935b279e06, 0xa976b2dce18, 0xf976a29dc5e, 0x8935b279e18});\n+typedef Field<uint64_t, 44, 33, StatTable44, &SQR_TABLE_44, &SQR2_TABLE_44, &SQR4_TABLE_44, &SQR8_TABLE_44, &SQR16_TABLE_44, &QRT_TABLE_44, IdTrans, &ID_TRANS, &ID_TRANS> Field44;\n+typedef FieldTri<uint64_t, 44, 5, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5>, &SQR_TABLE_44, &SQR2_TABLE_44, &SQR4_TABLE_44, &SQR8_TABLE_44, &SQR16_TABLE_44, &QRT_TABLE_44, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri44;\n+\n+// 45 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5> StatTable45;\n+constexpr StatTable45 SQR_TABLE_45({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x36, 0xd8, 0x360, 0xd80, 0x3600, 0xd800, 0x36000, 0xd8000, 0x360000, 0xd80000, 0x3600000, 0xd800000, 0x36000000, 0xd8000000, 0x360000000, 0xd80000000, 0x3600000000, 0xd800000000, 0x36000000000, 0xd8000000000, 0x16000000001b, 0x18000000005a});\n+constexpr StatTable45 SQR2_TABLE_45({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0xd8, 0xd80, 0xd800, 0xd8000, 0xd80000, 0xd800000, 0xd8000000, 0xd80000000, 0xd800000000, 0xd8000000000, 0x18000000005a, 0x514, 0x5140, 0x51400, 0x514000, 0x5140000, 0x51400000, 0x514000000, 0x5140000000, 0x51400000000, 0x114000000036, 0x1400000003b8, 0x3b6e, 0x3b6e0, 0x3b6e00, 0x3b6e000, 0x3b6e0000, 0x3b6e00000, 0x3b6e000000, 0x3b6e0000000, 0x1b6e0000001b, 0x16e00000011f, 0xe0000001105});\n+constexpr StatTable45 SQR4_TABLE_45({0x1, 0x10000, 0x100000000, 0xd8, 0xd80000, 0xd800000000, 0x5140, 0x51400000, 0x114000000036, 0x3b6e00, 0x3b6e000000, 0xe0000001105, 0x11011000, 0x110110000000, 0x1000000d58d8, 0xd58d58000, 0x18d58000054e, 0x5451454, 0x54514540000, 0x145400038db8, 0x38db6d8e0, 0xdb6d8e00104, 0x18e00101000a, 0x10100010100, 0x10100d8d8, 0x100d8d800d8, 0x18d800d8d85a, 0xd8d8511140, 0x18511140511a, 0x114051117b58, 0x11117b556e36, 0x1b556e3b5575, 0xe3b557f1015, 0x157f1011011e, 0x101101101c48, 0x1101c458d58, 0x1c458d58d580, 0xd58d58815d4, 0x158815d1451a, 0x15d1451452c0, 0x51452ce6f6e, 0x12ce6f6db6d6, 0xf6db6da6e3d, 0x16da6e39e00f, 0xe39e00000dd});\n+constexpr StatTable45 SQR8_TABLE_45({0x1, 0x18d58000054e, 0xe3b557f1015, 0x51985198, 0xdb68cb55452, 0x1d0cc1d84f02, 0x140110c19ae, 0x11a16a14e7fe, 0x1e7ca7c62aa9, 0xe0eae26629b, 0x12182bee80ab, 0x1a38a68f28d3, 0x8581419c8c, 0x1d47f6f12ebc, 0x19fd34c3806e, 0x12ddba59f3cd, 0x10fa07f12a0e, 0x1d93eb544486, 0x1cf42cd119be, 0x1ff32d4b62c3, 0xf34ae031191, 0xada837715bf, 0xd368a753f92, 0x2ba87b17a03, 0x10374c3e4088, 0x1a6f539c11bd, 0x16548a5473c7, 0x1eb70011a8c9, 0x1ee5435ba1a3, 0x1173c0537680, 0xa1a3668dd6b, 0x119faad25e8, 0xd3909240e00, 0x1b560d018881, 0x127ecb9095ed, 0x306b507e701, 0x12b934c21ea3, 0x1a9d258c5b8b, 0x10452fbf0b1c, 0xae92fee120d, 0x183eb4b419fa, 0xc24d2391313, 0x4e6c4746f6, 0x2815fe7c395, 0xe4ab383747f});\n+constexpr StatTable45 SQR16_TABLE_45({0x1, 0x14af92df932, 0x484e0190bdc, 0xda69889e16e, 0xcf70dfdb150, 0x18c6743571a8, 0x1b2c3ad7fa79, 0x5f0cbe204f6, 0xee973392a75, 0x3e86ef79673, 0xb2a9bef7181, 0x19b5347ff116, 0x1cae0ec79856, 0x69093f18f81, 0x1964382be09a, 0x92c894b073e, 0x1d99d2922eb2, 0x647905ad0eb, 0x1695971acdd3, 0x8f3292bc8c4, 0x1ee4057ad94, 0x17f02dc60e01, 0x1bb8e05ab4d5, 0x14de5d2a05d6, 0x13a019a02983, 0xcd7097c3616, 0x1bd798639b8f, 0x1cf0ca5ac7b2, 0xa93b983cf05, 0x159a955a2aa8, 0x69e5ba33397, 0x3a6b3392237, 0x26aeab71e13, 0x26fe04d38b9, 0x1fa9df0e8c45, 0x104e85c234b0, 0x1792853f8767, 0x81573b15f20, 0x127d6bfb06d3, 0x8110e6957e8, 0x11f59cbcc110, 0xad68264cad8, 0x61438575b35, 0x56e4446dc, 0x1cc9cb28b150});\n+constexpr StatTable45 QRT_TABLE_45({0xede34e3e0fc, 0x1554148191aa, 0x1554148191a8, 0x1767be1dc4a6, 0x1554148191ac, 0x26bd4931492, 0x1767be1dc4ae, 0x233ab9c454a, 0x1554148191bc, 0x16939e8bb3dc, 0x26bd49314b2, 0x3c6ca8bac52, 0x1767be1dc4ee, 0x16caa5054c16, 0x233ab9c45ca, 0x14a1649628bc, 0x1554148190bc, 0x3c382881252, 0x16939e8bb1dc, 0x3c7ca0aa160, 0x26bd49310b2, 0x27f40158000, 0x3c6ca8ba452, 0x173fc092853c, 0x1767be1dd4ee, 0x16cbe284f25c, 0x16caa5056c16, 0x155559002f96, 0x233ab9c05ca, 0x26eb8908b32, 0x14a16496a8bc, 0x15440885333c, 0x1554148090bc, 0x17d60702e0, 0x3c3828a1252, 0x54548d10b2, 0x16939e8fb1dc, 0x3ac1e81b1d2, 0x3c7ca02a160, 0x166bd48310bc, 0x26bd48310b2, 0, 0x27f40358000, 0x10000000000e, 0x3c6cacba452});\n+typedef Field<uint64_t, 45, 27, StatTable45, &SQR_TABLE_45, &SQR2_TABLE_45, &SQR4_TABLE_45, &SQR8_TABLE_45, &SQR16_TABLE_45, &QRT_TABLE_45, IdTrans, &ID_TRANS, &ID_TRANS> Field45;\n+\n+// 46 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5> StatTableTRI46;\n+constexpr StatTableTRI46 SQR_TABLE_TRI46({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000});\n+constexpr StatTableTRI46 SQR2_TABLE_TRI46({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0xc00000, 0xc000000, 0xc0000000, 0xc00000000, 0xc000000000, 0xc0000000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x50000000, 0x500000000, 0x5000000000, 0x50000000000, 0x100000000003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000, 0x3c00000, 0x3c000000, 0x3c0000000, 0x3c00000000, 0x3c000000000, 0x3c0000000000});\n+constexpr StatTableTRI46 SQR4_TABLE_TRI46({0x1, 0x10000, 0x100000000, 0xc, 0xc0000, 0xc00000000, 0x50, 0x500000, 0x5000000000, 0x3c0, 0x3c00000, 0x3c000000000, 0x1100, 0x11000000, 0x110000000000, 0xcc00, 0xcc000000, 0xc0000000005, 0x55000, 0x550000000, 0x10000000003f, 0x3fc000, 0x3fc0000000, 0x101, 0x1010000, 0x10100000000, 0xc0c, 0xc0c0000, 0xc0c00000000, 0x5050, 0x50500000, 0x105000000003, 0x3c3c0, 0x3c3c00000, 0x3c000000011, 0x111100, 0x1111000000, 0x1100000000cc, 0xcccc00, 0xcccc000000, 0xc0000000555, 0x5555000, 0x55550000000, 0x100000003fff, 0x3fffc000, 0x3fffc0000000});\n+constexpr StatTableTRI46 SQR8_TABLE_TRI46({0x1, 0xcc000000, 0x3c3c0, 0x10000000c, 0x550055000, 0x3c000111111, 0xc0050, 0x103fc000003f, 0x1111cccc00, 0x5000500390, 0x13ec1010101, 0xcccc9999955, 0x5000001100, 0xc0c01010000, 0xc003fffc555, 0x12c003c0cc00, 0x10505c5c0c0f, 0x155450003ffe, 0x1100cc054100, 0xfcc5053c3d1, 0xd3ff2c00d, 0xd059c3a5c3a, 0x2828282d21e, 0x5000000001, 0xcd010000, 0xc000003c695, 0x3c103c0000c, 0x55c095c0c, 0x169550112eee, 0x1100000c1150, 0x1c339050003f, 0x112e320c01, 0x1d50cc50cf95, 0x116d5292c2c2, 0xcccc9959954, 0x1050cc00113f, 0xc1d1002c3c0, 0xc013fafc509, 0x12fa93c59d01, 0x135c9081d11e, 0x150453cc3fae, 0x13f0d044d33, 0x688119f0a84, 0x39d2d62d29d, 0x3751370167, 0x24e4e4e4b4b4});\n+constexpr StatTableTRI46 SQR16_TABLE_TRI46({0x1, 0x1fe6e1ab503e, 0xbbae1f3f55b, 0x1d51cc530c59, 0x163a6a22e14a, 0x5847feb7f81, 0x1ec9cc5fd281, 0xf6cc7b80c70, 0x8f46b31e374, 0xc13bf2ed37d, 0x148a1595bffe, 0x581ad245849, 0x1ea6920b83c1, 0x9d9a8355c7d, 0x6bcf393d5ff, 0x1d4e245085c0, 0x602a8c5e62c, 0x1922dd69197f, 0x7945d3a2aad, 0xf82a823f768, 0xdd24665599b, 0x13b43f6a29d, 0x4df114f238d, 0x1ee783c75ec0, 0xfb670f65c31, 0xf855dc973d2, 0x61ede5f2651, 0x6c1a1266403, 0x1f66ed2a96a, 0xbbbdf683148, 0x1ecc83e160c0, 0x1a2778c4bc0c, 0x10e154273753, 0x1704f8873c23, 0x1b4d3172da99, 0x2b3be805044, 0x5bb08848b9d, 0x1967d2b99be5, 0x7fa55262740, 0xe761a27cc28, 0x17dedd7181b5, 0x155b0344714a, 0x15187b38816e, 0xc5a679b5300, 0x1096cbf94c5d, 0x3f6b3cc122da});\n+constexpr StatTableTRI46 QRT_TABLE_TRI46({0x211c4fd486ba, 0x100104a, 0x1001048, 0x104d0492d4, 0x100104c, 0x20005040c820, 0x104d0492dc, 0x40008080, 0x100105c, 0x24835068ce00, 0x20005040c800, 0x200000400800, 0x104d04929c, 0x100904325c, 0x40008000, 0x25da9e77daf0, 0x100115c, 0x1184e1696f0, 0x24835068cc00, 0x24825169dd5c, 0x20005040cc00, 0x3ea3241c60c0, 0x200000400000, 0x211c4e5496f0, 0x104d04829c, 0x20005340d86c, 0x100904125c, 0x24835968de5c, 0x4000c000, 0x6400a0c0, 0x25da9e775af0, 0x118cf1687ac, 0x101115c, 0x1ea1745cacc0, 0x1184e1496f0, 0x20181e445af0, 0x2483506ccc00, 0x20240060c0, 0x24825161dd5c, 0x1e21755dbd9c, 0x20005050cc00, 0x26a3746cacc0, 0x3ea3243c60c0, 0xea3243c60c0, 0x200000000000, 0});\n+typedef FieldTri<uint64_t, 46, 1, StatTableTRI46, &SQR_TABLE_TRI46, &SQR2_TABLE_TRI46, &SQR4_TABLE_TRI46, &SQR8_TABLE_TRI46, &SQR16_TABLE_TRI46, &QRT_TABLE_TRI46, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri46;\n+\n+// 47 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5> StatTable47;\n+constexpr StatTable47 SQR_TABLE_47({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x1080000, 0x4200000, 0x10800000, 0x42000000, 0x108000000, 0x420000000, 0x1080000000, 0x4200000000, 0x10800000000, 0x42000000000, 0x108000000000, 0x420000000000, 0x80000000042, 0x200000000108});\n+constexpr StatTable47 SQR2_TABLE_47({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x42, 0x420, 0x4200, 0x42000, 0x420000, 0x4200000, 0x42000000, 0x420000000, 0x4200000000, 0x42000000000, 0x420000000000, 0x200000000108, 0x1004, 0x10040, 0x100400, 0x1004000, 0x10040000, 0x100400000, 0x1004000000, 0x10040000000, 0x100400000000, 0x4000000042, 0x40000000420, 0x400000004200, 0x42108, 0x421080, 0x4210800, 0x42108000, 0x421080000, 0x4210800000, 0x42108000000, 0x421080000000, 0x210800000108, 0x108000001004, 0x80000010002});\n+constexpr StatTable47 SQR4_TABLE_47({0x1, 0x10000, 0x100000000, 0x42, 0x420000, 0x4200000000, 0x1004, 0x10040000, 0x100400000000, 0x42108, 0x421080000, 0x210800000108, 0x1000010, 0x10000100000, 0x1000004200, 0x42000420, 0x420004200000, 0x42000100400, 0x1004010040, 0x40100400420, 0x4004210842, 0x42108421080, 0x84210810002, 0x108100000004, 0x142, 0x1420000, 0x14200000000, 0x5204, 0x52040000, 0x520400000000, 0x142508, 0x1425080000, 0x250800000528, 0x5210810, 0x52108100000, 0x81000014202, 0x142001420, 0x420014200042, 0x142000520400, 0x5204052040, 0x40520401424, 0x20401425094a, 0x142509425080, 0x9425085210a, 0x508521084204, 0x21084210804a, 0x421080420010});\n+constexpr StatTable47 SQR8_TABLE_47({0x1, 0x420004200000, 0x250800000528, 0x11004, 0xc6210910402, 0x142005730c10, 0x101000010, 0x1056050040, 0x55a429184204, 0x111404110002, 0x532408500562, 0x3d196251d62e, 0x420142, 0x44524611c66, 0x1142047728, 0x46205e2508, 0x67339c2519da, 0x5661384b5880, 0x434346200424, 0x392938cb55aa, 0x724b0c31058c, 0x7f4f1cf703fc, 0x4fe303d32d1e, 0x75de250d676c, 0x100400011004, 0xc6210910540, 0x102525331834, 0x1101046318, 0x1057532548, 0x37f4bd7f4b5e, 0x115021380840, 0x52674a501142, 0x297a4a1b86ae, 0x666b0c2010ca, 0x776839031b88, 0x4b5316a05622, 0x254e215e2030, 0x6733ce2009de, 0xa8609d21e86, 0x567347420874, 0x6e0d31db55ba, 0x4357182485c4, 0x2afb35ef02ba, 0x5af227961c30, 0x64faad1b0116, 0x2d5d2527ef40, 0x6e27e3bc1978});\n+constexpr StatTable47 SQR16_TABLE_47({0x1, 0x421ac25c8774, 0x30581389b510, 0x423b9c671db0, 0xa4537914208, 0x38f9be0dbf38, 0x351c5a8b92a8, 0xc38b9920da2, 0x508d34674f2a, 0x1f8c359a6b76, 0x5ac4bf86daaa, 0x51d6a6616df2, 0xe2717a0378a, 0x13353e783e6e, 0x55a55ac09ec6, 0x3f17cde43402, 0x760584b64b6c, 0x6acbecc99a02, 0x16be80e45b76, 0x2d5069e0005a, 0x3388f5759aa6, 0x2f98f891f4e2, 0x7657f368d924, 0x48f81e34f5b0, 0x51a9087f072e, 0x1de01ba9001c, 0x560b4b374bfc, 0x13f576988ff0, 0x3673cd322294, 0x595959f7c5fe, 0xbfa426eb4a4, 0x2b68fd7c02c2, 0x2a3c1437913a, 0x6e4b179fcf9e, 0x69ddf09bbdee, 0x7b91973d5e52, 0x1329cefd9514, 0x6a5f380b7ab0, 0x48e6620529c4, 0x60589a4b95b6, 0x5e4bd1d1aa34, 0x4b1ec7645cc2, 0x5cfb8785aec6, 0x34e47cf10c3a, 0x7b6c363eee10, 0x1dc52d768b32, 0x3585af9113a0});\n+constexpr StatTable47 QRT_TABLE_47({0, 0x1001040, 0x1001042, 0x1047043076, 0x1001046, 0x112471c241e, 0x104704307e, 0x4304e052168, 0x1001056, 0x10004000, 0x112471c243e, 0x172a09c949d6, 0x104704303e, 0x4002020, 0x4304e0521e8, 0x5400e220, 0x1001156, 0x172b08c85080, 0x10004200, 0x41200b0800, 0x112471c203e, 0x172f0cca50a0, 0x172a09c941d6, 0x7eb88a11c1d6, 0x104704203e, 0x1044042020, 0x4000020, 0x42001011156, 0x4304e0561e8, 0x172a28c95880, 0x54006220, 0x112931cc21e, 0x1011156, 0x53670f283e, 0x172b08ca5080, 0x7a80c414a03e, 0x10044200, 0x40000000000, 0x4120030800, 0x1928318801e, 0x112470c203e, 0x799283188000, 0x172f0cea50a0, 0x1eb88a91c1c8, 0x172a098941d6, 0x3ea8cc95e1f6, 0x7eb88a91c1d6});\n+typedef Field<uint64_t, 47, 33, StatTable47, &SQR_TABLE_47, &SQR2_TABLE_47, &SQR4_TABLE_47, &SQR8_TABLE_47, &SQR16_TABLE_47, &QRT_TABLE_47, IdTrans, &ID_TRANS, &ID_TRANS> Field47;\n+typedef FieldTri<uint64_t, 47, 5, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_47, &SQR2_TABLE_47, &SQR4_TABLE_47, &SQR8_TABLE_47, &SQR16_TABLE_47, &QRT_TABLE_47, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri47;\n+\n+// 48 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6> StatTable48;\n+constexpr StatTable48 SQR_TABLE_48({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x2d, 0xb4, 0x2d0, 0xb40, 0x2d00, 0xb400, 0x2d000, 0xb4000, 0x2d0000, 0xb40000, 0x2d00000, 0xb400000, 0x2d000000, 0xb4000000, 0x2d0000000, 0xb40000000, 0x2d00000000, 0xb400000000, 0x2d000000000, 0xb4000000000, 0x2d0000000000, 0xb40000000000, 0xd0000000005a, 0x40000000011f});\n+constexpr StatTable48 SQR2_TABLE_48({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x2d, 0x2d0, 0x2d00, 0x2d000, 0x2d0000, 0x2d00000, 0x2d000000, 0x2d0000000, 0x2d00000000, 0x2d000000000, 0x2d0000000000, 0xd0000000005a, 0x451, 0x4510, 0x45100, 0x451000, 0x4510000, 0x45100000, 0x451000000, 0x4510000000, 0x45100000000, 0x451000000000, 0x5100000000b4, 0x100000000bd9, 0xbdbd, 0xbdbd0, 0xbdbd00, 0xbdbd000, 0xbdbd0000, 0xbdbd00000, 0xbdbd000000, 0xbdbd0000000, 0xbdbd00000000, 0xdbd00000011f, 0xbd0000001001, 0xd0000001010f});\n+constexpr StatTable48 SQR4_TABLE_48({0x1, 0x10000, 0x100000000, 0x2d, 0x2d0000, 0x2d00000000, 0x451, 0x4510000, 0x45100000000, 0xbdbd, 0xbdbd0000, 0xbdbd00000000, 0x101101, 0x1011010000, 0x1101000002d0, 0x2d2fd2d, 0x2d2fd2d0000, 0xfd2d0000454a, 0x45514551, 0x455145510000, 0x4551000bd0bd, 0xbd0b6d0bd, 0xd0b6d0bd011f, 0xd0bd0100011e, 0x10001010001, 0x10100012d00, 0x12d002d2d, 0x2d002d2d002d, 0x2d2d00295100, 0x2951045551, 0x5104555104e5, 0x555104ecbdb4, 0x4ecbdbd00bd, 0xbdbd00bdadbc, 0xbdadac1101, 0xadac11011001, 0x11011013c3fc, 0x1013c3fefd2d, 0xc3fefd2fd2a7, 0xfd2fd2baac36, 0xd2baac2d450b, 0xac2d45145ac2, 0x45145ad0f851, 0x5ad0f85adb64, 0xf85adb6cbd10, 0xdb6cbd0bd0a2, 0xbd0bd0bc003c, 0xd0bc002c001f});\n+constexpr StatTable48 SQR8_TABLE_48({0x1, 0x2d2fd2d0000, 0x4ecbdbd00bd, 0x2c0000002c, 0x47882d9b95ec, 0xb9eec2eefc90, 0xbd900450, 0x9734009bfc8f, 0x93070a51e9b7, 0xb9d0aa02ec00, 0x8630787dd0ab, 0x6b3468ab98c9, 0x4100001bc1bd, 0x3ffeec1692fd, 0x2e0cce80414a, 0x11a77fc95626, 0x7c9856084ffe, 0x2f41c702f193, 0xd260e95bfeeb, 0x3b86220b54eb, 0x5735c802071a, 0x44626fc7ba84, 0x2b9cda923f5b, 0xc57d0a962e45, 0xd1685001450b, 0x6d78400145b6, 0x9114412978c1, 0x7d9ece1f5b0c, 0xfd2419988960, 0xd12ac3eaeaa5, 0x7d67e75f441d, 0xf86c2ba5457c, 0x40db7617aa6a, 0x80ee292186, 0xbd0f8525d34c, 0xa87ce27ca699, 0xacf3315d7a6d, 0x1a289bca977, 0x92975374e0f1, 0x3fcf113826ab, 0xff4d9be19a5e, 0x1412e5091900, 0x82c721f22d43, 0x1d773380ff32, 0xfed661cca7b1, 0x308072e06846, 0xd3eb44e91aa0, 0x819a669cbb14});\n+constexpr StatTable48 SQR16_TABLE_48({0x1, 0x50c24311dfa9, 0xfc08c1e39482, 0xa9ff91b620a3, 0x54954a59d16c, 0xec45c0a9fb02, 0xba7004022837, 0xc1ea19828166, 0xee9a3efecffe, 0x57ed421a20bb, 0x69d387b19141, 0x9105d02d728f, 0xd2f24d4006da, 0x39195005f508, 0xd0206ff5333c, 0x8592e734a441, 0x787b36a1c435, 0x1151e6f03f85, 0xfe0429bf95ab, 0xab2b20b47651, 0x2a65fc935212, 0x7f73ae670e2e, 0x697c17f0fc4a, 0x55dc5681f013, 0xadbd09a289bc, 0x418414f64940, 0x927c737efd40, 0x38535d08fc98, 0xe811b107691c, 0x856c3bbf4cf6, 0x47e629ad3757, 0xf9c82b4b2c09, 0x64312c99e2f, 0xd4936c978dfd, 0x782ff8716675, 0xaf853e867dd7, 0x457143c1fa6d, 0x84c4dda48e91, 0xbac9aacda41e, 0x6a6e0ffb2dc1, 0xfef377f00194, 0x3a129790acc1, 0x541e49c6f92a, 0x73e821aca96d, 0x3a6f15c03f57, 0x1bf377c66f3b, 0xbff5e192fe3b, 0x346360ee74a});\n+constexpr StatTable48 QRT_TABLE_48({0xc00442c284f0, 0xc16b7fda410a, 0xc16b7fda4108, 0xada3b5c79fbe, 0xc16b7fda410c, 0x16f3c18d5b0, 0xada3b5c79fb6, 0x7090a381f64, 0xc16b7fda411c, 0xcafc15d179f8, 0x16f3c18d590, 0x6630880e534e, 0xada3b5c79ff6, 0xa13dd1f49826, 0x7090a381fe4, 0xb87560f6a74, 0xc16b7fda401c, 0xaaaaffff0012, 0xcafc15d17bf8, 0xaafd15f07bf6, 0x16f3c18d190, 0x60000020000e, 0x6630880e5b4e, 0xcb977fcb401c, 0xada3b5c78ff6, 0x6663420cad0, 0xa13dd1f4b826, 0xc0045fc2f41c, 0x7090a385fe4, 0x6762e24b834, 0xb87560fea74, 0xc6351fed241c, 0xc16b7fdb401c, 0x60065622ea7a, 0xaaaafffd0012, 0xdf9562bea74, 0xcafc15d57bf8, 0x6657ea057bea, 0xaafd15f87bf6, 0xa79329ddaa66, 0x16f3c08d190, 0xa39229f0aa66, 0x60000000000e, 0x175fb4468ad0, 0x6630884e5b4e, 0, 0xcb977f4b401c, 0x2630884e5b40});\n+typedef Field<uint64_t, 48, 45, StatTable48, &SQR_TABLE_48, &SQR2_TABLE_48, &SQR4_TABLE_48, &SQR8_TABLE_48, &SQR16_TABLE_48, &QRT_TABLE_48, IdTrans, &ID_TRANS, &ID_TRANS> Field48;\n+\n+}\n+\n+Sketch* ConstructClMul6Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 41: return new SketchImpl<Field41>(implementation, 41);\n+    case 42: return new SketchImpl<Field42>(implementation, 42);\n+    case 43: return new SketchImpl<Field43>(implementation, 43);\n+    case 44: return new SketchImpl<Field44>(implementation, 44);\n+    case 45: return new SketchImpl<Field45>(implementation, 45);\n+    case 47: return new SketchImpl<Field47>(implementation, 47);\n+    case 48: return new SketchImpl<Field48>(implementation, 48);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri6Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 41: return new SketchImpl<FieldTri41>(implementation, 41);\n+    case 42: return new SketchImpl<FieldTri42>(implementation, 42);\n+    case 44: return new SketchImpl<FieldTri44>(implementation, 44);\n+    case 46: return new SketchImpl<FieldTri46>(implementation, 46);\n+    case 47: return new SketchImpl<FieldTri47>(implementation, 47);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "cc33d745910dfdac6ba6c3a1b6adbbb6eb18fb0e",
        "filename": "src/fields/clmul_7bytes.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_7bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_7bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_7bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 49 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable49;\n+constexpr StatTable49 SQR_TABLE_49({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x402, 0x1008, 0x4020, 0x10080, 0x40200, 0x100800, 0x402000, 0x1008000, 0x4020000, 0x10080000, 0x40200000, 0x100800000, 0x402000000, 0x1008000000, 0x4020000000, 0x10080000000, 0x40200000000, 0x100800000000, 0x402000000000, 0x1008000000000, 0x20000000402, 0x80000001008, 0x200000004020, 0x800000010080});\n+constexpr StatTable49 SQR2_TABLE_49({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x1008, 0x10080, 0x100800, 0x1008000, 0x10080000, 0x100800000, 0x1008000000, 0x10080000000, 0x100800000000, 0x1008000000000, 0x80000001008, 0x800000010080, 0x100004, 0x1000040, 0x10000400, 0x100004000, 0x1000040000, 0x10000400000, 0x100004000000, 0x1000040000000, 0x400001008, 0x4000010080, 0x40000100800, 0x400001008000, 0x10080402, 0x100804020, 0x1008040200, 0x10080402000, 0x100804020000, 0x1008040200000, 0x80402001008, 0x804020010080, 0x40200100004, 0x402001000040, 0x20010000002, 0x200100000020});\n+constexpr StatTable49 SQR4_TABLE_49({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x1008000, 0x10080000000, 0x800000010080, 0x100004000, 0x1000040000000, 0x400001008000, 0x10080402000, 0x804020010080, 0x200100000020, 0x1000000001000, 0x11008000, 0x110080000000, 0x800000110880, 0x1108004000, 0x1080040001008, 0x400011008400, 0x110084402000, 0x844020110880, 0x201108040220, 0x1080402000008, 0x20001008002, 0x10080000100, 0x800001010080, 0x10100004000, 0x1000040010080, 0x400101808000, 0x1018080402000, 0x8040210100c0, 0x210100400020, 0x1004000011080, 0x11180c020, 0x11180c0200000, 0xc020011108c0, 0x11108004010, 0x1080040111088, 0x401111808400, 0x1118084403008, 0x8440311908c0, 0x311908440220, 0x108440211008c, 0x2110184c022, 0x10184c0201108, 0xc020100904c2, 0x100904024010, 0x1040240000004});\n+constexpr StatTable49 SQR8_TABLE_49({0x1, 0x800000110880, 0x210100400020, 0x1040240000004, 0x130081008002, 0x191c0a54130c8, 0x900804130890, 0x210111408020, 0x582c0402004, 0xd320910984c0, 0xb1d1ad4522e8, 0x1d80945829818, 0x1218540601128, 0x1240340000024, 0x11300c1018082, 0x193d1a4c5f0ea, 0x148a0522810, 0xe0201051c8e0, 0x2dc7c25120a8, 0x1d2205148a440, 0x33c0adc0e24a, 0x17850e987bab8, 0xa8a40071c9e0, 0x10d47d391c1a8, 0x9740b01888c2, 0x91c0e54130c8, 0x920805138892, 0x130819500b028, 0x8583c0516884, 0x1fa25934984e8, 0x1f5c2fcc5a6ec, 0x15a094483189a, 0x1014cc242300, 0xac020000582c, 0x3b05524100aa, 0x1520255145c6e, 0x4279b95aec40, 0x1f1a0951178e8, 0xbcc646004828, 0x3b055219aca8, 0x57d2fc40666e, 0xba50b987beba, 0x8aa44d913bea, 0x944717d1b9a0, 0x776562491022, 0x1701305105c4c, 0x19039cd5be842, 0x1b281d8e58082, 0x134dac80532a4});\n+constexpr StatTable49 SQR16_TABLE_49({0x1, 0x790181b552e0, 0xeb19044e00a, 0xc6bf7911f7ae, 0x447f77c1a0c4, 0x19d2a0d21c480, 0x13d4e22aadedc, 0x18fa344c8f0a6, 0x1481c1bbfde92, 0x41547e22f6e0, 0xf5ad96335088, 0xd7e4db3adaa0, 0x197fc8d7b53d0, 0x37781564b82a, 0xa52ef2139cbc, 0x153c6a0949498, 0x18d7401fc152e, 0xc4b5d8597752, 0xd15cd891aa2, 0x217903427da8, 0x13ec9e269a0e0, 0xc01720774514, 0x389aeb1d788a, 0x64a914a860a4, 0xa09aebec6188, 0x15c3239e150c8, 0x38f8fe110ce, 0xc1ea415c5006, 0x3209972f2ff0, 0x41bfc6b2ad88, 0x1ccc2fd5f73c8, 0x7bed1f863c00, 0x1a46d9b9844f4, 0x12e3ca6573ff6, 0x290c26cca98c, 0x514cb03b3b2e, 0x11168909cbc2c, 0x8e6dc910afda, 0x11311def1c440, 0x3e42d62664d8, 0x1c2bb2d75fe80, 0x2db5d58b45ca, 0x3d14059fd338, 0x109e8f457ebf8, 0x43b071b62a64, 0x185242247c010, 0x5e0c7721c092, 0x1c94950e46b82, 0x1761170f76a40});\n+constexpr StatTable49 QRT_TABLE_49({0, 0x10004196, 0x10004194, 0x5099461f080, 0x10004190, 0x40840600c20, 0x5099461f088, 0x58a56349cfde, 0x10004180, 0x48641a0c03fe, 0x40840600c00, 0x10084002848, 0x5099461f0c8, 0x4002048, 0x58a56349cf5e, 0x5088460a048, 0x10004080, 0x4c2852624dde, 0x48641a0c01fe, 0x14893129c280, 0x40840600800, 0x1eb23c323ace8, 0x10084002048, 0x48740a09417e, 0x5099461e0c8, 0x40852604d96, 0x4000048, 0x5cad2b29c37e, 0x58a563498f5e, 0x20000200, 0x50884602048, 0x10000000000, 0x10014080, 0x4c2a56624d96, 0x4c2852604dde, 0x1ee2347438ca0, 0x48641a0801fe, 0x480000000048, 0x14893121c280, 0x14091121c080, 0x40840700800, 0x1a5099561e17e, 0x1eb23c303ace8, 0x8740a894136, 0x10084402048, 0x18101c501ace8, 0x48740a89417e, 0x15dace6286f96, 0x5099561e0c8});\n+typedef Field<uint64_t, 49, 513, StatTable49, &SQR_TABLE_49, &SQR2_TABLE_49, &SQR4_TABLE_49, &SQR8_TABLE_49, &SQR16_TABLE_49, &QRT_TABLE_49, IdTrans, &ID_TRANS, &ID_TRANS> Field49;\n+typedef FieldTri<uint64_t, 49, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_49, &SQR2_TABLE_49, &SQR4_TABLE_49, &SQR8_TABLE_49, &SQR16_TABLE_49, &QRT_TABLE_49, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri49;\n+\n+// 50 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable50;\n+constexpr StatTable50 SQR_TABLE_50({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x1d, 0x74, 0x1d0, 0x740, 0x1d00, 0x7400, 0x1d000, 0x74000, 0x1d0000, 0x740000, 0x1d00000, 0x7400000, 0x1d000000, 0x74000000, 0x1d0000000, 0x740000000, 0x1d00000000, 0x7400000000, 0x1d000000000, 0x74000000000, 0x1d0000000000, 0x740000000000, 0x1d00000000000, 0x340000000001d, 0x1000000000053});\n+constexpr StatTable50 SQR2_TABLE_50({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x74, 0x740, 0x7400, 0x74000, 0x740000, 0x7400000, 0x74000000, 0x740000000, 0x7400000000, 0x74000000000, 0x740000000000, 0x340000000001d, 0x151, 0x1510, 0x15100, 0x151000, 0x1510000, 0x15100000, 0x151000000, 0x1510000000, 0x15100000000, 0x151000000000, 0x1510000000000, 0x1100000000069, 0x10000000006e4, 0x6e34, 0x6e340, 0x6e3400, 0x6e34000, 0x6e340000, 0x6e3400000, 0x6e34000000, 0x6e340000000, 0x6e3400000000, 0x2e3400000001d, 0x234000000011f, 0x3400000001118});\n+constexpr StatTable50 SQR4_TABLE_50({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x74000, 0x740000000, 0x340000000001d, 0x151000, 0x1510000000, 0x1100000000069, 0x6e3400, 0x6e34000000, 0x234000000011f, 0x1110100, 0x11101000000, 0x1010000000734, 0x7334740, 0x73347400000, 0x347400000145c, 0x14540510, 0x145405100000, 0x510000068b9, 0x68b91a34, 0x68b91a340000, 0x11a3400010106, 0x101010001, 0x1010100010000, 0x1000100074740, 0x1000747474000, 0x347474007401d, 0x340074015050d, 0x340150505101d, 0x1050510151069, 0x11015106e5a5d, 0x1106e5a5a3469, 0x25a5a346e351f, 0x2346e3510111e, 0x235101110001f, 0x111000110634, 0x1106347334, 0x1063473340074, 0x733400735301, 0x7353004541, 0x353004541014c, 0x454101446dc0, 0x101446dc1cb90, 0x6dc1cb97468d, 0x1cb97468c1a30, 0x3468c1a350009, 0x1a3500010007});\n+constexpr StatTable50 SQR8_TABLE_50({0x1, 0x7334740, 0x1050510151069, 0x3468c1a350009, 0x341624173531c, 0x245791a347b50, 0x23179d1a40682, 0x1671402235203, 0x321023818751e, 0x143ca5b716dd5, 0x171633ad257de, 0x33860681a5d1d, 0x5e572f82a317, 0x10e7512224646, 0x32d6b56300005, 0x350ab39687414, 0x25c47550c1a8a, 0x23a2e2d91533f, 0x2211af19c2381, 0x352073a863a68, 0x37f43380f0ac4, 0x233516127052a, 0x25ad4785169cf, 0x237b6a609b0b6, 0x132fd372b5dac, 0x1f311727562e, 0x345bd7e275754, 0x352fe5b3d7708, 0x259a328ca3376, 0x25101aab53ece, 0x32701d9da5ace, 0x17809a9c86099, 0x72b4752a7323, 0x202d22dc33a7c, 0x5a8c0dbc19a2, 0x14a86b37416ad, 0x5c574289fe12, 0x3627f3bf0f37b, 0x27349052a4f83, 0x2436d71033de5, 0x22fab345e0bce, 0x27ea796d5a27a, 0x1e4f33562d17, 0x31a1f9c3f2154, 0x1638db7753f96, 0x2256163f33b5f, 0x11a6ecf28882e, 0x1bd4cf35f47cc, 0x25e19aeb21e64, 0x371612d0b4dcd});\n+constexpr StatTable50 SQR16_TABLE_50({0x1, 0x14db3a1b1531f, 0x270a39b5e8c48, 0x26536a58442bd, 0x7f158d4b869e, 0x12663760f7d, 0x29634a2c8876, 0x15271f7ec5d31, 0x17fbb0726d0f0, 0x7f0f7bf826bb, 0x115135d3c7c4c, 0x348ffaaa125e5, 0x1887695a20d9, 0x25e41181c0de, 0x2670d7f17fb35, 0x356079737f513, 0x22bebda8a1574, 0x315f9649d2b50, 0x13abe45aa6ac8, 0x723d536b5242, 0x24263520a22a9, 0x15860c0156a69, 0x271d0bbeed892, 0x146920f281d19, 0x117d5d46e7991, 0x278d8273551fc, 0x15d73a9745614, 0x7e5e966bbfe0, 0x687b14e62abb, 0x178acea79fa5c, 0x3363c557e9662, 0x3153c79bf06ef, 0x15c8ff9daf7ce, 0x243b030f4617a, 0x20663fbd2383a, 0x25c5dbd448872, 0x21fc8dfbd2429, 0x229f9fb8f01b0, 0x17a180ae72359, 0x1c8e2f554ad9, 0x174596d1e774f, 0x3264c5da47f53, 0x333817d45b05c, 0x321907ec10dfd, 0x3a12b2018ada, 0x23ab0599cd08, 0x23028d60c00e5, 0x8ca05e2a1eab, 0x3537bf673a228, 0x32f8cf8611080});\n+constexpr StatTable50 QRT_TABLE_50({0xfbdfa3ae9d4c, 0x38143245a4878, 0x38143245a487a, 0x38527487e7492, 0x38143245a487e, 0x3124c61f56d2a, 0x38527487e749a, 0xfa8c91b087c0, 0x38143245a486e, 0x3eca48c6196be, 0x3124c61f56d0a, 0x380000040080a, 0x38527487e74da, 0x976b2d8b39b4, 0xfa8c91b08740, 0xfa8cd5b02724, 0x38143245a496e, 0x316291dd013fe, 0x3eca48c6194be, 0x10344122064, 0x3124c61f5690a, 0x68c5f006ee40, 0x380000040000a, 0x852749fe64d0, 0x38527487e64da, 0x37ef8e9d0e9da, 0x976b2d8b19b4, 0x37fabd1cef34a, 0xfa8c91b0c740, 0x96282d9159b4, 0xfa8cd5b0a724, 0x464a8249dd0, 0x38143245b496e, 0x37eaa8ddc94be, 0x316291dd213fe, 0x392446035690a, 0x3eca48c6594be, 0x974b258b4964, 0x103441a2064, 0x385a7c87fb4da, 0x3124c61e5690a, 0xeb8ad5d9a724, 0x68c5f026ee40, 0x3724c61e5690a, 0x380000000000a, 0x3a8c5f026ee4a, 0x8527497e64d0, 0, 0x38527497e64da, 0x2fbdfa2ae8d0a});\n+typedef Field<uint64_t, 50, 29, StatTable50, &SQR_TABLE_50, &SQR2_TABLE_50, &SQR4_TABLE_50, &SQR8_TABLE_50, &SQR16_TABLE_50, &QRT_TABLE_50, IdTrans, &ID_TRANS, &ID_TRANS> Field50;\n+\n+// 51 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable51;\n+constexpr StatTable51 SQR_TABLE_51({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x96, 0x258, 0x960, 0x2580, 0x9600, 0x25800, 0x96000, 0x258000, 0x960000, 0x2580000, 0x9600000, 0x25800000, 0x96000000, 0x258000000, 0x960000000, 0x2580000000, 0x9600000000, 0x25800000000, 0x96000000000, 0x258000000000, 0x960000000000, 0x2580000000000, 0x160000000004b, 0x580000000012c, 0x6000000000426});\n+constexpr StatTable51 SQR2_TABLE_51({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x96, 0x960, 0x9600, 0x96000, 0x960000, 0x9600000, 0x96000000, 0x960000000, 0x9600000000, 0x96000000000, 0x960000000000, 0x160000000004b, 0x6000000000426, 0x4114, 0x41140, 0x411400, 0x4114000, 0x41140000, 0x411400000, 0x4114000000, 0x41140000000, 0x411400000000, 0x4114000000000, 0x1140000000258, 0x1400000002516, 0x40000000251f6, 0x251d38, 0x251d380, 0x251d3800, 0x251d38000, 0x251d380000, 0x251d3800000, 0x251d38000000, 0x251d380000000, 0x51d380000012c, 0x1d3800000100e, 0x538000001003d, 0x380000010011e});\n+constexpr StatTable51 SQR4_TABLE_51({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x96000, 0x960000000, 0x160000000004b, 0x411400, 0x4114000000, 0x1140000000258, 0x251d380, 0x251d3800000, 0x1d3800000100e, 0x10010110, 0x100101100000, 0x1011000009600, 0x960969f6, 0x960969f60000, 0x169f60004110b, 0x6000411015132, 0x4110151054000, 0x1510540251f60, 0x540251f6ba760, 0x51f6ba74eb92c, 0x3a74eb900001f, 0x6b90000010033, 0x100010860, 0x1000108600000, 0x1086000096000, 0x960092874, 0x160092874004b, 0x128740041144b, 0x40041144304e2, 0x1144304c78258, 0x304c78251d1d8, 0x78251d1c38368, 0x1d1c38352800e, 0x3835280011188, 0x280011197096e, 0x1119709787000, 0x709787009fb46, 0x7009fb7861c9, 0x1fb7861cae24b, 0x61cae2456109, 0x2e245610a7bc3, 0x5610a7bd61498, 0x27bd614b79d2b, 0x614b79d3a74de, 0x79d3a74e9f68a, 0x274e9f6b06011, 0x1f6b06000000f});\n+constexpr StatTable51 SQR8_TABLE_51({0x1, 0x960969f6, 0x40041144304e2, 0x79d3a74e9f68a, 0x61005961939d4, 0x2e2108dfdafb5, 0xe7e61b897f73, 0x493a58b330d18, 0x7882105dc65ec, 0x5f00774200d11, 0x63ef4cd371ef3, 0x660b24b8d214b, 0x7ab791e669e3d, 0x10821820969f6, 0x1544b9d4c3f3e, 0x831185e3da14, 0x1eb0831983187, 0x1d8699ae87312, 0x586e000eb5f1a, 0x3ea794ef9c821, 0x2ab1c63209cc1, 0x7f434bcc29855, 0x673d370c40117, 0x6a668249ddd8b, 0x48be019e56bbe, 0x57d1a751be823, 0x5621931ca6d5f, 0x68c5a37844a68, 0xefa69123b6b1, 0x5804da97df62a, 0x30c29b82f3986, 0x5b808f6ddc779, 0x2c8b4e7596cbe, 0x2c5a432ec7a14, 0x7f178a4d63277, 0x77112a07b99b7, 0x56cf47ad50529, 0x73a2180190a41, 0x25cbc68f1f1a8, 0x1c27dc22e6950, 0x2fbf4aafee2ad, 0x554b728a595ca, 0x52726d34627e, 0x6dcc716c9e860, 0x36ade274d5eff, 0x1fa23a55b359a, 0x1bc6260896059, 0x53a74c5798bc1, 0x50e671fc54a4a, 0x251a72b3c4c3c, 0x6d9623f5d3a1e});\n+constexpr StatTable51 SQR16_TABLE_51({0x1, 0x27b32044e9663, 0x528c08dd195bf, 0x5d461228d5764, 0x616db8f131bf6, 0x9d910988ca4, 0x1e7a7a29c55fd, 0x512a2e6297818, 0x688d44453ead0, 0x70e0b6e1b3be2, 0x4313e5612d70, 0x132241d43589d, 0x7ca688c29c89a, 0x1d6b8caeb8958, 0x36d06e8e76e3b, 0x18ebafc89388e, 0x1cb5f93b2c29c, 0x5137bd7b7b6ec, 0x6e3ae8731000b, 0x359203e5e12fe, 0x1822ded1f1e16, 0x3ee9c50cbcb89, 0x5cc0b4564ab4, 0x695b235bd9236, 0x283c619a1ecb, 0x6f37f1f6ef70d, 0x7f394b6fbdd53, 0x3f482b36793f, 0x4055274e56dfa, 0x1a85d9d434f33, 0x37aa8f3df2031, 0x5f4e77b2bb063, 0x6e9702d84f07b, 0x25f16f8ffd4c2, 0x22c591d8277cb, 0x59435d9bae242, 0x46eaf9f69ddd9, 0x3098c1e26bd6e, 0x6c6544847a1d, 0x254946c0c33ce, 0x23970a6118811, 0x67f6c55082b49, 0x6592c83ebde46, 0x716418f089ed8, 0x8cb8de463166, 0x37cb1794fac42, 0x94ac55c1ac68, 0x3ab0d33bb4fdf, 0x1669c2f7ae3c5, 0x4d4e4f61d1f04, 0x476980d17eef5});\n+constexpr StatTable51 QRT_TABLE_51({0x778bf2703d152, 0x2aaaafbff2092, 0x2aaaafbff2090, 0x4d2119c7e7780, 0x2aaaafbff2094, 0x65de1df8ae194, 0x4d2119c7e7788, 0x67d63d7ba262c, 0x2aaaafbff2084, 0x28ff003f4167c, 0x65de1df8ae1b4, 0x658397fb1d034, 0x4d2119c7e77c8, 0x4d7c9284526ba, 0x67d63d7ba26ac, 0x6666333fc0cbe, 0x2aaaafbff2184, 0x295b807ab55ee, 0x28ff003f4147c, 0x2aaabfffe0016, 0x65de1df8ae5b4, 0x209210349d60, 0x658397fb1d834, 0x4d215dc7cf1c8, 0x4d2119c7e67c8, 0x662b2b3d7b4be, 0x4d7c9284506ba, 0x255af00b36e0, 0x67d63d7ba66ac, 0x65de1fb8ac1a6, 0x6666333fc8cbe, 0x662f3b3ded4be, 0x2aaaafbfe2184, 0x663a9dbc3a426, 0x295b807a955ee, 0x4cdc9ec128928, 0x28ff003f0147c, 0x28a0c93cd511c, 0x2aaabfff60016, 0x65d73cf8e78d4, 0x65de1df9ae5b4, 0x4d5eddc44f1c8, 0x209210149d60, 0x357fcc506c8a, 0x658397ff1d834, 0, 0x4d215dcfcf1c8, 0x63f536f5d4554, 0x4d2119d7e67c8, 0x4000000000022, 0x662b2b1d7b4be});\n+typedef Field<uint64_t, 51, 75, StatTable51, &SQR_TABLE_51, &SQR2_TABLE_51, &SQR4_TABLE_51, &SQR8_TABLE_51, &SQR16_TABLE_51, &QRT_TABLE_51, IdTrans, &ID_TRANS, &ID_TRANS> Field51;\n+\n+// 52 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable52;\n+constexpr StatTable52 SQR_TABLE_52({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x240000, 0x900000, 0x2400000, 0x9000000, 0x24000000, 0x90000000, 0x240000000, 0x900000000, 0x2400000000, 0x9000000000, 0x24000000000, 0x90000000000, 0x240000000000, 0x900000000000, 0x2400000000000, 0x9000000000000, 0x4000000000012});\n+constexpr StatTable52 SQR2_TABLE_52({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x9, 0x90, 0x900, 0x9000, 0x90000, 0x900000, 0x9000000, 0x90000000, 0x900000000, 0x9000000000, 0x90000000000, 0x900000000000, 0x9000000000000, 0x41, 0x410, 0x4100, 0x41000, 0x410000, 0x4100000, 0x41000000, 0x410000000, 0x4100000000, 0x41000000000, 0x410000000000, 0x4100000000000, 0x1000000000024, 0x249, 0x2490, 0x24900, 0x249000, 0x2490000, 0x24900000, 0x249000000, 0x2490000000, 0x24900000000, 0x249000000000, 0x2490000000000, 0x4900000000012, 0x9000000000104});\n+constexpr StatTable52 SQR4_TABLE_52({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x9000, 0x90000000, 0x900000000000, 0x4100, 0x41000000, 0x410000000000, 0x2490, 0x24900000, 0x249000000000, 0x1001, 0x10010000, 0x100100000000, 0x1000000000900, 0x9009000, 0x90090000000, 0x900000000410, 0x4104100, 0x41041000000, 0x410000000249, 0x2492490, 0x24924900000, 0x9249000000104, 0x1000001, 0x10000010000, 0x100000090, 0x1000000900000, 0x9000009000, 0x90000041, 0x900000410000, 0x4100004100, 0x1000041000024, 0x410000249000, 0x2490002490, 0x4900024900012, 0x249000100100, 0x1001001001, 0x10010010009, 0x100100090090, 0x1000900900900, 0x9009009009000, 0x90090041041, 0x900410410410, 0x4104104104100, 0x1041041024924, 0x410249249249, 0x2492492492490, 0x4924924910002, 0x9249100000004});\n+constexpr StatTable52 SQR8_TABLE_52({0x1, 0x1000000000900, 0x900000410000, 0x410249249249, 0x349100000000, 0x1900000d1, 0x10d10d1065965, 0x51010000, 0x2d924909000, 0x4114114114109, 0xe591, 0x1000007c96591, 0x1903981d13981, 0x249000000001, 0x1000100000990, 0x990090451041, 0x41022cb49249, 0x37d824910000, 0x90191890190d8, 0x10d10d106edf5, 0x54114101, 0x102f4b400bd90, 0x5c04114114108, 0x8f5900000ebcc, 0x1e59107b5f401, 0x8f5ab89f5abcc, 0x24924900001, 0x1010010010909, 0x90000041d100, 0x41024f7df7d9, 0x34a591003491, 0x9001900000d0, 0x4c10d106522c, 0xb49051500100, 0x43dafdb40249, 0x428c0c5114109, 0x59001f590e576, 0x49f59f25facf6, 0x19039c4c17881, 0x26fdb4902491, 0x10110010998, 0x109009045cc51, 0x90022a8867d9, 0x9527ffcb5a6dc, 0x9bc01190190d9, 0x14c119006e608, 0x42fd9e0d55042, 0x143f711b5bfd9, 0x5fa58e1809008, 0x23d647ac81eb2, 0x57ac8f223a466, 0x865abc8b4abcc});\n+constexpr StatTable52 SQR16_TABLE_52({0x1, 0x4f881c2d96599, 0xd7eb53011fc41, 0x81d7387961fef, 0xd9afe338982c3, 0x17590c140da98, 0x141a99a87a04e, 0x10036ba4083d9, 0x8f4f72ffb12c7, 0xc8b70df241e1b, 0x18bd9e5d46c40, 0x18331d76266bd, 0x4d915f264a4e0, 0x46aeffb8e4037, 0x4800042de37b5, 0xdb172953272e8, 0x17a9c2edf826a, 0x191cf7053e3f2, 0x82036da842cea, 0x5891da126c1e, 0x1e536e9e4af49, 0x451b5638f5449, 0x5a006c6c4f8c8, 0x5ac71a535fb44, 0xd39a4d489ebd0, 0x4704e31bc006d, 0xc4b327f6ffae1, 0x46980b709bd00, 0xd755405154c11, 0x5741be2d0b797, 0xcb3d48ed630cb, 0x98a66c9f4f599, 0x4caa324b91629, 0x816b5015eeeaf, 0xa595e92a8ed4, 0xc93c6d9f5a073, 0x4250068b39e2, 0x105add98997b5, 0x408b030c0bce0, 0xced5e4a4a2028, 0x1eb59d68e7f25, 0x189756a5b6db0, 0xc49c5a7c98b01, 0x18c9a496767cb, 0xde650554b3d49, 0x11077035fd81c, 0x8b37c5e95a659, 0x45b9226c2c25e, 0xdd2b5e20c7c8b, 0x6de972f0e7025, 0x84e80092f5681, 0x8dfcf97183cbc});\n+constexpr StatTable52 QRT_TABLE_52({0xc108165459b0e, 0x10004086, 0x10004084, 0xc00000100104e, 0x10004080, 0x2041810a545b0, 0xc000001001046, 0x1181e055efc0, 0x10004090, 0x40810214390, 0x2041810a54590, 0xc000141019106, 0xc000001001006, 0x10816045ab40, 0x1181e055ef40, 0xc000111015196, 0x10004190, 0xe045c19af44a2, 0x40810214190, 0xe045809ad0532, 0x2041810a54190, 0xdb387a03fe646, 0xc000141019906, 0x2000000800000, 0xc000001000006, 0x2486548199c34, 0x108160458b40, 0x2041808a50534, 0x1181e055af40, 0xc0408312153d6, 0xc00011101d196, 0x21499f0e0eed0, 0x10014190, 0xe15dff9faabe2, 0xe045c19ad44a2, 0xdb787b01ea7d6, 0x40810254190, 0xe484409180532, 0xe045809a50532, 0xc14095164d896, 0x2041810b54190, 0x217dee8fb7a74, 0xdb387a01fe646, 0x441810b54190, 0xc000141419906, 0xc3386e15e7f46, 0x2000000000000, 0x1000141419900, 0xc000000000006, 0, 0x248654a199c34, 0xa48654a199c32});\n+typedef Field<uint64_t, 52, 9, StatTable52, &SQR_TABLE_52, &SQR2_TABLE_52, &SQR4_TABLE_52, &SQR8_TABLE_52, &SQR16_TABLE_52, &QRT_TABLE_52, IdTrans, &ID_TRANS, &ID_TRANS> Field52;\n+typedef FieldTri<uint64_t, 52, 3, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5>, &SQR_TABLE_52, &SQR2_TABLE_52, &SQR4_TABLE_52, &SQR8_TABLE_52, &SQR16_TABLE_52, &QRT_TABLE_52, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri52;\n+\n+// 53 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable53;\n+constexpr StatTable53 SQR_TABLE_53({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x8e, 0x238, 0x8e0, 0x2380, 0x8e00, 0x23800, 0x8e000, 0x238000, 0x8e0000, 0x2380000, 0x8e00000, 0x23800000, 0x8e000000, 0x238000000, 0x8e0000000, 0x2380000000, 0x8e00000000, 0x23800000000, 0x8e000000000, 0x238000000000, 0x8e0000000000, 0x2380000000000, 0x8e00000000000, 0x3800000000047, 0xe00000000011c, 0x18000000000437});\n+constexpr StatTable53 SQR2_TABLE_53({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x238, 0x2380, 0x23800, 0x238000, 0x2380000, 0x23800000, 0x238000000, 0x2380000000, 0x23800000000, 0x238000000000, 0x2380000000000, 0x3800000000047, 0x18000000000437, 0x4054, 0x40540, 0x405400, 0x4054000, 0x40540000, 0x405400000, 0x4054000000, 0x40540000000, 0x405400000000, 0x4054000000000, 0x54000000008e, 0x54000000008e0, 0x14000000008e8e, 0x8ea56, 0x8ea560, 0x8ea5600, 0x8ea56000, 0x8ea560000, 0x8ea5600000, 0x8ea56000000, 0x8ea560000000, 0x8ea5600000000, 0xea5600000011c, 0xa560000001015, 0x560000001000b, 0x1600000010003e});\n+constexpr StatTable53 SQR4_TABLE_53({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x23800, 0x238000000, 0x2380000000000, 0x40540, 0x405400000, 0x4054000000000, 0x8ea56, 0x8ea560000, 0x8ea5600000000, 0x1600000010003e, 0x1000111000, 0x10001110000000, 0x11100000238000, 0x2380219b80, 0x380219b800047, 0x19b8000405447, 0x4054441114, 0x54441114008e, 0x41114008ea5ee, 0x14008ea5e6c1b8, 0xea5e6c193611c, 0x6c1936100000d, 0x13610000000124, 0x1010338, 0x10103380000, 0x1033800000238, 0x180000023a3e0f, 0x23a3e3d4000, 0x1a3e3d40000437, 0x1d400004014997, 0x40149af1600, 0x149af160008e0, 0xf160008e2a4a3, 0x8e2a4bc4710, 0x2a4bc47101015, 0x1c4710101022bb, 0x101010228120a8, 0x102281208ba380, 0x1208ba3a3c26c, 0xba3a3c26e7e1c, 0x3c26e7e0ad413, 0xe7e0ad414deb9, 0xad414dea4a7d0, 0x14dea4a7c40960, 0x4a7c4094acd8b, 0x4094acd82b43a, 0xacd82b432f376, 0x2b432f3623804, 0x12f36238010027});\n+constexpr StatTable53 SQR8_TABLE_53({0x1, 0x11100000238000, 0x1a3e3d40000437, 0x4a7c4094acd8b, 0x1eea7d6a679bbe, 0x1c423906384897, 0x2168da5f2c08c, 0x1b8259ec8ea11, 0x19d1f388b2d3d6, 0x1959a5720001a7, 0x1a6c8fa147c79, 0x191868056d58df, 0x19b717beaf7eb0, 0x1d37e92df66e7f, 0x16ec165c8535b7, 0x7da5e73dba0b3, 0x14d2bece5702b1, 0xadfaa30a5cf7e, 0x101934bec0d066, 0xaae7f006690ce, 0x6bfdbd85eb297, 0x6b2cb00d8c2b5, 0x52ee73aae547e, 0x67461baa976c2, 0xf8a44f459c7d, 0x2579abd0b5fc6, 0x6e7e5e9b82057, 0x1ab0a0fcf2d91c, 0x385dc87020053, 0xfc75a891c9df0, 0xca67b851d0c1a, 0x4c8d3234fd4f7, 0xf3ea564798c7f, 0x16881f479c0d6b, 0x60b0e8e33fe90, 0x18259a2869066d, 0xc52b463fb1475, 0x8229075c3475d, 0x6725108ff0948, 0xd5edf67d5a509, 0xbf52bb2383664, 0xd5b84ac7ed2ab, 0xbb5901d009d56, 0xcb380bfcebc5, 0x5f411d4594745, 0x18bdcb9f9d25da, 0xf0d3abe76ec15, 0x8b1a6404ca3b5, 0x15b7c7c793b65f, 0x11ff16f08569ff, 0x19c1d4c5eb3442, 0x5deb92ff5fc40, 0xa8009f9410cbc});\n+constexpr StatTable53 SQR16_TABLE_53({0x1, 0x5a65e677a526f, 0x142b8f50195f72, 0x12b0ca8e8b1225, 0x1b892547f268cc, 0x1239ca3a4824b6, 0x4249dac026ea8, 0x38080cba150e5, 0x903882481cefb, 0x1ad11e5cf99bf0, 0x14fa149116ab75, 0x6cbd888de21e5, 0x1388c718c37a69, 0x89d1eb38e9978, 0xf12019f00f91f, 0xb377986c7da1f, 0x1c780b06da5cb9, 0x1e10c7eee3249d, 0xe1afb7bd8111d, 0xc821f2a6fa090, 0x1a26caa65e1d59, 0x4280741c8cc4c, 0xb9c507337dad8, 0x65bffa0a097b6, 0x12068bb8ed4ac0, 0x6d751e7056355, 0xbccc3fbdcf084, 0x17ed82d58ea927, 0x125a30b543b4b8, 0xaf1ce3f5f84ce, 0x1082e42090b649, 0xf8d6a6212c41a, 0x1f89211d4982d, 0x1910bdfe092d07, 0x9363da9b9b9d3, 0x8a7196ef7b84e, 0x33fe46ddf1dc, 0x1f3f3291cf719d, 0x91a5da69f1035, 0x5a8dc6eb62cfb, 0xaf99fcc57728a, 0x15e73f1aa49f47, 0x2d82e50796b97, 0x1072fcbb074200, 0x15180f0fc7904, 0xa3a194b750f79, 0xb053c3eea9bb3, 0x1e58da5ae123de, 0x10b47afec00861, 0x17cd9ea910639d, 0x1ecf806dbf8c36, 0xf93d00fe6145b, 0x1247d788a3eda});\n+constexpr StatTable53 QRT_TABLE_53({0xf940b90844076, 0x1f940b90844052, 0x1f940b90844050, 0x9d2a063b43e64, 0x1f940b90844054, 0x936f69323ec14, 0x9d2a063b43e6c, 0xe12270a88898, 0x1f940b90844044, 0x1f917f00bb5a3c, 0x936f69323ec34, 0x1f622df85b46ee, 0x9d2a063b43e2c, 0x9bc65ab040b66, 0xe12270a88818, 0x958330b931986, 0x1f940b90844144, 0x98e2a06e32e0, 0x1f917f00bb583c, 0x1f877970dc1024, 0x936f69323e834, 0x16cc3c9b1558c2, 0x1f622df85b4eee, 0x16de1c3351dae8, 0x9d2a063b42e2c, 0x1fecdc7855f8ee, 0x9bc65ab042b66, 0x933821b1cb6fe, 0xe12270a8c818, 0x1f675958641c0e, 0x958330b939986, 0x9d97e050e960, 0x1f940b90854144, 0x1f820fa0e38adc, 0x98e2a06c32e0, 0x1650f0e358a010, 0x1f917f00bf583c, 0x1643af4b037a3a, 0x1f877970d41024, 0x1ffe2c281d8c16, 0x936f69333e834, 0xf00d50ffccf8, 0x16cc3c9b3558c2, 0x16bc31cbca943a, 0x1f622df81b4eee, 0xa6cbd8007232, 0x16de1c33d1dae8, 0x15d2a062b42e10, 0x9d2a062b42e2c, 0x1aa77896586ca, 0x1fecdc7a55f8ee, 0, 0x9bc65af042b66});\n+typedef Field<uint64_t, 53, 71, StatTable53, &SQR_TABLE_53, &SQR2_TABLE_53, &SQR4_TABLE_53, &SQR8_TABLE_53, &SQR16_TABLE_53, &QRT_TABLE_53, IdTrans, &ID_TRANS, &ID_TRANS> Field53;\n+\n+// 54 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable54;\n+constexpr StatTable54 SQR_TABLE_54({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x2010000000, 0x8040000000, 0x20100000000, 0x80400000000, 0x201000000000, 0x804000000000, 0x2010000000000, 0x8040000000000, 0x20100000000000, 0x400000000402, 0x1000000001008, 0x4000000004020, 0x10000000010080});\n+constexpr StatTable54 SQR2_TABLE_54({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x804, 0x8040, 0x80400, 0x804000, 0x8040000, 0x80400000, 0x804000000, 0x8040000000, 0x80400000000, 0x804000000000, 0x8040000000000, 0x400000000402, 0x4000000004020, 0x40001, 0x400010, 0x4000100, 0x40001000, 0x400010000, 0x4000100000, 0x40001000000, 0x400010000000, 0x4000100000000, 0x1000000201, 0x10000002010, 0x100000020100, 0x1000000201000, 0x10000002010000, 0x20100804, 0x201008040, 0x2010080400, 0x20100804000, 0x201008040000, 0x2010080400000, 0x20100804000000, 0x1008040001008, 0x10080400010080, 0x804000100004, 0x8040001000040, 0x400010000002, 0x4000100000020});\n+constexpr StatTable54 SQR4_TABLE_54({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x80400, 0x804000000, 0x8040000000000, 0x400010, 0x4000100000, 0x1000000201, 0x10000002010000, 0x20100804000, 0x1008040001008, 0x400010000002, 0x100000000100, 0x1008040, 0x10080400000, 0x804000000804, 0x8000001, 0x80000010000, 0x100004020, 0x1000040200000, 0x402000080400, 0x20000804020100, 0x8040200008000, 0x2000080400010, 0x804000000800, 0x8040001, 0x80400010000, 0x4000100004020, 0x1000040001000, 0x400010080400, 0x100804020100, 0x8040201008040, 0x2010080000010, 0x800000000004, 0x200, 0x2000000, 0x20000000000, 0x1008, 0x10080000, 0x100800000000, 0x8000000008040, 0x80002000, 0x800020000000, 0x200000040200, 0x402010080, 0x4020100800000, 0x1008000200008, 0x2000000002, 0x20000000020000, 0x201008000, 0x2010080000000, 0x800000100004});\n+constexpr StatTable54 SQR8_TABLE_54({0x1, 0x10080400000, 0x100804020100, 0x1008000200008, 0x10080002000000, 0x4000000804, 0x8000201000040, 0x402000000000, 0x20100004020, 0x1000000000, 0x80000010, 0x20100800000100, 0x201008, 0x80002010080, 0x804020100000, 0x201000040, 0x2000080000, 0x4020100004000, 0x8040000, 0x10000402000, 0x20000, 0x1008000001008, 0x10080402010080, 0x4000000004, 0x40001000040, 0x10080402, 0x4020000004000, 0x40001, 0x2000080402010, 0x20000000000000, 0x1000000200000, 0x10000000000080, 0x4020100000, 0x40201008040, 0x402000080002, 0x4020000800000, 0x1000000201, 0x2000080400010, 0x100800000000, 0x8040001008, 0x400000000, 0x20000004, 0x8040200000040, 0x80402, 0x20000804020, 0x201008040000, 0x80400010, 0x800020000, 0x1008040001000, 0x2010000, 0x4000100800, 0x8000, 0x402000000402, 0x4020100804020});\n+constexpr StatTable54 SQR16_TABLE_54({0x1, 0x80002010000, 0x4020000000000, 0x1000000201008, 0x402010000402, 0x20100804020000, 0x8000001000040, 0x2000000000000, 0x804020000800, 0x1000000201, 0x80002000080, 0x804020, 0x8, 0x400010080000, 0x20100000000000, 0x8000001008040, 0x2010080002010, 0x804020100804, 0x8000001, 0x10000000000000, 0x4020100004000, 0x8000001008, 0x400010000400, 0x4020100, 0x40, 0x2000080400000, 0x800000000804, 0x8040001, 0x10080400010080, 0x4020100804020, 0x40000008, 0x402, 0x20100800020000, 0x40000008040, 0x2000080002000, 0x20100800, 0x200, 0x10000402000000, 0x4000000004020, 0x40200008, 0x402000080002, 0x20100804020100, 0x200000040, 0x2010, 0x804000100804, 0x200000040200, 0x10000400010000, 0x100804000, 0x1000, 0x2010000402, 0x20000000020100, 0x201000040, 0x2010000400010, 0x804020100004});\n+constexpr StatTable54 QRT_TABLE_54({0x201008000200, 0x26c10916494994, 0x26c10916494996, 0x40008008, 0x26c10916494992, 0x141a2434c12d12, 0x40008000, 0x36c00110594c22, 0x26c10916494982, 0x200000040200, 0x141a2434c12d32, 0x10010816104534, 0x40008040, 0x36da60b01308b2, 0x36c00110594ca2, 0x48200209000, 0x26c10916494882, 0x41b6da2d86106, 0x200000040000, 0x32db2c228965b0, 0x141a2434c12932, 0x9000000200048, 0x10010816104d34, 0x32db68b2832da4, 0x40009040, 0x40045928b4902, 0x36da60b01328b2, 0x1000040000, 0x36c00110590ca2, 0x101b69865a4120, 0x48200201000, 0x22da6434912884, 0x26c10916484882, 0x9000240208008, 0x41b6da2da6106, 0x22c14484c20180, 0x200000000000, 0x4016db29b6812, 0x32db2c228165b0, 0x9008200201048, 0x141a2434d12932, 0x32c36ca2c264b0, 0x9000000000048, 0x140a65b48a2c32, 0x10010816504d34, 0, 0x32db68b2032da4, 0x404490824814, 0x41009040, 0x14da60a4536126, 0x40045908b4902, 0x8000041009008, 0x36da60b41328b2, 0x6db68b2032c12});\n+typedef Field<uint64_t, 54, 513, StatTable54, &SQR_TABLE_54, &SQR2_TABLE_54, &SQR4_TABLE_54, &SQR8_TABLE_54, &SQR16_TABLE_54, &QRT_TABLE_54, IdTrans, &ID_TRANS, &ID_TRANS> Field54;\n+typedef FieldTri<uint64_t, 54, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_54, &SQR2_TABLE_54, &SQR4_TABLE_54, &SQR8_TABLE_54, &SQR16_TABLE_54, &QRT_TABLE_54, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri54;\n+\n+// 55 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable55;\n+constexpr StatTable55 SQR_TABLE_55({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x102, 0x408, 0x1020, 0x4080, 0x10200, 0x40800, 0x102000, 0x408000, 0x1020000, 0x4080000, 0x10200000, 0x40800000, 0x102000000, 0x408000000, 0x1020000000, 0x4080000000, 0x10200000000, 0x40800000000, 0x102000000000, 0x408000000000, 0x1020000000000, 0x4080000000000, 0x10200000000000, 0x40800000000000, 0x2000000000102, 0x8000000000408, 0x20000000001020});\n+constexpr StatTable55 SQR2_TABLE_55({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x102, 0x1020, 0x10200, 0x102000, 0x1020000, 0x10200000, 0x102000000, 0x1020000000, 0x10200000000, 0x102000000000, 0x1020000000000, 0x10200000000000, 0x2000000000102, 0x20000000001020, 0x10004, 0x100040, 0x1000400, 0x10004000, 0x100040000, 0x1000400000, 0x10004000000, 0x100040000000, 0x1000400000000, 0x10004000000000, 0x40000000102, 0x400000001020, 0x4000000010200, 0x40000000102000, 0x1020408, 0x10204080, 0x102040800, 0x1020408000, 0x10204080000, 0x102040800000, 0x1020408000000, 0x10204080000000, 0x2040800000102, 0x20408000001020, 0x4080000010004, 0x40800000100040, 0x8000001000008});\n+constexpr StatTable55 SQR4_TABLE_55({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x10200, 0x102000000, 0x1020000000000, 0x10004, 0x100040000, 0x1000400000000, 0x4000000010200, 0x102040800, 0x1020408000000, 0x4080000010004, 0x100000010, 0x1000000100000, 0x1000010200, 0x10000102000000, 0x1020000102000, 0x1020010004, 0x10200100040000, 0x1000400100040, 0x4001000410200, 0x10004102040800, 0x41020408102000, 0x4081020418004, 0x10204180000010, 0x41800000000040, 0x10300, 0x103000000, 0x1030000000000, 0x10106, 0x101060000, 0x1010600000000, 0x6000000010302, 0x103040c00, 0x103040c000000, 0x40c0000010106, 0x101020418, 0x1010204180000, 0x2041800010302, 0x18000103000008, 0x1030000103000, 0x1030010106, 0x10300101060000, 0x1010600101060, 0x6001010610302, 0x10106103040c00, 0x6103040c103020, 0x40c103041c106, 0x103041c1020418, 0x41c10204081060, 0x2040810214282, 0x8102142800008, 0x21428000000020});\n+constexpr StatTable55 SQR8_TABLE_55({0x1, 0x1000010200, 0x101060000, 0x6103040c103020, 0x1001400010200, 0x4081121478004, 0x7903050f103028, 0x1100010200, 0x1020101162000, 0x6703040c113322, 0x113055c1030618, 0x50a102353a804, 0x3e83050f11336a, 0x103040f102071e, 0x101070200, 0x7123050c143020, 0x3100c010200, 0x60c193166c286, 0x6d2b040f15302c, 0x103140f010200, 0x2070f112772e2, 0x7621050c153322, 0x143341cd420418, 0x70e193270ee9e, 0xbe9840f14334e, 0x143355fe53051e, 0x3050e103555fc, 0x5153e50f143c00, 0x1001500050200, 0x450a152957a004, 0x7b071d0f11332a, 0x1000040200, 0x5000040b060000, 0x64061a0c103020, 0x153c44f147c71e, 0x4008142b428a04, 0x2ca75c8f103078, 0x113341f117371e, 0x5402040b162000, 0x62064aac143336, 0x50c003f51ff06, 0x7cf1f3d7ef2e6, 0x6e2d180714332e, 0x103150f050100, 0x43350b1a3152e2, 0x74261e06143020, 0x113f54fd17c65e, 0x56301c3b66cd98, 0x10dff9c7953054, 0x153055fe47360e, 0x46340a1b2277fc, 0x4574bfb5753c14, 0x50f003345fc52, 0x41f653264c9962, 0x7612375be93322});\n+constexpr StatTable55 SQR16_TABLE_55({0x1, 0x4ba7488f00015a, 0x30ce9d3a61c1e4, 0x4a2e76980aff84, 0x4e44f5b9d2f610, 0x7b479e4450115c, 0x248c18e86b39b2, 0x1ba74c8406015a, 0x35e93420af76aa, 0x7f282c7c68ad54, 0x7f8b356ad7bc5a, 0x527272878d3b24, 0x587495a40395a4, 0x43c4d0fd51f96c, 0x57ce893a71f0c6, 0x62c68a94803da, 0x1b32bc920e6546, 0x5073c39b469c78, 0x2fba08c009b110, 0x10bd0559ba45c, 0x3bbbd0ca4b3246, 0x243ad4b7c193b8, 0x335d7f186b5db2, 0x5590f3a0fd73f0, 0x72953f208233ba, 0x5210b9a31e6c62, 0x744bb124e351da, 0x4929f00a730244, 0x736ff5bdc1c63c, 0x4c1da1fb246e2e, 0x553c18b46d95cc, 0x268f5c8c143376, 0x438f5a59cbf094, 0x6a718b25fd3946, 0x67053b1bf54fe0, 0x441c5323cb0288, 0x5def8fcd41d5a8, 0x40446cdfcdb062, 0x1043009fb20072, 0xef08d6ed9e9c6, 0xbdf8adea645be, 0x76b092b499c072, 0xd754f98b724c2, 0x5a21d55c8f8752, 0x4f0f36a62eeb0c, 0x262f651fb93b18, 0x3336d340aa0aaa, 0x69375d0e9970fa, 0x2e0997225afe66, 0x6692008b83364e, 0x230856519bc3ae, 0x2c0a54962f8378, 0x2a6460de8a4266, 0x2f14d8fa237452, 0x25934cd7ae0030});\n+constexpr StatTable55 QRT_TABLE_55({0, 0x121d57b6623fde, 0x121d57b6623fdc, 0x68908340d10e00, 0x121d57b6623fd8, 0x100300510e20, 0x68908340d10e08, 0x10004096, 0x121d57b6623fc8, 0x100010000, 0x100300510e00, 0x7ea8c890a088e8, 0x68908340d10e48, 0x68809540871648, 0x10004016, 0x68808000808068, 0x121d57b6623ec8, 0x68909240d41c48, 0x100010200, 0x6884c170ad0216, 0x100300510a00, 0x68848160a50200, 0x7ea8c890a080e8, 0x7eecbca04ab4b6, 0x68908340d11e48, 0x120c54b62234c8, 0x68809540873648, 0x69929240d61c48, 0x10000016, 0x68808060800000, 0x68808000800068, 0x80000080, 0x121d57b6633ec8, 0x7ea8cb90a18ae8, 0x68909240d61c48, 0x16284090200080, 0x100050200, 0x474302a345e, 0x6884c170a50216, 0x166cbca0cab4de, 0x100300410a00, 0x1000000000000, 0x68848160850200, 0x688cc1f0a50296, 0x7ea8c890e080e8, 0x7e8cc1f0a50280, 0x7eecbca0cab4b6, 0x68000000000068, 0x68908341d11e48, 0x7880954487365e, 0x120c54b42234c8, 0x9929248d61c20, 0x68809544873648, 0x41121208561c20, 0x69929248d61c48});\n+typedef Field<uint64_t, 55, 129, StatTable55, &SQR_TABLE_55, &SQR2_TABLE_55, &SQR4_TABLE_55, &SQR8_TABLE_55, &SQR16_TABLE_55, &QRT_TABLE_55, IdTrans, &ID_TRANS, &ID_TRANS> Field55;\n+typedef FieldTri<uint64_t, 55, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_55, &SQR2_TABLE_55, &SQR4_TABLE_55, &SQR8_TABLE_55, &SQR16_TABLE_55, &QRT_TABLE_55, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri55;\n+\n+// 56 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable56;\n+constexpr StatTable56 SQR_TABLE_56({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x95, 0x254, 0x950, 0x2540, 0x9500, 0x25400, 0x95000, 0x254000, 0x950000, 0x2540000, 0x9500000, 0x25400000, 0x95000000, 0x254000000, 0x950000000, 0x2540000000, 0x9500000000, 0x25400000000, 0x95000000000, 0x254000000000, 0x950000000000, 0x2540000000000, 0x9500000000000, 0x25400000000000, 0x95000000000000, 0x5400000000012a, 0x5000000000043d, 0x40000000001061});\n+constexpr StatTable56 SQR2_TABLE_56({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x95, 0x950, 0x9500, 0x95000, 0x950000, 0x9500000, 0x95000000, 0x950000000, 0x9500000000, 0x95000000000, 0x950000000000, 0x9500000000000, 0x95000000000000, 0x5000000000043d, 0x4111, 0x41110, 0x411100, 0x4111000, 0x41110000, 0x411100000, 0x4111000000, 0x41110000000, 0x411100000000, 0x4111000000000, 0x41110000000000, 0x11100000000254, 0x110000000025d5, 0x10000000025dc5, 0x25dcc5, 0x25dcc50, 0x25dcc500, 0x25dcc5000, 0x25dcc50000, 0x25dcc500000, 0x25dcc5000000, 0x25dcc50000000, 0x25dcc500000000, 0x5dcc500000012a, 0xdcc50000001061, 0xcc500000010079, 0xc500000010016c, 0x5000000100103c});\n+constexpr StatTable56 SQR4_TABLE_56({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x9500, 0x95000000, 0x950000000000, 0x4111, 0x41110000, 0x411100000000, 0x110000000025d5, 0x25dcc500, 0x25dcc5000000, 0xdcc50000001061, 0x10010101, 0x100101010000, 0x1010100000950, 0x1000009509595, 0x95095959500, 0x5095959500043d, 0x95950004115111, 0x41151505011, 0x11515050110254, 0x505011025de985, 0x11025de9a93c10, 0x5de9a93c19c42a, 0xa93c19c400005d, 0x19c4000001000c, 0x100010094, 0x1000100940000, 0x1009400009500, 0x94000095009500, 0x950095418400, 0x954184004111, 0x41840041114111, 0x411141349dd4, 0x1141349dd425d5, 0x349dd425dce0d5, 0xd425dce0cce1b9, 0xdce0cce1ddd461, 0xcce1ddd4011160, 0xddd401110941f5, 0x1110941959dc4, 0x941959dc49cc5, 0x959dc49cc118d5, 0xc49cc1189454b9, 0xc1189454d4d12c, 0x9454d4d14358f8, 0xd4d14358b9aa44, 0x4358b9aa20a205, 0xb9aa20a221d7b8, 0x20a221d7ed10a2, 0x21d7ed10b0f90a, 0xed10b0f918507b, 0xb0f91850000050, 0x1850000001000d});\n+constexpr StatTable56 SQR8_TABLE_56({0x1, 0x1010100000950, 0x950095418400, 0xd4d14358b9aa44, 0x1135dd851025d5, 0x2c3e45b8a8a9d9, 0xcc39c4d816cc89, 0x51109400, 0x8496c8edb8f151, 0x1c2d7d88406199, 0x3856af0918b2ea, 0x2c26c02be43364, 0x7c13f0a9492898, 0x887abc757e3b3c, 0x10100411009c5, 0x850b98e029a995, 0x18309e7d346f24, 0x49e692600134d8, 0xf902789abce101, 0xed998d1d57187b, 0xa5488e663e846e, 0x84267921a952d0, 0x3d464f2d15176e, 0x801aac9d710b04, 0xfc00d6eb916343, 0x5c7fb78f391c1, 0x745ee236e80ea0, 0x81f8c65be65eac, 0x1940095415941, 0x1188025e2103d0, 0x49c166e0b13f34, 0xbd26558f28a2b3, 0xe147d131ae4b81, 0x25b501ad8ba86d, 0x75fb4e24c70a79, 0x88172901f1684d, 0xb090520bb570a2, 0x963c9b97aad59, 0x39b1e5f12c85a6, 0xd90de4c2bf3055, 0x9c921257e4a1b, 0x45f1f318fef834, 0x48161e1eb09635, 0x10685b397538ce, 0xbc8d4a0c6bc62a, 0xdce738247bfad9, 0x1115b3337d25a4, 0x195bf5a6f0999b, 0xb85101388b2f37, 0x8ee1b2833544cf, 0x49bc1efef7da90, 0x346e404662e355, 0x8c0dab6a1217d6, 0x3cb782ec54c968, 0x5efe07d4f59f4, 0x55f19c0f482900});\n+constexpr StatTable56 SQR16_TABLE_56({0x1, 0x2563e0b70105c4, 0x48ce07ef5576bb, 0xb94064d844f117, 0x207d2f511ffe3c, 0xf8f6dd1e2a3e6b, 0xe4cc405e0c6cdb, 0xd053f9b827b2bf, 0x550ae8d22edcbf, 0x29f7570f88728b, 0xa06a9e2dfd84a6, 0x55567b9483b3ff, 0x197c6c0d004df6, 0xe106c03f218a16, 0xc50dd2aaf0a388, 0x39473f6702a06c, 0xc8c1736b312ded, 0x992dc692bb707d, 0x24bb9a8dcad06f, 0x9cc45f9e3c2075, 0x455e7271eb130b, 0x847157a5326f59, 0xdc8ccb4ab3f5bd, 0x9463c02c46910d, 0xe1debd0b794514, 0x4c5128db660cde, 0x11910a685416a3, 0x11dfa5b9552a3d, 0x5d902ced822708, 0x794ff735e94601, 0xf1dc5fd7efcf7e, 0x19fb7ff8d06993, 0x7069119ac28a09, 0x98ba5a77d83e7f, 0xf4923dbc1b24e5, 0x7c2dcc84668312, 0xc27e2f5f2243f, 0x78c6d8ebe4bede, 0xad39495debf1a5, 0xa1564b894b50f0, 0x5898ae4e965be9, 0x28aa991e046567, 0x585e95889bb734, 0xc59e73661cf916, 0xed70696926d95d, 0xcca6630954309a, 0x8c4b12ac111264, 0xe8413ad0493e05, 0x1acea73bc9166, 0x9a7f11cd38d12d, 0x390dd1972139ec, 0x9146bc1a4fbff0, 0xd5a1c594335b01, 0x2566272e74ef1a, 0xd4a8baf259e7d0, 0x71e7efd8f20703});\n+constexpr StatTable56 QRT_TABLE_56({0x10004084, 0xd058f12fd5925e, 0xd058f12fd5925c, 0x41a60b5566d9f0, 0xd058f12fd59258, 0xbda60a142740ba, 0x41a60b5566d9f8, 0xd059f1afc5e688, 0xd058f12fd59248, 0xfc040841615a22, 0xbda60a1427409a, 0xbda60b5426c1ca, 0x41a60b5566d9b8, 0x1a60b4166b950, 0xd059f1afc5e608, 0xfc000041409822, 0xd058f12fd59348, 0xd1ee7a4ef4185c, 0xfc040841615822, 0x9049759b80b4a4, 0xbda60a1427449a, 0xd258e06f301e18, 0xbda60b5426c9ca, 0x6dfeeb3bf6d7d2, 0x41a60b5566c9b8, 0xbdef3ed4ae398a, 0x1a60b41669950, 0xd1ef3f8eeff04c, 0xd059f1afc5a608, 0xbda203340783de, 0xfc000041401822, 0x2dfefbaff2b27a, 0xd058f12fd49348, 0xfdb788a0706776, 0xd1ee7a4ef6185c, 0x2e5de0ae41337a, 0xfc040841655822, 0x41eb17d5ceecf8, 0x9049759b88b4a4, 0x40048874211afc, 0xbda60a1437449a, 0xd04a720f93400c, 0xd258e06f101e18, 0xbc559cf5ac7fce, 0xbda60b5466c9ca, 0x6dc9759b88b4d6, 0x6dfeeb3b76d7d2, 0x92feea7b275af0, 0x41a60b5466c9b8, 0, 0xbdef3ed6ae398a, 0x2811d5edd8ee2a, 0x1a60b45669950, 0xb1a60b5466c9ca, 0xd1ef3f86eff04c, 0xec493582c8f032});\n+typedef Field<uint64_t, 56, 149, StatTable56, &SQR_TABLE_56, &SQR2_TABLE_56, &SQR4_TABLE_56, &SQR8_TABLE_56, &SQR16_TABLE_56, &QRT_TABLE_56, IdTrans, &ID_TRANS, &ID_TRANS> Field56;\n+\n+}\n+\n+Sketch* ConstructClMul7Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 49: return new SketchImpl<Field49>(implementation, 49);\n+    case 50: return new SketchImpl<Field50>(implementation, 50);\n+    case 51: return new SketchImpl<Field51>(implementation, 51);\n+    case 52: return new SketchImpl<Field52>(implementation, 52);\n+    case 53: return new SketchImpl<Field53>(implementation, 53);\n+    case 54: return new SketchImpl<Field54>(implementation, 54);\n+    case 55: return new SketchImpl<Field55>(implementation, 55);\n+    case 56: return new SketchImpl<Field56>(implementation, 56);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri7Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 49: return new SketchImpl<FieldTri49>(implementation, 49);\n+    case 52: return new SketchImpl<FieldTri52>(implementation, 52);\n+    case 54: return new SketchImpl<FieldTri54>(implementation, 54);\n+    case 55: return new SketchImpl<FieldTri55>(implementation, 55);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "480228f44a7767cbb1837a74788482009bb1c60a",
        "filename": "src/fields/clmul_8bytes.cpp",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_8bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_8bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_8bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,134 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 57 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable57;\n+constexpr StatTable57 SQR_TABLE_57({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x8800000000, 0x22000000000, 0x88000000000, 0x220000000000, 0x880000000000, 0x2200000000000, 0x8800000000000, 0x22000000000000, 0x88000000000000, 0x20000000000011, 0x80000000000044});\n+constexpr StatTable57 SQR2_TABLE_57({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x88, 0x880, 0x8800, 0x88000, 0x880000, 0x8800000, 0x88000000, 0x880000000, 0x8800000000, 0x88000000000, 0x880000000000, 0x8800000000000, 0x88000000000000, 0x80000000000044, 0x404, 0x4040, 0x40400, 0x404000, 0x4040000, 0x40400000, 0x404000000, 0x4040000000, 0x40400000000, 0x404000000000, 0x4040000000000, 0x40400000000000, 0x4000000000022, 0x40000000000220, 0x2222, 0x22220, 0x222200, 0x2222000, 0x22220000, 0x222200000, 0x2222000000, 0x22220000000, 0x222200000000, 0x2222000000000, 0x22220000000000, 0x22200000000011, 0x22000000000101, 0x20000000001001});\n+constexpr StatTable57 SQR4_TABLE_57({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x880, 0x8800000, 0x88000000000, 0x80000000000044, 0x404000, 0x4040000000, 0x40400000000000, 0x22220, 0x222200000, 0x2222000000000, 0x20000000001001, 0x10001000, 0x100010000000, 0x100000000088, 0x880088, 0x8800880000, 0x88008800000000, 0x88000000040400, 0x404040400, 0x4040404000000, 0x4040000002222, 0x22222222, 0x222222220000, 0x22222200000101, 0x22000001000001, 0x10000000100, 0x100000001000000, 0x10000088000, 0x100000880000000, 0x8800000088000, 0x880004040, 0x8800040400000, 0x404000004040, 0x40000040400220, 0x404002222000, 0x40022220000220, 0x22200002222011, 0x22220100010, 0x22201000100011, 0x10001000100010, 0x10001000108800, 0x10001088008800, 0x10880088008800, 0x880088008c04, 0x88008c040404, 0x8c0404040404, 0x4040404040426, 0x4040404262222, 0x4042622222222, 0x26222222222222, 0x22222222232201, 0x22222322000001, 0x23220000000001});\n+constexpr StatTable57 SQR8_TABLE_57({0x1, 0x100010000000, 0x100000880000000, 0x88008c040404, 0x80000000022264, 0x26262604000101, 0x50023220100230, 0x222aa222000001, 0x20000404041401, 0x100404003222000, 0x32aa22aa23aa01, 0x2326048800088, 0x808100222ea722, 0x508e36ec548e34, 0x26222000022223, 0x22000223200001, 0x32001001108801, 0x91001000108844, 0x85048c04880044, 0x4c86ae64c80220, 0x6ea40546662003, 0x66662726ae22ab, 0x40622aa2aa40c8, 0x26063ea6364477, 0x2406744c950437, 0x8a33606aa727aa, 0xd09332ca7e2d9a, 0x7e2c14ce3e6c17, 0x22aa2626260405, 0x22200002626011, 0x27260000002223, 0x22208812aa3011, 0x2ba30040488001, 0x48c8c9caebe26, 0x28898040489001, 0x1048c008922aa26, 0x30c0c08a22b801, 0x12222666fa72601, 0x9afa60a8048eaa, 0x6aa1400afba131, 0xbc9c168c00800d, 0xc083aa60588bb0, 0xbeeefeae26e6e7, 0x8c44ee22226ae2, 0x8c44ee32205042, 0x2667443228d143, 0x36af14ba381d17, 0x72eb33981a3f35, 0x72c911aab20d9d, 0x72ca2b2aaacccd, 0x66463fae3f44ff, 0xac345eee3b4077, 0xe4977caefbe1fd, 0xf01b70a0dd0f9a, 0xf40f74bc580bbd, 0x17e2d1c6c5c0f35, 0x3624140232aa33});\n+constexpr StatTable57 SQR16_TABLE_57({0x1, 0xaeeec814065447, 0x110889c99ba3004, 0x1c59ed582798e0e, 0x1c9c766272a2a74, 0x1422928a5250a00, 0x2c97eb48f402a1, 0x10c6d916b128dea, 0x3f2e6ca66ebf67, 0x93ac75fcd63ec8, 0x19263128e42246, 0x1fd1ca54b556091, 0x60ff38200c4e09, 0x1381808ede9982b, 0xc7a9ace2f9dc2a, 0x6c2ee414271c57, 0x3c16f4cffdbe17, 0xc627ec6fe179ee, 0x178f994adf6525b, 0x18be0b635ca1650, 0x4afcb2ae2e98b6, 0x6f81f53a7688dd, 0x45319b3e02c15c, 0x1044be090058910, 0xaa02d012fca063, 0x11fba4c5b80dbfa, 0xf9f44be142268b, 0x1e351a44eb480bf, 0xacf5c17bd0aedf, 0x6f2d74bab851eb, 0x1b8ac3589da9915, 0x1afeb885d3fdd67, 0x7d7d596dd60bbd, 0x1329567316f5723, 0xfdfe23b549fcef, 0xc985ed1e7a009e, 0x71f794bbac1b03, 0xc740582125f7d0, 0x1b3584e031e3b77, 0x29978a3c559ed3, 0xde04d46b4ae516, 0x2f6d6e1c749405, 0x1ec95b44a4251f3, 0xb95b0a5f451f2d, 0x1dc80aedaab9bf2, 0xd0354d3ff74808, 0x180889b484b0364, 0x196895708367d90, 0x104575064a09414, 0x19e88f14fc111ec, 0x1cf4088d3cffd88, 0x1e6c28b9a76c6d5, 0x81ba060c9e485e, 0x12b811107188d68, 0x5e6f10ca82cd88, 0x120882748af043d, 0x145fb82467c596e});\n+constexpr StatTable57 QRT_TABLE_57({0xd0c3a82c902426, 0x232aa54103915e, 0x232aa54103915c, 0x1763e291e61699c, 0x232aa541039158, 0x1f424d678bb15e, 0x1763e291e616994, 0x26fd8122f10d36, 0x232aa541039148, 0x1e0a0206002000, 0x1f424d678bb17e, 0x5d72563f39d7e, 0x1763e291e6169d4, 0x1519beb9d597df4, 0x26fd8122f10db6, 0x150c3a87c90e4aa, 0x232aa541039048, 0x15514891f6179d4, 0x1e0a0206002200, 0x14ec9ba7a94c6aa, 0x1f424d678bb57e, 0x1e0f4286382420, 0x5d72563f3957e, 0x4000080000, 0x1763e291e6179d4, 0x1ac0e804882000, 0x1519beb9d595df4, 0x1f430d6793b57e, 0x26fd8122f14db6, 0x3c68e806882000, 0x150c3a87c9064aa, 0x1484fe18b915e, 0x232aa541029048, 0x14f91eb9b595df4, 0x15514891f6379d4, 0x48f6a82380420, 0x1e0a0206042200, 0x14b1beb99595df4, 0x14ec9ba7a9cc6aa, 0x4cf2a82b00420, 0x1f424d679bb57e, 0x26aa0002000000, 0x1e0f4286182420, 0x173f1039dd17df4, 0x5d72563b3957e, 0x4aa0002000000, 0x4000880000, 0x16d31eb9b595df4, 0x1763e291f6179d4, 0x20000000000000, 0x1ac0e806882000, 0x2caa0002000000, 0x1519beb99595df4, 0, 0x1f430d6f93b57e, 0x73e90d6d93b57e, 0x26fd8132f14db6});\n+typedef Field<uint64_t, 57, 17, StatTable57, &SQR_TABLE_57, &SQR2_TABLE_57, &SQR4_TABLE_57, &SQR8_TABLE_57, &SQR16_TABLE_57, &QRT_TABLE_57, IdTrans, &ID_TRANS, &ID_TRANS> Field57;\n+typedef FieldTri<uint64_t, 57, 4, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_57, &SQR2_TABLE_57, &SQR4_TABLE_57, &SQR8_TABLE_57, &SQR16_TABLE_57, &QRT_TABLE_57, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri57;\n+\n+// 58 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable58;\n+constexpr StatTable58 LOAD_TABLE_58({0x1, 0x77dd188d5d600, 0x41a7213270def0, 0x10921661867b40a, 0x880b92a6f74da3, 0x143e72cde8f4484, 0x1863cb65c3eee0e, 0x2a1aa4a82154057, 0x22265135db9e135, 0x1446f023770d6d0, 0x183c4be7b4fae6, 0x1cc8a1187e99bd4, 0x3a1ea282e1e2ff1, 0x2700aae9dbcd275, 0x1571f84428a416e, 0xc8eb0b234b8a57, 0x23227afc0d9ba75, 0x1de9497779018c7, 0x5898e896d43329, 0x1501bd1b83bb55f, 0xbb56c28ce180b, 0x188e087d2dbf7e0, 0x36eee77125d8ec9, 0xde4235cbe95166, 0x1c71e4d57306163, 0x2a7e1b1ae5d87ee, 0x3a685560450c909, 0x1cd0545bc185c4b, 0x151779b11f09892, 0x2ab069803c4d787, 0x3bf279c0b825ad5, 0x15edc1ef3d2513c, 0x37bf223b4d0d045, 0x262a786b0324cd3, 0x27658294b696713, 0x33771167b0137e8, 0x86a73ef2dc3271, 0xc64453d2ff05, 0x14c55bc975ce8c, 0x3581164b1e4826e, 0x461dde5468bc26, 0x3f31528346e9451, 0x3f2669a5324a555, 0xd0b1c042854400, 0x32cc9899ea263e3, 0x2a423a8a96f4e95, 0x3e64acd727b470b, 0x2f1f1c1de9c997d, 0x268f2df0a8ab060, 0x14fd82231712442, 0x106e14e5e9e8f8c, 0x2686a15d911a24c, 0x182f831c5142b40, 0x36ca3e60fc7c678, 0x22ba581841d83ff, 0x11539696ce13d17, 0x558c3670aecb8e, 0x2b9b2d828d6d864});\n+constexpr StatTable58 SAVE_TABLE_58({0x1, 0xde56167ca60c8e, 0x166391328282dfb, 0x2c6ed660535e701, 0xf83470e499e0e, 0x3686f752cff05fd, 0x1ada23d28022d0b, 0x2a2ac069b41ffd4, 0x2d40f316b40053e, 0x3fb69372877a1f3, 0x13def6e665e9b30, 0x23eb4222bc98b90, 0x2991c5ab618f62c, 0x1c4b63ee1e37a86, 0xdcb10179c77602, 0x708837c2f0ee59, 0x151fe1b533a6d99, 0x44613653cb9d83, 0x33dc64f2b5abae6, 0x27d704726f1f9ba, 0x2fdef2de96892ad, 0x3fd032a21834dbe, 0x1ce2548191e42ab, 0x431410a40ab44b, 0x206f1338c9a75e1, 0x130035675a32179, 0xdf781bb8adbd09, 0x1aaaf085ea624e0, 0x1df0605123c28e9, 0x28d3b3631320c9c, 0x81951a3af55e95, 0x388c776adc88ca1, 0x3ebed178f719885, 0x3c4546b19b0fe51, 0x129564a29700d09, 0x3f642277d82c520, 0x3a46d24ff0ac3fd, 0x1e75e367d627740, 0x33b01746a0f4aad, 0x2af930ca2fa61f, 0x3fcea0ca3af7aac, 0x230722de56e3f4a, 0x3541e58cc5afefd, 0x32cf711ae15ba7e, 0x11d3670d510fc6f, 0x6ddd78eec82112, 0x216210641885856, 0x87535f37c08809, 0x1fa464b5f82155b, 0xdbd43e91708494, 0x1500e23396dd2c4, 0x16cf4098632235f, 0x37e9117da8979ba, 0x6f8bfa04f66a7, 0x18dff008060e626, 0x196286fd9dbad1c, 0x35078156610f8ab, 0x7a669ff8398fea});\n+constexpr StatTable58 SQR_TABLE_58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x6300000000, 0x18c00000000, 0x63000000000, 0x18c000000000, 0x630000000000, 0x18c0000000000, 0x6300000000000, 0x18c00000000000, 0x63000000000000, 0x18c000000000000, 0x230000000000063, 0xc000000000014a, 0x300000000000528});\n+constexpr StatTable58 SQR2_TABLE_58({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x18c, 0x18c0, 0x18c00, 0x18c000, 0x18c0000, 0x18c00000, 0x18c000000, 0x18c0000000, 0x18c00000000, 0x18c000000000, 0x18c0000000000, 0x18c00000000000, 0x18c000000000000, 0xc000000000014a, 0x1405, 0x14050, 0x140500, 0x1405000, 0x14050000, 0x140500000, 0x1405000000, 0x14050000000, 0x140500000000, 0x1405000000000, 0x14050000000000, 0x140500000000000, 0x50000000001ef, 0x50000000001ef0, 0x10000000001ef63, 0x1ef7bc, 0x1ef7bc0, 0x1ef7bc00, 0x1ef7bc000, 0x1ef7bc0000, 0x1ef7bc00000, 0x1ef7bc000000, 0x1ef7bc0000000, 0x1ef7bc00000000, 0x1ef7bc000000000, 0x2f7bc0000000129, 0x37bc0000000112d, 0x3bc000000011027, 0x3c0000000110022});\n+constexpr StatTable58 SQR4_TABLE_58({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x18c0, 0x18c00000, 0x18c000000000, 0xc000000000014a, 0x1405000, 0x14050000000, 0x140500000000000, 0x1ef7bc, 0x1ef7bc0000, 0x1ef7bc00000000, 0x3bc000000011027, 0x110001100, 0x1100011000000, 0x11000000194c, 0x1000000194c018c, 0x194c0194c000, 0x14c0194c000014a, 0x194c00001545500, 0x15455154550, 0x154551545500000, 0x1154550001f18df, 0x150001f18c63193, 0x1f18c6318c7c00, 0xc6318c7c01010a, 0x18c7c0101000014, 0x1010000000101, 0x1000000010118c0, 0x10118d8c000, 0x10118d8c0000000, 0xd8c0000018d98a, 0x18d9811050, 0x18d98110500000, 0x18110500001411a, 0x500001410eb94c, 0x1410eb94bbc00, 0x10eb94bbc001ef0, 0x14bbc001ee85ab2, 0x1ee85aac1111, 0x2e85aac11110129, 0x2ac11110111097a, 0x111011109445c8c, 0x11109445c9554c0, 0x1445c9554d95406, 0x9554d954189419, 0xd954189414901f, 0x1894149014051f, 0x149014051e478f, 0x14051e478ee2ec, 0x11e478ee2edef63, 0x38ee2edef7aded3, 0x2edef7adef6bdc8, 0x37adef6bdf07c2d, 0x2f6bdf07c0018f9, 0x1f07c0018c018d1});\n+constexpr StatTable58 SQR8_TABLE_58({0x1, 0x1100011000000, 0x10118d8c0000000, 0xd954189414901f, 0xc018def7a2f6f6, 0x1e19cc6d44444e, 0x2b2e8450d1ef706, 0x196294c624791e5, 0x2a9441aa2b74da8, 0x1c6810fa7a2fe66, 0x4e0f0eff6badbb, 0x26faf3a76e59127, 0x11aa58d6498919f, 0x3b3ce4e04f23b30, 0x2ed3f70684ae8d7, 0x8d64c737fc5014, 0x1516c589c4fd458, 0x5ba5cee14ea182, 0x368ad344d93d4ae, 0x15e2547ea25ba2a, 0xdecb4283969d9a, 0x2f2a95e5c791149, 0x3fc958586bc93d2, 0x3216bfeab663783, 0xced412d3f6e530, 0x85fb7bcb26d797, 0x19be97fdbcede01, 0x192a5409529ebf4, 0x98b4f8527795b1, 0x192e8188bbc9aac, 0x322f07e9abdf6d0, 0x2a4a5cd6239de91, 0x4c97dec82e63a, 0x37d6397e1d26aee, 0x1939dc6d77a98db, 0x2e23b8e5b0a982a, 0x2787751f5aa0dba, 0x3f81252033f3cc8, 0x1171b73d009f511, 0x8811f0328040bb, 0x3a659ae0b1d2417, 0xc8b454d91baa72, 0x197b01428520b86, 0x1872c8c17f7fe81, 0x143f7913f4c7f5, 0x3a71b7542e7ec68, 0x3e60d3d49155d34, 0x11d5f10402402c8, 0x2be8db11809a1df, 0x3667129f17b1d6a, 0x2749715db24cd0a, 0x185d6130cdfee96, 0x3abdc4d78640154, 0x39bd5ea2e22f89a, 0x3f9a113c1095209, 0xdb4c8bd4f72f4e, 0x32ae35f0ad0b4ee, 0x2f3770997f16cc});\n+constexpr StatTable58 SQR16_TABLE_58({0x1, 0x2fcd2228a7c16ab, 0x846ef4a277243e, 0x1d2bf9061084cfb, 0x23598fddcd64f64, 0xcc36f3a7174e2a, 0x365a50c11b89583, 0x611bed1afae48, 0x22a03fae7957244, 0x45e6546308ff3e, 0x3aebd6f3893b9b4, 0x2bf4a9d5586f8db, 0x32fd7d2d5d6f867, 0x14819feeb813a6f, 0x100ab4d9ad808fc, 0x11c0fd674209c71, 0x3701211690581e7, 0x5c33087013a39a, 0x188935ebbc048bb, 0x10787f930a52538, 0xd49849206986b2, 0x17d1298ba5b565, 0x5d465e006f3142, 0x569a5ce90e9bff, 0x2b591716524b4cb, 0x32f7d39faa352cf, 0x10f701fea440dc0, 0x11c5f10a9d3c9d5, 0x18457154a0bf6ea, 0x15516f140726673, 0x1cf780781353aa4, 0x2a7d7e0e83c4bbc, 0x276c009e3198958, 0x220b8531adc2c11, 0x937d7effc370ab, 0x27632fc1b91dac1, 0x3b36628aa135d3f, 0x37230eddd77f21a, 0x1c1b5e0f410eca9, 0x3200c9c78a9127f, 0x3a55e6fb19e6dc4, 0x150cb064eb271f7, 0x5c74759db43ae1, 0x37046240fba02a9, 0x1937118eb920f04, 0x2795ad9a663a0c9, 0x1d4297ad3d62e8a, 0x3b927d82816e04d, 0x15b56f89c278c21, 0x2b8e4ef675619d6, 0x2e0823575b9bb28, 0xdeb4b405ed7e9c, 0x83d627c04e5155, 0x391134c52f7ae67, 0x9e2c9657999608, 0x3b1e574e9a4eb3a, 0x2b58dd062cd0021, 0x38d1fb86f1978ab});\n+constexpr StatTable58 QRT_TABLE_58({0x21b9dfe73454bc2, 0x351ca3a13788360, 0x351ca3a13788362, 0x1ad5a042934094, 0x351ca3a13788366, 0x48f62c33f34cc, 0x1ad5a04293409c, 0x14b1f9a41eb8342, 0x351ca3a13788376, 0x3682437996f7786, 0x48f62c33f34ec, 0x21ad5a152920174, 0x1ad5a0429340dc, 0x3766ef998858a86, 0x14b1f9a41eb83c2, 0x151ca3a437843c2, 0x351ca3a13788276, 0x1e5ac7c1aff42c, 0x3682437996f7586, 0x3767ee558c7856a, 0x48f62c33f30ec, 0x39fb408a690330, 0x21ad5a152920974, 0x372f1d7dbf4255a, 0x1ad5a0429350dc, 0x39bb888af33330, 0x3766ef99885aa86, 0x27b58e0ba2df00, 0x14b1f9a41ebc3c2, 0x1540d06c191bcf2, 0x151ca3a4378c3c2, 0x39ee0d0a17f4c0, 0x351ca3a13798276, 0x2049f6c5379fdb4, 0x1e5ac7c1adf42c, 0x1ac5a182d64bf0, 0x3682437996b7586, 0x16cbe3c0a2c7c1e, 0x3767ee558cf856a, 0x372a1d35b20aa6a, 0x48f62c32f30ec, 0x26ab144a891cdc, 0x39fb408a490330, 0x205df3712ae76a8, 0x21ad5a152d20974, 0x34fb58f12e386b6, 0x372f1d7db74255a, 0x21b4a5f53871674, 0x1ad5a0439350dc, 0x1d602e40318fdc, 0x39bb8888f33330, 0x179bb8888f3332e, 0x3766ef99c85aa86, 0x2cec9eb2f5d0aa8, 0x27b58e03a2df00, 0x6caa1452491cdc, 0x14b1f9a51ebc3c2, 0});\n+typedef Field<uint64_t, 58, 99, StatTable58, &SQR_TABLE_58, &SQR2_TABLE_58, &SQR4_TABLE_58, &SQR8_TABLE_58, &SQR16_TABLE_58, &QRT_TABLE_58, StatTable58, &LOAD_TABLE_58, &SAVE_TABLE_58> Field58;\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTableTRI58;\n+constexpr StatTableTRI58 SQR_TABLE_TRI58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x80001, 0x200004, 0x800010, 0x2000040, 0x8000100, 0x20000400, 0x80001000, 0x200004000, 0x800010000, 0x2000040000, 0x8000100000, 0x20000400000, 0x80001000000, 0x200004000000, 0x800010000000, 0x2000040000000, 0x8000100000000, 0x20000400000000, 0x80001000000000, 0x200004000000000, 0x10000100002, 0x40000400008, 0x100001000020, 0x400004000080, 0x1000010000200, 0x4000040000800, 0x10000100002000, 0x40000400008000, 0x100001000020000});\n+constexpr StatTableTRI58 SQR2_TABLE_TRI58({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x200004, 0x2000040, 0x20000400, 0x200004000, 0x2000040000, 0x20000400000, 0x200004000000, 0x2000040000000, 0x20000400000000, 0x200004000000000, 0x40000400008, 0x400004000080, 0x4000040000800, 0x40000400008000, 0x4000000001, 0x40000000010, 0x400000000100, 0x4000000001000, 0x40000000010000, 0x180001, 0x1800010, 0x18000100, 0x180001000, 0x1800010000, 0x18000100000, 0x180001000000, 0x1800010000000, 0x18000100000000, 0x180001000000000, 0x10000300006, 0x100003000060, 0x1000030000600, 0x10000300006000, 0x100003000060000, 0x30000400004, 0x300004000040, 0x3000040000400, 0x30000400004000, 0x300004000040000, 0x4000020000c, 0x4000020000c0, 0x4000020000c00, 0x4000020000c000});\n+constexpr StatTableTRI58 SQR4_TABLE_TRI58({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x2000040, 0x20000400000, 0x200004000000000, 0x40000400008000, 0x4000000001000, 0x18000100, 0x180001000000, 0x10000300006, 0x100003000060000, 0x30000400004000, 0x4000020000c00, 0x200004000100, 0x40001400008, 0x14000000001, 0x140000000010000, 0x380005000, 0x3800050000000, 0x5000070000e0, 0x70000400014, 0x3000040001c0001, 0x40001a0001c000, 0x1a000140001000, 0x1400024000680, 0x240004000050, 0x40000180009, 0x1800010001, 0x18000100010000, 0x1000130000600, 0x1300004000040, 0x4000220004c, 0x22000440001, 0x220004400010000, 0x44000540008800, 0x5400000001100, 0x1b800150, 0x1b8001500000, 0x380015000300006, 0x15000370006e000, 0x37000440005400, 0x440003a000dc0, 0x3a0005400110, 0x20005400160000e, 0x140016400068001, 0x164000400015000, 0x4000398005900, 0x3980051000100, 0x5100063000e6, 0x100063000460014, 0x2300044001c4001, 0x44001820018c00, 0x18200104001100, 0x1040021400608, 0x214004000041, 0x140040000010008});\n+constexpr StatTableTRI58 SQR8_TABLE_TRI58({0x1, 0x40001400008, 0x1300004000040, 0x4000398005900, 0x21a004140001000, 0x15007370046e014, 0x14004001b810158, 0x18022100441001, 0x1005130063600e6, 0x4200004181059, 0x447a1a3f41ccd0, 0x383d151573100e6, 0x101600544019940, 0x270027c0059c000, 0x4818070100e1, 0x20545402560168e, 0x76071e40419414, 0x38001501bb00157, 0x18054101401149, 0x104343116260a0c, 0x17b9c06c9180809, 0x35b793b6107d791, 0x2e706624276b452, 0x3a543cf805118, 0x278004063619444, 0x22aae45555d4155, 0x105597ba5075e80, 0x364504676052ce, 0x35800790000401, 0x264044141418809, 0x3313274051a405d, 0x52c1b85195848, 0x57f03b8205e9e, 0x22c5044070044e0, 0x1547370047f115, 0x10402383a848d51, 0x16220024510a1, 0x4050579e30c9e7, 0x15e201b4605c018, 0x297e7fd6e672cc2, 0x286f01429f08ff7, 0x31c56646279854c, 0x36fd34ece6e98e6, 0x31e6939431f00b9, 0x311386d18673a0a, 0x2b6524f5cf195aa, 0x2dd63711ff50016, 0x1585649073391ae, 0x1004431143e1ab5, 0x13be61cf659d4d9, 0x98a87036371777, 0x66673706472d14, 0x273867fcbd99159, 0x27c4c58464098e9, 0x347304213c56db, 0x721f05c140cc15, 0x38144503ed007d9, 0x2e054541404549});\n+constexpr StatTableTRI58 SQR16_TABLE_TRI58({0x1, 0x3f4d56f7779e1f0, 0xe27368ee2eeacd, 0x135c653e9699a2f, 0x6b0f78c5b96a46, 0x25fa3044c7e0248, 0x2a078335aa8c788, 0x2b2fb5e8ec09222, 0x214fe2bd0b14a22, 0x10b6f34977f0f41, 0x3dc4a1564361cee, 0xa2ae7c793a9fcf, 0x7fc45e1a362304, 0x3ec19729047ce58, 0x1ef9b26acd27396, 0x225a72a9b2db21a, 0xaaa90ccba715d8, 0x2da6362d54cd62, 0x37dae1e3484d433, 0x1ced37972ce3594, 0x164d907773ab8b9, 0xbeaf6f3fc883a1, 0x1d8ac7ee4682652, 0x102fa1481f0470a, 0x3e17062fd515fba, 0x21652276c35fe65, 0x57862a59d3fa78, 0x36b077a8057cde3, 0x287ce593d9cee2f, 0x290b965ae5d215a, 0x2cc2a18d887125c, 0xc46c603fd8423b, 0xdcd705a0e16776, 0x3307e00c6585a3f, 0x2d82d4b6c18532d, 0x28efe74f174d530, 0x2ddbc57b95adaac, 0x31d41679a107eb4, 0x1f24f6f872cb97f, 0x32718f9b0a03ff6, 0x1f283546f68ca0c, 0x158f309c150c885, 0x1ccaf78ea1873ea, 0x30e3b732bf1875f, 0xcce47efdb9ecb1, 0xcf3954987b5601, 0xebdc136185c456, 0x388046727963e11, 0x22e117909faee51, 0x3215b67613a2a60, 0x172480d3a2f11de, 0x382552280610b4d, 0x3c53c5d9c350cce, 0x6edc0d3330295e, 0x3452a6b8c868f37, 0x398cd7e93017ecc, 0x2e1ec37c30a741e, 0xb00d11006ffa14});\n+constexpr StatTableTRI58 QRT_TABLE_TRI58({0x2450096792a5c5c, 0x610014271011c, 0x610014271011e, 0x1f0cb811314ea88, 0x610014271011a, 0x8000000420, 0x1f0cb811314ea80, 0x265407ad8a20bcc, 0x610014271010a, 0x3d18be98392ebd0, 0x8000000400, 0xc29b930e407056, 0x1f0cb811314eac0, 0x1fcef001154dee8, 0x265407ad8a20b4c, 0xc69b924c61f94a, 0x610014271000a, 0x211006895845190, 0x3d18be98392e9d0, 0x54007accac09cc, 0x8000000000, 0xc08b934e107854, 0xc29b930e407856, 0x275407adc220bcc, 0x1f0cb811314fac0, 0x1f6db815164ea8a, 0x1fcef001154fee8, 0x1b2db801945e396, 0x265407ad8a24b4c, 0x21100ec95865590, 0xc69b924c61794a, 0x273507b1e530ad6, 0x610014270000a, 0x1b4cb835b34e29c, 0x211006895865190, 0x3839bf20d47e016, 0x3d18be98396e9d0, 0x3858bd34f36e01c, 0x54007acca409cc, 0, 0x8000100000, 0xc29a130e507856, 0xc08b934e307854, 0x13253921d448296, 0xc29b930e007856, 0x13c60935f6486bc, 0x275407adca20bcc, 0x3571be8c5e6c9da, 0x1f0cb811214fac0, 0x410014261011c, 0x1f6db815364ea8a, 0x13a50921d1486b6, 0x1fcef001554fee8, 0x64001249245a5c, 0x1b2db801145e396, 0x8610014670200a, 0x265407ac8a24b4c, 0x1a5cbfbdeb0f30c});\n+typedef FieldTri<uint64_t, 58, 19, StatTableTRI58, &SQR_TABLE_TRI58, &SQR2_TABLE_TRI58, &SQR4_TABLE_TRI58, &SQR8_TABLE_TRI58, &SQR16_TABLE_TRI58, &QRT_TABLE_TRI58, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri58;\n+\n+// 59 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable59;\n+constexpr StatTable59 SQR_TABLE_59({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x12a, 0x4a8, 0x12a0, 0x4a80, 0x12a00, 0x4a800, 0x12a000, 0x4a8000, 0x12a0000, 0x4a80000, 0x12a00000, 0x4a800000, 0x12a000000, 0x4a8000000, 0x12a0000000, 0x4a80000000, 0x12a00000000, 0x4a800000000, 0x12a000000000, 0x4a8000000000, 0x12a0000000000, 0x4a80000000000, 0x12a00000000000, 0x4a800000000000, 0x12a000000000000, 0x4a8000000000000, 0x2a000000000012a, 0x28000000000043d, 0x200000000001061});\n+constexpr StatTable59 SQR2_TABLE_59({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x12a, 0x12a0, 0x12a00, 0x12a000, 0x12a0000, 0x12a00000, 0x12a000000, 0x12a0000000, 0x12a00000000, 0x12a000000000, 0x12a0000000000, 0x12a00000000000, 0x12a000000000000, 0x2a000000000012a, 0x200000000001061, 0x10444, 0x104440, 0x1044400, 0x10444000, 0x104440000, 0x1044400000, 0x10444000000, 0x104440000000, 0x1044400000000, 0x10444000000000, 0x104440000000000, 0x4440000000012a, 0x4440000000012a0, 0x440000000012ea8, 0x40000000012ee28, 0x12ee628, 0x12ee6280, 0x12ee62800, 0x12ee628000, 0x12ee6280000, 0x12ee62800000, 0x12ee628000000, 0x12ee6280000000, 0x12ee62800000000, 0x2ee62800000012a, 0x6e6280000001061, 0x662800000010079, 0x62800000010016c, 0x28000000100103c});\n+constexpr StatTable59 SQR4_TABLE_59({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x12a0, 0x12a00000, 0x12a000000000, 0x2a000000000012a, 0x1044400, 0x10444000000, 0x104440000000000, 0x40000000012ee28, 0x12ee628000, 0x12ee6280000000, 0x662800000010079, 0x100101010, 0x1001010100000, 0x101010000012a0, 0x10000012a12b2a, 0x12a12b2b2a00, 0x2a12b2b2a00012a, 0x32b2a0001045461, 0x200010454541421, 0x104545414044000, 0x45414044012ef02, 0x4044012ef4d49aa, 0x12ef4d49e0ce28, 0x74d49e0ce290079, 0x1e0ce290000011d, 0x62900000100016d, 0x100010013a0, 0x100010013a00000, 0x10013a00012a000, 0x3a00012a012a12a, 0x12a012a116e400, 0x12a116e4010444, 0x116e40104450444, 0x40104450457ea6c, 0x4450457ea2692a0, 0x457ea2692ee7020, 0x22692ee706f7059, 0x2ee706f707e73ba, 0x6f707e73901116, 0x7e7390111013b6, 0x390111013b12b16, 0x11013b12b299b2a, 0x3b12b299b398b2a, 0x3299b398b17de61, 0x3398b17de543b4f, 0x317de543b7b1065, 0x6543b7b1053bb27, 0x37b1053bb4d0b6b, 0x53bb4d0b5b95ca, 0x34d0b5b95cfbf5b, 0x35b95cfbf6885b5, 0x5cfbf688587c89a, 0x7688587c8cf3adb, 0x587c8cf3aa00050, 0xcf3aa00001000d});\n+constexpr StatTable59 SQR8_TABLE_59({0x1, 0x1001010100000, 0x10013a00012a000, 0x3398b17de543b4f, 0x2a00116b8c2812a, 0x7cbf06ffa4d5cd6, 0x1288f1cf576c2e0, 0x3047cfc394d3391, 0x322d00452b2c451, 0x226dcb1999949d1, 0x2e2e5ab30351bc0, 0x10b2afcfca2edc6, 0x7ff39b98a3372a8, 0x2d7b439441ae332, 0x5603b26a2dae616, 0x3a13899c470338a, 0x16e8a14f0113f3c, 0x754f4aa46d3bb2, 0x38aa45436b16334, 0x634468d6b3f47b5, 0x248ca58bd03241d, 0x255d1fbddf51ae7, 0x7f4b46a330ef6bc, 0x3b3159b37b1a654, 0x7bbff798b50cf3e, 0x568afef7a72512a, 0x701d7955e599ab3, 0x3e7aed5ec2e2c82, 0x5c4d118847ff477, 0x21264d599c12421, 0x4d287fc89bb5a71, 0x6d1f30202fff956, 0x6c54d2de7c68bf8, 0x350c930ed65aed3, 0x5630ddede4ba32c, 0x7c18282af602d36, 0x198a362bf3c8a07, 0x40dde880541e01c, 0x49c0e7e7438c0c7, 0x3ade2abe6845a50, 0x6ffad83e7ac09c4, 0x52185a0d23e667a, 0x2e8c821b63a858a, 0x770e59a57577b23, 0x2fe0ea55e7032a6, 0x23cf0c9a1565a09, 0x1c53d32d80a4427, 0x23164f78db9fa8b, 0x691c4ffab038e2a, 0x33fc91a8a831d85, 0x48039e34eec4e05, 0x2581dbb898c10b5, 0x374067097dfc9f9, 0x241611fdbd3f8e7, 0x1b9f2934941d831, 0x1940c046b9b4a62, 0x5333ac5e7a608f6, 0xe9fa1f11b06830, 0x3d3bbe0ab819c34});\n+constexpr StatTable59 SQR16_TABLE_59({0x1, 0x857cdd2d43d447, 0xf829d2f68520b5, 0x19fe843a13f84fd, 0xcac85f3b30aa13, 0x5c7d9cd6997e169, 0x21e7ab9693a08f3, 0xe5cda6478df23f, 0xc3e206ed797b25, 0x755908ad7cca1c1, 0x16236a14b269480, 0x5fedfd73877a5e3, 0x6d66cb2c634cab2, 0x1b60fade310cb41, 0x5dcfd76c147e4ff, 0x2e686c220dcdc6a, 0x1d348a9dfc46113, 0x4e97ec4ce1b1081, 0x20ccc4ae0ada275, 0x5ec224932d09f73, 0x385cecd0572d2a0, 0x520f6a5162503d4, 0x3ff8003ba0976e, 0x5a314f7726ffcb7, 0x505c4f556b43e5a, 0x259ddd3f8c27783, 0x25441858e820409, 0x2714ab44ef6c58b, 0x53437cae5c3011c, 0x122c6454cb53ac0, 0x349b57934525af9, 0x394e01a9ab9a786, 0x665a91eb8e73f0d, 0x4c4e86cc5c98631, 0x7983a92ec037fe2, 0x67919ad3e0a3d69, 0x685c3d6c72af62e, 0x4eafca0e4b49fd7, 0x69534a8afbbeee, 0x720f8307d28c8cb, 0x49828239c03d1b7, 0x4c7e6edd9907a53, 0x1fe81ca4466f8fb, 0x19a865c194c7a23, 0x518bbfec9151454, 0x5b7bfbc756a7e4d, 0x146cc66da8b0754, 0x58e7cba08f0b29b, 0x1b578332a8f1985, 0x72d1c4f9eacac25, 0x6fc4f312025b99a, 0x199f6741974302b, 0x3edcb2e16193874, 0x38b45862414392c, 0x3a6669ab6604f52, 0x227da450a65496e, 0x4e85a5c57a7f719, 0x36b5dbf304b88be, 0x2ba8a1264ef68a0});\n+constexpr StatTable59 QRT_TABLE_59({0x38d905ab028567a, 0x789fa6ed3b44d72, 0x789fa6ed3b44d70, 0x74ec857e93d828c, 0x789fa6ed3b44d74, 0x116b3c1203c96, 0x74ec857e93d8284, 0xc25ebc3871e280, 0x789fa6ed3b44d64, 0x47a37c3d910b6, 0x116b3c1203cb6, 0xc7322d7a8f48de, 0x74ec857e93d82c4, 0xb509a0ea52e496, 0xc25ebc3871e200, 0x74fdee4681d3e0c, 0x789fa6ed3b44c64, 0x7ffbbd080b2f09a, 0x47a37c3d912b6, 0xd5c937bae506c8, 0x116b3c12038b6, 0xb173c76987625e, 0xc7322d7a8f40de, 0x7591ff36b3a682c, 0x74ec857e93d92c4, 0x72b253bfbfc90c4, 0xb509a0ea52c496, 0x79f2e7b10e6d452, 0xc25ebc3871a200, 0x78c86e951086aac, 0x74fdee4681dbe0c, 0x78c96eb514c602c, 0x789fa6ed3b54c64, 0xc34818b95658e8, 0x7ffbbd080b0f09a, 0x7399f563b1980f2, 0x47a37c3dd12b6, 0xa29e0e28c58880, 0xd5c937baed06c8, 0x788ac23520ac82c, 0x116b3c13038b6, 0xa2c857e83d92b6, 0xb173c769a7625e, 0x608da990122e48, 0xc7322d7acf40de, 0xa3a89269eebefe, 0x7591ff36bba682c, 0xa25ebc2871a200, 0x74ec857e83d92c4, 0x11f62e419f1cfe, 0x72b253bf9fc90c4, 0x7425ebc2871a272, 0xb509a0ee52c496, 0x4ed8555979c8de, 0x79f2e7b18e6d452, 0x6c3580d5915d4d2, 0xc25ebc2871a200, 0, 0x78c86e971086aac});\n+typedef Field<uint64_t, 59, 149, StatTable59, &SQR_TABLE_59, &SQR2_TABLE_59, &SQR4_TABLE_59, &SQR8_TABLE_59, &SQR16_TABLE_59, &QRT_TABLE_59, IdTrans, &ID_TRANS, &ID_TRANS> Field59;\n+\n+// 60 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTableTRI60;\n+constexpr StatTableTRI60 SQR_TABLE_TRI60({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000, 0xc00000000000, 0x3000000000000, 0xc000000000000, 0x30000000000000, 0xc0000000000000, 0x300000000000000, 0xc00000000000000});\n+constexpr StatTableTRI60 SQR2_TABLE_TRI60({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x3, 0x30, 0x300, 0x3000, 0x30000, 0x300000, 0x3000000, 0x30000000, 0x300000000, 0x3000000000, 0x30000000000, 0x300000000000, 0x3000000000000, 0x30000000000000, 0x300000000000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x50000000, 0x500000000, 0x5000000000, 0x50000000000, 0x500000000000, 0x5000000000000, 0x50000000000000, 0x500000000000000, 0xf, 0xf0, 0xf00, 0xf000, 0xf0000, 0xf00000, 0xf000000, 0xf0000000, 0xf00000000, 0xf000000000, 0xf0000000000, 0xf00000000000, 0xf000000000000, 0xf0000000000000, 0xf00000000000000});\n+constexpr StatTableTRI60 SQR4_TABLE_TRI60({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x30, 0x300000, 0x3000000000, 0x30000000000000, 0x500, 0x5000000, 0x50000000000, 0x500000000000000, 0xf000, 0xf0000000, 0xf00000000000, 0x11, 0x110000, 0x1100000000, 0x11000000000000, 0x330, 0x3300000, 0x33000000000, 0x330000000000000, 0x5500, 0x55000000, 0x550000000000, 0x50000000000000f, 0xff000, 0xff0000000, 0xff00000000000, 0x101, 0x1010000, 0x10100000000, 0x101000000000000, 0x3030, 0x30300000, 0x303000000000, 0x30000000000005, 0x50500, 0x505000000, 0x5050000000000, 0x5000000000000f0, 0xf0f000, 0xf0f0000000, 0xf0f00000000000, 0x1111, 0x11110000, 0x111100000000, 0x111000000000003, 0x33330, 0x333300000, 0x3333000000000, 0x330000000000055, 0x555500, 0x5555000000, 0x55550000000000, 0x500000000000fff, 0xffff000, 0xffff0000000, 0xffff00000000000});\n+constexpr StatTableTRI60 SQR8_TABLE_TRI60({0x1, 0x110000, 0x10100000000, 0x111000000000003, 0x300030, 0x33003300000, 0x30303000000005, 0x330000000555555, 0x50000000500, 0x50000005500000f, 0x5050000f0f000, 0x5000ffff0000fff, 0xf000f000f011, 0xff00ff1010101, 0xf0e11111111111, 0x31, 0x3210000, 0x313100000000, 0x221000000000056, 0x5300530, 0x563056300000, 0x5353530000000f5, 0x63000000faaaaaa, 0xf5000000f500, 0x500000fa500010e, 0xf5f50011e1f000, 0x5010ffef0010ffe, 0x11f011f011f321, 0x10ef10ec1313131, 0x1e2d22222222222, 0x501, 0x55110000, 0x5040100000000, 0x411000000000ffc, 0xf030f030, 0xff33ff3300000, 0xc0c03000001114, 0x330000100555554, 0x11050000110500, 0x50001015500303f, 0x114050333c0f003, 0x5300fcff0300fcf, 0x330f330f330a511, 0x3fc03af4040404, 0x395b44444444444, 0xf531, 0xfa6210000, 0xf5c43100000000, 0x721000000010fa8, 0x11f521f530, 0x10ea73ea6300000, 0x4d4c530000322d7, 0x63000310faaaa9b, 0x321f5000321f500, 0x500313ea505343e, 0x2d4f55677d1f056, 0x310acef5310ace, 0x621a621a62e562e, 0x43bc4cb34c4c4c4, 0x878788888888888});\n+constexpr StatTableTRI60 SQR16_TABLE_TRI60({0x1, 0x563055110000, 0x111010233c0f003, 0x1200afffa8baffc, 0x5356030553000c5, 0x7145cf221744a77, 0x5748045489aaaaf, 0x7d52fcee4febdb3, 0x221f633c000a012, 0x41431fb55d4f4c8, 0x7f126132f4be5d5, 0x323da1f43c3a7e0, 0x373b24844474766, 0x6cc378a25584eb, 0x7ef66648aae4aca, 0x33003000031, 0xc0c03fb7c0f1fb, 0x174757777d10536, 0x2116210a52facb3, 0x5316fc100c1fb35, 0x7aae07597d161e1, 0x6752c4decfb6b7f, 0xf590fa78d56bf3, 0x1be67573275f157, 0xe3e0e9e0d61817, 0x25ac0012251ff6c, 0x407de1e40e3a849, 0x7a7264848fdf67e, 0x3bb8ba7d3879348, 0x498941f57060c6c, 0x5000000f0f501, 0x10fa8cfc1213ac0, 0x51a500f5501aab9, 0x73ef9049dcace64, 0x526a202f322f6e7, 0x2789a852500ca93, 0x4d1346684907509, 0x7d02bcfe4febdb2, 0x330a0329aba0521, 0x50a33c66415f5eb, 0x2e99dced402a73d, 0xf78f2f1a2dbcfe, 0x793a675db461a6a, 0x73848cd4c2f25d2, 0x54fa22d244aa9c6, 0xfae22e13e01501, 0x538ead296f222e5, 0x4da65592d2a750a, 0x40f91ebc14fcd2a, 0x5e73ff2f3c21c03, 0x4c72dce55551460, 0x3ffa59f8e5aef0a, 0x30057fa7b802f82, 0x36efe87d58aa6e4, 0x3bc96a196d71957, 0x5a82cfde2ad602f, 0x1f9bce94df9d3bf, 0x43c91d9b6bcabba, 0x2193c1833502ba3, 0xd28f516c1311d3d});\n+constexpr StatTableTRI60 QRT_TABLE_TRI60({0x6983c00fe00104a, 0x804570322e054e6, 0x804570322e054e4, 0x15673387e0a4e4, 0x804570322e054e0, 0x100010110, 0x15673387e0a4ec, 0x920d01f34442a70, 0x804570322e054f0, 0x7a8dc0f2e4058f0, 0x100010130, 0x120c01f140462f0, 0x15673387e0a4ac, 0x7bdbb2ca9a4fe5c, 0x920d01f34442af0, 0xe9c6b039ce0c4ac, 0x804570322e055f0, 0xfac8b080ca20c00, 0x7a8dc0f2e405af0, 0x7a8dc4b2e4a59f0, 0x100010530, 0x10000100000, 0x120c01f14046af0, 0x131a02d91c5db6c, 0x15673387e0b4ac, 0x15623387d0b4ac, 0x7bdbb2ca9a4de5c, 0x7ffbbbca0a8ee5c, 0x920d01f34446af0, 0x800000020000000, 0xe9c6b039ce044ac, 0x81130302500f000, 0x804570322e155f0, 0x935b72eb3a48e9c, 0xfac8b080ca00c00, 0x120c016140563c0, 0x7a8dc0f2e445af0, 0x7bcbb3ca8a4ee5c, 0x7a8dc4b2e4259f0, 0xc4000a0300, 0x100110530, 0x11623285c1b19c, 0x10000300000, 0x420890090c3000, 0x120c01f14446af0, 0x68d7b33b9e0b4ac, 0x131a02d9145db6c, 0xe8ccb1e18a56fc0, 0x15673386e0b4ac, 0x7aadc8f2e485af0, 0x15623385d0b4ac, 0x4a0990093c3000, 0x7bdbb2cada4de5c, 0xf9d6b3389e0b4ac, 0x7ffbbbca8a8ee5c, 0xdf6ba38cec84ac, 0x920d01f24446af0, 0x520d01f24446af0, 0x800000000000000, 0});\n+typedef FieldTri<uint64_t, 60, 1, StatTableTRI60, &SQR_TABLE_TRI60, &SQR2_TABLE_TRI60, &SQR4_TABLE_TRI60, &SQR8_TABLE_TRI60, &SQR16_TABLE_TRI60, &QRT_TABLE_TRI60, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri60;\n+\n+// 61 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable61;\n+constexpr StatTable61 SQR_TABLE_61({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x13800000, 0x4e000000, 0x138000000, 0x4e0000000, 0x1380000000, 0x4e00000000, 0x13800000000, 0x4e000000000, 0x138000000000, 0x4e0000000000, 0x1380000000000, 0x4e00000000000, 0x13800000000000, 0x4e000000000000, 0x138000000000000, 0x4e0000000000000, 0x1380000000000000, 0xe0000000000004e, 0x180000000000011f});\n+constexpr StatTable61 SQR2_TABLE_61({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x138, 0x1380, 0x13800, 0x138000, 0x1380000, 0x13800000, 0x138000000, 0x1380000000, 0x13800000000, 0x138000000000, 0x1380000000000, 0x13800000000000, 0x138000000000000, 0x1380000000000000, 0x180000000000011f, 0x1054, 0x10540, 0x105400, 0x1054000, 0x10540000, 0x105400000, 0x1054000000, 0x10540000000, 0x105400000000, 0x1054000000000, 0x10540000000000, 0x105400000000000, 0x1054000000000000, 0x540000000000138, 0x14000000000013ce, 0x13d96, 0x13d960, 0x13d9600, 0x13d96000, 0x13d960000, 0x13d9600000, 0x13d96000000, 0x13d960000000, 0x13d9600000000, 0x13d96000000000, 0x13d960000000000, 0x13d9600000000000, 0x1d9600000000011f, 0x196000000000101a, 0x1600000000010004});\n+constexpr StatTable61 SQR4_TABLE_61({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x138, 0x1380000, 0x13800000000, 0x138000000000000, 0x10540, 0x105400000, 0x1054000000000, 0x540000000000138, 0x13d9600, 0x13d96000000, 0x13d960000000000, 0x1600000000010004, 0x100111000, 0x1001110000000, 0x11100000000138, 0x10000000013812b8, 0x13812ab8000, 0x13812ab80000000, 0x12ab800000010540, 0x105514114, 0x1055141140000, 0x551411400000138, 0x1140000013d84f6, 0x13d84f72f60, 0x13d84f72f600000, 0x4f72f6000010004, 0xf6000010000010f, 0x1000001010100, 0x10101000138, 0x101010001380000, 0x100013800013938, 0x138000139393800, 0x1393938010540, 0x193938010540011f, 0x180105400104445f, 0x540010444454138, 0x1044445413d9600, 0x445413d96013cae, 0x13d96013caaab96, 0x16013caaab970004, 0x1caaab970011111f, 0xb9700111101100b, 0x11110110010028, 0x11011001002812b8, 0x1001002812aab938, 0x2812aab92b8138, 0x12aab92b81382ec0, 0x192b81382ed1400b, 0x1382ed140105514, 0xed1401055150567, 0x105515056890f6, 0x1515056890f613ce, 0x56890f613d84e58, 0x10f613d84e5db85c, 0x13d84e5db84f6010, 0xe5db84f6000000e, 0x184f600000010123});\n+constexpr StatTable61 SQR8_TABLE_61({0x1, 0x100111000, 0x10101000138, 0x1001002812aab938, 0x1000001390478, 0x113916c2d28792b8, 0x1904457c4545aa5f, 0x13aa7f0f280c5e20, 0x1047900101540, 0x13be84504128808e, 0x839d72c6e39c0f1, 0x16a18bbeafc6bac6, 0x7290382d6ea1584, 0x1d7d80a66b181691, 0x19d2aaa6110c5d47, 0x1b613d85f602c96f, 0x3812870738, 0x113dbce704cbbd40, 0xd92856e5392f94b, 0x84f76c3d7c304a3, 0x1a519225fe5ce8cf, 0x1704aca0c7190b8e, 0xb7fb1620ed7d025, 0x12831368539314f6, 0x748fb7c048744be, 0x78cc8029440fcba, 0x10eb05b6015eb730, 0xfd3c38351ebc6bd, 0x1665bcfabbfbe624, 0x136549cb4738e1ec, 0x6db6139d4b707f2, 0x1000057853aeac78, 0x104401500109340, 0x554c25992c8f3d8, 0x192dd4b6c0886747, 0x219c35ac73165fc, 0xdf27daa47ee296b, 0x73ab415a10863d2, 0x1f06884b4f2dc1dd, 0xb56c8c3efd7847f, 0x7a6a82768a4a3f2, 0x8773791c3b9f69f, 0x1e4d128bbd8fa105, 0x16977fb4d8984d86, 0xb9a5106882f60bf, 0xc5102ee91822469, 0xdab44dc3cdf7a0b, 0x18d48e2841f63e4, 0x165b8e4d03de40d4, 0x11a7aec6ef42385a, 0x17064ddd9b5041ea, 0xf89b61f74d1f401, 0x18583a8c57e6cb7f, 0x607279105fda3be, 0x905e9c0d58240c7, 0x1ed3c0319519fa7d, 0xa3227b6d1cc17a1, 0xf6cb7bb2aa84563, 0xdda77eb9b649e97, 0x15480a00ec829caf, 0x62cb6da6128c272});\n+constexpr StatTable61 SQR16_TABLE_61({0x1, 0x1c7cd18a3a216933, 0xd201ddad374eb4, 0xee4694049c47289, 0x40db9f51130a1e6, 0x134cab3c67ec43f4, 0x97823873a2fc00f, 0xc08b772e8161a43, 0x128159f3d3611eac, 0x1f002f36181d6c4, 0x9de899abbd8d18f, 0x1a6ecb093fbb558b, 0xa6a1251b5961643, 0x1b285c169fb6616d, 0x9c04f5fcf0a4ce5, 0xd050c0ab89025ad, 0xdab152bf63418d9, 0xad3e33af7686059, 0x1561180155ac0dc8, 0x1d9e862521ab7d29, 0xa21b06e1e7632b5, 0x29b84e35cfc95ac, 0x17a27c78dac90e2c, 0x1312fa5f7b1e4ea2, 0xfe66bf53de6a93d, 0x182041e17dde85e9, 0x1289eb06f1803a2e, 0x129449a509af818c, 0x1f308057c81ab449, 0x419981420870054, 0x19f853b859910eb1, 0x9b422c0e9d60871, 0x9e6aec92bfcfa99, 0x15a788f1748b8f44, 0x1fa9a9c171dd83a1, 0x14096af6c0840cc6, 0x1bbe256976515067, 0x14f853fd9e5c0002, 0xf6256b0235f7a8, 0x37e727448043cf6, 0xbb0f467dd137c3f, 0x2538d574ceec19e, 0x15ff26c652c82188, 0x1c22b1e2a9ed31f3, 0x1f56b4b705c21301, 0x1502df3e9aa51832, 0x89c3dec02a6a543, 0x15eac5a464a4f736, 0x1d5023636fc14fa7, 0x499c5d458f9699e, 0x355b147c1703428, 0x1864a11df3efee51, 0x9af0f612e9c1265, 0x9c613962a1c08d9, 0x1cee6fc68f73b3f7, 0x185720007e663719, 0x101dd90a4502bf06, 0x1569af254da87eb0, 0x1781376276013a90, 0x10d2bf3d5e191483, 0x6215713bdc7d250});\n+constexpr StatTable61 QRT_TABLE_61({0x171d34fcdac955d0, 0x12cfc8c049e1c96, 0x12cfc8c049e1c94, 0x71d34fcdac955c2, 0x12cfc8c049e1c90, 0x631c871de564852, 0x71d34fcdac955ca, 0x129fa6407f27300, 0x12cfc8c049e1c80, 0x7094f6fdd0a3b12, 0x631c871de564872, 0xdb28cee59c8256a, 0x71d34fcdac9558a, 0xc8a0be15a915472, 0x129fa6407f27380, 0x12dfcb4058e0b80, 0x12cfc8c049e1d80, 0x117d7f04ad0118, 0x7094f6fdd0a3912, 0x621b576dbe35b6a, 0x631c871de564c72, 0x13c808a013a1ee0, 0xdb28cee59c82d6a, 0x113d79842a0272, 0x71d34fcdac9458a, 0x719776b580b6a98, 0xc8a0be15a917472, 0x6633498d6db760a, 0x129fa6407f23380, 0xbd4ae9e8c3e7560, 0x12dfcb4058e8b80, 0x8000000a, 0x12cfc8c049f1d80, 0x634ce9add3b26ea, 0x117d7f04af0118, 0xda3f19c5d66258a, 0x7094f6fdd0e3912, 0xb87427e85e71560, 0x621b576dbeb5b6a, 0xc8b0b085b8c4e0a, 0x631c871de464c72, 0x1538fc8649458a, 0x13c808a011a1ee0, 0xcddbca6d1cfe360, 0xdb28cee59882d6a, 0xae80f550d1ffff2, 0x113d7984aa0272, 0xda7770f5f195912, 0x71d34fcdbc9458a, 0x137c8a049a1ee0, 0x719776b5a0b6a98, 0xded39a9d236ba78, 0xc8a0be15e917472, 0x6732488ca7ce0a, 0x6633498dedb760a, 0xc0406d0527cb80a, 0x129fa6417f23380, 0x3d4ae9eac3e756a, 0xbd4ae9eac3e7560, 0, 0x12dfcb4458e8b80});\n+typedef Field<uint64_t, 61, 39, StatTable61, &SQR_TABLE_61, &SQR2_TABLE_61, &SQR4_TABLE_61, &SQR8_TABLE_61, &SQR16_TABLE_61, &QRT_TABLE_61, IdTrans, &ID_TRANS, &ID_TRANS> Field61;\n+\n+// 62 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable62;\n+constexpr StatTable62 SQR_TABLE_62({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x20000001, 0x80000004, 0x200000010, 0x800000040, 0x2000000100, 0x8000000400, 0x20000001000, 0x80000004000, 0x200000010000, 0x800000040000, 0x2000000100000, 0x8000000400000, 0x20000001000000, 0x80000004000000, 0x200000010000000, 0x800000040000000, 0x2000000100000000, 0x440000002, 0x1100000008, 0x4400000020, 0x11000000080, 0x44000000200, 0x110000000800, 0x440000002000, 0x1100000008000, 0x4400000020000, 0x11000000080000, 0x44000000200000, 0x110000000800000, 0x440000002000000, 0x1100000008000000});\n+constexpr StatTable62 SQR2_TABLE_62({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x80000004, 0x800000040, 0x8000000400, 0x80000004000, 0x800000040000, 0x8000000400000, 0x80000004000000, 0x800000040000000, 0x440000002, 0x4400000020, 0x44000000200, 0x440000002000, 0x4400000020000, 0x44000000200000, 0x440000002000000, 0x400000000000001, 0x20000011, 0x200000110, 0x2000001100, 0x20000011000, 0x200000110000, 0x2000001100000, 0x20000011000000, 0x200000110000000, 0x2000001100000000, 0x11100000008, 0x111000000080, 0x1110000000800, 0x11100000008000, 0x111000000080000, 0x1110000000800000, 0x1100000088000004, 0x1000000800000044, 0x8080000444, 0x80800004440, 0x808000044400, 0x8080000444000, 0x80800004440000, 0x808000044400000, 0x80000404000002, 0x800004040000020, 0x40440000202, 0x404400002020, 0x4044000020200, 0x40440000202000, 0x404400002020000});\n+constexpr StatTable62 SQR4_TABLE_62({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x80000004, 0x800000040000, 0x440000002, 0x4400000020000, 0x20000011, 0x200000110000, 0x2000001100000000, 0x11100000008000, 0x1000000800000044, 0x8080000444000, 0x800004040000020, 0x40440000202000, 0x400000000000101, 0x20001011000, 0x200010110000000, 0x101110000000800, 0x1100008088000404, 0x80808004044400, 0x80044404000202, 0x444044002020200, 0x440002002001110, 0x20002011101100, 0x20110011000080, 0x1100111000800080, 0x1110080000804400, 0x800080844004440, 0x808400044402000, 0x404400002021, 0x44000000210001, 0x300010110, 0x3000101100000, 0x101118000000c, 0x1118000800c0004, 0x8084c0040446, 0x84c00444460002, 0x4440460020213, 0x404600022130011, 0x2000201120111011, 0x2011301110118000, 0x3011001900008044, 0x1918080044c044, 0x1808004840440064, 0x484c4000646020, 0xc40004040200121, 0x40460001213100, 0x600010111000101, 0x101120001011800, 0x1200018198000404, 0x181910004044800, 0x110004c488000606, 0x4c4808006064400, 0x80046404001312, 0x464044013120200, 0x440112002001190, 0x1120002011901100, 0x20190011004480, 0x1900111044800080, 0x1110480000806400});\n+constexpr StatTable62 SQR8_TABLE_62({0x1, 0x400000000000101, 0x44000000210001, 0x40460001213100, 0x404500002021, 0xe40014150200121, 0x80b400145512000, 0x1495c4000646820, 0x8000808c4004445, 0xd0800c8c8440561, 0x1045c80080ad6405, 0x1988b0805419944, 0x190110048480008e, 0x2891049dcc008662, 0x8ac190411026482, 0x241574511233a020, 0x1120002031901110, 0x3040203922110044, 0x1110792020b25580, 0x282a4830647355, 0x2c60001037102032, 0x26e4507065221080, 0x2036c57040579390, 0x3450409552c0cc02, 0x5c4000c66824017, 0x5508ce8e2845301, 0x4934eca8d59343, 0x1c28a918f7c9c0d1, 0xb080581194c8e4, 0x1018495dc440e46a, 0x1ac80985d8604226, 0xc7044545722023, 0x145120003031900, 0x4440003a0200005, 0x134447a19a002514, 0x510e645a31f1135, 0xae4834446175200, 0x264f451435730311, 0x7220c2004155891, 0x2153045891358c65, 0x154154800ca02904, 0x54dc0c88ce92565, 0xdc54bc04d28bc20, 0x8c54b0401283d8b, 0x29088e8109411f28, 0x12d0dc41982620a, 0xc0030c89a712640, 0x1dc8192422907592, 0x145554681022a075, 0x470792013225580, 0x346c6a7130667300, 0x39147d7004b077b2, 0x6c83e2d354461c6, 0xcf6d0046247a030, 0x3221c0f063a45c80, 0x303645fc20539787, 0x21004cf150409b10, 0x1dd380444d78042, 0x1c709df8b7145381, 0x185834a4e8d51327, 0x1420e118b389a4d1, 0xf0c41811b4e8c4});\n+constexpr StatTable62 SQR16_TABLE_62({0x1, 0x147095f0731417c5, 0x3189fad107702e11, 0x3d3937fd86a460ab, 0x3ff26c959b47c587, 0x1e2ecbec4bf22bd6, 0x168ebaeceaf71b82, 0x216d6c4471f75c10, 0x1f6d31ccabfaee58, 0x1652ef2066ec0c61, 0x3d62ef6847f808fc, 0x26a33c99ec1b43d4, 0x32f26e79367c91ed, 0x361dcdd0d1e73240, 0xe2d494d081269e2, 0x33d231b9098b6045, 0x3c4e93c22fb78a3, 0x2f655fa56e578df3, 0x3a2b9600532c2609, 0x864e125951bbdb7, 0x2e2fca705bb62c58, 0x28e0629106401eaa, 0x7ac20f0ed6cdc1f, 0x3bd50add28a35850, 0x1a6e5ea19a59ab5d, 0x2add6d1d8c0aaefb, 0x2c3cf9842e6956a3, 0x1906944685f2c7c, 0x925997c95ed1de2, 0xcb9eb5d43c6f2e9, 0x1795f2b48a0fa71d, 0x19de5de41acc2100, 0x2e30c3a8444ef165, 0x29433812a3c4b1cd, 0xcbfa65dcdae6d63, 0x2580f2100e56c068, 0x25ce14544acc08cb, 0x24fa7059a7c87e18, 0x2a01d608b5d57d70, 0x3cefa2f54bdabc51, 0x29225fd40de84dea, 0x2d2276d8df087f20, 0x1a077580d9c5e840, 0x33b71879319b7de1, 0x16017e84617bddf4, 0x2596d6b0bd1a954c, 0x10267caddadbf666, 0x22c43bd90eaa3e05, 0xcaf6704a39c29fc, 0x25a0b38132106551, 0x1a78d1fcfd98f2a2, 0x1924d0b08fe1cc34, 0x3ea0a05c4cb14ee5, 0xa9b505540022072, 0x1e65cd1d5556d710, 0x3682cccd684103f1, 0x20a58fb864d70967, 0x35bfeeacb88f9b9b, 0x3b72dce9c4b09b87, 0x839908c285aaa64, 0x2ed676dc722e9732, 0x3dd67b08dc071450});\n+constexpr StatTable62 QRT_TABLE_62({0x30268b6fba455d2c, 0x200000006, 0x200000004, 0x3d67cb6c1fe66c76, 0x200000000, 0x3fc4f1901abfa400, 0x3d67cb6c1fe66c7e, 0x35e79b6c0a66bcbe, 0x200000010, 0x1e9372bc57a9941e, 0x3fc4f1901abfa420, 0x21ec9d424957a5b0, 0x3d67cb6c1fe66c3e, 0x1cb35a6e52f5fb0e, 0x35e79b6c0a66bc3e, 0x215481024c13a730, 0x200000110, 0x1c324a6c52f75b08, 0x1e9372bc57a9961e, 0x3764a9d00f676820, 0x3fc4f1901abfa020, 0x355481020e132730, 0x21ec9d424957adb0, 0x3c43c32c0f34301e, 0x3d67cb6c1fe67c3e, 0x1496122c45259728, 0x1cb35a6e52f5db0e, 0x15e418405b72ec20, 0x35e79b6c0a66fc3e, 0x30268b6e3a445c38, 0x215481024c132730, 0x100010114, 0x200010110, 0, 0x1c324a6c52f55b08, 0x215581044d133776, 0x1e9372bc57ad961e, 0x2155810e4d133766, 0x3764a9d00f6f6820, 0x2157833c4d12323e, 0x3fc4f1901aafa020, 0x1c324a4252f55b58, 0x355481020e332730, 0x28332fc0509d41e, 0x21ec9d424917adb0, 0x215783be4d12332e, 0x3c43c32c0fb4301e, 0x2157822c4d06363e, 0x3d67cb6c1ee67c3e, 0x23f6b9d2484afb78, 0x1496122c47259728, 0x14b8184047648a80, 0x1cb35a6e56f5db0e, 0x3fe4f1901aefa820, 0x15e418405372ec20, 0x3d5fd72c1be276be, 0x35e79b6c1a66fc3e, 0x14b038d24774cf10, 0x30268b6e1a445c38, 0x1d17022e43a7172e, 0x215481020c132730, 0x2157022e4d07372e});\n+typedef Field<uint64_t, 62, 536870913, StatTable62, &SQR_TABLE_62, &SQR2_TABLE_62, &SQR4_TABLE_62, &SQR8_TABLE_62, &SQR16_TABLE_62, &QRT_TABLE_62, IdTrans, &ID_TRANS, &ID_TRANS> Field62;\n+typedef FieldTri<uint64_t, 62, 29, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5>, &SQR_TABLE_62, &SQR2_TABLE_62, &SQR4_TABLE_62, &SQR8_TABLE_62, &SQR16_TABLE_62, &QRT_TABLE_62, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri62;\n+\n+// 63 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTableTRI63;\n+constexpr StatTableTRI63 SQR_TABLE_TRI63({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000, 0x18000, 0x60000, 0x180000, 0x600000, 0x1800000, 0x6000000, 0x18000000, 0x60000000, 0x180000000, 0x600000000, 0x1800000000, 0x6000000000, 0x18000000000, 0x60000000000, 0x180000000000, 0x600000000000, 0x1800000000000, 0x6000000000000, 0x18000000000000, 0x60000000000000, 0x180000000000000, 0x600000000000000, 0x1800000000000000, 0x6000000000000000});\n+constexpr StatTableTRI63 SQR2_TABLE_TRI63({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x6, 0x60, 0x600, 0x6000, 0x60000, 0x600000, 0x6000000, 0x60000000, 0x600000000, 0x6000000000, 0x60000000000, 0x600000000000, 0x6000000000000, 0x60000000000000, 0x600000000000000, 0x6000000000000000, 0x14, 0x140, 0x1400, 0x14000, 0x140000, 0x1400000, 0x14000000, 0x140000000, 0x1400000000, 0x14000000000, 0x140000000000, 0x1400000000000, 0x14000000000000, 0x140000000000000, 0x1400000000000000, 0x4000000000000006, 0x78, 0x780, 0x7800, 0x78000, 0x780000, 0x7800000, 0x78000000, 0x780000000, 0x7800000000, 0x78000000000, 0x780000000000, 0x7800000000000, 0x78000000000000, 0x780000000000000, 0x7800000000000000});\n+constexpr StatTableTRI63 SQR4_TABLE_TRI63({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x6, 0x60000, 0x600000000, 0x6000000000000, 0x14, 0x140000, 0x1400000000, 0x14000000000000, 0x78, 0x780000, 0x7800000000, 0x78000000000000, 0x110, 0x1100000, 0x11000000000, 0x110000000000000, 0x660, 0x6600000, 0x66000000000, 0x660000000000000, 0x1540, 0x15400000, 0x154000000000, 0x1540000000000000, 0x7f80, 0x7f800000, 0x7f8000000000, 0x7f80000000000000, 0x10100, 0x101000000, 0x1010000000000, 0x100000000000006, 0x60600, 0x606000000, 0x6060000000000, 0x600000000000014, 0x141400, 0x1414000000, 0x14140000000000, 0x1400000000000078, 0x787800, 0x7878000000, 0x78780000000000, 0x7800000000000110, 0x1111000, 0x11110000000, 0x111100000000000, 0x1000000000000666, 0x6666000, 0x66660000000, 0x666600000000000, 0x6000000000001554, 0x15554000, 0x155540000000, 0x1555400000000000, 0x4000000000007ffe, 0x7fff8000, 0x7fff80000000, 0x7fff800000000000});\n+constexpr StatTableTRI63 SQR8_TABLE_TRI63({0x1, 0x110, 0x10100, 0x1111000, 0x100010000, 0x11001100000, 0x1010101000000, 0x111111110000000, 0x100000006, 0x11000000660, 0x1010000060600, 0x111100006666000, 0x1000600060006, 0x110066006600660, 0x106060606060606, 0x1666666666666666, 0x12, 0x1320, 0x121200, 0x13332000, 0x1200120000, 0x132013200000, 0x12121212000000, 0x1333333320000000, 0x120000006c, 0x132000006ac0, 0x121200006c6c00, 0x133320006aaac000, 0x12006c006c006c, 0x13206ac06ac06ac0, 0x126c6c6c6c6c6c6c, 0x4aaaaaaaaaaaaaaa, 0x104, 0x11440, 0x1050400, 0x115544000, 0x10401040000, 0x1144114400000, 0x105050504000000, 0x1555555440000006, 0x10400000618, 0x1144000067980, 0x1050400061e1800, 0x155440067ff98006, 0x104061806180618, 0x1446798679867986, 0x21e1e1e1e1e1e1e, 0x3fffffffffffffec, 0x1248, 0x136c80, 0x125a4800, 0x137fec8000, 0x124812480000, 0x136c936c800000, 0x125a5a5a48000000, 0x7fffffec8000006a, 0x124800006db0, 0x136c80006b6b00, 0x125a48006dddb000, 0x7fec806b006b006a, 0x12486db06db06db0, 0x6ceb6b6b6b6b6b6a, 0x25dddddddddddddc});\n+constexpr StatTableTRI63 SQR16_TABLE_TRI63({0x1, 0x10006, 0x100000014, 0x1000600140078, 0x116, 0x1160674, 0x11600001538, 0x116067415387e90, 0x10114, 0x101120678, 0x1011400141510, 0x112066c15687e66, 0x1170338, 0x117054a0a90, 0x1170338152c3f60, 0x54a1fbc41888532, 0x100010110, 0x1000701160660, 0x1010400141546, 0x102060c153e7f92, 0x11601170760, 0x116076301121340, 0x1171258152c6df4, 0x142a78fc131d6a4a, 0x1011500050540, 0x113067b055e1f86, 0x1110440042477e, 0x102261da46f39362, 0x117022e054b0b80, 0x45c09af143a3f72, 0x106721d847ee9ae4, 0x408a833f0a833f0a, 0x100010106, 0x1000701000614, 0x101120014147e, 0x114067814067902, 0x11601171074, 0x116076316066138, 0x117054c152d40e4, 0x33e0a853e0b842a, 0x1011500131278, 0x113066d12126d16, 0x7077c017b681e, 0x76e12736f057056, 0x117022e12493290, 0x45c1ead5f26a912, 0x76518c96bc5efa4, 0xb97397297387286, 0x1700171666, 0x17006516147554, 0x17174a012d3f8a, 0x173872913964814e, 0x160216157534, 0x16026219014b3eb8, 0x16144d1d3902f39c, 0x3964974c65925d30, 0x17163b005d59f8, 0x164974c75837d462, 0x17062a404d28cfa, 0x65854b0a96152d3c, 0x16152c2a5943b390, 0x5854b1be6419dd1e, 0x6045c19c854b1fba});\n+constexpr StatTableTRI63 QRT_TABLE_TRI63({0, 0x100010114, 0x100010116, 0x1001701051372, 0x100010112, 0x1000040220, 0x100170105137a, 0x5107703453bba, 0x100010102, 0x101130117155a, 0x1000040200, 0x40000200800, 0x100170105133a, 0x103151a137276d8, 0x5107703453b3a, 0x134e65fc7c222be0, 0x100010002, 0x100030103115a, 0x101130117175a, 0x106052d103f4de2, 0x1000040600, 0x15122707691d3a, 0x40000200000, 0x4530770bc57b3a, 0x100170105033a, 0x103011a131256d8, 0x103151a137256d8, 0x176f29eb55c7a8da, 0x5107703457b3a, 0x130b158b7767d0da, 0x134e65fc7c22abe0, 0x7bcaf59d2f62d3e2, 0x100000002, 0x1001401041260, 0x100030101115a, 0x5107e03443ab8, 0x101130113175a, 0x1043701251b3a, 0x106052d10374de2, 0x134e657d7c232be2, 0x1000140600, 0x106073d103b4be2, 0x15122707491d3a, 0x4438600ac07800, 0x40000600000, 0x176a199c5682d3e0, 0x4530770b457b3a, 0x7bca759c2f62d3e0, 0x100170005033a, 0x6116d02572de2, 0x103011a111256d8, 0x1346656d7c372de2, 0x103151a177256d8, 0x643c600aa07800, 0x176f29eb5dc7a8da, 0x7b4b758b2f67d0da, 0x5107713457b3a, 0x104570776b457b3a, 0x130b158b5767d0da, 0x734e65fc3c22abe0, 0x134e65fc3c22abe0, 0x4000000000000000, 0x7bcaf59daf62d3e2});\n+typedef FieldTri<uint64_t, 63, 1, StatTableTRI63, &SQR_TABLE_TRI63, &SQR2_TABLE_TRI63, &SQR4_TABLE_TRI63, &SQR8_TABLE_TRI63, &SQR16_TABLE_TRI63, &QRT_TABLE_TRI63, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri63;\n+\n+// 64 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable64;\n+constexpr StatTable64 SQR_TABLE_64({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x6c00000, 0x1b000000, 0x6c000000, 0x1b0000000, 0x6c0000000, 0x1b00000000, 0x6c00000000, 0x1b000000000, 0x6c000000000, 0x1b0000000000, 0x6c0000000000, 0x1b00000000000, 0x6c00000000000, 0x1b000000000000, 0x6c000000000000, 0x1b0000000000000, 0x6c0000000000000, 0x1b00000000000000, 0x6c00000000000000, 0xb00000000000001b, 0xc00000000000005a});\n+constexpr StatTable64 SQR2_TABLE_64({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x1b, 0x1b0, 0x1b00, 0x1b000, 0x1b0000, 0x1b00000, 0x1b000000, 0x1b0000000, 0x1b00000000, 0x1b000000000, 0x1b0000000000, 0x1b00000000000, 0x1b000000000000, 0x1b0000000000000, 0x1b00000000000000, 0xb00000000000001b, 0x145, 0x1450, 0x14500, 0x145000, 0x1450000, 0x14500000, 0x145000000, 0x1450000000, 0x14500000000, 0x145000000000, 0x1450000000000, 0x14500000000000, 0x145000000000000, 0x1450000000000000, 0x450000000000001b, 0x50000000000001dc, 0x1db7, 0x1db70, 0x1db700, 0x1db7000, 0x1db70000, 0x1db700000, 0x1db7000000, 0x1db70000000, 0x1db700000000, 0x1db7000000000, 0x1db70000000000, 0x1db700000000000, 0x1db7000000000000, 0xdb7000000000001b, 0xb70000000000011f, 0x7000000000001105});\n+constexpr StatTable64 SQR4_TABLE_64({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x1b, 0x1b0000, 0x1b00000000, 0x1b000000000000, 0x145, 0x1450000, 0x14500000000, 0x145000000000000, 0x1db7, 0x1db70000, 0x1db700000000, 0x1db7000000000000, 0x11011, 0x110110000, 0x1101100000000, 0x101100000000001b, 0x1ab1ab, 0x1ab1ab0000, 0x1ab1ab00000000, 0xb1ab00000000015e, 0x1514515, 0x15145150000, 0x151451500000000, 0x4515000000001c6b, 0x1c6db6c7, 0x1c6db6c70000, 0x1c6db6c700000000, 0xb6c700000001010f, 0x101000101, 0x1010001010000, 0x10001010000001b, 0x1010000001b1b00, 0x1b1b001b1b, 0x1b1b001b1b0000, 0x1b001b1b00000145, 0x1b1b000001444500, 0x14445014445, 0x144450144450000, 0x4501444500001dac, 0x444500001daab71b, 0x1daab71daab7, 0x1daab71daab70000, 0xb71daab70001110e, 0xaab700011101101f, 0x1110110110111, 0x110110110111001b, 0x10110111001aab1b, 0x111001aab1ab1ab, 0x1aab1ab1ab1aab, 0xab1ab1ab1aab015e, 0xb1ab1aab0150145e, 0x1aab015014514515, 0x150145145145015, 0x1451451450151c70, 0x451450151c71db6b, 0x50151c71db6db6dc, 0x1c71db6db6db71c7, 0xdb6db6db71c6000b, 0xb6db71c60001000f, 0x71c6000100000005});\n+constexpr StatTable64 SQR8_TABLE_64({0x1, 0x11011, 0x101000101, 0x1110110110111, 0x100000001001a, 0x10110001100aa1a1, 0x100011a1b1a011a, 0x100baa100bb1aa0a, 0x1a00000144, 0x1ba1ba01505504, 0x1a001b5f4401441a, 0xa0eb1eea544fee41, 0x15e0144001a1ce8, 0xf5ee551fbc9d4f5d, 0x1b4543b0eee81b44, 0xb89a98b89a98b894, 0x10dbc, 0x11d76167c, 0x10cb1bd0cb1bc, 0x1c6b617617606a67, 0xdbc00010da6ad43, 0x167d1d6d105be392, 0xbd170ae2484f0af7, 0x162bc80d36e8d468, 0x1aad58014ae5f0, 0x63df9865e4bbbb5, 0x43fc5a4cbafe0d17, 0xe3d18fd6f8de2666, 0x49e2e5eab134a710, 0x1c78a1664f19bdd8, 0xf0829cea9886f08a, 0x4d8f634d8f625cdd, 0x100514550, 0x1104554401050, 0x15115140114154b, 0x10050551444aec57, 0x4551004b4277f24b, 0xef2afe861bdfb, 0x1d64ceb6c85ed2c9, 0x4975810172576524, 0x73cf4644451101e, 0x4fd1b234005fb6a7, 0x1bddd12e486f9a6f, 0xaa3c6f23ad5e9724, 0xa02b0a9206ef4923, 0x18a08533d5a4e65e, 0x1fc83ef027d0132b, 0x5e54f45f48c9a13c, 0x10deeff7bf8c0, 0x1d21c38d4f8874db, 0x10886029449884cd, 0xfe25b26c0190be86, 0xf5345525adfcb67e, 0xb606f05c0f274ae6, 0x49303a49c3147e89, 0xe3dec1f0cb3467b8, 0xf3dd197b59b91bb7, 0x6e062ec482dfc7e, 0xc24c087e94b8c9c, 0x42e75f2649a63926, 0x4646807e89775aa9, 0xca57e67631079503, 0xf738d302cd26e621, 0xda8702da9702da9d});\n+constexpr StatTable64 SQR16_TABLE_64({0x1, 0x15f0144001a114f, 0x1aad43011ba1e5, 0xe34916e80106e21d, 0x11cefef6be466, 0xab943b855d3d776b, 0x1c77b6cf4edf1bd0, 0x46923ddea5ce4e34, 0x5455145e48670f13, 0xfb7d34d8e2b804bb, 0xbbe0dfe164a4d5b4, 0x431d528b1f73a8a2, 0xc259794b79e2607, 0x5945c54c76a8d132, 0xf5cb8b3860386917, 0xb345180ffd7a5551, 0xbaf1bebe1ae4ad02, 0x45562dad588c6260, 0x55b2852b76a728c4, 0xb5908b73d457d739, 0xa5a058173d115951, 0x11e605f10dd49e16, 0xb122096fef2a82a8, 0xfb95933559736ac7, 0x42652cf9ded5daa5, 0xe9a56590d5ab5301, 0xb8cef5ec20abb26f, 0xb50edcd1421d92e0, 0x12ac73f1d2f67094, 0x1c5815d4c184bd2, 0xe227a4ef0cd1165c, 0xe8d4a3a319b07491, 0xb0ef530df44bb042, 0xfbcbf52ff08d7ea3, 0xa0eaea8c7f69bf70, 0xedc22185164a14b1, 0xbfb9f37fc5eb3abc, 0x3712083e323193a, 0xe7bdca1397a3c26c, 0xf2d44dcbd1d02306, 0xa8fcad00bc810b9c, 0x4f7014f9d2186ea, 0x1b4d4ccc40f8060f, 0xe9ecf1e0105dab78, 0xe34e682846de9f1d, 0xace6cd21bf5ef658, 0x10f0cfa8cf3326ff, 0x71a97b1c73b8a63, 0xe1398cba3a3345d1, 0xa439e4c62ecb0615, 0x4bcce9efcca8db40, 0x176e95394759914e, 0xb5c7335e43a80f7f, 0xeb5439d8e177d64d, 0xa6af064a2d733f41, 0x5efc52c7e2f99007, 0x4a6efe65d270460b, 0xfe0ff44f5baa9a6a, 0x104c70edd05ffd6f, 0xf07d029f554aa763, 0x1c3c3cc0aca30a16, 0x7a0a5f6c85237d50, 0x1b862fb6b961ed37, 0xdcd1bd32f8a7d3ba});\n+constexpr StatTable64 QRT_TABLE_64({0x19c9369f278adc02, 0x84b2b22ab2383ee4, 0x84b2b22ab2383ee6, 0x9d7b84b495b3e3f6, 0x84b2b22ab2383ee2, 0x37c470b49213f790, 0x9d7b84b495b3e3fe, 0x1000a0105137c, 0x84b2b22ab2383ef2, 0x368e964a8edce1fc, 0x37c470b49213f7b0, 0x19c9368e278fdf4c, 0x9d7b84b495b3e3be, 0x2e4da23cbc7d4570, 0x1000a010513fc, 0x84f35772bac24232, 0x84b2b22ab2383ff2, 0x37c570ba9314e4fc, 0x368e964a8edce3fc, 0xb377c390213cdb0e, 0x37c470b49213f3b0, 0x85ed5a3aa99c24f2, 0x19c9368e278fd74c, 0xaabff0000780000e, 0x9d7b84b495b3f3be, 0x84b6b3dab03038f2, 0x2e4da23cbc7d6570, 0x511ea03494ffc, 0x1000a010553fc, 0xae0c0220343c6c0e, 0x84f35772bac2c232, 0x800000008000000e, 0x84b2b22ab2393ff2, 0xb376c29c202bc97e, 0x37c570ba9316e4fc, 0x9c3062488879e6ce, 0x368e964a8ed8e3fc, 0x41e42c08e47e70, 0xb377c3902134db0e, 0x85b9b108a60f56ce, 0x37c470b49203f3b0, 0x19dd3b6e21f3cb4c, 0x85ed5a3aa9bc24f2, 0x198ddf682c428ac0, 0x19c9368e27cfd74c, 0x4b7c68431ca84b0, 0xaabff0000700000e, 0x8040655489ffefbe, 0x9d7b84b494b3f3be, 0x18c1354e32bfa74c, 0x84b6b3dab23038f2, 0xaaf613cc0f74627e, 0x2e4da23cb87d6570, 0x3248b3d6b3342a8c, 0x511ea0b494ffc, 0xb60813c00e70700e, 0x1000a110553fc, 0x1e0d022a05393ffc, 0xae0c0220143c6c0e, 0xe0c0220143c6c00, 0x84f35772fac2c232, 0xc041e55948fbfdce, 0x800000000000000e, 0});\n+typedef Field<uint64_t, 64, 27, StatTable64, &SQR_TABLE_64, &SQR2_TABLE_64, &SQR4_TABLE_64, &SQR8_TABLE_64, &SQR16_TABLE_64, &QRT_TABLE_64, IdTrans, &ID_TRANS, &ID_TRANS> Field64;\n+}\n+\n+Sketch* ConstructClMul8Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 57: return new SketchImpl<Field57>(implementation, 57);\n+    case 58: return new SketchImpl<Field58>(implementation, 58);\n+    case 59: return new SketchImpl<Field59>(implementation, 59);\n+    case 61: return new SketchImpl<Field61>(implementation, 61);\n+    case 62: return new SketchImpl<Field62>(implementation, 62);\n+    case 64: return new SketchImpl<Field64>(implementation, 63);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri8Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 57: return new SketchImpl<FieldTri57>(implementation, 57);\n+    case 58: return new SketchImpl<FieldTri58>(implementation, 58);\n+    case 60: return new SketchImpl<FieldTri60>(implementation, 60);\n+    case 62: return new SketchImpl<FieldTri62>(implementation, 62);\n+    case 63: return new SketchImpl<FieldTri63>(implementation, 63);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "37598c361236c0d20891d755a70ab35d6b34482a",
        "filename": "src/fields/clmul_common_impl.h",
        "status": "added",
        "additions": 157,
        "deletions": 0,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_common_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/clmul_common_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/clmul_common_impl.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,157 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FIELDS_CLMUL_COMMON_IMPL_H_\n+#define _MINISKETCH_FIELDS_CLMUL_COMMON_IMPL_H_ 1\n+\n+#include <stdint.h>\n+#include <x86intrin.h>\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+\n+namespace {\n+\n+template<typename I, int BITS, I MOD> I MulWithClMulReduce(I a, I b)\n+{\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+    const __m128i MOD128 = _mm_cvtsi64_si128(MOD);\n+    __m128i product = _mm_clmulepi64_si128(_mm_cvtsi64_si128((uint64_t)a), _mm_cvtsi64_si128((uint64_t)b), 0x00);\n+    if (BITS <= 32) {\n+        __m128i high1 = _mm_srli_epi64(product, BITS);\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00); \n+        __m128i high2 = _mm_srli_epi64(red1, BITS);\n+        __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+    } else if (BITS == 64) {\n+        __m128i red1 = _mm_clmulepi64_si128(product, MOD128, 0x01);\n+        __m128i red2 = _mm_clmulepi64_si128(red1, MOD128, 0x01);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2));\n+    } else if ((BITS % 8) == 0) {\n+        __m128i high1 = _mm_srli_si128(product, BITS / 8);\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+        __m128i high2 = _mm_srli_si128(red1, BITS / 8);\n+        __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+    } else {\n+        __m128i high1 = _mm_or_si128(_mm_srli_epi64(product, BITS), _mm_srli_si128(_mm_slli_epi64(product, 64 - BITS), 8));\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+        if ((uint64_t(MOD) >> (66 - BITS)) == 0) {\n+            __m128i high2 = _mm_srli_epi64(red1, BITS);\n+            __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        } else {\n+            __m128i high2 = _mm_or_si128(_mm_srli_epi64(red1, BITS), _mm_srli_si128(_mm_slli_epi64(red1, 64 - BITS), 8));\n+            __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    }\n+}\n+\n+template<typename I, int BITS, int POS> I MulTrinomial(I a, I b)\n+{\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+    __m128i product = _mm_clmulepi64_si128(_mm_cvtsi64_si128((uint64_t)a), _mm_cvtsi64_si128((uint64_t)b), 0x00);\n+    if (BITS <= 32) {\n+        __m128i high1 = _mm_srli_epi64(product, BITS);\n+        __m128i red1 = _mm_xor_si128(high1, _mm_slli_epi64(high1, POS));\n+        if (POS == 1) {\n+            return _mm_cvtsi128_si64(_mm_xor_si128(product, red1)) & MASK;\n+        } else {\n+            __m128i high2 = _mm_srli_epi64(red1, BITS);\n+            __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    } else {\n+        __m128i high1 = _mm_or_si128(_mm_srli_epi64(product, BITS), _mm_srli_si128(_mm_slli_epi64(product, 64 - BITS), 8));\n+        if (BITS + POS <= 66) {\n+            __m128i red1 = _mm_xor_si128(high1, _mm_slli_epi64(high1, POS));\n+            if (POS == 1) {\n+                return _mm_cvtsi128_si64(_mm_xor_si128(product, red1)) & MASK;\n+            } else if (BITS + POS <= 66) {\n+                __m128i high2 = _mm_srli_epi64(red1, BITS);\n+                __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+                return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+            }\n+        } else {\n+            const __m128i MOD128 = _mm_cvtsi64_si128(1 + (((uint64_t)1) << POS));\n+            __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+            __m128i high2 = _mm_or_si128(_mm_srli_epi64(red1, BITS), _mm_srli_si128(_mm_slli_epi64(red1, 64 - BITS), 8));\n+            __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    }\n+}\n+\n+/** Implementation of fields that use the SSE clmul intrinsic for multiplication. */\n+template<typename I, int B, I MOD, I (*MUL)(I, I), typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE> struct GenField\n+{\n+    typedef BitsInt<I, B> O;\n+    typedef LFSR<O, MOD> L;\n+\n+    static inline constexpr I Sqr1(I a) { return SQR->template Map<O>(a); }\n+    static inline constexpr I Sqr2(I a) { return SQR2->template Map<O>(a); }\n+    static inline constexpr I Sqr4(I a) { return SQR4->template Map<O>(a); }\n+    static inline constexpr I Sqr8(I a) { return SQR8->template Map<O>(a); }\n+    static inline constexpr I Sqr16(I a) { return SQR16->template Map<O>(a); }\n+\n+public:\n+    typedef I Elem;\n+\n+    inline constexpr int Bits() const { return B; }\n+\n+    inline constexpr Elem Mul2(Elem val) const { return L::Call(val); }\n+\n+    inline Elem Mul(Elem a, Elem b) const { return MUL(a, b); }\n+\n+    class Multiplier\n+    {\n+        Elem m_val;\n+    public:\n+        inline constexpr explicit Multiplier(const GenField&, Elem a) : m_val(a) {}\n+        constexpr Elem operator()(Elem a) const { return MUL(m_val, a); }\n+    };\n+\n+    /** Compute the square of a. */\n+    inline constexpr Elem Sqr(Elem val) const { return SQR->template Map<O>(val); }\n+\n+    /** Compute x such that x^2 + x = a (undefined result if no solution exists). */\n+    inline constexpr Elem Qrt(Elem val) const { return QRT->template Map<O>(val); }\n+\n+    /** Compute the inverse of x1. */\n+    inline Elem Inv(Elem val) const { return InvLadder<I, O, B, MUL, Sqr1, Sqr2, Sqr4, Sqr8, Sqr16>(val); }\n+\n+    /** Generate a random field element. */\n+    Elem FromSeed(uint64_t seed) const {\n+        uint64_t k0 = 0x434c4d554c466c64ull; // \"CLMULFld\"\n+        uint64_t k1 = seed;\n+        uint64_t count = ((uint64_t)B) << 32;\n+        I ret;\n+        do {\n+            ret = O::Mask(I(SipHash(k0, k1, count++)));\n+        } while(ret == 0);\n+        return LOAD->template Map<O>(ret);\n+    }\n+\n+    Elem Deserialize(BitReader& in) const { return LOAD->template Map<O>(in.Read<B, I>()); }\n+\n+    void Serialize(BitWriter& out, Elem val) const { out.Write<B, I>(SAVE->template Map<O>(val)); }\n+\n+    constexpr Elem FromUint64(uint64_t x) const { return LOAD->template Map<O>(O::Mask(I(x))); }\n+    constexpr uint64_t ToUint64(Elem val) const { return uint64_t(SAVE->template Map<O>(val)); }\n+};\n+\n+template<typename I, int B, I MOD, typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE>\n+using Field = GenField<I, B, MOD, MulWithClMulReduce<I, B, MOD>, F, SQR, SQR2, SQR4, SQR8, SQR16, QRT, T, LOAD, SAVE>;\n+\n+template<typename I, int B, int POS, typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE>\n+using FieldTri = GenField<I, B, I(1) + (I(1) << POS), MulTrinomial<I, B, POS>, F, SQR, SQR2, SQR4, SQR8, SQR16, QRT, T, LOAD, SAVE>;\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "5da96ce5eb5870d3256aa4320c4294f3c7074b7d",
        "filename": "src/fields/generic_1byte.cpp",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_1byte.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_1byte.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_1byte.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,83 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 2 bit field\n+typedef RecLinTrans<uint8_t, 2> StatTable2;\n+typedef RecLinTrans<uint8_t, 2> DynTable2;\n+constexpr StatTable2 SQR_TABLE_2({0x1, 0x3});\n+constexpr StatTable2 QRT_TABLE_2({0x2, 0});\n+typedef Field<uint8_t, 2, 3, StatTable2, DynTable2, &SQR_TABLE_2, &QRT_TABLE_2> Field2;\n+\n+// 3 bit field\n+typedef RecLinTrans<uint8_t, 3> StatTable3;\n+typedef RecLinTrans<uint8_t, 3> DynTable3;\n+constexpr StatTable3 SQR_TABLE_3({0x1, 0x4, 0x6});\n+constexpr StatTable3 QRT_TABLE_3({0, 0x4, 0x6});\n+typedef Field<uint8_t, 3, 3, StatTable3, DynTable3, &SQR_TABLE_3, &QRT_TABLE_3> Field3;\n+\n+// 4 bit field\n+typedef RecLinTrans<uint8_t, 4> StatTable4;\n+typedef RecLinTrans<uint8_t, 4> DynTable4;\n+constexpr StatTable4 SQR_TABLE_4({0x1, 0x4, 0x3, 0xc});\n+constexpr StatTable4 QRT_TABLE_4({0x6, 0xa, 0x8, 0});\n+typedef Field<uint8_t, 4, 3, StatTable4, DynTable4, &SQR_TABLE_4, &QRT_TABLE_4> Field4;\n+\n+// 5 bit field\n+typedef RecLinTrans<uint8_t, 5> StatTable5;\n+typedef RecLinTrans<uint8_t, 3, 2> DynTable5;\n+constexpr StatTable5 SQR_TABLE_5({0x1, 0x4, 0x10, 0xa, 0xd});\n+constexpr StatTable5 QRT_TABLE_5({0x14, 0x8, 0xa, 0, 0xe});\n+typedef Field<uint8_t, 5, 5, StatTable5, DynTable5, &SQR_TABLE_5, &QRT_TABLE_5> Field5;\n+\n+// 6 bit field\n+typedef RecLinTrans<uint8_t, 6> StatTable6;\n+typedef RecLinTrans<uint8_t, 3, 3> DynTable6;\n+constexpr StatTable6 SQR_TABLE_6({0x1, 0x4, 0x10, 0x3, 0xc, 0x30});\n+constexpr StatTable6 QRT_TABLE_6({0x3a, 0x26, 0x24, 0x14, 0x20, 0});\n+typedef Field<uint8_t, 6, 3, StatTable6, DynTable6, &SQR_TABLE_6, &QRT_TABLE_6> Field6;\n+\n+// 7 bit field\n+typedef RecLinTrans<uint8_t, 4, 3> StatTable7;\n+typedef RecLinTrans<uint8_t, 4, 3> DynTable7;\n+constexpr StatTable7 SQR_TABLE_7({0x1, 0x4, 0x10, 0x40, 0x6, 0x18, 0x60});\n+constexpr StatTable7 QRT_TABLE_7({0, 0x14, 0x16, 0x72, 0x12, 0x40, 0x7a});\n+typedef Field<uint8_t, 7, 3, StatTable7, DynTable7, &SQR_TABLE_7, &QRT_TABLE_7> Field7;\n+\n+// 8 bit field\n+typedef RecLinTrans<uint8_t, 4, 4> StatTable8;\n+typedef RecLinTrans<uint8_t, 4, 4> DynTable8;\n+constexpr StatTable8 SQR_TABLE_8({0x1, 0x4, 0x10, 0x40, 0x1b, 0x6c, 0xab, 0x9a});\n+constexpr StatTable8 QRT_TABLE_8({0xbc, 0x2a, 0x28, 0x86, 0x2c, 0xde, 0x8e, 0});\n+typedef Field<uint8_t, 8, 27, StatTable8, DynTable8, &SQR_TABLE_8, &QRT_TABLE_8> Field8;\n+\n+}\n+\n+Sketch* ConstructGeneric1Byte(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 2: return new SketchImpl<Field2>(implementation, 2);\n+    case 3: return new SketchImpl<Field3>(implementation, 3);\n+    case 4: return new SketchImpl<Field4>(implementation, 4);\n+    case 5: return new SketchImpl<Field5>(implementation, 5);\n+    case 6: return new SketchImpl<Field6>(implementation, 6);\n+    case 7: return new SketchImpl<Field7>(implementation, 7);\n+    case 8: return new SketchImpl<Field8>(implementation, 8);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "6641f0c298e37ccb95b0e839a94e30394a4fbdcd",
        "filename": "src/fields/generic_2bytes.cpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_2bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_2bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_2bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,91 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 9 bit field\n+typedef RecLinTrans<uint16_t, 5, 4> StatTable9;\n+typedef RecLinTrans<uint16_t, 3, 3, 3> DynTable9;\n+constexpr StatTable9 SQR_TABLE_9({0x1, 0x4, 0x10, 0x40, 0x100, 0x6, 0x18, 0x60, 0x180});\n+constexpr StatTable9 QRT_TABLE_9({0, 0x4e, 0x4c, 0x1aa, 0x48, 0x22, 0x1a2, 0x100, 0x58});\n+typedef Field<uint16_t, 9, 3, StatTable9, DynTable9, &SQR_TABLE_9, &QRT_TABLE_9> Field9;\n+\n+// 10 bit field\n+typedef RecLinTrans<uint16_t, 5, 5> StatTable10;\n+typedef RecLinTrans<uint16_t, 4, 3, 3> DynTable10;\n+constexpr StatTable10 SQR_TABLE_10({0x1, 0x4, 0x10, 0x40, 0x100, 0x9, 0x24, 0x90, 0x240, 0x112});\n+constexpr StatTable10 QRT_TABLE_10({0xec, 0x86, 0x84, 0x30e, 0x80, 0x3c2, 0x306, 0, 0x90, 0x296});\n+typedef Field<uint16_t, 10, 9, StatTable10, DynTable10, &SQR_TABLE_10, &QRT_TABLE_10> Field10;\n+\n+// 11 bit field\n+typedef RecLinTrans<uint16_t, 6, 5> StatTable11;\n+typedef RecLinTrans<uint16_t, 4, 4, 3> DynTable11;\n+constexpr StatTable11 SQR_TABLE_11({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0xa, 0x28, 0xa0, 0x280, 0x205});\n+constexpr StatTable11 QRT_TABLE_11({0x734, 0x48, 0x4a, 0x1de, 0x4e, 0x35e, 0x1d6, 0x200, 0x5e, 0, 0x37e});\n+typedef Field<uint16_t, 11, 5, StatTable11, DynTable11, &SQR_TABLE_11, &QRT_TABLE_11> Field11;\n+\n+// 12 bit field\n+typedef RecLinTrans<uint16_t, 6, 6> StatTable12;\n+typedef RecLinTrans<uint16_t, 4, 4, 4> DynTable12;\n+constexpr StatTable12 SQR_TABLE_12({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x9, 0x24, 0x90, 0x240, 0x900, 0x412});\n+constexpr StatTable12 QRT_TABLE_12({0x48, 0xc10, 0xc12, 0x208, 0xc16, 0xd82, 0x200, 0x110, 0xc06, 0, 0xda2, 0x5a4});\n+typedef Field<uint16_t, 12, 9, StatTable12, DynTable12, &SQR_TABLE_12, &QRT_TABLE_12> Field12;\n+\n+// 13 bit field\n+typedef RecLinTrans<uint16_t, 5, 4, 4> StatTable13;\n+typedef RecLinTrans<uint16_t, 4, 3, 3, 3> DynTable13;\n+constexpr StatTable13 SQR_TABLE_13({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x36, 0xd8, 0x360, 0xd80, 0x161b, 0x185a});\n+constexpr StatTable13 QRT_TABLE_13({0xcfc, 0x1500, 0x1502, 0x382, 0x1506, 0x149c, 0x38a, 0x118, 0x1516, 0, 0x14bc, 0x100e, 0x3ca});\n+typedef Field<uint16_t, 13, 27, StatTable13, DynTable13, &SQR_TABLE_13, &QRT_TABLE_13> Field13;\n+\n+// 14 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 4> StatTable14;\n+typedef RecLinTrans<uint16_t, 4, 4, 3, 3> DynTable14;\n+constexpr StatTable14 SQR_TABLE_14({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x442, 0x1108});\n+constexpr StatTable14 QRT_TABLE_14({0x13f2, 0x206, 0x204, 0x3e06, 0x200, 0x1266, 0x3e0e, 0x114, 0x210, 0, 0x1246, 0x2848, 0x3e4e, 0x2258});\n+typedef Field<uint16_t, 14, 33, StatTable14, DynTable14, &SQR_TABLE_14, &QRT_TABLE_14> Field14;\n+\n+// 15 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 5> StatTable15;\n+typedef RecLinTrans<uint16_t, 4, 4, 4, 3> DynTable15;\n+constexpr StatTable15 SQR_TABLE_15({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000});\n+constexpr StatTable15 QRT_TABLE_15({0, 0x114, 0x116, 0x428, 0x112, 0x137a, 0x420, 0x6d62, 0x102, 0x73a, 0x135a, 0x6460, 0x460, 0x4000, 0x6de2});\n+typedef Field<uint16_t, 15, 3, StatTable15, DynTable15, &SQR_TABLE_15, &QRT_TABLE_15> Field15;\n+\n+// 16 bit field\n+typedef RecLinTrans<uint16_t, 6, 5, 5> StatTable16;\n+typedef RecLinTrans<uint16_t, 4, 4, 4, 4> DynTable16;\n+constexpr StatTable16 SQR_TABLE_16({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x2b, 0xac, 0x2b0, 0xac0, 0x2b00, 0xac00, 0xb056, 0xc10e});\n+constexpr StatTable16 QRT_TABLE_16({0x732, 0x72b8, 0x72ba, 0x7e96, 0x72be, 0x78b2, 0x7e9e, 0x8cba, 0x72ae, 0xfa24, 0x7892, 0x5892, 0x7ede, 0xbec6, 0x8c3a, 0});\n+typedef Field<uint16_t, 16, 43, StatTable16, DynTable16, &SQR_TABLE_16, &QRT_TABLE_16> Field16;\n+\n+}\n+\n+Sketch* ConstructGeneric2Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 9: return new SketchImpl<Field9>(implementation, 9);\n+    case 10: return new SketchImpl<Field10>(implementation, 10);\n+    case 11: return new SketchImpl<Field11>(implementation, 11);\n+    case 12: return new SketchImpl<Field12>(implementation, 12);\n+    case 13: return new SketchImpl<Field13>(implementation, 13);\n+    case 14: return new SketchImpl<Field14>(implementation, 14);\n+    case 15: return new SketchImpl<Field15>(implementation, 15);\n+    case 16: return new SketchImpl<Field16>(implementation, 16);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "a86f37cbf5033ef514fc28fe554f453ee8ade2d2",
        "filename": "src/fields/generic_3bytes.cpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_3bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_3bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_3bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,91 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 17 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5> StatTable17;\n+typedef RecLinTrans<uint32_t, 4, 4, 3, 3, 3> DynTable17;\n+constexpr StatTable17 SQR_TABLE_17({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x8012});\n+constexpr StatTable17 QRT_TABLE_17({0, 0x4c3e, 0x4c3c, 0x1a248, 0x4c38, 0x428, 0x1a240, 0x1b608, 0x4c28, 0x206, 0x408, 0x4000, 0x1a200, 0x18006, 0x1b688, 0x14d2e, 0x4d28});\n+typedef Field<uint32_t, 17, 9, StatTable17, DynTable17, &SQR_TABLE_17, &QRT_TABLE_17> Field17;\n+\n+// 18 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6> StatTable18;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 3, 3> DynTable18;\n+constexpr StatTable18 SQR_TABLE_18({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x10012});\n+constexpr StatTable18 QRT_TABLE_18({0x9208, 0x422, 0x420, 0x8048, 0x424, 0x68b0, 0x8040, 0x30086, 0x434, 0x1040, 0x6890, 0x30ca2, 0x8000, 0x32896, 0x30006, 0, 0x534, 0x20532});\n+typedef Field<uint32_t, 18, 9, StatTable18, DynTable18, &SQR_TABLE_18, &QRT_TABLE_18> Field18;\n+\n+// 19 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 4> StatTable19;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3> DynTable19;\n+constexpr StatTable19 SQR_TABLE_19({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x3804e, 0x6011f});\n+constexpr StatTable19 QRT_TABLE_19({0x5d6b0, 0x2f476, 0x2f474, 0x1d6a2, 0x2f470, 0x42a, 0x1d6aa, 0x1060, 0x2f460, 0x19e92, 0x40a, 0x1da98, 0x1d6ea, 0x28c78, 0x10e0, 0xf56a, 0x2f560, 0, 0x19c92});\n+typedef Field<uint32_t, 19, 39, StatTable19, DynTable19, &SQR_TABLE_19, &QRT_TABLE_19> Field19;\n+\n+// 20 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5> StatTable20;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4> DynTable20;\n+constexpr StatTable20 SQR_TABLE_20({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x40012});\n+constexpr StatTable20 QRT_TABLE_20({0xc5dea, 0xc0110, 0xc0112, 0xe11de, 0xc0116, 0x24814, 0xe11d6, 0x20080, 0xc0106, 0xfe872, 0x24834, 0xe4106, 0xe1196, 0x1d9a4, 0x20000, 0x31190, 0xc0006, 0, 0xfea72, 0x7ea74});\n+typedef Field<uint32_t, 20, 9, StatTable20, DynTable20, &SQR_TABLE_20, &QRT_TABLE_20> Field20;\n+\n+// 21 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5> StatTable21;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 3, 3, 3> DynTable21;\n+constexpr StatTable21 SQR_TABLE_21({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x80005});\n+constexpr StatTable21 QRT_TABLE_21({0x1bd5fc, 0xbc196, 0xbc194, 0x74b96, 0xbc190, 0x1048, 0x74b9e, 0x672c8, 0xbc180, 0x4080, 0x1068, 0xc8200, 0x74bde, 0x64280, 0x67248, 0xc4280, 0xbc080, 0x80000, 0x4280, 0, 0x1468});\n+typedef Field<uint32_t, 21, 5, StatTable21, DynTable21, &SQR_TABLE_21, &QRT_TABLE_21> Field21;\n+\n+// 22 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5> StatTable22;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3, 3> DynTable22;\n+constexpr StatTable22 SQR_TABLE_22({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000});\n+constexpr StatTable22 QRT_TABLE_22({0x210d16, 0x104a, 0x1048, 0x4088, 0x104c, 0x200420, 0x4080, 0x492dc, 0x105c, 0x1a67f0, 0x200400, 0x21155c, 0x40c0, 0x20346c, 0x4925c, 0x1af7ac, 0x115c, 0x2274ac, 0x1a65f0, 0x2a65f0, 0x200000, 0});\n+typedef Field<uint32_t, 22, 3, StatTable22, DynTable22, &SQR_TABLE_22, &QRT_TABLE_22> Field22;\n+\n+// 23 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5> StatTable23;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3> DynTable23;\n+constexpr StatTable23 SQR_TABLE_23({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x80042, 0x200108});\n+constexpr StatTable23 QRT_TABLE_23({0, 0x1040, 0x1042, 0x43056, 0x1046, 0x121d76, 0x4305e, 0x40a0, 0x1056, 0x15176, 0x121d56, 0x7ee1f6, 0x4301e, 0x40000, 0x4020, 0x4f0be, 0x1156, 0x7cf0a0, 0x15376, 0x1ee9e8, 0x121956, 0x3ac9f6, 0x7ee9f6});\n+typedef Field<uint32_t, 23, 33, StatTable23, DynTable23, &SQR_TABLE_23, &QRT_TABLE_23> Field23;\n+\n+// 24 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6> StatTable24;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4> DynTable24;\n+constexpr StatTable24 SQR_TABLE_24({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0xb0001b, 0xc0005a});\n+constexpr StatTable24 QRT_TABLE_24({0x104e, 0xaf42a8, 0xaf42aa, 0xb78186, 0xaf42ae, 0x4090, 0xb7818e, 0x4a37c, 0xaf42be, 0x3688c0, 0x40b0, 0x80080e, 0xb781ce, 0xaf2232, 0x4a3fc, 0x856a82, 0xaf43be, 0x29c970, 0x368ac0, 0x968ace, 0x44b0, 0x77d570, 0x80000e, 0});\n+typedef Field<uint32_t, 24, 27, StatTable24, DynTable24, &SQR_TABLE_24, &QRT_TABLE_24> Field24;\n+\n+}\n+\n+Sketch* ConstructGeneric3Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 17: return new SketchImpl<Field17>(implementation, 17);\n+    case 18: return new SketchImpl<Field18>(implementation, 18);\n+    case 19: return new SketchImpl<Field19>(implementation, 19);\n+    case 20: return new SketchImpl<Field20>(implementation, 20);\n+    case 21: return new SketchImpl<Field21>(implementation, 21);\n+    case 22: return new SketchImpl<Field22>(implementation, 22);\n+    case 23: return new SketchImpl<Field23>(implementation, 23);\n+    case 24: return new SketchImpl<Field24>(implementation, 24);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "9383472bac49fbbd8784a6ac4b5be510f1ed5f9b",
        "filename": "src/fields/generic_4bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_4bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_4bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_4bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 25 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5, 5> StatTable25;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3, 3, 3> DynTable25;\n+constexpr StatTable25 SQR_TABLE_25({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x800012});\n+constexpr StatTable25 QRT_TABLE_25({0, 0x482110, 0x482112, 0x1b3c3e6, 0x482116, 0x4960ae, 0x1b3c3ee, 0x4088, 0x482106, 0x58a726, 0x49608e, 0x5ce52e, 0x1b3c3ae, 0x2006, 0x4008, 0x1c1a8, 0x482006, 0x1e96488, 0x58a526, 0x400000, 0x49648e, 0x1800006, 0x5ced2e, 0xb3d3a8, 0x1b3d3ae});\n+typedef Field<uint32_t, 25, 9, StatTable25, DynTable25, &SQR_TABLE_25, &QRT_TABLE_25> Field25;\n+\n+// 26 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5> StatTable26;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3, 3> DynTable26;\n+constexpr StatTable26 SQR_TABLE_26({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x2c0001b, 0x300005a});\n+constexpr StatTable26 QRT_TABLE_26({0x217b530, 0x2ae82a8, 0x2ae82aa, 0x2001046, 0x2ae82ae, 0x2de032e, 0x200104e, 0x70c10c, 0x2ae82be, 0x20151f2, 0x2de030e, 0xbc1400, 0x200100e, 0x178570, 0x70c18c, 0x2ae4232, 0x2ae83be, 0x211d742, 0x20153f2, 0x21f54f2, 0x2de070e, 0x5e0700, 0xbc1c00, 0x3abb97e, 0x200000e, 0});\n+typedef Field<uint32_t, 26, 27, StatTable26, DynTable26, &SQR_TABLE_26, &QRT_TABLE_26> Field26;\n+\n+// 27 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5> StatTable27;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 3> DynTable27;\n+constexpr StatTable27 SQR_TABLE_27({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x380004e, 0x600011f});\n+constexpr StatTable27 QRT_TABLE_27({0x6bf0530, 0x2be4496, 0x2be4494, 0x2bf0522, 0x2be4490, 0x1896cca, 0x2bf052a, 0x408a, 0x2be4480, 0x368ae72, 0x1896cea, 0x18d2ee0, 0x2bf056a, 0x1c76d6a, 0x400a, 0x336e9f8, 0x2be4580, 0x36baf12, 0x368ac72, 0x430360, 0x18968ea, 0x34a6b80, 0x18d26e0, 0xbf1560, 0x2bf156a, 0, 0x1c74d6a});\n+typedef Field<uint32_t, 27, 39, StatTable27, DynTable27, &SQR_TABLE_27, &QRT_TABLE_27> Field27;\n+\n+// 28 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5, 5> StatTable28;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4> DynTable28;\n+constexpr StatTable28 SQR_TABLE_28({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000});\n+constexpr StatTable28 QRT_TABLE_28({0x121d57a, 0x40216, 0x40214, 0x8112578, 0x40210, 0x10110, 0x8112570, 0x12597ec, 0x40200, 0x6983e00, 0x10130, 0x972b99c, 0x8112530, 0x8002000, 0x125976c, 0x815a76c, 0x40300, 0x936b29c, 0x6983c00, 0x97bb8ac, 0x10530, 0x9103000, 0x972b19c, 0xf6384ac, 0x8113530, 0x4113530, 0x8000000, 0});\n+typedef Field<uint32_t, 28, 3, StatTable28, DynTable28, &SQR_TABLE_28, &QRT_TABLE_28> Field28;\n+\n+// 29 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 5> StatTable29;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3, 3, 3> DynTable29;\n+constexpr StatTable29 SQR_TABLE_29({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x8000005});\n+constexpr StatTable29 QRT_TABLE_29({0x1b8351dc, 0xb87135e, 0xb87135c, 0xda7b35e, 0xb871358, 0x621a116, 0xda7b356, 0x40200, 0xb871348, 0xc9e2620, 0x621a136, 0x478b16, 0xda7b316, 0x6762e20, 0x40280, 0x6202000, 0xb871248, 0x627a316, 0xc9e2420, 0xcd1ad36, 0x621a536, 0x760e20, 0x478316, 0xa760e20, 0xda7a316, 0x8000000, 0x6760e20, 0, 0x44280});\n+typedef Field<uint32_t, 29, 5, StatTable29, DynTable29, &SQR_TABLE_29, &QRT_TABLE_29> Field29;\n+\n+// 30 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 6> StatTable30;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 3, 3> DynTable30;\n+constexpr StatTable30 SQR_TABLE_30({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000});\n+constexpr StatTable30 QRT_TABLE_30({0x2159df4a, 0x109134a, 0x1091348, 0x10114, 0x109134c, 0x3a203420, 0x1011c, 0x20004080, 0x109135c, 0x2005439c, 0x3a203400, 0x100400, 0x1015c, 0x3eb21930, 0x20004000, 0x20504c00, 0x109125c, 0x3b2b276c, 0x2005419c, 0x210450c0, 0x3a203000, 0x3e93186c, 0x100c00, 0x3aa23530, 0x1115c, 0x6b3286c, 0x3eb23930, 0xeb23930, 0x20000000, 0});\n+typedef Field<uint32_t, 30, 3, StatTable30, DynTable30, &SQR_TABLE_30, &QRT_TABLE_30> Field30;\n+\n+// 31 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5> StatTable31;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4, 3> DynTable31;\n+constexpr StatTable31 SQR_TABLE_31({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x20000012});\n+constexpr StatTable31 QRT_TABLE_31({0, 0x10110, 0x10112, 0x15076e, 0x10116, 0x117130e, 0x150766, 0x4743fa0, 0x10106, 0x1121008, 0x117132e, 0x176b248e, 0x150726, 0x172a2c88, 0x4743f20, 0x7eb81e86, 0x10006, 0x20008, 0x1121208, 0x56b2c8e, 0x117172e, 0x133f1bae, 0x176b2c8e, 0x7f2a0c8e, 0x151726, 0x10000000, 0x172a0c88, 0x60000006, 0x4747f20, 0x3eb89e80, 0x7eb89e86});\n+typedef Field<uint32_t, 31, 9, StatTable31, DynTable31, &SQR_TABLE_31, &QRT_TABLE_31> Field31;\n+\n+// 32 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5, 5> StatTable32;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4, 4> DynTable32;\n+constexpr StatTable32 SQR_TABLE_32({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x8d, 0x234, 0x8d0, 0x2340, 0x8d00, 0x23400, 0x8d000, 0x234000, 0x8d0000, 0x2340000, 0x8d00000, 0x23400000, 0x8d000000, 0x3400011a, 0xd0000468, 0x40001037});\n+constexpr StatTable32 QRT_TABLE_32({0x54fd1264, 0xc26fcd64, 0xc26fcd66, 0x238a7462, 0xc26fcd62, 0x973bccaa, 0x238a746a, 0x77766712, 0xc26fcd72, 0xc1bdd556, 0x973bcc8a, 0x572a094c, 0x238a742a, 0xb693be84, 0x77766792, 0x9555c03e, 0xc26fcc72, 0x568419f8, 0xc1bdd756, 0x96c3d2ca, 0x973bc88a, 0x54861fdc, 0x572a014c, 0xb79badc4, 0x238a642a, 0xb9b99fe0, 0xb6939e84, 0xc519fa86, 0x77762792, 0, 0x9555403e, 0x377627ba});\n+typedef Field<uint32_t, 32, 141, StatTable32, DynTable32, &SQR_TABLE_32, &QRT_TABLE_32> Field32;\n+\n+}\n+\n+Sketch* ConstructGeneric4Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 25: return new SketchImpl<Field25>(implementation, 25);\n+    case 26: return new SketchImpl<Field26>(implementation, 26);\n+    case 27: return new SketchImpl<Field27>(implementation, 27);\n+    case 28: return new SketchImpl<Field28>(implementation, 28);\n+    case 29: return new SketchImpl<Field29>(implementation, 29);\n+    case 30: return new SketchImpl<Field30>(implementation, 30);\n+    case 31: return new SketchImpl<Field31>(implementation, 31);\n+    case 32: return new SketchImpl<Field32>(implementation, 32);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "e7fc9cce5780a945129fd00ffc01af217adbeff7",
        "filename": "src/fields/generic_5bytes.cpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_5bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_5bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_5bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,89 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+// 33 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5> StatTable33;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable33;\n+constexpr StatTable33 SQR_TABLE_33({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x802, 0x2008, 0x8020, 0x20080, 0x80200, 0x200800, 0x802000, 0x2008000, 0x8020000, 0x20080000, 0x80200000, 0x800401, 0x2001004, 0x8004010, 0x20010040, 0x80040100});\n+constexpr StatTable33 QRT_TABLE_33({0xba504dd4, 0x1e2798ef2, 0x1e2798ef0, 0x6698a4ec, 0x1e2798ef4, 0x1c7f1bef0, 0x6698a4e4, 0x16da1b384, 0x1e2798ee4, 0x661ca6ec, 0x1c7f1bed0, 0x1483b87a6, 0x6698a4a4, 0x800000, 0x16da1b304, 0x1a185101c, 0x1e2798fe4, 0xaa400954, 0x661ca4ec, 0x667caeec, 0x1c7f1bad0, 0x400800, 0x1483b8fa6, 0, 0x6698b4a4, 0x1c61da4b8, 0x802000, 0x16e5dadec, 0x16da1f304, 0x62fc8eec, 0x1a185901c, 0x1661da5ec, 0x1e2788fe4});\n+typedef Field<uint64_t, 33, 1025, StatTable33, DynTable33, &SQR_TABLE_33, &QRT_TABLE_33> Field33;\n+\n+// 34 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5> StatTable34;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable34;\n+constexpr StatTable34 SQR_TABLE_34({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x10000102, 0x40000408, 0x100001020});\n+constexpr StatTable34 QRT_TABLE_34({0x2f973a1f6, 0x40202, 0x40200, 0x348102060, 0x40204, 0x8000420, 0x348102068, 0x1092195c8, 0x40214, 0x3f6881b6e, 0x8000400, 0x3f810383e, 0x348102028, 0x340002068, 0x109219548, 0x24015a774, 0x40314, 0x3f050343e, 0x3f688196e, 0x3f81c3a3a, 0x8000000, 0x24031a560, 0x3f810303e, 0xb08c1a12, 0x348103028, 0xb2881906, 0x340000068, 0, 0x10921d548, 0x2e131e576, 0x240152774, 0x18921d55e, 0x50314, 0x14015271c});\n+typedef Field<uint64_t, 34, 129, StatTable34, DynTable34, &SQR_TABLE_34, &QRT_TABLE_34> Field34;\n+\n+// 35 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5> StatTable35;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable35;\n+constexpr StatTable35 SQR_TABLE_35({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x28000000, 0xa0000000, 0x280000000, 0x200000005});\n+constexpr StatTable35 QRT_TABLE_35({0x5c2038114, 0x2bf547ee8, 0x2bf547eea, 0x2bf1074e8, 0x2bf547eee, 0x1883d0736, 0x2bf1074e0, 0x100420, 0x2bf547efe, 0x400800, 0x1883d0716, 0x5e90e4a0, 0x2bf1074a0, 0x4e70ac20, 0x1004a0, 0x2f060c880, 0x2bf547ffe, 0x37d55fffe, 0x400a00, 0x3372573de, 0x1883d0316, 0x700c20, 0x5e90eca0, 0x10604880, 0x2bf1064a0, 0x18f35377e, 0x4e708c20, 0x33f557ffe, 0x1044a0, 0x1bf557ffe, 0x2f0604880, 0x200000000, 0x2bf557ffe, 0, 0x37d57fffe});\n+typedef Field<uint64_t, 35, 5, StatTable35, DynTable35, &SQR_TABLE_35, &QRT_TABLE_35> Field35;\n+\n+// 36 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6> StatTable36;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable36;\n+constexpr StatTable36 SQR_TABLE_36({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x10000402, 0x40001008, 0x100004020, 0x400010080});\n+constexpr StatTable36 QRT_TABLE_36({0x40200, 0x8b0526186, 0x8b0526184, 0x240001000, 0x8b0526180, 0xcb6894d94, 0x240001008, 0xdb6880c22, 0x8b0526190, 0x8000200, 0xcb6894db4, 0x500424836, 0x240001048, 0x406cb2834, 0xdb6880ca2, 0x241200008, 0x8b0526090, 0xdb05021a6, 0x8000000, 0xdb01829b2, 0xcb68949b4, 0x1001000, 0x500424036, 0x106116406, 0x240000048, 0xcb29968a4, 0x406cb0834, 0, 0xdb6884ca2, 0x110010516, 0x241208008, 0x430434520, 0x8b0536090, 0x41208040, 0xdb05221a6, 0xb6884d14});\n+typedef Field<uint64_t, 36, 513, StatTable36, DynTable36, &SQR_TABLE_36, &QRT_TABLE_36> Field36;\n+\n+// 37 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 5, 5, 5, 5, 5> StatTable37;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable37;\n+constexpr StatTable37 SQR_TABLE_37({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0xa6, 0x298, 0xa60, 0x2980, 0xa600, 0x29800, 0xa6000, 0x298000, 0xa60000, 0x2980000, 0xa600000, 0x29800000, 0xa6000000, 0x298000000, 0xa60000000, 0x980000053, 0x60000011f, 0x180000047c});\n+constexpr StatTable37 QRT_TABLE_37({0xa3c62e7ba, 0xdc7a0c16a, 0xdc7a0c168, 0x12f7484546, 0xdc7a0c16c, 0xa9803a20, 0x12f748454e, 0xda07064a4, 0xdc7a0c17c, 0x123908de8e, 0xa9803a00, 0x122a888a8e, 0x12f748450e, 0x6790add8, 0xda0706424, 0x12e0a0384c, 0xdc7a0c07c, 0xcb28a2c2, 0x123908dc8e, 0xd09f85e86, 0xa9803e00, 0x124d682b6e, 0x122a88828e, 0x1738711a, 0x12f748550e, 0x73035b8, 0x67908dd8, 0xa0702438, 0xda0702424, 0xe0a0b860, 0x12e0a0b84c, 0x1c7a1c060, 0xdc7a1c07c, 0, 0xcb2aa2c2, 0x100000002c, 0x12390cdc8e});\n+typedef Field<uint64_t, 37, 83, StatTable37, DynTable37, &SQR_TABLE_37, &QRT_TABLE_37> Field37;\n+\n+// 38 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5> StatTable38;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable38;\n+constexpr StatTable38 SQR_TABLE_38({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x2300000063, 0xc0000014a, 0x3000000528});\n+constexpr StatTable38 QRT_TABLE_38({0x34b0ac6430, 0x2223262fa, 0x2223262f8, 0x35554405fe, 0x2223262fc, 0x355514098a, 0x35554405f6, 0x400840, 0x2223262ec, 0x1777726532, 0x35551409aa, 0x15c06fc0, 0x35554405b6, 0x1f5303fec, 0x4008c0, 0x236a21030, 0x2223263ec, 0x1a9008c00, 0x1777726732, 0x3692c60ab6, 0x3555140daa, 0x15556007ee, 0x15c067c0, 0x14a0b030f2, 0x35554415b6, 0x227c06d168, 0x1f5301fec, 0x16c3928fc2, 0x4048c0, 0x3a942c4c0, 0x236a29030, 0x1636a2902e, 0x2223363ec, 0x3a6e898276, 0x1a9028c00, 0x6de74eb2c, 0x1777766732, 0});\n+typedef Field<uint64_t, 38, 99, StatTable38, DynTable38, &SQR_TABLE_38, &QRT_TABLE_38> Field38;\n+\n+// 39 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5> StatTable39;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable39;\n+constexpr StatTable39 SQR_TABLE_39({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x800000011, 0x2000000044});\n+constexpr StatTable39 QRT_TABLE_39({0x66b02a408c, 0x100420, 0x100422, 0x14206080, 0x100426, 0x5dccefab1c, 0x14206088, 0x9fc11e5b6, 0x100436, 0x5466bea62a, 0x5dccefab3c, 0x9aa110536, 0x142060c8, 0x54739ed6e2, 0x9fc11e536, 0xe7a82c080, 0x100536, 0x4002000, 0x5466bea42a, 0x6a4022000, 0x5dccefaf3c, 0x9e8118536, 0x9aa110d36, 0x5680e080, 0x142070c8, 0x7d293c5b6, 0x54739ef6e2, 0x8d680e080, 0x9fc11a536, 0x6d282c080, 0xe7a824080, 0x800000000, 0x110536, 0x2d680e080, 0x4022000, 0, 0x5466baa42a, 0x46b03a44aa, 0x6a40a2000});\n+typedef Field<uint64_t, 39, 17, StatTable39, DynTable39, &SQR_TABLE_39, &QRT_TABLE_39> Field39;\n+\n+// 40 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5> StatTable40;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable40;\n+constexpr StatTable40 SQR_TABLE_40({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x39, 0xe4, 0x390, 0xe40, 0x3900, 0xe400, 0x39000, 0xe4000, 0x390000, 0xe40000, 0x3900000, 0xe400000, 0x39000000, 0xe4000000, 0x390000000, 0xe40000000, 0x3900000000, 0xe400000000, 0x900000004b, 0x400000015e});\n+constexpr StatTable40 QRT_TABLE_40({0x624b3cecc, 0xbc5c3f4c6, 0xbc5c3f4c4, 0xde1603e2c, 0xbc5c3f4c0, 0xaabec06cea, 0xde1603e24, 0x6cd9f724c2, 0xbc5c3f4d0, 0xcde1743818, 0xaabec06cca, 0xa138c314ca, 0xde1603e64, 0xaafc00f01a, 0x6cd9f72442, 0xcdca11bb4, 0xbc5c3f5d0, 0xa00002001a, 0xcde1743a18, 0xdf1407b90, 0xaabec068ca, 0xc043b482c8, 0xa138c31cca, 0xcb86977e3c, 0xde1602e64, 0x604596a326, 0xaafc00d01a, 0xcc1c165d0, 0x6cd9f76442, 0x673c94da26, 0xcdca19bb4, 0x67c0940a26, 0xbc5c2f5d0, 0xa4dca19bae, 0xa00000001a, 0x1bc5c2f5d0, 0xcde1703a18, 0, 0xdf1487b90, 0x8df1487b8a});\n+typedef Field<uint64_t, 40, 57, StatTable40, DynTable40, &SQR_TABLE_40, &QRT_TABLE_40> Field40;\n+\n+}\n+\n+Sketch* ConstructGeneric5Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 33: return new SketchImpl<Field33>(implementation, 33);\n+    case 34: return new SketchImpl<Field34>(implementation, 34);\n+    case 35: return new SketchImpl<Field35>(implementation, 35);\n+    case 36: return new SketchImpl<Field36>(implementation, 36);\n+    case 37: return new SketchImpl<Field37>(implementation, 37);\n+    case 38: return new SketchImpl<Field38>(implementation, 38);\n+    case 39: return new SketchImpl<Field39>(implementation, 39);\n+    case 40: return new SketchImpl<Field40>(implementation, 40);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "ec5526ec346819bf7d588e22784be3660deddaab",
        "filename": "src/fields/generic_6bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_6bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_6bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_6bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 41 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5> StatTable41;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable41;\n+constexpr StatTable41 SQR_TABLE_41({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x120000000, 0x480000000, 0x1200000000, 0x4800000000, 0x12000000000, 0x8000000012});\n+constexpr StatTable41 QRT_TABLE_41({0, 0x1599a5e0b0, 0x1599a5e0b2, 0x105c119e0, 0x1599a5e0b6, 0x1a2030452a6, 0x105c119e8, 0x1a307c55b2e, 0x1599a5e0a6, 0x1ee3f47bc8e, 0x1a203045286, 0x400808, 0x105c119a8, 0x1a3038573a6, 0x1a307c55bae, 0x4d2882a520, 0x1599a5e1a6, 0x1ffbaa0b720, 0x1ee3f47be8e, 0x4d68c22528, 0x1a203045686, 0x200006, 0x400008, 0x1b79a21b200, 0x105c109a8, 0x1ef3886a526, 0x1a3038553a6, 0x1b692209200, 0x1a307c51bae, 0x5d99a4e1a6, 0x4d28822520, 0x185e109ae, 0x1599a4e1a6, 0x4e3f43be88, 0x1ffbaa2b720, 0x4000000000, 0x1ee3f43be8e, 0x18000000006, 0x4d68ca2528, 0xa203145680, 0x1a203145686});\n+typedef Field<uint64_t, 41, 9, StatTable41, DynTable41, &SQR_TABLE_41, &QRT_TABLE_41> Field41;\n+\n+// 42 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6> StatTable42;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable42;\n+constexpr StatTable42 SQR_TABLE_42({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x810000000, 0x2040000000, 0x8100000000, 0x20400000000, 0x1000000102, 0x4000000408, 0x10000001020});\n+constexpr StatTable42 QRT_TABLE_42({0x810200080, 0x120810806, 0x120810804, 0x1068c1a1000, 0x120810800, 0x34005023008, 0x1068c1a1008, 0x800004080, 0x120810810, 0x162818a10, 0x34005023028, 0x42408a14, 0x1068c1a1048, 0x1001040, 0x800004000, 0xb120808906, 0x120810910, 0x34000020068, 0x162818810, 0x68c021400, 0x34005023428, 0x10004000, 0x42408214, 0x162418214, 0x1068c1a0048, 0xb002018116, 0x1003040, 0x10008180448, 0x800000000, 0x62c08b04, 0xb120800906, 0x2408d1a3060, 0x120800910, 0x34401003028, 0x34000000068, 0, 0x162858810, 0xa042058116, 0x68c0a1400, 0x8162858806, 0x34005123428, 0x3068c0a1468});\n+typedef Field<uint64_t, 42, 129, StatTable42, DynTable42, &SQR_TABLE_42, &QRT_TABLE_42> Field42;\n+\n+// 43 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5, 5> StatTable43;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable43;\n+constexpr StatTable43 SQR_TABLE_43({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0xb2, 0x2c8, 0xb20, 0x2c80, 0xb200, 0x2c800, 0xb2000, 0x2c8000, 0xb20000, 0x2c80000, 0xb200000, 0x2c800000, 0xb2000000, 0x2c8000000, 0xb20000000, 0x2c80000000, 0xb200000000, 0x2c800000000, 0x32000000059, 0x4800000013d, 0x20000000446});\n+constexpr StatTable43 QRT_TABLE_43({0x2bccc2d6f6c, 0x4bccc2d6f54, 0x4bccc2d6f56, 0x7cc7bc61df0, 0x4bccc2d6f52, 0x7d13b404b10, 0x7cc7bc61df8, 0x37456e9ac5a, 0x4bccc2d6f42, 0x4e042c6a6, 0x7d13b404b30, 0x4a56de9ef4c, 0x7cc7bc61db8, 0x14bc18d8e, 0x37456e9acda, 0x7c89f84fb1e, 0x4bccc2d6e42, 0x7ffae40d210, 0x4e042c4a6, 0x366f45dd06, 0x7d13b404f30, 0x496fcaf8cca, 0x4a56de9e74c, 0x370b62b6af4, 0x7cc7bc60db8, 0x1498185a8, 0x14bc1ad8e, 0x7e602c46a98, 0x37456e9ecda, 0x36ccc2c6e74, 0x7c89f847b1e, 0x7e27d06d516, 0x4bccc2c6e42, 0x7f93302c396, 0x7ffae42d210, 0x3dd3440706, 0x4e046c4a6, 0x78bbc09da36, 0x366f4ddd06, 0, 0x7d13b504f30, 0x8bbc09da00, 0x496fc8f8cca});\n+typedef Field<uint64_t, 43, 89, StatTable43, DynTable43, &SQR_TABLE_43, &QRT_TABLE_43> Field43;\n+\n+// 44 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5> StatTable44;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable44;\n+constexpr StatTable44 SQR_TABLE_44({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x8400, 0x21000, 0x84000, 0x210000, 0x840000, 0x2100000, 0x8400000, 0x21000000, 0x84000000, 0x210000000, 0x840000000, 0x2100000000, 0x8400000000, 0x21000000000, 0x84000000000, 0x10000000042, 0x40000000108});\n+constexpr StatTable44 QRT_TABLE_44({0xf05334f4f6e, 0x4002016, 0x4002014, 0xf04350e6246, 0x4002010, 0x4935b379a26, 0xf04350e624e, 0xf84250c228e, 0x4002000, 0xf04300e521e, 0x4935b379a06, 0xb966838dd48, 0xf04350e620e, 0xf7b8b80feda, 0xf84250c220e, 0xf972e097d5e, 0x4002100, 0x8000020000, 0xf04300e501e, 0x430025000, 0x4935b379e06, 0xf976a09dc5e, 0xb966838d548, 0xf84218c029a, 0xf04350e720e, 0x4925f36bf06, 0xf7b8b80deda, 0xb047d3ee758, 0xf84250c620e, 0xf80350e720e, 0xf972e09fd5e, 0x8091825284, 0x4012100, 0x9015063210, 0x8000000000, 0xff31a028c5e, 0xf04300a501e, 0x44340b7100, 0x4300a5000, 0, 0x4935b279e06, 0xa976b2dce18, 0xf976a29dc5e, 0x8935b279e18});\n+typedef Field<uint64_t, 44, 33, StatTable44, DynTable44, &SQR_TABLE_44, &QRT_TABLE_44> Field44;\n+\n+// 45 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5> StatTable45;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable45;\n+constexpr StatTable45 SQR_TABLE_45({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x36, 0xd8, 0x360, 0xd80, 0x3600, 0xd800, 0x36000, 0xd8000, 0x360000, 0xd80000, 0x3600000, 0xd800000, 0x36000000, 0xd8000000, 0x360000000, 0xd80000000, 0x3600000000, 0xd800000000, 0x36000000000, 0xd8000000000, 0x16000000001b, 0x18000000005a});\n+constexpr StatTable45 QRT_TABLE_45({0xede34e3e0fc, 0x1554148191aa, 0x1554148191a8, 0x1767be1dc4a6, 0x1554148191ac, 0x26bd4931492, 0x1767be1dc4ae, 0x233ab9c454a, 0x1554148191bc, 0x16939e8bb3dc, 0x26bd49314b2, 0x3c6ca8bac52, 0x1767be1dc4ee, 0x16caa5054c16, 0x233ab9c45ca, 0x14a1649628bc, 0x1554148190bc, 0x3c382881252, 0x16939e8bb1dc, 0x3c7ca0aa160, 0x26bd49310b2, 0x27f40158000, 0x3c6ca8ba452, 0x173fc092853c, 0x1767be1dd4ee, 0x16cbe284f25c, 0x16caa5056c16, 0x155559002f96, 0x233ab9c05ca, 0x26eb8908b32, 0x14a16496a8bc, 0x15440885333c, 0x1554148090bc, 0x17d60702e0, 0x3c3828a1252, 0x54548d10b2, 0x16939e8fb1dc, 0x3ac1e81b1d2, 0x3c7ca02a160, 0x166bd48310bc, 0x26bd48310b2, 0, 0x27f40358000, 0x10000000000e, 0x3c6cacba452});\n+typedef Field<uint64_t, 45, 27, StatTable45, DynTable45, &SQR_TABLE_45, &QRT_TABLE_45> Field45;\n+\n+// 46 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5> StatTable46;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable46;\n+constexpr StatTable46 SQR_TABLE_46({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000});\n+constexpr StatTable46 QRT_TABLE_46({0x211c4fd486ba, 0x100104a, 0x1001048, 0x104d0492d4, 0x100104c, 0x20005040c820, 0x104d0492dc, 0x40008080, 0x100105c, 0x24835068ce00, 0x20005040c800, 0x200000400800, 0x104d04929c, 0x100904325c, 0x40008000, 0x25da9e77daf0, 0x100115c, 0x1184e1696f0, 0x24835068cc00, 0x24825169dd5c, 0x20005040cc00, 0x3ea3241c60c0, 0x200000400000, 0x211c4e5496f0, 0x104d04829c, 0x20005340d86c, 0x100904125c, 0x24835968de5c, 0x4000c000, 0x6400a0c0, 0x25da9e775af0, 0x118cf1687ac, 0x101115c, 0x1ea1745cacc0, 0x1184e1496f0, 0x20181e445af0, 0x2483506ccc00, 0x20240060c0, 0x24825161dd5c, 0x1e21755dbd9c, 0x20005050cc00, 0x26a3746cacc0, 0x3ea3243c60c0, 0xea3243c60c0, 0x200000000000, 0});\n+typedef Field<uint64_t, 46, 3, StatTable46, DynTable46, &SQR_TABLE_46, &QRT_TABLE_46> Field46;\n+\n+// 47 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5> StatTable47;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable47;\n+constexpr StatTable47 SQR_TABLE_47({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x1080000, 0x4200000, 0x10800000, 0x42000000, 0x108000000, 0x420000000, 0x1080000000, 0x4200000000, 0x10800000000, 0x42000000000, 0x108000000000, 0x420000000000, 0x80000000042, 0x200000000108});\n+constexpr StatTable47 QRT_TABLE_47({0, 0x1001040, 0x1001042, 0x1047043076, 0x1001046, 0x112471c241e, 0x104704307e, 0x4304e052168, 0x1001056, 0x10004000, 0x112471c243e, 0x172a09c949d6, 0x104704303e, 0x4002020, 0x4304e0521e8, 0x5400e220, 0x1001156, 0x172b08c85080, 0x10004200, 0x41200b0800, 0x112471c203e, 0x172f0cca50a0, 0x172a09c941d6, 0x7eb88a11c1d6, 0x104704203e, 0x1044042020, 0x4000020, 0x42001011156, 0x4304e0561e8, 0x172a28c95880, 0x54006220, 0x112931cc21e, 0x1011156, 0x53670f283e, 0x172b08ca5080, 0x7a80c414a03e, 0x10044200, 0x40000000000, 0x4120030800, 0x1928318801e, 0x112470c203e, 0x799283188000, 0x172f0cea50a0, 0x1eb88a91c1c8, 0x172a098941d6, 0x3ea8cc95e1f6, 0x7eb88a91c1d6});\n+typedef Field<uint64_t, 47, 33, StatTable47, DynTable47, &SQR_TABLE_47, &QRT_TABLE_47> Field47;\n+\n+// 48 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6> StatTable48;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable48;\n+constexpr StatTable48 SQR_TABLE_48({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x2d, 0xb4, 0x2d0, 0xb40, 0x2d00, 0xb400, 0x2d000, 0xb4000, 0x2d0000, 0xb40000, 0x2d00000, 0xb400000, 0x2d000000, 0xb4000000, 0x2d0000000, 0xb40000000, 0x2d00000000, 0xb400000000, 0x2d000000000, 0xb4000000000, 0x2d0000000000, 0xb40000000000, 0xd0000000005a, 0x40000000011f});\n+constexpr StatTable48 QRT_TABLE_48({0xc00442c284f0, 0xc16b7fda410a, 0xc16b7fda4108, 0xada3b5c79fbe, 0xc16b7fda410c, 0x16f3c18d5b0, 0xada3b5c79fb6, 0x7090a381f64, 0xc16b7fda411c, 0xcafc15d179f8, 0x16f3c18d590, 0x6630880e534e, 0xada3b5c79ff6, 0xa13dd1f49826, 0x7090a381fe4, 0xb87560f6a74, 0xc16b7fda401c, 0xaaaaffff0012, 0xcafc15d17bf8, 0xaafd15f07bf6, 0x16f3c18d190, 0x60000020000e, 0x6630880e5b4e, 0xcb977fcb401c, 0xada3b5c78ff6, 0x6663420cad0, 0xa13dd1f4b826, 0xc0045fc2f41c, 0x7090a385fe4, 0x6762e24b834, 0xb87560fea74, 0xc6351fed241c, 0xc16b7fdb401c, 0x60065622ea7a, 0xaaaafffd0012, 0xdf9562bea74, 0xcafc15d57bf8, 0x6657ea057bea, 0xaafd15f87bf6, 0xa79329ddaa66, 0x16f3c08d190, 0xa39229f0aa66, 0x60000000000e, 0x175fb4468ad0, 0x6630884e5b4e, 0, 0xcb977f4b401c, 0x2630884e5b40});\n+typedef Field<uint64_t, 48, 45, StatTable48, DynTable48, &SQR_TABLE_48, &QRT_TABLE_48> Field48;\n+\n+}\n+\n+Sketch* ConstructGeneric6Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 41: return new SketchImpl<Field41>(implementation, 41);\n+    case 42: return new SketchImpl<Field42>(implementation, 42);\n+    case 43: return new SketchImpl<Field43>(implementation, 43);\n+    case 44: return new SketchImpl<Field44>(implementation, 44);\n+    case 45: return new SketchImpl<Field45>(implementation, 45);\n+    case 46: return new SketchImpl<Field46>(implementation, 46);\n+    case 47: return new SketchImpl<Field47>(implementation, 47);\n+    case 48: return new SketchImpl<Field48>(implementation, 48);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "4fb3f3c11298925f97e1a321169a87221cc62748",
        "filename": "src/fields/generic_7bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_7bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_7bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_7bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 49 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable49;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable49;\n+constexpr StatTable49 SQR_TABLE_49({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x402, 0x1008, 0x4020, 0x10080, 0x40200, 0x100800, 0x402000, 0x1008000, 0x4020000, 0x10080000, 0x40200000, 0x100800000, 0x402000000, 0x1008000000, 0x4020000000, 0x10080000000, 0x40200000000, 0x100800000000, 0x402000000000, 0x1008000000000, 0x20000000402, 0x80000001008, 0x200000004020, 0x800000010080});\n+constexpr StatTable49 QRT_TABLE_49({0, 0x10004196, 0x10004194, 0x5099461f080, 0x10004190, 0x40840600c20, 0x5099461f088, 0x58a56349cfde, 0x10004180, 0x48641a0c03fe, 0x40840600c00, 0x10084002848, 0x5099461f0c8, 0x4002048, 0x58a56349cf5e, 0x5088460a048, 0x10004080, 0x4c2852624dde, 0x48641a0c01fe, 0x14893129c280, 0x40840600800, 0x1eb23c323ace8, 0x10084002048, 0x48740a09417e, 0x5099461e0c8, 0x40852604d96, 0x4000048, 0x5cad2b29c37e, 0x58a563498f5e, 0x20000200, 0x50884602048, 0x10000000000, 0x10014080, 0x4c2a56624d96, 0x4c2852604dde, 0x1ee2347438ca0, 0x48641a0801fe, 0x480000000048, 0x14893121c280, 0x14091121c080, 0x40840700800, 0x1a5099561e17e, 0x1eb23c303ace8, 0x8740a894136, 0x10084402048, 0x18101c501ace8, 0x48740a89417e, 0x15dace6286f96, 0x5099561e0c8});\n+typedef Field<uint64_t, 49, 513, StatTable49, DynTable49, &SQR_TABLE_49, &QRT_TABLE_49> Field49;\n+\n+// 50 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable50;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable50;\n+constexpr StatTable50 SQR_TABLE_50({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x1d, 0x74, 0x1d0, 0x740, 0x1d00, 0x7400, 0x1d000, 0x74000, 0x1d0000, 0x740000, 0x1d00000, 0x7400000, 0x1d000000, 0x74000000, 0x1d0000000, 0x740000000, 0x1d00000000, 0x7400000000, 0x1d000000000, 0x74000000000, 0x1d0000000000, 0x740000000000, 0x1d00000000000, 0x340000000001d, 0x1000000000053});\n+constexpr StatTable50 QRT_TABLE_50({0xfbdfa3ae9d4c, 0x38143245a4878, 0x38143245a487a, 0x38527487e7492, 0x38143245a487e, 0x3124c61f56d2a, 0x38527487e749a, 0xfa8c91b087c0, 0x38143245a486e, 0x3eca48c6196be, 0x3124c61f56d0a, 0x380000040080a, 0x38527487e74da, 0x976b2d8b39b4, 0xfa8c91b08740, 0xfa8cd5b02724, 0x38143245a496e, 0x316291dd013fe, 0x3eca48c6194be, 0x10344122064, 0x3124c61f5690a, 0x68c5f006ee40, 0x380000040000a, 0x852749fe64d0, 0x38527487e64da, 0x37ef8e9d0e9da, 0x976b2d8b19b4, 0x37fabd1cef34a, 0xfa8c91b0c740, 0x96282d9159b4, 0xfa8cd5b0a724, 0x464a8249dd0, 0x38143245b496e, 0x37eaa8ddc94be, 0x316291dd213fe, 0x392446035690a, 0x3eca48c6594be, 0x974b258b4964, 0x103441a2064, 0x385a7c87fb4da, 0x3124c61e5690a, 0xeb8ad5d9a724, 0x68c5f026ee40, 0x3724c61e5690a, 0x380000000000a, 0x3a8c5f026ee4a, 0x8527497e64d0, 0, 0x38527497e64da, 0x2fbdfa2ae8d0a});\n+typedef Field<uint64_t, 50, 29, StatTable50, DynTable50, &SQR_TABLE_50, &QRT_TABLE_50> Field50;\n+\n+// 51 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable51;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable51;\n+constexpr StatTable51 SQR_TABLE_51({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x96, 0x258, 0x960, 0x2580, 0x9600, 0x25800, 0x96000, 0x258000, 0x960000, 0x2580000, 0x9600000, 0x25800000, 0x96000000, 0x258000000, 0x960000000, 0x2580000000, 0x9600000000, 0x25800000000, 0x96000000000, 0x258000000000, 0x960000000000, 0x2580000000000, 0x160000000004b, 0x580000000012c, 0x6000000000426});\n+constexpr StatTable51 QRT_TABLE_51({0x778bf2703d152, 0x2aaaafbff2092, 0x2aaaafbff2090, 0x4d2119c7e7780, 0x2aaaafbff2094, 0x65de1df8ae194, 0x4d2119c7e7788, 0x67d63d7ba262c, 0x2aaaafbff2084, 0x28ff003f4167c, 0x65de1df8ae1b4, 0x658397fb1d034, 0x4d2119c7e77c8, 0x4d7c9284526ba, 0x67d63d7ba26ac, 0x6666333fc0cbe, 0x2aaaafbff2184, 0x295b807ab55ee, 0x28ff003f4147c, 0x2aaabfffe0016, 0x65de1df8ae5b4, 0x209210349d60, 0x658397fb1d834, 0x4d215dc7cf1c8, 0x4d2119c7e67c8, 0x662b2b3d7b4be, 0x4d7c9284506ba, 0x255af00b36e0, 0x67d63d7ba66ac, 0x65de1fb8ac1a6, 0x6666333fc8cbe, 0x662f3b3ded4be, 0x2aaaafbfe2184, 0x663a9dbc3a426, 0x295b807a955ee, 0x4cdc9ec128928, 0x28ff003f0147c, 0x28a0c93cd511c, 0x2aaabfff60016, 0x65d73cf8e78d4, 0x65de1df9ae5b4, 0x4d5eddc44f1c8, 0x209210149d60, 0x357fcc506c8a, 0x658397ff1d834, 0, 0x4d215dcfcf1c8, 0x63f536f5d4554, 0x4d2119d7e67c8, 0x4000000000022, 0x662b2b1d7b4be});\n+typedef Field<uint64_t, 51, 75, StatTable51, DynTable51, &SQR_TABLE_51, &QRT_TABLE_51> Field51;\n+\n+// 52 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable52;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable52;\n+constexpr StatTable52 SQR_TABLE_52({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x240000, 0x900000, 0x2400000, 0x9000000, 0x24000000, 0x90000000, 0x240000000, 0x900000000, 0x2400000000, 0x9000000000, 0x24000000000, 0x90000000000, 0x240000000000, 0x900000000000, 0x2400000000000, 0x9000000000000, 0x4000000000012});\n+constexpr StatTable52 QRT_TABLE_52({0xc108165459b0e, 0x10004086, 0x10004084, 0xc00000100104e, 0x10004080, 0x2041810a545b0, 0xc000001001046, 0x1181e055efc0, 0x10004090, 0x40810214390, 0x2041810a54590, 0xc000141019106, 0xc000001001006, 0x10816045ab40, 0x1181e055ef40, 0xc000111015196, 0x10004190, 0xe045c19af44a2, 0x40810214190, 0xe045809ad0532, 0x2041810a54190, 0xdb387a03fe646, 0xc000141019906, 0x2000000800000, 0xc000001000006, 0x2486548199c34, 0x108160458b40, 0x2041808a50534, 0x1181e055af40, 0xc0408312153d6, 0xc00011101d196, 0x21499f0e0eed0, 0x10014190, 0xe15dff9faabe2, 0xe045c19ad44a2, 0xdb787b01ea7d6, 0x40810254190, 0xe484409180532, 0xe045809a50532, 0xc14095164d896, 0x2041810b54190, 0x217dee8fb7a74, 0xdb387a01fe646, 0x441810b54190, 0xc000141419906, 0xc3386e15e7f46, 0x2000000000000, 0x1000141419900, 0xc000000000006, 0, 0x248654a199c34, 0xa48654a199c32});\n+typedef Field<uint64_t, 52, 9, StatTable52, DynTable52, &SQR_TABLE_52, &QRT_TABLE_52> Field52;\n+\n+// 53 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable53;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable53;\n+constexpr StatTable53 SQR_TABLE_53({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x8e, 0x238, 0x8e0, 0x2380, 0x8e00, 0x23800, 0x8e000, 0x238000, 0x8e0000, 0x2380000, 0x8e00000, 0x23800000, 0x8e000000, 0x238000000, 0x8e0000000, 0x2380000000, 0x8e00000000, 0x23800000000, 0x8e000000000, 0x238000000000, 0x8e0000000000, 0x2380000000000, 0x8e00000000000, 0x3800000000047, 0xe00000000011c, 0x18000000000437});\n+constexpr StatTable53 QRT_TABLE_53({0xf940b90844076, 0x1f940b90844052, 0x1f940b90844050, 0x9d2a063b43e64, 0x1f940b90844054, 0x936f69323ec14, 0x9d2a063b43e6c, 0xe12270a88898, 0x1f940b90844044, 0x1f917f00bb5a3c, 0x936f69323ec34, 0x1f622df85b46ee, 0x9d2a063b43e2c, 0x9bc65ab040b66, 0xe12270a88818, 0x958330b931986, 0x1f940b90844144, 0x98e2a06e32e0, 0x1f917f00bb583c, 0x1f877970dc1024, 0x936f69323e834, 0x16cc3c9b1558c2, 0x1f622df85b4eee, 0x16de1c3351dae8, 0x9d2a063b42e2c, 0x1fecdc7855f8ee, 0x9bc65ab042b66, 0x933821b1cb6fe, 0xe12270a8c818, 0x1f675958641c0e, 0x958330b939986, 0x9d97e050e960, 0x1f940b90854144, 0x1f820fa0e38adc, 0x98e2a06c32e0, 0x1650f0e358a010, 0x1f917f00bf583c, 0x1643af4b037a3a, 0x1f877970d41024, 0x1ffe2c281d8c16, 0x936f69333e834, 0xf00d50ffccf8, 0x16cc3c9b3558c2, 0x16bc31cbca943a, 0x1f622df81b4eee, 0xa6cbd8007232, 0x16de1c33d1dae8, 0x15d2a062b42e10, 0x9d2a062b42e2c, 0x1aa77896586ca, 0x1fecdc7a55f8ee, 0, 0x9bc65af042b66});\n+typedef Field<uint64_t, 53, 71, StatTable53, DynTable53, &SQR_TABLE_53, &QRT_TABLE_53> Field53;\n+\n+// 54 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable54;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable54;\n+constexpr StatTable54 SQR_TABLE_54({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x2010000000, 0x8040000000, 0x20100000000, 0x80400000000, 0x201000000000, 0x804000000000, 0x2010000000000, 0x8040000000000, 0x20100000000000, 0x400000000402, 0x1000000001008, 0x4000000004020, 0x10000000010080});\n+constexpr StatTable54 QRT_TABLE_54({0x201008000200, 0x26c10916494994, 0x26c10916494996, 0x40008008, 0x26c10916494992, 0x141a2434c12d12, 0x40008000, 0x36c00110594c22, 0x26c10916494982, 0x200000040200, 0x141a2434c12d32, 0x10010816104534, 0x40008040, 0x36da60b01308b2, 0x36c00110594ca2, 0x48200209000, 0x26c10916494882, 0x41b6da2d86106, 0x200000040000, 0x32db2c228965b0, 0x141a2434c12932, 0x9000000200048, 0x10010816104d34, 0x32db68b2832da4, 0x40009040, 0x40045928b4902, 0x36da60b01328b2, 0x1000040000, 0x36c00110590ca2, 0x101b69865a4120, 0x48200201000, 0x22da6434912884, 0x26c10916484882, 0x9000240208008, 0x41b6da2da6106, 0x22c14484c20180, 0x200000000000, 0x4016db29b6812, 0x32db2c228165b0, 0x9008200201048, 0x141a2434d12932, 0x32c36ca2c264b0, 0x9000000000048, 0x140a65b48a2c32, 0x10010816504d34, 0, 0x32db68b2032da4, 0x404490824814, 0x41009040, 0x14da60a4536126, 0x40045908b4902, 0x8000041009008, 0x36da60b41328b2, 0x6db68b2032c12});\n+typedef Field<uint64_t, 54, 513, StatTable54, DynTable54, &SQR_TABLE_54, &QRT_TABLE_54> Field54;\n+\n+// 55 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable55;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable55;\n+constexpr StatTable55 SQR_TABLE_55({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x102, 0x408, 0x1020, 0x4080, 0x10200, 0x40800, 0x102000, 0x408000, 0x1020000, 0x4080000, 0x10200000, 0x40800000, 0x102000000, 0x408000000, 0x1020000000, 0x4080000000, 0x10200000000, 0x40800000000, 0x102000000000, 0x408000000000, 0x1020000000000, 0x4080000000000, 0x10200000000000, 0x40800000000000, 0x2000000000102, 0x8000000000408, 0x20000000001020});\n+constexpr StatTable55 QRT_TABLE_55({0, 0x121d57b6623fde, 0x121d57b6623fdc, 0x68908340d10e00, 0x121d57b6623fd8, 0x100300510e20, 0x68908340d10e08, 0x10004096, 0x121d57b6623fc8, 0x100010000, 0x100300510e00, 0x7ea8c890a088e8, 0x68908340d10e48, 0x68809540871648, 0x10004016, 0x68808000808068, 0x121d57b6623ec8, 0x68909240d41c48, 0x100010200, 0x6884c170ad0216, 0x100300510a00, 0x68848160a50200, 0x7ea8c890a080e8, 0x7eecbca04ab4b6, 0x68908340d11e48, 0x120c54b62234c8, 0x68809540873648, 0x69929240d61c48, 0x10000016, 0x68808060800000, 0x68808000800068, 0x80000080, 0x121d57b6633ec8, 0x7ea8cb90a18ae8, 0x68909240d61c48, 0x16284090200080, 0x100050200, 0x474302a345e, 0x6884c170a50216, 0x166cbca0cab4de, 0x100300410a00, 0x1000000000000, 0x68848160850200, 0x688cc1f0a50296, 0x7ea8c890e080e8, 0x7e8cc1f0a50280, 0x7eecbca0cab4b6, 0x68000000000068, 0x68908341d11e48, 0x7880954487365e, 0x120c54b42234c8, 0x9929248d61c20, 0x68809544873648, 0x41121208561c20, 0x69929248d61c48});\n+typedef Field<uint64_t, 55, 129, StatTable55, DynTable55, &SQR_TABLE_55, &QRT_TABLE_55> Field55;\n+\n+// 56 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable56;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable56;\n+constexpr StatTable56 SQR_TABLE_56({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x95, 0x254, 0x950, 0x2540, 0x9500, 0x25400, 0x95000, 0x254000, 0x950000, 0x2540000, 0x9500000, 0x25400000, 0x95000000, 0x254000000, 0x950000000, 0x2540000000, 0x9500000000, 0x25400000000, 0x95000000000, 0x254000000000, 0x950000000000, 0x2540000000000, 0x9500000000000, 0x25400000000000, 0x95000000000000, 0x5400000000012a, 0x5000000000043d, 0x40000000001061});\n+constexpr StatTable56 QRT_TABLE_56({0x10004084, 0xd058f12fd5925e, 0xd058f12fd5925c, 0x41a60b5566d9f0, 0xd058f12fd59258, 0xbda60a142740ba, 0x41a60b5566d9f8, 0xd059f1afc5e688, 0xd058f12fd59248, 0xfc040841615a22, 0xbda60a1427409a, 0xbda60b5426c1ca, 0x41a60b5566d9b8, 0x1a60b4166b950, 0xd059f1afc5e608, 0xfc000041409822, 0xd058f12fd59348, 0xd1ee7a4ef4185c, 0xfc040841615822, 0x9049759b80b4a4, 0xbda60a1427449a, 0xd258e06f301e18, 0xbda60b5426c9ca, 0x6dfeeb3bf6d7d2, 0x41a60b5566c9b8, 0xbdef3ed4ae398a, 0x1a60b41669950, 0xd1ef3f8eeff04c, 0xd059f1afc5a608, 0xbda203340783de, 0xfc000041401822, 0x2dfefbaff2b27a, 0xd058f12fd49348, 0xfdb788a0706776, 0xd1ee7a4ef6185c, 0x2e5de0ae41337a, 0xfc040841655822, 0x41eb17d5ceecf8, 0x9049759b88b4a4, 0x40048874211afc, 0xbda60a1437449a, 0xd04a720f93400c, 0xd258e06f101e18, 0xbc559cf5ac7fce, 0xbda60b5466c9ca, 0x6dc9759b88b4d6, 0x6dfeeb3b76d7d2, 0x92feea7b275af0, 0x41a60b5466c9b8, 0, 0xbdef3ed6ae398a, 0x2811d5edd8ee2a, 0x1a60b45669950, 0xb1a60b5466c9ca, 0xd1ef3f86eff04c, 0xec493582c8f032});\n+typedef Field<uint64_t, 56, 149, StatTable56, DynTable56, &SQR_TABLE_56, &QRT_TABLE_56> Field56;\n+\n+}\n+\n+Sketch* ConstructGeneric7Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 49: return new SketchImpl<Field49>(implementation, 49);\n+    case 50: return new SketchImpl<Field50>(implementation, 50);\n+    case 51: return new SketchImpl<Field51>(implementation, 51);\n+    case 52: return new SketchImpl<Field52>(implementation, 52);\n+    case 53: return new SketchImpl<Field53>(implementation, 53);\n+    case 54: return new SketchImpl<Field54>(implementation, 54);\n+    case 55: return new SketchImpl<Field55>(implementation, 55);\n+    case 56: return new SketchImpl<Field56>(implementation, 56);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "bbde7337039b6ca679765fab16ace3ac71bbe2af",
        "filename": "src/fields/generic_8bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_8bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_8bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_8bytes.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 57 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable57;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable57;\n+constexpr StatTable57 SQR_TABLE_57({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x8800000000, 0x22000000000, 0x88000000000, 0x220000000000, 0x880000000000, 0x2200000000000, 0x8800000000000, 0x22000000000000, 0x88000000000000, 0x20000000000011, 0x80000000000044});\n+constexpr StatTable57 QRT_TABLE_57({0xd0c3a82c902426, 0x232aa54103915e, 0x232aa54103915c, 0x1763e291e61699c, 0x232aa541039158, 0x1f424d678bb15e, 0x1763e291e616994, 0x26fd8122f10d36, 0x232aa541039148, 0x1e0a0206002000, 0x1f424d678bb17e, 0x5d72563f39d7e, 0x1763e291e6169d4, 0x1519beb9d597df4, 0x26fd8122f10db6, 0x150c3a87c90e4aa, 0x232aa541039048, 0x15514891f6179d4, 0x1e0a0206002200, 0x14ec9ba7a94c6aa, 0x1f424d678bb57e, 0x1e0f4286382420, 0x5d72563f3957e, 0x4000080000, 0x1763e291e6179d4, 0x1ac0e804882000, 0x1519beb9d595df4, 0x1f430d6793b57e, 0x26fd8122f14db6, 0x3c68e806882000, 0x150c3a87c9064aa, 0x1484fe18b915e, 0x232aa541029048, 0x14f91eb9b595df4, 0x15514891f6379d4, 0x48f6a82380420, 0x1e0a0206042200, 0x14b1beb99595df4, 0x14ec9ba7a9cc6aa, 0x4cf2a82b00420, 0x1f424d679bb57e, 0x26aa0002000000, 0x1e0f4286182420, 0x173f1039dd17df4, 0x5d72563b3957e, 0x4aa0002000000, 0x4000880000, 0x16d31eb9b595df4, 0x1763e291f6179d4, 0x20000000000000, 0x1ac0e806882000, 0x2caa0002000000, 0x1519beb99595df4, 0, 0x1f430d6f93b57e, 0x73e90d6d93b57e, 0x26fd8132f14db6});\n+typedef Field<uint64_t, 57, 17, StatTable57, DynTable57, &SQR_TABLE_57, &QRT_TABLE_57> Field57;\n+\n+// 58 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable58;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable58;\n+constexpr StatTable58 SQR_TABLE_58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x80001, 0x200004, 0x800010, 0x2000040, 0x8000100, 0x20000400, 0x80001000, 0x200004000, 0x800010000, 0x2000040000, 0x8000100000, 0x20000400000, 0x80001000000, 0x200004000000, 0x800010000000, 0x2000040000000, 0x8000100000000, 0x20000400000000, 0x80001000000000, 0x200004000000000, 0x10000100002, 0x40000400008, 0x100001000020, 0x400004000080, 0x1000010000200, 0x4000040000800, 0x10000100002000, 0x40000400008000, 0x100001000020000});\n+constexpr StatTable58 QRT_TABLE_58({0x2450096792a5c5c, 0x610014271011c, 0x610014271011e, 0x1f0cb811314ea88, 0x610014271011a, 0x8000000420, 0x1f0cb811314ea80, 0x265407ad8a20bcc, 0x610014271010a, 0x3d18be98392ebd0, 0x8000000400, 0xc29b930e407056, 0x1f0cb811314eac0, 0x1fcef001154dee8, 0x265407ad8a20b4c, 0xc69b924c61f94a, 0x610014271000a, 0x211006895845190, 0x3d18be98392e9d0, 0x54007accac09cc, 0x8000000000, 0xc08b934e107854, 0xc29b930e407856, 0x275407adc220bcc, 0x1f0cb811314fac0, 0x1f6db815164ea8a, 0x1fcef001154fee8, 0x1b2db801945e396, 0x265407ad8a24b4c, 0x21100ec95865590, 0xc69b924c61794a, 0x273507b1e530ad6, 0x610014270000a, 0x1b4cb835b34e29c, 0x211006895865190, 0x3839bf20d47e016, 0x3d18be98396e9d0, 0x3858bd34f36e01c, 0x54007acca409cc, 0, 0x8000100000, 0xc29a130e507856, 0xc08b934e307854, 0x13253921d448296, 0xc29b930e007856, 0x13c60935f6486bc, 0x275407adca20bcc, 0x3571be8c5e6c9da, 0x1f0cb811214fac0, 0x410014261011c, 0x1f6db815364ea8a, 0x13a50921d1486b6, 0x1fcef001554fee8, 0x64001249245a5c, 0x1b2db801145e396, 0x8610014670200a, 0x265407ac8a24b4c, 0x1a5cbfbdeb0f30c});\n+typedef Field<uint64_t, 58, 524289, StatTable58, DynTable58, &SQR_TABLE_58, &QRT_TABLE_58> Field58;\n+\n+// 59 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable59;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable59;\n+constexpr StatTable59 SQR_TABLE_59({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x12a, 0x4a8, 0x12a0, 0x4a80, 0x12a00, 0x4a800, 0x12a000, 0x4a8000, 0x12a0000, 0x4a80000, 0x12a00000, 0x4a800000, 0x12a000000, 0x4a8000000, 0x12a0000000, 0x4a80000000, 0x12a00000000, 0x4a800000000, 0x12a000000000, 0x4a8000000000, 0x12a0000000000, 0x4a80000000000, 0x12a00000000000, 0x4a800000000000, 0x12a000000000000, 0x4a8000000000000, 0x2a000000000012a, 0x28000000000043d, 0x200000000001061});\n+constexpr StatTable59 QRT_TABLE_59({0x38d905ab028567a, 0x789fa6ed3b44d72, 0x789fa6ed3b44d70, 0x74ec857e93d828c, 0x789fa6ed3b44d74, 0x116b3c1203c96, 0x74ec857e93d8284, 0xc25ebc3871e280, 0x789fa6ed3b44d64, 0x47a37c3d910b6, 0x116b3c1203cb6, 0xc7322d7a8f48de, 0x74ec857e93d82c4, 0xb509a0ea52e496, 0xc25ebc3871e200, 0x74fdee4681d3e0c, 0x789fa6ed3b44c64, 0x7ffbbd080b2f09a, 0x47a37c3d912b6, 0xd5c937bae506c8, 0x116b3c12038b6, 0xb173c76987625e, 0xc7322d7a8f40de, 0x7591ff36b3a682c, 0x74ec857e93d92c4, 0x72b253bfbfc90c4, 0xb509a0ea52c496, 0x79f2e7b10e6d452, 0xc25ebc3871a200, 0x78c86e951086aac, 0x74fdee4681dbe0c, 0x78c96eb514c602c, 0x789fa6ed3b54c64, 0xc34818b95658e8, 0x7ffbbd080b0f09a, 0x7399f563b1980f2, 0x47a37c3dd12b6, 0xa29e0e28c58880, 0xd5c937baed06c8, 0x788ac23520ac82c, 0x116b3c13038b6, 0xa2c857e83d92b6, 0xb173c769a7625e, 0x608da990122e48, 0xc7322d7acf40de, 0xa3a89269eebefe, 0x7591ff36bba682c, 0xa25ebc2871a200, 0x74ec857e83d92c4, 0x11f62e419f1cfe, 0x72b253bf9fc90c4, 0x7425ebc2871a272, 0xb509a0ee52c496, 0x4ed8555979c8de, 0x79f2e7b18e6d452, 0x6c3580d5915d4d2, 0xc25ebc2871a200, 0, 0x78c86e971086aac});\n+typedef Field<uint64_t, 59, 149, StatTable59, DynTable59, &SQR_TABLE_59, &QRT_TABLE_59> Field59;\n+\n+// 60 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable60;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable60;\n+constexpr StatTable60 SQR_TABLE_60({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000, 0xc00000000000, 0x3000000000000, 0xc000000000000, 0x30000000000000, 0xc0000000000000, 0x300000000000000, 0xc00000000000000});\n+constexpr StatTable60 QRT_TABLE_60({0x6983c00fe00104a, 0x804570322e054e6, 0x804570322e054e4, 0x15673387e0a4e4, 0x804570322e054e0, 0x100010110, 0x15673387e0a4ec, 0x920d01f34442a70, 0x804570322e054f0, 0x7a8dc0f2e4058f0, 0x100010130, 0x120c01f140462f0, 0x15673387e0a4ac, 0x7bdbb2ca9a4fe5c, 0x920d01f34442af0, 0xe9c6b039ce0c4ac, 0x804570322e055f0, 0xfac8b080ca20c00, 0x7a8dc0f2e405af0, 0x7a8dc4b2e4a59f0, 0x100010530, 0x10000100000, 0x120c01f14046af0, 0x131a02d91c5db6c, 0x15673387e0b4ac, 0x15623387d0b4ac, 0x7bdbb2ca9a4de5c, 0x7ffbbbca0a8ee5c, 0x920d01f34446af0, 0x800000020000000, 0xe9c6b039ce044ac, 0x81130302500f000, 0x804570322e155f0, 0x935b72eb3a48e9c, 0xfac8b080ca00c00, 0x120c016140563c0, 0x7a8dc0f2e445af0, 0x7bcbb3ca8a4ee5c, 0x7a8dc4b2e4259f0, 0xc4000a0300, 0x100110530, 0x11623285c1b19c, 0x10000300000, 0x420890090c3000, 0x120c01f14446af0, 0x68d7b33b9e0b4ac, 0x131a02d9145db6c, 0xe8ccb1e18a56fc0, 0x15673386e0b4ac, 0x7aadc8f2e485af0, 0x15623385d0b4ac, 0x4a0990093c3000, 0x7bdbb2cada4de5c, 0xf9d6b3389e0b4ac, 0x7ffbbbca8a8ee5c, 0xdf6ba38cec84ac, 0x920d01f24446af0, 0x520d01f24446af0, 0x800000000000000, 0});\n+typedef Field<uint64_t, 60, 3, StatTable60, DynTable60, &SQR_TABLE_60, &QRT_TABLE_60> Field60;\n+\n+// 61 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable61;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable61;\n+constexpr StatTable61 SQR_TABLE_61({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x13800000, 0x4e000000, 0x138000000, 0x4e0000000, 0x1380000000, 0x4e00000000, 0x13800000000, 0x4e000000000, 0x138000000000, 0x4e0000000000, 0x1380000000000, 0x4e00000000000, 0x13800000000000, 0x4e000000000000, 0x138000000000000, 0x4e0000000000000, 0x1380000000000000, 0xe0000000000004e, 0x180000000000011f});\n+constexpr StatTable61 QRT_TABLE_61({0x171d34fcdac955d0, 0x12cfc8c049e1c96, 0x12cfc8c049e1c94, 0x71d34fcdac955c2, 0x12cfc8c049e1c90, 0x631c871de564852, 0x71d34fcdac955ca, 0x129fa6407f27300, 0x12cfc8c049e1c80, 0x7094f6fdd0a3b12, 0x631c871de564872, 0xdb28cee59c8256a, 0x71d34fcdac9558a, 0xc8a0be15a915472, 0x129fa6407f27380, 0x12dfcb4058e0b80, 0x12cfc8c049e1d80, 0x117d7f04ad0118, 0x7094f6fdd0a3912, 0x621b576dbe35b6a, 0x631c871de564c72, 0x13c808a013a1ee0, 0xdb28cee59c82d6a, 0x113d79842a0272, 0x71d34fcdac9458a, 0x719776b580b6a98, 0xc8a0be15a917472, 0x6633498d6db760a, 0x129fa6407f23380, 0xbd4ae9e8c3e7560, 0x12dfcb4058e8b80, 0x8000000a, 0x12cfc8c049f1d80, 0x634ce9add3b26ea, 0x117d7f04af0118, 0xda3f19c5d66258a, 0x7094f6fdd0e3912, 0xb87427e85e71560, 0x621b576dbeb5b6a, 0xc8b0b085b8c4e0a, 0x631c871de464c72, 0x1538fc8649458a, 0x13c808a011a1ee0, 0xcddbca6d1cfe360, 0xdb28cee59882d6a, 0xae80f550d1ffff2, 0x113d7984aa0272, 0xda7770f5f195912, 0x71d34fcdbc9458a, 0x137c8a049a1ee0, 0x719776b5a0b6a98, 0xded39a9d236ba78, 0xc8a0be15e917472, 0x6732488ca7ce0a, 0x6633498dedb760a, 0xc0406d0527cb80a, 0x129fa6417f23380, 0x3d4ae9eac3e756a, 0xbd4ae9eac3e7560, 0, 0x12dfcb4458e8b80});\n+typedef Field<uint64_t, 61, 39, StatTable61, DynTable61, &SQR_TABLE_61, &QRT_TABLE_61> Field61;\n+\n+// 62 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable62;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable62;\n+constexpr StatTable62 SQR_TABLE_62({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x20000001, 0x80000004, 0x200000010, 0x800000040, 0x2000000100, 0x8000000400, 0x20000001000, 0x80000004000, 0x200000010000, 0x800000040000, 0x2000000100000, 0x8000000400000, 0x20000001000000, 0x80000004000000, 0x200000010000000, 0x800000040000000, 0x2000000100000000, 0x440000002, 0x1100000008, 0x4400000020, 0x11000000080, 0x44000000200, 0x110000000800, 0x440000002000, 0x1100000008000, 0x4400000020000, 0x11000000080000, 0x44000000200000, 0x110000000800000, 0x440000002000000, 0x1100000008000000});\n+constexpr StatTable62 QRT_TABLE_62({0x30268b6fba455d2c, 0x200000006, 0x200000004, 0x3d67cb6c1fe66c76, 0x200000000, 0x3fc4f1901abfa400, 0x3d67cb6c1fe66c7e, 0x35e79b6c0a66bcbe, 0x200000010, 0x1e9372bc57a9941e, 0x3fc4f1901abfa420, 0x21ec9d424957a5b0, 0x3d67cb6c1fe66c3e, 0x1cb35a6e52f5fb0e, 0x35e79b6c0a66bc3e, 0x215481024c13a730, 0x200000110, 0x1c324a6c52f75b08, 0x1e9372bc57a9961e, 0x3764a9d00f676820, 0x3fc4f1901abfa020, 0x355481020e132730, 0x21ec9d424957adb0, 0x3c43c32c0f34301e, 0x3d67cb6c1fe67c3e, 0x1496122c45259728, 0x1cb35a6e52f5db0e, 0x15e418405b72ec20, 0x35e79b6c0a66fc3e, 0x30268b6e3a445c38, 0x215481024c132730, 0x100010114, 0x200010110, 0, 0x1c324a6c52f55b08, 0x215581044d133776, 0x1e9372bc57ad961e, 0x2155810e4d133766, 0x3764a9d00f6f6820, 0x2157833c4d12323e, 0x3fc4f1901aafa020, 0x1c324a4252f55b58, 0x355481020e332730, 0x28332fc0509d41e, 0x21ec9d424917adb0, 0x215783be4d12332e, 0x3c43c32c0fb4301e, 0x2157822c4d06363e, 0x3d67cb6c1ee67c3e, 0x23f6b9d2484afb78, 0x1496122c47259728, 0x14b8184047648a80, 0x1cb35a6e56f5db0e, 0x3fe4f1901aefa820, 0x15e418405372ec20, 0x3d5fd72c1be276be, 0x35e79b6c1a66fc3e, 0x14b038d24774cf10, 0x30268b6e1a445c38, 0x1d17022e43a7172e, 0x215481020c132730, 0x2157022e4d07372e});\n+typedef Field<uint64_t, 62, 536870913, StatTable62, DynTable62, &SQR_TABLE_62, &QRT_TABLE_62> Field62;\n+\n+// 63 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable63;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable63;\n+constexpr StatTable63 SQR_TABLE_63({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000, 0x18000, 0x60000, 0x180000, 0x600000, 0x1800000, 0x6000000, 0x18000000, 0x60000000, 0x180000000, 0x600000000, 0x1800000000, 0x6000000000, 0x18000000000, 0x60000000000, 0x180000000000, 0x600000000000, 0x1800000000000, 0x6000000000000, 0x18000000000000, 0x60000000000000, 0x180000000000000, 0x600000000000000, 0x1800000000000000, 0x6000000000000000});\n+constexpr StatTable63 QRT_TABLE_63({0, 0x100010114, 0x100010116, 0x1001701051372, 0x100010112, 0x1000040220, 0x100170105137a, 0x5107703453bba, 0x100010102, 0x101130117155a, 0x1000040200, 0x40000200800, 0x100170105133a, 0x103151a137276d8, 0x5107703453b3a, 0x134e65fc7c222be0, 0x100010002, 0x100030103115a, 0x101130117175a, 0x106052d103f4de2, 0x1000040600, 0x15122707691d3a, 0x40000200000, 0x4530770bc57b3a, 0x100170105033a, 0x103011a131256d8, 0x103151a137256d8, 0x176f29eb55c7a8da, 0x5107703457b3a, 0x130b158b7767d0da, 0x134e65fc7c22abe0, 0x7bcaf59d2f62d3e2, 0x100000002, 0x1001401041260, 0x100030101115a, 0x5107e03443ab8, 0x101130113175a, 0x1043701251b3a, 0x106052d10374de2, 0x134e657d7c232be2, 0x1000140600, 0x106073d103b4be2, 0x15122707491d3a, 0x4438600ac07800, 0x40000600000, 0x176a199c5682d3e0, 0x4530770b457b3a, 0x7bca759c2f62d3e0, 0x100170005033a, 0x6116d02572de2, 0x103011a111256d8, 0x1346656d7c372de2, 0x103151a177256d8, 0x643c600aa07800, 0x176f29eb5dc7a8da, 0x7b4b758b2f67d0da, 0x5107713457b3a, 0x104570776b457b3a, 0x130b158b5767d0da, 0x734e65fc3c22abe0, 0x134e65fc3c22abe0, 0x4000000000000000, 0x7bcaf59daf62d3e2});\n+typedef Field<uint64_t, 63, 3, StatTable63, DynTable63, &SQR_TABLE_63, &QRT_TABLE_63> Field63;\n+\n+// 64 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable64;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable64;\n+constexpr StatTable64 SQR_TABLE_64({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x6c00000, 0x1b000000, 0x6c000000, 0x1b0000000, 0x6c0000000, 0x1b00000000, 0x6c00000000, 0x1b000000000, 0x6c000000000, 0x1b0000000000, 0x6c0000000000, 0x1b00000000000, 0x6c00000000000, 0x1b000000000000, 0x6c000000000000, 0x1b0000000000000, 0x6c0000000000000, 0x1b00000000000000, 0x6c00000000000000, 0xb00000000000001b, 0xc00000000000005a});\n+constexpr StatTable64 QRT_TABLE_64({0x19c9369f278adc02, 0x84b2b22ab2383ee4, 0x84b2b22ab2383ee6, 0x9d7b84b495b3e3f6, 0x84b2b22ab2383ee2, 0x37c470b49213f790, 0x9d7b84b495b3e3fe, 0x1000a0105137c, 0x84b2b22ab2383ef2, 0x368e964a8edce1fc, 0x37c470b49213f7b0, 0x19c9368e278fdf4c, 0x9d7b84b495b3e3be, 0x2e4da23cbc7d4570, 0x1000a010513fc, 0x84f35772bac24232, 0x84b2b22ab2383ff2, 0x37c570ba9314e4fc, 0x368e964a8edce3fc, 0xb377c390213cdb0e, 0x37c470b49213f3b0, 0x85ed5a3aa99c24f2, 0x19c9368e278fd74c, 0xaabff0000780000e, 0x9d7b84b495b3f3be, 0x84b6b3dab03038f2, 0x2e4da23cbc7d6570, 0x511ea03494ffc, 0x1000a010553fc, 0xae0c0220343c6c0e, 0x84f35772bac2c232, 0x800000008000000e, 0x84b2b22ab2393ff2, 0xb376c29c202bc97e, 0x37c570ba9316e4fc, 0x9c3062488879e6ce, 0x368e964a8ed8e3fc, 0x41e42c08e47e70, 0xb377c3902134db0e, 0x85b9b108a60f56ce, 0x37c470b49203f3b0, 0x19dd3b6e21f3cb4c, 0x85ed5a3aa9bc24f2, 0x198ddf682c428ac0, 0x19c9368e27cfd74c, 0x4b7c68431ca84b0, 0xaabff0000700000e, 0x8040655489ffefbe, 0x9d7b84b494b3f3be, 0x18c1354e32bfa74c, 0x84b6b3dab23038f2, 0xaaf613cc0f74627e, 0x2e4da23cb87d6570, 0x3248b3d6b3342a8c, 0x511ea0b494ffc, 0xb60813c00e70700e, 0x1000a110553fc, 0x1e0d022a05393ffc, 0xae0c0220143c6c0e, 0xe0c0220143c6c00, 0x84f35772fac2c232, 0xc041e55948fbfdce, 0x800000000000000e, 0});\n+typedef Field<uint64_t, 64, 27, StatTable64, DynTable64, &SQR_TABLE_64, &QRT_TABLE_64> Field64;\n+\n+}\n+\n+Sketch* ConstructGeneric8Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 57: return new SketchImpl<Field57>(implementation, 57);\n+    case 58: return new SketchImpl<Field58>(implementation, 58);\n+    case 59: return new SketchImpl<Field59>(implementation, 59);\n+    case 60: return new SketchImpl<Field60>(implementation, 60);\n+    case 61: return new SketchImpl<Field61>(implementation, 61);\n+    case 62: return new SketchImpl<Field62>(implementation, 62);\n+    case 63: return new SketchImpl<Field63>(implementation, 63);\n+    case 64: return new SketchImpl<Field64>(implementation, 64);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "c98f11b14beae4d753fc7ac8c0515eaa87e61542",
        "filename": "src/fields/generic_common_impl.h",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_common_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/fields/generic_common_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fields/generic_common_impl.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,71 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FIELDS_GENERIC_COMMON_IMPL_H_\n+#define _MINISKETCH_FIELDS_GENERIC_COMMON_IMPL_H_ 1\n+\n+#include <stdint.h>\n+#include <random>\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+\n+namespace {\n+\n+/** Generic implementation for fields whose elements can be represented by an integer type. */\n+template<typename I, int B, uint32_t MOD, typename F, typename T, const F* SQR, const F* QRT> class Field\n+{\n+    typedef BitsInt<I, B> O;\n+    typedef LFSR<O, MOD> L;\n+\n+public:\n+    typedef I Elem;\n+    constexpr int Bits() const { return B; }\n+\n+    constexpr inline Elem Mul2(Elem val) const { return L::Call(val); }\n+\n+    class Multiplier\n+    {\n+        T table;\n+    public:\n+        explicit Multiplier(const Field&, Elem a) { table.template Build<L::Call>(a); }\n+        constexpr inline Elem operator()(Elem a) const { return table.template Map<O>(a); }\n+    };\n+\n+    Elem Mul(Elem a, Elem b) const { return GFMul<I, B, L, O>(a, b); }\n+\n+    /** Compute the square of a. */\n+    inline constexpr Elem Sqr(Elem a) const { return SQR->template Map<O>(a); }\n+\n+    /** Compute x such that x^2 + x = a (undefined result if no solution exists). */\n+    inline constexpr Elem Qrt(Elem a) const { return QRT->template Map<O>(a); }\n+\n+    /** Compute the inverse of x1. */\n+    Elem Inv(Elem a) const { return InvExtGCD<I, O, B, MOD>(a); }\n+\n+    /** Generate a random field element. */\n+    Elem FromSeed(uint64_t seed) const {\n+        uint64_t k0 = 0x496e744669656c64ull; // \"IntField\"\n+        uint64_t k1 = seed;\n+        uint64_t count = ((uint64_t)B) << 32;\n+        Elem ret;\n+        do {\n+            ret = O::Mask(I(SipHash(k0, k1, count++)));\n+        } while(ret == 0);\n+        return ret;\n+    }\n+\n+    Elem Deserialize(BitReader& in) const { return in.template Read<B, I>(); }\n+\n+    void Serialize(BitWriter& out, Elem val) const { out.template Write<B, I>(val); }\n+\n+    constexpr Elem FromUint64(uint64_t x) const { return O::Mask(I(x)); }\n+    constexpr uint64_t ToUint64(Elem val) const { return uint64_t(val); }\n+};\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "a2762f6a8be308fdeec128c55b2016ad7aa0512d",
        "filename": "src/int_utils.h",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/int_utils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/int_utils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/int_utils.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,275 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_INT_UTILS_H_\n+#define _MINISKETCH_INT_UTILS_H_\n+\n+#include <stdlib.h>\n+\n+#include <limits>\n+#include <algorithm>\n+#include <type_traits>\n+\n+template<int bits>\n+static constexpr inline uint64_t Rot(uint64_t x) { return (x << bits) | (x >> (64 - bits)); }\n+\n+static inline void SipHashRound(uint64_t& v0, uint64_t& v1, uint64_t& v2, uint64_t& v3) {\n+    v0 += v1; v1 = Rot<13>(v1); v1 ^= v0;\n+    v0 = Rot<32>(v0);\n+    v2 += v3; v3 = Rot<16>(v3); v3 ^= v2;\n+    v0 += v3; v3 = Rot<21>(v3); v3 ^= v0;\n+    v2 += v1; v1 = Rot<17>(v1); v1 ^= v2;\n+    v2 = Rot<32>(v2);\n+}\n+\n+inline uint64_t SipHash(uint64_t k0, uint64_t k1, uint64_t data) {\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ data;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    v0 ^= data;\n+    v3 ^= 0x800000000000000ULL;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    v0 ^= 0x800000000000000ULL;\n+    v2 ^= 0xFF;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}\n+\n+class BitWriter {\n+    unsigned char state = 0;\n+    int offset = 0;\n+    unsigned char* out;\n+\n+public:\n+    BitWriter(unsigned char* output) : out(output) {}\n+\n+    template<int BITS, typename I>\n+    inline void Write(I val) {\n+        int bits = BITS;\n+        if (bits + offset >= 8) {\n+            state |= ((val & ((I(1) << (8 - offset)) - 1)) << offset);\n+            *(out++) = state;\n+            val >>= (8 - offset);\n+            bits -= 8 - offset;\n+            offset = 0;\n+            state = 0;\n+        }\n+        while (bits >= 8) {\n+            *(out++) = val & 255;\n+            val >>= 8;\n+            bits -= 8;\n+        }\n+        state |= ((val & ((I(1) << bits) - 1)) << offset);\n+        offset += bits;\n+    }\n+\n+    inline void Flush() {\n+        if (offset) {\n+            *(out++) = state;\n+            state = 0;\n+            offset = 0;\n+        }\n+    }\n+};\n+\n+class BitReader {\n+    unsigned char state = 0;\n+    int offset = 0;\n+    const unsigned char* in;\n+\n+public:\n+    BitReader(const unsigned char* input) : in(input) {}\n+\n+    template<int BITS, typename I>\n+    inline I Read() {\n+        int bits = BITS;\n+        if (offset >= bits) {\n+            I ret = state & ((1 << bits) - 1);\n+            state >>= bits;\n+            offset -= bits;\n+            return ret;\n+        }\n+        I val = state;\n+        int out = offset;\n+        while (out + 8 <= bits) {\n+            val |= ((I(*(in++))) << out);\n+            out += 8;\n+        }\n+        if (out < bits) {\n+            unsigned char c = *(in++);\n+            val |= (c & ((I(1) << (bits - out)) - 1)) << out;\n+            state = c >> (bits - out);\n+            offset = 8 - (bits - out);\n+        } else {\n+            state = 0;\n+            offset = 0;\n+        }\n+        return val;\n+    }\n+};\n+\n+/** Return a value of type I with its `bits` lowest bits set (bits must be > 0). */\n+template<int BITS, typename I>\n+constexpr inline I Mask() { return ((I((I(-1)) << (std::numeric_limits<I>::digits - BITS))) >> (std::numeric_limits<I>::digits - BITS)); }\n+\n+/** Compute the smallest power of two that is larger than val. */\n+template<typename I>\n+static inline int CountBits(I val, int max) {\n+#ifdef HAVE_CLZ\n+    (void)max;\n+    if (val == 0) return 0;\n+    if (std::numeric_limits<unsigned>::digits >= std::numeric_limits<I>::digits) {\n+        return std::numeric_limits<unsigned>::digits - __builtin_clz(val);\n+    } else if (std::numeric_limits<unsigned long>::digits >= std::numeric_limits<I>::digits) {\n+        return std::numeric_limits<unsigned long>::digits - __builtin_clzl(val);\n+    } else {\n+        return std::numeric_limits<unsigned long long>::digits - __builtin_clzll(val);\n+    }\n+#else\n+    while (max && (val >> (max - 1) == 0)) --max;\n+    return max;\n+#endif\n+}\n+\n+template<typename I, int BITS>\n+class BitsInt {\n+private:\n+    static_assert(std::is_integral<I>::value && std::is_unsigned<I>::value, \"BitsInt requires an unsigned integer type\");\n+    static_assert(BITS > 0 && BITS <= std::numeric_limits<I>::digits, \"BitsInt requires 1 <= Bits <= representation type size\");\n+\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+public:\n+\n+    typedef I Repr;\n+\n+    static constexpr int SIZE = BITS;\n+\n+    static void inline Swap(I& a, I& b) {\n+        std::swap(a, b);\n+    }\n+\n+    static constexpr inline bool IsZero(I a) { return a == 0; }\n+    static constexpr inline I Mask(I val) { return val & MASK; }\n+    static constexpr inline I Shift(I val, int bits) { return ((val << bits) & MASK); }\n+    static constexpr inline I UnsafeShift(I val, int bits) { return (val << bits); }\n+\n+    template<int Offset, int Count>\n+    static constexpr inline int MidBits(I val) {\n+        static_assert(Count > 0, \"BITSInt::MidBits needs Count > 0\");\n+        static_assert(Count + Offset <= BITS, \"BitsInt::MidBits overflow of Count+Offset\");\n+        return (val >> Offset) & ((I(1) << Count) - 1);\n+    }\n+\n+    template<int Count>\n+    static constexpr inline int TopBits(I val) {\n+        static_assert(Count > 0, \"BitsInt::TopBits needs Count > 0\");\n+        static_assert(Count <= BITS, \"BitsInt::TopBits needs Offset <= BITS\");\n+        return val >> (BITS - Count);\n+    }\n+\n+    static inline constexpr I CondXorWith(I val, bool cond, I v) {\n+        return val ^ (-I(cond) & v);\n+    }\n+\n+    template<I MOD>\n+    static inline constexpr I CondXorWith(I val, bool cond) {\n+        return val ^ (-I(cond) & MOD);\n+    }\n+\n+    static inline int Bits(I val, int max) { return CountBits<I>(val, max); }\n+};\n+\n+/** Class which implements a stateless LFSR for generic moduli. */\n+template<typename F, uint32_t MOD>\n+struct LFSR {\n+    typedef typename F::Repr I;\n+    /** Shift a value `a` up once, treating it as an `N`-bit LFSR, with pattern `MOD`. */\n+    static inline constexpr I Call(const I& a) {\n+        return F::template CondXorWith<MOD>(F::Shift(a, 1), F::template TopBits<1>(a));\n+    }\n+};\n+\n+/** Helper class for carryless multiplications. */\n+template<typename I, int N, typename L, typename F, int K> struct GFMulHelper;\n+template<typename I, int N, typename L, typename F> struct GFMulHelper<I, N, L, F, 0>\n+{\n+    static inline constexpr I Run(const I& a, const I& b) { return I(0); }\n+};\n+template<typename I, int N, typename L, typename F, int K> struct GFMulHelper\n+{\n+    static inline constexpr I Run(const I& a, const I& b) { return F::CondXorWith(GFMulHelper<I, N, L, F, K - 1>::Run(L::Call(a), b), F::template MidBits<N - K, 1>(b), a); }\n+};\n+\n+/** Compute the carry-less multiplication of a and b, with N bits, using L as LFSR type. */\n+template<typename I, int N, typename L, typename F> inline constexpr I GFMul(const I& a, const I& b) { return GFMulHelper<I, N, L, F, N>::Run(a, b); }\n+\n+/** Compute the inverse of x using an extgcd algorithm. */\n+template<typename I, typename F, int BITS, uint32_t MOD>\n+inline I InvExtGCD(I x)\n+{\n+    if (F::IsZero(x)) return x;\n+    I t(0), newt(1);\n+    I r(MOD), newr = x;\n+    int rlen = BITS + 1, newrlen = F::Bits(newr, BITS);\n+    while (newr) {\n+        int q = rlen - newrlen;\n+        r ^= F::Shift(newr, q);\n+        t ^= F::UnsafeShift(newt, q);\n+        rlen = F::Bits(r, rlen - 1);\n+        if (r < newr) {\n+            F::Swap(t, newt);\n+            F::Swap(r, newr);\n+            std::swap(rlen, newrlen);\n+        }\n+    }\n+    return t;\n+}\n+\n+/** Compute the inverse of x1 using an exponentiation ladder.\n+ *\n+ * The `MUL` argument is a multiplication function, `SQR` is a squaring function, and the `SQRi` arguments\n+ * compute x**(2**i).\n+ */\n+template<typename I, typename F, int BITS, I (*MUL)(I, I), I (*SQR)(I), I (*SQR2)(I), I(*SQR4)(I), I(*SQR8)(I), I(*SQR16)(I)>\n+inline I InvLadder(I x1)\n+{\n+    static constexpr int INV_EXP = BITS - 1;\n+    I x2 = (INV_EXP >= 2) ? MUL(SQR(x1), x1) : I();\n+    I x4 = (INV_EXP >= 4) ? MUL(SQR2(x2), x2) : I();\n+    I x8 = (INV_EXP >= 8) ? MUL(SQR4(x4), x4) : I();\n+    I x16 = (INV_EXP >= 16) ? MUL(SQR8(x8), x8) : I();\n+    I x32 = (INV_EXP >= 32) ? MUL(SQR16(x16), x16) : I();\n+    I r;\n+    if (INV_EXP >= 32) {\n+        r = x32;\n+    } else if (INV_EXP >= 16) {\n+        r = x16;\n+    } else if (INV_EXP >= 8) {\n+        r = x8;\n+    } else if (INV_EXP >= 4) {\n+        r = x4;\n+    } else if (INV_EXP >= 2) {\n+        r = x2;\n+    } else {\n+        r = x1;\n+    }\n+    if (INV_EXP >= 32 && (INV_EXP & 16)) r = MUL(SQR16(r), x16);\n+    if (INV_EXP >= 16 && (INV_EXP & 8)) r = MUL(SQR8(r), x8);\n+    if (INV_EXP >= 8 && (INV_EXP & 4)) r = MUL(SQR4(r), x4);\n+    if (INV_EXP >= 4 && (INV_EXP & 2)) r = MUL(SQR2(r), x2);\n+    if (INV_EXP >= 2 && (INV_EXP & 1)) r = MUL(SQR(r), x1);\n+    return SQR(r);\n+}\n+\n+#endif"
      },
      {
        "sha": "b9d8ea8e1da3cb949571d62ff32d06ce97ce617e",
        "filename": "src/lintrans.h",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/lintrans.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/lintrans.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lintrans.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,150 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_LINTRANS_H_\n+#define _MINISKETCH_LINTRANS_H_\n+\n+#include \"int_utils.h\"\n+\n+/** A type to represent integers in the type system. */\n+template<int N> struct Num {};\n+\n+/** A Linear N-bit transformation over the field I. */\n+template<typename I, int N> class LinTrans {\n+private:\n+    I table[1 << N];\n+public:\n+    LinTrans() = default;\n+\n+    /* Construct a transformation over 3 to 8 bits, using the images of each bit. */\n+    constexpr LinTrans(I a, I b) : table{I(0), I(a), I(b), I(a ^ b)} {}\n+    constexpr LinTrans(I a, I b, I c) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c)} {}\n+    constexpr LinTrans(I a, I b, I c, I d) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f, I g) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f), I(g), I(a ^ g), I(b ^ g), I(a ^ b ^ g), I(c ^ g), I(a ^ c ^ g), I(b ^ c ^ g), I(a ^ b ^ c ^ g), I(d ^ g), I(a ^ d ^ g), I(b ^ d ^ g), I(a ^ b ^ d ^ g), I(c ^ d ^ g), I(a ^ c ^ d ^ g), I(b ^ c ^ d ^ g), I(a ^ b ^ c ^ d ^ g), I(e ^ g), I(a ^ e ^ g), I(b ^ e ^ g), I(a ^ b ^ e ^ g), I(c ^ e ^ g), I(a ^ c ^ e ^ g), I(b ^ c ^ e ^ g), I(a ^ b ^ c ^ e ^ g), I(d ^ e ^ g), I(a ^ d ^ e ^ g), I(b ^ d ^ e ^ g), I(a ^ b ^ d ^ e ^ g), I(c ^ d ^ e ^ g), I(a ^ c ^ d ^ e ^ g), I(b ^ c ^ d ^ e ^ g), I(a ^ b ^ c ^ d ^ e ^ g), I(f ^ g), I(a ^ f ^ g), I(b^ f ^ g), I(a ^ b ^ f ^ g), I(c^ f ^ g), I(a ^ c ^ f ^ g), I(b ^ c ^ f ^ g), I(a ^ b ^ c ^ f ^ g), I(d ^ f ^ g), I(a ^ d ^ f ^ g), I(b ^ d ^ f ^ g), I(a ^ b ^ d ^ f ^ g), I(c ^ d ^ f ^ g), I(a ^ c ^ d ^ f ^ g), I(b ^ c ^ d ^ f ^ g), I(a ^ b ^ c ^ d ^ f ^ g), I(e ^ f ^ g), I(a ^ e ^ f ^ g), I(b ^ e ^ f ^ g), I(a ^ b ^ e ^ f ^ g), I(c ^ e ^ f ^ g), I(a ^ c ^ e ^ f ^ g), I(b ^ c ^ e ^ f ^ g), I(a ^ b ^ c ^ e ^ f ^ g), I(d ^ e ^ f ^ g), I(a ^ d ^ e ^ f ^ g), I(b ^ d ^ e ^ f ^ g), I(a ^ b ^ d ^ e ^ f ^ g), I(c ^ d ^ e ^ f ^ g), I(a ^ c ^ d ^ e ^ f ^ g), I(b ^ c ^ d ^ e ^ f ^ g), I(a ^ b ^ c ^ d ^ e ^ f ^ g)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f, I g, I h) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f), I(g), I(a ^ g), I(b ^ g), I(a ^ b ^ g), I(c ^ g), I(a ^ c ^ g), I(b ^ c ^ g), I(a ^ b ^ c ^ g), I(d ^ g), I(a ^ d ^ g), I(b ^ d ^ g), I(a ^ b ^ d ^ g), I(c ^ d ^ g), I(a ^ c ^ d ^ g), I(b ^ c ^ d ^ g), I(a ^ b ^ c ^ d ^ g), I(e ^ g), I(a ^ e ^ g), I(b ^ e ^ g), I(a ^ b ^ e ^ g), I(c ^ e ^ g), I(a ^ c ^ e ^ g), I(b ^ c ^ e ^ g), I(a ^ b ^ c ^ e ^ g), I(d ^ e ^ g), I(a ^ d ^ e ^ g), I(b ^ d ^ e ^ g), I(a ^ b ^ d ^ e ^ g), I(c ^ d ^ e ^ g), I(a ^ c ^ d ^ e ^ g), I(b ^ c ^ d ^ e ^ g), I(a ^ b ^ c ^ d ^ e ^ g), I(f ^ g), I(a ^ f ^ g), I(b^ f ^ g), I(a ^ b ^ f ^ g), I(c^ f ^ g), I(a ^ c ^ f ^ g), I(b ^ c ^ f ^ g), I(a ^ b ^ c ^ f ^ g), I(d ^ f ^ g), I(a ^ d ^ f ^ g), I(b ^ d ^ f ^ g), I(a ^ b ^ d ^ f ^ g), I(c ^ d ^ f ^ g), I(a ^ c ^ d ^ f ^ g), I(b ^ c ^ d ^ f ^ g), I(a ^ b ^ c ^ d ^ f ^ g), I(e ^ f ^ g), I(a ^ e ^ f ^ g), I(b ^ e ^ f ^ g), I(a ^ b ^ e ^ f ^ g), I(c ^ e ^ f ^ g), I(a ^ c ^ e ^ f ^ g), I(b ^ c ^ e ^ f ^ g), I(a ^ b ^ c ^ e ^ f ^ g), I(d ^ e ^ f ^ g), I(a ^ d ^ e ^ f ^ g), I(b ^ d ^ e ^ f ^ g), I(a ^ b ^ d ^ e ^ f ^ g), I(c ^ d ^ e ^ f ^ g), I(a ^ c ^ d ^ e ^ f ^ g), I(b ^ c ^ d ^ e ^ f ^ g), I(a ^ b ^ c ^ d ^ e ^ f ^ g), I(h), I(a ^ h), I(b ^ h), I(a ^ b ^ h), I(c ^ h), I(a ^ c ^ h), I(b ^ c ^ h), I(a ^ b ^ c ^ h), I(d ^ h), I(a ^ d ^ h), I(b ^ d ^ h), I(a ^ b ^ d ^ h), I(c ^ d ^ h), I(a ^ c ^ d ^ h), I(b ^ c ^ d ^ h), I(a ^ b ^ c ^ d ^ h), I(e ^ h), I(a ^ e ^ h), I(b ^ e ^ h), I(a ^ b ^ e ^ h), I(c ^ e ^ h), I(a ^ c ^ e ^ h), I(b ^ c ^ e ^ h), I(a ^ b ^ c ^ e ^ h), I(d ^ e ^ h), I(a ^ d ^ e ^ h), I(b ^ d ^ e ^ h), I(a ^ b ^ d ^ e ^ h), I(c ^ d ^ e ^ h), I(a ^ c ^ d ^ e ^ h), I(b ^ c ^ d ^ e ^ h), I(a ^ b ^ c ^ d ^ e ^ h), I(f ^ h), I(a ^ f ^ h), I(b^ f ^ h), I(a ^ b ^ f ^ h), I(c^ f ^ h), I(a ^ c ^ f ^ h), I(b ^ c ^ f ^ h), I(a ^ b ^ c ^ f ^ h), I(d ^ f ^ h), I(a ^ d ^ f ^ h), I(b ^ d ^ f ^ h), I(a ^ b ^ d ^ f ^ h), I(c ^ d ^ f ^ h), I(a ^ c ^ d ^ f ^ h), I(b ^ c ^ d ^ f ^ h), I(a ^ b ^ c ^ d ^ f ^ h), I(e ^ f ^ h), I(a ^ e ^ f ^ h), I(b ^ e ^ f ^ h), I(a ^ b ^ e ^ f ^ h), I(c ^ e ^ f ^ h), I(a ^ c ^ e ^ f ^ h), I(b ^ c ^ e ^ f ^ h), I(a ^ b ^ c ^ e ^ f ^ h), I(d ^ e ^ f ^ h), I(a ^ d ^ e ^ f ^ h), I(b ^ d ^ e ^ f ^ h), I(a ^ b ^ d ^ e ^ f ^ h), I(c ^ d ^ e ^ f ^ h), I(a ^ c ^ d ^ e ^ f ^ h), I(b ^ c ^ d ^ e ^ f ^ h), I(a ^ b ^ c ^ d ^ e ^ f ^ h), I(g ^ h), I(a ^ g ^ h), I(b ^ g ^ h), I(a ^ b ^ g ^ h), I(c ^ g ^ h), I(a ^ c ^ g ^ h), I(b ^ c ^ g ^ h), I(a ^ b ^ c ^ g ^ h), I(d ^ g ^ h), I(a ^ d ^ g ^ h), I(b ^ d ^ g ^ h), I(a ^ b ^ d ^ g ^ h), I(c ^ d ^ g ^ h), I(a ^ c ^ d ^ g ^ h), I(b ^ c ^ d ^ g ^ h), I(a ^ b ^ c ^ d ^ g ^ h), I(e ^ g ^ h), I(a ^ e ^ g ^ h), I(b ^ e ^ g ^ h), I(a ^ b ^ e ^ g ^ h), I(c ^ e ^ g ^ h), I(a ^ c ^ e ^ g ^ h), I(b ^ c ^ e ^ g ^ h), I(a ^ b ^ c ^ e ^ g ^ h), I(d ^ e ^ g ^ h), I(a ^ d ^ e ^ g ^ h), I(b ^ d ^ e ^ g ^ h), I(a ^ b ^ d ^ e ^ g ^ h), I(c ^ d ^ e ^ g ^ h), I(a ^ c ^ d ^ e ^ g ^ h), I(b ^ c ^ d ^ e ^ g ^ h), I(a ^ b ^ c ^ d ^ e ^ g ^ h), I(f ^ g ^ h), I(a ^ f ^ g ^ h), I(b^ f ^ g ^ h), I(a ^ b ^ f ^ g ^ h), I(c^ f ^ g ^ h), I(a ^ c ^ f ^ g ^ h), I(b ^ c ^ f ^ g ^ h), I(a ^ b ^ c ^ f ^ g ^ h), I(d ^ f ^ g ^ h), I(a ^ d ^ f ^ g ^ h), I(b ^ d ^ f ^ g ^ h), I(a ^ b ^ d ^ f ^ g ^ h), I(c ^ d ^ f ^ g ^ h), I(a ^ c ^ d ^ f ^ g ^ h), I(b ^ c ^ d ^ f ^ g ^ h), I(a ^ b ^ c ^ d ^ f ^ g ^ h), I(e ^ f ^ g ^ h), I(a ^ e ^ f ^ g ^ h), I(b ^ e ^ f ^ g ^ h), I(a ^ b ^ e ^ f ^ g ^ h), I(c ^ e ^ f ^ g ^ h), I(a ^ c ^ e ^ f ^ g ^ h), I(b ^ c ^ e ^ f ^ g ^ h), I(a ^ b ^ c ^ e ^ f ^ g ^ h), I(d ^ e ^ f ^ g ^ h), I(a ^ d ^ e ^ f ^ g ^ h), I(b ^ d ^ e ^ f ^ g ^ h), I(a ^ b ^ d ^ e ^ f ^ g ^ h), I(c ^ d ^ e ^ f ^ g ^ h), I(a ^ c ^ d ^ e ^ f ^ g ^ h), I(b ^ c ^ d ^ e ^ f ^ g ^ h), I(a ^ b ^ c ^ d ^ e ^ f ^ g ^ h)} {}\n+\n+    /* Construct a transformation over 3 to 8 bits, using a pointer to the bit's images. */\n+    constexpr LinTrans(const I* p, Num<2>) : LinTrans(I(p[0]), I(p[1])) {}\n+    constexpr LinTrans(const I* p, Num<3>) : LinTrans(I(p[0]), I(p[1]), I(p[2])) {}\n+    constexpr LinTrans(const I* p, Num<4>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3])) {}\n+    constexpr LinTrans(const I* p, Num<5>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4])) {}\n+    constexpr LinTrans(const I* p, Num<6>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5])) {}\n+    constexpr LinTrans(const I* p, Num<7>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5]), I(p[6])) {}\n+    constexpr LinTrans(const I* p, Num<8>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5]), I(p[6]), I(p[7])) {}\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<1>, I a)\n+    {\n+        table[0] = I(); table[1] = a;\n+        return a;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<2>, I a)\n+    {\n+        I b = F(a);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b;\n+        return b;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<3>, I a)\n+    {\n+        I b = F(a), c = F(b);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        return c;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<4>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        return d;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<5>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c), e = F(d);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        table[16] = e; table[17] = a ^ e; table[18] = b ^ e; table[19] = a ^ b ^ e; table[20] = c ^ e; table[21] = a ^ c ^ e; table[22] = b ^ c ^ e; table[23] = a ^ b ^ c ^ e;\n+        table[24] = d ^ e; table[25] = a ^ d ^ e; table[26] = b ^ d ^ e; table[27] = a ^ b ^ d ^ e; table[28] = c ^ d ^ e; table[29] = a ^ c ^ d ^ e; table[30] = b ^ c ^ d ^ e; table[31] = a ^ b ^ c ^ d ^ e;\n+        return e;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<6>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c), e = F(d), f = F(e);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        table[16] = e; table[17] = a ^ e; table[18] = b ^ e; table[19] = a ^ b ^ e; table[20] = c ^ e; table[21] = a ^ c ^ e; table[22] = b ^ c ^ e; table[23] = a ^ b ^ c ^ e;\n+        table[24] = d ^ e; table[25] = a ^ d ^ e; table[26] = b ^ d ^ e; table[27] = a ^ b ^ d ^ e; table[28] = c ^ d ^ e; table[29] = a ^ c ^ d ^ e; table[30] = b ^ c ^ d ^ e; table[31] = a ^ b ^ c ^ d ^ e;\n+        table[32] = f; table[33] = a ^ f; table[34] = b ^ f; table[35] = a ^ b ^ f; table[36] = c ^ f; table[37] = a ^ c ^ f; table[38] = b ^ c ^ f; table[39] = a ^ b ^ c ^ f;\n+        table[40] = d ^ f; table[41] = a ^ d ^ f; table[42] = b ^ d ^ f; table[43] = a ^ b ^ d ^ f; table[44] = c ^ d ^ f; table[45] = a ^ c ^ d ^ f; table[46] = b ^ c ^ d ^ f; table[47] = a ^ b ^ c ^ d ^ f;\n+        table[48] = e ^ f; table[49] = a ^ e ^ f; table[50] = b ^ e ^ f; table[51] = a ^ b ^ e ^ f; table[52] = c ^ e ^ f; table[53] = a ^ c ^ e ^ f; table[54] = b ^ c ^ e ^ f; table[55] = a ^ b ^ c ^ e ^ f;\n+        table[56] = d ^ e ^ f; table[57] = a ^ d ^ e ^ f; table[58] = b ^ d ^ e ^ f; table[59] = a ^ b ^ d ^ e ^ f; table[60] = c ^ d ^ e ^ f; table[61] = a ^ c ^ d ^ e ^ f; table[62] = b ^ c ^ d ^ e ^ f; table[63] = a ^ b ^ c ^ d ^ e ^ f;\n+        return f;\n+    }\n+\n+    template<typename O, int P>\n+    inline I constexpr Map(I a) const { return table[O::template MidBits<P, N>(a)]; }\n+\n+    template<typename O, int P>\n+    inline I constexpr TopMap(I a) const { static_assert(P + N == O::SIZE, \"TopMap inconsistency\"); return table[O::template TopBits<N>(a)]; }\n+};\n+\n+\n+/** A linear transformation constructed using LinTrans tables for sections of bits. */\n+template<typename I, int... N> class RecLinTrans;\n+\n+template<typename I, int N> class RecLinTrans<I, N> {\n+    LinTrans<I, N> trans;\n+public:\n+    static constexpr int BITS = N;\n+    constexpr RecLinTrans(const I* p, Num<BITS>) : trans(p, Num<N>()) {}\n+    constexpr RecLinTrans() = default;\n+    constexpr RecLinTrans(const I (&init)[BITS]) : RecLinTrans(init, Num<BITS>()) {}\n+\n+    template<typename O, int P = 0>\n+    inline I constexpr Map(I a) const { return trans.template TopMap<O, P>(a); }\n+\n+    template<I (*F)(const I&)>\n+    inline void Build(I a) { trans.template Build<F>(Num<N>(), a); }\n+};\n+\n+template<typename I, int N, int... X> class RecLinTrans<I, N, X...> {\n+    LinTrans<I, N> trans;\n+    RecLinTrans<I, X...> rec;\n+public:\n+    static constexpr int BITS = RecLinTrans<I, X...>::BITS + N;\n+    constexpr RecLinTrans(const I* p, Num<BITS>) : trans(p, Num<N>()), rec(p + N, Num<BITS - N>()) {}\n+    constexpr RecLinTrans() = default;\n+    constexpr RecLinTrans(const I (&init)[BITS]) : RecLinTrans(init, Num<BITS>()) {}\n+\n+    template<typename O, int P = 0>\n+    inline I constexpr Map(I a) const { return trans.template Map<O, P>(a) ^ rec.template Map<O, P + N>(a); }\n+\n+    template<I (*F)(const I&)>\n+    inline void Build(I a) { I n = trans.template Build<F>(Num<N>(), a); rec.template Build<F>(F(n)); }\n+};\n+\n+/** The identity transformation. */\n+class IdTrans {\n+public:\n+    template<typename O, typename I>\n+    inline I constexpr Map(I a) const { return a; }\n+};\n+\n+/** A singleton for the identity transformation. */\n+constexpr IdTrans ID_TRANS{};\n+\n+#endif"
      },
      {
        "sha": "e04cba89d9524d9d3b9accf5da73e8c6f1c7f314",
        "filename": "src/minisketch.cpp",
        "status": "added",
        "additions": 263,
        "deletions": 0,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/minisketch.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/minisketch.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,263 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <new>\n+\n+#include \"../include/minisketch.h\"\n+\n+#include \"false_positives.h\"\n+#include \"sketch.h\"\n+\n+#ifdef HAVE_CLMUL\n+#include <cpuid.h>\n+#endif\n+\n+Sketch* ConstructGeneric1Byte(int bits, int implementation);\n+Sketch* ConstructGeneric2Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric3Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric4Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric5Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric6Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric7Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric8Bytes(int bits, int implementation);\n+\n+#ifdef HAVE_CLMUL\n+Sketch* ConstructClMul1Byte(int bits, int implementation);\n+Sketch* ConstructClMul2Bytes(int bits, int implementation);\n+Sketch* ConstructClMul3Bytes(int bits, int implementation);\n+Sketch* ConstructClMul4Bytes(int bits, int implementation);\n+Sketch* ConstructClMul5Bytes(int bits, int implementation);\n+Sketch* ConstructClMul6Bytes(int bits, int implementation);\n+Sketch* ConstructClMul7Bytes(int bits, int implementation);\n+Sketch* ConstructClMul8Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri1Byte(int bits, int implementation);\n+Sketch* ConstructClMulTri2Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri3Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri4Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri5Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri6Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri7Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri8Bytes(int bits, int implementation);\n+#endif\n+\n+namespace {\n+\n+enum class FieldImpl {\n+    GENERIC = 0,\n+#ifdef HAVE_CLMUL\n+    CLMUL,\n+    CLMUL_TRI,\n+#endif\n+};\n+\n+Sketch* Construct(int bits, int impl)\n+{\n+    switch (FieldImpl(impl)) {\n+    case FieldImpl::GENERIC:\n+        switch ((bits + 7) / 8) {\n+        case 1:\n+            return ConstructGeneric1Byte(bits, impl);\n+        case 2:\n+            return ConstructGeneric2Bytes(bits, impl);\n+        case 3:\n+            return ConstructGeneric3Bytes(bits, impl);\n+        case 4:\n+            return ConstructGeneric4Bytes(bits, impl);\n+        case 5:\n+            return ConstructGeneric5Bytes(bits, impl);\n+        case 6:\n+            return ConstructGeneric6Bytes(bits, impl);\n+        case 7:\n+            return ConstructGeneric7Bytes(bits, impl);\n+        case 8:\n+            return ConstructGeneric8Bytes(bits, impl);\n+        default:\n+            return nullptr;\n+        }\n+#ifdef HAVE_CLMUL\n+    case FieldImpl::CLMUL:\n+    case FieldImpl::CLMUL_TRI: {\n+        uint32_t eax, ebx, ecx, edx;\n+        if (__get_cpuid(1, &eax, &ebx, &ecx, &edx) && (ecx & 0x2)) {\n+            switch ((bits + 7) / 8) {\n+            case 1:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul1Byte(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri1Byte(bits, impl);\n+            case 2:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul2Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri2Bytes(bits, impl);\n+            case 3:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul3Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri3Bytes(bits, impl);\n+            case 4:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul4Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri4Bytes(bits, impl);\n+            case 5:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul5Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri5Bytes(bits, impl);\n+            case 6:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul6Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri6Bytes(bits, impl);\n+            case 7:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul7Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri7Bytes(bits, impl);\n+            case 8:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul8Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri8Bytes(bits, impl);\n+            default:\n+                return nullptr;\n+            }\n+        }\n+    }\n+#endif\n+    }\n+    return nullptr;\n+}\n+\n+}\n+\n+extern \"C\" {\n+\n+int minisketch_bits_supported(uint32_t bits) {\n+    return (bits >= 2) && (bits <= 64);\n+}\n+\n+uint32_t minisketch_implementation_max() {\n+    uint32_t ret = 0;\n+#ifdef HAVE_CLMUL\n+    ret += 2;\n+#endif\n+    return ret;\n+}\n+\n+int minisketch_implementation_supported(uint32_t bits, uint32_t implementation) {\n+    if (!minisketch_bits_supported(bits) || implementation > minisketch_implementation_max()) {\n+        return 0;\n+    }\n+    try {\n+        Sketch* sketch = Construct(bits, implementation);\n+        if (sketch) {\n+            delete sketch;\n+            return 1;\n+        }\n+    } catch (std::bad_alloc& ba) {}\n+    return 0;\n+}\n+\n+minisketch* minisketch_create(uint32_t bits, uint32_t implementation, size_t capacity) {\n+    if (capacity == 0) {\n+        return nullptr;\n+    }\n+    try {\n+        Sketch* sketch = Construct(bits, implementation);\n+        if (sketch) {\n+            try {\n+                sketch->Init(capacity);\n+            } catch (std::bad_alloc& ba) {\n+                delete sketch;\n+                throw;\n+            }\n+            sketch->Ready();\n+        }\n+        return (minisketch*)sketch;\n+    } catch (std::bad_alloc& ba) {\n+        return nullptr;\n+    }\n+}\n+\n+uint32_t minisketch_bits(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Bits();\n+}\n+\n+size_t minisketch_capacity(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Syndromes();\n+}\n+\n+uint32_t minisketch_implementation(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Implementation();\n+}\n+\n+minisketch* minisketch_clone(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    Sketch* r = (Sketch*) minisketch_create(s->Bits(), s->Implementation(), s->Syndromes());\n+    if (r) {\n+        r->Merge(s);\n+    }\n+    return (minisketch*) r;\n+}\n+\n+void minisketch_destroy(minisketch* sketch) {\n+    if (sketch) {\n+        Sketch* s = (Sketch*)sketch;\n+        s->UnReady();\n+        delete s;\n+    }\n+}\n+\n+size_t minisketch_serialized_size(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    size_t bits = s->Bits();\n+    size_t syndromes = s->Syndromes();\n+    return (bits * syndromes + 7) / 8;\n+}\n+\n+void minisketch_serialize(const minisketch* sketch, unsigned char* output) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    s->Serialize(output);\n+}\n+\n+void minisketch_deserialize(minisketch* sketch, const unsigned char* input) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->Deserialize(input);\n+}\n+\n+void minisketch_add_uint64(minisketch* sketch, uint64_t element) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->Add(element);\n+}\n+\n+size_t minisketch_merge(minisketch* sketch, const minisketch* other_sketch) {\n+    Sketch* s1 = (Sketch*)sketch;\n+    const Sketch* s2 = (const Sketch*)other_sketch;\n+    s1->Check();\n+    s2->Check();\n+    if (s1->Bits() != s2->Bits()) return 0;\n+    if (s1->Implementation() != s2->Implementation()) return 0;\n+    return s1->Merge(s2);\n+}\n+\n+ssize_t minisketch_decode(const minisketch* sketch, size_t max_elements, uint64_t* output) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Decode(max_elements, output);\n+}\n+\n+void minisketch_set_seed(minisketch* sketch, uint64_t seed) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->SetSeed(seed);\n+}\n+\n+size_t minisketch_compute_capacity(uint32_t bits, size_t max_elements, uint32_t fpbits) {\n+    return ComputeCapacity(bits, max_elements, fpbits);\n+}\n+\n+size_t minisketch_compute_max_elements(uint32_t bits, size_t capacity, uint32_t fpbits) {\n+    return ComputeMaxElements(bits, capacity, fpbits);\n+}\n+\n+}"
      },
      {
        "sha": "3e9bad793d5210f87462573786baabb104e77109",
        "filename": "src/sketch.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/sketch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/sketch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sketch.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,42 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_STATE_H_\n+#define _MINISKETCH_STATE_H_\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** Abstract class for internal representation of a minisketch object. */\n+class Sketch\n+{\n+    uint64_t m_canary;\n+    const int m_implementation;\n+    const int m_bits;\n+\n+public:\n+    Sketch(int implementation, int bits) : m_implementation(implementation), m_bits(bits) {}\n+\n+    void Ready() { m_canary = 0x6d496e536b65LU; }\n+    void Check() const { if (m_canary != 0x6d496e536b65LU) abort(); }\n+    void UnReady() { m_canary = 1; }\n+    int Implementation() const { return m_implementation; }\n+    int Bits() const { return m_bits; }\n+\n+    virtual ~Sketch() {}\n+    virtual size_t Syndromes() const = 0;\n+\n+    virtual void Init(int syndromes) = 0;\n+    virtual void Add(uint64_t element) = 0;\n+    virtual void Serialize(unsigned char*) const = 0;\n+    virtual void Deserialize(const unsigned char*) = 0;\n+    virtual size_t Merge(const Sketch* other_sketch) = 0;\n+    virtual void SetSeed(uint64_t seed) = 0;\n+\n+    virtual int Decode(int max_count, uint64_t* roots) const = 0;\n+};\n+\n+#endif"
      },
      {
        "sha": "e4392da1cd596fc8899aad497def7f76209604f2",
        "filename": "src/sketch_impl.h",
        "status": "added",
        "additions": 432,
        "deletions": 0,
        "changes": 432,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/sketch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/sketch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sketch_impl.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,432 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_SKETCH_IMPL_H_\n+#define _MINISKETCH_SKETCH_IMPL_H_\n+\n+#include <random>\n+\n+#include \"util.h\"\n+#include \"sketch.h\"\n+#include \"int_utils.h\"\n+\n+/** Compute the remainder of a polynomial division of val by mod, putting the result in mod. */\n+template<typename F>\n+void PolyMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& val, const F& field) {\n+    size_t modsize = mod.size();\n+    CHECK_SAFE(modsize > 0 && mod.back() == 1);\n+    if (val.size() < modsize) return;\n+    CHECK_SAFE(val.back() != 0);\n+    while (val.size() >= modsize) {\n+        auto term = val.back();\n+        val.pop_back();\n+        if (term != 0) {\n+            typename F::Multiplier mul(field, term);\n+            for (size_t x = 0; x < mod.size() - 1; ++x) {\n+                val[val.size() - modsize + 1 + x] ^= mul(mod[x]);\n+            }\n+        }\n+    }\n+    while (val.size() > 0 && val.back() == 0) val.pop_back();\n+}\n+\n+/** Compute the quotient of a polynomial division of val by mod, putting the quotient in div and the remainder in val. */\n+template<typename F>\n+void DivMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& val, std::vector<typename F::Elem>& div, const F& field) {\n+    size_t modsize = mod.size();\n+    CHECK_SAFE(mod.size() > 0 && mod.back() == 1);\n+    if (val.size() < mod.size()) {\n+        div.clear();\n+        return;\n+    }\n+    CHECK_SAFE(val.back() != 0);\n+    div.resize(val.size() - mod.size() + 1);\n+    while (val.size() >= modsize) {\n+        auto term = val.back();\n+        div[val.size() - modsize] = term;\n+        val.pop_back();\n+        if (term != 0) {\n+            typename F::Multiplier mul(field, term);\n+            for (size_t x = 0; x < mod.size() - 1; ++x) {\n+                val[val.size() - modsize + 1 + x] ^= mul(mod[x]);\n+            }\n+        }\n+    }\n+}\n+\n+/** Make a polynomial monic. */\n+template<typename F>\n+typename F::Elem MakeMonic(std::vector<typename F::Elem>& a, const F& field) {\n+    CHECK_SAFE(a.back() != 0);\n+    if (a.back() == 1) return 0;\n+    auto inv = field.Inv(a.back());\n+    typename F::Multiplier mul(field, inv);\n+    a.back() = 1;\n+    for (size_t i = 0; i < a.size() - 1; ++i) {\n+        a[i] = mul(a[i]);\n+    }\n+    return inv;\n+}\n+\n+/** Compute the GCD of two polynomials, putting the result in a. b will be cleared. */\n+template<typename F>\n+void GCD(std::vector<typename F::Elem>& a, std::vector<typename F::Elem>& b, const F& field) {\n+    if (a.size() < b.size()) std::swap(a, b);\n+    while (b.size() > 0) {\n+        if (b.size() == 1) {\n+            a.resize(1);\n+            a[0] = 1;\n+            return;\n+        }\n+        MakeMonic(b, field);\n+        PolyMod(b, a, field);\n+        std::swap(a, b);\n+    }\n+}\n+\n+/** Square a polynomial. */\n+template<typename F>\n+void Sqr(std::vector<typename F::Elem>& poly, const F& field) {\n+    if (poly.size() == 0) return;\n+    poly.resize(poly.size() * 2 - 1);\n+    for (int x = poly.size() - 1; x >= 0; --x) {\n+        poly[x] = (x & 1) ? 0 : field.Sqr(poly[x / 2]);\n+    }\n+}\n+\n+/** Compute the trace map of (param*x) modulo mod, putting the result in out. */\n+template<typename F>\n+void TraceMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& out, const typename F::Elem& param, const F& field) {\n+    out.reserve(mod.size() * 2);\n+    out.resize(2);\n+    out[0] = 0;\n+    out[1] = param;\n+\n+    for (int i = 0; i < field.Bits() - 1; ++i) {\n+        Sqr(out, field);\n+        if (out.size() < 2) out.resize(2);\n+        out[1] = param;\n+        PolyMod(mod, out, field);\n+    }\n+}\n+\n+/** One step of the root finding algorithm; finds roots of stack[pos] and adds them to roots. Stack elements >= pos are destroyed.\n+ *\n+ * It operates on a stack of polynomials. The polynomial operated on is `stack[pos]`, where elements of `stack` with index higher\n+ * than `pos` are used as scratch space.\n+ *\n+ * `stack[pos]` is assumed to be square-free polynomial. If `fully_factorizable` is true, it is also assumed to have no irreducible\n+ * factors of degree higher than 1.\n+\n+ * This implements the Berlekamp trace algorithm, plus an efficient test to fail fast in\n+ * case the polynomial cannot be fully factored.\n+ */\n+template<typename F>\n+bool RecFindRoots(std::vector<std::vector<typename F::Elem>>& stack, size_t pos, std::vector<typename F::Elem>& roots, bool fully_factorizable, int depth, typename F::Elem randv, const F& field) {\n+    auto& ppoly = stack[pos];\n+    // We assert ppoly.size() > 1 (instead of just ppoly.size() > 0) to additionally exclude\n+    // constants polynomials because\n+    //  - ppoly is not constant initially (this is ensured by FindRoots()), and\n+    //  - we never recurse on a constant polynomial.\n+    CHECK_SAFE(ppoly.size() > 1 && ppoly.back() == 1);\n+    /* 1st degree input: constant term is the root. */\n+    if (ppoly.size() == 2) {\n+        roots.push_back(ppoly[0]);\n+        return true;\n+    }\n+    /* 2nd degree input: use direct quadratic solver. */\n+    if (ppoly.size() == 3) {\n+        CHECK_RETURN(ppoly[1] != 0, false); // Equations of the form (x^2 + a) have two identical solutions; contradicts square-free assumption. */\n+        auto input = field.Mul(ppoly[0], field.Sqr(field.Inv(ppoly[1])));\n+        auto root = field.Qrt(input);\n+        if ((field.Sqr(root) ^ root) != input) {\n+            CHECK_SAFE(!fully_factorizable);\n+            return false; // No root found.\n+        }\n+        auto sol = field.Mul(root, ppoly[1]);\n+        roots.push_back(sol);\n+        roots.push_back(sol ^ ppoly[1]);\n+        return true;\n+    }\n+    /* 3rd degree input and more: recurse further. */\n+    if (pos + 3 > stack.size()) {\n+        // Allocate memory if necessary.\n+        stack.resize((pos + 3) * 2);\n+    }\n+    auto& poly = stack[pos];\n+    auto& tmp = stack[pos + 1];\n+    auto& trace = stack[pos + 2];\n+    trace.clear();\n+    tmp.clear();\n+    for (int iter = 0;; ++iter) {\n+        // Compute the polynomial (trace(x*randv) mod poly(x)) symbolically,\n+        // and put the result in `trace`.\n+        TraceMod(poly, trace, randv, field);\n+\n+        if (iter >= 1 && !fully_factorizable) {\n+            // If the polynomial cannot be factorized completely (it has an\n+            // irreducible factor of degree higher than 1), we want to avoid\n+            // the case where this is only detected after trying all BITS\n+            // independent split attempts fail (see the assert below).\n+            //\n+            // Observe that if we call y = randv*x, it is true that:\n+            //\n+            //   trace = y + y^2 + y^4 + y^8 + ... y^(FIELDSIZE/2) mod poly\n+            //\n+            // Due to the Frobenius endomorphism, this means:\n+            //\n+            //   trace^2 = y^2 + y^4 + y^8 + ... + y^FIELDSIZE mod poly\n+            //\n+            // Or, adding them up:\n+            //\n+            //   trace + trace^2 = y + y^FIELDSIZE mod poly.\n+            //                   = randv*x + randv^FIELDSIZE*x^FIELDSIZE\n+            //                   = randv*x + randv*x^FIELDSIZE\n+            //                   = randv*(x + x^FIELDSIZE).\n+            //     (all mod poly)\n+            //\n+            // x + x^FIELDSIZE is the polynomial which has every field element\n+            // as root once. Whenever x + x^FIELDSIZE is multiple of poly,\n+            // this means it only has unique first degree factors. The same\n+            // holds for its constant multiple randv*(x + x^FIELDSIZE) =\n+            // trace + trace^2.\n+            //\n+            // We use this test to quickly verify whether the polynomial is\n+            // fully factorizable after already having computed a trace.\n+            // We don't invoke it immediately; only when splitting has failed\n+            // at least once, which avoids it for most polynomials that are\n+            // fully factorizable (or at least pushes the test down the\n+            // recursion to factors which are smaller and thus faster).\n+            tmp = trace;\n+            Sqr(tmp, field);\n+            for (size_t i = 0; i < trace.size(); ++i) {\n+                tmp[i] ^= trace[i];\n+            }\n+            while (tmp.size() && tmp.back() == 0) tmp.pop_back();\n+            PolyMod(poly, tmp, field);\n+\n+            // Whenever the test fails, we can immediately abort the root\n+            // finding. Whenever it succeeds, we can remember and pass down\n+            // the information that it is in fact fully factorizable, avoiding\n+            // the need to run the test again.\n+            if (tmp.size() != 0) return false;\n+            fully_factorizable = true;\n+        }\n+\n+        if (fully_factorizable) {\n+            // Every succesful iteration of this algorithm splits the input\n+            // polynomial further into buckets, each corresponding to a subset\n+            // of 2^(BITS-depth) roots. If after depth splits the degree of\n+            // the polynomial is >= 2^(BITS-depth), something is wrong.\n+            CHECK_RETURN((poly.size() - 2) >> (field.Bits() - depth) == 0, false);\n+        }\n+\n+        depth++;\n+        // In every iteration we multiply randv by 2. As a result, the set\n+        // of randv values forms a GF(2)-linearly independent basis of splits.\n+        randv = field.Mul2(randv);\n+        tmp = poly;\n+        GCD(trace, tmp, field);\n+        if (trace.size() != poly.size() && trace.size() > 1) break;\n+    }\n+    MakeMonic(trace, field);\n+    DivMod(trace, poly, tmp, field);\n+    // At this point, the stack looks like [... (poly) tmp trace], and we want to recursively\n+    // find roots of trace and tmp (= poly/trace). As we don't care about poly anymore, move\n+    // trace into its position first.\n+    std::swap(poly, trace);\n+    // Now the stack is [... (trace) tmp ...]. First we factor tmp (at pos = pos+1), and then\n+    // we factor trace (at pos = pos).\n+    if (!RecFindRoots(stack, pos + 1, roots, fully_factorizable, depth, randv, field)) return false;\n+    // The stack position pos contains trace, the polynomial with all of poly's roots which (after\n+    // multiplication with randv) have trace 0. This is never the case for irreducible factors\n+    // (which always end up in tmp), so we can set fully_factorizable to true when recursing.\n+    bool ret = RecFindRoots(stack, pos, roots, true, depth, randv, field);\n+    // Because of the above, recursion can never fail here.\n+    CHECK_SAFE(ret);\n+    return ret;\n+}\n+\n+/** Returns the roots of a fully factorizable polynomial\n+ *\n+ * This function assumes that the input polynomial is square-free\n+ * and not the zero polynomial (represented by an empty vector).\n+ *\n+ * In case the square-free polynomial is not fully factorizable, i.e., it\n+ * has fewer roots than its degree, the empty vector is returned.\n+ */\n+template<typename F>\n+std::vector<typename F::Elem> FindRoots(const std::vector<typename F::Elem>& poly, typename F::Elem basis, const F& field) {\n+    std::vector<typename F::Elem> roots;\n+    CHECK_RETURN(poly.size() != 0, {});\n+    CHECK_RETURN(basis != 0, {});\n+    if (poly.size() == 1) return roots; // No roots when the polynomial is a constant.\n+    roots.reserve(poly.size() - 1);\n+    std::vector<std::vector<typename F::Elem>> stack = {poly};\n+\n+    // Invoke the recursive factorization algorithm.\n+    if (!RecFindRoots(stack, 0, roots, false, 0, basis, field)) {\n+        // Not fully factorizable.\n+        return {};\n+    }\n+    CHECK_RETURN(poly.size() - 1 == roots.size(), {});\n+    return roots;\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> BerlekampMassey(const std::vector<typename F::Elem>& syndromes, size_t max_degree, const F& field) {\n+    std::vector<typename F::Multiplier> table;\n+    std::vector<typename F::Elem> current, prev, tmp;\n+    current.reserve(syndromes.size() / 2 + 1);\n+    prev.reserve(syndromes.size() / 2 + 1);\n+    tmp.reserve(syndromes.size() / 2 + 1);\n+    current.resize(1);\n+    current[0] = 1;\n+    prev.resize(1);\n+    prev[0] = 1;\n+    typename F::Elem b = 1, b_inv = 1;\n+    bool b_have_inv = true;\n+    table.reserve(syndromes.size());\n+\n+    for (size_t n = 0; n != syndromes.size(); ++n) {\n+        table.emplace_back(field, syndromes[n]);\n+        auto discrepancy = syndromes[n];\n+        for (size_t i = 1; i < current.size(); ++i) discrepancy ^= table[n - i](current[i]);\n+        if (discrepancy != 0) {\n+            int x = n + 1 - (current.size() - 1) - (prev.size() - 1);\n+            if (!b_have_inv) {\n+                b_inv = field.Inv(b);\n+                b_have_inv = true;\n+            }\n+            bool swap = 2 * (current.size() - 1) <= n;\n+            if (swap) {\n+                if (prev.size() + x - 1 > max_degree) return {}; // We'd exceed maximum degree\n+                tmp = current;\n+                current.resize(prev.size() + x);\n+            }\n+            typename F::Multiplier mul(field, field.Mul(discrepancy, b_inv));\n+            for (size_t i = 0; i < prev.size(); ++i) current[i + x] ^= mul(prev[i]);\n+            if (swap) {\n+                std::swap(prev, tmp);\n+                b = discrepancy;\n+                b_have_inv = false;\n+            }\n+        }\n+    }\n+    CHECK_RETURN(current.size() && current.back() != 0, {});\n+    return current;\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> ReconstructAllSyndromes(const std::vector<typename F::Elem>& odd_syndromes, const F& field) {\n+    std::vector<typename F::Elem> all_syndromes;\n+    all_syndromes.resize(odd_syndromes.size() * 2);\n+    for (size_t i = 0; i < odd_syndromes.size(); ++i) {\n+        all_syndromes[i * 2] = odd_syndromes[i];\n+        all_syndromes[i * 2 + 1] = field.Sqr(all_syndromes[i]);\n+    }\n+    return all_syndromes;\n+}\n+\n+template<typename F>\n+void AddToOddSyndromes(std::vector<typename F::Elem>& osyndromes, typename F::Elem data, const F& field) {\n+    auto sqr = field.Sqr(data);\n+    typename F::Multiplier mul(field, sqr);\n+    for (auto& osyndrome : osyndromes) {\n+        osyndrome ^= data;\n+        data = mul(data);\n+    }\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> FullDecode(const std::vector<typename F::Elem>& osyndromes, const F& field) {\n+    auto asyndromes = ReconstructAllSyndromes<typename F::Elem>(osyndromes, field);\n+    auto poly = BerlekampMassey(asyndromes, field);\n+    std::reverse(poly.begin(), poly.end());\n+    return FindRoots(poly, field);\n+}\n+\n+template<typename F>\n+class SketchImpl final : public Sketch\n+{\n+    const F m_field;\n+    std::vector<typename F::Elem> m_syndromes;\n+    typename F::Elem m_basis;\n+\n+public:\n+    template<typename... Args>\n+    SketchImpl(int implementation, int bits, const Args&... args) : Sketch(implementation, bits), m_field(args...) {\n+        std::random_device rng;\n+        std::uniform_int_distribution<uint64_t> dist;\n+        m_basis = m_field.FromSeed(dist(rng));\n+    }\n+\n+    size_t Syndromes() const override { return m_syndromes.size(); }\n+    void Init(int count) override { m_syndromes.assign(count, 0); }\n+\n+    void Add(uint64_t val) override\n+    {\n+        auto elem = m_field.FromUint64(val);\n+        AddToOddSyndromes(m_syndromes, elem, m_field);\n+    }\n+\n+    void Serialize(unsigned char* ptr) const override\n+    {\n+        BitWriter writer(ptr);\n+        for (const auto& val : m_syndromes) {\n+            m_field.Serialize(writer, val);\n+        }\n+        writer.Flush();\n+    }\n+\n+    void Deserialize(const unsigned char* ptr) override\n+    {\n+        BitReader reader(ptr);\n+        for (auto& val : m_syndromes) {\n+            val = m_field.Deserialize(reader);\n+        }\n+    }\n+\n+    int Decode(int max_count, uint64_t* out) const override\n+    {\n+        auto all_syndromes = ReconstructAllSyndromes(m_syndromes, m_field);\n+        auto poly = BerlekampMassey(all_syndromes, max_count, m_field);\n+        if (poly.size() == 0) return -1;\n+        if (poly.size() == 1) return 0;\n+        if ((int)poly.size() > 1 + max_count) return -1;\n+        std::reverse(poly.begin(), poly.end());\n+        auto roots = FindRoots(poly, m_basis, m_field);\n+        if (roots.size() == 0) return -1;\n+\n+        for (const auto& root : roots) {\n+            *(out++) = m_field.ToUint64(root);\n+        }\n+        return roots.size();\n+    }\n+\n+    size_t Merge(const Sketch* other_sketch) override\n+    {\n+        // Sad cast. This is safe only because the caller code in minisketch.cpp checks\n+        // that implementation and field size match.\n+        const SketchImpl* other = static_cast<const SketchImpl*>(other_sketch);\n+        m_syndromes.resize(std::min(m_syndromes.size(), other->m_syndromes.size()));\n+        for (size_t i = 0; i < m_syndromes.size(); ++i) {\n+            m_syndromes[i] ^= other->m_syndromes[i];\n+        }\n+        return m_syndromes.size();\n+    }\n+\n+    void SetSeed(uint64_t seed) override\n+    {\n+        if (seed == (uint64_t)-1) {\n+            m_basis = 1;\n+        } else {\n+            m_basis = m_field.FromSeed(seed);\n+        }\n+    }\n+};\n+\n+#endif"
      },
      {
        "sha": "051d8431ef0a4804ae5597ec3b4cb36d8266087b",
        "filename": "src/test-exhaust.cpp",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/test-exhaust.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/test-exhaust.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test-exhaust.cpp?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,247 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <algorithm>\n+#include <random>\n+#include <iostream>\n+#include <thread>\n+#include \"util.h\"\n+\n+uint64_t Combination(uint64_t n, uint64_t k) {\n+    if (n - k < k) k = n - k;\n+    uint64_t ret = 1;\n+    for (uint64_t i = 1; i <= k; ++i) {\n+        ret = (ret * n) / i;\n+        --n;\n+    }\n+    return ret;\n+}\n+\n+void TestAll(int bits, int impl, int count, uint32_t threadid, uint32_t threads, std::vector<uint64_t>& ret) {\n+    bool supported = minisketch_implementation_supported(bits, impl);\n+    minisketch* state = minisketch_create(bits, impl, count);\n+    CHECK(supported == (state != nullptr));\n+    if (!state) return;\n+\n+    // Iterate over all (bits)-bit sketches with (count) syndromes.\n+    for (uint64_t x = threadid; (x >> (bits * count)) == 0; x += threads) {\n+        // Construct the serialization and load it.\n+        unsigned char ser[8];\n+        ser[0] = x;\n+        ser[1] = x >> 8;\n+        ser[2] = x >> 16;\n+        ser[3] = x >> 24;\n+        ser[4] = x >> 32;\n+        ser[5] = x >> 40;\n+        ser[6] = x >> 48;\n+        ser[7] = x >> 56;\n+\n+        minisketch_deserialize(state, ser);\n+\n+        // Compute all the solutions.\n+        uint64_t roots[64];\n+        int num_roots = minisketch_decode(state, 64, roots);\n+\n+        // If there are solutions:\n+        if (num_roots >= 0) {\n+            // Asking for one root less should fail.\n+            CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots) == -1);\n+            // Reconstruct the sketch from the solutions.\n+            minisketch* state2 = minisketch_create(bits, 0, count);\n+            for (int i = 0; i < num_roots; ++i) {\n+                minisketch_add_uint64(state2, roots[i]);\n+            }\n+            // Serialize it.\n+            unsigned char nser[8] = {0};\n+            minisketch_serialize(state2, nser);\n+            // Compare it to the original.\n+            CHECK(memcmp(ser, nser, 8) == 0);\n+            // Count it.\n+            if (num_roots +1 >= (int)ret.size()) ret.resize(num_roots + 2);\n+            ret[num_roots + 1]++;\n+            minisketch_destroy(state2);\n+        } else {\n+            if (ret.size() == 0) ret.resize(1);\n+            ret[0]++;\n+        }\n+    }\n+    minisketch_destroy(state);\n+}\n+\n+std::vector<uint64_t> TestAll(int bits, int impl, int count, uint32_t threads) {\n+    std::vector<std::vector<uint64_t>> outputs;\n+    std::vector<std::thread> thread_list;\n+    thread_list.reserve(threads);\n+    outputs.resize(threads);\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list.emplace_back([=,&outputs](){ TestAll(bits, impl, count, i, threads, outputs[i]); });\n+    }\n+    std::vector<uint64_t> ret;\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list[i].join();\n+        if (ret.size() < outputs[i].size()) ret.resize(outputs[i].size());\n+        for (size_t j = 0; j < outputs[i].size(); ++j) {\n+            ret[j] += outputs[i][j];\n+        }\n+    }\n+    if (ret.size()) {\n+        for (int i = 1; i <= count + 1; ++i) {\n+            CHECK(ret[i] == Combination((uint64_t(1) << bits) - 1, i - 1));\n+        }\n+    }\n+    return ret;\n+}\n+\n+void TestRand(int bits, int impl, int count, int iter) {\n+    std::vector<uint64_t> elems(count);\n+    std::vector<uint64_t> roots(count + 1);\n+    std::random_device rnd;\n+    std::uniform_int_distribution<uint64_t> dist(1, bits == 64 ? -1 : ((uint64_t(1) << bits) - 1));\n+\n+    for (int i = 0; i < iter; ++i) {\n+        bool overfill = iter & 1; // Test some cases with overfull sketches that may not decode.\n+        minisketch* state = minisketch_create(bits, impl, count);\n+        if (!state) return;\n+        minisketch* basestate = minisketch_create(bits, 0, count);\n+        for (int j = 0; j < count + 3*overfill; ++j) {\n+            uint64_t r = dist(rnd);\n+            if (!overfill) elems[j] = r;\n+            minisketch_add_uint64(state, r);\n+            minisketch_add_uint64(basestate, r);\n+        }\n+        roots.assign(count + 1, 0);\n+        std::vector<unsigned char> data, basedata;\n+        basedata.resize(((count + 1) * bits + 7) / 8);\n+        data.resize(((count + 1) * bits + 7) / 8);\n+        minisketch_serialize(basestate, basedata.data());\n+        minisketch_serialize(state, data.data());\n+        CHECK(data == basedata);\n+        minisketch_deserialize(state, basedata.data());\n+        int num_roots = minisketch_decode(state, count + 1, roots.data());\n+        CHECK(overfill || num_roots >= 0);\n+        CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots.data()) == -1); // Decoding with a too-low maximum should fail.\n+        if (!overfill) {\n+            std::sort(roots.begin(), roots.begin() + num_roots);\n+//            fprintf(stderr, \"Solut: \");\n+//            for (int j = 0; j < num_roots; ++j) {\n+//                fprintf(stderr, \"%016llx \", (unsigned long long)roots[j]);\n+//            }\n+//            fprintf(stderr, \"\\n\");\n+            std::sort(elems.begin(), elems.end());\n+            int expected = elems.size();\n+            for (size_t pos = 0; pos < elems.size(); ++pos) {\n+                if (pos + 1 < elems.size() && elems[pos] == elems[pos + 1]) {\n+                    expected -= 2;\n+                    elems[pos] = 0;\n+                    elems[pos + 1] = 0;\n+                    ++pos;\n+                }\n+            }\n+            CHECK(num_roots == expected);\n+            std::sort(elems.begin(), elems.end());\n+//            fprintf(stderr, \"Elems: \");\n+//            for (int j = 0; j < expected; ++j) {\n+//                fprintf(stderr, \"%016llx \", (unsigned long long)elems[j + elems.size() - expected]);\n+//            }\n+//            fprintf(stderr, \"\\n\");\n+            CHECK(std::equal(roots.begin(), roots.begin() + num_roots, elems.end() - expected));\n+        }\n+        minisketch_destroy(state);\n+        minisketch_destroy(basestate);\n+    }\n+}\n+\n+void TestComputeFunctions() {\n+    for (uint32_t bits = 0; bits <= 256; ++bits) {\n+        for (uint32_t fpbits = 0; fpbits <= 512; ++fpbits) {\n+            std::vector<size_t> table_max_elements(1025);\n+            for (size_t capacity = 0; capacity <= 1024; ++capacity) {\n+                table_max_elements[capacity] = minisketch_compute_max_elements(bits, capacity, fpbits);\n+                // Exception for bits==0\n+                if (bits == 0) CHECK(table_max_elements[capacity] == 0);\n+                // A sketch with capacity N cannot guarantee decoding more than N elements.\n+                CHECK(table_max_elements[capacity] <= capacity);\n+                // When asking for N bits of false positive protection, either no solution exists, or no more than ceil(N / bits) excess capacity should be needed.\n+                if (bits > 0) CHECK(table_max_elements[capacity] == 0 || capacity - table_max_elements[capacity] <= (fpbits + bits - 1) / bits);\n+                // Increasing capacity by one, if there is a solution, should always increment the max_elements by at least one as well.\n+                if (capacity > 0) CHECK(table_max_elements[capacity] == 0 || table_max_elements[capacity] > table_max_elements[capacity - 1]);\n+            }\n+\n+            std::vector<size_t> table_capacity(513);\n+            for (size_t max_elements = 0; max_elements <= 512; ++max_elements) {\n+                table_capacity[max_elements] = minisketch_compute_capacity(bits, max_elements, fpbits);\n+                // Exception for bits==0\n+                if (bits == 0) CHECK(table_capacity[max_elements] == 0);\n+                // To be able to decode N elements, capacity needs to be at least N.\n+                if (bits > 0) CHECK(table_capacity[max_elements] >= max_elements);\n+                // A sketch of N bits in total cannot have more than N bits of false positive protection;\n+                if (bits > 0) CHECK(bits * table_capacity[max_elements] >= fpbits);\n+                // When asking for N bits of false positive protection, no more than ceil(N / bits) excess capacity should be needed.\n+                if (bits > 0) CHECK(table_capacity[max_elements] - max_elements <= (fpbits + bits - 1) / bits);\n+                // Increasing max_elements by one can only increment the capacity by 0 or 1.\n+                if (max_elements > 0 && fpbits < 256) CHECK(table_capacity[max_elements] == table_capacity[max_elements - 1] || table_capacity[max_elements] == table_capacity[max_elements - 1] + 1);\n+                // Check round-tripping max_elements->capacity->max_elements (only a lower bound)\n+                CHECK(table_capacity[max_elements] <= 1024);\n+                CHECK(table_max_elements[table_capacity[max_elements]] == 0 || table_max_elements[table_capacity[max_elements]] >= max_elements);\n+            }\n+\n+            for (size_t capacity = 0; capacity <= 512; ++capacity) {\n+                // Check round-tripping capacity->max_elements->capacity (exact, if it exists)\n+                CHECK(table_max_elements[capacity] <= 512);\n+                CHECK(table_max_elements[capacity] == 0 || table_capacity[table_max_elements[capacity]] == capacity);\n+            }\n+        }\n+    }\n+}\n+\n+int main(void) {\n+    TestComputeFunctions();\n+\n+    for (int j = 2; j <= 64; j += 1) {\n+        fprintf(stderr, \"%i random tests with %i bits:\\n\", 500 / j, j);\n+        TestRand(j, 0, 150, 500 / j);\n+        TestRand(j, 1, 150, 500 / j);\n+        TestRand(j, 2, 150, 500 / j);\n+        fprintf(stderr, \"%i random tests with %i bits: done\\n\", 500 / j, j);\n+    }\n+\n+    int counts[65] = {0};\n+    // Initialize capacities to 1 because a 0 capacity is not allowed.\n+    for (int bits = 0; bits < 65; ++bits) {\n+        counts[bits] = 1;\n+    }\n+    for (int weight = 0; weight <= 40; weight += 1) {\n+        for (int bits = 2; bits <= 32; ++bits) {\n+            int count = counts[bits];\n+            while (count < (1 << bits) && count * bits <= weight) {\n+                auto ret = TestAll(bits, 0, count, 4);\n+                auto ret2 = TestAll(bits, 1, count, 4);\n+                auto ret3 = TestAll(bits, 2, count, 4);\n+                CHECK(ret2.empty() || ret == ret2);\n+                CHECK(ret3.empty() || ret == ret3);\n+                fprintf(stderr, \"bits=%i count=%i below_bound=[\", bits, count);\n+                for (int i = 0; i <= count; ++i) {\n+                    if (i) fprintf(stderr,  \",\");\n+                    fprintf(stderr, \"%llu\", (unsigned long long)ret[i + 1]);\n+                }\n+                fprintf(stderr, \"] above_bound=[\");\n+                for (int i = count + 1; i + 1 < (int)ret.size(); ++i) {\n+                    if (i > count + 1) fprintf(stderr,  \",\");\n+                    fprintf(stderr, \"%llu/%llu\", (unsigned long long)ret[i + 1], (unsigned long long)Combination((uint64_t(1) << bits) - 1, i));\n+                }\n+                fprintf(stderr, \"] nodecode=[%g]\\n\", (double)ret[0] * pow(0.5, bits * count));\n+                ++count;\n+            }\n+            counts[bits] = count;\n+        }\n+    }\n+\n+    return 0;\n+}"
      },
      {
        "sha": "fdb3f3a231d05f32b2fc10caed04733ac2f29651",
        "filename": "src/util.h",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a495a213bbc56bc4e90070e9081371ec6ea1da7/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "patch": "@@ -0,0 +1,74 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_UTIL_H_\n+#define _MINISKETCH_UTIL_H_\n+\n+#ifdef MINISKETCH_VERIFY\n+#include <stdio.h>\n+#endif\n+\n+#if !defined(__GNUC_PREREQ)\n+# if defined(__GNUC__)&&defined(__GNUC_MINOR__)\n+#  define __GNUC_PREREQ(_maj,_min) \\\n+ ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))\n+# else\n+#  define __GNUC_PREREQ(_maj,_min) 0\n+# endif\n+#endif\n+\n+#if __GNUC_PREREQ(3, 0)\n+#define EXPECT(x,c) __builtin_expect((x),(c))\n+#else\n+#define EXPECT(x,c) (x)\n+#endif\n+\n+/* Assertion macros */\n+\n+/**\n+ * Unconditional failure on condition failure.\n+ * Primarily used in testing harnesses.\n+ */\n+#define CHECK(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, \"Check condition failed: \" #cond); \\\n+        abort(); \\\n+    } \\\n+} while(0)\n+\n+/**\n+ * Check macro that does nothing in normal non-verify builds but crashes in verify builds.\n+ * This is used to test conditions at runtime that should always be true, but are either\n+ * expensive to test or in locations where returning on failure would be messy.\n+ */\n+#ifdef MINISKETCH_VERIFY\n+#define CHECK_SAFE(cond) CHECK(cond)\n+#else\n+#define CHECK_SAFE(cond)\n+#endif\n+\n+/**\n+ * Check a condition and return on failure in non-verify builds, crash in verify builds.\n+ * Used for inexpensive conditions which believed to be always true in locations where\n+ * a graceful exit is possible.\n+ */\n+#ifdef MINISKETCH_VERIFY\n+#define CHECK_RETURN(cond, rvar) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, \"Check condition failed: \" #cond); \\\n+        abort(); \\\n+        return rvar; /* Does nothing, but causes compile to warn on incorrect return types. */ \\\n+    } \\\n+} while(0)\n+#else\n+#define CHECK_RETURN(cond, rvar) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        return rvar; \\\n+    } \\\n+} while(0)\n+#endif\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "fec47ad22dd25e319ffbfb9fe95a991a36d24427",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWM0N2FkMjJkZDI1ZTMxOWZmYmZiOWZlOTVhOTkxYTM2ZDI0NDI3",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T14:00:46Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T14:00:46Z"
      },
      "message": "Merge commit '0a495a213bbc56bc4e90070e9081371ec6ea1da7' as 'src/minisketch'",
      "tree": {
        "sha": "141e659b3beaddaecc8501544492a6790c66700b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/141e659b3beaddaecc8501544492a6790c66700b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fec47ad22dd25e319ffbfb9fe95a991a36d24427",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec47ad22dd25e319ffbfb9fe95a991a36d24427",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fec47ad22dd25e319ffbfb9fe95a991a36d24427",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec47ad22dd25e319ffbfb9fe95a991a36d24427/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6474c9f1ed472d7ba4b4391dc4455c41f5163c28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6474c9f1ed472d7ba4b4391dc4455c41f5163c28"
      },
      {
        "sha": "0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a495a213bbc56bc4e90070e9081371ec6ea1da7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a495a213bbc56bc4e90070e9081371ec6ea1da7"
      }
    ],
    "stats": {
      "total": 6419,
      "additions": 6419,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4320413c6e666caca54d45f45d8003bb89e177b4",
        "filename": "src/minisketch/.gitignore",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/.gitignore?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,36 @@\n+*.o\n+*.lo\n+*.la\n+*.dll\n+*.dylib\n+*.so.*\n+.*\n+*.a\n+*~\n+\n+Makefile\n+Makefile.in\n+aclocal.m4\n+autom4te.cache/\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n+config.log\n+config.status\n+configure\n+libtool\n+stamp-h1\n+\n+test-exhaust\n+test-exhaust-verify\n+bench"
      },
      {
        "sha": "b25e3caee3580d8bfcef225792e35b7641a5f401",
        "filename": "src/minisketch/LICENSE",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/LICENSE?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
      },
      {
        "sha": "fc2d4a10ba3a23555dde8fd1f53af01df73d2d6d",
        "filename": "src/minisketch/Makefile.am",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/Makefile.am?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,93 @@\n+ACLOCAL_AMFLAGS = -I build-aux/m4\n+AM_CXXFLAGS = $(WARN_CXXFLAGS) $(NOWARN_CXXFLAGS)\n+\n+include sources.mk\n+\n+include_HEADERS = $(MINISKETCH_DIST_HEADERS_INT)\n+noinst_HEADERS = $(MINISKETCH_LIB_HEADERS_INT) $(MINISKETCH_FIELD_GENERIC_HEADERS_INT) $(MINISKETCH_FIELD_CLMUL_HEADERS_INT)\n+\n+LIBMINISKETCH = libminisketch.la\n+LIBMINISKETCH_FIELD_GENERIC = libminisketch_field_generic.la\n+if ENABLE_CLMUL\n+LIBMINISKETCH_FIELD_CLMUL = libminisketch_field_clmul.la\n+endif\n+if USE_TESTS\n+LIBMINISKETCH_VERIFY=libminisketch_verify.la\n+LIBMINISKETCH_FIELD_GENERIC_VERIFY=libminisketch_field_generic_verify.la\n+if ENABLE_CLMUL\n+LIBMINISKETCH_FIELD_CLMUL_VERIFY=libminisketch_field_clmul_verify.la\n+endif\n+endif\n+\n+lib_LTLIBRARIES =\n+lib_LTLIBRARIES +=  $(LIBMINISKETCH)\n+\n+noinst_LTLIBRARIES =\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_GENERIC)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_GENERIC_VERIFY)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_CLMUL)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_FIELD_CLMUL_VERIFY)\n+noinst_LTLIBRARIES += $(LIBMINISKETCH_VERIFY)\n+\n+# Release libs\n+libminisketch_field_generic_la_SOURCES = $(MINISKETCH_FIELD_GENERIC_SOURCES_INT)\n+libminisketch_field_generic_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+\n+libminisketch_field_clmul_la_SOURCES = $(MINISKETCH_FIELD_CLMUL_SOURCES_INT)\n+libminisketch_field_clmul_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+libminisketch_field_clmul_la_CXXFLAGS = $(AM_CXXFLAGS) $(CLMUL_CXXFLAGS)\n+\n+libminisketch_la_SOURCES = $(MINISKETCH_LIB_SOURCES_INT)\n+libminisketch_la_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+libminisketch_la_LIBADD = $(LIBMINISKETCH_FIELD_CLMUL) $(LIBMINISKETCH_FIELD_GENERIC)\n+\n+# Libs with extra verification checks\n+libminisketch_field_generic_verify_la_SOURCES = $(MINISKETCH_FIELD_GENERIC_SOURCES_INT)\n+libminisketch_field_generic_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+\n+libminisketch_field_clmul_verify_la_SOURCES = $(MINISKETCH_FIELD_CLMUL_SOURCES_INT)\n+libminisketch_field_clmul_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+libminisketch_field_clmul_verify_la_CXXFLAGS = $(AM_CXXFLAGS) $(CLMUL_CXXFLAGS)\n+\n+libminisketch_verify_la_SOURCES = $(MINISKETCH_LIB_SOURCES_INT)\n+libminisketch_verify_la_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+libminisketch_verify_la_LIBADD = $(LIBMINISKETCH_FIELD_CLMUL_VERIFY) $(LIBMINISKETCH_FIELD_GENERIC_VERIFY)\n+\n+noinst_PROGRAMS =\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench\n+endif\n+if USE_TESTS\n+noinst_PROGRAMS += test-exhaust test-exhaust-verify\n+TESTS = test-exhaust test-exhaust-verify\n+endif\n+\n+bench_SOURCES = $(MINISKETCH_BENCH_SOURCES_INT)\n+bench_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+bench_LDADD = $(LIBMINISKETCH)\n+bench_LDFLAGS = $(AM_LDFLAGS) -static\n+\n+test_exhaust_SOURCES = $(MINISKETCH_TEST_SOURCES_INT)\n+test_exhaust_CPPFLAGS = $(AM_CPPFLAGS) $(RELEASE_DEFINES)\n+test_exhaust_CXXFLAGS = $(AM_CXXFLAGS) $(PTHREAD_CFLAGS)\n+test_exhaust_LDADD = $(LIBMINISKETCH)\n+test_exhaust_LDFLAGS = $(AM_LDFLAGS) $(PTHREAD_CFLAGS) -static\n+\n+test_exhaust_verify_SOURCES = $(MINISKETCH_TEST_SOURCES_INT)\n+test_exhaust_verify_CPPFLAGS = $(AM_CPPFLAGS) $(VERIFY_DEFINES)\n+test_exhaust_verify_CXXFLAGS = $(AM_CXXFLAGS) $(PTHREAD_CFLAGS)\n+test_exhaust_verify_LDADD = $(LIBMINISKETCH_VERIFY)\n+test_exhaust_verify_LDFLAGS = $(AM_LDFLAGS) $(PTHREAD_CFLAGS) -static\n+\n+EXTRA_DIST=\n+EXTRA_DIST += LICENSE\n+EXTRA_DIST += README.md\n+EXTRA_DIST += doc/example.c\n+EXTRA_DIST += doc/gen_params.sage\n+EXTRA_DIST += doc/math.md\n+EXTRA_DIST += doc/moduli.md\n+EXTRA_DIST += doc/plot_bits.png\n+EXTRA_DIST += doc/plot_capacity.png\n+EXTRA_DIST += doc/plot_diff.png\n+EXTRA_DIST += doc/plot_size.png\n+EXTRA_DIST += doc/protocoltips.md"
      },
      {
        "sha": "ba6011e8063a17084bc6bde04cacc022115e6be9",
        "filename": "src/minisketch/README.md",
        "status": "added",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/README.md?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,210 @@\n+# Minisketch: a library for [BCH](https://en.wikipedia.org/wiki/BCH_code)-based set reconciliation\n+<img align=\"right\" src=\"https://people.xiph.org/~greg/minisketch-vs.png\" />\n+\n+`libminisketch` is an optimized standalone MIT-licensed library with C API for constructing and decoding *set sketches*, which can be used for compact set reconciliation and other applications.\n+It is an implementation of the PinSketch<sup>[[1]](#myfootnote1)</sup> algorithm. An explanation of the algorithm can be found [here](doc/math.md).\n+\n+## Sketches for set reconciliation\n+\n+Sketches, as produced by this library, can be seen as \"set checksums\" with two peculiar properties:\n+* Sketches have a predetermined capacity, and when the number of elements in the set is not higher than the capacity, `libminisketch` will always recover the entire set from the sketch. A sketch of *b*-bit elements with capacity *c* can be stored in *bc* bits.\n+* The sketches of two sets can be combined by adding them (XOR) to obtain a sketch of the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) between the two sets (*i.e.*, all elements that occur in one but not both input sets).\n+\n+This makes them appropriate for a very bandwidth-efficient set reconciliation protocol. If Alice and Bob each have a set of elements, and they suspect that the sets largely but not entirely overlap,\n+they can use the following protocol to let both parties learn all the elements:\n+* Alice and Bob both compute a sketch of their set elements.\n+* Alice sends her sketch to Bob.\n+* Bob combines the two sketches, and obtains a sketch of the symmetric difference.\n+* Bob tries to recover the elements from the difference sketch.\n+* Bob sends every element in the difference that he has to Alice.\n+\n+This will always succeed when the size of the difference (elements that Alice has but Bob doesn't plus elements that Bob has but Alice doesn't) does not exceed the\n+capacity of the sketch that Alice sent. The interesting part is that this works regardless of the actual set sizes\u2014only the difference matters.\n+\n+If the elements are large, it may be preferable to compute the sketches over *hashes* of the set elements. In that case an additional step is added to the protocol, where Bob also sends the hash\n+of every element he does not have to Alice, who responds with the requested elements.\n+\n+The doc/ directory has additional [tips for designing reconciliation protocols using libminisketch](doc/protocoltips.md).\n+\n+## Evaluation\n+\n+<img src=\"doc/plot_capacity.png\" width=\"432\" height=\"324\" /> <img src=\"doc/plot_diff.png\" width=\"432\" height=\"324\" />\n+\n+<img src=\"doc/plot_size.png\" width=\"432\" height=\"324\" /> <img src=\"doc/plot_bits.png\" width=\"432\" height=\"324\" />\n+\n+**The first graph** above shows a benchmark of `libminisketch` against three other set reconciliation algorithms/implementations. The benchmarks were performed using a single core on a system with an Intel Core i7-7820HQ CPU with clock speed locked at 2.4 GHz. The diagram shows the time needed for merging of two sketches and decoding the result. The creation of a sketch on the same machine takes around 5 ns per capacity and per set element. The other implementations are:\n+* [`pinsketch`](https://www.cs.bu.edu/~reyzin/code/fuzzy.html), the original PinSketch implementation.\n+* [`cpisync`](https://github.com/trachten/cpisync), a software project which implements a number of set reconciliation algorithms and protocols. The included benchmark analyzes the non-probabilistic version of the original CPISync algorithm<sup>[[5]](#myfootnote5)</sup> only.\n+* A high-performance custom IBLT implementation using 4 hash functions and 32-bit checksums.\n+\n+For the largest sizes currently of interest to the authors, such as a set of capacity 4096 with 1024 differences, `libminisketch` is forty-nine times faster than `pinsketch` and over eight thousand times faster than `cpisync`. `libminisketch` is fast enough on realistic set sizes for use on high-traffic network servers where computational resources are limited.\n+\n+Even where performance is latency-limited, small minisketches can be fast enough to improve performance. On the above i7-7820HQ, a set of 2500 30-bit entries with a difference of 20 elements can be communicated in less time with a minisketch than sending the raw set so long as the communications bandwidth is 1 gigabit per second or less; an eight-element difference can be communicated in better than one-fifth the time on a gigabit link.\n+\n+**The second graph** above shows the performance of the same algorithms on the same system, but this time keeping the capacity constant at 128, while varying the number of differences to reconcile between 1 and 128. It shows how `cpisync`'s reconciliation speed is mostly dependent on capacity, while `pinsketch`/`libminisketch` are more dependent on number of differences.\n+\n+**The third graph** above shows the size overhead of a typical IBLT scheme over the other algorithms (which are near-optimal bandwidth), for various levels of failure probability. IBLT takes tens of times the bandwidth of `libminisketch` sketches when the set difference size is small and the required failure rate is low.\n+\n+**The fourth graph** above shows the effect of the field size on speed in `libminisketch`. The three lines correspond to:\n+* CLMUL 64-bit: Intel Core i7-7820HQ system at 2.4 GHz\n+* Generic 64-bit: POWER9 CP9M06 system at 2.8 GHz (Talos II)\n+* Generic 32-bit: Cortex-A53 at 1.2 GHz (Raspberry Pi 3B)\n+\n+It shows how CLMUL implementations are faster for certain fields (specifically, field sizes for which an irreducible polynomial of the form *x<sup>b</sup> + x + 1* over *GF(2)* exists, and to a lesser extent, fields which are a multiple of 8 bits). It also shows how (for now) a significant performance drop exists for fields larger than 32 bits on 32-bit platforms. Note that the three lines are not at the same scale (the Raspberry Pi 3B is around 10x slower for 32-bit fields than the Core i7; the POWER9 is around 1.3x slower).\n+\n+Below we compare the PinSketch algorithm (which `libminisketch` is an implementation of) with other set reconciliation algorithms:\n+\n+| Algorithm                                             | Sketch size               | Decode success | Decoding complexity | Difference type | Secure sketch |\n+| ----------------------------------------------------- | ------------------------- | ---------------| ------------------- | --------------- | ------------- |\n+| CPISync<sup>[[2]](#myfootnote2)</sup>                 | *(b+1)c*                  | Always         | *O(n<sup>3</sup>)*  | Both            | Yes           |\n+| PinSketch<sup>[[1]](#myfootnote1)</sup>               | *bc*                      | Always         | *O(n<sup>2</sup>)*  | Symmetric only  | Yes           |\n+| IBLT<sup>[[6]](#myfootnote1)[[7]](#myfootnote1)</sup> | *&alpha;bc* (see graph 3) | Probabilistic  | *O(n)*              | Depends         | No            |\n+\n+* **Sketch size:** This column shows the size in bits of a sketch designed for reconciling *c* different *b*-bit elements. PinSketch and CPISync have a near-optimal<sup>[[11]](#myfootnote11)</sup> communication overhead, which in practice means the sketch size is very close (or equal to) *bc* bits. That is the same size as would be needed to transfer the elements of the difference naively (which is remarkable, as the difference isn't even known by the sender). For IBLT there is an overhead factor *&alpha;*, which depends on various design parameters, but is often between *2* and *10*.\n+* **Decode success:** Whenever a sketch is designed with a capacity not lower than the actual difference size, CPISync and PinSketch guarantee that decoding of the difference will always succeed. IBLT always has a chance of failure, though that chance can be made arbitrarily small by increasing the communication overhead.\n+* **Decoding complexity:** The space savings achieved by near-optimal algorithms come at a cost in performance, as their asymptotic decode complexity is quadratic or cubic, while IBLT is linear. This means that using near-optimal algorithms can be too expensive for applications where the difference is sufficiently large.\n+* **Difference type:** PinSketch can only compute the symmetric difference from a merged sketch, while CPISync and IBLT can distinguish which side certain elements were missing on. When the decoder has access to one of the sets, this generally doesn't matter, as he can look up each of the elements in the symmetric difference with one of the sets.\n+* **Secure sketch:** Whether the sketch satisfies the definition of a secure sketch<sup>[[1]](#myfootnote1)</sup>, which implies a minimal amount about a set can be extracted from a sketch by anyone who does not know most of the elements already. This makes the algorithm appropriate for applications like fingerprint authentication.\n+\n+## Building\n+\n+The build system is very rudimentary for now, and [improvements](https://github.com/sipa/minisketch/pulls) are welcome.\n+\n+The following may work and produce a `libminisketch.a` file you can link against:\n+\n+```bash\n+git clone https://github.com/sipa/minisketch\n+cd minisketch/src\n+make\n+```\n+\n+## Usage\n+\n+In this section Alice and Bob are trying to find the difference between their sets.\n+Alice has the set *[3000 ... 3009]*, while Bob has *[3002 ... 3011]*.\n+\n+First, Alice creates a sketch:\n+\n+```c\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"../include/minisketch.h\"\n+int main(void) {\n+\n+  minisketch *sketch_a = minisketch_create(12, 0, 4);\n+```\n+\n+The arguments are:\n+* The field size *b*, which specifies the size of the elements being reconciled. With a field size *b*, the supported range of set elements is the integers from *1* to *2<sup>b</sub>* *- 1*, inclusive. Note that elements cannot be zero.\n+* The implementation number. Implementation *0* is always supported, but more efficient algorithms may be available on some hardware. The serialized form of a sketch is independent of the implementation, so different implementations can interoperate.\n+* The capacity *c*, which specifies how many differences the resulting sketch can reconcile.\n+\n+Then Alice adds her elements to her sketch. Note that adding the same element a second time removes it again, as sketches have set semantics, not multiset semantics.\n+\n+```c\n+  for (int i = 3000; i < 3010; ++i) {\n+    minisketch_add_uint64(sketch_a, i);\n+  }\n+```\n+\n+The next step is serializing the sketch into a byte array:\n+\n+```c\n+  size_t sersize = minisketch_serialized_size(sketch_a);\n+  assert(sersize == 12 * 4 / 8); // 4 12-bit values is 6 bytes.\n+  unsigned char *buffer_a = malloc(sersize);\n+  minisketch_serialize(sketch_a, buffer_a);\n+  minisketch_destroy(sketch_a);\n+```\n+\n+The contents of the buffer can then be submitted to Bob, who can create his own sketch:\n+\n+```c\n+  minisketch *sketch_b = minisketch_create(12, 0, 4); // Bob's own sketch\n+  for (int i = 3002; i < 3012; ++i) {\n+    minisketch_add_uint64(sketch_b, i);\n+  }\n+```\n+\n+After Bob receives Alice's serialized sketch, he can reconcile:\n+\n+```c\n+  sketch_a = minisketch_create(12, 0, 4);     // Alice's sketch\n+  minisketch_deserialize(sketch_a, buffer_a); // Load Alice's sketch\n+  free(buffer_a);\n+\n+  // Merge the elements from sketch_a into sketch_b. The result is a sketch_b\n+  // which contains all elements that occurred in Alice's or Bob's sets, but not\n+  // in both.\n+  minisketch_merge(sketch_b, sketch_a);\n+\n+  uint64_t differences[4];\n+  ssize_t num_differences = minisketch_decode(sketch_b, 4, differences);\n+  minisketch_destroy(sketch_a);\n+  minisketch_destroy(sketch_b);\n+  if (num_differences < 0) {\n+    printf(\"More than 4 differences!\\n\");\n+  } else {\n+    ssize_t i;\n+    for (i = 0; i < num_differences; ++i) {\n+      printf(\"%u is in only one of the two sets\\n\", (unsigned)differences[i]);\n+    }\n+  }\n+}\n+```\n+\n+In this example Bob would see output such as:\n+\n+```\n+$ gcc -std=c99 -Wall -Wextra -o example ./doc/example.c -Lsrc/ -lminisketch -lstdc++ && ./example\n+3000 is in only one of the two sets\n+3011 is in only one of the two sets\n+3001 is in only one of the two sets\n+3010 is in only one of the two sets\n+```\n+\n+The order of the output is arbitrary and will differ on different runs of minisketch_decode().\n+\n+## Applications\n+\n+Communications efficient set reconciliation has been proposed to optimize Bitcoin transaction distribution<sup>[[8]](#myfootnote8)</sup>, which would allow Bitcoin nodes to have many more peers while reducing bandwidth usage. It could also be used for Bitcoin block distribution<sup>[[9]](#myfootnote9)</sup>, particularly for very low bandwidth links such as satellite.  A similar approach (CPISync) is used by PGP SKS keyservers to synchronize their databases efficiently. Secure sketches can also be used as helper data to reliably extract a consistent cryptographic key from fuzzy biometric data while leaking minimal information<sup>[[1]](#myfootnote1)</sup>. They can be combined with [dcnets](https://en.wikipedia.org/wiki/Dining_cryptographers_problem) to create cryptographic multiparty anonymous communication<sup>[[10]](#myfootnote10)</sup>. \n+\n+## Implementation notes\n+\n+`libminisketch` is written in C++11, but has a [C API](include/minisketch.h) for compatibility reasons.\n+\n+Specific algorithms and optimizations used:\n+* Finite field implementations:\n+  * A generic implementation using C unsigned integer bit operations, and one using the [CLMUL instruction](https://en.wikipedia.org/wiki/CLMUL_instruction_set) where available. The latter has specializations for different classes of fields that permit optimizations (those with trinomial irreducible polynomials, and those whose size is a multiple of 8 bits).\n+  * Precomputed tables for (repeated) squaring, and for solving equations of the form *x<sup>2</sup> + x = a*<sup>[[2]](#myfootnote2)</sup>.\n+  * Inverses are computed using an [exponentiation ladder](https://en.wikipedia.org/w/index.php?title=Exponentiation_by_squaring&oldid=868883860)<sup>[[12]](#myfootnote12)</sup> on systems where multiplications are relatively fast, and using an [extended GCD algorithm](https://en.wikipedia.org/w/index.php?title=Extended_Euclidean_algorithm&oldid=865802511#Computing_multiplicative_inverses_in_modular_structures) otherwise.\n+  * Repeated multiplications are accelerated using runtime precomputations on systems where multiplications are relatively slow.\n+  * The serialization of field elements always represents them as bits that are coefficients of the lowest-weight (using lexicographic order as tie breaker) irreducible polynomials over *GF(2)* (see [this list](doc/moduli.md)), but for some implementations they are converted to a different representation internally.\n+* The sketch algorithms are specialized for each separate field implementation, permitting inlining and specific optimizations while avoiding dynamic allocations and branching costs.\n+* Decoding of sketches uses the [Berlekamp-Massey algorithm](https://en.wikipedia.org/w/index.php?title=Berlekamp%E2%80%93Massey_algorithm&oldid=870768940)<sup>[[3]](#myfootnote3)</sup> to compute the characteristic polynomial.\n+* Finding the roots of polynomials is done using the Berlekamp trace algorithm with explicit formula for quadratic polynomials<sup>[[4]](#myfootnote4)</sup>. The root finding is randomized to prevent adversarial inputs that intentionally trigger worst-case decode time.\n+* A (possibly) novel optimization combines a test for unique roots with the Berlekamp trace algorithm.\n+\n+Some improvements that are still TODO:\n+* Explicit formulas for the roots of polynomials of higher degree than 2\n+* Subquadratic multiplication and modulus algorithms\n+* The [Half-GCD algorithm](http://mathworld.wolfram.com/Half-GCD.html) for faster GCDs\n+* An interface for incremental decoding: most of the computation in most failed decodes can be reused when attempting to decode a longer sketch of the same set\n+* Platform specific optimizations for platforms other than x86\n+* Avoid using slow uint64_t for calculations on 32-bit hosts\n+* Optional IBLT / Hybrid and set entropy coder under the same interface\n+\n+## References\n+\n+* <a name=\"myfootnote1\">[1]</a> Dodis, Ostrovsky, Reyzin and Smith. *Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data.* SIAM Journal on Computing, volume 38, number 1, pages 97-139, 2008). [[URL]](http://eprint.iacr.org/2003/235) [[PDF]](https://eprint.iacr.org/2003/235.pdf)\n+* <a name=\"myfootnote5\">[5]</a> A. Trachtenberg, D. Starobinski and S. Agarwal. *Fast PDA synchronization using characteristic polynomial interpolation.* Proceedings, Twenty-First Annual Joint Conference of the IEEE Computer and Communications Societies, New York, NY, USA, 2002, pp. 1510-1519 vol.3. [[PDF]](https://pdfs.semanticscholar.org/43da/2070b6b7b2320a1fed2fd5e70e87332c9c5e.pdf)\n+* <a name=\"myfootnote2\">[2]</a> Cherly, J\u00f8rgen, Luis Gallardo, Leonid Vaserstein, and Ethel Wheland. *Solving quadratic equations over polynomial rings of characteristic two.* Publicacions Matem\u00e0tiques (1998): 131-142. [[PDF]](https://www.raco.cat/index.php/PublicacionsMatematiques/article/viewFile/37927/40412)\n+* <a name=\"myfootnote3\">[3]</a> J. Massey. *Shift-register synthesis and BCH decoding.* IEEE Transactions on Information Theory, vol. 15, no. 1, pp. 122-127, January 1969. [[PDF]](http://crypto.stanford.edu/~mironov/cs359/massey.pdf)\n+* <a name=\"myfootnote4\">[4]</a> Bhaskar Biswas, Vincent Herbert. *Efficient Root Finding of Polynomials over Fields of Characteristic 2.* 2009. hal-00626997. [[URL]](https://hal.archives-ouvertes.fr/hal-00626997) [[PDF]](https://hal.archives-ouvertes.fr/hal-00626997/document)\n+* <a name=\"myfootnote6\">[6]</a> Eppstein, David, Michael T. Goodrich, Frank Uyeda, and George Varghese. *What's the difference?: efficient set reconciliation without prior context.* ACM SIGCOMM Computer Communication Review, vol. 41, no. 4, pp. 218-229. ACM, 2011. [[PDF]](https://www.ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf)\n+* <a name=\"myfootnote7\">[7]</a> Goodrich, Michael T. and Michael Mitzenmacher. *Invertible bloom lookup tables.* 2011 49th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2011): 792-799. [[PDF]](https://arxiv.org/pdf/1101.2245.pdf)\n+* <a name=\"myfootnote8\">[8]</a> Maxwell, Gregory F. *[Blocksonly mode BW savings, the limits of efficient block xfer, and better relay](https://bitcointalk.org/index.php?topic=1377345.0)* Bitcointalk 2016, *[Technical notes on mempool synchronizing relay](https://people.xiph.org/~greg/mempool_sync_relay.txt)* #bitcoin-wizards 2016.\n+* <a name=\"myfootnote9\">[9]</a> Maxwell, Gregory F. *[Block network coding](https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding)* Bitcoin Wiki 2014, *[Technical notes on efficient block xfer](https://people.xiph.org/~greg/efficient.block.xfer.txt)* #bitcoin-wizards 2015.\n+* <a name=\"myfootnote10\">[10]</a> Ruffing, Tim, Moreno-Sanchez, Pedro, Aniket, Kate, *P2P Mixing and Unlinkable Bitcoin Transactions* NDSS Symposium 2017 [[URL]](https://eprint.iacr.org/2016/824) [[PDF]](https://eprint.iacr.org/2016/824.pdf)\n+* <a name=\"myfootnote11\">[11]</a> Y. Misky, A. Trachtenberg, R. Zippel. *Set Reconciliation with Nearly Optimal Communication Complexity.* Cornell University, 2000. [[URL]](https://ecommons.cornell.edu/handle/1813/5803) [[PDF]](https://ecommons.cornell.edu/bitstream/handle/1813/5803/2000-1813.pdf)\n+* <a name=\"myfootnote12\">[12]</a> Itoh, Toshiya, and Shigeo Tsujii. \"A fast algorithm for computing multiplicative inverses in GF (2m) using normal bases.\" Information and computation 78, no. 3 (1988): 171-177. [[URL]](https://www.sciencedirect.com/science/article/pii/0890540188900247)"
      },
      {
        "sha": "27417daf7691513da832eae5541b6c5bee091551",
        "filename": "src/minisketch/autogen.sh",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/autogen.sh?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+# Copyright (c) 2013-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+set -e\n+srcdir=\"$(dirname $0)\"\n+cd \"$srcdir\"\n+if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE=\"`which glibtoolize 2>/dev/null`\"; then\n+  LIBTOOLIZE=\"${GLIBTOOLIZE}\"\n+  export LIBTOOLIZE\n+fi\n+which autoreconf >/dev/null || \\\n+  (echo \"configuration failed, please install autoconf first\" && exit 1)\n+autoreconf --install --force --warnings=all"
      },
      {
        "sha": "ca3639715e7243fa4343eb2e7f3de53927cc9d4a",
        "filename": "src/minisketch/build-aux/m4/ax_check_compile_flag.m4",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_check_compile_flag.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_check_compile_flag.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/build-aux/m4/ax_check_compile_flag.m4?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,74 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])\n+#\n+# DESCRIPTION\n+#\n+#   Check whether the given FLAG works with the current language's compiler\n+#   or gives an error.  (Warnings, however, are ignored)\n+#\n+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on\n+#   success/failure.\n+#\n+#   If EXTRA-FLAGS is defined, it is added to the current language's default\n+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with\n+#   the flags: \"CFLAGS EXTRA-FLAGS FLAG\".  This can for example be used to\n+#   force the compiler to issue an error when a bad flag is given.\n+#\n+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.\n+#\n+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this\n+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>\n+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 4\n+\n+AC_DEFUN([AX_CHECK_COMPILE_FLAG],\n+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF\n+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl\n+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [\n+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS\n+  _AC_LANG_PREFIX[]FLAGS=\"$[]_AC_LANG_PREFIX[]FLAGS $4 $1\"\n+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],\n+    [AS_VAR_SET(CACHEVAR,[yes])],\n+    [AS_VAR_SET(CACHEVAR,[no])])\n+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])\n+AS_VAR_IF(CACHEVAR,yes,\n+  [m4_default([$2], :)],\n+  [m4_default([$3], :)])\n+AS_VAR_POPDEF([CACHEVAR])dnl\n+])dnl AX_CHECK_COMPILE_FLAGS"
      },
      {
        "sha": "ca1d5ee2b6d1ae107504d4ab433bc5f6fd629f61",
        "filename": "src/minisketch/build-aux/m4/ax_check_preproc_flag.m4",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_check_preproc_flag.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_check_preproc_flag.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/build-aux/m4/ax_check_preproc_flag.m4?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,74 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_check_preproc_flag.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CHECK_PREPROC_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])\n+#\n+# DESCRIPTION\n+#\n+#   Check whether the given FLAG works with the current language's\n+#   preprocessor or gives an error.  (Warnings, however, are ignored)\n+#\n+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on\n+#   success/failure.\n+#\n+#   If EXTRA-FLAGS is defined, it is added to the preprocessor's default\n+#   flags when the check is done.  The check is thus made with the flags:\n+#   \"CPPFLAGS EXTRA-FLAGS FLAG\".  This can for example be used to force the\n+#   preprocessor to issue an error when a bad flag is given.\n+#\n+#   INPUT gives an alternative input source to AC_PREPROC_IFELSE.\n+#\n+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this\n+#   macro in sync with AX_CHECK_{COMPILE,LINK}_FLAG.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>\n+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 4\n+\n+AC_DEFUN([AX_CHECK_PREPROC_FLAG],\n+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF\n+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]cppflags_$4_$1])dnl\n+AC_CACHE_CHECK([whether _AC_LANG preprocessor accepts $1], CACHEVAR, [\n+  ax_check_save_flags=$CPPFLAGS\n+  CPPFLAGS=\"$CPPFLAGS $4 $1\"\n+  AC_PREPROC_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],\n+    [AS_VAR_SET(CACHEVAR,[yes])],\n+    [AS_VAR_SET(CACHEVAR,[no])])\n+  CPPFLAGS=$ax_check_save_flags])\n+AS_VAR_IF(CACHEVAR,yes,\n+  [m4_default([$2], :)],\n+  [m4_default([$3], :)])\n+AS_VAR_POPDEF([CACHEVAR])dnl\n+])dnl AX_CHECK_PREPROC_FLAGS"
      },
      {
        "sha": "f147cee3b117f80b22544976385e267b26f46dd9",
        "filename": "src/minisketch/build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "status": "added",
        "additions": 568,
        "deletions": 0,
        "changes": 568,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_cxx_compile_stdcxx.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/build-aux/m4/ax_cxx_compile_stdcxx.m4?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,568 @@\n+# ===========================================================================\n+#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])\n+#\n+# DESCRIPTION\n+#\n+#   Check for baseline language coverage in the compiler for the specified\n+#   version of the C++ standard.  If necessary, add switches to CXX and\n+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)\n+#   or '14' (for the C++14 standard).\n+#\n+#   The second argument, if specified, indicates whether you insist on an\n+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.\n+#   -std=c++11).  If neither is specified, you get whatever works, with\n+#   preference for an extended mode.\n+#\n+#   The third argument, if specified 'mandatory' or if left unspecified,\n+#   indicates that baseline support for the specified C++ standard is\n+#   required and that the macro should error out if no mode with that\n+#   support is found.  If specified 'optional', then configuration proceeds\n+#   regardless, after defining HAVE_CXX${VERSION} if and only if a\n+#   supporting mode is found.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>\n+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>\n+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>\n+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>\n+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>\n+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved.  This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 4\n+\n+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro\n+dnl  (serial version number 13).\n+\n+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n+  m4_if([$1], [11], [],\n+        [$1], [14], [],\n+        [$1], [17], [m4_fatal([support for C++17 not yet implemented in AX_CXX_COMPILE_STDCXX])],\n+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$2], [], [],\n+        [$2], [ext], [],\n+        [$2], [noext], [],\n+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],\n+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])\n+  m4_if([$4], [], [ax_cxx_compile_cxx$1_try_default=true],\n+        [$4], [default], [ax_cxx_compile_cxx$1_try_default=true],\n+        [$4], [nodefault], [ax_cxx_compile_cxx$1_try_default=false],\n+        [m4_fatal([invalid fourth argument `$4' to AX_CXX_COMPILE_STDCXX])])\n+  AC_LANG_PUSH([C++])dnl\n+  ac_success=no\n+\n+  m4_if([$4], [nodefault], [], [dnl\n+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,\n+  ax_cv_cxx_compile_cxx$1,\n+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+    [ax_cv_cxx_compile_cxx$1=yes],\n+    [ax_cv_cxx_compile_cxx$1=no])])\n+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then\n+    ac_success=yes\n+  fi])\n+\n+  m4_if([$2], [noext], [], [dnl\n+  if test x$ac_success = xno; then\n+    for switch in -std=gnu++$1 -std=gnu++0x; do\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                     $cachevar,\n+        [ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+          [eval $cachevar=yes],\n+          [eval $cachevar=no])\n+         CXX=\"$ac_save_CXX\"])\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi])\n+\n+  m4_if([$2], [ext], [], [dnl\n+  if test x$ac_success = xno; then\n+    dnl HP's aCC needs +std=c++11 according to:\n+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf\n+    dnl Cray's crayCC needs \"-h std=c++11\"\n+    for switch in -std=c++$1 -std=c++0x +std=c++$1 \"-h std=c++$1\"; do\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                     $cachevar,\n+        [ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+          [eval $cachevar=yes],\n+          [eval $cachevar=no])\n+         CXX=\"$ac_save_CXX\"])\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi])\n+  AC_LANG_POP([C++])\n+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX$1=0\n+    AC_MSG_NOTICE([No compiler with C++$1 support was found])\n+  else\n+    HAVE_CXX$1=1\n+    AC_DEFINE(HAVE_CXX$1,1,\n+              [define if the compiler supports basic C++$1 syntax])\n+  fi\n+  AC_SUBST(HAVE_CXX$1)\n+])\n+\n+\n+dnl  Test body for checking C++11 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+)\n+\n+\n+dnl  Test body for checking C++14 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14\n+)\n+\n+\n+dnl  Tests for new features in C++11\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+]])\n+\n+\n+dnl  Tests for new features in C++14\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[\n+\n+// If the compiler admits that it is not ready for C++14, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201402L\n+\n+#error \"This is not a C++14 compiler\"\n+\n+#else\n+\n+namespace cxx14\n+{\n+\n+  namespace test_polymorphic_lambdas\n+  {\n+\n+    int\n+    test()\n+    {\n+      const auto lambda = [](auto&&... args){\n+        const auto istiny = [](auto x){\n+          return (sizeof(x) == 1UL) ? 1 : 0;\n+        };\n+        const int aretiny[] = { istiny(args)... };\n+        return aretiny[0];\n+      };\n+      return lambda(1, 1L, 1.0f, '1');\n+    }\n+\n+  }\n+\n+  namespace test_binary_literals\n+  {\n+\n+    constexpr auto ivii = 0b0000000000101010;\n+    static_assert(ivii == 42, \"wrong value\");\n+\n+  }\n+\n+  namespace test_generalized_constexpr\n+  {\n+\n+    template < typename CharT >\n+    constexpr unsigned long\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      auto length = 0UL;\n+      for (auto p = s; *p; ++p)\n+        ++length;\n+      return length;\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"x\") == 1UL, \"\");\n+    static_assert(strlen_c(\"test\") == 4UL, \"\");\n+    static_assert(strlen_c(\"another\\0test\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_lambda_init_capture\n+  {\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      const auto lambda1 = [a = x](int b){ return a + b; };\n+      const auto lambda2 = [a = lambda1(x)](){ return a; };\n+      return lambda2();\n+    }\n+\n+  }\n+\n+  namespace test_digit_seperators\n+  {\n+\n+    constexpr auto ten_million = 100'000'000;\n+    static_assert(ten_million == 100000000, \"\");\n+\n+  }\n+\n+  namespace test_return_type_deduction\n+  {\n+\n+    auto f(int& x) { return x; }\n+    decltype(auto) g(int& x) { return x; }\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static constexpr auto value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static constexpr auto value = true;\n+    };\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      static_assert(is_same<int, decltype(f(x))>::value, \"\");\n+      static_assert(is_same<int&, decltype(g(x))>::value, \"\");\n+      return x;\n+    }\n+\n+  }\n+\n+}  // namespace cxx14\n+\n+#endif  // __cplusplus >= 201402L\n+\n+]])"
      },
      {
        "sha": "4c4051ea376f720faf21a4705c66604fe444c958",
        "filename": "src/minisketch/build-aux/m4/ax_pthread.m4",
        "status": "added",
        "additions": 485,
        "deletions": 0,
        "changes": 485,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_pthread.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/build-aux/m4/ax_pthread.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/build-aux/m4/ax_pthread.m4?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,485 @@\n+# ===========================================================================\n+#        http://www.gnu.org/software/autoconf-archive/ax_pthread.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])\n+#\n+# DESCRIPTION\n+#\n+#   This macro figures out how to build C programs using POSIX threads. It\n+#   sets the PTHREAD_LIBS output variable to the threads library and linker\n+#   flags, and the PTHREAD_CFLAGS output variable to any special C compiler\n+#   flags that are needed. (The user can also force certain compiler\n+#   flags/libs to be tested by setting these environment variables.)\n+#\n+#   Also sets PTHREAD_CC to any special C compiler that is needed for\n+#   multi-threaded programs (defaults to the value of CC otherwise). (This\n+#   is necessary on AIX to use the special cc_r compiler alias.)\n+#\n+#   NOTE: You are assumed to not only compile your program with these flags,\n+#   but also to link with them as well. For example, you might link with\n+#   $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS $LIBS\n+#\n+#   If you are only building threaded programs, you may wish to use these\n+#   variables in your default LIBS, CFLAGS, and CC:\n+#\n+#     LIBS=\"$PTHREAD_LIBS $LIBS\"\n+#     CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+#     CC=\"$PTHREAD_CC\"\n+#\n+#   In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute constant\n+#   has a nonstandard name, this macro defines PTHREAD_CREATE_JOINABLE to\n+#   that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).\n+#\n+#   Also HAVE_PTHREAD_PRIO_INHERIT is defined if pthread is found and the\n+#   PTHREAD_PRIO_INHERIT symbol is defined when compiling with\n+#   PTHREAD_CFLAGS.\n+#\n+#   ACTION-IF-FOUND is a list of shell commands to run if a threads library\n+#   is found, and ACTION-IF-NOT-FOUND is a list of commands to run it if it\n+#   is not found. If ACTION-IF-FOUND is not specified, the default action\n+#   will define HAVE_PTHREAD.\n+#\n+#   Please let the authors know if this macro fails on any platform, or if\n+#   you have any other suggestions or comments. This macro was based on work\n+#   by SGJ on autoconf scripts for FFTW (http://www.fftw.org/) (with help\n+#   from M. Frigo), as well as ac_pthread and hb_pthread macros posted by\n+#   Alejandro Forero Cuervo to the autoconf macro repository. We are also\n+#   grateful for the helpful feedback of numerous users.\n+#\n+#   Updated for Autoconf 2.68 by Daniel Richard G.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>\n+#   Copyright (c) 2011 Daniel Richard G. <skunk@iSKUNK.ORG>\n+#\n+#   This program is free software: you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published by the\n+#   Free Software Foundation, either version 3 of the License, or (at your\n+#   option) any later version.\n+#\n+#   This program is distributed in the hope that it will be useful, but\n+#   WITHOUT ANY WARRANTY; without even the implied warranty of\n+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+#   Public License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License along\n+#   with this program. If not, see <http://www.gnu.org/licenses/>.\n+#\n+#   As a special exception, the respective Autoconf Macro's copyright owner\n+#   gives unlimited permission to copy, distribute and modify the configure\n+#   scripts that are the output of Autoconf when processing the Macro. You\n+#   need not follow the terms of the GNU General Public License when using\n+#   or distributing such scripts, even though portions of the text of the\n+#   Macro appear in them. The GNU General Public License (GPL) does govern\n+#   all other use of the material that constitutes the Autoconf Macro.\n+#\n+#   This special exception to the GPL applies to versions of the Autoconf\n+#   Macro released by the Autoconf Archive. When you make and distribute a\n+#   modified version of the Autoconf Macro, you may extend this special\n+#   exception to the GPL to apply to your modified version as well.\n+\n+#serial 23\n+\n+AU_ALIAS([ACX_PTHREAD], [AX_PTHREAD])\n+AC_DEFUN([AX_PTHREAD], [\n+AC_REQUIRE([AC_CANONICAL_HOST])\n+AC_REQUIRE([AC_PROG_CC])\n+AC_REQUIRE([AC_PROG_SED])\n+AC_LANG_PUSH([C])\n+ax_pthread_ok=no\n+\n+# We used to check for pthread.h first, but this fails if pthread.h\n+# requires special compiler flags (e.g. on Tru64 or Sequent).\n+# It gets checked for in the link test anyway.\n+\n+# First of all, check if the user has set any of the PTHREAD_LIBS,\n+# etcetera environment variables, and if threads linking works using\n+# them:\n+if test \"x$PTHREAD_CFLAGS$PTHREAD_LIBS\" != \"x\"; then\n+        ax_pthread_save_CC=\"$CC\"\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        AS_IF([test \"x$PTHREAD_CC\" != \"x\"], [CC=\"$PTHREAD_CC\"])\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+        AC_MSG_CHECKING([for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS])\n+        AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_join])], [ax_pthread_ok=yes])\n+        AC_MSG_RESULT([$ax_pthread_ok])\n+        if test \"x$ax_pthread_ok\" = \"xno\"; then\n+                PTHREAD_LIBS=\"\"\n+                PTHREAD_CFLAGS=\"\"\n+        fi\n+        CC=\"$ax_pthread_save_CC\"\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+fi\n+\n+# We must check for the threads library under a number of different\n+# names; the ordering is very important because some systems\n+# (e.g. DEC) have both -lpthread and -lpthreads, where one of the\n+# libraries is broken (non-POSIX).\n+\n+# Create a list of thread flags to try.  Items starting with a \"-\" are\n+# C compiler flags, and other items are library names, except for \"none\"\n+# which indicates that we try without any flags at all, and \"pthread-config\"\n+# which is a program returning the flags for the Pth emulation library.\n+\n+ax_pthread_flags=\"pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config\"\n+\n+# The ordering *is* (sometimes) important.  Some notes on the\n+# individual items follow:\n+\n+# pthreads: AIX (must check this before -lpthread)\n+# none: in case threads are in libc; should be tried before -Kthread and\n+#       other compiler flags to prevent continual compiler warnings\n+# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)\n+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64\n+#           (Note: HP C rejects this with \"bad form for `-t' option\")\n+# -pthreads: Solaris/gcc (Note: HP C also rejects)\n+# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it\n+#      doesn't hurt to check since this sometimes defines pthreads and\n+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which\n+#      is present but should not be used directly; and before -mthreads,\n+#      because the compiler interprets this as \"-mt\" + \"-hreads\")\n+# -mthreads: Mingw32/gcc, Lynx/gcc\n+# pthread: Linux, etcetera\n+# --thread-safe: KAI C++\n+# pthread-config: use pthread-config program (for GNU Pth library)\n+\n+case $host_os in\n+\n+        freebsd*)\n+\n+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)\n+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)\n+\n+        ax_pthread_flags=\"-kthread lthread $ax_pthread_flags\"\n+        ;;\n+\n+        hpux*)\n+\n+        # From the cc(1) man page: \"[-mt] Sets various -D flags to enable\n+        # multi-threading and also sets -lpthread.\"\n+\n+        ax_pthread_flags=\"-mt -pthread pthread $ax_pthread_flags\"\n+        ;;\n+\n+        openedition*)\n+\n+        # IBM z/OS requires a feature-test macro to be defined in order to\n+        # enable POSIX threads at all, so give the user a hint if this is\n+        # not set. (We don't define these ourselves, as they can affect\n+        # other portions of the system API in unpredictable ways.)\n+\n+        AC_EGREP_CPP([AX_PTHREAD_ZOS_MISSING],\n+            [\n+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)\n+             AX_PTHREAD_ZOS_MISSING\n+#            endif\n+            ],\n+            [AC_MSG_WARN([IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support.])])\n+        ;;\n+\n+        solaris*)\n+\n+        # On Solaris (at least, for some versions), libc contains stubbed\n+        # (non-functional) versions of the pthreads routines, so link-based\n+        # tests will erroneously succeed. (N.B.: The stubs are missing\n+        # pthread_cleanup_push, or rather a function called by this macro,\n+        # so we could check for that, but who knows whether they'll stub\n+        # that too in a future libc.)  So we'll check first for the\n+        # standard Solaris way of linking pthreads (-mt -lpthread).\n+\n+        ax_pthread_flags=\"-mt,pthread pthread $ax_pthread_flags\"\n+        ;;\n+esac\n+\n+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)\n+\n+AS_IF([test \"x$GCC\" = \"xyes\"],\n+      [ax_pthread_flags=\"-pthread -pthreads $ax_pthread_flags\"])\n+\n+# The presence of a feature test macro requesting re-entrant function\n+# definitions is, on some systems, a strong hint that pthreads support is\n+# correctly enabled\n+\n+case $host_os in\n+        darwin* | hpux* | linux* | osf* | solaris*)\n+        ax_pthread_check_macro=\"_REENTRANT\"\n+        ;;\n+\n+        aix*)\n+        ax_pthread_check_macro=\"_THREAD_SAFE\"\n+        ;;\n+\n+        *)\n+        ax_pthread_check_macro=\"--\"\n+        ;;\n+esac\n+AS_IF([test \"x$ax_pthread_check_macro\" = \"x--\"],\n+      [ax_pthread_check_cond=0],\n+      [ax_pthread_check_cond=\"!defined($ax_pthread_check_macro)\"])\n+\n+# Are we compiling with Clang?\n+\n+AC_CACHE_CHECK([whether $CC is Clang],\n+    [ax_cv_PTHREAD_CLANG],\n+    [ax_cv_PTHREAD_CLANG=no\n+     # Note that Autoconf sets GCC=yes for Clang as well as GCC\n+     if test \"x$GCC\" = \"xyes\"; then\n+        AC_EGREP_CPP([AX_PTHREAD_CC_IS_CLANG],\n+            [/* Note: Clang 2.7 lacks __clang_[a-z]+__ */\n+#            if defined(__clang__) && defined(__llvm__)\n+             AX_PTHREAD_CC_IS_CLANG\n+#            endif\n+            ],\n+            [ax_cv_PTHREAD_CLANG=yes])\n+     fi\n+    ])\n+ax_pthread_clang=\"$ax_cv_PTHREAD_CLANG\"\n+\n+ax_pthread_clang_warning=no\n+\n+# Clang needs special handling, because older versions handle the -pthread\n+# option in a rather... idiosyncratic way\n+\n+if test \"x$ax_pthread_clang\" = \"xyes\"; then\n+\n+        # Clang takes -pthread; it has never supported any other flag\n+\n+        # (Note 1: This will need to be revisited if a system that Clang\n+        # supports has POSIX threads in a separate library.  This tends not\n+        # to be the way of modern systems, but it's conceivable.)\n+\n+        # (Note 2: On some systems, notably Darwin, -pthread is not needed\n+        # to get POSIX threads support; the API is always present and\n+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But\n+        # -pthread does define _REENTRANT, and while the Darwin headers\n+        # ignore this macro, third-party headers might not.)\n+\n+        PTHREAD_CFLAGS=\"-pthread\"\n+        PTHREAD_LIBS=\n+\n+        ax_pthread_ok=yes\n+\n+        # However, older versions of Clang make a point of warning the user\n+        # that, in an invocation where only linking and no compilation is\n+        # taking place, the -pthread option has no effect (\"argument unused\n+        # during compilation\").  They expect -pthread to be passed in only\n+        # when source code is being compiled.\n+        #\n+        # Problem is, this is at odds with the way Automake and most other\n+        # C build frameworks function, which is that the same flags used in\n+        # compilation (CFLAGS) are also used in linking.  Many systems\n+        # supported by AX_PTHREAD require exactly this for POSIX threads\n+        # support, and in fact it is often not straightforward to specify a\n+        # flag that is used only in the compilation phase and not in\n+        # linking.  Such a scenario is extremely rare in practice.\n+        #\n+        # Even though use of the -pthread flag in linking would only print\n+        # a warning, this can be a nuisance for well-run software projects\n+        # that build with -Werror.  So if the active version of Clang has\n+        # this misfeature, we search for an option to squash it.\n+\n+        AC_CACHE_CHECK([whether Clang needs flag to prevent \"argument unused\" warning when linking with -pthread],\n+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG],\n+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown\n+             # Create an alternate version of $ac_link that compiles and\n+             # links in two steps (.c -> .o, .o -> exe) instead of one\n+             # (.c -> exe), because the warning occurs only in the second\n+             # step\n+             ax_pthread_save_ac_link=\"$ac_link\"\n+             ax_pthread_sed='s/conftest\\.\\$ac_ext/conftest.$ac_objext/g'\n+             ax_pthread_link_step=`$as_echo \"$ac_link\" | sed \"$ax_pthread_sed\"`\n+             ax_pthread_2step_ac_link=\"($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)\"\n+             ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do\n+                AS_IF([test \"x$ax_pthread_try\" = \"xunknown\"], [break])\n+                CFLAGS=\"-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS\"\n+                ac_link=\"$ax_pthread_save_ac_link\"\n+                AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],\n+                    [ac_link=\"$ax_pthread_2step_ac_link\"\n+                     AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],\n+                         [break])\n+                    ])\n+             done\n+             ac_link=\"$ax_pthread_save_ac_link\"\n+             CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+             AS_IF([test \"x$ax_pthread_try\" = \"x\"], [ax_pthread_try=no])\n+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=\"$ax_pthread_try\"\n+            ])\n+\n+        case \"$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG\" in\n+                no | unknown) ;;\n+                *) PTHREAD_CFLAGS=\"$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS\" ;;\n+        esac\n+\n+fi # $ax_pthread_clang = yes\n+\n+if test \"x$ax_pthread_ok\" = \"xno\"; then\n+for ax_pthread_try_flag in $ax_pthread_flags; do\n+\n+        case $ax_pthread_try_flag in\n+                none)\n+                AC_MSG_CHECKING([whether pthreads work without any flags])\n+                ;;\n+\n+                -mt,pthread)\n+                AC_MSG_CHECKING([whether pthreads work with -mt -lpthread])\n+                PTHREAD_CFLAGS=\"-mt\"\n+                PTHREAD_LIBS=\"-lpthread\"\n+                ;;\n+\n+                -*)\n+                AC_MSG_CHECKING([whether pthreads work with $ax_pthread_try_flag])\n+                PTHREAD_CFLAGS=\"$ax_pthread_try_flag\"\n+                ;;\n+\n+                pthread-config)\n+                AC_CHECK_PROG([ax_pthread_config], [pthread-config], [yes], [no])\n+                AS_IF([test \"x$ax_pthread_config\" = \"xno\"], [continue])\n+                PTHREAD_CFLAGS=\"`pthread-config --cflags`\"\n+                PTHREAD_LIBS=\"`pthread-config --ldflags` `pthread-config --libs`\"\n+                ;;\n+\n+                *)\n+                AC_MSG_CHECKING([for the pthreads library -l$ax_pthread_try_flag])\n+                PTHREAD_LIBS=\"-l$ax_pthread_try_flag\"\n+                ;;\n+        esac\n+\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+\n+        # Check for various functions.  We must include pthread.h,\n+        # since some functions may be macros.  (On the Sequent, we\n+        # need a special flag -Kthread to make this header compile.)\n+        # We check for pthread_join because it is in -lpthread on IRIX\n+        # while pthread_create is in libc.  We check for pthread_attr_init\n+        # due to DEC craziness with -lpthreads.  We check for\n+        # pthread_cleanup_push because it is one of the few pthread\n+        # functions on Solaris that doesn't have a non-functional libc stub.\n+        # We try pthread_create on general principles.\n+\n+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>\n+#                       if $ax_pthread_check_cond\n+#                        error \"$ax_pthread_check_macro must be defined\"\n+#                       endif\n+                        static void routine(void *a) { a = 0; }\n+                        static void *start_routine(void *a) { return a; }],\n+                       [pthread_t th; pthread_attr_t attr;\n+                        pthread_create(&th, 0, start_routine, 0);\n+                        pthread_join(th, 0);\n+                        pthread_attr_init(&attr);\n+                        pthread_cleanup_push(routine, 0);\n+                        pthread_cleanup_pop(0) /* ; */])],\n+            [ax_pthread_ok=yes],\n+            [])\n+\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+\n+        AC_MSG_RESULT([$ax_pthread_ok])\n+        AS_IF([test \"x$ax_pthread_ok\" = \"xyes\"], [break])\n+\n+        PTHREAD_LIBS=\"\"\n+        PTHREAD_CFLAGS=\"\"\n+done\n+fi\n+\n+# Various other checks:\n+if test \"x$ax_pthread_ok\" = \"xyes\"; then\n+        ax_pthread_save_CFLAGS=\"$CFLAGS\"\n+        ax_pthread_save_LIBS=\"$LIBS\"\n+        CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+        LIBS=\"$PTHREAD_LIBS $LIBS\"\n+\n+        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.\n+        AC_CACHE_CHECK([for joinable pthread attribute],\n+            [ax_cv_PTHREAD_JOINABLE_ATTR],\n+            [ax_cv_PTHREAD_JOINABLE_ATTR=unknown\n+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do\n+                 AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],\n+                                                 [int attr = $ax_pthread_attr; return attr /* ; */])],\n+                                [ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break],\n+                                [])\n+             done\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_JOINABLE_ATTR\" != \"xunknown\" && \\\n+               test \"x$ax_cv_PTHREAD_JOINABLE_ATTR\" != \"xPTHREAD_CREATE_JOINABLE\" && \\\n+               test \"x$ax_pthread_joinable_attr_defined\" != \"xyes\"],\n+              [AC_DEFINE_UNQUOTED([PTHREAD_CREATE_JOINABLE],\n+                                  [$ax_cv_PTHREAD_JOINABLE_ATTR],\n+                                  [Define to necessary symbol if this constant\n+                                   uses a non-standard name on your system.])\n+               ax_pthread_joinable_attr_defined=yes\n+              ])\n+\n+        AC_CACHE_CHECK([whether more special flags are required for pthreads],\n+            [ax_cv_PTHREAD_SPECIAL_FLAGS],\n+            [ax_cv_PTHREAD_SPECIAL_FLAGS=no\n+             case $host_os in\n+             solaris*)\n+             ax_cv_PTHREAD_SPECIAL_FLAGS=\"-D_POSIX_PTHREAD_SEMANTICS\"\n+             ;;\n+             esac\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_SPECIAL_FLAGS\" != \"xno\" && \\\n+               test \"x$ax_pthread_special_flags_added\" != \"xyes\"],\n+              [PTHREAD_CFLAGS=\"$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS\"\n+               ax_pthread_special_flags_added=yes])\n+\n+        AC_CACHE_CHECK([for PTHREAD_PRIO_INHERIT],\n+            [ax_cv_PTHREAD_PRIO_INHERIT],\n+            [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <pthread.h>]],\n+                                             [[int i = PTHREAD_PRIO_INHERIT;]])],\n+                            [ax_cv_PTHREAD_PRIO_INHERIT=yes],\n+                            [ax_cv_PTHREAD_PRIO_INHERIT=no])\n+            ])\n+        AS_IF([test \"x$ax_cv_PTHREAD_PRIO_INHERIT\" = \"xyes\" && \\\n+               test \"x$ax_pthread_prio_inherit_defined\" != \"xyes\"],\n+              [AC_DEFINE([HAVE_PTHREAD_PRIO_INHERIT], [1], [Have PTHREAD_PRIO_INHERIT.])\n+               ax_pthread_prio_inherit_defined=yes\n+              ])\n+\n+        CFLAGS=\"$ax_pthread_save_CFLAGS\"\n+        LIBS=\"$ax_pthread_save_LIBS\"\n+\n+        # More AIX lossage: compile with *_r variant\n+        if test \"x$GCC\" != \"xyes\"; then\n+            case $host_os in\n+                aix*)\n+                AS_CASE([\"x/$CC\"],\n+                    [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],\n+                    [#handle absolute path differently from PATH based program lookup\n+                     AS_CASE([\"x$CC\"],\n+                         [x/*],\n+                         [AS_IF([AS_EXECUTABLE_P([${CC}_r])],[PTHREAD_CC=\"${CC}_r\"])],\n+                         [AC_CHECK_PROGS([PTHREAD_CC],[${CC}_r],[$CC])])])\n+                ;;\n+            esac\n+        fi\n+fi\n+\n+test -n \"$PTHREAD_CC\" || PTHREAD_CC=\"$CC\"\n+\n+AC_SUBST([PTHREAD_LIBS])\n+AC_SUBST([PTHREAD_CFLAGS])\n+AC_SUBST([PTHREAD_CC])\n+\n+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:\n+if test \"x$ax_pthread_ok\" = \"xyes\"; then\n+        ifelse([$1],,[AC_DEFINE([HAVE_PTHREAD],[1],[Define if you have POSIX threads libraries and header files.])],[$1])\n+        :\n+else\n+        ax_pthread_ok=no\n+        $2\n+fi\n+AC_LANG_POP\n+])dnl AX_PTHREAD"
      },
      {
        "sha": "71bda3d8f0befb08cda53f2a5bf531810ac09cd9",
        "filename": "src/minisketch/configure.ac",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/configure.ac?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,102 @@\n+AC_INIT([minisketch], [0.0.1], [http://github.com/sipa/minisketch/])\n+\n+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n+\n+AC_PREREQ(2.60)\n+AC_CONFIG_SRCDIR([src/minisketch.cpp])\n+AC_CONFIG_AUX_DIR([build-aux])\n+AC_CONFIG_MACRO_DIR([build-aux/m4])\n+AM_INIT_AUTOMAKE([subdir-objects foreign])\n+\n+LT_INIT\n+LT_LANG([C++])\n+AC_LANG([C++])\n+\n+AC_PATH_PROG(CCACHE,ccache)\n+\n+AC_ARG_ENABLE([ccache],\n+  [AS_HELP_STRING([--disable-ccache],\n+  [do not use ccache for building (default is to use if found)])],\n+  [use_ccache=$enableval],\n+  [use_ccache=auto])\n+\n+AC_ARG_ENABLE(tests,\n+    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    [use_tests=$enableval],\n+    [use_tests=yes])\n+\n+AC_ARG_ENABLE(benchmark,\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is no)]),\n+    [use_benchmark=$enableval],\n+    [use_benchmark=no])\n+\n+dnl Check for pthread compile/link requirements\n+AX_PTHREAD\n+\n+AX_CHECK_COMPILE_FLAG([-Werror],[CXXFLAG_WERROR=\"-Werror\"],[CXXFLAG_WERROR=\"\"])\n+\n+AX_CXX_COMPILE_STDCXX([11], [noext], [mandatory], [nodefault])\n+enable_clmul=\n+AX_CHECK_COMPILE_FLAG([-mpclmul],[[enable_clmul=yes]],,[[$CXXFLAG_WERROR]])\n+if test x$enable_clmul = xyes; then\n+  CLMUL_CXXFLAGS=\"-mpclmul\"\n+  AC_DEFINE(HAVE_CLMUL, 1, [Define this symbol if clmul instructions can be used])\n+fi\n+\n+\n+AC_MSG_CHECKING(for working clz builtins)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [\n+  unsigned a = __builtin_clz(1);\n+  unsigned long b = __builtin_clzl(1);\n+  unsigned long long c = __builtin_clzll(1);\n+  ])],\n+  [\n+    AC_DEFINE(HAVE_CLZ, 1, [Define this symbol if clz builtins are present and working])\n+    AC_MSG_RESULT(yes)\n+  ],[\n+    AC_MSG_RESULT(no)\n+  ]\n+)\n+\n+AX_CHECK_COMPILE_FLAG([-Wall],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wall\"],,[[$CXXFLAG_WERROR]])\n+## Some compilers (gcc) ignore unknown -Wno-* options, but warn about all\n+## unknown options if any other warning is produced. Test the -Wfoo case, and\n+## set the -Wno-foo case if it works.\n+AX_CHECK_COMPILE_FLAG([-Wshift-count-overflow],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-shift-count-overflow\"],,[[$CXXFLAG_WERROR]])\n+\n+if test \"x$use_ccache\" != \"xno\"; then\n+  AC_MSG_CHECKING(if ccache should be used)\n+  if test x$CCACHE = x; then\n+    if test \"x$use_ccache\" = \"xyes\"; then\n+      AC_MSG_ERROR([ccache not found.]);\n+    else\n+      use_ccache=no\n+    fi\n+  else\n+    use_ccache=yes\n+    CC=\"$ac_cv_path_CCACHE $CC\"\n+    CXX=\"$ac_cv_path_CCACHE $CXX\"\n+  fi\n+  AC_MSG_RESULT($use_ccache)\n+fi\n+if test \"x$use_ccache\" = \"xyes\"; then\n+    AX_CHECK_COMPILE_FLAG([-Qunused-arguments],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Qunused-arguments\"],,[[$CXXFLAG_WERROR]])\n+fi\n+\n+VERIFY_DEFINES=-DMINISKETCH_VERIFY\n+RELEASE_DEFINES=\n+\n+AC_CONFIG_FILES([\n+    Makefile\n+])\n+\n+AC_SUBST(CLMUL_CXXFLAGS)\n+AC_SUBST(WARN_CXXFLAGS)\n+AC_SUBST(NOWARN_CXXFLAGS)\n+AC_SUBST(VERIFY_DEFINES)\n+AC_SUBST(RELEASE_DEFINES)\n+AM_CONDITIONAL([ENABLE_CLMUL],[test x$enable_clmul = xyes])\n+AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n+AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AC_OUTPUT\n+"
      },
      {
        "sha": "7279165845efc230d9781cecf99107231722ffbc",
        "filename": "src/minisketch/doc/example.c",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/example.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/example.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/example.c?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,51 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"../include/minisketch.h\"\n+\n+int main(void) {\n+\n+  minisketch *sketch_a = minisketch_create(12, 0, 4);\n+\n+  for (int i = 3000; i < 3010; ++i) {\n+    minisketch_add_uint64(sketch_a, i);\n+  }\n+\n+  size_t sersize = minisketch_serialized_size(sketch_a);\n+  assert(sersize == 12 * 4 / 8); // 4 12-bit values is 6 bytes.\n+  unsigned char *buffer_a = malloc(sersize);\n+  minisketch_serialize(sketch_a, buffer_a);\n+  minisketch_destroy(sketch_a);\n+\n+  minisketch *sketch_b = minisketch_create(12, 0, 4); // Bob's own sketch\n+  for (int i = 3002; i < 3012; ++i) {\n+    minisketch_add_uint64(sketch_b, i);\n+  }\n+\n+  sketch_a = minisketch_create(12, 0, 4);     // Alice's sketch\n+  minisketch_deserialize(sketch_a, buffer_a); // Load Alice's sketch\n+  free(buffer_a);\n+\n+  // Merge the elements from sketch_a into sketch_b. The result is a sketch_b\n+  // which contains all elements that occurred in Alice's or Bob's sets, but not\n+  // in both.\n+  minisketch_merge(sketch_b, sketch_a);\n+\n+  uint64_t differences[4];\n+  ssize_t num_differences = minisketch_decode(sketch_b, 4, differences);\n+  minisketch_destroy(sketch_a);\n+  minisketch_destroy(sketch_b);\n+  if (num_differences < 0) {\n+    printf(\"More than 4 differences!\\n\");\n+  } else {\n+    ssize_t i;\n+    for (i = 0; i < num_differences; ++i) {\n+      printf(\"%u is in only one of the two sets\\n\", (unsigned)differences[i]);\n+    }\n+  }\n+}"
      },
      {
        "sha": "d1e75a6e2912ed2f1989d96e4c5922a42c16bb74",
        "filename": "src/minisketch/doc/gen_basefpbits.sage",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/gen_basefpbits.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/gen_basefpbits.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/gen_basefpbits.sage?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,78 @@\n+# Require exact values up to\n+FPBITS = 256\n+\n+# Overkill accuracy\n+F = RealField(400)\n+\n+def BaseFPBits(bits, capacity):\n+    return bits * capacity - int(ceil(F(log(sum(binomial(2**bits - 1, i) for i in range(capacity+1)), 2))))\n+\n+def Log2Factorial(capacity):\n+    return int(floor(log(factorial(capacity), 2)))\n+\n+print(\"uint64_t BaseFPBits(uint32_t bits, uint32_t capacity) {\")\n+print(\"    // Correction table for low bits/capacities\")\n+TBLS={}\n+FARS={}\n+SKIPS={}\n+for bits in range(1, 32):\n+    TBL = []\n+    for capacity in range(1, min(2**bits, FPBITS)):\n+        exact = BaseFPBits(bits, capacity)\n+        approx = Log2Factorial(capacity)\n+        TBL.append((exact, approx))\n+    MIN = 10000000000\n+    while len(TBL) and ((TBL[-1][0] == TBL[-1][1]) or (TBL[-1][0] >= FPBITS and TBL[-1][1] >= FPBITS)):\n+        MIN = min(MIN, TBL[-1][0] - TBL[-1][1])\n+        TBL.pop()\n+    while len(TBL) and (TBL[-1][0] - TBL[-1][1] == MIN):\n+        TBL.pop()\n+    SKIP = 0\n+    while SKIP < len(TBL) and TBL[SKIP][0] == TBL[SKIP][1]:\n+        SKIP += 1\n+    DIFFS = [TBL[i][0] - TBL[i][1] for i in range(SKIP, len(TBL))]\n+    if len(DIFFS) > 0 and len(DIFFS) * Integer(max(DIFFS)).nbits() > 64:\n+        print(\"    static constexpr uint8_t ADD%i[] = {%s};\" % (bits, \", \".join((\"%i\" % (TBL[i][0] - TBL[i][1])) for i in range(SKIP, len(TBL)))))\n+    TBLS[bits] = DIFFS\n+    FARS[bits] = MIN\n+    SKIPS[bits] = SKIP\n+print(\"\")\n+print(\"    if (capacity == 0) return 0;\")\n+print(\"    uint64_t ret = 0;\")\n+print(\"    if (bits < 32 && capacity >= (1U << bits)) {\")\n+print(\"        ret = uint64_t{bits} * (capacity - (1U << bits) + 1);\")\n+print(\"        capacity = (1U << bits) - 1;\")\n+print(\"    }\")\n+print(\"    ret += Log2Factorial(capacity);\")\n+print(\"    switch (bits) {\")\n+for bits in sorted(TBLS.keys()):\n+    if len(TBLS[bits]) == 0:\n+        continue\n+    width = Integer(max(TBLS[bits])).nbits()\n+    if len(TBLS[bits]) == 1:\n+        add = \"%i\" % TBLS[bits][0]\n+    elif len(TBLS[bits]) * width <= 64:\n+        code = sum((2**(width*i) * TBLS[bits][i]) for i in range(len(TBLS[bits])))\n+        if width == 1:\n+            add = \"(0x%x >> (capacity - %i)) & 1\" % (code, 1 + SKIPS[bits])\n+        else:\n+            add = \"(0x%x >> %i * (capacity - %i)) & %i\" % (code, width, 1 + SKIPS[bits], 2**width - 1)\n+    else:\n+        add = \"ADD%i[capacity - %i]\" % (bits, 1 + SKIPS[bits])\n+    if len(TBLS[bits]) + SKIPS[bits] == 2**bits - 1:\n+        print(\"        case %i: return ret + (capacity <= %i ? 0 : %s);\" % (bits, SKIPS[bits], add))\n+    else:\n+        print(\"        case %i: return ret + (capacity <= %i ? 0 : capacity > %i ? %i : %s);\" % (bits, SKIPS[bits], len(TBLS[bits]) + SKIPS[bits], FARS[bits], add))\n+print(\"        default: return ret;\")\n+print(\"    }\")\n+print(\"}\")\n+\n+print(\"void TestBaseFPBits() {\")\n+print(\"    static constexpr uint16_t TBL[20][100] = {%s};\" % (\", \".join(\"{\" + \", \".join((\"%i\" % BaseFPBits(bits, capacity)) for capacity in range(0, 100)) + \"}\" for bits in range(1, 21))))\n+print(\"    for (int bits = 1; bits <= 20; ++bits) {\")\n+print(\"        for (int capacity = 0; capacity < 100; ++capacity) {\")\n+print(\"        uint64_t computed = BaseFPBits(bits, capacity), exact = TBL[bits - 1][capacity];\")\n+print(\"            CHECK(exact == computed || (exact >= 256 && computed >= 256));\")\n+print(\"        }\")\n+print(\"    }\")\n+print(\"}\")"
      },
      {
        "sha": "afab49778bc4245356bd0a61f4bf89062e7336f0",
        "filename": "src/minisketch/doc/gen_params.sage",
        "status": "added",
        "additions": 326,
        "deletions": 0,
        "changes": 326,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/gen_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/gen_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/gen_params.sage?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,326 @@\n+#!/usr/bin/env sage\n+r\"\"\"\n+Generate finite field parameters for minisketch.\n+\n+This script selects the finite fields used by minisketch\n+ for various sizes and generates the required tables for\n+ the implementation.\n+\n+The output (after formatting) can be found in src/fields/*.cpp.\n+\n+\"\"\"\n+B.<b> = GF(2)\n+P.<p> = B[]\n+\n+def apply_map(m, v):\n+    r = 0\n+    i = 0\n+    while v != 0:\n+        if (v & 1):\n+            r ^^= m[i]\n+        i += 1\n+        v >>= 1\n+    return r\n+\n+def recurse_moduli(acc, maxweight, maxdegree):\n+    for pos in range(maxweight, maxdegree + 1, 1):\n+        poly = acc + p^pos\n+        if maxweight == 1:\n+            if poly.is_irreducible():\n+                return (pos, poly)\n+        else:\n+            (deg, ret) = recurse_moduli(poly, maxweight - 1, pos - 1)\n+            if ret is not None:\n+                return (pos, ret)\n+    return (None, None)\n+\n+def compute_moduli(bits):\n+    # Return all optimal irreducible polynomials for GF(2^bits)\n+    # The result is a list of tuples (weight, degree of second-highest nonzero coefficient, polynomial)\n+    maxdegree = bits - 1\n+    result = []\n+    for weight in range(1, bits, 2):\n+        deg, res = None, None\n+        while True:\n+            ret = recurse_moduli(p^bits + 1, weight, maxdegree)\n+            if ret[0] is not None:\n+                (deg, res) = ret\n+                maxdegree = deg - 1\n+            else:\n+                break\n+        if res is not None:\n+            result.append((weight + 2, deg, res))\n+    return result\n+\n+def bits_to_int(vals):\n+    ret = 0\n+    base = 1\n+    for val in vals:\n+        ret += Integer(val) * base\n+        base *= 2\n+    return ret\n+\n+def sqr_table(f, bits, n=1):\n+    ret = []\n+    for i in range(bits):\n+        ret.append((f^(2^n*i)).integer_representation())\n+    return ret\n+\n+# Compute x**(2**n)\n+def pow2(x, n):\n+    for i in range(n):\n+        x = x**2\n+    return x\n+\n+def qrt_table(F, f, bits):\n+    # Table for solving x2 + x = a\n+    # This implements the technique from https://www.raco.cat/index.php/PublicacionsMatematiques/article/viewFile/37927/40412, Lemma 1\n+    for i in range(bits):\n+        if (f**i).trace() != 0:\n+            u = f**i\n+    ret = []\n+    for i in range(0, bits):\n+        d = f^i\n+        y = sum(pow2(d, j) * sum(pow2(u, k) for k in range(j)) for j in range(1, bits))\n+        ret.append(y.integer_representation() ^^ (y.integer_representation() & 1))\n+    return ret\n+\n+def conv_tables(F, NF, bits):\n+    # Generate a F(2) linear projection that maps elements from one field\n+    #  to an isomorphic field with a different modulus.\n+    f = F.gen()\n+    fp = f.minimal_polynomial()\n+    assert(fp == F.modulus())\n+    nfp = fp.change_ring(NF)\n+    nf = sorted(nfp.roots(multiplicities=False))[0]\n+    ret = []\n+    matrepr = [[B(0) for x in range(bits)] for y in range(bits)]\n+    for i in range(bits):\n+        val = (nf**i).integer_representation()\n+        ret.append(val)\n+        for j in range(bits):\n+            matrepr[j][i] = B((val >> j) & 1)\n+    mat = Matrix(matrepr).inverse().transpose()\n+    ret2 = []\n+    for i in range(bits):\n+        ret2.append(bits_to_int(mat[i]))\n+\n+    for t in range(100):\n+        f1a = F.random_element()\n+        f1b = F.random_element()\n+        f1r = f1a * f1b\n+        f2a = NF.fetch_int(apply_map(ret, f1a.integer_representation()))\n+        f2b = NF.fetch_int(apply_map(ret, f1b.integer_representation()))\n+        f2r = NF.fetch_int(apply_map(ret, f1r.integer_representation()))\n+        f2s = f2a * f2b\n+        assert(f2r == f2s)\n+\n+    for t in range(100):\n+        f2a = NF.random_element()\n+        f2b = NF.random_element()\n+        f2r = f2a * f2b\n+        f1a = F.fetch_int(apply_map(ret2, f2a.integer_representation()))\n+        f1b = F.fetch_int(apply_map(ret2, f2b.integer_representation()))\n+        f1r = F.fetch_int(apply_map(ret2, f2r.integer_representation()))\n+        f1s = f1a * f1b\n+        assert(f1r == f1s)\n+\n+    return (ret, ret2)\n+\n+def fmt(i,typ):\n+    if i == 0:\n+        return \"0\"\n+    else:\n+        return \"0x%x\" % i\n+\n+def lintranstype(typ, bits, maxtbl):\n+    gsize = min(maxtbl, bits)\n+    array_size = (bits + gsize - 1) // gsize\n+    bits_list = []\n+    total = 0\n+    for i in range(array_size):\n+        rsize = (bits - total + array_size - i - 1) // (array_size - i)\n+        total += rsize\n+        bits_list.append(rsize)\n+    return \"RecLinTrans<%s, %s>\" % (typ, \", \".join(\"%i\" % x for x in bits_list))\n+\n+INT=0\n+CLMUL=1\n+CLMUL_TRI=2\n+MD=3\n+\n+def print_modulus_md(mod):\n+    ret = \"\"\n+    pos = mod.degree()\n+    for c in reversed(list(mod)):\n+        if c:\n+            if ret:\n+                ret += \" + \"\n+            if pos == 0:\n+                ret += \"1\"\n+            elif pos == 1:\n+                ret += \"x\"\n+            else:\n+                ret += \"x<sup>%i</sup>\" % pos\n+        pos -= 1\n+    return ret\n+\n+def pick_modulus(bits, style):\n+    # Choose the lexicographicly-first lowest-weight modulus\n+    #  optionally subject to implementation specific constraints.\n+    moduli = compute_moduli(bits)\n+    if style == INT or style == MD:\n+        multi_sqr = False\n+        need_trans = False\n+    elif style == CLMUL:\n+        # Fast CLMUL reduction requires that bits + the highest\n+        #  set bit are less than 66.\n+        moduli = filter(lambda x: bits+x[1] <= 66, moduli) + moduli\n+        multi_sqr = True\n+        need_trans = True\n+        if not moduli or moduli[0][2].change_ring(ZZ)(2) == 3 + 2**bits:\n+            # For modulus 3, CLMUL_TRI is obviously better.\n+            return None\n+    elif style == CLMUL_TRI:\n+        moduli = filter(lambda x: bits+x[1] <= 66, moduli) + moduli\n+        moduli = filter(lambda x: x[0] == 3, moduli)\n+        multi_sqr = True\n+        need_trans = True\n+    else:\n+        assert(False)\n+    if not moduli:\n+        return None\n+    return moduli[0][2]\n+\n+def print_result(bits, style):\n+    if style == INT:\n+        multi_sqr = False\n+        need_trans = False\n+        table_id = \"%i\" % bits\n+    elif style == MD:\n+        pass\n+    elif style == CLMUL:\n+        multi_sqr = True\n+        need_trans = True\n+        table_id = \"%i\" % bits\n+    elif style == CLMUL_TRI:\n+        multi_sqr = True\n+        need_trans = True\n+        table_id = \"TRI%i\" % bits\n+    else:\n+        assert(False)\n+\n+    nmodulus = pick_modulus(bits, INT)\n+    modulus = pick_modulus(bits, style)\n+    if modulus is None:\n+        return\n+\n+    if style == MD:\n+        print(\"* *%s*\" % print_modulus_md(modulus))\n+        return\n+\n+    if bits > 32:\n+        typ = \"uint64_t\"\n+    elif bits > 16:\n+        typ = \"uint32_t\"\n+    elif bits > 8:\n+        typ = \"uint16_t\"\n+    else:\n+        typ = \"uint8_t\"\n+\n+    ttyp = lintranstype(typ, bits, 4)\n+    rtyp = lintranstype(typ, bits, 6)\n+\n+    F.<f> = GF(2**bits, modulus=modulus)\n+\n+    include_table = True\n+    if style != INT and style != CLMUL:\n+        cmodulus = pick_modulus(bits, CLMUL)\n+        if cmodulus == modulus:\n+            include_table = False\n+            table_id = \"%i\" % bits\n+\n+    if include_table:\n+        print(\"typedef %s StatTable%s;\" % (rtyp, table_id))\n+        rtyp = \"StatTable%s\" % table_id\n+        if (style == INT):\n+            print(\"typedef %s DynTable%s;\" % (ttyp, table_id))\n+            ttyp = \"DynTable%s\" % table_id\n+\n+    if need_trans:\n+        if modulus != nmodulus:\n+            # If the bitstream modulus is not the best modulus for\n+            #  this implementation a conversion table will be needed.\n+            ctyp = rtyp\n+            NF.<nf> = GF(2**bits, modulus=nmodulus)\n+            ctables = conv_tables(NF, F, bits)\n+            loadtbl = \"&LOAD_TABLE_%s\" % table_id\n+            savetbl = \"&SAVE_TABLE_%s\" % table_id\n+            if include_table:\n+                print(\"constexpr %s LOAD_TABLE_%s({%s});\" % (ctyp, table_id, \", \".join([fmt(x,typ) for x in ctables[0]])))\n+                print(\"constexpr %s SAVE_TABLE_%s({%s});\" % (ctyp, table_id, \", \".join([fmt(x,typ) for x in ctables[1]])))\n+        else:\n+            ctyp = \"IdTrans\"\n+            loadtbl = \"&ID_TRANS\"\n+            savetbl = \"&ID_TRANS\"\n+    else:\n+        assert(modulus == nmodulus)\n+\n+    if include_table:\n+        print(\"constexpr %s SQR_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 1)])))\n+    if multi_sqr:\n+        # Repeated squaring is a linearised polynomial so in F(2^n) it is\n+        #  F(2) linear and can be computed by a simple bit-matrix.\n+        # Repeated squaring is especially useful in powering ladders such as\n+        #  for inversion.\n+        sqr2 = \"nullptr\"\n+        sqr4 = \"nullptr\"\n+        sqr8 = \"nullptr\"\n+        sqr16 = \"nullptr\"\n+        if ((bits - 1) >= 4):\n+            if include_table:\n+                print(\"constexpr %s SQR2_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 2)])))\n+            sqr2 = \"&SQR2_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 8):\n+            if include_table:\n+                print(\"constexpr %s SQR4_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 4)])))\n+            sqr4 = \"&SQR4_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 16):\n+            if include_table:\n+                print(\"constexpr %s SQR8_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 8)])))\n+            sqr8 = \"&SQR8_TABLE_%s\" % table_id\n+        if ((bits - 1) >= 32):\n+            if include_table:\n+                print(\"constexpr %s SQR16_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in sqr_table(f, bits, 16)])))\n+            sqr16 = \"&SQR16_TABLE_%s\" % table_id\n+    if include_table:\n+        print(\"constexpr %s QRT_TABLE_%s({%s});\" % (rtyp, table_id, \", \".join([fmt(x,typ) for x in qrt_table(F, f, bits)])))\n+\n+    modulus_weight = modulus.hamming_weight()\n+    modulus_degree = (modulus - p**bits).degree()\n+    modulus_int = (modulus - p**bits).change_ring(ZZ)(2)\n+\n+    lfsr = \"\"\n+\n+    if style == INT:\n+        print(\"typedef Field<%s, %i, %i, %s, %s, &SQR_TABLE_%s, &QRT_TABLE_%s%s> Field%i;\" % (typ, bits, modulus_int, rtyp, ttyp, table_id, table_id, lfsr, bits))\n+    elif style == CLMUL:\n+        print(\"typedef Field<%s, %i, %i, %s, &SQR_TABLE_%s, %s, %s, %s, %s, &QRT_TABLE_%s, %s, %s, %s%s> Field%i;\" % (typ, bits, modulus_int, rtyp, table_id, sqr2, sqr4, sqr8, sqr16, table_id, ctyp, loadtbl, savetbl, lfsr, bits))\n+    elif style == CLMUL_TRI:\n+        print(\"typedef FieldTri<%s, %i, %i, %s, &SQR_TABLE_%s, %s, %s, %s, %s, &QRT_TABLE_%s, %s, %s, %s> FieldTri%i;\" % (typ, bits, modulus_degree, rtyp, table_id, sqr2, sqr4, sqr8, sqr16, table_id, ctyp, loadtbl, savetbl, bits))\n+    else:\n+        assert(False)\n+\n+for bits in range(2, 65):\n+    print(\"// %i bit field\" % bits)\n+    print_result(bits, INT)\n+    print(\"\")\n+\n+for bits in range(2, 65):\n+    print(\"// %i bit field\" % bits)\n+    print_result(bits, CLMUL)\n+    print_result(bits, CLMUL_TRI)\n+    print(\"\")\n+\n+for bits in range(2, 65):\n+    print_result(bits, MD)"
      },
      {
        "sha": "afc6d66c57b68323d189546f407b55b4a25f6a83",
        "filename": "src/minisketch/doc/log2_factorial.sage",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/log2_factorial.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/log2_factorial.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/log2_factorial.sage?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,85 @@\n+import bisect\n+\n+INPUT_BITS = 32\n+TABLE_BITS = 5\n+INT_BITS = 64\n+EXACT_FPBITS = 256\n+\n+F = RealField(100) # overkill\n+\n+def BestOverApproxInvLog2(mulof, maxd):\n+    \"\"\"\n+    Compute denominator of an approximation of 1/log(2).\n+\n+    Specifically, find the value of d (<= maxd, and a multiple of mulof)\n+    such that ceil(d/log(2))/d is the best approximation of 1/log(2).\n+    \"\"\"\n+    dist=1\n+    best=0\n+    # Precomputed denominators that lead to good approximations of 1/log(2)\n+    for d in [1, 2, 9, 70, 131, 192, 445, 1588, 4319, 11369, 18419, 25469, 287209, 836158, 3057423, 8336111, 21950910, 35565709, 49180508, 161156323, 273132138, 385107953, 882191721]:\n+        kd = lcm(mulof, d)\n+        if kd <= maxd:\n+            n = ceil(kd / log(2))\n+            dis = F((n / kd) - 1 / log(2))\n+            if dis < dist:\n+                dist = dis\n+                best = kd\n+    return best\n+\n+\n+LOG2_TABLE = []\n+A = 0\n+B = 0\n+C = 0\n+D = 0\n+K = 0\n+\n+def Setup(k):\n+    global LOG2_TABLE, A, B, C, D, K\n+    K = k\n+    LOG2_TABLE = []\n+    for i in range(2 ** TABLE_BITS):\n+        LOG2_TABLE.append(int(floor(F(K * log(1 + i / 2**TABLE_BITS, 2)))))\n+\n+    # Maximum for (2*x+1)*LogK2(x)\n+    max_T = (2^(INPUT_BITS + 1) - 1) * (INPUT_BITS*K - 1)\n+    # Maximum for A\n+    max_A = (2^INT_BITS - 1) // max_T\n+    D = BestOverApproxInvLog2(2 * K, max_A * 2 * K)\n+    A = D // (2 * K)\n+    B = int(ceil(F(D/log(2))))\n+    C = int(floor(F(D*log(2*pi,2)/2)))\n+\n+def LogK2(n):\n+    assert(n >= 1 and n < (1 << INPUT_BITS))\n+    bits = Integer(n).nbits()\n+    return K * (bits - 1) + LOG2_TABLE[((n << (INPUT_BITS - bits)) >> (INPUT_BITS - TABLE_BITS - 1)) - 2**TABLE_BITS]\n+\n+def Log2Fact(n):\n+    # Use formula (A*(2*x+1)*LogK2(x) - B*x + C) / D\n+    return (A*(2*n+1)*LogK2(n) - B*n + C) // D + (n < 3)\n+\n+RES = [int(F(log(factorial(i),2))) for i in range(EXACT_FPBITS * 10)]\n+\n+best_worst_ratio = 0\n+\n+for K in range(1, 10000):\n+    Setup(K)\n+    assert(LogK2(1) == 0)\n+    assert(LogK2(2) == K)\n+    assert(LogK2(4) == 2 * K)\n+    good = True\n+    worst_ratio = 1\n+    for i in range(1, EXACT_FPBITS * 10):\n+        exact = RES[i]\n+        approx = Log2Fact(i)\n+        if not (approx <= exact and ((approx == exact) or (approx >= EXACT_FPBITS and exact >= EXACT_FPBITS))):\n+            good = False\n+            break\n+        if worst_ratio * exact > approx:\n+            worst_ratio = approx / exact\n+    if good and worst_ratio > best_worst_ratio:\n+        best_worst_ratio = worst_ratio\n+        print(\"Formula: (%i*(2*x+1)*floor(%i*log2(x)) - %i*x + %i) / %i; log(max_ratio)=%f\" % (A, K, B, C, D, RR(-log(worst_ratio))))\n+        print(\"LOG2K_TABLE: %r\" % LOG2_TABLE)"
      },
      {
        "sha": "cf46f193ab84397613d3883ebfebf3125e2e7843",
        "filename": "src/minisketch/doc/math.md",
        "status": "added",
        "additions": 117,
        "deletions": 0,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/math.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/math.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/math.md?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,117 @@\n+# The mathematics of Minisketch sketches\n+\n+This is an unconventional mathematical overview of the PinSketch algorithm without references to coding theory<sup>[[1]](#myfootnote1)</sup>.\n+\n+## Set sketches\n+\n+A sketch, for the purpose of this description, can be seen as a \"set checksum\" with two peculiar properties:\n+\n+* Sketches have a predetermined capacity, and when the number of elements in the set is not higher than the capacity, minisketch will always recover the entire set from the sketch. A sketch of *b*-bit elements with capacity *c* can be stored in *bc* bits.\n+* The sketches of two sets can be combined by adding them (XOR) to obtain a sketch of the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) between the two sets (*i.e.*, all elements that occur in one but not both input sets).\n+\n+This overview explains how sets can be converted into a sketch and how a set can be recovered from a sketch. \n+\n+## From field elements to sketches\n+\n+**Data entries as field elements**\n+\n+Every integer in the range *[1...2<sup>b</sup>-1]* (the acceptable data elements for a Minisketch sketch with field size *b*) can be mapped to a nonzero field element of *GF(2<sup>b</sup>)*. In this [finite field](https://en.wikipedia.org/wiki/Finite_field), we can add and multiply elements together, with many of the expected properties for those operations. Addition (and subtraction!) of field elements corresponds to bitwise XOR of the integers they correspond to, though multiplication is more involved.\n+\n+**Sets as power series**\n+\n+We define a function *S* which maps field elements *m* to the following [formal power series](https://en.wikipedia.org/wiki/Formal_power_series) (similar to a polynomial, except there can be an infinite number of terms, and we don't care about concepts like convergence as we're never going to actually evaluate it for a specific value of *x*):\n+\n+* *S(m) = 1 + mx + m<sup>2</sup>x<sup>2</sup> + m<sup>3</sup>x<sup>3</sup> + ...*.\n+\n+We then extend this function to operate on sets of field elements, by adding together the images of every set element. If *M = {m<sub>1</sub>, m<sub>2</sub>, ... }*:\n+\n+* *S(M) = S({m<sub>1</sub>,m<sub>2</sub>,...}) = S(m<sub>1</sub>) + S(m<sub>2</sub>) + ... = (1 + 1 + ...) + (m<sub>1</sub> + m<sub>2</sub> + ...)x + (m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ...)x<sup>2</sup> + (m<sub>1</sub><sup>3</sup> + ...*\n+\n+Because in our field addition corresponds to XOR of integers, it holds for every *a* that *a + a = 0*. This carries over to the *S* function, meaning that *S(a) + S(a) = 0* for every *a*. This means that the coefficients of these power series have the second of the properties we\n+desire from a sketch, namely that an efficient operation exists to\n+combine two sketches such that the result is a sketch of the symmetric\n+difference of the sets. It holds that\n+*S({m<sub>1</sub>,m<sub>2</sub>}) + S({m<sub>2</sub>,m<sub>3</sub>}) = S(m<sub>1</sub>) + (S(m<sub>2</sub>) + S(m<sub>2</sub>)) + S(m<sub>3</sub>) = S(m<sub>1</sub>) + S(m<sub>3</sub>) = S({m<sub>1</sub>,m<sub>3</sub>})*. The question is whether we can also efficiently recover the elements from their power series' coefficients.\n+\n+**An infinity of coefficients is hard**\n+\n+To make reasoning about these power series easier, notice that the series for a single element is in fact a [geometric series](https://en.wikipedia.org/wiki/Geometric_series). If we were working over real numbers rather than a finite field and *|mx| < 1*, it would converge to *(1 - mx)<sup>-1</sup>*. Convergence has no meaning in formal power series, however it is still the case that:\n+\n+* *(1 - mx) S(m) = 1*\n+\n+You can verify this by seeing that every coefficient except the constant one gets cancelled out by the multiplication. This can be generalized to the series for multiple set elements. For two elements we have:\n+\n+* *(1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) S({m<sub>1</sub>,m<sub>2</sub>}) = (1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (S(m<sub>1</sub>) + S(m<sub>2</sub>)) = (1 - m<sub>2</sub>x) + (1 - m<sub>1</sub>x)*\n+\n+And for three:\n+\n+* *(1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (1 - m<sub>3</sub>x) S({m<sub>1</sub>,m<sub>2</sub>,m<sub>3</sub>}) = (1 - m<sub>1</sub>x) (1 - m<sub>2</sub>x) (1 - m<sub>3</sub>x) (S(m<sub>1</sub>) + S(m<sub>2</sub>) + S(m<sub>3</sub>)) = (1 - m<sub>2</sub>x)(1 - m<sub>3</sub>x) + (1 - m<sub>1</sub>x)(1 - m<sub>3</sub>x) + (1 - m<sub>1</sub>x)(1 - m<sub>2</sub>x)*\n+\n+In each case, we notice that multiplying *S(M)* with *(1 - m<sub>i</sub>x)* for each element *m<sub>i</sub> &isin; M* results in a polynomial of degree *n-1*.\n+\n+**Solving for the set elements**\n+\n+The above insight lets us build a solver that extracts the set elements from the coefficients of a power series. If we can find a polynomial *L* that is the product of *n* different *(1 - m<sub>i</sub>x)* factors for various values of *m<sub>i</sub>*, such that *P = S(M)L* is an *n-1* degree polynomial, then those values *m<sub>i</sub>* are the elements of *M*.\n+\n+The coefficients of *P* are nontrivial expressions of the set elements themselves. However, we can just focus on the coefficients of degree *n* and higher in *P*, as those are all 0. Let *s<sub>i</sub>* be the coefficients of *S(M)*, and *l<sub>i</sub>* the coefficients of L. In other words, *S(M) = s<sub>0</sub> + s<sub>1</sub>x + s<sub>2</sub>x<sup>2</sup> + s<sub>3</sub>x<sup>3</sup> + ...* and *L = l<sub>0</sub> + l<sub>1</sub>x + l<sub>2</sub>x<sup>2</sup> + l<sub>3</sub>x<sup>3</sup> + ... + l<sub>n</sub>x<sup>n</sup>*. Note that *l<sub>0</sub> = 1*, as it is the product of all the *1* terms in the *(1 - m<sub>i</sub>x)* factors.\n+\n+Here are the equations for the coefficients of *S(M)L* of degree *n+1* through *2n*:\n+* *s<sub>n+1</sub> + s<sub>n+0</sub>l<sub>1</sub> + s<sub>n-1</sub>l<sub>2</sub> + s<sub>n-2</sub>l<sub>3</sub> + ... + s<sub>1</sub>l<sub>n</sub> = 0*\n+* *s<sub>n+2</sub> + s<sub>n+1</sub>l<sub>1</sub> + s<sub>n+0</sub>l<sub>2</sub> + s<sub>n-1</sub>l<sub>3</sub> + ... + s<sub>2</sub>l<sub>n</sub> = 0*\n+* *s<sub>n+3</sub> + s<sub>n+2</sub>l<sub>1</sub> + s<sub>n+1</sub>l<sub>2</sub> + s<sub>n+0</sub>l<sub>3</sub> + ... + s<sub>3</sub>l<sub>n</sub> = 0*\n+* ...\n+* *s<sub>2n</sub> + s<sub>2n-1</sub>l<sub>1</sub> + s<sub>2n-2</sub>l<sub>2</sub> + s<sub>2n-3</sub>l<sub>3</sub> + ... + s<sub>n</sub>l<sub>n</sub> = 0*\n+\n+These are *n* linear equations with *n* unknowns (the *l<sub>i<sub>*\n+values, for *i=1..n*), which can be solved using [Gaussian elimination](https://en.wikipedia.org/wiki/Gaussian_elimination). After doing so,\n+we have the coefficients of *L*, which can then be [factored](https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields)\n+into first degree factors of the form *(1 - m<sub>i</sub>x)*. The resulting *m* values are our set elements.\n+\n+**Putting it all together**\n+\n+Interestingly, only *2n* coefficients of *S(M)* were needed for solving\n+the set of equations above. This means we have our answer: the\n+coefficients *1* through *2n* of *S(M)*, or the list\n+*[m<sub>1</sub> + m<sub>2</sub> + ..., m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ..., ..., m<sub>1</sub><sup>2n</sup> + m<sub>2</sub><sup>2n</sup> + ...]*\n+functions as a sketch, satisfying the two properties we want:\n+\n+* Sketches can be combined to form the sketch of their symmetric difference, by simply pairwise adding the list elements together.\n+* With *2n* list elements we can efficiently recover *n* elements from a sketch.\n+\n+**Capacity and difference**\n+\n+The approach above only works when the number of elements *n* in the sketch is known. Of course we want to support cases where only an upper bound on the number of elements in the sketch is known, the capacity *c*. Given that we can reconstruct a set of size *c* from a sketch with *2c* terms, we should be able to reconstruct a set of size *n* too as long as *n &le; c*. This is simply a matter of trying to solve the above set of equations assuming values of *n* that count down from *c* until a solution is found for one. This is known as the [Peterson-Gorenstein-Zierler algorithm](https://en.wikipedia.org/wiki/BCH_code#Peterson%E2%80%93Gorenstein%E2%80%93Zierler_algorithm).\n+\n+## Optimizations\n+\n+**Halving the sketch size**\n+\n+We can in fact only include the odd terms in the sketch, and reconstruct the even ones before solving the equation to find *L*. This means the size of a sketch becomes just *c* field elements, the same size as would be needed to send its contents naively.\n+\n+To see how this is possible, we need the [Frobenius endomorphism](https://en.wikipedia.org/wiki/Frobenius_endomorphism), which in short states that in fields where *x + x = 0* it holds that *(x + y)<sup>2</sup> = x<sup>2</sup> + y<sup>2</sup>* for every *x* and *y* (the dream of every high school math student!). This means that:\n+\n+* *s<sub>2</sub> = m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ... = (m<sub>1</sub> + m<sub>2</sub> + ...)<sup>2</sup> = s<sub>1</sub><sup>2</sup>*.\n+* *s<sub>4</sub> = m<sub>1</sub><sup>4</sup> + m<sub>2</sub><sup>4</sup> + ... = (m<sub>1</sub><sup>2</sup> + m<sub>2</sub><sup>2</sup> + ...)<sup>2</sup> = s<sub>2</sub><sup>2</sup>*.\n+* *s<sub>6</sub> = m<sub>1</sub><sup>6</sup> + m<sub>2</sub><sup>6</sup> + ... = (m<sub>1</sub><sup>3</sup> + m<sub>2</sub><sup>3</sup> + ...)<sup>2</sup> = s<sub>3</sub><sup>2</sup>*.\n+* ...\n+\n+In other words, we only need to send *s<sub>1</sub>, s<sub>3</sub>, s<sub>5</sub>, ..., s<sub>2n-1</sub>* to recover all *2n* *s<sub>i</sub>* values, and proceed with reconstruction.\n+\n+**Quadratic performance rather than cubic**\n+\n+Using Gaussian elimination to solve the set of equations above for the *l<sub>i</sub>* values requires *O(n<sup>3</sup>)* field operations. However, due to the special structure in the equations (look at the repeated *s<sub>i</sub>* values), it can be solved in *O(n<sup>2</sup>)* time using a number of techniques, including the [Berlekamp-Massey algorithm](https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm) (BM).\n+\n+**Roots instead of factorization**\n+\n+As explained above, the polynomial *L* can be factored into *(1 - m<sub>i</sub>x)* factors, where the values *m<sub>i</sub>* are the set elements. However, since we know that a decodable sketch must result in a polynomial that is fully factorizable into degree-*1* factors, we can instead use a more efficient root-finding algorithm rather than a factorization algorithm. As the root of each *(1 - m<sub>i</sub>x)* factor is *m<sub>i</sub><sup>-1</sup>*, we conclude that the set elements are in fact the inverses of the roots of *L*.\n+\n+**Avoiding inversions**\n+\n+As inversions are a relatively expensive operation, it would be useful to avoid them.\n+\n+Say that we're trying to find the inverses of the roots of *L = 1 + l<sub>1</sub>x + l<sub>2</sub>x<sup>2</sup> + ... + l<sub>n</sub>x<sup>n</sup>*, then we're really interested in the solutions *y* for *1 + l<sub>1</sub>y<sup>-1</sup> + l<sub>2</sub>y<sup>-2</sup> + ... + l<sub>n</sub>y<sup>-n</sup> = 0*. By multiplying both sides in the equations with *y<sup>n</sup>*, we find *l<sub>n</sub> + l<sub>n-1</sub>y + l<sub>n-2</sub>y<sup>2</sup> + ... + y<sup>n</sup> = 0*.\n+\n+In other words, we can find the inverses of the roots of *L* by instead factoring the polynomial with the coefficients of *L* in reverse order.\n+\n+* <a name=\"myfootnote1\">[1]</a> For those familiar with coding theory: PinSketch communicates a set difference by encoding the set members as errors in a binary [BCH](https://en.wikipedia.org/wiki/BCH_code) codeword 2<sup>bits</sup> in size and sends the syndromes.\n+  The linearity of the syndromes provides all the properties needed for a sketch. Sketch decoding is simply finding the error locations. Decode is much faster than an ordinary BCH decoder for such a large codeword because the need to take a discrete log is avoided by storing the set in the roots directly instead of in an exponent (logically permuting the bits of the codeword)."
      },
      {
        "sha": "379ac481b336f843528ce92c3a4b969843e7a833",
        "filename": "src/minisketch/doc/moduli.md",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/moduli.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/moduli.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/moduli.md?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,65 @@\n+These are the irreducible polynomials over *GF(2)* used to represent field elements:\n+\n+* *x<sup>2</sup> + x + 1*\n+* *x<sup>3</sup> + x + 1*\n+* *x<sup>4</sup> + x + 1*\n+* *x<sup>5</sup> + x<sup>2</sup> + 1*\n+* *x<sup>6</sup> + x + 1*\n+* *x<sup>7</sup> + x + 1*\n+* *x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>9</sup> + x + 1*\n+* *x<sup>10</sup> + x<sup>3</sup> + 1*\n+* *x<sup>11</sup> + x<sup>2</sup> + 1*\n+* *x<sup>12</sup> + x<sup>3</sup> + 1*\n+* *x<sup>13</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>14</sup> + x<sup>5</sup> + 1*\n+* *x<sup>15</sup> + x + 1*\n+* *x<sup>16</sup> + x<sup>5</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>17</sup> + x<sup>3</sup> + 1*\n+* *x<sup>18</sup> + x<sup>3</sup> + 1*\n+* *x<sup>19</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>20</sup> + x<sup>3</sup> + 1*\n+* *x<sup>21</sup> + x<sup>2</sup> + 1*\n+* *x<sup>22</sup> + x + 1*\n+* *x<sup>23</sup> + x<sup>5</sup> + 1*\n+* *x<sup>24</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>25</sup> + x<sup>3</sup> + 1*\n+* *x<sup>26</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>27</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>28</sup> + x + 1*\n+* *x<sup>29</sup> + x<sup>2</sup> + 1*\n+* *x<sup>30</sup> + x + 1*\n+* *x<sup>31</sup> + x<sup>3</sup> + 1*\n+* *x<sup>32</sup> + x<sup>7</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>33</sup> + x<sup>10</sup> + 1*\n+* *x<sup>34</sup> + x<sup>7</sup> + 1*\n+* *x<sup>35</sup> + x<sup>2</sup> + 1*\n+* *x<sup>36</sup> + x<sup>9</sup> + 1*\n+* *x<sup>37</sup> + x<sup>6</sup> + x<sup>4</sup> + x + 1*\n+* *x<sup>38</sup> + x<sup>6</sup> + x<sup>5</sup> + x + 1*\n+* *x<sup>39</sup> + x<sup>4</sup> + 1*\n+* *x<sup>40</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>3</sup> + 1*\n+* *x<sup>41</sup> + x<sup>3</sup> + 1*\n+* *x<sup>42</sup> + x<sup>7</sup> + 1*\n+* *x<sup>43</sup> + x<sup>6</sup> + x<sup>4</sup> + x<sup>3</sup> + 1*\n+* *x<sup>44</sup> + x<sup>5</sup> + 1*\n+* *x<sup>45</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>46</sup> + x + 1*\n+* *x<sup>47</sup> + x<sup>5</sup> + 1*\n+* *x<sup>48</sup> + x<sup>5</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>49</sup> + x<sup>9</sup> + 1*\n+* *x<sup>50</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1*\n+* *x<sup>51</sup> + x<sup>6</sup> + x<sup>3</sup> + x + 1*\n+* *x<sup>52</sup> + x<sup>3</sup> + 1*\n+* *x<sup>53</sup> + x<sup>6</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>54</sup> + x<sup>9</sup> + 1*\n+* *x<sup>55</sup> + x<sup>7</sup> + 1*\n+* *x<sup>56</sup> + x<sup>7</sup> + x<sup>4</sup> + x<sup>2</sup> + 1*\n+* *x<sup>57</sup> + x<sup>4</sup> + 1*\n+* *x<sup>58</sup> + x<sup>19</sup> + 1*\n+* *x<sup>59</sup> + x<sup>7</sup> + x<sup>4</sup> + x<sup>2</sup> + 1*\n+* *x<sup>60</sup> + x + 1*\n+* *x<sup>61</sup> + x<sup>5</sup> + x<sup>2</sup> + x + 1*\n+* *x<sup>62</sup> + x<sup>29</sup> + 1*\n+* *x<sup>63</sup> + x + 1*\n+* *x<sup>64</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1*"
      },
      {
        "sha": "6e907d6b20c0d88e38283ba0d66dd177070a2986",
        "filename": "src/minisketch/doc/plot_bits.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_bits.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_bits.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/plot_bits.png?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427"
      },
      {
        "sha": "b4f760da367bdb440587916b2256363e4823e31e",
        "filename": "src/minisketch/doc/plot_capacity.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_capacity.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_capacity.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/plot_capacity.png?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427"
      },
      {
        "sha": "08ab6a86b96d41abf056d91ca7162e22e69e3237",
        "filename": "src/minisketch/doc/plot_diff.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_diff.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_diff.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/plot_diff.png?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427"
      },
      {
        "sha": "b21921776a7a9321acd4d1a2b01f455e864e93f7",
        "filename": "src/minisketch/doc/plot_size.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_size.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/plot_size.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/plot_size.png?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427"
      },
      {
        "sha": "610407ebc226935902480a42c1c1faed07e3e2bc",
        "filename": "src/minisketch/doc/protocoltips.md",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/protocoltips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/doc/protocoltips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/doc/protocoltips.md?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,30 @@\n+# Tips for designing protocols using `libminisketch`\n+\n+Sending a sketch is less efficient than just sending your whole set with efficient entropy coding if the number of differences is larger than *log<sub>2</sub>( 2<sup>b</sup> choose set_size ) / b*.\n+\n+In most applications your set can be hashed to entries just large enough to make the probability of collision negligible. This can be a considerable speedup and bandwidth savings.  Short hashes (<128 bits) should be salted with an unpredictable value to prevent malicious inputs from intentionally causing collisions. Salting also allows an entry missed due to a collision to be reconciled on a later run with a different salt. Pre-hashing may not be possible in some applications, such as where there is only one-way communication, where the confidentiality of entry origin matters, or where security depends on the total absence of collisions.\n+\n+Some element sizes are faster to decode than others; see the benchmarks in the readme.\n+\n+Almost all the computational burden of reconciliation is in minisketch_decode(). Denial-of-service attacks can be mitigated by arranging protocol flow so that a party requests a sketch and decodes it rather than a construction where the participants will decode unsolicited sketches. Decode times can be constrained by limiting sketch capacity or via the max_count argument to minisketch_decode().\n+\n+In most cases you don't actually know the size of the set difference in advance, but often you know a lower bound on it (the difference in set sizes).\n+\n+* There are difference size estimation techniques such as min-wise hashing<sup>[[1]](#myfootnote1)</sup> or random projections<sup>[[2]](#myfootnote2)</sup>, but complex estimators can end up using more bandwidth than they save.\n+\n+* It may be useful to always overestimate the sketch size needed to amortize communications overheads (*e.g.* packet headers, round trip delays).\n+\n+* If the total data sent would end up leaving you better off having just sent the whole set, per above, then you can send the set in response to a failure but leave out as many elements as the size of the previously sent sketch. The receiver can decode the partial set and use the data they already have to complete it, reducing bandwidth waste.\n+\n+* Additional elements can be sent for a sketch as few as one at a time with little decode cost until enough data is received to decode.  This is most easily implemented by always computing the largest sketch size and sending it incrementally as needed.\n+\n+* Because sketches are linear you can adaptively subdivide to decode an overfull set. The sender uses a hash function to select approximately half their set members and sends a sketch of those members. The receiver can do the same and combine the result with the initially sent sketch to get two sketches with roughly half the number of members and attempt to decode them. Repeat recursively on failure. This adaptive subdivision procedure makes decode time essentially linear at the cost of communications inefficiency.  Minisketches can also be used as the cells in an IBLT for similar reasons.\n+\n+Less efficient reconciliation techniques like IBLT or adaptive subdivision, or overheads like complex estimators effectively lower the threshold where sending the whole set efficiently would use less bandwidth.\n+\n+When the number of differences is more than 2<sup>b/2-1</sup> an alternative sketch encoding is possible that is somewhat smaller, but requires a table of size 2<sup>b</sup>; contact the authors if you have an application where that might be useful.\n+\n+## References\n+\n+* <a name=\"myfootnote1\">[1]</a> Broder, A. *On the Resemblance and Containment of Documents* Proceedings of the Compression and Complexity of Sequences 1997 [[PDF]](https://www.cs.princeton.edu/courses/archive/spring13/cos598C/broder97resemblance.pdf)\n+* <a name=\"myfootnote2\">[2]</a> Feigenbaum, Joan and Kannan, Sampath and Strauss, Martin J. and Viswanathan, Mahesh. *An Approximate L1-Difference Algorithm for  Massive Data Streams* SIAM J. Comput. 2003 [[PDF]](http://www.cs.yale.edu/homes/jf/FKSV1.pdf)"
      },
      {
        "sha": "2b991d3956ead97b48c9f25a3740615a2788c7cc",
        "filename": "src/minisketch/include/minisketch.h",
        "status": "added",
        "additions": 319,
        "deletions": 0,
        "changes": 319,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/include/minisketch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/include/minisketch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/include/minisketch.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,319 @@\n+#ifndef _MINISKETCH_H_\n+#define _MINISKETCH_H_ 1\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#ifdef __cplusplus\n+#  if __cplusplus >= 201103L\n+#    include <memory>\n+#    include <vector>\n+#    include <cassert>\n+#    if __cplusplus >= 201703L\n+#      include <optional>\n+#    endif // __cplusplus >= 201703L\n+#  endif // __cplusplus >= 201103L\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/** Opaque type for decoded sketches. */\n+typedef struct minisketch minisketch;\n+\n+/** Determine whether support for elements of `bits` bits was compiled in. */\n+int minisketch_bits_supported(uint32_t bits);\n+\n+/** Determine the maximum number of implementations available.\n+ *\n+ * Multiple implementations may be available for a given element size, with\n+ * different performance characteristics on different hardware.\n+ *\n+ * Each implementation is identified by a number from 0 to the output of this\n+ * function call, inclusive. Note that not every combination of implementation\n+ * and element size may exist (see further).\n+*/\n+uint32_t minisketch_implementation_max(void);\n+\n+/** Determine if the a combination of bits and implementation number is available.\n+ *\n+ * Returns 1 if it is, 0 otherwise.\n+ */\n+int minisketch_implementation_supported(uint32_t bits, uint32_t implementation);\n+\n+/** Construct a sketch for a given element size, implementation and capacity.\n+ *\n+ * If the combination of `bits` and `implementation` is unavailable, or if\n+ * `capacity` is 0, NULL is returned. If minisketch_implementation_supported\n+ * returns 1 for the specified bits and implementation, this will always succeed\n+ * (except when allocation fails).\n+ *\n+ * If the result is not NULL, it must be destroyed using minisketch_destroy.\n+ */\n+minisketch* minisketch_create(uint32_t bits, uint32_t implementation, size_t capacity);\n+\n+/** Get the element size of a sketch in bits. */\n+uint32_t minisketch_bits(const minisketch* sketch);\n+\n+/** Get the capacity of a sketch. */\n+size_t minisketch_capacity(const minisketch* sketch);\n+\n+/** Get the implementation of a sketch. */\n+uint32_t minisketch_implementation(const minisketch* sketch);\n+\n+/** Set the seed for randomizing algorithm choices to a fixed value.\n+ *\n+ * By default, sketches are initialized with a random seed. This is important\n+ * to avoid scenarios where an attacker could force worst-case behavior.\n+ *\n+ * This function initializes the seed to a user-provided value (any 64-bit\n+ * integer is acceptable, regardless of field size).\n+ *\n+ * When seed is -1, a fixed internal value with predictable behavior is\n+ * used. It is only intended for testing.\n+ */\n+void minisketch_set_seed(minisketch* sketch, uint64_t seed);\n+\n+/** Clone a sketch.\n+ *\n+ * The result must be destroyed using minisketch_destroy.\n+ */\n+minisketch* minisketch_clone(const minisketch* sketch);\n+\n+/** Destroy a sketch.\n+ *\n+ * The pointer that was passed in may not be used anymore afterwards.\n+ */\n+void minisketch_destroy(minisketch* sketch);\n+\n+/** Compute the size in bytes for serializing a given sketch. */\n+size_t minisketch_serialized_size(const minisketch* sketch);\n+\n+/** Serialize a sketch to bytes. */\n+void minisketch_serialize(const minisketch* sketch, unsigned char* output);\n+\n+/** Deserialize a sketch from bytes. */\n+void minisketch_deserialize(minisketch* sketch, const unsigned char* input);\n+\n+/** Add an element to a sketch.\n+ * \n+ * If the element to be added is too large for the sketch, the most significant\n+ * bits of the element are dropped. More precisely, if the element size of\n+ * `sketch` is b bits, then this function adds the unsigned integer represented\n+ * by the b least significant bits of `element` to `sketch`.\n+ * \n+ * If the element to be added is 0 (after potentially dropping the most significant\n+ * bits), then this function is a no-op. Sketches cannot contain an element with\n+ * the value 0.\n+ */\n+void minisketch_add_uint64(minisketch* sketch, uint64_t element);\n+\n+/** Merge the elements of another sketch into this sketch.\n+ *\n+ * After merging, `sketch` will contain every element that existed in one but not\n+ * both of the input sketches. It can be seen as an exclusive or operation on\n+ * the set elements.  If the capacity of `other_sketch` is lower than `sketch`'s,\n+ * merging reduces the capacity of `sketch` to that of `other_sketch`.\n+ *\n+ * This function returns the capacity of `sketch` after merging has been performed\n+ * (where this capacity is at least 1), or 0 to indicate that merging has failed because\n+ * the two input sketches differ in their element size or implementation. If 0 is\n+ * returned, `sketch` (and its capacity) have not been modified.\n+ *\n+ * It is also possible to perform this operation directly on the serializations\n+ * of two sketches with the same element size and capacity by performing a bitwise XOR\n+ * of the serializations.\n+ */\n+size_t minisketch_merge(minisketch* sketch, const minisketch* other_sketch);\n+\n+/** Decode a sketch.\n+ *\n+ * `output` is a pointer to an array of `max_element` uint64_t's, which will be\n+ * filled with the elements in this sketch.\n+ *\n+ * The return value is the number of decoded elements, or -1 if decoding failed.\n+ */\n+ssize_t minisketch_decode(const minisketch* sketch, size_t max_elements, uint64_t* output);\n+\n+/** Compute the capacity needed to achieve a certain rate of false positives.\n+ *\n+ * A sketch with capacity c and no more than c elements can always be decoded\n+ * correctly. However, if it has more than c elements, or contains just random\n+ * bytes, it is possible that it will still decode, but the result will be\n+ * nonsense. This can be counteracted by increasing the capacity slightly.\n+ *\n+ * Given a field size bits, an intended number of elements that can be decoded\n+ * max_elements, and a false positive probability of 1 in 2**fpbits, this\n+ * function computes the necessary capacity. It is only guaranteed to be\n+ * accurate up to fpbits=256.\n+ */\n+size_t minisketch_compute_capacity(uint32_t bits, size_t max_elements, uint32_t fpbits);\n+\n+/** Compute what max_elements can be decoded for a certain rate of false positives.\n+ *\n+ * This is the inverse operation of minisketch_compute_capacity. It determines,\n+ * given a field size bits, a capacity of a sketch, and an acceptable false\n+ * positive probability of 1 in 2**fpbits, what the maximum allowed\n+ * max_elements value is. If no value of max_elements would give the desired\n+ * false positive probability, 0 is returned.\n+ *\n+ * Note that this is not an exact inverse of minisketch_compute_capacity. For\n+ * example, with bits=32, fpbits=16, and max_elements=8,\n+ * minisketch_compute_capacity will return 9, as capacity 8 would only have a\n+ * false positive chance of 1 in 2^15.3. Increasing the capacity to 9 however\n+ * decreases the fp chance to 1 in 2^47.3, enough for max_elements=9 (with fp\n+ * chance of 1 in 2^18.5). Therefore, minisketch_compute_max_elements with\n+ * capacity=9 will return 9.\n+ */\n+size_t minisketch_compute_max_elements(uint32_t bits, size_t capacity, uint32_t fpbits);\n+\n+#ifdef __cplusplus\n+}\n+\n+#if __cplusplus >= 201103L\n+/** Simple RAII C++11 wrapper around the minisketch API. */\n+class Minisketch\n+{\n+    struct Deleter\n+    {\n+        void operator()(minisketch* ptr) const\n+        {\n+            minisketch_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<minisketch, Deleter> m_minisketch;\n+\n+public:\n+    /** See minisketch_bits_supported(). */\n+    static bool BitsSupported(uint32_t bits) noexcept { return minisketch_bits_supported(bits); }\n+\n+    /** minisketch_implementation_supported(). */\n+    static bool ImplementationSupported(uint32_t bits, uint32_t implementation) noexcept { return minisketch_implementation_supported(bits, implementation); }\n+\n+    /** See minisketch_implementation_max(). */\n+    static uint32_t MaxImplementation() noexcept { return minisketch_implementation_max(); }\n+\n+    /** See minisketch_compute_capacity(). */\n+    static size_t ComputeCapacity(uint32_t bits, size_t max_elements, uint32_t fpbits) noexcept { return minisketch_compute_capacity(bits, max_elements, fpbits); }\n+\n+    /** See minisketch_compute_max_elements(). */\n+    static size_t ComputeMaxElements(uint32_t bits, size_t capacity, uint32_t fpbits) noexcept { return minisketch_compute_max_elements(bits, capacity, fpbits); }\n+\n+    /** Construct a clone of the specified sketch. */\n+    Minisketch(const Minisketch& sketch) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_clone(sketch.m_minisketch.get()));\n+    }\n+\n+    /** Make this Minisketch a clone of the specified one. */\n+    Minisketch& operator=(const Minisketch& sketch) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_clone(sketch.m_minisketch.get()));\n+        return *this;\n+    }\n+\n+    explicit operator bool() const noexcept { return bool{m_minisketch}; }\n+\n+    Minisketch() noexcept = default;\n+    Minisketch(Minisketch&&) noexcept = default;\n+    Minisketch& operator=(Minisketch&&) noexcept = default;\n+\n+    /** Construct a Minisketch object with the specified parameters. */\n+    Minisketch(uint32_t bits, uint32_t implementation, size_t capacity) noexcept\n+    {\n+        m_minisketch = std::unique_ptr<minisketch, Deleter>(minisketch_create(bits, implementation, capacity));\n+    }\n+\n+    /** Create a Minisketch object sufficiently large for the specified number of elements at given fpbits. */\n+    static Minisketch CreateFP(uint32_t bits, uint32_t implementation, size_t max_elements, uint32_t fpbits) noexcept\n+    {\n+        return Minisketch(bits, implementation, ComputeCapacity(bits, max_elements, fpbits));\n+    }\n+\n+    /** See minisketch_get_bits(). */\n+    uint32_t GetBits() const noexcept { return minisketch_bits(m_minisketch.get()); }\n+\n+    /** See minisketch_get_capacity(). */\n+    size_t GetCapacity() const noexcept { return minisketch_capacity(m_minisketch.get()); }\n+\n+    /** See minisketch_get_implementation(). */\n+    uint32_t GetImplementation() const noexcept { return minisketch_implementation(m_minisketch.get()); }\n+\n+    /** See minisketch_set_seed(). */\n+    Minisketch& SetSeed(uint64_t seed) noexcept\n+    {\n+        minisketch_set_seed(m_minisketch.get(), seed);\n+        return *this;\n+    }\n+\n+    /** See miniksetch_add_element(). */\n+    Minisketch& Add(uint64_t element) noexcept\n+    {\n+        minisketch_add_uint64(m_minisketch.get(), element);\n+        return *this;\n+    }\n+\n+    /** See minisketch_merge(). */\n+    Minisketch& Merge(const Minisketch& sketch) noexcept\n+    {\n+        minisketch_merge(m_minisketch.get(), sketch.m_minisketch.get());\n+        return *this;\n+    }\n+\n+    /** Decode this sketch into the result vector, up to as many elements as the vector's size permits. */\n+    bool Decode(std::vector<uint64_t>& result) const\n+    {\n+        ssize_t ret = minisketch_decode(m_minisketch.get(), result.size(), result.data());\n+        if (ret == -1) return false;\n+        result.resize(ret);\n+        return true;\n+    }\n+\n+    /** See minisketch_serialized_size(). */\n+    size_t GetSerializedSize() const noexcept { return minisketch_serialized_size(m_minisketch.get()); }\n+\n+    /** Serialize the sketch as a byte vector. */\n+    std::vector<unsigned char> Serialize() const\n+    {\n+        std::vector<unsigned char> result(GetSerializedSize());\n+        minisketch_serialize(m_minisketch.get(), result.data());\n+        return result;\n+    }\n+\n+    /** Deserialize into this sketch from an object containing its bytes (which has data() and size() members). */\n+    template<typename T>\n+    Minisketch& Deserialize(\n+        const T& obj,\n+        typename std::enable_if<\n+            std::is_convertible<typename std::remove_pointer<decltype(obj.data())>::type (*)[], const unsigned char (*)[]>::value &&\n+            std::is_convertible<decltype(obj.size()), std::size_t>::value,\n+            std::nullptr_t\n+        >::type = nullptr) noexcept\n+    {\n+        assert(GetSerializedSize() == obj.size());\n+        minisketch_deserialize(m_minisketch.get(), obj.data());\n+        return *this;\n+    }\n+\n+#if __cplusplus >= 201703L\n+    /** C++17 only: decode up to a specified number of elements into an optional vector. */\n+    std::optional<std::vector<uint64_t>> Decode(size_t max_elements) const\n+    {\n+        std::vector<uint64_t> result(max_elements);\n+        ssize_t ret = minisketch_decode(m_minisketch.get(), max_elements, result.data());\n+        if (ret == -1) return {};\n+        result.resize(ret);\n+        return std::move(result);\n+    }\n+\n+    /** C++17 only: similar to Decode(), but with specified false positive probability. */\n+    std::optional<std::vector<uint64_t>> DecodeFP(uint32_t fpbits) const\n+    {\n+        return Decode(ComputeMaxElements(GetBits(), GetCapacity(), fpbits));\n+    }\n+#endif // __cplusplus >= 201703L\n+};\n+#endif // __cplusplus >= 201103L\n+#endif // __cplusplus\n+\n+#endif  // _MINISKETCH_H_"
      },
      {
        "sha": "ac4ff0db8fc66d405fea79acf41374a59fe4b2bf",
        "filename": "src/minisketch/sources.mk",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/sources.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/sources.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/sources.mk?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,54 @@\n+# - All variables are namespaced with MINISKETCH_ to avoid colliding with\n+#     downstream makefiles.\n+# - All Variables ending in _HEADERS or _SOURCES confuse automake, so the\n+#     _INT postfix is applied.\n+# - Convenience variables, for example a MINISKETCH_FIELDS_DIR should not be used\n+#     as they interfere with automatic dependency generation\n+# - The %reldir% is the relative path from the Makefile.am. This allows\n+#   downstreams to use these variables without having to manually account for\n+#   the path change.\n+\n+MINISKETCH_DIST_HEADERS_INT =\n+MINISKETCH_DIST_HEADERS_INT += %reldir%/include/minisketch.h\n+\n+MINISKETCH_LIB_HEADERS_INT =\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/int_utils.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/lintrans.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/sketch.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/sketch_impl.h\n+MINISKETCH_LIB_HEADERS_INT += %reldir%/src/util.h\n+\n+MINISKETCH_LIB_SOURCES_INT =\n+MINISKETCH_LIB_SOURCES_INT += %reldir%/src/minisketch.cpp\n+\n+MINISKETCH_FIELD_GENERIC_HEADERS_INT =\n+MINISKETCH_FIELD_GENERIC_HEADERS_INT += %reldir%/src/fields/generic_common_impl.h\n+\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT =\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_1byte.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_2bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_3bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_4bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_5bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_6bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_7bytes.cpp\n+MINISKETCH_FIELD_GENERIC_SOURCES_INT += %reldir%/src/fields/generic_8bytes.cpp\n+\n+MINISKETCH_FIELD_CLMUL_HEADERS_INT =\n+MINISKETCH_FIELD_CLMUL_HEADERS_INT += %reldir%/src/fields/clmul_common_impl.h\n+\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT =\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_1byte.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_2bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_3bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_4bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_5bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_6bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_7bytes.cpp\n+MINISKETCH_FIELD_CLMUL_SOURCES_INT += %reldir%/src/fields/clmul_8bytes.cpp\n+\n+MINISKETCH_BENCH_SOURCES_INT =\n+MINISKETCH_BENCH_SOURCES_INT += %reldir%/src/bench.cpp\n+\n+MINISKETCH_TEST_SOURCES_INT =\n+MINISKETCH_TEST_SOURCES_INT += %reldir%/src/test-exhaust.cpp"
      },
      {
        "sha": "f55944a448a41c074b6809e0a99bfd6e629bbf87",
        "filename": "src/minisketch/src/bench.cpp",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/bench.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,122 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <chrono>\n+#include <random>\n+#include <set>\n+#include <algorithm>\n+\n+int main(int argc, char** argv) {\n+    if (argc < 1 || argc > 4) {\n+        printf(\"Usage: %s [syndromes=150] [errors=syndromes] [iters=10]\\n\", argv[0]);\n+        return 1;\n+    }\n+    int syndromes = argc > 1 ? strtoul(argv[1], NULL, 10) : 150;\n+    int errors = argc > 2 ? strtoul(argv[2], NULL, 10) : syndromes;\n+    int iters = argc > 3 ? strtoul(argv[3], NULL, 10) : 10;\n+    if (syndromes < 0 || syndromes > 1000000) {\n+        printf(\"Number of syndromes (%i) out of range 0..1000000\\n\", syndromes);\n+        return 1;\n+    }\n+    if (errors < 0) {\n+        printf(\"Number of errors (%i) is negative(%i)\\n\", errors, syndromes);\n+        return 1;\n+    }\n+    if (iters < 0 || iters > 1000000000) {\n+        printf(\"Number of iterations (%i) out of range 0..1000000000\\n\", iters);\n+        return 1;\n+    }\n+    uint32_t max_impl = minisketch_implementation_max();\n+    for (int bits = 2; bits <= 64; ++bits) {\n+        if (errors > pow(2.0, bits - 1)) continue;\n+        if (!minisketch_bits_supported(bits)) continue;\n+        printf(\"recover[ms]\\t% 3i\\t\", bits);\n+        for (uint32_t impl = 0; impl <= max_impl; ++impl) {\n+            std::vector<minisketch*> states;\n+            std::vector<uint64_t> roots(2 * syndromes);\n+            std::random_device rng;\n+            std::uniform_int_distribution<uint64_t> dist(1, (uint64_t(1) << bits) - 1);\n+            states.resize(iters);\n+            std::vector<double> benches;\n+            benches.reserve(iters);\n+            for (int i = 0; i < iters; ++i) {\n+                states[i] = minisketch_create(bits, impl, syndromes);\n+                if (!states[i]) break;\n+                std::set<uint64_t> done;\n+                for (int j = 0; j < errors; ++j) {\n+                    uint64_t r;\n+                    do {\n+                        r = dist(rng);\n+                    } while (done.count(r));\n+                    done.insert(r);\n+                    minisketch_add_uint64(states[i], r);\n+                }\n+            }\n+            if (!states[0]) {\n+                printf(\"         -\\t\");\n+            } else {\n+                double total = 0.0;\n+                for (auto& state : states) {\n+                    auto start = std::chrono::steady_clock::now();\n+                    minisketch_decode(state, 2 * syndromes, roots.data());\n+                    auto stop = std::chrono::steady_clock::now();\n+                    std::chrono::duration<double> dur(stop - start);\n+                    total += dur.count();\n+                    benches.push_back(dur.count());\n+                }\n+                std::sort(benches.begin(), benches.end());\n+                printf(\"% 10.5f\\t\", benches[0] * 1000.0);\n+            }\n+            for (auto& state : states) {\n+                minisketch_destroy(state);\n+            }\n+        }\n+        printf(\"\\n\");\n+        printf(\"create[ns]\\t% 3i\\t\", bits);\n+        for (uint32_t impl = 0; impl <= max_impl; ++impl) {\n+            std::vector<minisketch*> states;\n+            std::random_device rng;\n+            std::uniform_int_distribution<uint64_t> dist;\n+            std::vector<uint64_t> data;\n+            data.resize(errors * 10);\n+            states.resize(iters);\n+            std::vector<double> benches;\n+            benches.reserve(iters);\n+            for (int i = 0; i < iters; ++i) {\n+                states[i] = minisketch_create(bits, impl, syndromes);\n+            }\n+            for (size_t i = 0; i < data.size(); ++i) {\n+                data[i] = dist(rng);\n+            }\n+            if (!states[0]) {\n+                printf(\"         -\\t\");\n+            } else {\n+                double total = 0.0;\n+                for (auto& state : states) {\n+                    auto start = std::chrono::steady_clock::now();\n+                    for (auto val : data) {\n+                        minisketch_add_uint64(state, val);\n+                    }\n+                    auto stop = std::chrono::steady_clock::now();\n+                    std::chrono::duration<double> dur(stop - start);\n+                    total += dur.count();\n+                    benches.push_back(dur.count());\n+                }\n+                std::sort(benches.begin(), benches.end());\n+                printf(\"% 10.5f\\t\", benches[0] * 1000000000.0 / data.size() / syndromes);\n+            }\n+            for (auto& state : states) {\n+                minisketch_destroy(state);\n+            }\n+        }\n+        printf(\"\\n\");\n+    }\n+    return 0;\n+}"
      },
      {
        "sha": "44ebb3e94c3f152c56c05770a02a722012fe5306",
        "filename": "src/minisketch/src/false_positives.h",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/false_positives.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/false_positives.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/false_positives.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,110 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FALSE_POSITIVES_H_\n+#define _MINISKETCH_FALSE_POSITIVES_H_\n+\n+#include \"util.h\"\n+\n+#include \"int_utils.h\"\n+\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** Compute floor(log2(x!)), exactly up to x=57; an underestimate up to x=2^32-1. */\n+uint64_t Log2Factorial(uint32_t x) {\n+    //! Values of floor(106*log2(1 + i/32)) for i=0..31\n+    static constexpr uint8_t T[32] = {\n+        0, 4, 9, 13, 18, 22, 26, 30, 34, 37, 41, 45, 48, 52, 55, 58, 62, 65, 68,\n+        71, 74, 77, 80, 82, 85, 88, 90, 93, 96, 98, 101, 103\n+    };\n+    int bits = CountBits(x, 32);\n+    // Compute an (under)estimate of floor(106*log2(x)).\n+    // This works by relying on floor(log2(x)) = countbits(x)-1, and adding\n+    // precision using the top 6 bits of x (the highest one of which is always\n+    // one).\n+    unsigned l2_106 = 106 * (bits - 1) + T[((x << (32 - bits)) >> 26) & 31];\n+    // Based on Stirling approximation for log2(x!):\n+    //   log2(x!) = log(x!) / log(2)\n+    //            = ((x + 1/2) * log(x) - x + log(2*pi)/2 + ...) / log(2)\n+    //            = (x + 1/2) * log2(x) - x/log(2) + log2(2*pi)/2 + ...\n+    //            = 1/2*(2*x+1)*log2(x) - (1/log(2))*x + log2(2*pi)/2 + ...\n+    //            = 1/212*(2*x+1)*(106*log2(x)) + (-1/log(2))*x + log2(2*pi)/2 + ...\n+    // where 418079/88632748 is exactly 1/212\n+    //       -127870026/88632748 is slightly less than -1/log(2)\n+    //       117504694/88632748 is less than log2(2*pi)/2\n+    // A correction term is only needed for x < 3.\n+    //\n+    // See doc/log2_factorial.sage for how these constants were obtained.\n+    return (418079 * (2 * uint64_t{x} + 1) * l2_106 - 127870026 * uint64_t{x} + 117504694 + 88632748 * (x < 3)) / 88632748;\n+}\n+\n+/** Compute floor(log2(2^(bits * capacity) / sum((2^bits - 1) choose k, k=0..capacity))), for bits>1\n+ *\n+ * See doc/gen_basefpbits.sage for how the tables were obtained. */\n+uint64_t BaseFPBits(uint32_t bits, uint32_t capacity) {\n+    // Correction table for low bits/capacities\n+    static constexpr uint8_t ADD5[] = {1, 1, 1, 1, 2, 2, 2, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12};\n+    static constexpr uint8_t ADD6[] = {1, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 8, 8, 10, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 23, 24, 24, 24, 24};\n+    static constexpr uint8_t ADD7[] = {1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 7, 8, 9, 9, 9, 10, 11, 11, 12, 12, 13, 13, 15, 15, 15, 16, 17, 17, 18, 19, 20, 20};\n+    static constexpr uint8_t ADD8[] = {1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 3, 4, 4, 5, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 9, 9};\n+    static constexpr uint8_t ADD9[] = {1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 3, 4, 3, 3, 4, 4, 4, 4};\n+\n+    if (capacity == 0) return 0;\n+    uint64_t ret = 0;\n+    if (bits < 32 && capacity >= (1U << bits)) {\n+        ret = uint64_t{bits} * (capacity - (1U << bits) + 1);\n+        capacity = (1U << bits) - 1;\n+    }\n+    ret += Log2Factorial(capacity);\n+    switch (bits) {\n+        case 2: return ret + (capacity <= 2 ? 0 : 1);\n+        case 3: return ret + (capacity <= 2 ? 0 : (0x2a5 >> 2 * (capacity - 3)) & 3);\n+        case 4: return ret + (capacity <= 3 ? 0 : (0xb6d91a449 >> 3 * (capacity - 4)) & 7);\n+        case 5: return ret + (capacity <= 4 ? 0 : ADD5[capacity - 5]);\n+        case 6: return ret + (capacity <= 4 ? 0 : capacity > 54 ? 25 : ADD6[capacity - 5]);\n+        case 7: return ret + (capacity <= 4 ? 0 : capacity > 57 ? 21 : ADD7[capacity - 5]);\n+        case 8: return ret + (capacity <= 9 ? 0 : capacity > 56 ? 10 : ADD8[capacity - 10]);\n+        case 9: return ret + (capacity <= 11 ? 0 : capacity > 54 ? 5 : ADD9[capacity - 12]);\n+        case 10: return ret + (capacity <= 21 ? 0 : capacity > 50 ? 2 : (0x1a6665545555041 >> 2 * (capacity - 22)) & 3);\n+        case 11: return ret + (capacity <= 21 ? 0 : capacity > 45 ? 1 : (0x5b3dc1 >> (capacity - 22)) & 1);\n+        case 12: return ret + (capacity <= 21 ? 0 : capacity > 57 ? 0 : (0xe65522041 >> (capacity - 22)) & 1);\n+        case 13: return ret + (capacity <= 27 ? 0 : capacity > 55 ? 0 : (0x8904081 >> (capacity - 28)) & 1);\n+        case 14: return ret + (capacity <= 47 ? 0 : capacity > 48 ? 0 : 1);\n+        default: return ret;\n+    }\n+}\n+\n+size_t ComputeCapacity(uint32_t bits, size_t max_elements, uint32_t fpbits) {\n+    if (bits == 0) return 0;\n+    uint64_t base_fpbits = BaseFPBits(bits, max_elements);\n+    // The fpbits provided by the base max_elements==capacity case are sufficient.\n+    if (base_fpbits >= fpbits) return max_elements;\n+    // Otherwise, increment capacity by ceil(fpbits / bits) beyond that.\n+    return max_elements + (fpbits - base_fpbits + bits - 1) / bits;\n+}\n+\n+size_t ComputeMaxElements(uint32_t bits, size_t capacity, uint32_t fpbits) {\n+    if (bits == 0) return 0;\n+    // Start with max_elements=capacity, and decrease max_elements until the corresponding capacity is capacity.\n+    size_t max_elements = capacity;\n+    while (true) {\n+        size_t capacity_for_max_elements = ComputeCapacity(bits, max_elements, fpbits);\n+        CHECK_SAFE(capacity_for_max_elements >= capacity);\n+        if (capacity_for_max_elements <= capacity) return max_elements;\n+        size_t adjust = capacity_for_max_elements - capacity;\n+        // Decrementing max_elements by N will at most decrement the corresponding capacity by N.\n+        // As the observed capacity is adjust too high, we can safely decrease max_elements by adjust.\n+        // If that brings us into negative max_elements territory, no solution exists and we return 0.\n+        if (max_elements < adjust) return 0;\n+        max_elements -= adjust;\n+    }\n+}\n+\n+}  // namespace\n+\n+#endif"
      },
      {
        "sha": "5fe60f7f5a434125e53c8a37270486ee1cb92a5f",
        "filename": "src/minisketch/src/fields/clmul_1byte.cpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_1byte.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_1byte.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_1byte.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,87 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 2 bit field\n+typedef RecLinTrans<uint8_t, 2> StatTableTRI2;\n+constexpr StatTableTRI2 SQR_TABLE_TRI2({0x1, 0x3});\n+constexpr StatTableTRI2 QRT_TABLE_TRI2({0x2, 0});\n+typedef FieldTri<uint8_t, 2, 1, StatTableTRI2, &SQR_TABLE_TRI2, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI2, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri2;\n+\n+// 3 bit field\n+typedef RecLinTrans<uint8_t, 3> StatTableTRI3;\n+constexpr StatTableTRI3 SQR_TABLE_TRI3({0x1, 0x4, 0x6});\n+constexpr StatTableTRI3 QRT_TABLE_TRI3({0, 0x4, 0x6});\n+typedef FieldTri<uint8_t, 3, 1, StatTableTRI3, &SQR_TABLE_TRI3, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI3, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri3;\n+\n+// 4 bit field\n+typedef RecLinTrans<uint8_t, 4> StatTableTRI4;\n+constexpr StatTableTRI4 SQR_TABLE_TRI4({0x1, 0x4, 0x3, 0xc});\n+constexpr StatTableTRI4 QRT_TABLE_TRI4({0x6, 0xa, 0x8, 0});\n+typedef FieldTri<uint8_t, 4, 1, StatTableTRI4, &SQR_TABLE_TRI4, nullptr, nullptr, nullptr, nullptr, &QRT_TABLE_TRI4, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri4;\n+\n+// 5 bit field\n+typedef RecLinTrans<uint8_t, 5> StatTable5;\n+constexpr StatTable5 SQR_TABLE_5({0x1, 0x4, 0x10, 0xa, 0xd});\n+constexpr StatTable5 SQR2_TABLE_5({0x1, 0x10, 0xd, 0xe, 0x1b});\n+constexpr StatTable5 QRT_TABLE_5({0x14, 0x8, 0xa, 0, 0xe});\n+typedef Field<uint8_t, 5, 5, StatTable5, &SQR_TABLE_5, &SQR2_TABLE_5, nullptr, nullptr, nullptr, &QRT_TABLE_5, IdTrans, &ID_TRANS, &ID_TRANS> Field5;\n+typedef FieldTri<uint8_t, 5, 2, RecLinTrans<uint8_t, 5>, &SQR_TABLE_5, &SQR2_TABLE_5, nullptr, nullptr, nullptr, &QRT_TABLE_5, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri5;\n+\n+// 6 bit field\n+typedef RecLinTrans<uint8_t, 6> StatTableTRI6;\n+constexpr StatTableTRI6 SQR_TABLE_TRI6({0x1, 0x4, 0x10, 0x3, 0xc, 0x30});\n+constexpr StatTableTRI6 SQR2_TABLE_TRI6({0x1, 0x10, 0xc, 0x5, 0x13, 0x3c});\n+constexpr StatTableTRI6 QRT_TABLE_TRI6({0x3a, 0x26, 0x24, 0x14, 0x20, 0});\n+typedef FieldTri<uint8_t, 6, 1, StatTableTRI6, &SQR_TABLE_TRI6, &SQR2_TABLE_TRI6, nullptr, nullptr, nullptr, &QRT_TABLE_TRI6, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri6;\n+\n+// 7 bit field\n+typedef RecLinTrans<uint8_t, 4, 3> StatTableTRI7;\n+constexpr StatTableTRI7 SQR_TABLE_TRI7({0x1, 0x4, 0x10, 0x40, 0x6, 0x18, 0x60});\n+constexpr StatTableTRI7 SQR2_TABLE_TRI7({0x1, 0x10, 0x6, 0x60, 0x14, 0x46, 0x78});\n+constexpr StatTableTRI7 QRT_TABLE_TRI7({0, 0x14, 0x16, 0x72, 0x12, 0x40, 0x7a});\n+typedef FieldTri<uint8_t, 7, 1, StatTableTRI7, &SQR_TABLE_TRI7, &SQR2_TABLE_TRI7, nullptr, nullptr, nullptr, &QRT_TABLE_TRI7, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri7;\n+\n+// 8 bit field\n+typedef RecLinTrans<uint8_t, 4, 4> StatTable8;\n+constexpr StatTable8 SQR_TABLE_8({0x1, 0x4, 0x10, 0x40, 0x1b, 0x6c, 0xab, 0x9a});\n+constexpr StatTable8 SQR2_TABLE_8({0x1, 0x10, 0x1b, 0xab, 0x5e, 0x97, 0xb3, 0xc5});\n+constexpr StatTable8 QRT_TABLE_8({0xbc, 0x2a, 0x28, 0x86, 0x2c, 0xde, 0x8e, 0});\n+typedef Field<uint8_t, 8, 27, StatTable8, &SQR_TABLE_8, &SQR2_TABLE_8, nullptr, nullptr, nullptr, &QRT_TABLE_8, IdTrans, &ID_TRANS, &ID_TRANS> Field8;\n+\n+}\n+\n+Sketch* ConstructClMul1Byte(int bits, int implementation) {\n+    switch (bits) {\n+    case 5: return new SketchImpl<Field5>(implementation, 5);\n+    case 8: return new SketchImpl<Field8>(implementation, 8);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri1Byte(int bits, int implementation) {\n+    switch (bits) {\n+    case 2: return new SketchImpl<FieldTri2>(implementation, 2);\n+    case 3: return new SketchImpl<FieldTri3>(implementation, 3);\n+    case 4: return new SketchImpl<FieldTri4>(implementation, 4);\n+    case 5: return new SketchImpl<FieldTri5>(implementation, 5);\n+    case 6: return new SketchImpl<FieldTri6>(implementation, 6);\n+    case 7: return new SketchImpl<FieldTri7>(implementation, 7);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "4329c221a1d6a215a466c9723dabf918736ef183",
        "filename": "src/minisketch/src/fields/clmul_2bytes.cpp",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_2bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_2bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_2bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,112 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 9 bit field\n+typedef RecLinTrans<uint16_t, 5, 4> StatTableTRI9;\n+constexpr StatTableTRI9 SQR_TABLE_TRI9({0x1, 0x4, 0x10, 0x40, 0x100, 0x6, 0x18, 0x60, 0x180});\n+constexpr StatTableTRI9 SQR2_TABLE_TRI9({0x1, 0x10, 0x100, 0x18, 0x180, 0x14, 0x140, 0x1e, 0x1e0});\n+constexpr StatTableTRI9 SQR4_TABLE_TRI9({0x1, 0x180, 0x1e0, 0x198, 0x1fe, 0x80, 0xa0, 0x88, 0xaa});\n+constexpr StatTableTRI9 QRT_TABLE_TRI9({0, 0x4e, 0x4c, 0x1aa, 0x48, 0x22, 0x1a2, 0x100, 0x58});\n+typedef FieldTri<uint16_t, 9, 1, StatTableTRI9, &SQR_TABLE_TRI9, &SQR2_TABLE_TRI9, &SQR4_TABLE_TRI9, nullptr, nullptr, &QRT_TABLE_TRI9, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri9;\n+\n+// 10 bit field\n+typedef RecLinTrans<uint16_t, 5, 5> StatTable10;\n+constexpr StatTable10 SQR_TABLE_10({0x1, 0x4, 0x10, 0x40, 0x100, 0x9, 0x24, 0x90, 0x240, 0x112});\n+constexpr StatTable10 SQR2_TABLE_10({0x1, 0x10, 0x100, 0x24, 0x240, 0x41, 0x19, 0x190, 0x136, 0x344});\n+constexpr StatTable10 SQR4_TABLE_10({0x1, 0x240, 0x136, 0x141, 0x35d, 0x18, 0x265, 0x2e6, 0x227, 0x36b});\n+constexpr StatTable10 QRT_TABLE_10({0xec, 0x86, 0x84, 0x30e, 0x80, 0x3c2, 0x306, 0, 0x90, 0x296});\n+typedef Field<uint16_t, 10, 9, StatTable10, &SQR_TABLE_10, &SQR2_TABLE_10, &SQR4_TABLE_10, nullptr, nullptr, &QRT_TABLE_10, IdTrans, &ID_TRANS, &ID_TRANS> Field10;\n+typedef FieldTri<uint16_t, 10, 3, RecLinTrans<uint16_t, 5, 5>, &SQR_TABLE_10, &SQR2_TABLE_10, &SQR4_TABLE_10, nullptr, nullptr, &QRT_TABLE_10, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri10;\n+\n+// 11 bit field\n+typedef RecLinTrans<uint16_t, 6, 5> StatTable11;\n+constexpr StatTable11 SQR_TABLE_11({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0xa, 0x28, 0xa0, 0x280, 0x205});\n+constexpr StatTable11 SQR2_TABLE_11({0x1, 0x10, 0x100, 0xa, 0xa0, 0x205, 0x44, 0x440, 0x428, 0x2a8, 0x291});\n+constexpr StatTable11 SQR4_TABLE_11({0x1, 0xa0, 0x428, 0x1a, 0x645, 0x3a9, 0x144, 0x2d5, 0x9e, 0x4e7, 0x649});\n+constexpr StatTable11 QRT_TABLE_11({0x734, 0x48, 0x4a, 0x1de, 0x4e, 0x35e, 0x1d6, 0x200, 0x5e, 0, 0x37e});\n+typedef Field<uint16_t, 11, 5, StatTable11, &SQR_TABLE_11, &SQR2_TABLE_11, &SQR4_TABLE_11, nullptr, nullptr, &QRT_TABLE_11, IdTrans, &ID_TRANS, &ID_TRANS> Field11;\n+typedef FieldTri<uint16_t, 11, 2, RecLinTrans<uint16_t, 6, 5>, &SQR_TABLE_11, &SQR2_TABLE_11, &SQR4_TABLE_11, nullptr, nullptr, &QRT_TABLE_11, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri11;\n+\n+// 12 bit field\n+typedef RecLinTrans<uint16_t, 6, 6> StatTable12;\n+constexpr StatTable12 SQR_TABLE_12({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x9, 0x24, 0x90, 0x240, 0x900, 0x412});\n+constexpr StatTable12 SQR2_TABLE_12({0x1, 0x10, 0x100, 0x9, 0x90, 0x900, 0x41, 0x410, 0x124, 0x249, 0x482, 0x804});\n+constexpr StatTable12 SQR4_TABLE_12({0x1, 0x90, 0x124, 0x8, 0x480, 0x920, 0x40, 0x412, 0x924, 0x200, 0x82, 0x904});\n+constexpr StatTable12 QRT_TABLE_12({0x48, 0xc10, 0xc12, 0x208, 0xc16, 0xd82, 0x200, 0x110, 0xc06, 0, 0xda2, 0x5a4});\n+typedef Field<uint16_t, 12, 9, StatTable12, &SQR_TABLE_12, &SQR2_TABLE_12, &SQR4_TABLE_12, nullptr, nullptr, &QRT_TABLE_12, IdTrans, &ID_TRANS, &ID_TRANS> Field12;\n+typedef FieldTri<uint16_t, 12, 3, RecLinTrans<uint16_t, 6, 6>, &SQR_TABLE_12, &SQR2_TABLE_12, &SQR4_TABLE_12, nullptr, nullptr, &QRT_TABLE_12, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri12;\n+\n+// 13 bit field\n+typedef RecLinTrans<uint16_t, 5, 4, 4> StatTable13;\n+constexpr StatTable13 SQR_TABLE_13({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x36, 0xd8, 0x360, 0xd80, 0x161b, 0x185a});\n+constexpr StatTable13 SQR2_TABLE_13({0x1, 0x10, 0x100, 0x1000, 0xd8, 0xd80, 0x185a, 0x514, 0x1176, 0x17b8, 0x1b75, 0x17ff, 0x1f05});\n+constexpr StatTable13 SQR4_TABLE_13({0x1, 0xd8, 0x1176, 0x1f05, 0xd96, 0x18e8, 0x68, 0xbdb, 0x1a61, 0x1af2, 0x1a37, 0x3b9, 0x1440});\n+constexpr StatTable13 QRT_TABLE_13({0xcfc, 0x1500, 0x1502, 0x382, 0x1506, 0x149c, 0x38a, 0x118, 0x1516, 0, 0x14bc, 0x100e, 0x3ca});\n+typedef Field<uint16_t, 13, 27, StatTable13, &SQR_TABLE_13, &SQR2_TABLE_13, &SQR4_TABLE_13, nullptr, nullptr, &QRT_TABLE_13, IdTrans, &ID_TRANS, &ID_TRANS> Field13;\n+\n+// 14 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 4> StatTable14;\n+constexpr StatTable14 SQR_TABLE_14({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x442, 0x1108});\n+constexpr StatTable14 SQR2_TABLE_14({0x1, 0x10, 0x100, 0x1000, 0x84, 0x840, 0x442, 0x401, 0x31, 0x310, 0x3100, 0x118c, 0x1844, 0x486});\n+constexpr StatTable14 SQR4_TABLE_14({0x1, 0x84, 0x31, 0x1844, 0x501, 0x15ce, 0x3552, 0x3101, 0x8c5, 0x3a5, 0x1cf3, 0xd74, 0xc8a, 0x3411});\n+constexpr StatTable14 QRT_TABLE_14({0x13f2, 0x206, 0x204, 0x3e06, 0x200, 0x1266, 0x3e0e, 0x114, 0x210, 0, 0x1246, 0x2848, 0x3e4e, 0x2258});\n+typedef Field<uint16_t, 14, 33, StatTable14, &SQR_TABLE_14, &SQR2_TABLE_14, &SQR4_TABLE_14, nullptr, nullptr, &QRT_TABLE_14, IdTrans, &ID_TRANS, &ID_TRANS> Field14;\n+typedef FieldTri<uint16_t, 14, 5, RecLinTrans<uint16_t, 5, 5, 4>, &SQR_TABLE_14, &SQR2_TABLE_14, &SQR4_TABLE_14, nullptr, nullptr, &QRT_TABLE_14, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri14;\n+\n+// 15 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 5> StatTableTRI15;\n+constexpr StatTableTRI15 SQR_TABLE_TRI15({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000});\n+constexpr StatTableTRI15 SQR2_TABLE_TRI15({0x1, 0x10, 0x100, 0x1000, 0x6, 0x60, 0x600, 0x6000, 0x14, 0x140, 0x1400, 0x4006, 0x78, 0x780, 0x7800});\n+constexpr StatTableTRI15 SQR4_TABLE_TRI15({0x1, 0x6, 0x14, 0x78, 0x110, 0x660, 0x1540, 0x7f80, 0x106, 0x614, 0x1478, 0x7910, 0x1666, 0x7554, 0x3ffe});\n+constexpr StatTableTRI15 QRT_TABLE_TRI15({0, 0x114, 0x116, 0x428, 0x112, 0x137a, 0x420, 0x6d62, 0x102, 0x73a, 0x135a, 0x6460, 0x460, 0x4000, 0x6de2});\n+typedef FieldTri<uint16_t, 15, 1, StatTableTRI15, &SQR_TABLE_TRI15, &SQR2_TABLE_TRI15, &SQR4_TABLE_TRI15, nullptr, nullptr, &QRT_TABLE_TRI15, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri15;\n+\n+// 16 bit field\n+typedef RecLinTrans<uint16_t, 6, 5, 5> StatTable16;\n+constexpr StatTable16 SQR_TABLE_16({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x2b, 0xac, 0x2b0, 0xac0, 0x2b00, 0xac00, 0xb056, 0xc10e});\n+constexpr StatTable16 SQR2_TABLE_16({0x1, 0x10, 0x100, 0x1000, 0x2b, 0x2b0, 0x2b00, 0xb056, 0x445, 0x4450, 0x45ac, 0x5a6c, 0xa647, 0x657e, 0x571a, 0x7127});\n+constexpr StatTable16 SQR4_TABLE_16({0x1, 0x2b, 0x445, 0xa647, 0x12a1, 0xf69d, 0x7f07, 0x9825, 0x6fad, 0x399d, 0xb515, 0xd7d1, 0x3fb4, 0x4b06, 0xe4df, 0x93c7});\n+constexpr StatTable16 QRT_TABLE_16({0x732, 0x72b8, 0x72ba, 0x7e96, 0x72be, 0x78b2, 0x7e9e, 0x8cba, 0x72ae, 0xfa24, 0x7892, 0x5892, 0x7ede, 0xbec6, 0x8c3a, 0});\n+typedef Field<uint16_t, 16, 43, StatTable16, &SQR_TABLE_16, &SQR2_TABLE_16, &SQR4_TABLE_16, nullptr, nullptr, &QRT_TABLE_16, IdTrans, &ID_TRANS, &ID_TRANS> Field16;\n+\n+}\n+\n+Sketch* ConstructClMul2Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 10: return new SketchImpl<Field10>(implementation, 10);\n+    case 11: return new SketchImpl<Field11>(implementation, 11);\n+    case 12: return new SketchImpl<Field12>(implementation, 12);\n+    case 13: return new SketchImpl<Field13>(implementation, 13);\n+    case 14: return new SketchImpl<Field14>(implementation, 14);\n+    case 16: return new SketchImpl<Field16>(implementation, 16);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri2Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 9: return new SketchImpl<FieldTri9>(implementation, 9);\n+    case 10: return new SketchImpl<FieldTri10>(implementation, 10);\n+    case 11: return new SketchImpl<FieldTri11>(implementation, 11);\n+    case 12: return new SketchImpl<FieldTri12>(implementation, 12);\n+    case 14: return new SketchImpl<FieldTri14>(implementation, 14);\n+    case 15: return new SketchImpl<FieldTri15>(implementation, 15);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "23d29f7b50084d043ab1d557a8c9a7c5ab0982f2",
        "filename": "src/minisketch/src/fields/clmul_3bytes.cpp",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_3bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_3bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_3bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,122 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 17 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5> StatTable17;\n+constexpr StatTable17 SQR_TABLE_17({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x8012});\n+constexpr StatTable17 SQR2_TABLE_17({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x48, 0x480, 0x4800, 0x8012, 0x104, 0x1040, 0x10400, 0x4048, 0x492, 0x4920, 0x9212, 0x12104});\n+constexpr StatTable17 SQR4_TABLE_17({0x1, 0x10000, 0x8012, 0x4048, 0x12104, 0x1480, 0x5840, 0x14d20, 0x19202, 0x8112, 0x44c8, 0x13144, 0x5da0, 0x15850, 0x1cd7a, 0x1d34e, 0x1a484});\n+constexpr StatTable17 SQR8_TABLE_17({0x1, 0x1a484, 0x1f24a, 0x1d572, 0x1eec4, 0x15448, 0xf9de, 0x9af0, 0x1ab78, 0x6048, 0xdc9a, 0x1eb24, 0x2ef4, 0x7c5e, 0x170b2, 0x16c1a, 0xa660});\n+constexpr StatTable17 QRT_TABLE_17({0, 0x4c3e, 0x4c3c, 0x1a248, 0x4c38, 0x428, 0x1a240, 0x1b608, 0x4c28, 0x206, 0x408, 0x4000, 0x1a200, 0x18006, 0x1b688, 0x14d2e, 0x4d28});\n+typedef Field<uint32_t, 17, 9, StatTable17, &SQR_TABLE_17, &SQR2_TABLE_17, &SQR4_TABLE_17, &SQR8_TABLE_17, nullptr, &QRT_TABLE_17, IdTrans, &ID_TRANS, &ID_TRANS> Field17;\n+typedef FieldTri<uint32_t, 17, 3, RecLinTrans<uint32_t, 6, 6, 5>, &SQR_TABLE_17, &SQR2_TABLE_17, &SQR4_TABLE_17, &SQR8_TABLE_17, nullptr, &QRT_TABLE_17, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri17;\n+\n+// 18 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6> StatTable18;\n+constexpr StatTable18 SQR_TABLE_18({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x10012});\n+constexpr StatTable18 SQR2_TABLE_18({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x24, 0x240, 0x2400, 0x24000, 0x41, 0x410, 0x4100, 0x1009, 0x10090, 0x924, 0x9240, 0x12412, 0x24104});\n+constexpr StatTable18 SQR4_TABLE_18({0x1, 0x10000, 0x24000, 0x1009, 0x12412, 0x124, 0x201, 0x10480, 0x24820, 0x241, 0x10410, 0x24924, 0x8, 0x12, 0x20024, 0x8048, 0x12082, 0x920});\n+constexpr StatTable18 SQR8_TABLE_18({0x1, 0x12082, 0x20904, 0x1000, 0x92, 0x904, 0x240, 0x12012, 0x4104, 0x41, 0x10080, 0x4924, 0x1009, 0x2412, 0x24804, 0x9240, 0x12410, 0x20});\n+constexpr StatTable18 QRT_TABLE_18({0x9208, 0x422, 0x420, 0x8048, 0x424, 0x68b0, 0x8040, 0x30086, 0x434, 0x1040, 0x6890, 0x30ca2, 0x8000, 0x32896, 0x30006, 0, 0x534, 0x20532});\n+typedef Field<uint32_t, 18, 9, StatTable18, &SQR_TABLE_18, &SQR2_TABLE_18, &SQR4_TABLE_18, &SQR8_TABLE_18, nullptr, &QRT_TABLE_18, IdTrans, &ID_TRANS, &ID_TRANS> Field18;\n+typedef FieldTri<uint32_t, 18, 3, RecLinTrans<uint32_t, 6, 6, 6>, &SQR_TABLE_18, &SQR2_TABLE_18, &SQR4_TABLE_18, &SQR8_TABLE_18, nullptr, &QRT_TABLE_18, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri18;\n+\n+// 19 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 4> StatTable19;\n+constexpr StatTable19 SQR_TABLE_19({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x3804e, 0x6011f});\n+constexpr StatTable19 SQR2_TABLE_19({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x4e, 0x4e0, 0x4e00, 0x4e000, 0x6011f, 0x1054, 0x10540, 0x544e, 0x544e0, 0x44f76, 0x4f658, 0x7649f, 0x6481a, 0x48004});\n+constexpr StatTable19 SQR4_TABLE_19({0x1, 0x10000, 0x4e000, 0x544e, 0x7649f, 0x15f0, 0x5afa, 0x35b7d, 0x17dca, 0x7390f, 0x151ae, 0x3902b, 0x41e9c, 0x7f117, 0x23ec7, 0x62c2f, 0x5e852, 0x69238, 0x775c});\n+constexpr StatTable19 SQR8_TABLE_19({0x1, 0x5e852, 0x394a3, 0x29f41, 0x618e5, 0x4210, 0x7add9, 0x31105, 0x5d098, 0x7bb13, 0x44f00, 0x966, 0x11ae6, 0x70901, 0x664bf, 0x67449, 0x3d2bf, 0x4cbf9, 0x54e0c});\n+constexpr StatTable19 QRT_TABLE_19({0x5d6b0, 0x2f476, 0x2f474, 0x1d6a2, 0x2f470, 0x42a, 0x1d6aa, 0x1060, 0x2f460, 0x19e92, 0x40a, 0x1da98, 0x1d6ea, 0x28c78, 0x10e0, 0xf56a, 0x2f560, 0, 0x19c92});\n+typedef Field<uint32_t, 19, 39, StatTable19, &SQR_TABLE_19, &SQR2_TABLE_19, &SQR4_TABLE_19, &SQR8_TABLE_19, nullptr, &QRT_TABLE_19, IdTrans, &ID_TRANS, &ID_TRANS> Field19;\n+\n+// 20 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5> StatTable20;\n+constexpr StatTable20 SQR_TABLE_20({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x40012});\n+constexpr StatTable20 SQR2_TABLE_20({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x9, 0x90, 0x900, 0x9000, 0x90000, 0x41, 0x410, 0x4100, 0x41000, 0x10024, 0x249, 0x2490, 0x24900, 0x49012, 0x90104});\n+constexpr StatTable20 SQR4_TABLE_20({0x1, 0x10000, 0x9000, 0x4100, 0x2490, 0x1001, 0x10900, 0x9410, 0x4349, 0x92594, 0x91, 0x10041, 0x19024, 0x4d112, 0x2599, 0x91091, 0x51941, 0x3dd34, 0x5d34b, 0x9b494});\n+constexpr StatTable20 SQR8_TABLE_20({0x1, 0x51941, 0x880b5, 0x66d0, 0x46103, 0x19025, 0x45a49, 0x8a4b4, 0x80b45, 0x81f9f, 0xb081, 0x41040, 0xd19f5, 0xc11be, 0x4634b, 0xd8d70, 0x11027, 0xf8651, 0x141fa, 0xdc63});\n+constexpr StatTable20 QRT_TABLE_20({0xc5dea, 0xc0110, 0xc0112, 0xe11de, 0xc0116, 0x24814, 0xe11d6, 0x20080, 0xc0106, 0xfe872, 0x24834, 0xe4106, 0xe1196, 0x1d9a4, 0x20000, 0x31190, 0xc0006, 0, 0xfea72, 0x7ea74});\n+typedef Field<uint32_t, 20, 9, StatTable20, &SQR_TABLE_20, &SQR2_TABLE_20, &SQR4_TABLE_20, &SQR8_TABLE_20, nullptr, &QRT_TABLE_20, IdTrans, &ID_TRANS, &ID_TRANS> Field20;\n+typedef FieldTri<uint32_t, 20, 3, RecLinTrans<uint32_t, 5, 5, 5, 5>, &SQR_TABLE_20, &SQR2_TABLE_20, &SQR4_TABLE_20, &SQR8_TABLE_20, nullptr, &QRT_TABLE_20, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri20;\n+\n+// 21 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5> StatTable21;\n+constexpr StatTable21 SQR_TABLE_21({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x80005});\n+constexpr StatTable21 SQR2_TABLE_21({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x28, 0x280, 0x2800, 0x28000, 0x80005, 0x44, 0x440, 0x4400, 0x44000, 0x4000a, 0xaa, 0xaa0, 0xaa00, 0xaa000, 0xa0011});\n+constexpr StatTable21 SQR4_TABLE_21({0x1, 0x10000, 0x2800, 0x440, 0xaa, 0xa0011, 0x101000, 0x28280, 0x4444, 0x40aaa, 0xaa101, 0x128, 0x8002d, 0xc4005, 0x4ea00, 0xba10, 0x101290, 0x1282c4, 0x6c44e, 0xeeeaa, 0xbaaa1});\n+constexpr StatTable21 SQR8_TABLE_21({0x1, 0x101290, 0xc412d, 0x1ab101, 0x986d1, 0x1c6cc5, 0x3aa8c, 0x14b0fe, 0x1e7301, 0xb491d, 0x10d23e, 0xa4015, 0x4c2fa, 0xce8e5, 0xadfd9, 0xf110, 0x5220c, 0xf225f, 0xb8bdb, 0x159467, 0xc0df9});\n+constexpr StatTable21 QRT_TABLE_21({0x1bd5fc, 0xbc196, 0xbc194, 0x74b96, 0xbc190, 0x1048, 0x74b9e, 0x672c8, 0xbc180, 0x4080, 0x1068, 0xc8200, 0x74bde, 0x64280, 0x67248, 0xc4280, 0xbc080, 0x80000, 0x4280, 0, 0x1468});\n+typedef Field<uint32_t, 21, 5, StatTable21, &SQR_TABLE_21, &SQR2_TABLE_21, &SQR4_TABLE_21, &SQR8_TABLE_21, nullptr, &QRT_TABLE_21, IdTrans, &ID_TRANS, &ID_TRANS> Field21;\n+typedef FieldTri<uint32_t, 21, 2, RecLinTrans<uint32_t, 6, 5, 5, 5>, &SQR_TABLE_21, &SQR2_TABLE_21, &SQR4_TABLE_21, &SQR8_TABLE_21, nullptr, &QRT_TABLE_21, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri21;\n+\n+// 22 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5> StatTableTRI22;\n+constexpr StatTableTRI22 SQR_TABLE_TRI22({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000});\n+constexpr StatTableTRI22 SQR2_TABLE_TRI22({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x100003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000});\n+constexpr StatTableTRI22 SQR4_TABLE_TRI22({0x1, 0x10000, 0xc00, 0x50, 0x100003, 0x3c000, 0x1100, 0xcc, 0xc0005, 0x55000, 0x3fc0, 0x101, 0x1000c, 0xc0c00, 0x5050, 0x1003c3, 0x3c011, 0x111100, 0xcccc, 0xc0555, 0x15503f, 0x3fffc0});\n+constexpr StatTableTRI22 SQR8_TABLE_TRI22({0x1, 0x3c011, 0x3ec1, 0x101103, 0x14503e, 0x28282, 0xd0009, 0x1d9c, 0xcc598, 0x25c81, 0x47304, 0xc0004, 0x3cc41, 0xcf758, 0x11415f, 0x1d11f7, 0x128280, 0x1b9027, 0x1070ce, 0x10eb5e, 0x5c0ec, 0x2097e0});\n+constexpr StatTableTRI22 QRT_TABLE_TRI22({0x210d16, 0x104a, 0x1048, 0x4088, 0x104c, 0x200420, 0x4080, 0x492dc, 0x105c, 0x1a67f0, 0x200400, 0x21155c, 0x40c0, 0x20346c, 0x4925c, 0x1af7ac, 0x115c, 0x2274ac, 0x1a65f0, 0x2a65f0, 0x200000, 0});\n+typedef FieldTri<uint32_t, 22, 1, StatTableTRI22, &SQR_TABLE_TRI22, &SQR2_TABLE_TRI22, &SQR4_TABLE_TRI22, &SQR8_TABLE_TRI22, nullptr, &QRT_TABLE_TRI22, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri22;\n+\n+// 23 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5> StatTable23;\n+constexpr StatTable23 SQR_TABLE_23({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x80042, 0x200108});\n+constexpr StatTable23 SQR2_TABLE_23({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x42, 0x420, 0x4200, 0x42000, 0x420000, 0x200108, 0x1004, 0x10040, 0x100400, 0x4042, 0x40420, 0x404200, 0x42108, 0x421080, 0x210908, 0x109004, 0x90002});\n+constexpr StatTable23 SQR4_TABLE_23({0x1, 0x10000, 0x4200, 0x1004, 0x40420, 0x210908, 0x52, 0x520000, 0x142400, 0x52148, 0x494202, 0x10c204, 0x1104, 0x40462, 0x630908, 0x100452, 0x562108, 0x1d2402, 0x57348, 0x495626, 0x34c72c, 0x21584e, 0x4614b0});\n+constexpr StatTable23 SQR8_TABLE_23({0x1, 0x562108, 0x662840, 0x5304, 0x6d3842, 0x738f46, 0x50472, 0x6ff79e, 0x7cf204, 0x436274, 0x3e4bde, 0x42a93e, 0x147704, 0x6c3810, 0x28bff4, 0x78815c, 0x7ab4b0, 0x62852a, 0x255b30, 0x5653d0, 0x1afd36, 0x5f118, 0x601dd4});\n+constexpr StatTable23 QRT_TABLE_23({0, 0x1040, 0x1042, 0x43056, 0x1046, 0x121d76, 0x4305e, 0x40a0, 0x1056, 0x15176, 0x121d56, 0x7ee1f6, 0x4301e, 0x40000, 0x4020, 0x4f0be, 0x1156, 0x7cf0a0, 0x15376, 0x1ee9e8, 0x121956, 0x3ac9f6, 0x7ee9f6});\n+typedef Field<uint32_t, 23, 33, StatTable23, &SQR_TABLE_23, &SQR2_TABLE_23, &SQR4_TABLE_23, &SQR8_TABLE_23, nullptr, &QRT_TABLE_23, IdTrans, &ID_TRANS, &ID_TRANS> Field23;\n+typedef FieldTri<uint32_t, 23, 5, RecLinTrans<uint32_t, 6, 6, 6, 5>, &SQR_TABLE_23, &SQR2_TABLE_23, &SQR4_TABLE_23, &SQR8_TABLE_23, nullptr, &QRT_TABLE_23, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri23;\n+\n+// 24 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6> StatTable24;\n+constexpr StatTable24 SQR_TABLE_24({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0xb0001b, 0xc0005a});\n+constexpr StatTable24 SQR2_TABLE_24({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1b, 0x1b0, 0x1b00, 0x1b000, 0x1b0000, 0xb0001b, 0x145, 0x1450, 0x14500, 0x145000, 0x45001b, 0x5001dc, 0x1db7, 0x1db70, 0x1db700, 0xdb701b, 0xb7011f, 0x701105});\n+constexpr StatTable24 SQR4_TABLE_24({0x1, 0x10000, 0x1b00, 0x145, 0x45001b, 0x1db700, 0x11011, 0x111ab0, 0xb1aa5e, 0x51450e, 0x96db7, 0xb7c60f, 0x1a1a, 0x1a015e, 0x5f5e1b, 0x1ceef2, 0xf30ca2, 0xabbdb4, 0xba1aff, 0xf0bf5e, 0x579fc9, 0xce3da9, 0xa2c07f, 0x71dd40});\n+constexpr StatTable24 SQR8_TABLE_24({0x1, 0xf30ca2, 0x573345, 0xb0a14e, 0xafd77d, 0x1419b, 0xb616a2, 0xba7db, 0xbe1560, 0xe0d0a3, 0x15bf5, 0x1056dd, 0xa29845, 0xf83d32, 0x13e0e9, 0xe2d8d3, 0xa10841, 0x57ac5a, 0x1c432f, 0x57044e, 0x454fba, 0x2bb37c, 0xf50fa, 0x85d5b9});\n+constexpr StatTable24 QRT_TABLE_24({0x104e, 0xaf42a8, 0xaf42aa, 0xb78186, 0xaf42ae, 0x4090, 0xb7818e, 0x4a37c, 0xaf42be, 0x3688c0, 0x40b0, 0x80080e, 0xb781ce, 0xaf2232, 0x4a3fc, 0x856a82, 0xaf43be, 0x29c970, 0x368ac0, 0x968ace, 0x44b0, 0x77d570, 0x80000e, 0});\n+typedef Field<uint32_t, 24, 27, StatTable24, &SQR_TABLE_24, &SQR2_TABLE_24, &SQR4_TABLE_24, &SQR8_TABLE_24, nullptr, &QRT_TABLE_24, IdTrans, &ID_TRANS, &ID_TRANS> Field24;\n+\n+}\n+\n+Sketch* ConstructClMul3Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 17: return new SketchImpl<Field17>(implementation, 17);\n+    case 18: return new SketchImpl<Field18>(implementation, 18);\n+    case 19: return new SketchImpl<Field19>(implementation, 19);\n+    case 20: return new SketchImpl<Field20>(implementation, 20);\n+    case 21: return new SketchImpl<Field21>(implementation, 21);\n+    case 23: return new SketchImpl<Field23>(implementation, 23);\n+    case 24: return new SketchImpl<Field24>(implementation, 24);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri3Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 17: return new SketchImpl<FieldTri17>(implementation, 17);\n+    case 18: return new SketchImpl<FieldTri18>(implementation, 18);\n+    case 20: return new SketchImpl<FieldTri20>(implementation, 20);\n+    case 21: return new SketchImpl<FieldTri21>(implementation, 21);\n+    case 22: return new SketchImpl<FieldTri22>(implementation, 22);\n+    case 23: return new SketchImpl<FieldTri23>(implementation, 23);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "c7615aae53eab180e28b02a30574f9385d340d93",
        "filename": "src/minisketch/src/fields/clmul_4bytes.cpp",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_4bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_4bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_4bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,118 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 25 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5, 5> StatTable25;\n+constexpr StatTable25 SQR_TABLE_25({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x800012});\n+constexpr StatTable25 SQR2_TABLE_25({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x48, 0x480, 0x4800, 0x48000, 0x480000, 0x800012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x400048, 0x492, 0x4920, 0x49200, 0x492000, 0x920012, 0x1200104});\n+constexpr StatTable25 SQR4_TABLE_25({0x1, 0x10000, 0x480, 0x800012, 0x104000, 0x4920, 0x1200104, 0x1001000, 0x48048, 0x481040, 0x410448, 0x492492, 0x930002, 0x580, 0x1800012, 0x14c000, 0x5960, 0x160014c, 0x1493000, 0x58058, 0x5814c0, 0xc14c5a, 0x596596, 0x1974922, 0x1249684});\n+constexpr StatTable25 SQR8_TABLE_25({0x1, 0x5960, 0x1411448, 0x1860922, 0x1d814d2, 0x1cdede8, 0x1e15e16, 0x1b79686, 0xfdf116, 0x1efe4c8, 0x1b839a8, 0x10ced66, 0xae05ce, 0x1459400, 0xa29fa6, 0x85e4d2, 0x7eecee, 0x183a96, 0x1eb2fa8, 0xede876, 0xf6e440, 0x1f7140a, 0xd07d7c, 0x10e4ea2, 0x1222a54});\n+constexpr StatTable25 QRT_TABLE_25({0, 0x482110, 0x482112, 0x1b3c3e6, 0x482116, 0x4960ae, 0x1b3c3ee, 0x4088, 0x482106, 0x58a726, 0x49608e, 0x5ce52e, 0x1b3c3ae, 0x2006, 0x4008, 0x1c1a8, 0x482006, 0x1e96488, 0x58a526, 0x400000, 0x49648e, 0x1800006, 0x5ced2e, 0xb3d3a8, 0x1b3d3ae});\n+typedef Field<uint32_t, 25, 9, StatTable25, &SQR_TABLE_25, &SQR2_TABLE_25, &SQR4_TABLE_25, &SQR8_TABLE_25, nullptr, &QRT_TABLE_25, IdTrans, &ID_TRANS, &ID_TRANS> Field25;\n+typedef FieldTri<uint32_t, 25, 3, RecLinTrans<uint32_t, 5, 5, 5, 5, 5>, &SQR_TABLE_25, &SQR2_TABLE_25, &SQR4_TABLE_25, &SQR8_TABLE_25, nullptr, &QRT_TABLE_25, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri25;\n+\n+// 26 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5> StatTable26;\n+constexpr StatTable26 SQR_TABLE_26({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x2c0001b, 0x300005a});\n+constexpr StatTable26 SQR2_TABLE_26({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x6c, 0x6c0, 0x6c00, 0x6c000, 0x6c0000, 0x2c0001b, 0x145, 0x1450, 0x14500, 0x145000, 0x1450000, 0x500077, 0x100076b, 0x76dc, 0x76dc0, 0x76dc00, 0x36dc01b, 0x2dc011f, 0x1c01105});\n+constexpr StatTable26 SQR4_TABLE_26({0x1, 0x10000, 0x6c0, 0x2c0001b, 0x145000, 0x76dc, 0x2dc011f, 0x1101100, 0x106ac6c, 0x6ad515, 0x1145127, 0x121b6dc, 0x2da1d0f, 0x10007c1, 0x3c7c01b, 0x128290, 0x29062e0, 0x2ee8d68, 0x167abcd, 0x3cabbce, 0x3c7a862, 0x6b83ce, 0x3cf5620, 0x229b787, 0x38a6b0f, 0x3071ade});\n+constexpr StatTable26 SQR8_TABLE_26({0x1, 0x29062e0, 0x2b2942d, 0x34ab63, 0x3bddebb, 0x7b1823, 0x58b9ae, 0x391720e, 0x1385e18, 0x3891746, 0x13069c5, 0x2dfd089, 0x12a35ff, 0x3e534f, 0x172c6a2, 0x55338f, 0x3887137, 0x3f45b03, 0x164a695, 0x2c7e7ef, 0x29c907d, 0x636c85, 0x3db4007, 0x97e7ff, 0x3cbfe55, 0x31c0d96});\n+constexpr StatTable26 QRT_TABLE_26({0x217b530, 0x2ae82a8, 0x2ae82aa, 0x2001046, 0x2ae82ae, 0x2de032e, 0x200104e, 0x70c10c, 0x2ae82be, 0x20151f2, 0x2de030e, 0xbc1400, 0x200100e, 0x178570, 0x70c18c, 0x2ae4232, 0x2ae83be, 0x211d742, 0x20153f2, 0x21f54f2, 0x2de070e, 0x5e0700, 0xbc1c00, 0x3abb97e, 0x200000e, 0});\n+typedef Field<uint32_t, 26, 27, StatTable26, &SQR_TABLE_26, &SQR2_TABLE_26, &SQR4_TABLE_26, &SQR8_TABLE_26, nullptr, &QRT_TABLE_26, IdTrans, &ID_TRANS, &ID_TRANS> Field26;\n+\n+// 27 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5> StatTable27;\n+constexpr StatTable27 SQR_TABLE_27({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x380004e, 0x600011f});\n+constexpr StatTable27 SQR2_TABLE_27({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x4e, 0x4e0, 0x4e00, 0x4e000, 0x4e0000, 0x4e00000, 0x600011f, 0x1054, 0x10540, 0x105400, 0x1054000, 0x54004e, 0x54004e0, 0x4004f76, 0x4f658, 0x4f6580, 0x4f65800, 0x765811f, 0x658101a, 0x5810004});\n+constexpr StatTable27 SQR4_TABLE_27({0x1, 0x10000, 0x4e0, 0x4e00000, 0x105400, 0x4004f76, 0x765811f, 0x1001110, 0x114e04e, 0x4abe54, 0x6551445, 0x45e212e, 0x13ccbdc, 0x3d805ef, 0x5e10100, 0x114b0e0, 0xe4bf22, 0x721c505, 0x51b3ba8, 0x3bf04d5, 0x4dabba0, 0x3b0aa45, 0x24a80cb, 0xc3d4b0, 0x4b34626, 0x6372e18, 0x6028c1b});\n+constexpr StatTable27 SQR8_TABLE_27({0x1, 0xe4bf22, 0x430cb3c, 0x73b7225, 0x6526539, 0x3c278e3, 0x4724a6e, 0x48b39b4, 0x1dbf7de, 0x106508, 0x3564785, 0x33ae33f, 0x61d6685, 0x6adaca3, 0x2786b6f, 0x4e76784, 0x869f42, 0x466b048, 0x415e00e, 0x46c3c9a, 0x73ffd91, 0x49002e0, 0x3734fed, 0x3c04a43, 0x191d3ee, 0xe828b9, 0xfab68c});\n+constexpr StatTable27 QRT_TABLE_27({0x6bf0530, 0x2be4496, 0x2be4494, 0x2bf0522, 0x2be4490, 0x1896cca, 0x2bf052a, 0x408a, 0x2be4480, 0x368ae72, 0x1896cea, 0x18d2ee0, 0x2bf056a, 0x1c76d6a, 0x400a, 0x336e9f8, 0x2be4580, 0x36baf12, 0x368ac72, 0x430360, 0x18968ea, 0x34a6b80, 0x18d26e0, 0xbf1560, 0x2bf156a, 0, 0x1c74d6a});\n+typedef Field<uint32_t, 27, 39, StatTable27, &SQR_TABLE_27, &SQR2_TABLE_27, &SQR4_TABLE_27, &SQR8_TABLE_27, nullptr, &QRT_TABLE_27, IdTrans, &ID_TRANS, &ID_TRANS> Field27;\n+\n+// 28 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5, 5> StatTableTRI28;\n+constexpr StatTableTRI28 SQR_TABLE_TRI28({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000});\n+constexpr StatTableTRI28 SQR2_TABLE_TRI28({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x3, 0x30, 0x300, 0x3000, 0x30000, 0x300000, 0x3000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0xf, 0xf0, 0xf00, 0xf000, 0xf0000, 0xf00000, 0xf000000});\n+constexpr StatTableTRI28 SQR4_TABLE_TRI28({0x1, 0x10000, 0x30, 0x300000, 0x500, 0x5000000, 0xf000, 0x11, 0x110000, 0x330, 0x3300000, 0x5500, 0x500000f, 0xff000, 0x101, 0x1010000, 0x3030, 0x300005, 0x50500, 0x50000f0, 0xf0f000, 0x1111, 0x1110003, 0x33330, 0x3300055, 0x555500, 0x5000fff, 0xffff000});\n+constexpr StatTableTRI28 SQR8_TABLE_TRI28({0x1, 0x3030, 0x5000500, 0xf0e111, 0x3210000, 0x6300faa, 0x40ef10e, 0x501, 0xf0c030, 0x5110630, 0x395b444, 0x621010e, 0x6010f9b, 0x13bc4cb, 0x110001, 0x3303065, 0xff50f, 0xf0e120, 0x3243530, 0x330fabb, 0x5ec232c, 0x511050e, 0x3c1c064, 0x2ec60a, 0x3954175, 0x7c5c43d, 0x20acba, 0x943bc43});\n+constexpr StatTableTRI28 QRT_TABLE_TRI28({0x121d57a, 0x40216, 0x40214, 0x8112578, 0x40210, 0x10110, 0x8112570, 0x12597ec, 0x40200, 0x6983e00, 0x10130, 0x972b99c, 0x8112530, 0x8002000, 0x125976c, 0x815a76c, 0x40300, 0x936b29c, 0x6983c00, 0x97bb8ac, 0x10530, 0x9103000, 0x972b19c, 0xf6384ac, 0x8113530, 0x4113530, 0x8000000, 0});\n+typedef FieldTri<uint32_t, 28, 1, StatTableTRI28, &SQR_TABLE_TRI28, &SQR2_TABLE_TRI28, &SQR4_TABLE_TRI28, &SQR8_TABLE_TRI28, nullptr, &QRT_TABLE_TRI28, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri28;\n+\n+// 29 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 5> StatTable29;\n+constexpr StatTable29 SQR_TABLE_29({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x8000005});\n+constexpr StatTable29 SQR2_TABLE_29({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x28, 0x280, 0x2800, 0x28000, 0x280000, 0x2800000, 0x8000005, 0x44, 0x440, 0x4400, 0x44000, 0x440000, 0x4400000, 0x400000a, 0xaa, 0xaa0, 0xaa00, 0xaa000, 0xaa0000, 0xaa00000, 0xa000011});\n+constexpr StatTable29 SQR4_TABLE_29({0x1, 0x10000, 0x28, 0x280000, 0x440, 0x4400000, 0xaa00, 0xa000011, 0x101000, 0x10000280, 0x2828000, 0x4444, 0x444000a, 0xaaaa0, 0xaa00101, 0x1000100, 0x1002800, 0x8002805, 0x8044005, 0x440aa, 0xaa00aa, 0xaa1010, 0x10101010, 0x10128280, 0x28282c4, 0x2c44444, 0x4444eaa, 0xeaaaaaa, 0xaaba001});\n+constexpr StatTable29 SQR8_TABLE_29({0x1, 0x1002800, 0x4680000, 0xae50ba, 0x2822a00, 0x14545eba, 0x110aed64, 0xc6eeaaf, 0x4ee00a0, 0x10aba290, 0x1bd6efc1, 0x8222b29, 0x1c791ebf, 0x174e85da, 0x1cc66c7f, 0x29292c4, 0x2886c20, 0xea04467, 0xc0eeb87, 0xccd4115, 0x16d5fa2e, 0x1cf8fe75, 0xe45a4e1, 0x19018b3f, 0x1d64778, 0x2e0bdf8, 0xa1bd96b, 0xff5b70e, 0x14d89770});\n+constexpr StatTable29 QRT_TABLE_29({0x1b8351dc, 0xb87135e, 0xb87135c, 0xda7b35e, 0xb871358, 0x621a116, 0xda7b356, 0x40200, 0xb871348, 0xc9e2620, 0x621a136, 0x478b16, 0xda7b316, 0x6762e20, 0x40280, 0x6202000, 0xb871248, 0x627a316, 0xc9e2420, 0xcd1ad36, 0x621a536, 0x760e20, 0x478316, 0xa760e20, 0xda7a316, 0x8000000, 0x6760e20, 0, 0x44280});\n+typedef Field<uint32_t, 29, 5, StatTable29, &SQR_TABLE_29, &SQR2_TABLE_29, &SQR4_TABLE_29, &SQR8_TABLE_29, nullptr, &QRT_TABLE_29, IdTrans, &ID_TRANS, &ID_TRANS> Field29;\n+typedef FieldTri<uint32_t, 29, 2, RecLinTrans<uint32_t, 6, 6, 6, 6, 5>, &SQR_TABLE_29, &SQR2_TABLE_29, &SQR4_TABLE_29, &SQR8_TABLE_29, nullptr, &QRT_TABLE_29, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri29;\n+\n+// 30 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 6> StatTableTRI30;\n+constexpr StatTableTRI30 SQR_TABLE_TRI30({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000});\n+constexpr StatTableTRI30 SQR2_TABLE_TRI30({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0xc00000, 0xc000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x10000003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000, 0x3c00000, 0x3c000000});\n+constexpr StatTableTRI30 SQR4_TABLE_TRI30({0x1, 0x10000, 0xc, 0xc0000, 0x50, 0x500000, 0x3c0, 0x3c00000, 0x1100, 0x11000000, 0xcc00, 0xc000005, 0x55000, 0x1000003f, 0x3fc000, 0x101, 0x1010000, 0xc0c, 0xc0c0000, 0x5050, 0x10500003, 0x3c3c0, 0x3c00011, 0x111100, 0x110000cc, 0xcccc00, 0xc000555, 0x5555000, 0x10003fff, 0x3fffc000});\n+constexpr StatTableTRI30 SQR8_TABLE_TRI30({0x1, 0x1010000, 0xc000c, 0xc0c5050, 0x390, 0x13900012, 0x12c012c0, 0x121ddddd, 0x54100, 0x1003f33, 0xc3f0d04, 0x9555558, 0xd379000, 0x105d3fa2, 0x1d615e9e, 0x1101, 0x100100cc, 0xc0ccc09, 0x5590505, 0x3a9390, 0x3913fec, 0x13fedfcd, 0x121ddd8c, 0x11544103, 0x2cc3cff, 0x3e24c45, 0x9558bc8, 0x3a7958b, 0x1e98b158, 0x29d629e9});\n+constexpr StatTableTRI30 QRT_TABLE_TRI30({0x2159df4a, 0x109134a, 0x1091348, 0x10114, 0x109134c, 0x3a203420, 0x1011c, 0x20004080, 0x109135c, 0x2005439c, 0x3a203400, 0x100400, 0x1015c, 0x3eb21930, 0x20004000, 0x20504c00, 0x109125c, 0x3b2b276c, 0x2005419c, 0x210450c0, 0x3a203000, 0x3e93186c, 0x100c00, 0x3aa23530, 0x1115c, 0x6b3286c, 0x3eb23930, 0xeb23930, 0x20000000, 0});\n+typedef FieldTri<uint32_t, 30, 1, StatTableTRI30, &SQR_TABLE_TRI30, &SQR2_TABLE_TRI30, &SQR4_TABLE_TRI30, &SQR8_TABLE_TRI30, nullptr, &QRT_TABLE_TRI30, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri30;\n+\n+// 31 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5> StatTable31;\n+constexpr StatTable31 SQR_TABLE_31({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x20000012});\n+constexpr StatTable31 SQR2_TABLE_31({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x12, 0x120, 0x1200, 0x12000, 0x120000, 0x1200000, 0x12000000, 0x20000012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x10400000, 0x4000012, 0x40000120, 0x1248, 0x12480, 0x124800, 0x1248000, 0x12480000, 0x24800012, 0x48000104});\n+constexpr StatTable31 SQR4_TABLE_31({0x1, 0x10000, 0x12, 0x120000, 0x104, 0x1040000, 0x1248, 0x12480000, 0x10010, 0x100012, 0x120120, 0x1200104, 0x1041040, 0x10401248, 0x12492480, 0x24810002, 0x112, 0x1120000, 0x1304, 0x13040000, 0x11648, 0x16480012, 0x134810, 0x48100116, 0x1121120, 0x11201304, 0x13053040, 0x3041165a, 0x16596492, 0x64934922, 0x49248016});\n+constexpr StatTable31 SQR8_TABLE_31({0x1, 0x112, 0x10104, 0x1131648, 0x10002, 0x1120224, 0x106021a, 0x146e3f86, 0x16, 0x174c, 0x161658, 0x175b1130, 0x16002c, 0x174c2e98, 0x16742dfc, 0x3f877966, 0x114, 0x10768, 0x1151050, 0x66b75b2, 0x1140228, 0x76a0ec2, 0x127a33da, 0x79648102, 0x1738, 0x1665f0, 0x172f64e0, 0x73cc668c, 0x17382e70, 0x65dccaac, 0x4abf956e});\n+constexpr StatTable31 QRT_TABLE_31({0, 0x10110, 0x10112, 0x15076e, 0x10116, 0x117130e, 0x150766, 0x4743fa0, 0x10106, 0x1121008, 0x117132e, 0x176b248e, 0x150726, 0x172a2c88, 0x4743f20, 0x7eb81e86, 0x10006, 0x20008, 0x1121208, 0x56b2c8e, 0x117172e, 0x133f1bae, 0x176b2c8e, 0x7f2a0c8e, 0x151726, 0x10000000, 0x172a0c88, 0x60000006, 0x4747f20, 0x3eb89e80, 0x7eb89e86});\n+typedef Field<uint32_t, 31, 9, StatTable31, &SQR_TABLE_31, &SQR2_TABLE_31, &SQR4_TABLE_31, &SQR8_TABLE_31, nullptr, &QRT_TABLE_31, IdTrans, &ID_TRANS, &ID_TRANS> Field31;\n+typedef FieldTri<uint32_t, 31, 3, RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_31, &SQR2_TABLE_31, &SQR4_TABLE_31, &SQR8_TABLE_31, nullptr, &QRT_TABLE_31, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri31;\n+\n+// 32 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5, 5> StatTable32;\n+constexpr StatTable32 SQR_TABLE_32({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x8d, 0x234, 0x8d0, 0x2340, 0x8d00, 0x23400, 0x8d000, 0x234000, 0x8d0000, 0x2340000, 0x8d00000, 0x23400000, 0x8d000000, 0x3400011a, 0xd0000468, 0x40001037});\n+constexpr StatTable32 SQR2_TABLE_32({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x8d, 0x8d0, 0x8d00, 0x8d000, 0x8d0000, 0x8d00000, 0x8d000000, 0xd0000468, 0x4051, 0x40510, 0x405100, 0x4051000, 0x40510000, 0x5100234, 0x51002340, 0x100236b9, 0x236b1d, 0x236b1d0, 0x236b1d00, 0x36b1d11a, 0x6b1d1037, 0xb1d1005e, 0x1d10001f, 0xd100017d});\n+constexpr StatTable32 SQR4_TABLE_32({0x1, 0x10000, 0x8d, 0x8d0000, 0x4051, 0x40510000, 0x236b1d, 0x6b1d1037, 0x10001101, 0x1109d000, 0xd00859e5, 0x59881468, 0x144737e8, 0x37e2c4e3, 0xc4f9a67a, 0xa61d8c55, 0x8c010001, 0x41dc8d, 0xdc8d23cd, 0x23a60c51, 0xc41630e, 0x63087fcd, 0x7ffe7368, 0x735580f6, 0x80cd8e29, 0x8e6fe311, 0xe350f32b, 0xf35edc90, 0xdced0bd6, 0xbbd3eb1, 0x3eb4a621, 0xa63f6bc4});\n+constexpr StatTable32 SQR8_TABLE_32({0x1, 0x8c010001, 0x6b9010bb, 0x7faf6b, 0xc4da8d37, 0xc10ab646, 0x445f546c, 0xe389129e, 0xd8aa2d3e, 0x85249468, 0xd599253f, 0x458976f9, 0xc9c86411, 0xccc2f34b, 0xa79e37dc, 0x9068e3c4, 0x3a30447f, 0x674c3398, 0x94f38a7, 0x402d3532, 0x116fffc7, 0x1c6b5ba2, 0xcd6a32e4, 0x49067a77, 0xa7f6a61e, 0x3cc3746, 0xeebe962e, 0x599276e1, 0x7b5fa4d9, 0x2aa3ce1, 0x990f8767, 0x1c3b66cb});\n+constexpr StatTable32 QRT_TABLE_32({0x54fd1264, 0xc26fcd64, 0xc26fcd66, 0x238a7462, 0xc26fcd62, 0x973bccaa, 0x238a746a, 0x77766712, 0xc26fcd72, 0xc1bdd556, 0x973bcc8a, 0x572a094c, 0x238a742a, 0xb693be84, 0x77766792, 0x9555c03e, 0xc26fcc72, 0x568419f8, 0xc1bdd756, 0x96c3d2ca, 0x973bc88a, 0x54861fdc, 0x572a014c, 0xb79badc4, 0x238a642a, 0xb9b99fe0, 0xb6939e84, 0xc519fa86, 0x77762792, 0, 0x9555403e, 0x377627ba});\n+typedef Field<uint32_t, 32, 141, StatTable32, &SQR_TABLE_32, &SQR2_TABLE_32, &SQR4_TABLE_32, &SQR8_TABLE_32, nullptr, &QRT_TABLE_32, IdTrans, &ID_TRANS, &ID_TRANS> Field32;\n+\n+}\n+\n+Sketch* ConstructClMul4Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 25: return new SketchImpl<Field25>(implementation, 25);\n+    case 26: return new SketchImpl<Field26>(implementation, 26);\n+    case 27: return new SketchImpl<Field27>(implementation, 27);\n+    case 29: return new SketchImpl<Field29>(implementation, 29);\n+    case 31: return new SketchImpl<Field31>(implementation, 31);\n+    case 32: return new SketchImpl<Field32>(implementation, 32);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri4Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 25: return new SketchImpl<FieldTri25>(implementation, 25);\n+    case 28: return new SketchImpl<FieldTri28>(implementation, 28);\n+    case 29: return new SketchImpl<FieldTri29>(implementation, 29);\n+    case 30: return new SketchImpl<FieldTri30>(implementation, 30);\n+    case 31: return new SketchImpl<FieldTri31>(implementation, 31);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "305c9cdff74c4c0aca5c99c1d79e5bc7718b83f4",
        "filename": "src/minisketch/src/fields/clmul_5bytes.cpp",
        "status": "added",
        "additions": 130,
        "deletions": 0,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_5bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_5bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_5bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,130 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 33 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5> StatTable33;\n+constexpr StatTable33 SQR_TABLE_33({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x802, 0x2008, 0x8020, 0x20080, 0x80200, 0x200800, 0x802000, 0x2008000, 0x8020000, 0x20080000, 0x80200000, 0x800401, 0x2001004, 0x8004010, 0x20010040, 0x80040100});\n+constexpr StatTable33 SQR2_TABLE_33({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x2008, 0x20080, 0x200800, 0x2008000, 0x20080000, 0x800401, 0x8004010, 0x80040100, 0x400004, 0x4000040, 0x40000400, 0x4802, 0x48020, 0x480200, 0x4802000, 0x48020000, 0x80200802, 0x2009024, 0x20090240, 0x902001, 0x9020010, 0x90200100, 0x102000004, 0x20002048});\n+constexpr StatTable33 SQR4_TABLE_33({0x1, 0x10000, 0x100000000, 0x2008000, 0x80040100, 0x4802, 0x48020000, 0x902001, 0x20002048, 0x20081000, 0x10400004, 0x248820, 0x88204812, 0x49020410, 0x4822081, 0x20880641, 0x6000044, 0x480300, 0x3009024, 0x90220180, 0xa00c11, 0xc104050, 0x40482608, 0x2688b024, 0xb0690344, 0x102248834, 0x8a30c912, 0xc8062518, 0x24886803, 0x684a0244, 0x294a025, 0xa020294a, 0x280a1010});\n+constexpr StatTable33 SQR8_TABLE_33({0x1, 0x6000044, 0x280a1010, 0x122ac8e75, 0x83209926, 0x4a7a8a1, 0xcada863d, 0x6f2ab824, 0x6b4a8654, 0x70484bd6, 0x164c04e0b, 0x2fbc1617, 0xe095e5a3, 0xeaf7847d, 0xe5625e26, 0xa6aaa3e5, 0xc0164126, 0xd06217c0, 0x1ae58d21, 0xa8600250, 0xbaf87951, 0x8e12c19a, 0xa9b413b9, 0xb75ef087, 0x17e9214d9, 0x85968f33, 0x1e299478f, 0x92bc9a0f, 0x1975d642, 0x11af0b3f1, 0x4e86ee77, 0xe75f4726, 0x38026cce});\n+constexpr StatTable33 SQR16_TABLE_33({0x1, 0x185df5e91, 0x193fb40eb, 0xd464f9e4, 0x1ba2d73a6, 0x1d9288c5e, 0x5de03a49, 0x1869ea37b, 0x13faaf379, 0x195d1a8f5, 0x6afd5625, 0xf9d75bab, 0xaf44fe50, 0x101034b9e, 0xcc889caf, 0x5ec7455, 0x7d232a66, 0x17dcfe2c3, 0x1c66ff8d0, 0x17107e836, 0x1939cdead, 0x9852afa0, 0x1b946909a, 0x1846638c5, 0xdd5fa94c, 0x1cb2600fe, 0x19241c856, 0x15fe05ccd, 0xc9f9a425, 0x89e0f463, 0x37b01b39, 0xab0410e0, 0x1ace4ca03});\n+constexpr StatTable33 QRT_TABLE_33({0xba504dd4, 0x1e2798ef2, 0x1e2798ef0, 0x6698a4ec, 0x1e2798ef4, 0x1c7f1bef0, 0x6698a4e4, 0x16da1b384, 0x1e2798ee4, 0x661ca6ec, 0x1c7f1bed0, 0x1483b87a6, 0x6698a4a4, 0x800000, 0x16da1b304, 0x1a185101c, 0x1e2798fe4, 0xaa400954, 0x661ca4ec, 0x667caeec, 0x1c7f1bad0, 0x400800, 0x1483b8fa6, 0, 0x6698b4a4, 0x1c61da4b8, 0x802000, 0x16e5dadec, 0x16da1f304, 0x62fc8eec, 0x1a185901c, 0x1661da5ec, 0x1e2788fe4});\n+typedef Field<uint64_t, 33, 1025, StatTable33, &SQR_TABLE_33, &SQR2_TABLE_33, &SQR4_TABLE_33, &SQR8_TABLE_33, &SQR16_TABLE_33, &QRT_TABLE_33, IdTrans, &ID_TRANS, &ID_TRANS> Field33;\n+typedef FieldTri<uint64_t, 33, 10, RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_33, &SQR2_TABLE_33, &SQR4_TABLE_33, &SQR8_TABLE_33, &SQR16_TABLE_33, &QRT_TABLE_33, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri33;\n+\n+// 34 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5> StatTable34;\n+constexpr StatTable34 SQR_TABLE_34({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x10000102, 0x40000408, 0x100001020});\n+constexpr StatTable34 SQR2_TABLE_34({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x204, 0x2040, 0x20400, 0x204000, 0x2040000, 0x20400000, 0x204000000, 0x40000408, 0x4001, 0x40010, 0x400100, 0x4001000, 0x40010000, 0x100081, 0x1000810, 0x10008100, 0x100081000, 0x810204, 0x8102040, 0x81020400, 0x10204102, 0x102041020, 0x20410004, 0x204100040, 0x41000008});\n+constexpr StatTable34 SQR4_TABLE_34({0x1, 0x10000, 0x100000000, 0x204000, 0x40000408, 0x4001000, 0x10008100, 0x81020400, 0x204100040, 0x304, 0x3040000, 0x6041, 0x60410000, 0x1000c1010, 0x10304183, 0x4181020c, 0x102042060, 0x20400001, 0x50010, 0x100100081, 0xa14204, 0x142041428, 0x14001001, 0x10038500, 0x385020400, 0x204704140, 0x41000f1c, 0xf143040, 0x3041e145, 0x1e1430410, 0x3042c5050, 0x5030448b, 0x4481120c, 0x112048120});\n+constexpr StatTable34 SQR8_TABLE_34({0x1, 0x102042060, 0x4481120c, 0x1523455ab, 0x307081050, 0x21410f1c, 0x275d0e309, 0x3f676408a, 0x143a54d38, 0x304100344, 0x181774550, 0x1003cd092, 0x3f36b6421, 0x164d51695, 0x3e7c7f2ab, 0x9309b234, 0x354f8d24c, 0x1f5431410, 0x142012478, 0xc5225409, 0x14033f3cf, 0x123bd530c, 0x1100ee58, 0x35490c368, 0x2e1f3dcba, 0x2018108d2, 0x3c61a735d, 0xbf8fa918, 0x282ab07ea, 0x19c32af, 0x175e54c02, 0x2e4dfe2bb, 0x3374ab928, 0x3124a055});\n+constexpr StatTable34 SQR16_TABLE_34({0x1, 0x3448e6f02, 0x352590eb9, 0xb173da17, 0x264977d39, 0x172d45e48, 0x1e026e5d6, 0x357b54017, 0x2925d27a4, 0x1f6a32696, 0x2f49f220c, 0x3a7383d9e, 0x28111d79b, 0x5580fcf1, 0x276ede679, 0x175b379f8, 0x34d67b66, 0xc7019416, 0x3f3d9d59f, 0x2a7c2c032, 0x2b3482ba7, 0x177cd0128, 0x1d6f4bd2e, 0x31647a632, 0x41353027, 0x56292eea, 0x2733c0501, 0x6d7ed066, 0x2f3db9a75, 0x3225bc5cc, 0x3f22da089, 0xd0a7588e, 0xb60b22d1, 0xc2fddb7e});\n+constexpr StatTable34 QRT_TABLE_34({0x2f973a1f6, 0x40202, 0x40200, 0x348102060, 0x40204, 0x8000420, 0x348102068, 0x1092195c8, 0x40214, 0x3f6881b6e, 0x8000400, 0x3f810383e, 0x348102028, 0x340002068, 0x109219548, 0x24015a774, 0x40314, 0x3f050343e, 0x3f688196e, 0x3f81c3a3a, 0x8000000, 0x24031a560, 0x3f810303e, 0xb08c1a12, 0x348103028, 0xb2881906, 0x340000068, 0, 0x10921d548, 0x2e131e576, 0x240152774, 0x18921d55e, 0x50314, 0x14015271c});\n+typedef Field<uint64_t, 34, 129, StatTable34, &SQR_TABLE_34, &SQR2_TABLE_34, &SQR4_TABLE_34, &SQR8_TABLE_34, &SQR16_TABLE_34, &QRT_TABLE_34, IdTrans, &ID_TRANS, &ID_TRANS> Field34;\n+typedef FieldTri<uint64_t, 34, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5>, &SQR_TABLE_34, &SQR2_TABLE_34, &SQR4_TABLE_34, &SQR8_TABLE_34, &SQR16_TABLE_34, &QRT_TABLE_34, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri34;\n+\n+// 35 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5> StatTable35;\n+constexpr StatTable35 SQR_TABLE_35({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x28000000, 0xa0000000, 0x280000000, 0x200000005});\n+constexpr StatTable35 SQR2_TABLE_35({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0xa, 0xa0, 0xa00, 0xa000, 0xa0000, 0xa00000, 0xa000000, 0xa0000000, 0x200000005, 0x44, 0x440, 0x4400, 0x44000, 0x440000, 0x4400000, 0x44000000, 0x440000000, 0x400000028, 0x2a8, 0x2a80, 0x2a800, 0x2a8000, 0x2a80000, 0x2a800000, 0x2a8000000, 0x280000011});\n+constexpr StatTable35 SQR4_TABLE_35({0x1, 0x10000, 0x100000000, 0xa000, 0xa0000000, 0x4400, 0x44000000, 0x2a80, 0x2a800000, 0x1010, 0x10100000, 0xa0a, 0xa0a0000, 0x200000445, 0x4444000, 0x4400002a8, 0x2aaa800, 0x2a8000101, 0x1000100, 0x10000a0, 0xa000a0, 0xa00044, 0x440044, 0x400440028, 0x4002a8028, 0x2802a8011, 0x280101011, 0x1010100a, 0x100a0a0a, 0x20a0a0a05, 0x20a044445, 0x444444440, 0x44442aaa8, 0x2aaaaaaa8, 0x2aaa90001});\n+constexpr StatTable35 SQR8_TABLE_35({0x1, 0x2aaa800, 0x44442aaa8, 0x6400006ed, 0x64e4e4e45, 0x14544000, 0x8a145454, 0x2000034df, 0x49a749a36, 0xaa0a0000, 0x10aa0aaa, 0x1ba1a, 0x393a91ba, 0x3febaaaa9, 0x285105155, 0xa0ad9ad4, 0x269ce8d3b, 0x4de74f4e6, 0x42aaa8028, 0x4002aeea8, 0x400e46eec, 0x544e4006c, 0x145440144, 0x2abede545, 0x44309e74c, 0xa74eeda4, 0x64444ee49, 0x1aa1aaaa, 0x2b90bb1b1, 0x393902109, 0x16bc47bb2, 0x271ad1511, 0x6c8f98767, 0x69d3aa74c, 0x27790dc3b});\n+constexpr StatTable35 SQR16_TABLE_35({0x1, 0x4c80f98a4, 0x763684437, 0x5a1cc86a0, 0x38922db8, 0x71755e12d, 0x2ca94c627, 0x388a2bc7f, 0x406596de0, 0x1818c6958, 0x174a92efe, 0x1a80c764e, 0x2f23eacbf, 0xd611ea8, 0x64d783fd5, 0x4fdfe0798, 0x31459de8d, 0x62c889d99, 0x9c419962, 0x2d8d865b3, 0x1ac7e7ffc, 0x38a0c12f3, 0x9fbc1076, 0x6f76d3b89, 0x6e472c757, 0x5f240de42, 0x10176ecc0, 0x20c1cef8, 0x8f77f91c, 0x3f6e533b9, 0x62017c147, 0x5ce81e2fa, 0x371fe4ad9, 0x2552b5046, 0xc3f3696c});\n+constexpr StatTable35 QRT_TABLE_35({0x5c2038114, 0x2bf547ee8, 0x2bf547eea, 0x2bf1074e8, 0x2bf547eee, 0x1883d0736, 0x2bf1074e0, 0x100420, 0x2bf547efe, 0x400800, 0x1883d0716, 0x5e90e4a0, 0x2bf1074a0, 0x4e70ac20, 0x1004a0, 0x2f060c880, 0x2bf547ffe, 0x37d55fffe, 0x400a00, 0x3372573de, 0x1883d0316, 0x700c20, 0x5e90eca0, 0x10604880, 0x2bf1064a0, 0x18f35377e, 0x4e708c20, 0x33f557ffe, 0x1044a0, 0x1bf557ffe, 0x2f0604880, 0x200000000, 0x2bf557ffe, 0, 0x37d57fffe});\n+typedef Field<uint64_t, 35, 5, StatTable35, &SQR_TABLE_35, &SQR2_TABLE_35, &SQR4_TABLE_35, &SQR8_TABLE_35, &SQR16_TABLE_35, &QRT_TABLE_35, IdTrans, &ID_TRANS, &ID_TRANS> Field35;\n+typedef FieldTri<uint64_t, 35, 2, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_35, &SQR2_TABLE_35, &SQR4_TABLE_35, &SQR8_TABLE_35, &SQR16_TABLE_35, &QRT_TABLE_35, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri35;\n+\n+// 36 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6> StatTable36;\n+constexpr StatTable36 SQR_TABLE_36({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x10000402, 0x40001008, 0x100004020, 0x400010080});\n+constexpr StatTable36 SQR2_TABLE_36({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x201, 0x2010, 0x20100, 0x201000, 0x2010000, 0x20100000, 0x201000000, 0x10000402, 0x100004020, 0x40001, 0x400010, 0x4000100, 0x40001000, 0x400010000, 0x100804, 0x1008040, 0x10080400, 0x100804000, 0x8040201, 0x80402010, 0x804020100, 0x40200008, 0x402000080, 0x20000004, 0x200000040, 0x2, 0x20});\n+constexpr StatTable36 SQR4_TABLE_36({0x1, 0x10000, 0x100000000, 0x201000, 0x10000402, 0x4000100, 0x1008040, 0x80402010, 0x20000004, 0x200, 0x2000000, 0x4020, 0x40200000, 0x80002, 0x800020000, 0x201008000, 0x80400010, 0x4, 0x40000, 0x400000000, 0x804000, 0x40001008, 0x10000400, 0x4020100, 0x201008040, 0x80000010, 0x800, 0x8000000, 0x10080, 0x100800000, 0x200008, 0x80402, 0x804020000, 0x201000040, 0x10, 0x100000});\n+constexpr StatTable36 SQR8_TABLE_36({0x1, 0x80400010, 0x804020000, 0x201008, 0x2000080, 0x20000804, 0x1008000, 0x402, 0x800000, 0x200, 0x80000010, 0x804020100, 0x40201000, 0x400010000, 0x100004, 0x201000000, 0x80400, 0x100000000, 0x40000, 0x10, 0x804000100, 0x40201008, 0x2010080, 0x20000800, 0x200008040, 0x10080000, 0x4020, 0x8000000, 0x2000, 0x800000100, 0x40200008, 0x402010000, 0x100804, 0x1000040, 0x10000402, 0x804000});\n+constexpr StatTable36 SQR16_TABLE_36({0x1, 0x402000000, 0x100800020, 0x201000, 0x10080402, 0x800000000, 0x1008040, 0x400000, 0x20000800, 0x200, 0x400010080, 0x100000020, 0x40200000, 0x10080002, 0x20100, 0x201008000, 0x80000000, 0x100804, 0x40000, 0x2000080, 0x20, 0x40001008, 0x10000002, 0x4020000, 0x201008040, 0x2010, 0x20100800, 0x8000000, 0x400010000, 0x4000, 0x200008, 0x2, 0x804000000, 0x201000040, 0x402000, 0x20100804});\n+constexpr StatTable36 QRT_TABLE_36({0x40200, 0x8b0526186, 0x8b0526184, 0x240001000, 0x8b0526180, 0xcb6894d94, 0x240001008, 0xdb6880c22, 0x8b0526190, 0x8000200, 0xcb6894db4, 0x500424836, 0x240001048, 0x406cb2834, 0xdb6880ca2, 0x241200008, 0x8b0526090, 0xdb05021a6, 0x8000000, 0xdb01829b2, 0xcb68949b4, 0x1001000, 0x500424036, 0x106116406, 0x240000048, 0xcb29968a4, 0x406cb0834, 0, 0xdb6884ca2, 0x110010516, 0x241208008, 0x430434520, 0x8b0536090, 0x41208040, 0xdb05221a6, 0xb6884d14});\n+typedef Field<uint64_t, 36, 513, StatTable36, &SQR_TABLE_36, &SQR2_TABLE_36, &SQR4_TABLE_36, &SQR8_TABLE_36, &SQR16_TABLE_36, &QRT_TABLE_36, IdTrans, &ID_TRANS, &ID_TRANS> Field36;\n+typedef FieldTri<uint64_t, 36, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_36, &SQR2_TABLE_36, &SQR4_TABLE_36, &SQR8_TABLE_36, &SQR16_TABLE_36, &QRT_TABLE_36, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri36;\n+\n+// 37 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 5, 5, 5, 5, 5> StatTable37;\n+constexpr StatTable37 SQR_TABLE_37({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0xa6, 0x298, 0xa60, 0x2980, 0xa600, 0x29800, 0xa6000, 0x298000, 0xa60000, 0x2980000, 0xa600000, 0x29800000, 0xa6000000, 0x298000000, 0xa60000000, 0x980000053, 0x60000011f, 0x180000047c});\n+constexpr StatTable37 SQR2_TABLE_37({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x298, 0x2980, 0x29800, 0x298000, 0x2980000, 0x29800000, 0x298000000, 0x980000053, 0x180000047c, 0x4414, 0x44140, 0x441400, 0x4414000, 0x44140000, 0x441400000, 0x4140000a6, 0x140000ac6, 0x140000ac60, 0xac43e, 0xac43e0, 0xac43e00, 0xac43e000, 0xac43e0000, 0xc43e0011f, 0x43e00101a, 0x3e0010106, 0x1e00101033});\n+constexpr StatTable37 SQR4_TABLE_37({0x1, 0x10000, 0x100000000, 0x29800, 0x298000000, 0x44140, 0x441400000, 0xac43e, 0xac43e0000, 0x1e00101033, 0x1010011000, 0x11029a980, 0x9a982b1d3, 0x2b1c45014, 0x4501005f2, 0x1005f8ef80, 0x18efa98941, 0x9897de117, 0x1de10002ad, 0x2990398, 0x190398047c, 0x180443dee4, 0x3ded94ac6, 0x194ac071fa, 0x71c56e1a, 0x56e1adff2, 0x1adffa1690, 0x1a16a9ab31, 0x9ab0957cf, 0x957d85468, 0x18547edba2, 0x1edb9fc515, 0x1fc526c1a4, 0x6c1956aab, 0x156aa5b9d4, 0x5b9f59def, 0x159de6d961});\n+constexpr StatTable37 SQR8_TABLE_37({0x1, 0x18efa98941, 0x1fc526c1a4, 0x11352e16c4, 0xba7aa5340, 0x17346e075f, 0xe91c746aa, 0xe560ac1bd, 0xa4544c5d9, 0x11bd3c631f, 0xd70c4b63c, 0xfe77d107c, 0x10548e5288, 0x1183954fb3, 0x19b3aa4bb, 0x782a2943c, 0x1c19ba61de, 0x6ad01fe38, 0xa22701577, 0xb96546ca0, 0x1d7c6c8b9c, 0xffef807e2, 0x16fcc14dc2, 0x110cc4e83c, 0xc3a35629a, 0x1062330476, 0xb2e5d1de1, 0x1ca4e3d229, 0x67826b51b, 0xe7e4c36e7, 0x59f1ac963, 0x12777f22c6, 0x13963d623a, 0x9e305ac92, 0x219b91d13, 0x175bebeb0d, 0xc6b7b5572});\n+constexpr StatTable37 SQR16_TABLE_37({0x1, 0xcb88f2f8b, 0x1a2a0be7af, 0xb93048ada, 0x113ed92190, 0xc95a18e2b, 0x1e1cd4a85b, 0x19584a1a66, 0x1b947c28c2, 0x1b52b48e27, 0xe64e7b169, 0x14a256d011, 0xda657196d, 0x1947c1dcb4, 0x18b2fa3851, 0xae3d4171a, 0x658f1f4b9, 0x91852c314, 0x69346cf8e, 0x8224bf36c, 0x1086c810ed, 0x10419bc782, 0x57d6a4e36, 0xfbb31a43e, 0x18b502de05, 0x786795174, 0x1de0f1b7f3, 0x1d456b87dc, 0x1aabb2f3bc, 0xc5b80ef0c, 0x1ce4fd7543, 0x7ca740ca1, 0x29eaec26a, 0x1eb0b42043, 0xca3b2b17, 0x3453101c1, 0x1714c59187});\n+constexpr StatTable37 QRT_TABLE_37({0xa3c62e7ba, 0xdc7a0c16a, 0xdc7a0c168, 0x12f7484546, 0xdc7a0c16c, 0xa9803a20, 0x12f748454e, 0xda07064a4, 0xdc7a0c17c, 0x123908de8e, 0xa9803a00, 0x122a888a8e, 0x12f748450e, 0x6790add8, 0xda0706424, 0x12e0a0384c, 0xdc7a0c07c, 0xcb28a2c2, 0x123908dc8e, 0xd09f85e86, 0xa9803e00, 0x124d682b6e, 0x122a88828e, 0x1738711a, 0x12f748550e, 0x73035b8, 0x67908dd8, 0xa0702438, 0xda0702424, 0xe0a0b860, 0x12e0a0b84c, 0x1c7a1c060, 0xdc7a1c07c, 0, 0xcb2aa2c2, 0x100000002c, 0x12390cdc8e});\n+typedef Field<uint64_t, 37, 83, StatTable37, &SQR_TABLE_37, &SQR2_TABLE_37, &SQR4_TABLE_37, &SQR8_TABLE_37, &SQR16_TABLE_37, &QRT_TABLE_37, IdTrans, &ID_TRANS, &ID_TRANS> Field37;\n+\n+// 38 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5> StatTable38;\n+constexpr StatTable38 SQR_TABLE_38({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x2300000063, 0xc0000014a, 0x3000000528});\n+constexpr StatTable38 SQR2_TABLE_38({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x18c, 0x18c0, 0x18c00, 0x18c000, 0x18c0000, 0x18c00000, 0x18c000000, 0x18c0000000, 0xc0000014a, 0x1405, 0x14050, 0x140500, 0x1405000, 0x14050000, 0x140500000, 0x1405000000, 0x500001ef, 0x500001ef0, 0x100001ef63, 0x1ef7bc, 0x1ef7bc0, 0x1ef7bc00, 0x1ef7bc000, 0x1ef7bc0000, 0x2f7bc00129, 0x37bc00112d, 0x3bc0011027, 0x3c00110022});\n+constexpr StatTable38 SQR4_TABLE_38({0x1, 0x10000, 0x100000000, 0x18c00, 0x18c000000, 0x14050, 0x140500000, 0x100001ef63, 0x1ef7bc000, 0x3bc0011027, 0x110001100, 0x110194c0, 0x194c0194c, 0x194d5455, 0xd5455154f, 0x151544a193, 0x4a18c631f, 0xc6319c6ca, 0x19c6c00014, 0x18c8d, 0x18c8d0000, 0xd00014096, 0x1409ddc00, 0x1ddc01efc6, 0x1efd5ab90, 0x15ab9110e1, 0x1110fe85b2, 0x3e85ab5465, 0x2b5445c97a, 0x5c9450993, 0x50994148f, 0x141488b12a, 0x8b134ee36, 0x34ee3a8ecc, 0x3a8ee3edc8, 0x23edeef7ed, 0x2ef7de8bf9, 0x1e8bc14041});\n+constexpr StatTable38 SQR8_TABLE_38({0x1, 0x4a18c631f, 0x8b134ee36, 0x10b5c9474c, 0x3330e98ecb, 0x939897650, 0xd74b026b9, 0x860251dd9, 0x3afbe829b4, 0x3ae6afc308, 0x239ecafe00, 0x2acbc94749, 0x3a5770e19e, 0x4052e180b, 0x321fa15712, 0x3a8a4869ef, 0x1948598082, 0x3b1bd98542, 0xc1deb9112, 0x1b5c9242e, 0x338ba58e8b, 0x8abe06d20, 0x145bb1d2a9, 0x1d6e10fbf0, 0x197d522629, 0x2ff1bbe50d, 0xcc1594a16, 0xc94db1b03, 0x3b20e51c56, 0x101d1e5d07, 0x19472478f7, 0x269635a968, 0x2fd4a35802, 0x1b63e116b6, 0x19fdf9d22a, 0x2ef0e4d419, 0x3e80f730f4, 0x29869b04b9});\n+constexpr StatTable38 SQR16_TABLE_38({0x1, 0x3f5fe2afaa, 0x4216541b5, 0x33b362f56a, 0x9d630d7e1, 0x11127694c1, 0x3f8daab2d6, 0x153ca20edc, 0x22a747a3de, 0xc6ab16040, 0x19cc9a7e37, 0x449d96001, 0x45a7e7c46, 0x36d11561ce, 0x114b93f52a, 0x42a87f1b3, 0x23112a30bc, 0x400df9212, 0x3aca9544df, 0x140c4b0bcf, 0x2ae2efa6d3, 0x2f7051159c, 0x19cca2f62e, 0x102023d8c0, 0xccc793f0b, 0x2ff4789b55, 0x339e4cd9ba, 0x2b02ab5052, 0x8c1b5db82, 0x2e461e4e32, 0xd93541605, 0x1acf12087, 0x33b88dca2b, 0x1e91723c8b, 0xd81047b2b, 0x2e5e54b97c, 0x85bb507d8, 0x2145b1864b});\n+constexpr StatTable38 QRT_TABLE_38({0x34b0ac6430, 0x2223262fa, 0x2223262f8, 0x35554405fe, 0x2223262fc, 0x355514098a, 0x35554405f6, 0x400840, 0x2223262ec, 0x1777726532, 0x35551409aa, 0x15c06fc0, 0x35554405b6, 0x1f5303fec, 0x4008c0, 0x236a21030, 0x2223263ec, 0x1a9008c00, 0x1777726732, 0x3692c60ab6, 0x3555140daa, 0x15556007ee, 0x15c067c0, 0x14a0b030f2, 0x35554415b6, 0x227c06d168, 0x1f5301fec, 0x16c3928fc2, 0x4048c0, 0x3a942c4c0, 0x236a29030, 0x1636a2902e, 0x2223363ec, 0x3a6e898276, 0x1a9028c00, 0x6de74eb2c, 0x1777766732, 0});\n+typedef Field<uint64_t, 38, 99, StatTable38, &SQR_TABLE_38, &SQR2_TABLE_38, &SQR4_TABLE_38, &SQR8_TABLE_38, &SQR16_TABLE_38, &QRT_TABLE_38, IdTrans, &ID_TRANS, &ID_TRANS> Field38;\n+\n+// 39 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5> StatTable39;\n+constexpr StatTable39 SQR_TABLE_39({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x800000011, 0x2000000044});\n+constexpr StatTable39 SQR2_TABLE_39({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x22, 0x220, 0x2200, 0x22000, 0x220000, 0x2200000, 0x22000000, 0x220000000, 0x2200000000, 0x2000000044, 0x404, 0x4040, 0x40400, 0x404000, 0x4040000, 0x40400000, 0x404000000, 0x4040000000, 0x400000088, 0x4000000880, 0x8888, 0x88880, 0x888800, 0x8888000, 0x88880000, 0x888800000, 0x888000011, 0x880000101, 0x800001001});\n+constexpr StatTable39 SQR4_TABLE_39({0x1, 0x10000, 0x100000000, 0x2200, 0x22000000, 0x404, 0x4040000, 0x400000088, 0x888800, 0x888000011, 0x100010, 0x1000100000, 0x1000022000, 0x220022000, 0x220004040, 0x40404040, 0x4040400880, 0x4008888880, 0x888888101, 0x881000001, 0x122, 0x1220000, 0x2200000022, 0x260400, 0x2604000000, 0x48c88, 0x48c880000, 0x800009889, 0x98881000, 0x810001221, 0x12201220, 0x2012200264, 0x2002604264, 0x6042604044, 0x604048c8c4, 0x48c8c8c880, 0x48c8898881, 0x988888881, 0x888802201});\n+constexpr StatTable39 SQR8_TABLE_39({0x1, 0x4040400880, 0x2002604264, 0xaa8022011, 0x810049ea9, 0x100100010, 0xc04008101, 0x644048ea4c, 0x18c1764441, 0x60f8e8526c, 0x22000122, 0x48c88989a3, 0xae0032001, 0x2a7aeafae5, 0x6a76641225, 0x2036245242, 0x3e9ab0308b, 0x1c49f6fe41, 0x681b069e2d, 0x4edee8cae5, 0x898c04, 0x660daa8880, 0x69cae9ccc1, 0x4881320991, 0xd06280001, 0x1cc8c8e3d9, 0x445fc65628, 0x4c889a8a49, 0x300b8caeec, 0x50d842fc94, 0x1811acb89d, 0x9d22101c, 0x2025aa407e, 0x20370a744a, 0x3cf77cb80b, 0x54a13e66e7, 0x34c17e2e04, 0x5c19fe54c1, 0x6a72cc767d});\n+constexpr StatTable39 SQR16_TABLE_39({0x1, 0x37214861ce, 0x689e897065, 0x5678d6ee60, 0x619da834c4, 0x28352752d3, 0x14fed69ec6, 0x5b3d4aa637, 0x682fb8da4d, 0x2ce48c5615, 0x1591ac539c, 0x72d4fbcd0, 0x346b547296, 0x1e7065d419, 0x4e6eb48571, 0x26615d4c2c, 0x60d1c6122e, 0x78d0e2a2eb, 0x52bb3e2980, 0x3c2592d0ab, 0x701ba76b58, 0x5fdf53b685, 0x57cfd2d120, 0x75559e4344, 0x3837a46907, 0x15f961a4ce, 0x397b9a03e9, 0x5a8dd4ab69, 0x3a6ab3356f, 0x215d39c25e, 0x5bbaf82443, 0x6759e3c88c, 0x3c0b862ca1, 0x37eec7e79e, 0x6ce865e38, 0x4a56a338c0, 0x5684636aee, 0x325a019126, 0x24f18a4ef6});\n+constexpr StatTable39 QRT_TABLE_39({0x66b02a408c, 0x100420, 0x100422, 0x14206080, 0x100426, 0x5dccefab1c, 0x14206088, 0x9fc11e5b6, 0x100436, 0x5466bea62a, 0x5dccefab3c, 0x9aa110536, 0x142060c8, 0x54739ed6e2, 0x9fc11e536, 0xe7a82c080, 0x100536, 0x4002000, 0x5466bea42a, 0x6a4022000, 0x5dccefaf3c, 0x9e8118536, 0x9aa110d36, 0x5680e080, 0x142070c8, 0x7d293c5b6, 0x54739ef6e2, 0x8d680e080, 0x9fc11a536, 0x6d282c080, 0xe7a824080, 0x800000000, 0x110536, 0x2d680e080, 0x4022000, 0, 0x5466baa42a, 0x46b03a44aa, 0x6a40a2000});\n+typedef Field<uint64_t, 39, 17, StatTable39, &SQR_TABLE_39, &SQR2_TABLE_39, &SQR4_TABLE_39, &SQR8_TABLE_39, &SQR16_TABLE_39, &QRT_TABLE_39, IdTrans, &ID_TRANS, &ID_TRANS> Field39;\n+typedef FieldTri<uint64_t, 39, 4, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_39, &SQR2_TABLE_39, &SQR4_TABLE_39, &SQR8_TABLE_39, &SQR16_TABLE_39, &QRT_TABLE_39, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri39;\n+\n+// 40 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5> StatTable40;\n+constexpr StatTable40 SQR_TABLE_40({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x39, 0xe4, 0x390, 0xe40, 0x3900, 0xe400, 0x39000, 0xe4000, 0x390000, 0xe40000, 0x3900000, 0xe400000, 0x39000000, 0xe4000000, 0x390000000, 0xe40000000, 0x3900000000, 0xe400000000, 0x900000004b, 0x400000015e});\n+constexpr StatTable40 SQR2_TABLE_40({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x39, 0x390, 0x3900, 0x39000, 0x390000, 0x3900000, 0x39000000, 0x390000000, 0x3900000000, 0x900000004b, 0x541, 0x5410, 0x54100, 0x541000, 0x5410000, 0x54100000, 0x541000000, 0x5410000000, 0x41000000dd, 0x1000000d34, 0xd379, 0xd3790, 0xd37900, 0xd379000, 0xd3790000, 0xd37900000, 0xd379000000, 0x3790000115, 0x790000111b, 0x900001111f});\n+constexpr StatTable40 SQR4_TABLE_40({0x1, 0x10000, 0x100000000, 0x3900, 0x39000000, 0x541, 0x5410000, 0x41000000dd, 0xd37900, 0xd379000000, 0x111001, 0x1110010000, 0x10003aa90, 0x3aa903900, 0x903900511a, 0x51051541, 0x515410de9, 0x410de9de4d, 0xe9de437815, 0x437801010e, 0x101000038, 0x383939, 0x3839390000, 0x3900057d41, 0x57d444100, 0x444100d6e5, 0xd6ebaa79, 0xebaa7911c6, 0x7911d2791a, 0xd2791102a9, 0x1102b82901, 0xb82902a972, 0x2a96bfed1, 0x6bfed16851, 0xd16859f42e, 0x59f43f61a8, 0x3f61a43794, 0xa43791de59, 0x91de42401f, 0x424000390e});\n+constexpr StatTable40 SQR8_TABLE_40({0x1, 0x515410de9, 0x2a96bfed1, 0x13ba41ea90, 0x45bffe2b75, 0x5836900, 0x3887d7e690, 0xd34b688712, 0xc7a3d51557, 0xd1151ada71, 0x51442a740, 0x41cc5cbdb6, 0xc61a5701e9, 0x8757946d91, 0xa99e8b9e65, 0x80a0aca777, 0xc242b5c0e9, 0x6826eccb25, 0xad687ebd2d, 0xad5c69d802, 0x7ed2f8390, 0x51fa78eedf, 0xc0718c96f6, 0xaf4672a8c2, 0xc67436f2fd, 0x56ddb12767, 0x535afb0326, 0xbce1edda33, 0xef36202f0f, 0x45d13015ec, 0x104ab11aef, 0xef96c86d49, 0xc1b790bfc9, 0x2fa610e77f, 0x2a10a27d6e, 0xca5bb10773, 0xfdaf2b4642, 0xb3b4b7e20d, 0xe8bbe4d22e, 0xf9986bd2df});\n+constexpr StatTable40 SQR16_TABLE_40({0x1, 0xe88450a7de, 0x3a0a56c3e8, 0x1684757d36, 0xc7f40bf3e9, 0x38aa7009c0, 0x2b6f129659, 0xd1e0fc42e5, 0x96150bc554, 0x9774ef4cc1, 0xd34eebf74d, 0x2d183441ec, 0xeedf6d1c78, 0x3f93c5d217, 0xb924305809, 0xc383bb7c14, 0x3f242bb94e, 0x9313556f6b, 0x2f5e1ecc6b, 0x2e7f9df195, 0xac8b882870, 0xd14f457f55, 0xf9f936148d, 0x719190770, 0x6838b41a21, 0xb95ff30106, 0xc1527dd1c5, 0xe858b5f9b6, 0x9368a791c2, 0x7de23878af, 0x95c610d398, 0xed0edcb032, 0x9548a680b0, 0xc133469e7b, 0x68c96ccbb2, 0x7773231ebb, 0xbd5ef4207c, 0xdf8bd59374, 0xb862414268, 0xfa62b39e42});\n+constexpr StatTable40 QRT_TABLE_40({0x624b3cecc, 0xbc5c3f4c6, 0xbc5c3f4c4, 0xde1603e2c, 0xbc5c3f4c0, 0xaabec06cea, 0xde1603e24, 0x6cd9f724c2, 0xbc5c3f4d0, 0xcde1743818, 0xaabec06cca, 0xa138c314ca, 0xde1603e64, 0xaafc00f01a, 0x6cd9f72442, 0xcdca11bb4, 0xbc5c3f5d0, 0xa00002001a, 0xcde1743a18, 0xdf1407b90, 0xaabec068ca, 0xc043b482c8, 0xa138c31cca, 0xcb86977e3c, 0xde1602e64, 0x604596a326, 0xaafc00d01a, 0xcc1c165d0, 0x6cd9f76442, 0x673c94da26, 0xcdca19bb4, 0x67c0940a26, 0xbc5c2f5d0, 0xa4dca19bae, 0xa00000001a, 0x1bc5c2f5d0, 0xcde1703a18, 0, 0xdf1487b90, 0x8df1487b8a});\n+typedef Field<uint64_t, 40, 57, StatTable40, &SQR_TABLE_40, &SQR2_TABLE_40, &SQR4_TABLE_40, &SQR8_TABLE_40, &SQR16_TABLE_40, &QRT_TABLE_40, IdTrans, &ID_TRANS, &ID_TRANS> Field40;\n+\n+}\n+\n+Sketch* ConstructClMul5Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 33: return new SketchImpl<Field33>(implementation, 33);\n+    case 34: return new SketchImpl<Field34>(implementation, 34);\n+    case 35: return new SketchImpl<Field35>(implementation, 35);\n+    case 36: return new SketchImpl<Field36>(implementation, 36);\n+    case 37: return new SketchImpl<Field37>(implementation, 37);\n+    case 38: return new SketchImpl<Field38>(implementation, 38);\n+    case 39: return new SketchImpl<Field39>(implementation, 39);\n+    case 40: return new SketchImpl<Field40>(implementation, 40);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri5Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 33: return new SketchImpl<FieldTri33>(implementation, 33);\n+    case 34: return new SketchImpl<FieldTri34>(implementation, 34);\n+    case 35: return new SketchImpl<FieldTri35>(implementation, 35);\n+    case 36: return new SketchImpl<FieldTri36>(implementation, 36);\n+    case 39: return new SketchImpl<FieldTri39>(implementation, 39);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "239fef3e2182e56b63435f8d7fe7a94b92ccd5e6",
        "filename": "src/minisketch/src/fields/clmul_6bytes.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_6bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_6bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_6bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 41 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5> StatTable41;\n+constexpr StatTable41 SQR_TABLE_41({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x120000000, 0x480000000, 0x1200000000, 0x4800000000, 0x12000000000, 0x8000000012});\n+constexpr StatTable41 SQR2_TABLE_41({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x48, 0x480, 0x4800, 0x48000, 0x480000, 0x4800000, 0x48000000, 0x480000000, 0x4800000000, 0x8000000012, 0x104, 0x1040, 0x10400, 0x104000, 0x1040000, 0x10400000, 0x104000000, 0x1040000000, 0x10400000000, 0x4000000048, 0x492, 0x4920, 0x49200, 0x492000, 0x4920000, 0x49200000, 0x492000000, 0x4920000000, 0x9200000012, 0x12000000104});\n+constexpr StatTable41 SQR4_TABLE_41({0x1, 0x10000, 0x100000000, 0x480, 0x4800000, 0x8000000012, 0x104000, 0x1040000000, 0x4920, 0x49200000, 0x12000000104, 0x1001000, 0x10010000000, 0x48048, 0x480480000, 0x4800001040, 0x10410400, 0x4104000048, 0x492492, 0x4924920000, 0x9200010002, 0x100000100, 0x1000480, 0x10004800000, 0x8000048012, 0x480104000, 0x1040001040, 0x10404920, 0x4049200048, 0x12000492104, 0x4921001000, 0x10010010010, 0x100148048, 0x1480480480, 0x4804805840, 0x8058410412, 0x410410414c, 0x10414d2492, 0x14d24924920, 0x9249259202, 0x12592000004});\n+constexpr StatTable41 SQR8_TABLE_41({0x1, 0x10410400, 0x100148048, 0x13040000104, 0x11044801040, 0x924da49202, 0x9680490002, 0x82510514c, 0x8481485932, 0xc83144d832, 0x134d34d6db6, 0x18010048012, 0x165db20004c, 0x4800597052, 0x10131135cd0, 0xcd6cc30d32, 0x160586101cc, 0x15c64969da8, 0x179715681cc, 0x12f3c0ffc74, 0xc7dd3dd3ce, 0x10014c968, 0x1b040048116, 0x35d6801044, 0xda4deda6d0, 0x1de94c85852, 0x1083500114c, 0xc4c9685dfa, 0x18515c6d592, 0x17de69aed7e, 0x16c6c8a6c6c, 0x165cfe1044c, 0xdb004cf018, 0x7075031c98, 0x1d9a90b0d72, 0x1bb2485caee, 0x1cbe4dfd48a, 0x1f1540b7400, 0xc62bc7fd02, 0x147b5103f2e, 0x390ee8bcc6});\n+constexpr StatTable41 SQR16_TABLE_41({0x1, 0x61deee38fe, 0xe00adae2e, 0x1ea53eaa95a, 0x503e540566, 0xabc8e7f89a, 0x1bf760d86ac, 0x94cce9c722, 0x15c8006ee5c, 0x7aba20c1da, 0x12662a9603e, 0x5fe76acec4, 0x1e6beca9e42, 0x1efc8f7a000, 0x165997c6d7e, 0xee947a07ee, 0xd9bd741142, 0xaa304566c0, 0x5fe336e356, 0x11f1021b80c, 0xd34e5a1674, 0x99ed56b9dc, 0x9afae0eca, 0x1a5830b390e, 0x1be1a63eb7e, 0x141e77e141c, 0xee3be92168, 0xa93823d65c, 0x18a59f4b19c, 0xce69942af6, 0x3f7b319c0e, 0xba83a4a7b4, 0x7da4b6fcde, 0x17f79268f10, 0x1222602d048, 0x1b4b2f326b8, 0x159abff0786, 0xb35534a7a2, 0x84bbc48050, 0x173d5cbf330, 0x2897dd6f58});\n+constexpr StatTable41 QRT_TABLE_41({0, 0x1599a5e0b0, 0x1599a5e0b2, 0x105c119e0, 0x1599a5e0b6, 0x1a2030452a6, 0x105c119e8, 0x1a307c55b2e, 0x1599a5e0a6, 0x1ee3f47bc8e, 0x1a203045286, 0x400808, 0x105c119a8, 0x1a3038573a6, 0x1a307c55bae, 0x4d2882a520, 0x1599a5e1a6, 0x1ffbaa0b720, 0x1ee3f47be8e, 0x4d68c22528, 0x1a203045686, 0x200006, 0x400008, 0x1b79a21b200, 0x105c109a8, 0x1ef3886a526, 0x1a3038553a6, 0x1b692209200, 0x1a307c51bae, 0x5d99a4e1a6, 0x4d28822520, 0x185e109ae, 0x1599a4e1a6, 0x4e3f43be88, 0x1ffbaa2b720, 0x4000000000, 0x1ee3f43be8e, 0x18000000006, 0x4d68ca2528, 0xa203145680, 0x1a203145686});\n+typedef Field<uint64_t, 41, 9, StatTable41, &SQR_TABLE_41, &SQR2_TABLE_41, &SQR4_TABLE_41, &SQR8_TABLE_41, &SQR16_TABLE_41, &QRT_TABLE_41, IdTrans, &ID_TRANS, &ID_TRANS> Field41;\n+typedef FieldTri<uint64_t, 41, 3, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_41, &SQR2_TABLE_41, &SQR4_TABLE_41, &SQR8_TABLE_41, &SQR16_TABLE_41, &QRT_TABLE_41, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri41;\n+\n+// 42 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6> StatTable42;\n+constexpr StatTable42 SQR_TABLE_42({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x810000000, 0x2040000000, 0x8100000000, 0x20400000000, 0x1000000102, 0x4000000408, 0x10000001020});\n+constexpr StatTable42 SQR2_TABLE_42({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x204, 0x2040, 0x20400, 0x204000, 0x2040000, 0x20400000, 0x204000000, 0x2040000000, 0x20400000000, 0x4000000408, 0x4001, 0x40010, 0x400100, 0x4001000, 0x40010000, 0x400100000, 0x4001000000, 0x10000081, 0x100000810, 0x1000008100, 0x10000081000, 0x810204, 0x8102040, 0x81020400, 0x810204000, 0x8102040000, 0x1020400102, 0x10204001020, 0x2040010004, 0x20400100040, 0x4001000008});\n+constexpr StatTable42 SQR4_TABLE_42({0x1, 0x10000, 0x100000000, 0x2040, 0x20400000, 0x4000000408, 0x4001000, 0x10000081, 0x810204, 0x8102040000, 0x20400100040, 0x1000000100, 0x1020400, 0x10204000000, 0x200001, 0x2000010000, 0x100040800, 0x408002040, 0x20408002, 0x4080020408, 0x204000020, 0x204001, 0x2040010000, 0x100040010, 0x400102040, 0x1020408100, 0x4081020008, 0x10200000020, 0x80, 0x800000, 0x8000000000, 0x102000, 0x1020000000, 0x20008, 0x200080000, 0x800004080, 0x40810200, 0x8102000810, 0x20008000040, 0x8102, 0x81020000, 0x10200001020});\n+constexpr StatTable42 SQR8_TABLE_42({0x1, 0x100040800, 0x1020000000, 0x10200001000, 0x2040810000, 0x408102040, 0x4080000408, 0x10000000, 0x8002040810, 0x20008000, 0x10200080000, 0x40000004, 0x20408000040, 0x4000020000, 0x204000, 0x8002040010, 0x408102, 0x200081020, 0x40810000, 0x2000, 0x81000408, 0x4001, 0x2040010, 0x1020008002, 0x10204081020, 0x800004, 0x20000000000, 0x4081000400, 0x10000081, 0x100040010, 0x8102, 0x10000000020, 0x40010200, 0x408000000, 0x4080000400, 0x810204000, 0x102040810, 0x1020000102, 0x4000000, 0x2000810204, 0x8002000, 0x4080020000});\n+constexpr StatTable42 SQR16_TABLE_42({0x1, 0x40800204, 0x2000800, 0x20008002040, 0x408100, 0x20000, 0x10004081020, 0x10000081, 0x40010204, 0x8102000000, 0x400000000, 0x1020008102, 0x1020408, 0x204081020, 0x200001, 0x10200, 0x102000010, 0x20408100000, 0x1020408002, 0x4000020000, 0x204000000, 0x204001, 0x2000800004, 0x8100000010, 0x400102000, 0x8002, 0x4080020000, 0x10000001000, 0x80, 0x2040010200, 0x100040000, 0x400100040, 0x20408000, 0x1000000, 0x204080020, 0x800004080, 0x2000810200, 0x8100000810, 0x20000000000, 0x1000408002, 0x81020400, 0x10204081000});\n+constexpr StatTable42 QRT_TABLE_42({0x810200080, 0x120810806, 0x120810804, 0x1068c1a1000, 0x120810800, 0x34005023008, 0x1068c1a1008, 0x800004080, 0x120810810, 0x162818a10, 0x34005023028, 0x42408a14, 0x1068c1a1048, 0x1001040, 0x800004000, 0xb120808906, 0x120810910, 0x34000020068, 0x162818810, 0x68c021400, 0x34005023428, 0x10004000, 0x42408214, 0x162418214, 0x1068c1a0048, 0xb002018116, 0x1003040, 0x10008180448, 0x800000000, 0x62c08b04, 0xb120800906, 0x2408d1a3060, 0x120800910, 0x34401003028, 0x34000000068, 0, 0x162858810, 0xa042058116, 0x68c0a1400, 0x8162858806, 0x34005123428, 0x3068c0a1468});\n+typedef Field<uint64_t, 42, 129, StatTable42, &SQR_TABLE_42, &SQR2_TABLE_42, &SQR4_TABLE_42, &SQR8_TABLE_42, &SQR16_TABLE_42, &QRT_TABLE_42, IdTrans, &ID_TRANS, &ID_TRANS> Field42;\n+typedef FieldTri<uint64_t, 42, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_42, &SQR2_TABLE_42, &SQR4_TABLE_42, &SQR8_TABLE_42, &SQR16_TABLE_42, &QRT_TABLE_42, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri42;\n+\n+// 43 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5, 5> StatTable43;\n+constexpr StatTable43 SQR_TABLE_43({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0xb2, 0x2c8, 0xb20, 0x2c80, 0xb200, 0x2c800, 0xb2000, 0x2c8000, 0xb20000, 0x2c80000, 0xb200000, 0x2c800000, 0xb2000000, 0x2c8000000, 0xb20000000, 0x2c80000000, 0xb200000000, 0x2c800000000, 0x32000000059, 0x4800000013d, 0x20000000446});\n+constexpr StatTable43 SQR2_TABLE_43({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0xb2, 0xb20, 0xb200, 0xb2000, 0xb20000, 0xb200000, 0xb2000000, 0xb20000000, 0xb200000000, 0x32000000059, 0x20000000446, 0x4504, 0x45040, 0x450400, 0x4504000, 0x45040000, 0x450400000, 0x4504000000, 0x45040000000, 0x504000002c8, 0x4000002efa, 0x4000002efa0, 0x2ef8c8, 0x2ef8c80, 0x2ef8c800, 0x2ef8c8000, 0x2ef8c80000, 0x2ef8c800000, 0x6f8c800013d, 0x78c80001025, 0xc800010117, 0x48000101129});\n+constexpr StatTable43 SQR4_TABLE_43({0x1, 0x10000, 0x100000000, 0xb20, 0xb200000, 0x32000000059, 0x450400, 0x4504000000, 0x4000002efa0, 0x2ef8c8000, 0x78c80001025, 0x10110010, 0x11001000b2, 0x1000b2b920, 0xb2b920b200, 0x120b204545f, 0x20454554046, 0x45540506efa, 0x506ed4df68, 0x6d4df6a79f5, 0x76a79c80133, 0x1c801010007, 0x101000b2100, 0xb210b2b20, 0x10b2b204504, 0x320450f655d, 0x50f654106c8, 0x54106efcb4c, 0x6efcb696320, 0x369631c93e1, 0x31c93ff9d8c, 0x3ff9d91a2a2, 0x591a2b9839b, 0x2b983b98dd4, 0x3b98dc651b0, 0x5c651a971e9, 0x1a971c9c0ba, 0x1c9c0b5853e, 0xb585322d78, 0x5322d7c6430, 0x57c6416617d, 0x4166159c82c, 0x159c8000b6c});\n+constexpr StatTable43 SQR8_TABLE_43({0x1, 0x20454554046, 0x591a2b9839b, 0x722ff9f6fe9, 0x6a269c1eb12, 0xa3ce9f234e, 0x4d9ba8aae0b, 0x392cf0cf99b, 0x465f8594525, 0x4f9c1fb1524, 0x3b1a1dd441c, 0x381edd42255, 0x37a599424b, 0x554caee8670, 0x5335bb91d81, 0x69288c8a1a3, 0x3df2b6e68e5, 0x75330d31d56, 0x51a604b090c, 0x32e0d5a7ca3, 0x41eb9d4896e, 0x633e2855c9f, 0x4780d70e32f, 0x73b0cd728c3, 0x16627402bad, 0x4418f2a818a, 0x5cdd06cf7e5, 0x2a8da97a3ae, 0x446864a8976, 0x5a7bcbd45ea, 0x4034a4b8b04, 0x6bdaac9c5fa, 0x18769ce3a67, 0x560278257c, 0x41c06d6b64c, 0x69f6f61bd4b, 0x16cc45f84fd, 0x53f6b42f0f0, 0x6cac3d234f3, 0x1f94e8f24d5, 0x319342c7148, 0x8685bca86d, 0x6b694a6ea66});\n+constexpr StatTable43 SQR16_TABLE_43({0x1, 0x1ce77599049, 0x191715250a, 0xc1573d8dff, 0x118e73ab5e4, 0x4b6a83225fe, 0x72b4bc8e0f5, 0x4a4b2b6bb02, 0x66daf4741e9, 0x50baba19898, 0x5eb38771912, 0x6fb458aad3c, 0x5ce3b10bde9, 0x5575f3498f0, 0x5f075aa8a0a, 0x41d0aa8ee20, 0x609e3c78c28, 0xe2e45a8018, 0x523ac062837, 0x738388a569d, 0x6616ec46da9, 0x1a75cc16d96, 0x49b0b43bbc3, 0x400416b3c9a, 0x25813f41ffe, 0x309fdb9d0bc, 0x489f45b2cbf, 0xa141f4f88e, 0x739e0d11fb3, 0x44971f51cc0, 0x6490576e60e, 0x6c6674c5355, 0x6978126a4e1, 0x3d04eae5a5, 0x312eed633f2, 0x1de4b98d6b9, 0x118a106fb0a, 0x26dae025f4, 0x5c179312ebb, 0x75870ef1921, 0x60e9fed95c0, 0x209ab92427a, 0x1c5014a1937});\n+constexpr StatTable43 QRT_TABLE_43({0x2bccc2d6f6c, 0x4bccc2d6f54, 0x4bccc2d6f56, 0x7cc7bc61df0, 0x4bccc2d6f52, 0x7d13b404b10, 0x7cc7bc61df8, 0x37456e9ac5a, 0x4bccc2d6f42, 0x4e042c6a6, 0x7d13b404b30, 0x4a56de9ef4c, 0x7cc7bc61db8, 0x14bc18d8e, 0x37456e9acda, 0x7c89f84fb1e, 0x4bccc2d6e42, 0x7ffae40d210, 0x4e042c4a6, 0x366f45dd06, 0x7d13b404f30, 0x496fcaf8cca, 0x4a56de9e74c, 0x370b62b6af4, 0x7cc7bc60db8, 0x1498185a8, 0x14bc1ad8e, 0x7e602c46a98, 0x37456e9ecda, 0x36ccc2c6e74, 0x7c89f847b1e, 0x7e27d06d516, 0x4bccc2c6e42, 0x7f93302c396, 0x7ffae42d210, 0x3dd3440706, 0x4e046c4a6, 0x78bbc09da36, 0x366f4ddd06, 0, 0x7d13b504f30, 0x8bbc09da00, 0x496fc8f8cca});\n+typedef Field<uint64_t, 43, 89, StatTable43, &SQR_TABLE_43, &SQR2_TABLE_43, &SQR4_TABLE_43, &SQR8_TABLE_43, &SQR16_TABLE_43, &QRT_TABLE_43, IdTrans, &ID_TRANS, &ID_TRANS> Field43;\n+\n+// 44 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5> StatTable44;\n+constexpr StatTable44 SQR_TABLE_44({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x8400, 0x21000, 0x84000, 0x210000, 0x840000, 0x2100000, 0x8400000, 0x21000000, 0x84000000, 0x210000000, 0x840000000, 0x2100000000, 0x8400000000, 0x21000000000, 0x84000000000, 0x10000000042, 0x40000000108});\n+constexpr StatTable44 SQR2_TABLE_44({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x21, 0x210, 0x2100, 0x21000, 0x210000, 0x2100000, 0x21000000, 0x210000000, 0x2100000000, 0x21000000000, 0x10000000042, 0x401, 0x4010, 0x40100, 0x401000, 0x4010000, 0x40100000, 0x401000000, 0x4010000000, 0x40100000000, 0x1000000084, 0x10000000840, 0x8421, 0x84210, 0x842100, 0x8421000, 0x84210000, 0x842100000, 0x8421000000, 0x84210000000, 0x42100000108, 0x21000001004, 0x10000010002});\n+constexpr StatTable44 SQR4_TABLE_44({0x1, 0x10000, 0x100000000, 0x210, 0x2100000, 0x21000000000, 0x40100, 0x401000000, 0x10000000840, 0x8421000, 0x84210000000, 0x100001, 0x1000010000, 0x100002100, 0x21000210, 0x10002100042, 0x21000401000, 0x4010040100, 0x401008421, 0x10084210840, 0x42108421108, 0x84211000010, 0x10000000001, 0x31000, 0x310000000, 0x611, 0x6110000, 0x61100000000, 0xc4310, 0xc43100000, 0x31000001844, 0x18421100, 0x84211000021, 0x10000310001, 0x3100031000, 0x310006110, 0x61100611, 0x110061100c6, 0x61100c43100, 0xc4310c4310, 0x10c43118423, 0x31184210844, 0x42108421218, 0x84212100010});\n+constexpr StatTable44 SQR8_TABLE_44({0x1, 0x21000401000, 0x84211000021, 0xa521000, 0x42108421719, 0x311e5310e55, 0x10401008c61, 0x3210031000, 0x10c43058522, 0x74110050101, 0xf5312e97201, 0x42108421109, 0x21061501611, 0x94311002961, 0xf59421000, 0x52d4b56923a, 0x201e5300e54, 0x71501c8fe71, 0xb6002131043, 0xb5e4c168432, 0xb320f5619ae, 0xf5000f97201, 0x10c43118422, 0x24010451100, 0x942113d4330, 0x8421a521001, 0x6310e130719, 0xf72fc731c6c, 0x4ae739631, 0x70008417e4d, 0x20ca6358b77, 0x64110094a51, 0xd4002e97200, 0xf7f5a13853a, 0xb12664417f6, 0x843322d6860, 0xf7c4100194d, 0x7382d17842b, 0xf67fd71a10c, 0x6efcca4b731, 0xf4e5901ea2d, 0xcb8278a46, 0xa32050401ee, 0xb7218bb6518});\n+constexpr StatTable44 SQR16_TABLE_44({0x1, 0xc6cdb660138, 0x13de5a69a7b, 0x80bcafe7981, 0x60eb6f976d1, 0x677fbef6cce, 0x1549bb4cdec, 0x3b1ddf6859, 0xc01b8da28a6, 0xf3e11efbf8c, 0xd3e6faf8ee3, 0xa3dbc5712c8, 0x72361d7ca84, 0xe59e509337d, 0x15fca12a6f4, 0x33ce445498c, 0x44406de91fb, 0x9784b690571, 0xb0fb81753af, 0xb53a7c2c977, 0x34fbd3dba9b, 0xc758c22e647, 0xd5ff69aa469, 0x41e6d42b47d, 0xa4d1a3d02e7, 0x365db54ae9f, 0xd2293b8770b, 0xf1bf95c7746, 0x337fbe1d950, 0x726879e26a7, 0xa4be5ec2171, 0x7080da9df82, 0x7560017ce2, 0xd03997e34ae, 0x27ad4309a78, 0xb7b0ead892b, 0xf45bedb915d, 0xc4f0e25a52c, 0xe774a9d7fe8, 0xece6c1d7a26, 0xf20ea9ab655, 0x159bb624dc2, 0x12f2780b45f, 0x840cc52f19d});\n+constexpr StatTable44 QRT_TABLE_44({0xf05334f4f6e, 0x4002016, 0x4002014, 0xf04350e6246, 0x4002010, 0x4935b379a26, 0xf04350e624e, 0xf84250c228e, 0x4002000, 0xf04300e521e, 0x4935b379a06, 0xb966838dd48, 0xf04350e620e, 0xf7b8b80feda, 0xf84250c220e, 0xf972e097d5e, 0x4002100, 0x8000020000, 0xf04300e501e, 0x430025000, 0x4935b379e06, 0xf976a09dc5e, 0xb966838d548, 0xf84218c029a, 0xf04350e720e, 0x4925f36bf06, 0xf7b8b80deda, 0xb047d3ee758, 0xf84250c620e, 0xf80350e720e, 0xf972e09fd5e, 0x8091825284, 0x4012100, 0x9015063210, 0x8000000000, 0xff31a028c5e, 0xf04300a501e, 0x44340b7100, 0x4300a5000, 0, 0x4935b279e06, 0xa976b2dce18, 0xf976a29dc5e, 0x8935b279e18});\n+typedef Field<uint64_t, 44, 33, StatTable44, &SQR_TABLE_44, &SQR2_TABLE_44, &SQR4_TABLE_44, &SQR8_TABLE_44, &SQR16_TABLE_44, &QRT_TABLE_44, IdTrans, &ID_TRANS, &ID_TRANS> Field44;\n+typedef FieldTri<uint64_t, 44, 5, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5>, &SQR_TABLE_44, &SQR2_TABLE_44, &SQR4_TABLE_44, &SQR8_TABLE_44, &SQR16_TABLE_44, &QRT_TABLE_44, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri44;\n+\n+// 45 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5> StatTable45;\n+constexpr StatTable45 SQR_TABLE_45({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x36, 0xd8, 0x360, 0xd80, 0x3600, 0xd800, 0x36000, 0xd8000, 0x360000, 0xd80000, 0x3600000, 0xd800000, 0x36000000, 0xd8000000, 0x360000000, 0xd80000000, 0x3600000000, 0xd800000000, 0x36000000000, 0xd8000000000, 0x16000000001b, 0x18000000005a});\n+constexpr StatTable45 SQR2_TABLE_45({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0xd8, 0xd80, 0xd800, 0xd8000, 0xd80000, 0xd800000, 0xd8000000, 0xd80000000, 0xd800000000, 0xd8000000000, 0x18000000005a, 0x514, 0x5140, 0x51400, 0x514000, 0x5140000, 0x51400000, 0x514000000, 0x5140000000, 0x51400000000, 0x114000000036, 0x1400000003b8, 0x3b6e, 0x3b6e0, 0x3b6e00, 0x3b6e000, 0x3b6e0000, 0x3b6e00000, 0x3b6e000000, 0x3b6e0000000, 0x1b6e0000001b, 0x16e00000011f, 0xe0000001105});\n+constexpr StatTable45 SQR4_TABLE_45({0x1, 0x10000, 0x100000000, 0xd8, 0xd80000, 0xd800000000, 0x5140, 0x51400000, 0x114000000036, 0x3b6e00, 0x3b6e000000, 0xe0000001105, 0x11011000, 0x110110000000, 0x1000000d58d8, 0xd58d58000, 0x18d58000054e, 0x5451454, 0x54514540000, 0x145400038db8, 0x38db6d8e0, 0xdb6d8e00104, 0x18e00101000a, 0x10100010100, 0x10100d8d8, 0x100d8d800d8, 0x18d800d8d85a, 0xd8d8511140, 0x18511140511a, 0x114051117b58, 0x11117b556e36, 0x1b556e3b5575, 0xe3b557f1015, 0x157f1011011e, 0x101101101c48, 0x1101c458d58, 0x1c458d58d580, 0xd58d58815d4, 0x158815d1451a, 0x15d1451452c0, 0x51452ce6f6e, 0x12ce6f6db6d6, 0xf6db6da6e3d, 0x16da6e39e00f, 0xe39e00000dd});\n+constexpr StatTable45 SQR8_TABLE_45({0x1, 0x18d58000054e, 0xe3b557f1015, 0x51985198, 0xdb68cb55452, 0x1d0cc1d84f02, 0x140110c19ae, 0x11a16a14e7fe, 0x1e7ca7c62aa9, 0xe0eae26629b, 0x12182bee80ab, 0x1a38a68f28d3, 0x8581419c8c, 0x1d47f6f12ebc, 0x19fd34c3806e, 0x12ddba59f3cd, 0x10fa07f12a0e, 0x1d93eb544486, 0x1cf42cd119be, 0x1ff32d4b62c3, 0xf34ae031191, 0xada837715bf, 0xd368a753f92, 0x2ba87b17a03, 0x10374c3e4088, 0x1a6f539c11bd, 0x16548a5473c7, 0x1eb70011a8c9, 0x1ee5435ba1a3, 0x1173c0537680, 0xa1a3668dd6b, 0x119faad25e8, 0xd3909240e00, 0x1b560d018881, 0x127ecb9095ed, 0x306b507e701, 0x12b934c21ea3, 0x1a9d258c5b8b, 0x10452fbf0b1c, 0xae92fee120d, 0x183eb4b419fa, 0xc24d2391313, 0x4e6c4746f6, 0x2815fe7c395, 0xe4ab383747f});\n+constexpr StatTable45 SQR16_TABLE_45({0x1, 0x14af92df932, 0x484e0190bdc, 0xda69889e16e, 0xcf70dfdb150, 0x18c6743571a8, 0x1b2c3ad7fa79, 0x5f0cbe204f6, 0xee973392a75, 0x3e86ef79673, 0xb2a9bef7181, 0x19b5347ff116, 0x1cae0ec79856, 0x69093f18f81, 0x1964382be09a, 0x92c894b073e, 0x1d99d2922eb2, 0x647905ad0eb, 0x1695971acdd3, 0x8f3292bc8c4, 0x1ee4057ad94, 0x17f02dc60e01, 0x1bb8e05ab4d5, 0x14de5d2a05d6, 0x13a019a02983, 0xcd7097c3616, 0x1bd798639b8f, 0x1cf0ca5ac7b2, 0xa93b983cf05, 0x159a955a2aa8, 0x69e5ba33397, 0x3a6b3392237, 0x26aeab71e13, 0x26fe04d38b9, 0x1fa9df0e8c45, 0x104e85c234b0, 0x1792853f8767, 0x81573b15f20, 0x127d6bfb06d3, 0x8110e6957e8, 0x11f59cbcc110, 0xad68264cad8, 0x61438575b35, 0x56e4446dc, 0x1cc9cb28b150});\n+constexpr StatTable45 QRT_TABLE_45({0xede34e3e0fc, 0x1554148191aa, 0x1554148191a8, 0x1767be1dc4a6, 0x1554148191ac, 0x26bd4931492, 0x1767be1dc4ae, 0x233ab9c454a, 0x1554148191bc, 0x16939e8bb3dc, 0x26bd49314b2, 0x3c6ca8bac52, 0x1767be1dc4ee, 0x16caa5054c16, 0x233ab9c45ca, 0x14a1649628bc, 0x1554148190bc, 0x3c382881252, 0x16939e8bb1dc, 0x3c7ca0aa160, 0x26bd49310b2, 0x27f40158000, 0x3c6ca8ba452, 0x173fc092853c, 0x1767be1dd4ee, 0x16cbe284f25c, 0x16caa5056c16, 0x155559002f96, 0x233ab9c05ca, 0x26eb8908b32, 0x14a16496a8bc, 0x15440885333c, 0x1554148090bc, 0x17d60702e0, 0x3c3828a1252, 0x54548d10b2, 0x16939e8fb1dc, 0x3ac1e81b1d2, 0x3c7ca02a160, 0x166bd48310bc, 0x26bd48310b2, 0, 0x27f40358000, 0x10000000000e, 0x3c6cacba452});\n+typedef Field<uint64_t, 45, 27, StatTable45, &SQR_TABLE_45, &SQR2_TABLE_45, &SQR4_TABLE_45, &SQR8_TABLE_45, &SQR16_TABLE_45, &QRT_TABLE_45, IdTrans, &ID_TRANS, &ID_TRANS> Field45;\n+\n+// 46 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5> StatTableTRI46;\n+constexpr StatTableTRI46 SQR_TABLE_TRI46({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000});\n+constexpr StatTableTRI46 SQR2_TABLE_TRI46({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0xc, 0xc0, 0xc00, 0xc000, 0xc0000, 0xc00000, 0xc000000, 0xc0000000, 0xc00000000, 0xc000000000, 0xc0000000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x50000000, 0x500000000, 0x5000000000, 0x50000000000, 0x100000000003, 0x3c, 0x3c0, 0x3c00, 0x3c000, 0x3c0000, 0x3c00000, 0x3c000000, 0x3c0000000, 0x3c00000000, 0x3c000000000, 0x3c0000000000});\n+constexpr StatTableTRI46 SQR4_TABLE_TRI46({0x1, 0x10000, 0x100000000, 0xc, 0xc0000, 0xc00000000, 0x50, 0x500000, 0x5000000000, 0x3c0, 0x3c00000, 0x3c000000000, 0x1100, 0x11000000, 0x110000000000, 0xcc00, 0xcc000000, 0xc0000000005, 0x55000, 0x550000000, 0x10000000003f, 0x3fc000, 0x3fc0000000, 0x101, 0x1010000, 0x10100000000, 0xc0c, 0xc0c0000, 0xc0c00000000, 0x5050, 0x50500000, 0x105000000003, 0x3c3c0, 0x3c3c00000, 0x3c000000011, 0x111100, 0x1111000000, 0x1100000000cc, 0xcccc00, 0xcccc000000, 0xc0000000555, 0x5555000, 0x55550000000, 0x100000003fff, 0x3fffc000, 0x3fffc0000000});\n+constexpr StatTableTRI46 SQR8_TABLE_TRI46({0x1, 0xcc000000, 0x3c3c0, 0x10000000c, 0x550055000, 0x3c000111111, 0xc0050, 0x103fc000003f, 0x1111cccc00, 0x5000500390, 0x13ec1010101, 0xcccc9999955, 0x5000001100, 0xc0c01010000, 0xc003fffc555, 0x12c003c0cc00, 0x10505c5c0c0f, 0x155450003ffe, 0x1100cc054100, 0xfcc5053c3d1, 0xd3ff2c00d, 0xd059c3a5c3a, 0x2828282d21e, 0x5000000001, 0xcd010000, 0xc000003c695, 0x3c103c0000c, 0x55c095c0c, 0x169550112eee, 0x1100000c1150, 0x1c339050003f, 0x112e320c01, 0x1d50cc50cf95, 0x116d5292c2c2, 0xcccc9959954, 0x1050cc00113f, 0xc1d1002c3c0, 0xc013fafc509, 0x12fa93c59d01, 0x135c9081d11e, 0x150453cc3fae, 0x13f0d044d33, 0x688119f0a84, 0x39d2d62d29d, 0x3751370167, 0x24e4e4e4b4b4});\n+constexpr StatTableTRI46 SQR16_TABLE_TRI46({0x1, 0x1fe6e1ab503e, 0xbbae1f3f55b, 0x1d51cc530c59, 0x163a6a22e14a, 0x5847feb7f81, 0x1ec9cc5fd281, 0xf6cc7b80c70, 0x8f46b31e374, 0xc13bf2ed37d, 0x148a1595bffe, 0x581ad245849, 0x1ea6920b83c1, 0x9d9a8355c7d, 0x6bcf393d5ff, 0x1d4e245085c0, 0x602a8c5e62c, 0x1922dd69197f, 0x7945d3a2aad, 0xf82a823f768, 0xdd24665599b, 0x13b43f6a29d, 0x4df114f238d, 0x1ee783c75ec0, 0xfb670f65c31, 0xf855dc973d2, 0x61ede5f2651, 0x6c1a1266403, 0x1f66ed2a96a, 0xbbbdf683148, 0x1ecc83e160c0, 0x1a2778c4bc0c, 0x10e154273753, 0x1704f8873c23, 0x1b4d3172da99, 0x2b3be805044, 0x5bb08848b9d, 0x1967d2b99be5, 0x7fa55262740, 0xe761a27cc28, 0x17dedd7181b5, 0x155b0344714a, 0x15187b38816e, 0xc5a679b5300, 0x1096cbf94c5d, 0x3f6b3cc122da});\n+constexpr StatTableTRI46 QRT_TABLE_TRI46({0x211c4fd486ba, 0x100104a, 0x1001048, 0x104d0492d4, 0x100104c, 0x20005040c820, 0x104d0492dc, 0x40008080, 0x100105c, 0x24835068ce00, 0x20005040c800, 0x200000400800, 0x104d04929c, 0x100904325c, 0x40008000, 0x25da9e77daf0, 0x100115c, 0x1184e1696f0, 0x24835068cc00, 0x24825169dd5c, 0x20005040cc00, 0x3ea3241c60c0, 0x200000400000, 0x211c4e5496f0, 0x104d04829c, 0x20005340d86c, 0x100904125c, 0x24835968de5c, 0x4000c000, 0x6400a0c0, 0x25da9e775af0, 0x118cf1687ac, 0x101115c, 0x1ea1745cacc0, 0x1184e1496f0, 0x20181e445af0, 0x2483506ccc00, 0x20240060c0, 0x24825161dd5c, 0x1e21755dbd9c, 0x20005050cc00, 0x26a3746cacc0, 0x3ea3243c60c0, 0xea3243c60c0, 0x200000000000, 0});\n+typedef FieldTri<uint64_t, 46, 1, StatTableTRI46, &SQR_TABLE_TRI46, &SQR2_TABLE_TRI46, &SQR4_TABLE_TRI46, &SQR8_TABLE_TRI46, &SQR16_TABLE_TRI46, &QRT_TABLE_TRI46, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri46;\n+\n+// 47 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5> StatTable47;\n+constexpr StatTable47 SQR_TABLE_47({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x1080000, 0x4200000, 0x10800000, 0x42000000, 0x108000000, 0x420000000, 0x1080000000, 0x4200000000, 0x10800000000, 0x42000000000, 0x108000000000, 0x420000000000, 0x80000000042, 0x200000000108});\n+constexpr StatTable47 SQR2_TABLE_47({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x42, 0x420, 0x4200, 0x42000, 0x420000, 0x4200000, 0x42000000, 0x420000000, 0x4200000000, 0x42000000000, 0x420000000000, 0x200000000108, 0x1004, 0x10040, 0x100400, 0x1004000, 0x10040000, 0x100400000, 0x1004000000, 0x10040000000, 0x100400000000, 0x4000000042, 0x40000000420, 0x400000004200, 0x42108, 0x421080, 0x4210800, 0x42108000, 0x421080000, 0x4210800000, 0x42108000000, 0x421080000000, 0x210800000108, 0x108000001004, 0x80000010002});\n+constexpr StatTable47 SQR4_TABLE_47({0x1, 0x10000, 0x100000000, 0x42, 0x420000, 0x4200000000, 0x1004, 0x10040000, 0x100400000000, 0x42108, 0x421080000, 0x210800000108, 0x1000010, 0x10000100000, 0x1000004200, 0x42000420, 0x420004200000, 0x42000100400, 0x1004010040, 0x40100400420, 0x4004210842, 0x42108421080, 0x84210810002, 0x108100000004, 0x142, 0x1420000, 0x14200000000, 0x5204, 0x52040000, 0x520400000000, 0x142508, 0x1425080000, 0x250800000528, 0x5210810, 0x52108100000, 0x81000014202, 0x142001420, 0x420014200042, 0x142000520400, 0x5204052040, 0x40520401424, 0x20401425094a, 0x142509425080, 0x9425085210a, 0x508521084204, 0x21084210804a, 0x421080420010});\n+constexpr StatTable47 SQR8_TABLE_47({0x1, 0x420004200000, 0x250800000528, 0x11004, 0xc6210910402, 0x142005730c10, 0x101000010, 0x1056050040, 0x55a429184204, 0x111404110002, 0x532408500562, 0x3d196251d62e, 0x420142, 0x44524611c66, 0x1142047728, 0x46205e2508, 0x67339c2519da, 0x5661384b5880, 0x434346200424, 0x392938cb55aa, 0x724b0c31058c, 0x7f4f1cf703fc, 0x4fe303d32d1e, 0x75de250d676c, 0x100400011004, 0xc6210910540, 0x102525331834, 0x1101046318, 0x1057532548, 0x37f4bd7f4b5e, 0x115021380840, 0x52674a501142, 0x297a4a1b86ae, 0x666b0c2010ca, 0x776839031b88, 0x4b5316a05622, 0x254e215e2030, 0x6733ce2009de, 0xa8609d21e86, 0x567347420874, 0x6e0d31db55ba, 0x4357182485c4, 0x2afb35ef02ba, 0x5af227961c30, 0x64faad1b0116, 0x2d5d2527ef40, 0x6e27e3bc1978});\n+constexpr StatTable47 SQR16_TABLE_47({0x1, 0x421ac25c8774, 0x30581389b510, 0x423b9c671db0, 0xa4537914208, 0x38f9be0dbf38, 0x351c5a8b92a8, 0xc38b9920da2, 0x508d34674f2a, 0x1f8c359a6b76, 0x5ac4bf86daaa, 0x51d6a6616df2, 0xe2717a0378a, 0x13353e783e6e, 0x55a55ac09ec6, 0x3f17cde43402, 0x760584b64b6c, 0x6acbecc99a02, 0x16be80e45b76, 0x2d5069e0005a, 0x3388f5759aa6, 0x2f98f891f4e2, 0x7657f368d924, 0x48f81e34f5b0, 0x51a9087f072e, 0x1de01ba9001c, 0x560b4b374bfc, 0x13f576988ff0, 0x3673cd322294, 0x595959f7c5fe, 0xbfa426eb4a4, 0x2b68fd7c02c2, 0x2a3c1437913a, 0x6e4b179fcf9e, 0x69ddf09bbdee, 0x7b91973d5e52, 0x1329cefd9514, 0x6a5f380b7ab0, 0x48e6620529c4, 0x60589a4b95b6, 0x5e4bd1d1aa34, 0x4b1ec7645cc2, 0x5cfb8785aec6, 0x34e47cf10c3a, 0x7b6c363eee10, 0x1dc52d768b32, 0x3585af9113a0});\n+constexpr StatTable47 QRT_TABLE_47({0, 0x1001040, 0x1001042, 0x1047043076, 0x1001046, 0x112471c241e, 0x104704307e, 0x4304e052168, 0x1001056, 0x10004000, 0x112471c243e, 0x172a09c949d6, 0x104704303e, 0x4002020, 0x4304e0521e8, 0x5400e220, 0x1001156, 0x172b08c85080, 0x10004200, 0x41200b0800, 0x112471c203e, 0x172f0cca50a0, 0x172a09c941d6, 0x7eb88a11c1d6, 0x104704203e, 0x1044042020, 0x4000020, 0x42001011156, 0x4304e0561e8, 0x172a28c95880, 0x54006220, 0x112931cc21e, 0x1011156, 0x53670f283e, 0x172b08ca5080, 0x7a80c414a03e, 0x10044200, 0x40000000000, 0x4120030800, 0x1928318801e, 0x112470c203e, 0x799283188000, 0x172f0cea50a0, 0x1eb88a91c1c8, 0x172a098941d6, 0x3ea8cc95e1f6, 0x7eb88a91c1d6});\n+typedef Field<uint64_t, 47, 33, StatTable47, &SQR_TABLE_47, &SQR2_TABLE_47, &SQR4_TABLE_47, &SQR8_TABLE_47, &SQR16_TABLE_47, &QRT_TABLE_47, IdTrans, &ID_TRANS, &ID_TRANS> Field47;\n+typedef FieldTri<uint64_t, 47, 5, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5>, &SQR_TABLE_47, &SQR2_TABLE_47, &SQR4_TABLE_47, &SQR8_TABLE_47, &SQR16_TABLE_47, &QRT_TABLE_47, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri47;\n+\n+// 48 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6> StatTable48;\n+constexpr StatTable48 SQR_TABLE_48({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x2d, 0xb4, 0x2d0, 0xb40, 0x2d00, 0xb400, 0x2d000, 0xb4000, 0x2d0000, 0xb40000, 0x2d00000, 0xb400000, 0x2d000000, 0xb4000000, 0x2d0000000, 0xb40000000, 0x2d00000000, 0xb400000000, 0x2d000000000, 0xb4000000000, 0x2d0000000000, 0xb40000000000, 0xd0000000005a, 0x40000000011f});\n+constexpr StatTable48 SQR2_TABLE_48({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x2d, 0x2d0, 0x2d00, 0x2d000, 0x2d0000, 0x2d00000, 0x2d000000, 0x2d0000000, 0x2d00000000, 0x2d000000000, 0x2d0000000000, 0xd0000000005a, 0x451, 0x4510, 0x45100, 0x451000, 0x4510000, 0x45100000, 0x451000000, 0x4510000000, 0x45100000000, 0x451000000000, 0x5100000000b4, 0x100000000bd9, 0xbdbd, 0xbdbd0, 0xbdbd00, 0xbdbd000, 0xbdbd0000, 0xbdbd00000, 0xbdbd000000, 0xbdbd0000000, 0xbdbd00000000, 0xdbd00000011f, 0xbd0000001001, 0xd0000001010f});\n+constexpr StatTable48 SQR4_TABLE_48({0x1, 0x10000, 0x100000000, 0x2d, 0x2d0000, 0x2d00000000, 0x451, 0x4510000, 0x45100000000, 0xbdbd, 0xbdbd0000, 0xbdbd00000000, 0x101101, 0x1011010000, 0x1101000002d0, 0x2d2fd2d, 0x2d2fd2d0000, 0xfd2d0000454a, 0x45514551, 0x455145510000, 0x4551000bd0bd, 0xbd0b6d0bd, 0xd0b6d0bd011f, 0xd0bd0100011e, 0x10001010001, 0x10100012d00, 0x12d002d2d, 0x2d002d2d002d, 0x2d2d00295100, 0x2951045551, 0x5104555104e5, 0x555104ecbdb4, 0x4ecbdbd00bd, 0xbdbd00bdadbc, 0xbdadac1101, 0xadac11011001, 0x11011013c3fc, 0x1013c3fefd2d, 0xc3fefd2fd2a7, 0xfd2fd2baac36, 0xd2baac2d450b, 0xac2d45145ac2, 0x45145ad0f851, 0x5ad0f85adb64, 0xf85adb6cbd10, 0xdb6cbd0bd0a2, 0xbd0bd0bc003c, 0xd0bc002c001f});\n+constexpr StatTable48 SQR8_TABLE_48({0x1, 0x2d2fd2d0000, 0x4ecbdbd00bd, 0x2c0000002c, 0x47882d9b95ec, 0xb9eec2eefc90, 0xbd900450, 0x9734009bfc8f, 0x93070a51e9b7, 0xb9d0aa02ec00, 0x8630787dd0ab, 0x6b3468ab98c9, 0x4100001bc1bd, 0x3ffeec1692fd, 0x2e0cce80414a, 0x11a77fc95626, 0x7c9856084ffe, 0x2f41c702f193, 0xd260e95bfeeb, 0x3b86220b54eb, 0x5735c802071a, 0x44626fc7ba84, 0x2b9cda923f5b, 0xc57d0a962e45, 0xd1685001450b, 0x6d78400145b6, 0x9114412978c1, 0x7d9ece1f5b0c, 0xfd2419988960, 0xd12ac3eaeaa5, 0x7d67e75f441d, 0xf86c2ba5457c, 0x40db7617aa6a, 0x80ee292186, 0xbd0f8525d34c, 0xa87ce27ca699, 0xacf3315d7a6d, 0x1a289bca977, 0x92975374e0f1, 0x3fcf113826ab, 0xff4d9be19a5e, 0x1412e5091900, 0x82c721f22d43, 0x1d773380ff32, 0xfed661cca7b1, 0x308072e06846, 0xd3eb44e91aa0, 0x819a669cbb14});\n+constexpr StatTable48 SQR16_TABLE_48({0x1, 0x50c24311dfa9, 0xfc08c1e39482, 0xa9ff91b620a3, 0x54954a59d16c, 0xec45c0a9fb02, 0xba7004022837, 0xc1ea19828166, 0xee9a3efecffe, 0x57ed421a20bb, 0x69d387b19141, 0x9105d02d728f, 0xd2f24d4006da, 0x39195005f508, 0xd0206ff5333c, 0x8592e734a441, 0x787b36a1c435, 0x1151e6f03f85, 0xfe0429bf95ab, 0xab2b20b47651, 0x2a65fc935212, 0x7f73ae670e2e, 0x697c17f0fc4a, 0x55dc5681f013, 0xadbd09a289bc, 0x418414f64940, 0x927c737efd40, 0x38535d08fc98, 0xe811b107691c, 0x856c3bbf4cf6, 0x47e629ad3757, 0xf9c82b4b2c09, 0x64312c99e2f, 0xd4936c978dfd, 0x782ff8716675, 0xaf853e867dd7, 0x457143c1fa6d, 0x84c4dda48e91, 0xbac9aacda41e, 0x6a6e0ffb2dc1, 0xfef377f00194, 0x3a129790acc1, 0x541e49c6f92a, 0x73e821aca96d, 0x3a6f15c03f57, 0x1bf377c66f3b, 0xbff5e192fe3b, 0x346360ee74a});\n+constexpr StatTable48 QRT_TABLE_48({0xc00442c284f0, 0xc16b7fda410a, 0xc16b7fda4108, 0xada3b5c79fbe, 0xc16b7fda410c, 0x16f3c18d5b0, 0xada3b5c79fb6, 0x7090a381f64, 0xc16b7fda411c, 0xcafc15d179f8, 0x16f3c18d590, 0x6630880e534e, 0xada3b5c79ff6, 0xa13dd1f49826, 0x7090a381fe4, 0xb87560f6a74, 0xc16b7fda401c, 0xaaaaffff0012, 0xcafc15d17bf8, 0xaafd15f07bf6, 0x16f3c18d190, 0x60000020000e, 0x6630880e5b4e, 0xcb977fcb401c, 0xada3b5c78ff6, 0x6663420cad0, 0xa13dd1f4b826, 0xc0045fc2f41c, 0x7090a385fe4, 0x6762e24b834, 0xb87560fea74, 0xc6351fed241c, 0xc16b7fdb401c, 0x60065622ea7a, 0xaaaafffd0012, 0xdf9562bea74, 0xcafc15d57bf8, 0x6657ea057bea, 0xaafd15f87bf6, 0xa79329ddaa66, 0x16f3c08d190, 0xa39229f0aa66, 0x60000000000e, 0x175fb4468ad0, 0x6630884e5b4e, 0, 0xcb977f4b401c, 0x2630884e5b40});\n+typedef Field<uint64_t, 48, 45, StatTable48, &SQR_TABLE_48, &SQR2_TABLE_48, &SQR4_TABLE_48, &SQR8_TABLE_48, &SQR16_TABLE_48, &QRT_TABLE_48, IdTrans, &ID_TRANS, &ID_TRANS> Field48;\n+\n+}\n+\n+Sketch* ConstructClMul6Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 41: return new SketchImpl<Field41>(implementation, 41);\n+    case 42: return new SketchImpl<Field42>(implementation, 42);\n+    case 43: return new SketchImpl<Field43>(implementation, 43);\n+    case 44: return new SketchImpl<Field44>(implementation, 44);\n+    case 45: return new SketchImpl<Field45>(implementation, 45);\n+    case 47: return new SketchImpl<Field47>(implementation, 47);\n+    case 48: return new SketchImpl<Field48>(implementation, 48);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri6Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 41: return new SketchImpl<FieldTri41>(implementation, 41);\n+    case 42: return new SketchImpl<FieldTri42>(implementation, 42);\n+    case 44: return new SketchImpl<FieldTri44>(implementation, 44);\n+    case 46: return new SketchImpl<FieldTri46>(implementation, 46);\n+    case 47: return new SketchImpl<FieldTri47>(implementation, 47);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "cc33d745910dfdac6ba6c3a1b6adbbb6eb18fb0e",
        "filename": "src/minisketch/src/fields/clmul_7bytes.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_7bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_7bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_7bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 49 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable49;\n+constexpr StatTable49 SQR_TABLE_49({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x402, 0x1008, 0x4020, 0x10080, 0x40200, 0x100800, 0x402000, 0x1008000, 0x4020000, 0x10080000, 0x40200000, 0x100800000, 0x402000000, 0x1008000000, 0x4020000000, 0x10080000000, 0x40200000000, 0x100800000000, 0x402000000000, 0x1008000000000, 0x20000000402, 0x80000001008, 0x200000004020, 0x800000010080});\n+constexpr StatTable49 SQR2_TABLE_49({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x1008, 0x10080, 0x100800, 0x1008000, 0x10080000, 0x100800000, 0x1008000000, 0x10080000000, 0x100800000000, 0x1008000000000, 0x80000001008, 0x800000010080, 0x100004, 0x1000040, 0x10000400, 0x100004000, 0x1000040000, 0x10000400000, 0x100004000000, 0x1000040000000, 0x400001008, 0x4000010080, 0x40000100800, 0x400001008000, 0x10080402, 0x100804020, 0x1008040200, 0x10080402000, 0x100804020000, 0x1008040200000, 0x80402001008, 0x804020010080, 0x40200100004, 0x402001000040, 0x20010000002, 0x200100000020});\n+constexpr StatTable49 SQR4_TABLE_49({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x1008000, 0x10080000000, 0x800000010080, 0x100004000, 0x1000040000000, 0x400001008000, 0x10080402000, 0x804020010080, 0x200100000020, 0x1000000001000, 0x11008000, 0x110080000000, 0x800000110880, 0x1108004000, 0x1080040001008, 0x400011008400, 0x110084402000, 0x844020110880, 0x201108040220, 0x1080402000008, 0x20001008002, 0x10080000100, 0x800001010080, 0x10100004000, 0x1000040010080, 0x400101808000, 0x1018080402000, 0x8040210100c0, 0x210100400020, 0x1004000011080, 0x11180c020, 0x11180c0200000, 0xc020011108c0, 0x11108004010, 0x1080040111088, 0x401111808400, 0x1118084403008, 0x8440311908c0, 0x311908440220, 0x108440211008c, 0x2110184c022, 0x10184c0201108, 0xc020100904c2, 0x100904024010, 0x1040240000004});\n+constexpr StatTable49 SQR8_TABLE_49({0x1, 0x800000110880, 0x210100400020, 0x1040240000004, 0x130081008002, 0x191c0a54130c8, 0x900804130890, 0x210111408020, 0x582c0402004, 0xd320910984c0, 0xb1d1ad4522e8, 0x1d80945829818, 0x1218540601128, 0x1240340000024, 0x11300c1018082, 0x193d1a4c5f0ea, 0x148a0522810, 0xe0201051c8e0, 0x2dc7c25120a8, 0x1d2205148a440, 0x33c0adc0e24a, 0x17850e987bab8, 0xa8a40071c9e0, 0x10d47d391c1a8, 0x9740b01888c2, 0x91c0e54130c8, 0x920805138892, 0x130819500b028, 0x8583c0516884, 0x1fa25934984e8, 0x1f5c2fcc5a6ec, 0x15a094483189a, 0x1014cc242300, 0xac020000582c, 0x3b05524100aa, 0x1520255145c6e, 0x4279b95aec40, 0x1f1a0951178e8, 0xbcc646004828, 0x3b055219aca8, 0x57d2fc40666e, 0xba50b987beba, 0x8aa44d913bea, 0x944717d1b9a0, 0x776562491022, 0x1701305105c4c, 0x19039cd5be842, 0x1b281d8e58082, 0x134dac80532a4});\n+constexpr StatTable49 SQR16_TABLE_49({0x1, 0x790181b552e0, 0xeb19044e00a, 0xc6bf7911f7ae, 0x447f77c1a0c4, 0x19d2a0d21c480, 0x13d4e22aadedc, 0x18fa344c8f0a6, 0x1481c1bbfde92, 0x41547e22f6e0, 0xf5ad96335088, 0xd7e4db3adaa0, 0x197fc8d7b53d0, 0x37781564b82a, 0xa52ef2139cbc, 0x153c6a0949498, 0x18d7401fc152e, 0xc4b5d8597752, 0xd15cd891aa2, 0x217903427da8, 0x13ec9e269a0e0, 0xc01720774514, 0x389aeb1d788a, 0x64a914a860a4, 0xa09aebec6188, 0x15c3239e150c8, 0x38f8fe110ce, 0xc1ea415c5006, 0x3209972f2ff0, 0x41bfc6b2ad88, 0x1ccc2fd5f73c8, 0x7bed1f863c00, 0x1a46d9b9844f4, 0x12e3ca6573ff6, 0x290c26cca98c, 0x514cb03b3b2e, 0x11168909cbc2c, 0x8e6dc910afda, 0x11311def1c440, 0x3e42d62664d8, 0x1c2bb2d75fe80, 0x2db5d58b45ca, 0x3d14059fd338, 0x109e8f457ebf8, 0x43b071b62a64, 0x185242247c010, 0x5e0c7721c092, 0x1c94950e46b82, 0x1761170f76a40});\n+constexpr StatTable49 QRT_TABLE_49({0, 0x10004196, 0x10004194, 0x5099461f080, 0x10004190, 0x40840600c20, 0x5099461f088, 0x58a56349cfde, 0x10004180, 0x48641a0c03fe, 0x40840600c00, 0x10084002848, 0x5099461f0c8, 0x4002048, 0x58a56349cf5e, 0x5088460a048, 0x10004080, 0x4c2852624dde, 0x48641a0c01fe, 0x14893129c280, 0x40840600800, 0x1eb23c323ace8, 0x10084002048, 0x48740a09417e, 0x5099461e0c8, 0x40852604d96, 0x4000048, 0x5cad2b29c37e, 0x58a563498f5e, 0x20000200, 0x50884602048, 0x10000000000, 0x10014080, 0x4c2a56624d96, 0x4c2852604dde, 0x1ee2347438ca0, 0x48641a0801fe, 0x480000000048, 0x14893121c280, 0x14091121c080, 0x40840700800, 0x1a5099561e17e, 0x1eb23c303ace8, 0x8740a894136, 0x10084402048, 0x18101c501ace8, 0x48740a89417e, 0x15dace6286f96, 0x5099561e0c8});\n+typedef Field<uint64_t, 49, 513, StatTable49, &SQR_TABLE_49, &SQR2_TABLE_49, &SQR4_TABLE_49, &SQR8_TABLE_49, &SQR16_TABLE_49, &QRT_TABLE_49, IdTrans, &ID_TRANS, &ID_TRANS> Field49;\n+typedef FieldTri<uint64_t, 49, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_49, &SQR2_TABLE_49, &SQR4_TABLE_49, &SQR8_TABLE_49, &SQR16_TABLE_49, &QRT_TABLE_49, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri49;\n+\n+// 50 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable50;\n+constexpr StatTable50 SQR_TABLE_50({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x1d, 0x74, 0x1d0, 0x740, 0x1d00, 0x7400, 0x1d000, 0x74000, 0x1d0000, 0x740000, 0x1d00000, 0x7400000, 0x1d000000, 0x74000000, 0x1d0000000, 0x740000000, 0x1d00000000, 0x7400000000, 0x1d000000000, 0x74000000000, 0x1d0000000000, 0x740000000000, 0x1d00000000000, 0x340000000001d, 0x1000000000053});\n+constexpr StatTable50 SQR2_TABLE_50({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x74, 0x740, 0x7400, 0x74000, 0x740000, 0x7400000, 0x74000000, 0x740000000, 0x7400000000, 0x74000000000, 0x740000000000, 0x340000000001d, 0x151, 0x1510, 0x15100, 0x151000, 0x1510000, 0x15100000, 0x151000000, 0x1510000000, 0x15100000000, 0x151000000000, 0x1510000000000, 0x1100000000069, 0x10000000006e4, 0x6e34, 0x6e340, 0x6e3400, 0x6e34000, 0x6e340000, 0x6e3400000, 0x6e34000000, 0x6e340000000, 0x6e3400000000, 0x2e3400000001d, 0x234000000011f, 0x3400000001118});\n+constexpr StatTable50 SQR4_TABLE_50({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x74000, 0x740000000, 0x340000000001d, 0x151000, 0x1510000000, 0x1100000000069, 0x6e3400, 0x6e34000000, 0x234000000011f, 0x1110100, 0x11101000000, 0x1010000000734, 0x7334740, 0x73347400000, 0x347400000145c, 0x14540510, 0x145405100000, 0x510000068b9, 0x68b91a34, 0x68b91a340000, 0x11a3400010106, 0x101010001, 0x1010100010000, 0x1000100074740, 0x1000747474000, 0x347474007401d, 0x340074015050d, 0x340150505101d, 0x1050510151069, 0x11015106e5a5d, 0x1106e5a5a3469, 0x25a5a346e351f, 0x2346e3510111e, 0x235101110001f, 0x111000110634, 0x1106347334, 0x1063473340074, 0x733400735301, 0x7353004541, 0x353004541014c, 0x454101446dc0, 0x101446dc1cb90, 0x6dc1cb97468d, 0x1cb97468c1a30, 0x3468c1a350009, 0x1a3500010007});\n+constexpr StatTable50 SQR8_TABLE_50({0x1, 0x7334740, 0x1050510151069, 0x3468c1a350009, 0x341624173531c, 0x245791a347b50, 0x23179d1a40682, 0x1671402235203, 0x321023818751e, 0x143ca5b716dd5, 0x171633ad257de, 0x33860681a5d1d, 0x5e572f82a317, 0x10e7512224646, 0x32d6b56300005, 0x350ab39687414, 0x25c47550c1a8a, 0x23a2e2d91533f, 0x2211af19c2381, 0x352073a863a68, 0x37f43380f0ac4, 0x233516127052a, 0x25ad4785169cf, 0x237b6a609b0b6, 0x132fd372b5dac, 0x1f311727562e, 0x345bd7e275754, 0x352fe5b3d7708, 0x259a328ca3376, 0x25101aab53ece, 0x32701d9da5ace, 0x17809a9c86099, 0x72b4752a7323, 0x202d22dc33a7c, 0x5a8c0dbc19a2, 0x14a86b37416ad, 0x5c574289fe12, 0x3627f3bf0f37b, 0x27349052a4f83, 0x2436d71033de5, 0x22fab345e0bce, 0x27ea796d5a27a, 0x1e4f33562d17, 0x31a1f9c3f2154, 0x1638db7753f96, 0x2256163f33b5f, 0x11a6ecf28882e, 0x1bd4cf35f47cc, 0x25e19aeb21e64, 0x371612d0b4dcd});\n+constexpr StatTable50 SQR16_TABLE_50({0x1, 0x14db3a1b1531f, 0x270a39b5e8c48, 0x26536a58442bd, 0x7f158d4b869e, 0x12663760f7d, 0x29634a2c8876, 0x15271f7ec5d31, 0x17fbb0726d0f0, 0x7f0f7bf826bb, 0x115135d3c7c4c, 0x348ffaaa125e5, 0x1887695a20d9, 0x25e41181c0de, 0x2670d7f17fb35, 0x356079737f513, 0x22bebda8a1574, 0x315f9649d2b50, 0x13abe45aa6ac8, 0x723d536b5242, 0x24263520a22a9, 0x15860c0156a69, 0x271d0bbeed892, 0x146920f281d19, 0x117d5d46e7991, 0x278d8273551fc, 0x15d73a9745614, 0x7e5e966bbfe0, 0x687b14e62abb, 0x178acea79fa5c, 0x3363c557e9662, 0x3153c79bf06ef, 0x15c8ff9daf7ce, 0x243b030f4617a, 0x20663fbd2383a, 0x25c5dbd448872, 0x21fc8dfbd2429, 0x229f9fb8f01b0, 0x17a180ae72359, 0x1c8e2f554ad9, 0x174596d1e774f, 0x3264c5da47f53, 0x333817d45b05c, 0x321907ec10dfd, 0x3a12b2018ada, 0x23ab0599cd08, 0x23028d60c00e5, 0x8ca05e2a1eab, 0x3537bf673a228, 0x32f8cf8611080});\n+constexpr StatTable50 QRT_TABLE_50({0xfbdfa3ae9d4c, 0x38143245a4878, 0x38143245a487a, 0x38527487e7492, 0x38143245a487e, 0x3124c61f56d2a, 0x38527487e749a, 0xfa8c91b087c0, 0x38143245a486e, 0x3eca48c6196be, 0x3124c61f56d0a, 0x380000040080a, 0x38527487e74da, 0x976b2d8b39b4, 0xfa8c91b08740, 0xfa8cd5b02724, 0x38143245a496e, 0x316291dd013fe, 0x3eca48c6194be, 0x10344122064, 0x3124c61f5690a, 0x68c5f006ee40, 0x380000040000a, 0x852749fe64d0, 0x38527487e64da, 0x37ef8e9d0e9da, 0x976b2d8b19b4, 0x37fabd1cef34a, 0xfa8c91b0c740, 0x96282d9159b4, 0xfa8cd5b0a724, 0x464a8249dd0, 0x38143245b496e, 0x37eaa8ddc94be, 0x316291dd213fe, 0x392446035690a, 0x3eca48c6594be, 0x974b258b4964, 0x103441a2064, 0x385a7c87fb4da, 0x3124c61e5690a, 0xeb8ad5d9a724, 0x68c5f026ee40, 0x3724c61e5690a, 0x380000000000a, 0x3a8c5f026ee4a, 0x8527497e64d0, 0, 0x38527497e64da, 0x2fbdfa2ae8d0a});\n+typedef Field<uint64_t, 50, 29, StatTable50, &SQR_TABLE_50, &SQR2_TABLE_50, &SQR4_TABLE_50, &SQR8_TABLE_50, &SQR16_TABLE_50, &QRT_TABLE_50, IdTrans, &ID_TRANS, &ID_TRANS> Field50;\n+\n+// 51 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable51;\n+constexpr StatTable51 SQR_TABLE_51({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x96, 0x258, 0x960, 0x2580, 0x9600, 0x25800, 0x96000, 0x258000, 0x960000, 0x2580000, 0x9600000, 0x25800000, 0x96000000, 0x258000000, 0x960000000, 0x2580000000, 0x9600000000, 0x25800000000, 0x96000000000, 0x258000000000, 0x960000000000, 0x2580000000000, 0x160000000004b, 0x580000000012c, 0x6000000000426});\n+constexpr StatTable51 SQR2_TABLE_51({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x96, 0x960, 0x9600, 0x96000, 0x960000, 0x9600000, 0x96000000, 0x960000000, 0x9600000000, 0x96000000000, 0x960000000000, 0x160000000004b, 0x6000000000426, 0x4114, 0x41140, 0x411400, 0x4114000, 0x41140000, 0x411400000, 0x4114000000, 0x41140000000, 0x411400000000, 0x4114000000000, 0x1140000000258, 0x1400000002516, 0x40000000251f6, 0x251d38, 0x251d380, 0x251d3800, 0x251d38000, 0x251d380000, 0x251d3800000, 0x251d38000000, 0x251d380000000, 0x51d380000012c, 0x1d3800000100e, 0x538000001003d, 0x380000010011e});\n+constexpr StatTable51 SQR4_TABLE_51({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x96000, 0x960000000, 0x160000000004b, 0x411400, 0x4114000000, 0x1140000000258, 0x251d380, 0x251d3800000, 0x1d3800000100e, 0x10010110, 0x100101100000, 0x1011000009600, 0x960969f6, 0x960969f60000, 0x169f60004110b, 0x6000411015132, 0x4110151054000, 0x1510540251f60, 0x540251f6ba760, 0x51f6ba74eb92c, 0x3a74eb900001f, 0x6b90000010033, 0x100010860, 0x1000108600000, 0x1086000096000, 0x960092874, 0x160092874004b, 0x128740041144b, 0x40041144304e2, 0x1144304c78258, 0x304c78251d1d8, 0x78251d1c38368, 0x1d1c38352800e, 0x3835280011188, 0x280011197096e, 0x1119709787000, 0x709787009fb46, 0x7009fb7861c9, 0x1fb7861cae24b, 0x61cae2456109, 0x2e245610a7bc3, 0x5610a7bd61498, 0x27bd614b79d2b, 0x614b79d3a74de, 0x79d3a74e9f68a, 0x274e9f6b06011, 0x1f6b06000000f});\n+constexpr StatTable51 SQR8_TABLE_51({0x1, 0x960969f6, 0x40041144304e2, 0x79d3a74e9f68a, 0x61005961939d4, 0x2e2108dfdafb5, 0xe7e61b897f73, 0x493a58b330d18, 0x7882105dc65ec, 0x5f00774200d11, 0x63ef4cd371ef3, 0x660b24b8d214b, 0x7ab791e669e3d, 0x10821820969f6, 0x1544b9d4c3f3e, 0x831185e3da14, 0x1eb0831983187, 0x1d8699ae87312, 0x586e000eb5f1a, 0x3ea794ef9c821, 0x2ab1c63209cc1, 0x7f434bcc29855, 0x673d370c40117, 0x6a668249ddd8b, 0x48be019e56bbe, 0x57d1a751be823, 0x5621931ca6d5f, 0x68c5a37844a68, 0xefa69123b6b1, 0x5804da97df62a, 0x30c29b82f3986, 0x5b808f6ddc779, 0x2c8b4e7596cbe, 0x2c5a432ec7a14, 0x7f178a4d63277, 0x77112a07b99b7, 0x56cf47ad50529, 0x73a2180190a41, 0x25cbc68f1f1a8, 0x1c27dc22e6950, 0x2fbf4aafee2ad, 0x554b728a595ca, 0x52726d34627e, 0x6dcc716c9e860, 0x36ade274d5eff, 0x1fa23a55b359a, 0x1bc6260896059, 0x53a74c5798bc1, 0x50e671fc54a4a, 0x251a72b3c4c3c, 0x6d9623f5d3a1e});\n+constexpr StatTable51 SQR16_TABLE_51({0x1, 0x27b32044e9663, 0x528c08dd195bf, 0x5d461228d5764, 0x616db8f131bf6, 0x9d910988ca4, 0x1e7a7a29c55fd, 0x512a2e6297818, 0x688d44453ead0, 0x70e0b6e1b3be2, 0x4313e5612d70, 0x132241d43589d, 0x7ca688c29c89a, 0x1d6b8caeb8958, 0x36d06e8e76e3b, 0x18ebafc89388e, 0x1cb5f93b2c29c, 0x5137bd7b7b6ec, 0x6e3ae8731000b, 0x359203e5e12fe, 0x1822ded1f1e16, 0x3ee9c50cbcb89, 0x5cc0b4564ab4, 0x695b235bd9236, 0x283c619a1ecb, 0x6f37f1f6ef70d, 0x7f394b6fbdd53, 0x3f482b36793f, 0x4055274e56dfa, 0x1a85d9d434f33, 0x37aa8f3df2031, 0x5f4e77b2bb063, 0x6e9702d84f07b, 0x25f16f8ffd4c2, 0x22c591d8277cb, 0x59435d9bae242, 0x46eaf9f69ddd9, 0x3098c1e26bd6e, 0x6c6544847a1d, 0x254946c0c33ce, 0x23970a6118811, 0x67f6c55082b49, 0x6592c83ebde46, 0x716418f089ed8, 0x8cb8de463166, 0x37cb1794fac42, 0x94ac55c1ac68, 0x3ab0d33bb4fdf, 0x1669c2f7ae3c5, 0x4d4e4f61d1f04, 0x476980d17eef5});\n+constexpr StatTable51 QRT_TABLE_51({0x778bf2703d152, 0x2aaaafbff2092, 0x2aaaafbff2090, 0x4d2119c7e7780, 0x2aaaafbff2094, 0x65de1df8ae194, 0x4d2119c7e7788, 0x67d63d7ba262c, 0x2aaaafbff2084, 0x28ff003f4167c, 0x65de1df8ae1b4, 0x658397fb1d034, 0x4d2119c7e77c8, 0x4d7c9284526ba, 0x67d63d7ba26ac, 0x6666333fc0cbe, 0x2aaaafbff2184, 0x295b807ab55ee, 0x28ff003f4147c, 0x2aaabfffe0016, 0x65de1df8ae5b4, 0x209210349d60, 0x658397fb1d834, 0x4d215dc7cf1c8, 0x4d2119c7e67c8, 0x662b2b3d7b4be, 0x4d7c9284506ba, 0x255af00b36e0, 0x67d63d7ba66ac, 0x65de1fb8ac1a6, 0x6666333fc8cbe, 0x662f3b3ded4be, 0x2aaaafbfe2184, 0x663a9dbc3a426, 0x295b807a955ee, 0x4cdc9ec128928, 0x28ff003f0147c, 0x28a0c93cd511c, 0x2aaabfff60016, 0x65d73cf8e78d4, 0x65de1df9ae5b4, 0x4d5eddc44f1c8, 0x209210149d60, 0x357fcc506c8a, 0x658397ff1d834, 0, 0x4d215dcfcf1c8, 0x63f536f5d4554, 0x4d2119d7e67c8, 0x4000000000022, 0x662b2b1d7b4be});\n+typedef Field<uint64_t, 51, 75, StatTable51, &SQR_TABLE_51, &SQR2_TABLE_51, &SQR4_TABLE_51, &SQR8_TABLE_51, &SQR16_TABLE_51, &QRT_TABLE_51, IdTrans, &ID_TRANS, &ID_TRANS> Field51;\n+\n+// 52 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable52;\n+constexpr StatTable52 SQR_TABLE_52({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x240000, 0x900000, 0x2400000, 0x9000000, 0x24000000, 0x90000000, 0x240000000, 0x900000000, 0x2400000000, 0x9000000000, 0x24000000000, 0x90000000000, 0x240000000000, 0x900000000000, 0x2400000000000, 0x9000000000000, 0x4000000000012});\n+constexpr StatTable52 SQR2_TABLE_52({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x9, 0x90, 0x900, 0x9000, 0x90000, 0x900000, 0x9000000, 0x90000000, 0x900000000, 0x9000000000, 0x90000000000, 0x900000000000, 0x9000000000000, 0x41, 0x410, 0x4100, 0x41000, 0x410000, 0x4100000, 0x41000000, 0x410000000, 0x4100000000, 0x41000000000, 0x410000000000, 0x4100000000000, 0x1000000000024, 0x249, 0x2490, 0x24900, 0x249000, 0x2490000, 0x24900000, 0x249000000, 0x2490000000, 0x24900000000, 0x249000000000, 0x2490000000000, 0x4900000000012, 0x9000000000104});\n+constexpr StatTable52 SQR4_TABLE_52({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x9000, 0x90000000, 0x900000000000, 0x4100, 0x41000000, 0x410000000000, 0x2490, 0x24900000, 0x249000000000, 0x1001, 0x10010000, 0x100100000000, 0x1000000000900, 0x9009000, 0x90090000000, 0x900000000410, 0x4104100, 0x41041000000, 0x410000000249, 0x2492490, 0x24924900000, 0x9249000000104, 0x1000001, 0x10000010000, 0x100000090, 0x1000000900000, 0x9000009000, 0x90000041, 0x900000410000, 0x4100004100, 0x1000041000024, 0x410000249000, 0x2490002490, 0x4900024900012, 0x249000100100, 0x1001001001, 0x10010010009, 0x100100090090, 0x1000900900900, 0x9009009009000, 0x90090041041, 0x900410410410, 0x4104104104100, 0x1041041024924, 0x410249249249, 0x2492492492490, 0x4924924910002, 0x9249100000004});\n+constexpr StatTable52 SQR8_TABLE_52({0x1, 0x1000000000900, 0x900000410000, 0x410249249249, 0x349100000000, 0x1900000d1, 0x10d10d1065965, 0x51010000, 0x2d924909000, 0x4114114114109, 0xe591, 0x1000007c96591, 0x1903981d13981, 0x249000000001, 0x1000100000990, 0x990090451041, 0x41022cb49249, 0x37d824910000, 0x90191890190d8, 0x10d10d106edf5, 0x54114101, 0x102f4b400bd90, 0x5c04114114108, 0x8f5900000ebcc, 0x1e59107b5f401, 0x8f5ab89f5abcc, 0x24924900001, 0x1010010010909, 0x90000041d100, 0x41024f7df7d9, 0x34a591003491, 0x9001900000d0, 0x4c10d106522c, 0xb49051500100, 0x43dafdb40249, 0x428c0c5114109, 0x59001f590e576, 0x49f59f25facf6, 0x19039c4c17881, 0x26fdb4902491, 0x10110010998, 0x109009045cc51, 0x90022a8867d9, 0x9527ffcb5a6dc, 0x9bc01190190d9, 0x14c119006e608, 0x42fd9e0d55042, 0x143f711b5bfd9, 0x5fa58e1809008, 0x23d647ac81eb2, 0x57ac8f223a466, 0x865abc8b4abcc});\n+constexpr StatTable52 SQR16_TABLE_52({0x1, 0x4f881c2d96599, 0xd7eb53011fc41, 0x81d7387961fef, 0xd9afe338982c3, 0x17590c140da98, 0x141a99a87a04e, 0x10036ba4083d9, 0x8f4f72ffb12c7, 0xc8b70df241e1b, 0x18bd9e5d46c40, 0x18331d76266bd, 0x4d915f264a4e0, 0x46aeffb8e4037, 0x4800042de37b5, 0xdb172953272e8, 0x17a9c2edf826a, 0x191cf7053e3f2, 0x82036da842cea, 0x5891da126c1e, 0x1e536e9e4af49, 0x451b5638f5449, 0x5a006c6c4f8c8, 0x5ac71a535fb44, 0xd39a4d489ebd0, 0x4704e31bc006d, 0xc4b327f6ffae1, 0x46980b709bd00, 0xd755405154c11, 0x5741be2d0b797, 0xcb3d48ed630cb, 0x98a66c9f4f599, 0x4caa324b91629, 0x816b5015eeeaf, 0xa595e92a8ed4, 0xc93c6d9f5a073, 0x4250068b39e2, 0x105add98997b5, 0x408b030c0bce0, 0xced5e4a4a2028, 0x1eb59d68e7f25, 0x189756a5b6db0, 0xc49c5a7c98b01, 0x18c9a496767cb, 0xde650554b3d49, 0x11077035fd81c, 0x8b37c5e95a659, 0x45b9226c2c25e, 0xdd2b5e20c7c8b, 0x6de972f0e7025, 0x84e80092f5681, 0x8dfcf97183cbc});\n+constexpr StatTable52 QRT_TABLE_52({0xc108165459b0e, 0x10004086, 0x10004084, 0xc00000100104e, 0x10004080, 0x2041810a545b0, 0xc000001001046, 0x1181e055efc0, 0x10004090, 0x40810214390, 0x2041810a54590, 0xc000141019106, 0xc000001001006, 0x10816045ab40, 0x1181e055ef40, 0xc000111015196, 0x10004190, 0xe045c19af44a2, 0x40810214190, 0xe045809ad0532, 0x2041810a54190, 0xdb387a03fe646, 0xc000141019906, 0x2000000800000, 0xc000001000006, 0x2486548199c34, 0x108160458b40, 0x2041808a50534, 0x1181e055af40, 0xc0408312153d6, 0xc00011101d196, 0x21499f0e0eed0, 0x10014190, 0xe15dff9faabe2, 0xe045c19ad44a2, 0xdb787b01ea7d6, 0x40810254190, 0xe484409180532, 0xe045809a50532, 0xc14095164d896, 0x2041810b54190, 0x217dee8fb7a74, 0xdb387a01fe646, 0x441810b54190, 0xc000141419906, 0xc3386e15e7f46, 0x2000000000000, 0x1000141419900, 0xc000000000006, 0, 0x248654a199c34, 0xa48654a199c32});\n+typedef Field<uint64_t, 52, 9, StatTable52, &SQR_TABLE_52, &SQR2_TABLE_52, &SQR4_TABLE_52, &SQR8_TABLE_52, &SQR16_TABLE_52, &QRT_TABLE_52, IdTrans, &ID_TRANS, &ID_TRANS> Field52;\n+typedef FieldTri<uint64_t, 52, 3, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5>, &SQR_TABLE_52, &SQR2_TABLE_52, &SQR4_TABLE_52, &SQR8_TABLE_52, &SQR16_TABLE_52, &QRT_TABLE_52, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri52;\n+\n+// 53 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable53;\n+constexpr StatTable53 SQR_TABLE_53({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x8e, 0x238, 0x8e0, 0x2380, 0x8e00, 0x23800, 0x8e000, 0x238000, 0x8e0000, 0x2380000, 0x8e00000, 0x23800000, 0x8e000000, 0x238000000, 0x8e0000000, 0x2380000000, 0x8e00000000, 0x23800000000, 0x8e000000000, 0x238000000000, 0x8e0000000000, 0x2380000000000, 0x8e00000000000, 0x3800000000047, 0xe00000000011c, 0x18000000000437});\n+constexpr StatTable53 SQR2_TABLE_53({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x238, 0x2380, 0x23800, 0x238000, 0x2380000, 0x23800000, 0x238000000, 0x2380000000, 0x23800000000, 0x238000000000, 0x2380000000000, 0x3800000000047, 0x18000000000437, 0x4054, 0x40540, 0x405400, 0x4054000, 0x40540000, 0x405400000, 0x4054000000, 0x40540000000, 0x405400000000, 0x4054000000000, 0x54000000008e, 0x54000000008e0, 0x14000000008e8e, 0x8ea56, 0x8ea560, 0x8ea5600, 0x8ea56000, 0x8ea560000, 0x8ea5600000, 0x8ea56000000, 0x8ea560000000, 0x8ea5600000000, 0xea5600000011c, 0xa560000001015, 0x560000001000b, 0x1600000010003e});\n+constexpr StatTable53 SQR4_TABLE_53({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x23800, 0x238000000, 0x2380000000000, 0x40540, 0x405400000, 0x4054000000000, 0x8ea56, 0x8ea560000, 0x8ea5600000000, 0x1600000010003e, 0x1000111000, 0x10001110000000, 0x11100000238000, 0x2380219b80, 0x380219b800047, 0x19b8000405447, 0x4054441114, 0x54441114008e, 0x41114008ea5ee, 0x14008ea5e6c1b8, 0xea5e6c193611c, 0x6c1936100000d, 0x13610000000124, 0x1010338, 0x10103380000, 0x1033800000238, 0x180000023a3e0f, 0x23a3e3d4000, 0x1a3e3d40000437, 0x1d400004014997, 0x40149af1600, 0x149af160008e0, 0xf160008e2a4a3, 0x8e2a4bc4710, 0x2a4bc47101015, 0x1c4710101022bb, 0x101010228120a8, 0x102281208ba380, 0x1208ba3a3c26c, 0xba3a3c26e7e1c, 0x3c26e7e0ad413, 0xe7e0ad414deb9, 0xad414dea4a7d0, 0x14dea4a7c40960, 0x4a7c4094acd8b, 0x4094acd82b43a, 0xacd82b432f376, 0x2b432f3623804, 0x12f36238010027});\n+constexpr StatTable53 SQR8_TABLE_53({0x1, 0x11100000238000, 0x1a3e3d40000437, 0x4a7c4094acd8b, 0x1eea7d6a679bbe, 0x1c423906384897, 0x2168da5f2c08c, 0x1b8259ec8ea11, 0x19d1f388b2d3d6, 0x1959a5720001a7, 0x1a6c8fa147c79, 0x191868056d58df, 0x19b717beaf7eb0, 0x1d37e92df66e7f, 0x16ec165c8535b7, 0x7da5e73dba0b3, 0x14d2bece5702b1, 0xadfaa30a5cf7e, 0x101934bec0d066, 0xaae7f006690ce, 0x6bfdbd85eb297, 0x6b2cb00d8c2b5, 0x52ee73aae547e, 0x67461baa976c2, 0xf8a44f459c7d, 0x2579abd0b5fc6, 0x6e7e5e9b82057, 0x1ab0a0fcf2d91c, 0x385dc87020053, 0xfc75a891c9df0, 0xca67b851d0c1a, 0x4c8d3234fd4f7, 0xf3ea564798c7f, 0x16881f479c0d6b, 0x60b0e8e33fe90, 0x18259a2869066d, 0xc52b463fb1475, 0x8229075c3475d, 0x6725108ff0948, 0xd5edf67d5a509, 0xbf52bb2383664, 0xd5b84ac7ed2ab, 0xbb5901d009d56, 0xcb380bfcebc5, 0x5f411d4594745, 0x18bdcb9f9d25da, 0xf0d3abe76ec15, 0x8b1a6404ca3b5, 0x15b7c7c793b65f, 0x11ff16f08569ff, 0x19c1d4c5eb3442, 0x5deb92ff5fc40, 0xa8009f9410cbc});\n+constexpr StatTable53 SQR16_TABLE_53({0x1, 0x5a65e677a526f, 0x142b8f50195f72, 0x12b0ca8e8b1225, 0x1b892547f268cc, 0x1239ca3a4824b6, 0x4249dac026ea8, 0x38080cba150e5, 0x903882481cefb, 0x1ad11e5cf99bf0, 0x14fa149116ab75, 0x6cbd888de21e5, 0x1388c718c37a69, 0x89d1eb38e9978, 0xf12019f00f91f, 0xb377986c7da1f, 0x1c780b06da5cb9, 0x1e10c7eee3249d, 0xe1afb7bd8111d, 0xc821f2a6fa090, 0x1a26caa65e1d59, 0x4280741c8cc4c, 0xb9c507337dad8, 0x65bffa0a097b6, 0x12068bb8ed4ac0, 0x6d751e7056355, 0xbccc3fbdcf084, 0x17ed82d58ea927, 0x125a30b543b4b8, 0xaf1ce3f5f84ce, 0x1082e42090b649, 0xf8d6a6212c41a, 0x1f89211d4982d, 0x1910bdfe092d07, 0x9363da9b9b9d3, 0x8a7196ef7b84e, 0x33fe46ddf1dc, 0x1f3f3291cf719d, 0x91a5da69f1035, 0x5a8dc6eb62cfb, 0xaf99fcc57728a, 0x15e73f1aa49f47, 0x2d82e50796b97, 0x1072fcbb074200, 0x15180f0fc7904, 0xa3a194b750f79, 0xb053c3eea9bb3, 0x1e58da5ae123de, 0x10b47afec00861, 0x17cd9ea910639d, 0x1ecf806dbf8c36, 0xf93d00fe6145b, 0x1247d788a3eda});\n+constexpr StatTable53 QRT_TABLE_53({0xf940b90844076, 0x1f940b90844052, 0x1f940b90844050, 0x9d2a063b43e64, 0x1f940b90844054, 0x936f69323ec14, 0x9d2a063b43e6c, 0xe12270a88898, 0x1f940b90844044, 0x1f917f00bb5a3c, 0x936f69323ec34, 0x1f622df85b46ee, 0x9d2a063b43e2c, 0x9bc65ab040b66, 0xe12270a88818, 0x958330b931986, 0x1f940b90844144, 0x98e2a06e32e0, 0x1f917f00bb583c, 0x1f877970dc1024, 0x936f69323e834, 0x16cc3c9b1558c2, 0x1f622df85b4eee, 0x16de1c3351dae8, 0x9d2a063b42e2c, 0x1fecdc7855f8ee, 0x9bc65ab042b66, 0x933821b1cb6fe, 0xe12270a8c818, 0x1f675958641c0e, 0x958330b939986, 0x9d97e050e960, 0x1f940b90854144, 0x1f820fa0e38adc, 0x98e2a06c32e0, 0x1650f0e358a010, 0x1f917f00bf583c, 0x1643af4b037a3a, 0x1f877970d41024, 0x1ffe2c281d8c16, 0x936f69333e834, 0xf00d50ffccf8, 0x16cc3c9b3558c2, 0x16bc31cbca943a, 0x1f622df81b4eee, 0xa6cbd8007232, 0x16de1c33d1dae8, 0x15d2a062b42e10, 0x9d2a062b42e2c, 0x1aa77896586ca, 0x1fecdc7a55f8ee, 0, 0x9bc65af042b66});\n+typedef Field<uint64_t, 53, 71, StatTable53, &SQR_TABLE_53, &SQR2_TABLE_53, &SQR4_TABLE_53, &SQR8_TABLE_53, &SQR16_TABLE_53, &QRT_TABLE_53, IdTrans, &ID_TRANS, &ID_TRANS> Field53;\n+\n+// 54 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable54;\n+constexpr StatTable54 SQR_TABLE_54({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x2010000000, 0x8040000000, 0x20100000000, 0x80400000000, 0x201000000000, 0x804000000000, 0x2010000000000, 0x8040000000000, 0x20100000000000, 0x400000000402, 0x1000000001008, 0x4000000004020, 0x10000000010080});\n+constexpr StatTable54 SQR2_TABLE_54({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x804, 0x8040, 0x80400, 0x804000, 0x8040000, 0x80400000, 0x804000000, 0x8040000000, 0x80400000000, 0x804000000000, 0x8040000000000, 0x400000000402, 0x4000000004020, 0x40001, 0x400010, 0x4000100, 0x40001000, 0x400010000, 0x4000100000, 0x40001000000, 0x400010000000, 0x4000100000000, 0x1000000201, 0x10000002010, 0x100000020100, 0x1000000201000, 0x10000002010000, 0x20100804, 0x201008040, 0x2010080400, 0x20100804000, 0x201008040000, 0x2010080400000, 0x20100804000000, 0x1008040001008, 0x10080400010080, 0x804000100004, 0x8040001000040, 0x400010000002, 0x4000100000020});\n+constexpr StatTable54 SQR4_TABLE_54({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x80400, 0x804000000, 0x8040000000000, 0x400010, 0x4000100000, 0x1000000201, 0x10000002010000, 0x20100804000, 0x1008040001008, 0x400010000002, 0x100000000100, 0x1008040, 0x10080400000, 0x804000000804, 0x8000001, 0x80000010000, 0x100004020, 0x1000040200000, 0x402000080400, 0x20000804020100, 0x8040200008000, 0x2000080400010, 0x804000000800, 0x8040001, 0x80400010000, 0x4000100004020, 0x1000040001000, 0x400010080400, 0x100804020100, 0x8040201008040, 0x2010080000010, 0x800000000004, 0x200, 0x2000000, 0x20000000000, 0x1008, 0x10080000, 0x100800000000, 0x8000000008040, 0x80002000, 0x800020000000, 0x200000040200, 0x402010080, 0x4020100800000, 0x1008000200008, 0x2000000002, 0x20000000020000, 0x201008000, 0x2010080000000, 0x800000100004});\n+constexpr StatTable54 SQR8_TABLE_54({0x1, 0x10080400000, 0x100804020100, 0x1008000200008, 0x10080002000000, 0x4000000804, 0x8000201000040, 0x402000000000, 0x20100004020, 0x1000000000, 0x80000010, 0x20100800000100, 0x201008, 0x80002010080, 0x804020100000, 0x201000040, 0x2000080000, 0x4020100004000, 0x8040000, 0x10000402000, 0x20000, 0x1008000001008, 0x10080402010080, 0x4000000004, 0x40001000040, 0x10080402, 0x4020000004000, 0x40001, 0x2000080402010, 0x20000000000000, 0x1000000200000, 0x10000000000080, 0x4020100000, 0x40201008040, 0x402000080002, 0x4020000800000, 0x1000000201, 0x2000080400010, 0x100800000000, 0x8040001008, 0x400000000, 0x20000004, 0x8040200000040, 0x80402, 0x20000804020, 0x201008040000, 0x80400010, 0x800020000, 0x1008040001000, 0x2010000, 0x4000100800, 0x8000, 0x402000000402, 0x4020100804020});\n+constexpr StatTable54 SQR16_TABLE_54({0x1, 0x80002010000, 0x4020000000000, 0x1000000201008, 0x402010000402, 0x20100804020000, 0x8000001000040, 0x2000000000000, 0x804020000800, 0x1000000201, 0x80002000080, 0x804020, 0x8, 0x400010080000, 0x20100000000000, 0x8000001008040, 0x2010080002010, 0x804020100804, 0x8000001, 0x10000000000000, 0x4020100004000, 0x8000001008, 0x400010000400, 0x4020100, 0x40, 0x2000080400000, 0x800000000804, 0x8040001, 0x10080400010080, 0x4020100804020, 0x40000008, 0x402, 0x20100800020000, 0x40000008040, 0x2000080002000, 0x20100800, 0x200, 0x10000402000000, 0x4000000004020, 0x40200008, 0x402000080002, 0x20100804020100, 0x200000040, 0x2010, 0x804000100804, 0x200000040200, 0x10000400010000, 0x100804000, 0x1000, 0x2010000402, 0x20000000020100, 0x201000040, 0x2010000400010, 0x804020100004});\n+constexpr StatTable54 QRT_TABLE_54({0x201008000200, 0x26c10916494994, 0x26c10916494996, 0x40008008, 0x26c10916494992, 0x141a2434c12d12, 0x40008000, 0x36c00110594c22, 0x26c10916494982, 0x200000040200, 0x141a2434c12d32, 0x10010816104534, 0x40008040, 0x36da60b01308b2, 0x36c00110594ca2, 0x48200209000, 0x26c10916494882, 0x41b6da2d86106, 0x200000040000, 0x32db2c228965b0, 0x141a2434c12932, 0x9000000200048, 0x10010816104d34, 0x32db68b2832da4, 0x40009040, 0x40045928b4902, 0x36da60b01328b2, 0x1000040000, 0x36c00110590ca2, 0x101b69865a4120, 0x48200201000, 0x22da6434912884, 0x26c10916484882, 0x9000240208008, 0x41b6da2da6106, 0x22c14484c20180, 0x200000000000, 0x4016db29b6812, 0x32db2c228165b0, 0x9008200201048, 0x141a2434d12932, 0x32c36ca2c264b0, 0x9000000000048, 0x140a65b48a2c32, 0x10010816504d34, 0, 0x32db68b2032da4, 0x404490824814, 0x41009040, 0x14da60a4536126, 0x40045908b4902, 0x8000041009008, 0x36da60b41328b2, 0x6db68b2032c12});\n+typedef Field<uint64_t, 54, 513, StatTable54, &SQR_TABLE_54, &SQR2_TABLE_54, &SQR4_TABLE_54, &SQR8_TABLE_54, &SQR16_TABLE_54, &QRT_TABLE_54, IdTrans, &ID_TRANS, &ID_TRANS> Field54;\n+typedef FieldTri<uint64_t, 54, 9, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6>, &SQR_TABLE_54, &SQR2_TABLE_54, &SQR4_TABLE_54, &SQR8_TABLE_54, &SQR16_TABLE_54, &QRT_TABLE_54, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri54;\n+\n+// 55 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable55;\n+constexpr StatTable55 SQR_TABLE_55({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x102, 0x408, 0x1020, 0x4080, 0x10200, 0x40800, 0x102000, 0x408000, 0x1020000, 0x4080000, 0x10200000, 0x40800000, 0x102000000, 0x408000000, 0x1020000000, 0x4080000000, 0x10200000000, 0x40800000000, 0x102000000000, 0x408000000000, 0x1020000000000, 0x4080000000000, 0x10200000000000, 0x40800000000000, 0x2000000000102, 0x8000000000408, 0x20000000001020});\n+constexpr StatTable55 SQR2_TABLE_55({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x102, 0x1020, 0x10200, 0x102000, 0x1020000, 0x10200000, 0x102000000, 0x1020000000, 0x10200000000, 0x102000000000, 0x1020000000000, 0x10200000000000, 0x2000000000102, 0x20000000001020, 0x10004, 0x100040, 0x1000400, 0x10004000, 0x100040000, 0x1000400000, 0x10004000000, 0x100040000000, 0x1000400000000, 0x10004000000000, 0x40000000102, 0x400000001020, 0x4000000010200, 0x40000000102000, 0x1020408, 0x10204080, 0x102040800, 0x1020408000, 0x10204080000, 0x102040800000, 0x1020408000000, 0x10204080000000, 0x2040800000102, 0x20408000001020, 0x4080000010004, 0x40800000100040, 0x8000001000008});\n+constexpr StatTable55 SQR4_TABLE_55({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x10200, 0x102000000, 0x1020000000000, 0x10004, 0x100040000, 0x1000400000000, 0x4000000010200, 0x102040800, 0x1020408000000, 0x4080000010004, 0x100000010, 0x1000000100000, 0x1000010200, 0x10000102000000, 0x1020000102000, 0x1020010004, 0x10200100040000, 0x1000400100040, 0x4001000410200, 0x10004102040800, 0x41020408102000, 0x4081020418004, 0x10204180000010, 0x41800000000040, 0x10300, 0x103000000, 0x1030000000000, 0x10106, 0x101060000, 0x1010600000000, 0x6000000010302, 0x103040c00, 0x103040c000000, 0x40c0000010106, 0x101020418, 0x1010204180000, 0x2041800010302, 0x18000103000008, 0x1030000103000, 0x1030010106, 0x10300101060000, 0x1010600101060, 0x6001010610302, 0x10106103040c00, 0x6103040c103020, 0x40c103041c106, 0x103041c1020418, 0x41c10204081060, 0x2040810214282, 0x8102142800008, 0x21428000000020});\n+constexpr StatTable55 SQR8_TABLE_55({0x1, 0x1000010200, 0x101060000, 0x6103040c103020, 0x1001400010200, 0x4081121478004, 0x7903050f103028, 0x1100010200, 0x1020101162000, 0x6703040c113322, 0x113055c1030618, 0x50a102353a804, 0x3e83050f11336a, 0x103040f102071e, 0x101070200, 0x7123050c143020, 0x3100c010200, 0x60c193166c286, 0x6d2b040f15302c, 0x103140f010200, 0x2070f112772e2, 0x7621050c153322, 0x143341cd420418, 0x70e193270ee9e, 0xbe9840f14334e, 0x143355fe53051e, 0x3050e103555fc, 0x5153e50f143c00, 0x1001500050200, 0x450a152957a004, 0x7b071d0f11332a, 0x1000040200, 0x5000040b060000, 0x64061a0c103020, 0x153c44f147c71e, 0x4008142b428a04, 0x2ca75c8f103078, 0x113341f117371e, 0x5402040b162000, 0x62064aac143336, 0x50c003f51ff06, 0x7cf1f3d7ef2e6, 0x6e2d180714332e, 0x103150f050100, 0x43350b1a3152e2, 0x74261e06143020, 0x113f54fd17c65e, 0x56301c3b66cd98, 0x10dff9c7953054, 0x153055fe47360e, 0x46340a1b2277fc, 0x4574bfb5753c14, 0x50f003345fc52, 0x41f653264c9962, 0x7612375be93322});\n+constexpr StatTable55 SQR16_TABLE_55({0x1, 0x4ba7488f00015a, 0x30ce9d3a61c1e4, 0x4a2e76980aff84, 0x4e44f5b9d2f610, 0x7b479e4450115c, 0x248c18e86b39b2, 0x1ba74c8406015a, 0x35e93420af76aa, 0x7f282c7c68ad54, 0x7f8b356ad7bc5a, 0x527272878d3b24, 0x587495a40395a4, 0x43c4d0fd51f96c, 0x57ce893a71f0c6, 0x62c68a94803da, 0x1b32bc920e6546, 0x5073c39b469c78, 0x2fba08c009b110, 0x10bd0559ba45c, 0x3bbbd0ca4b3246, 0x243ad4b7c193b8, 0x335d7f186b5db2, 0x5590f3a0fd73f0, 0x72953f208233ba, 0x5210b9a31e6c62, 0x744bb124e351da, 0x4929f00a730244, 0x736ff5bdc1c63c, 0x4c1da1fb246e2e, 0x553c18b46d95cc, 0x268f5c8c143376, 0x438f5a59cbf094, 0x6a718b25fd3946, 0x67053b1bf54fe0, 0x441c5323cb0288, 0x5def8fcd41d5a8, 0x40446cdfcdb062, 0x1043009fb20072, 0xef08d6ed9e9c6, 0xbdf8adea645be, 0x76b092b499c072, 0xd754f98b724c2, 0x5a21d55c8f8752, 0x4f0f36a62eeb0c, 0x262f651fb93b18, 0x3336d340aa0aaa, 0x69375d0e9970fa, 0x2e0997225afe66, 0x6692008b83364e, 0x230856519bc3ae, 0x2c0a54962f8378, 0x2a6460de8a4266, 0x2f14d8fa237452, 0x25934cd7ae0030});\n+constexpr StatTable55 QRT_TABLE_55({0, 0x121d57b6623fde, 0x121d57b6623fdc, 0x68908340d10e00, 0x121d57b6623fd8, 0x100300510e20, 0x68908340d10e08, 0x10004096, 0x121d57b6623fc8, 0x100010000, 0x100300510e00, 0x7ea8c890a088e8, 0x68908340d10e48, 0x68809540871648, 0x10004016, 0x68808000808068, 0x121d57b6623ec8, 0x68909240d41c48, 0x100010200, 0x6884c170ad0216, 0x100300510a00, 0x68848160a50200, 0x7ea8c890a080e8, 0x7eecbca04ab4b6, 0x68908340d11e48, 0x120c54b62234c8, 0x68809540873648, 0x69929240d61c48, 0x10000016, 0x68808060800000, 0x68808000800068, 0x80000080, 0x121d57b6633ec8, 0x7ea8cb90a18ae8, 0x68909240d61c48, 0x16284090200080, 0x100050200, 0x474302a345e, 0x6884c170a50216, 0x166cbca0cab4de, 0x100300410a00, 0x1000000000000, 0x68848160850200, 0x688cc1f0a50296, 0x7ea8c890e080e8, 0x7e8cc1f0a50280, 0x7eecbca0cab4b6, 0x68000000000068, 0x68908341d11e48, 0x7880954487365e, 0x120c54b42234c8, 0x9929248d61c20, 0x68809544873648, 0x41121208561c20, 0x69929248d61c48});\n+typedef Field<uint64_t, 55, 129, StatTable55, &SQR_TABLE_55, &SQR2_TABLE_55, &SQR4_TABLE_55, &SQR8_TABLE_55, &SQR16_TABLE_55, &QRT_TABLE_55, IdTrans, &ID_TRANS, &ID_TRANS> Field55;\n+typedef FieldTri<uint64_t, 55, 7, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5>, &SQR_TABLE_55, &SQR2_TABLE_55, &SQR4_TABLE_55, &SQR8_TABLE_55, &SQR16_TABLE_55, &QRT_TABLE_55, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri55;\n+\n+// 56 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable56;\n+constexpr StatTable56 SQR_TABLE_56({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x95, 0x254, 0x950, 0x2540, 0x9500, 0x25400, 0x95000, 0x254000, 0x950000, 0x2540000, 0x9500000, 0x25400000, 0x95000000, 0x254000000, 0x950000000, 0x2540000000, 0x9500000000, 0x25400000000, 0x95000000000, 0x254000000000, 0x950000000000, 0x2540000000000, 0x9500000000000, 0x25400000000000, 0x95000000000000, 0x5400000000012a, 0x5000000000043d, 0x40000000001061});\n+constexpr StatTable56 SQR2_TABLE_56({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x95, 0x950, 0x9500, 0x95000, 0x950000, 0x9500000, 0x95000000, 0x950000000, 0x9500000000, 0x95000000000, 0x950000000000, 0x9500000000000, 0x95000000000000, 0x5000000000043d, 0x4111, 0x41110, 0x411100, 0x4111000, 0x41110000, 0x411100000, 0x4111000000, 0x41110000000, 0x411100000000, 0x4111000000000, 0x41110000000000, 0x11100000000254, 0x110000000025d5, 0x10000000025dc5, 0x25dcc5, 0x25dcc50, 0x25dcc500, 0x25dcc5000, 0x25dcc50000, 0x25dcc500000, 0x25dcc5000000, 0x25dcc50000000, 0x25dcc500000000, 0x5dcc500000012a, 0xdcc50000001061, 0xcc500000010079, 0xc500000010016c, 0x5000000100103c});\n+constexpr StatTable56 SQR4_TABLE_56({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x9500, 0x95000000, 0x950000000000, 0x4111, 0x41110000, 0x411100000000, 0x110000000025d5, 0x25dcc500, 0x25dcc5000000, 0xdcc50000001061, 0x10010101, 0x100101010000, 0x1010100000950, 0x1000009509595, 0x95095959500, 0x5095959500043d, 0x95950004115111, 0x41151505011, 0x11515050110254, 0x505011025de985, 0x11025de9a93c10, 0x5de9a93c19c42a, 0xa93c19c400005d, 0x19c4000001000c, 0x100010094, 0x1000100940000, 0x1009400009500, 0x94000095009500, 0x950095418400, 0x954184004111, 0x41840041114111, 0x411141349dd4, 0x1141349dd425d5, 0x349dd425dce0d5, 0xd425dce0cce1b9, 0xdce0cce1ddd461, 0xcce1ddd4011160, 0xddd401110941f5, 0x1110941959dc4, 0x941959dc49cc5, 0x959dc49cc118d5, 0xc49cc1189454b9, 0xc1189454d4d12c, 0x9454d4d14358f8, 0xd4d14358b9aa44, 0x4358b9aa20a205, 0xb9aa20a221d7b8, 0x20a221d7ed10a2, 0x21d7ed10b0f90a, 0xed10b0f918507b, 0xb0f91850000050, 0x1850000001000d});\n+constexpr StatTable56 SQR8_TABLE_56({0x1, 0x1010100000950, 0x950095418400, 0xd4d14358b9aa44, 0x1135dd851025d5, 0x2c3e45b8a8a9d9, 0xcc39c4d816cc89, 0x51109400, 0x8496c8edb8f151, 0x1c2d7d88406199, 0x3856af0918b2ea, 0x2c26c02be43364, 0x7c13f0a9492898, 0x887abc757e3b3c, 0x10100411009c5, 0x850b98e029a995, 0x18309e7d346f24, 0x49e692600134d8, 0xf902789abce101, 0xed998d1d57187b, 0xa5488e663e846e, 0x84267921a952d0, 0x3d464f2d15176e, 0x801aac9d710b04, 0xfc00d6eb916343, 0x5c7fb78f391c1, 0x745ee236e80ea0, 0x81f8c65be65eac, 0x1940095415941, 0x1188025e2103d0, 0x49c166e0b13f34, 0xbd26558f28a2b3, 0xe147d131ae4b81, 0x25b501ad8ba86d, 0x75fb4e24c70a79, 0x88172901f1684d, 0xb090520bb570a2, 0x963c9b97aad59, 0x39b1e5f12c85a6, 0xd90de4c2bf3055, 0x9c921257e4a1b, 0x45f1f318fef834, 0x48161e1eb09635, 0x10685b397538ce, 0xbc8d4a0c6bc62a, 0xdce738247bfad9, 0x1115b3337d25a4, 0x195bf5a6f0999b, 0xb85101388b2f37, 0x8ee1b2833544cf, 0x49bc1efef7da90, 0x346e404662e355, 0x8c0dab6a1217d6, 0x3cb782ec54c968, 0x5efe07d4f59f4, 0x55f19c0f482900});\n+constexpr StatTable56 SQR16_TABLE_56({0x1, 0x2563e0b70105c4, 0x48ce07ef5576bb, 0xb94064d844f117, 0x207d2f511ffe3c, 0xf8f6dd1e2a3e6b, 0xe4cc405e0c6cdb, 0xd053f9b827b2bf, 0x550ae8d22edcbf, 0x29f7570f88728b, 0xa06a9e2dfd84a6, 0x55567b9483b3ff, 0x197c6c0d004df6, 0xe106c03f218a16, 0xc50dd2aaf0a388, 0x39473f6702a06c, 0xc8c1736b312ded, 0x992dc692bb707d, 0x24bb9a8dcad06f, 0x9cc45f9e3c2075, 0x455e7271eb130b, 0x847157a5326f59, 0xdc8ccb4ab3f5bd, 0x9463c02c46910d, 0xe1debd0b794514, 0x4c5128db660cde, 0x11910a685416a3, 0x11dfa5b9552a3d, 0x5d902ced822708, 0x794ff735e94601, 0xf1dc5fd7efcf7e, 0x19fb7ff8d06993, 0x7069119ac28a09, 0x98ba5a77d83e7f, 0xf4923dbc1b24e5, 0x7c2dcc84668312, 0xc27e2f5f2243f, 0x78c6d8ebe4bede, 0xad39495debf1a5, 0xa1564b894b50f0, 0x5898ae4e965be9, 0x28aa991e046567, 0x585e95889bb734, 0xc59e73661cf916, 0xed70696926d95d, 0xcca6630954309a, 0x8c4b12ac111264, 0xe8413ad0493e05, 0x1acea73bc9166, 0x9a7f11cd38d12d, 0x390dd1972139ec, 0x9146bc1a4fbff0, 0xd5a1c594335b01, 0x2566272e74ef1a, 0xd4a8baf259e7d0, 0x71e7efd8f20703});\n+constexpr StatTable56 QRT_TABLE_56({0x10004084, 0xd058f12fd5925e, 0xd058f12fd5925c, 0x41a60b5566d9f0, 0xd058f12fd59258, 0xbda60a142740ba, 0x41a60b5566d9f8, 0xd059f1afc5e688, 0xd058f12fd59248, 0xfc040841615a22, 0xbda60a1427409a, 0xbda60b5426c1ca, 0x41a60b5566d9b8, 0x1a60b4166b950, 0xd059f1afc5e608, 0xfc000041409822, 0xd058f12fd59348, 0xd1ee7a4ef4185c, 0xfc040841615822, 0x9049759b80b4a4, 0xbda60a1427449a, 0xd258e06f301e18, 0xbda60b5426c9ca, 0x6dfeeb3bf6d7d2, 0x41a60b5566c9b8, 0xbdef3ed4ae398a, 0x1a60b41669950, 0xd1ef3f8eeff04c, 0xd059f1afc5a608, 0xbda203340783de, 0xfc000041401822, 0x2dfefbaff2b27a, 0xd058f12fd49348, 0xfdb788a0706776, 0xd1ee7a4ef6185c, 0x2e5de0ae41337a, 0xfc040841655822, 0x41eb17d5ceecf8, 0x9049759b88b4a4, 0x40048874211afc, 0xbda60a1437449a, 0xd04a720f93400c, 0xd258e06f101e18, 0xbc559cf5ac7fce, 0xbda60b5466c9ca, 0x6dc9759b88b4d6, 0x6dfeeb3b76d7d2, 0x92feea7b275af0, 0x41a60b5466c9b8, 0, 0xbdef3ed6ae398a, 0x2811d5edd8ee2a, 0x1a60b45669950, 0xb1a60b5466c9ca, 0xd1ef3f86eff04c, 0xec493582c8f032});\n+typedef Field<uint64_t, 56, 149, StatTable56, &SQR_TABLE_56, &SQR2_TABLE_56, &SQR4_TABLE_56, &SQR8_TABLE_56, &SQR16_TABLE_56, &QRT_TABLE_56, IdTrans, &ID_TRANS, &ID_TRANS> Field56;\n+\n+}\n+\n+Sketch* ConstructClMul7Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 49: return new SketchImpl<Field49>(implementation, 49);\n+    case 50: return new SketchImpl<Field50>(implementation, 50);\n+    case 51: return new SketchImpl<Field51>(implementation, 51);\n+    case 52: return new SketchImpl<Field52>(implementation, 52);\n+    case 53: return new SketchImpl<Field53>(implementation, 53);\n+    case 54: return new SketchImpl<Field54>(implementation, 54);\n+    case 55: return new SketchImpl<Field55>(implementation, 55);\n+    case 56: return new SketchImpl<Field56>(implementation, 56);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri7Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 49: return new SketchImpl<FieldTri49>(implementation, 49);\n+    case 52: return new SketchImpl<FieldTri52>(implementation, 52);\n+    case 54: return new SketchImpl<FieldTri54>(implementation, 54);\n+    case 55: return new SketchImpl<FieldTri55>(implementation, 55);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "480228f44a7767cbb1837a74788482009bb1c60a",
        "filename": "src/minisketch/src/fields/clmul_8bytes.cpp",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_8bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_8bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_8bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,134 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"clmul_common_impl.h\"\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 57 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable57;\n+constexpr StatTable57 SQR_TABLE_57({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x8800000000, 0x22000000000, 0x88000000000, 0x220000000000, 0x880000000000, 0x2200000000000, 0x8800000000000, 0x22000000000000, 0x88000000000000, 0x20000000000011, 0x80000000000044});\n+constexpr StatTable57 SQR2_TABLE_57({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x88, 0x880, 0x8800, 0x88000, 0x880000, 0x8800000, 0x88000000, 0x880000000, 0x8800000000, 0x88000000000, 0x880000000000, 0x8800000000000, 0x88000000000000, 0x80000000000044, 0x404, 0x4040, 0x40400, 0x404000, 0x4040000, 0x40400000, 0x404000000, 0x4040000000, 0x40400000000, 0x404000000000, 0x4040000000000, 0x40400000000000, 0x4000000000022, 0x40000000000220, 0x2222, 0x22220, 0x222200, 0x2222000, 0x22220000, 0x222200000, 0x2222000000, 0x22220000000, 0x222200000000, 0x2222000000000, 0x22220000000000, 0x22200000000011, 0x22000000000101, 0x20000000001001});\n+constexpr StatTable57 SQR4_TABLE_57({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x880, 0x8800000, 0x88000000000, 0x80000000000044, 0x404000, 0x4040000000, 0x40400000000000, 0x22220, 0x222200000, 0x2222000000000, 0x20000000001001, 0x10001000, 0x100010000000, 0x100000000088, 0x880088, 0x8800880000, 0x88008800000000, 0x88000000040400, 0x404040400, 0x4040404000000, 0x4040000002222, 0x22222222, 0x222222220000, 0x22222200000101, 0x22000001000001, 0x10000000100, 0x100000001000000, 0x10000088000, 0x100000880000000, 0x8800000088000, 0x880004040, 0x8800040400000, 0x404000004040, 0x40000040400220, 0x404002222000, 0x40022220000220, 0x22200002222011, 0x22220100010, 0x22201000100011, 0x10001000100010, 0x10001000108800, 0x10001088008800, 0x10880088008800, 0x880088008c04, 0x88008c040404, 0x8c0404040404, 0x4040404040426, 0x4040404262222, 0x4042622222222, 0x26222222222222, 0x22222222232201, 0x22222322000001, 0x23220000000001});\n+constexpr StatTable57 SQR8_TABLE_57({0x1, 0x100010000000, 0x100000880000000, 0x88008c040404, 0x80000000022264, 0x26262604000101, 0x50023220100230, 0x222aa222000001, 0x20000404041401, 0x100404003222000, 0x32aa22aa23aa01, 0x2326048800088, 0x808100222ea722, 0x508e36ec548e34, 0x26222000022223, 0x22000223200001, 0x32001001108801, 0x91001000108844, 0x85048c04880044, 0x4c86ae64c80220, 0x6ea40546662003, 0x66662726ae22ab, 0x40622aa2aa40c8, 0x26063ea6364477, 0x2406744c950437, 0x8a33606aa727aa, 0xd09332ca7e2d9a, 0x7e2c14ce3e6c17, 0x22aa2626260405, 0x22200002626011, 0x27260000002223, 0x22208812aa3011, 0x2ba30040488001, 0x48c8c9caebe26, 0x28898040489001, 0x1048c008922aa26, 0x30c0c08a22b801, 0x12222666fa72601, 0x9afa60a8048eaa, 0x6aa1400afba131, 0xbc9c168c00800d, 0xc083aa60588bb0, 0xbeeefeae26e6e7, 0x8c44ee22226ae2, 0x8c44ee32205042, 0x2667443228d143, 0x36af14ba381d17, 0x72eb33981a3f35, 0x72c911aab20d9d, 0x72ca2b2aaacccd, 0x66463fae3f44ff, 0xac345eee3b4077, 0xe4977caefbe1fd, 0xf01b70a0dd0f9a, 0xf40f74bc580bbd, 0x17e2d1c6c5c0f35, 0x3624140232aa33});\n+constexpr StatTable57 SQR16_TABLE_57({0x1, 0xaeeec814065447, 0x110889c99ba3004, 0x1c59ed582798e0e, 0x1c9c766272a2a74, 0x1422928a5250a00, 0x2c97eb48f402a1, 0x10c6d916b128dea, 0x3f2e6ca66ebf67, 0x93ac75fcd63ec8, 0x19263128e42246, 0x1fd1ca54b556091, 0x60ff38200c4e09, 0x1381808ede9982b, 0xc7a9ace2f9dc2a, 0x6c2ee414271c57, 0x3c16f4cffdbe17, 0xc627ec6fe179ee, 0x178f994adf6525b, 0x18be0b635ca1650, 0x4afcb2ae2e98b6, 0x6f81f53a7688dd, 0x45319b3e02c15c, 0x1044be090058910, 0xaa02d012fca063, 0x11fba4c5b80dbfa, 0xf9f44be142268b, 0x1e351a44eb480bf, 0xacf5c17bd0aedf, 0x6f2d74bab851eb, 0x1b8ac3589da9915, 0x1afeb885d3fdd67, 0x7d7d596dd60bbd, 0x1329567316f5723, 0xfdfe23b549fcef, 0xc985ed1e7a009e, 0x71f794bbac1b03, 0xc740582125f7d0, 0x1b3584e031e3b77, 0x29978a3c559ed3, 0xde04d46b4ae516, 0x2f6d6e1c749405, 0x1ec95b44a4251f3, 0xb95b0a5f451f2d, 0x1dc80aedaab9bf2, 0xd0354d3ff74808, 0x180889b484b0364, 0x196895708367d90, 0x104575064a09414, 0x19e88f14fc111ec, 0x1cf4088d3cffd88, 0x1e6c28b9a76c6d5, 0x81ba060c9e485e, 0x12b811107188d68, 0x5e6f10ca82cd88, 0x120882748af043d, 0x145fb82467c596e});\n+constexpr StatTable57 QRT_TABLE_57({0xd0c3a82c902426, 0x232aa54103915e, 0x232aa54103915c, 0x1763e291e61699c, 0x232aa541039158, 0x1f424d678bb15e, 0x1763e291e616994, 0x26fd8122f10d36, 0x232aa541039148, 0x1e0a0206002000, 0x1f424d678bb17e, 0x5d72563f39d7e, 0x1763e291e6169d4, 0x1519beb9d597df4, 0x26fd8122f10db6, 0x150c3a87c90e4aa, 0x232aa541039048, 0x15514891f6179d4, 0x1e0a0206002200, 0x14ec9ba7a94c6aa, 0x1f424d678bb57e, 0x1e0f4286382420, 0x5d72563f3957e, 0x4000080000, 0x1763e291e6179d4, 0x1ac0e804882000, 0x1519beb9d595df4, 0x1f430d6793b57e, 0x26fd8122f14db6, 0x3c68e806882000, 0x150c3a87c9064aa, 0x1484fe18b915e, 0x232aa541029048, 0x14f91eb9b595df4, 0x15514891f6379d4, 0x48f6a82380420, 0x1e0a0206042200, 0x14b1beb99595df4, 0x14ec9ba7a9cc6aa, 0x4cf2a82b00420, 0x1f424d679bb57e, 0x26aa0002000000, 0x1e0f4286182420, 0x173f1039dd17df4, 0x5d72563b3957e, 0x4aa0002000000, 0x4000880000, 0x16d31eb9b595df4, 0x1763e291f6179d4, 0x20000000000000, 0x1ac0e806882000, 0x2caa0002000000, 0x1519beb99595df4, 0, 0x1f430d6f93b57e, 0x73e90d6d93b57e, 0x26fd8132f14db6});\n+typedef Field<uint64_t, 57, 17, StatTable57, &SQR_TABLE_57, &SQR2_TABLE_57, &SQR4_TABLE_57, &SQR8_TABLE_57, &SQR16_TABLE_57, &QRT_TABLE_57, IdTrans, &ID_TRANS, &ID_TRANS> Field57;\n+typedef FieldTri<uint64_t, 57, 4, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5>, &SQR_TABLE_57, &SQR2_TABLE_57, &SQR4_TABLE_57, &SQR8_TABLE_57, &SQR16_TABLE_57, &QRT_TABLE_57, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri57;\n+\n+// 58 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable58;\n+constexpr StatTable58 LOAD_TABLE_58({0x1, 0x77dd188d5d600, 0x41a7213270def0, 0x10921661867b40a, 0x880b92a6f74da3, 0x143e72cde8f4484, 0x1863cb65c3eee0e, 0x2a1aa4a82154057, 0x22265135db9e135, 0x1446f023770d6d0, 0x183c4be7b4fae6, 0x1cc8a1187e99bd4, 0x3a1ea282e1e2ff1, 0x2700aae9dbcd275, 0x1571f84428a416e, 0xc8eb0b234b8a57, 0x23227afc0d9ba75, 0x1de9497779018c7, 0x5898e896d43329, 0x1501bd1b83bb55f, 0xbb56c28ce180b, 0x188e087d2dbf7e0, 0x36eee77125d8ec9, 0xde4235cbe95166, 0x1c71e4d57306163, 0x2a7e1b1ae5d87ee, 0x3a685560450c909, 0x1cd0545bc185c4b, 0x151779b11f09892, 0x2ab069803c4d787, 0x3bf279c0b825ad5, 0x15edc1ef3d2513c, 0x37bf223b4d0d045, 0x262a786b0324cd3, 0x27658294b696713, 0x33771167b0137e8, 0x86a73ef2dc3271, 0xc64453d2ff05, 0x14c55bc975ce8c, 0x3581164b1e4826e, 0x461dde5468bc26, 0x3f31528346e9451, 0x3f2669a5324a555, 0xd0b1c042854400, 0x32cc9899ea263e3, 0x2a423a8a96f4e95, 0x3e64acd727b470b, 0x2f1f1c1de9c997d, 0x268f2df0a8ab060, 0x14fd82231712442, 0x106e14e5e9e8f8c, 0x2686a15d911a24c, 0x182f831c5142b40, 0x36ca3e60fc7c678, 0x22ba581841d83ff, 0x11539696ce13d17, 0x558c3670aecb8e, 0x2b9b2d828d6d864});\n+constexpr StatTable58 SAVE_TABLE_58({0x1, 0xde56167ca60c8e, 0x166391328282dfb, 0x2c6ed660535e701, 0xf83470e499e0e, 0x3686f752cff05fd, 0x1ada23d28022d0b, 0x2a2ac069b41ffd4, 0x2d40f316b40053e, 0x3fb69372877a1f3, 0x13def6e665e9b30, 0x23eb4222bc98b90, 0x2991c5ab618f62c, 0x1c4b63ee1e37a86, 0xdcb10179c77602, 0x708837c2f0ee59, 0x151fe1b533a6d99, 0x44613653cb9d83, 0x33dc64f2b5abae6, 0x27d704726f1f9ba, 0x2fdef2de96892ad, 0x3fd032a21834dbe, 0x1ce2548191e42ab, 0x431410a40ab44b, 0x206f1338c9a75e1, 0x130035675a32179, 0xdf781bb8adbd09, 0x1aaaf085ea624e0, 0x1df0605123c28e9, 0x28d3b3631320c9c, 0x81951a3af55e95, 0x388c776adc88ca1, 0x3ebed178f719885, 0x3c4546b19b0fe51, 0x129564a29700d09, 0x3f642277d82c520, 0x3a46d24ff0ac3fd, 0x1e75e367d627740, 0x33b01746a0f4aad, 0x2af930ca2fa61f, 0x3fcea0ca3af7aac, 0x230722de56e3f4a, 0x3541e58cc5afefd, 0x32cf711ae15ba7e, 0x11d3670d510fc6f, 0x6ddd78eec82112, 0x216210641885856, 0x87535f37c08809, 0x1fa464b5f82155b, 0xdbd43e91708494, 0x1500e23396dd2c4, 0x16cf4098632235f, 0x37e9117da8979ba, 0x6f8bfa04f66a7, 0x18dff008060e626, 0x196286fd9dbad1c, 0x35078156610f8ab, 0x7a669ff8398fea});\n+constexpr StatTable58 SQR_TABLE_58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x6300000000, 0x18c00000000, 0x63000000000, 0x18c000000000, 0x630000000000, 0x18c0000000000, 0x6300000000000, 0x18c00000000000, 0x63000000000000, 0x18c000000000000, 0x230000000000063, 0xc000000000014a, 0x300000000000528});\n+constexpr StatTable58 SQR2_TABLE_58({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x18c, 0x18c0, 0x18c00, 0x18c000, 0x18c0000, 0x18c00000, 0x18c000000, 0x18c0000000, 0x18c00000000, 0x18c000000000, 0x18c0000000000, 0x18c00000000000, 0x18c000000000000, 0xc000000000014a, 0x1405, 0x14050, 0x140500, 0x1405000, 0x14050000, 0x140500000, 0x1405000000, 0x14050000000, 0x140500000000, 0x1405000000000, 0x14050000000000, 0x140500000000000, 0x50000000001ef, 0x50000000001ef0, 0x10000000001ef63, 0x1ef7bc, 0x1ef7bc0, 0x1ef7bc00, 0x1ef7bc000, 0x1ef7bc0000, 0x1ef7bc00000, 0x1ef7bc000000, 0x1ef7bc0000000, 0x1ef7bc00000000, 0x1ef7bc000000000, 0x2f7bc0000000129, 0x37bc0000000112d, 0x3bc000000011027, 0x3c0000000110022});\n+constexpr StatTable58 SQR4_TABLE_58({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x18c0, 0x18c00000, 0x18c000000000, 0xc000000000014a, 0x1405000, 0x14050000000, 0x140500000000000, 0x1ef7bc, 0x1ef7bc0000, 0x1ef7bc00000000, 0x3bc000000011027, 0x110001100, 0x1100011000000, 0x11000000194c, 0x1000000194c018c, 0x194c0194c000, 0x14c0194c000014a, 0x194c00001545500, 0x15455154550, 0x154551545500000, 0x1154550001f18df, 0x150001f18c63193, 0x1f18c6318c7c00, 0xc6318c7c01010a, 0x18c7c0101000014, 0x1010000000101, 0x1000000010118c0, 0x10118d8c000, 0x10118d8c0000000, 0xd8c0000018d98a, 0x18d9811050, 0x18d98110500000, 0x18110500001411a, 0x500001410eb94c, 0x1410eb94bbc00, 0x10eb94bbc001ef0, 0x14bbc001ee85ab2, 0x1ee85aac1111, 0x2e85aac11110129, 0x2ac11110111097a, 0x111011109445c8c, 0x11109445c9554c0, 0x1445c9554d95406, 0x9554d954189419, 0xd954189414901f, 0x1894149014051f, 0x149014051e478f, 0x14051e478ee2ec, 0x11e478ee2edef63, 0x38ee2edef7aded3, 0x2edef7adef6bdc8, 0x37adef6bdf07c2d, 0x2f6bdf07c0018f9, 0x1f07c0018c018d1});\n+constexpr StatTable58 SQR8_TABLE_58({0x1, 0x1100011000000, 0x10118d8c0000000, 0xd954189414901f, 0xc018def7a2f6f6, 0x1e19cc6d44444e, 0x2b2e8450d1ef706, 0x196294c624791e5, 0x2a9441aa2b74da8, 0x1c6810fa7a2fe66, 0x4e0f0eff6badbb, 0x26faf3a76e59127, 0x11aa58d6498919f, 0x3b3ce4e04f23b30, 0x2ed3f70684ae8d7, 0x8d64c737fc5014, 0x1516c589c4fd458, 0x5ba5cee14ea182, 0x368ad344d93d4ae, 0x15e2547ea25ba2a, 0xdecb4283969d9a, 0x2f2a95e5c791149, 0x3fc958586bc93d2, 0x3216bfeab663783, 0xced412d3f6e530, 0x85fb7bcb26d797, 0x19be97fdbcede01, 0x192a5409529ebf4, 0x98b4f8527795b1, 0x192e8188bbc9aac, 0x322f07e9abdf6d0, 0x2a4a5cd6239de91, 0x4c97dec82e63a, 0x37d6397e1d26aee, 0x1939dc6d77a98db, 0x2e23b8e5b0a982a, 0x2787751f5aa0dba, 0x3f81252033f3cc8, 0x1171b73d009f511, 0x8811f0328040bb, 0x3a659ae0b1d2417, 0xc8b454d91baa72, 0x197b01428520b86, 0x1872c8c17f7fe81, 0x143f7913f4c7f5, 0x3a71b7542e7ec68, 0x3e60d3d49155d34, 0x11d5f10402402c8, 0x2be8db11809a1df, 0x3667129f17b1d6a, 0x2749715db24cd0a, 0x185d6130cdfee96, 0x3abdc4d78640154, 0x39bd5ea2e22f89a, 0x3f9a113c1095209, 0xdb4c8bd4f72f4e, 0x32ae35f0ad0b4ee, 0x2f3770997f16cc});\n+constexpr StatTable58 SQR16_TABLE_58({0x1, 0x2fcd2228a7c16ab, 0x846ef4a277243e, 0x1d2bf9061084cfb, 0x23598fddcd64f64, 0xcc36f3a7174e2a, 0x365a50c11b89583, 0x611bed1afae48, 0x22a03fae7957244, 0x45e6546308ff3e, 0x3aebd6f3893b9b4, 0x2bf4a9d5586f8db, 0x32fd7d2d5d6f867, 0x14819feeb813a6f, 0x100ab4d9ad808fc, 0x11c0fd674209c71, 0x3701211690581e7, 0x5c33087013a39a, 0x188935ebbc048bb, 0x10787f930a52538, 0xd49849206986b2, 0x17d1298ba5b565, 0x5d465e006f3142, 0x569a5ce90e9bff, 0x2b591716524b4cb, 0x32f7d39faa352cf, 0x10f701fea440dc0, 0x11c5f10a9d3c9d5, 0x18457154a0bf6ea, 0x15516f140726673, 0x1cf780781353aa4, 0x2a7d7e0e83c4bbc, 0x276c009e3198958, 0x220b8531adc2c11, 0x937d7effc370ab, 0x27632fc1b91dac1, 0x3b36628aa135d3f, 0x37230eddd77f21a, 0x1c1b5e0f410eca9, 0x3200c9c78a9127f, 0x3a55e6fb19e6dc4, 0x150cb064eb271f7, 0x5c74759db43ae1, 0x37046240fba02a9, 0x1937118eb920f04, 0x2795ad9a663a0c9, 0x1d4297ad3d62e8a, 0x3b927d82816e04d, 0x15b56f89c278c21, 0x2b8e4ef675619d6, 0x2e0823575b9bb28, 0xdeb4b405ed7e9c, 0x83d627c04e5155, 0x391134c52f7ae67, 0x9e2c9657999608, 0x3b1e574e9a4eb3a, 0x2b58dd062cd0021, 0x38d1fb86f1978ab});\n+constexpr StatTable58 QRT_TABLE_58({0x21b9dfe73454bc2, 0x351ca3a13788360, 0x351ca3a13788362, 0x1ad5a042934094, 0x351ca3a13788366, 0x48f62c33f34cc, 0x1ad5a04293409c, 0x14b1f9a41eb8342, 0x351ca3a13788376, 0x3682437996f7786, 0x48f62c33f34ec, 0x21ad5a152920174, 0x1ad5a0429340dc, 0x3766ef998858a86, 0x14b1f9a41eb83c2, 0x151ca3a437843c2, 0x351ca3a13788276, 0x1e5ac7c1aff42c, 0x3682437996f7586, 0x3767ee558c7856a, 0x48f62c33f30ec, 0x39fb408a690330, 0x21ad5a152920974, 0x372f1d7dbf4255a, 0x1ad5a0429350dc, 0x39bb888af33330, 0x3766ef99885aa86, 0x27b58e0ba2df00, 0x14b1f9a41ebc3c2, 0x1540d06c191bcf2, 0x151ca3a4378c3c2, 0x39ee0d0a17f4c0, 0x351ca3a13798276, 0x2049f6c5379fdb4, 0x1e5ac7c1adf42c, 0x1ac5a182d64bf0, 0x3682437996b7586, 0x16cbe3c0a2c7c1e, 0x3767ee558cf856a, 0x372a1d35b20aa6a, 0x48f62c32f30ec, 0x26ab144a891cdc, 0x39fb408a490330, 0x205df3712ae76a8, 0x21ad5a152d20974, 0x34fb58f12e386b6, 0x372f1d7db74255a, 0x21b4a5f53871674, 0x1ad5a0439350dc, 0x1d602e40318fdc, 0x39bb8888f33330, 0x179bb8888f3332e, 0x3766ef99c85aa86, 0x2cec9eb2f5d0aa8, 0x27b58e03a2df00, 0x6caa1452491cdc, 0x14b1f9a51ebc3c2, 0});\n+typedef Field<uint64_t, 58, 99, StatTable58, &SQR_TABLE_58, &SQR2_TABLE_58, &SQR4_TABLE_58, &SQR8_TABLE_58, &SQR16_TABLE_58, &QRT_TABLE_58, StatTable58, &LOAD_TABLE_58, &SAVE_TABLE_58> Field58;\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTableTRI58;\n+constexpr StatTableTRI58 SQR_TABLE_TRI58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x80001, 0x200004, 0x800010, 0x2000040, 0x8000100, 0x20000400, 0x80001000, 0x200004000, 0x800010000, 0x2000040000, 0x8000100000, 0x20000400000, 0x80001000000, 0x200004000000, 0x800010000000, 0x2000040000000, 0x8000100000000, 0x20000400000000, 0x80001000000000, 0x200004000000000, 0x10000100002, 0x40000400008, 0x100001000020, 0x400004000080, 0x1000010000200, 0x4000040000800, 0x10000100002000, 0x40000400008000, 0x100001000020000});\n+constexpr StatTableTRI58 SQR2_TABLE_TRI58({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x200004, 0x2000040, 0x20000400, 0x200004000, 0x2000040000, 0x20000400000, 0x200004000000, 0x2000040000000, 0x20000400000000, 0x200004000000000, 0x40000400008, 0x400004000080, 0x4000040000800, 0x40000400008000, 0x4000000001, 0x40000000010, 0x400000000100, 0x4000000001000, 0x40000000010000, 0x180001, 0x1800010, 0x18000100, 0x180001000, 0x1800010000, 0x18000100000, 0x180001000000, 0x1800010000000, 0x18000100000000, 0x180001000000000, 0x10000300006, 0x100003000060, 0x1000030000600, 0x10000300006000, 0x100003000060000, 0x30000400004, 0x300004000040, 0x3000040000400, 0x30000400004000, 0x300004000040000, 0x4000020000c, 0x4000020000c0, 0x4000020000c00, 0x4000020000c000});\n+constexpr StatTableTRI58 SQR4_TABLE_TRI58({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x2000040, 0x20000400000, 0x200004000000000, 0x40000400008000, 0x4000000001000, 0x18000100, 0x180001000000, 0x10000300006, 0x100003000060000, 0x30000400004000, 0x4000020000c00, 0x200004000100, 0x40001400008, 0x14000000001, 0x140000000010000, 0x380005000, 0x3800050000000, 0x5000070000e0, 0x70000400014, 0x3000040001c0001, 0x40001a0001c000, 0x1a000140001000, 0x1400024000680, 0x240004000050, 0x40000180009, 0x1800010001, 0x18000100010000, 0x1000130000600, 0x1300004000040, 0x4000220004c, 0x22000440001, 0x220004400010000, 0x44000540008800, 0x5400000001100, 0x1b800150, 0x1b8001500000, 0x380015000300006, 0x15000370006e000, 0x37000440005400, 0x440003a000dc0, 0x3a0005400110, 0x20005400160000e, 0x140016400068001, 0x164000400015000, 0x4000398005900, 0x3980051000100, 0x5100063000e6, 0x100063000460014, 0x2300044001c4001, 0x44001820018c00, 0x18200104001100, 0x1040021400608, 0x214004000041, 0x140040000010008});\n+constexpr StatTableTRI58 SQR8_TABLE_TRI58({0x1, 0x40001400008, 0x1300004000040, 0x4000398005900, 0x21a004140001000, 0x15007370046e014, 0x14004001b810158, 0x18022100441001, 0x1005130063600e6, 0x4200004181059, 0x447a1a3f41ccd0, 0x383d151573100e6, 0x101600544019940, 0x270027c0059c000, 0x4818070100e1, 0x20545402560168e, 0x76071e40419414, 0x38001501bb00157, 0x18054101401149, 0x104343116260a0c, 0x17b9c06c9180809, 0x35b793b6107d791, 0x2e706624276b452, 0x3a543cf805118, 0x278004063619444, 0x22aae45555d4155, 0x105597ba5075e80, 0x364504676052ce, 0x35800790000401, 0x264044141418809, 0x3313274051a405d, 0x52c1b85195848, 0x57f03b8205e9e, 0x22c5044070044e0, 0x1547370047f115, 0x10402383a848d51, 0x16220024510a1, 0x4050579e30c9e7, 0x15e201b4605c018, 0x297e7fd6e672cc2, 0x286f01429f08ff7, 0x31c56646279854c, 0x36fd34ece6e98e6, 0x31e6939431f00b9, 0x311386d18673a0a, 0x2b6524f5cf195aa, 0x2dd63711ff50016, 0x1585649073391ae, 0x1004431143e1ab5, 0x13be61cf659d4d9, 0x98a87036371777, 0x66673706472d14, 0x273867fcbd99159, 0x27c4c58464098e9, 0x347304213c56db, 0x721f05c140cc15, 0x38144503ed007d9, 0x2e054541404549});\n+constexpr StatTableTRI58 SQR16_TABLE_TRI58({0x1, 0x3f4d56f7779e1f0, 0xe27368ee2eeacd, 0x135c653e9699a2f, 0x6b0f78c5b96a46, 0x25fa3044c7e0248, 0x2a078335aa8c788, 0x2b2fb5e8ec09222, 0x214fe2bd0b14a22, 0x10b6f34977f0f41, 0x3dc4a1564361cee, 0xa2ae7c793a9fcf, 0x7fc45e1a362304, 0x3ec19729047ce58, 0x1ef9b26acd27396, 0x225a72a9b2db21a, 0xaaa90ccba715d8, 0x2da6362d54cd62, 0x37dae1e3484d433, 0x1ced37972ce3594, 0x164d907773ab8b9, 0xbeaf6f3fc883a1, 0x1d8ac7ee4682652, 0x102fa1481f0470a, 0x3e17062fd515fba, 0x21652276c35fe65, 0x57862a59d3fa78, 0x36b077a8057cde3, 0x287ce593d9cee2f, 0x290b965ae5d215a, 0x2cc2a18d887125c, 0xc46c603fd8423b, 0xdcd705a0e16776, 0x3307e00c6585a3f, 0x2d82d4b6c18532d, 0x28efe74f174d530, 0x2ddbc57b95adaac, 0x31d41679a107eb4, 0x1f24f6f872cb97f, 0x32718f9b0a03ff6, 0x1f283546f68ca0c, 0x158f309c150c885, 0x1ccaf78ea1873ea, 0x30e3b732bf1875f, 0xcce47efdb9ecb1, 0xcf3954987b5601, 0xebdc136185c456, 0x388046727963e11, 0x22e117909faee51, 0x3215b67613a2a60, 0x172480d3a2f11de, 0x382552280610b4d, 0x3c53c5d9c350cce, 0x6edc0d3330295e, 0x3452a6b8c868f37, 0x398cd7e93017ecc, 0x2e1ec37c30a741e, 0xb00d11006ffa14});\n+constexpr StatTableTRI58 QRT_TABLE_TRI58({0x2450096792a5c5c, 0x610014271011c, 0x610014271011e, 0x1f0cb811314ea88, 0x610014271011a, 0x8000000420, 0x1f0cb811314ea80, 0x265407ad8a20bcc, 0x610014271010a, 0x3d18be98392ebd0, 0x8000000400, 0xc29b930e407056, 0x1f0cb811314eac0, 0x1fcef001154dee8, 0x265407ad8a20b4c, 0xc69b924c61f94a, 0x610014271000a, 0x211006895845190, 0x3d18be98392e9d0, 0x54007accac09cc, 0x8000000000, 0xc08b934e107854, 0xc29b930e407856, 0x275407adc220bcc, 0x1f0cb811314fac0, 0x1f6db815164ea8a, 0x1fcef001154fee8, 0x1b2db801945e396, 0x265407ad8a24b4c, 0x21100ec95865590, 0xc69b924c61794a, 0x273507b1e530ad6, 0x610014270000a, 0x1b4cb835b34e29c, 0x211006895865190, 0x3839bf20d47e016, 0x3d18be98396e9d0, 0x3858bd34f36e01c, 0x54007acca409cc, 0, 0x8000100000, 0xc29a130e507856, 0xc08b934e307854, 0x13253921d448296, 0xc29b930e007856, 0x13c60935f6486bc, 0x275407adca20bcc, 0x3571be8c5e6c9da, 0x1f0cb811214fac0, 0x410014261011c, 0x1f6db815364ea8a, 0x13a50921d1486b6, 0x1fcef001554fee8, 0x64001249245a5c, 0x1b2db801145e396, 0x8610014670200a, 0x265407ac8a24b4c, 0x1a5cbfbdeb0f30c});\n+typedef FieldTri<uint64_t, 58, 19, StatTableTRI58, &SQR_TABLE_TRI58, &SQR2_TABLE_TRI58, &SQR4_TABLE_TRI58, &SQR8_TABLE_TRI58, &SQR16_TABLE_TRI58, &QRT_TABLE_TRI58, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri58;\n+\n+// 59 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable59;\n+constexpr StatTable59 SQR_TABLE_59({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x12a, 0x4a8, 0x12a0, 0x4a80, 0x12a00, 0x4a800, 0x12a000, 0x4a8000, 0x12a0000, 0x4a80000, 0x12a00000, 0x4a800000, 0x12a000000, 0x4a8000000, 0x12a0000000, 0x4a80000000, 0x12a00000000, 0x4a800000000, 0x12a000000000, 0x4a8000000000, 0x12a0000000000, 0x4a80000000000, 0x12a00000000000, 0x4a800000000000, 0x12a000000000000, 0x4a8000000000000, 0x2a000000000012a, 0x28000000000043d, 0x200000000001061});\n+constexpr StatTable59 SQR2_TABLE_59({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x12a, 0x12a0, 0x12a00, 0x12a000, 0x12a0000, 0x12a00000, 0x12a000000, 0x12a0000000, 0x12a00000000, 0x12a000000000, 0x12a0000000000, 0x12a00000000000, 0x12a000000000000, 0x2a000000000012a, 0x200000000001061, 0x10444, 0x104440, 0x1044400, 0x10444000, 0x104440000, 0x1044400000, 0x10444000000, 0x104440000000, 0x1044400000000, 0x10444000000000, 0x104440000000000, 0x4440000000012a, 0x4440000000012a0, 0x440000000012ea8, 0x40000000012ee28, 0x12ee628, 0x12ee6280, 0x12ee62800, 0x12ee628000, 0x12ee6280000, 0x12ee62800000, 0x12ee628000000, 0x12ee6280000000, 0x12ee62800000000, 0x2ee62800000012a, 0x6e6280000001061, 0x662800000010079, 0x62800000010016c, 0x28000000100103c});\n+constexpr StatTable59 SQR4_TABLE_59({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x12a0, 0x12a00000, 0x12a000000000, 0x2a000000000012a, 0x1044400, 0x10444000000, 0x104440000000000, 0x40000000012ee28, 0x12ee628000, 0x12ee6280000000, 0x662800000010079, 0x100101010, 0x1001010100000, 0x101010000012a0, 0x10000012a12b2a, 0x12a12b2b2a00, 0x2a12b2b2a00012a, 0x32b2a0001045461, 0x200010454541421, 0x104545414044000, 0x45414044012ef02, 0x4044012ef4d49aa, 0x12ef4d49e0ce28, 0x74d49e0ce290079, 0x1e0ce290000011d, 0x62900000100016d, 0x100010013a0, 0x100010013a00000, 0x10013a00012a000, 0x3a00012a012a12a, 0x12a012a116e400, 0x12a116e4010444, 0x116e40104450444, 0x40104450457ea6c, 0x4450457ea2692a0, 0x457ea2692ee7020, 0x22692ee706f7059, 0x2ee706f707e73ba, 0x6f707e73901116, 0x7e7390111013b6, 0x390111013b12b16, 0x11013b12b299b2a, 0x3b12b299b398b2a, 0x3299b398b17de61, 0x3398b17de543b4f, 0x317de543b7b1065, 0x6543b7b1053bb27, 0x37b1053bb4d0b6b, 0x53bb4d0b5b95ca, 0x34d0b5b95cfbf5b, 0x35b95cfbf6885b5, 0x5cfbf688587c89a, 0x7688587c8cf3adb, 0x587c8cf3aa00050, 0xcf3aa00001000d});\n+constexpr StatTable59 SQR8_TABLE_59({0x1, 0x1001010100000, 0x10013a00012a000, 0x3398b17de543b4f, 0x2a00116b8c2812a, 0x7cbf06ffa4d5cd6, 0x1288f1cf576c2e0, 0x3047cfc394d3391, 0x322d00452b2c451, 0x226dcb1999949d1, 0x2e2e5ab30351bc0, 0x10b2afcfca2edc6, 0x7ff39b98a3372a8, 0x2d7b439441ae332, 0x5603b26a2dae616, 0x3a13899c470338a, 0x16e8a14f0113f3c, 0x754f4aa46d3bb2, 0x38aa45436b16334, 0x634468d6b3f47b5, 0x248ca58bd03241d, 0x255d1fbddf51ae7, 0x7f4b46a330ef6bc, 0x3b3159b37b1a654, 0x7bbff798b50cf3e, 0x568afef7a72512a, 0x701d7955e599ab3, 0x3e7aed5ec2e2c82, 0x5c4d118847ff477, 0x21264d599c12421, 0x4d287fc89bb5a71, 0x6d1f30202fff956, 0x6c54d2de7c68bf8, 0x350c930ed65aed3, 0x5630ddede4ba32c, 0x7c18282af602d36, 0x198a362bf3c8a07, 0x40dde880541e01c, 0x49c0e7e7438c0c7, 0x3ade2abe6845a50, 0x6ffad83e7ac09c4, 0x52185a0d23e667a, 0x2e8c821b63a858a, 0x770e59a57577b23, 0x2fe0ea55e7032a6, 0x23cf0c9a1565a09, 0x1c53d32d80a4427, 0x23164f78db9fa8b, 0x691c4ffab038e2a, 0x33fc91a8a831d85, 0x48039e34eec4e05, 0x2581dbb898c10b5, 0x374067097dfc9f9, 0x241611fdbd3f8e7, 0x1b9f2934941d831, 0x1940c046b9b4a62, 0x5333ac5e7a608f6, 0xe9fa1f11b06830, 0x3d3bbe0ab819c34});\n+constexpr StatTable59 SQR16_TABLE_59({0x1, 0x857cdd2d43d447, 0xf829d2f68520b5, 0x19fe843a13f84fd, 0xcac85f3b30aa13, 0x5c7d9cd6997e169, 0x21e7ab9693a08f3, 0xe5cda6478df23f, 0xc3e206ed797b25, 0x755908ad7cca1c1, 0x16236a14b269480, 0x5fedfd73877a5e3, 0x6d66cb2c634cab2, 0x1b60fade310cb41, 0x5dcfd76c147e4ff, 0x2e686c220dcdc6a, 0x1d348a9dfc46113, 0x4e97ec4ce1b1081, 0x20ccc4ae0ada275, 0x5ec224932d09f73, 0x385cecd0572d2a0, 0x520f6a5162503d4, 0x3ff8003ba0976e, 0x5a314f7726ffcb7, 0x505c4f556b43e5a, 0x259ddd3f8c27783, 0x25441858e820409, 0x2714ab44ef6c58b, 0x53437cae5c3011c, 0x122c6454cb53ac0, 0x349b57934525af9, 0x394e01a9ab9a786, 0x665a91eb8e73f0d, 0x4c4e86cc5c98631, 0x7983a92ec037fe2, 0x67919ad3e0a3d69, 0x685c3d6c72af62e, 0x4eafca0e4b49fd7, 0x69534a8afbbeee, 0x720f8307d28c8cb, 0x49828239c03d1b7, 0x4c7e6edd9907a53, 0x1fe81ca4466f8fb, 0x19a865c194c7a23, 0x518bbfec9151454, 0x5b7bfbc756a7e4d, 0x146cc66da8b0754, 0x58e7cba08f0b29b, 0x1b578332a8f1985, 0x72d1c4f9eacac25, 0x6fc4f312025b99a, 0x199f6741974302b, 0x3edcb2e16193874, 0x38b45862414392c, 0x3a6669ab6604f52, 0x227da450a65496e, 0x4e85a5c57a7f719, 0x36b5dbf304b88be, 0x2ba8a1264ef68a0});\n+constexpr StatTable59 QRT_TABLE_59({0x38d905ab028567a, 0x789fa6ed3b44d72, 0x789fa6ed3b44d70, 0x74ec857e93d828c, 0x789fa6ed3b44d74, 0x116b3c1203c96, 0x74ec857e93d8284, 0xc25ebc3871e280, 0x789fa6ed3b44d64, 0x47a37c3d910b6, 0x116b3c1203cb6, 0xc7322d7a8f48de, 0x74ec857e93d82c4, 0xb509a0ea52e496, 0xc25ebc3871e200, 0x74fdee4681d3e0c, 0x789fa6ed3b44c64, 0x7ffbbd080b2f09a, 0x47a37c3d912b6, 0xd5c937bae506c8, 0x116b3c12038b6, 0xb173c76987625e, 0xc7322d7a8f40de, 0x7591ff36b3a682c, 0x74ec857e93d92c4, 0x72b253bfbfc90c4, 0xb509a0ea52c496, 0x79f2e7b10e6d452, 0xc25ebc3871a200, 0x78c86e951086aac, 0x74fdee4681dbe0c, 0x78c96eb514c602c, 0x789fa6ed3b54c64, 0xc34818b95658e8, 0x7ffbbd080b0f09a, 0x7399f563b1980f2, 0x47a37c3dd12b6, 0xa29e0e28c58880, 0xd5c937baed06c8, 0x788ac23520ac82c, 0x116b3c13038b6, 0xa2c857e83d92b6, 0xb173c769a7625e, 0x608da990122e48, 0xc7322d7acf40de, 0xa3a89269eebefe, 0x7591ff36bba682c, 0xa25ebc2871a200, 0x74ec857e83d92c4, 0x11f62e419f1cfe, 0x72b253bf9fc90c4, 0x7425ebc2871a272, 0xb509a0ee52c496, 0x4ed8555979c8de, 0x79f2e7b18e6d452, 0x6c3580d5915d4d2, 0xc25ebc2871a200, 0, 0x78c86e971086aac});\n+typedef Field<uint64_t, 59, 149, StatTable59, &SQR_TABLE_59, &SQR2_TABLE_59, &SQR4_TABLE_59, &SQR8_TABLE_59, &SQR16_TABLE_59, &QRT_TABLE_59, IdTrans, &ID_TRANS, &ID_TRANS> Field59;\n+\n+// 60 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTableTRI60;\n+constexpr StatTableTRI60 SQR_TABLE_TRI60({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000, 0xc00000000000, 0x3000000000000, 0xc000000000000, 0x30000000000000, 0xc0000000000000, 0x300000000000000, 0xc00000000000000});\n+constexpr StatTableTRI60 SQR2_TABLE_TRI60({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x3, 0x30, 0x300, 0x3000, 0x30000, 0x300000, 0x3000000, 0x30000000, 0x300000000, 0x3000000000, 0x30000000000, 0x300000000000, 0x3000000000000, 0x30000000000000, 0x300000000000000, 0x5, 0x50, 0x500, 0x5000, 0x50000, 0x500000, 0x5000000, 0x50000000, 0x500000000, 0x5000000000, 0x50000000000, 0x500000000000, 0x5000000000000, 0x50000000000000, 0x500000000000000, 0xf, 0xf0, 0xf00, 0xf000, 0xf0000, 0xf00000, 0xf000000, 0xf0000000, 0xf00000000, 0xf000000000, 0xf0000000000, 0xf00000000000, 0xf000000000000, 0xf0000000000000, 0xf00000000000000});\n+constexpr StatTableTRI60 SQR4_TABLE_TRI60({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x30, 0x300000, 0x3000000000, 0x30000000000000, 0x500, 0x5000000, 0x50000000000, 0x500000000000000, 0xf000, 0xf0000000, 0xf00000000000, 0x11, 0x110000, 0x1100000000, 0x11000000000000, 0x330, 0x3300000, 0x33000000000, 0x330000000000000, 0x5500, 0x55000000, 0x550000000000, 0x50000000000000f, 0xff000, 0xff0000000, 0xff00000000000, 0x101, 0x1010000, 0x10100000000, 0x101000000000000, 0x3030, 0x30300000, 0x303000000000, 0x30000000000005, 0x50500, 0x505000000, 0x5050000000000, 0x5000000000000f0, 0xf0f000, 0xf0f0000000, 0xf0f00000000000, 0x1111, 0x11110000, 0x111100000000, 0x111000000000003, 0x33330, 0x333300000, 0x3333000000000, 0x330000000000055, 0x555500, 0x5555000000, 0x55550000000000, 0x500000000000fff, 0xffff000, 0xffff0000000, 0xffff00000000000});\n+constexpr StatTableTRI60 SQR8_TABLE_TRI60({0x1, 0x110000, 0x10100000000, 0x111000000000003, 0x300030, 0x33003300000, 0x30303000000005, 0x330000000555555, 0x50000000500, 0x50000005500000f, 0x5050000f0f000, 0x5000ffff0000fff, 0xf000f000f011, 0xff00ff1010101, 0xf0e11111111111, 0x31, 0x3210000, 0x313100000000, 0x221000000000056, 0x5300530, 0x563056300000, 0x5353530000000f5, 0x63000000faaaaaa, 0xf5000000f500, 0x500000fa500010e, 0xf5f50011e1f000, 0x5010ffef0010ffe, 0x11f011f011f321, 0x10ef10ec1313131, 0x1e2d22222222222, 0x501, 0x55110000, 0x5040100000000, 0x411000000000ffc, 0xf030f030, 0xff33ff3300000, 0xc0c03000001114, 0x330000100555554, 0x11050000110500, 0x50001015500303f, 0x114050333c0f003, 0x5300fcff0300fcf, 0x330f330f330a511, 0x3fc03af4040404, 0x395b44444444444, 0xf531, 0xfa6210000, 0xf5c43100000000, 0x721000000010fa8, 0x11f521f530, 0x10ea73ea6300000, 0x4d4c530000322d7, 0x63000310faaaa9b, 0x321f5000321f500, 0x500313ea505343e, 0x2d4f55677d1f056, 0x310acef5310ace, 0x621a621a62e562e, 0x43bc4cb34c4c4c4, 0x878788888888888});\n+constexpr StatTableTRI60 SQR16_TABLE_TRI60({0x1, 0x563055110000, 0x111010233c0f003, 0x1200afffa8baffc, 0x5356030553000c5, 0x7145cf221744a77, 0x5748045489aaaaf, 0x7d52fcee4febdb3, 0x221f633c000a012, 0x41431fb55d4f4c8, 0x7f126132f4be5d5, 0x323da1f43c3a7e0, 0x373b24844474766, 0x6cc378a25584eb, 0x7ef66648aae4aca, 0x33003000031, 0xc0c03fb7c0f1fb, 0x174757777d10536, 0x2116210a52facb3, 0x5316fc100c1fb35, 0x7aae07597d161e1, 0x6752c4decfb6b7f, 0xf590fa78d56bf3, 0x1be67573275f157, 0xe3e0e9e0d61817, 0x25ac0012251ff6c, 0x407de1e40e3a849, 0x7a7264848fdf67e, 0x3bb8ba7d3879348, 0x498941f57060c6c, 0x5000000f0f501, 0x10fa8cfc1213ac0, 0x51a500f5501aab9, 0x73ef9049dcace64, 0x526a202f322f6e7, 0x2789a852500ca93, 0x4d1346684907509, 0x7d02bcfe4febdb2, 0x330a0329aba0521, 0x50a33c66415f5eb, 0x2e99dced402a73d, 0xf78f2f1a2dbcfe, 0x793a675db461a6a, 0x73848cd4c2f25d2, 0x54fa22d244aa9c6, 0xfae22e13e01501, 0x538ead296f222e5, 0x4da65592d2a750a, 0x40f91ebc14fcd2a, 0x5e73ff2f3c21c03, 0x4c72dce55551460, 0x3ffa59f8e5aef0a, 0x30057fa7b802f82, 0x36efe87d58aa6e4, 0x3bc96a196d71957, 0x5a82cfde2ad602f, 0x1f9bce94df9d3bf, 0x43c91d9b6bcabba, 0x2193c1833502ba3, 0xd28f516c1311d3d});\n+constexpr StatTableTRI60 QRT_TABLE_TRI60({0x6983c00fe00104a, 0x804570322e054e6, 0x804570322e054e4, 0x15673387e0a4e4, 0x804570322e054e0, 0x100010110, 0x15673387e0a4ec, 0x920d01f34442a70, 0x804570322e054f0, 0x7a8dc0f2e4058f0, 0x100010130, 0x120c01f140462f0, 0x15673387e0a4ac, 0x7bdbb2ca9a4fe5c, 0x920d01f34442af0, 0xe9c6b039ce0c4ac, 0x804570322e055f0, 0xfac8b080ca20c00, 0x7a8dc0f2e405af0, 0x7a8dc4b2e4a59f0, 0x100010530, 0x10000100000, 0x120c01f14046af0, 0x131a02d91c5db6c, 0x15673387e0b4ac, 0x15623387d0b4ac, 0x7bdbb2ca9a4de5c, 0x7ffbbbca0a8ee5c, 0x920d01f34446af0, 0x800000020000000, 0xe9c6b039ce044ac, 0x81130302500f000, 0x804570322e155f0, 0x935b72eb3a48e9c, 0xfac8b080ca00c00, 0x120c016140563c0, 0x7a8dc0f2e445af0, 0x7bcbb3ca8a4ee5c, 0x7a8dc4b2e4259f0, 0xc4000a0300, 0x100110530, 0x11623285c1b19c, 0x10000300000, 0x420890090c3000, 0x120c01f14446af0, 0x68d7b33b9e0b4ac, 0x131a02d9145db6c, 0xe8ccb1e18a56fc0, 0x15673386e0b4ac, 0x7aadc8f2e485af0, 0x15623385d0b4ac, 0x4a0990093c3000, 0x7bdbb2cada4de5c, 0xf9d6b3389e0b4ac, 0x7ffbbbca8a8ee5c, 0xdf6ba38cec84ac, 0x920d01f24446af0, 0x520d01f24446af0, 0x800000000000000, 0});\n+typedef FieldTri<uint64_t, 60, 1, StatTableTRI60, &SQR_TABLE_TRI60, &SQR2_TABLE_TRI60, &SQR4_TABLE_TRI60, &SQR8_TABLE_TRI60, &SQR16_TABLE_TRI60, &QRT_TABLE_TRI60, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri60;\n+\n+// 61 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable61;\n+constexpr StatTable61 SQR_TABLE_61({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x13800000, 0x4e000000, 0x138000000, 0x4e0000000, 0x1380000000, 0x4e00000000, 0x13800000000, 0x4e000000000, 0x138000000000, 0x4e0000000000, 0x1380000000000, 0x4e00000000000, 0x13800000000000, 0x4e000000000000, 0x138000000000000, 0x4e0000000000000, 0x1380000000000000, 0xe0000000000004e, 0x180000000000011f});\n+constexpr StatTable61 SQR2_TABLE_61({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x138, 0x1380, 0x13800, 0x138000, 0x1380000, 0x13800000, 0x138000000, 0x1380000000, 0x13800000000, 0x138000000000, 0x1380000000000, 0x13800000000000, 0x138000000000000, 0x1380000000000000, 0x180000000000011f, 0x1054, 0x10540, 0x105400, 0x1054000, 0x10540000, 0x105400000, 0x1054000000, 0x10540000000, 0x105400000000, 0x1054000000000, 0x10540000000000, 0x105400000000000, 0x1054000000000000, 0x540000000000138, 0x14000000000013ce, 0x13d96, 0x13d960, 0x13d9600, 0x13d96000, 0x13d960000, 0x13d9600000, 0x13d96000000, 0x13d960000000, 0x13d9600000000, 0x13d96000000000, 0x13d960000000000, 0x13d9600000000000, 0x1d9600000000011f, 0x196000000000101a, 0x1600000000010004});\n+constexpr StatTable61 SQR4_TABLE_61({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x138, 0x1380000, 0x13800000000, 0x138000000000000, 0x10540, 0x105400000, 0x1054000000000, 0x540000000000138, 0x13d9600, 0x13d96000000, 0x13d960000000000, 0x1600000000010004, 0x100111000, 0x1001110000000, 0x11100000000138, 0x10000000013812b8, 0x13812ab8000, 0x13812ab80000000, 0x12ab800000010540, 0x105514114, 0x1055141140000, 0x551411400000138, 0x1140000013d84f6, 0x13d84f72f60, 0x13d84f72f600000, 0x4f72f6000010004, 0xf6000010000010f, 0x1000001010100, 0x10101000138, 0x101010001380000, 0x100013800013938, 0x138000139393800, 0x1393938010540, 0x193938010540011f, 0x180105400104445f, 0x540010444454138, 0x1044445413d9600, 0x445413d96013cae, 0x13d96013caaab96, 0x16013caaab970004, 0x1caaab970011111f, 0xb9700111101100b, 0x11110110010028, 0x11011001002812b8, 0x1001002812aab938, 0x2812aab92b8138, 0x12aab92b81382ec0, 0x192b81382ed1400b, 0x1382ed140105514, 0xed1401055150567, 0x105515056890f6, 0x1515056890f613ce, 0x56890f613d84e58, 0x10f613d84e5db85c, 0x13d84e5db84f6010, 0xe5db84f6000000e, 0x184f600000010123});\n+constexpr StatTable61 SQR8_TABLE_61({0x1, 0x100111000, 0x10101000138, 0x1001002812aab938, 0x1000001390478, 0x113916c2d28792b8, 0x1904457c4545aa5f, 0x13aa7f0f280c5e20, 0x1047900101540, 0x13be84504128808e, 0x839d72c6e39c0f1, 0x16a18bbeafc6bac6, 0x7290382d6ea1584, 0x1d7d80a66b181691, 0x19d2aaa6110c5d47, 0x1b613d85f602c96f, 0x3812870738, 0x113dbce704cbbd40, 0xd92856e5392f94b, 0x84f76c3d7c304a3, 0x1a519225fe5ce8cf, 0x1704aca0c7190b8e, 0xb7fb1620ed7d025, 0x12831368539314f6, 0x748fb7c048744be, 0x78cc8029440fcba, 0x10eb05b6015eb730, 0xfd3c38351ebc6bd, 0x1665bcfabbfbe624, 0x136549cb4738e1ec, 0x6db6139d4b707f2, 0x1000057853aeac78, 0x104401500109340, 0x554c25992c8f3d8, 0x192dd4b6c0886747, 0x219c35ac73165fc, 0xdf27daa47ee296b, 0x73ab415a10863d2, 0x1f06884b4f2dc1dd, 0xb56c8c3efd7847f, 0x7a6a82768a4a3f2, 0x8773791c3b9f69f, 0x1e4d128bbd8fa105, 0x16977fb4d8984d86, 0xb9a5106882f60bf, 0xc5102ee91822469, 0xdab44dc3cdf7a0b, 0x18d48e2841f63e4, 0x165b8e4d03de40d4, 0x11a7aec6ef42385a, 0x17064ddd9b5041ea, 0xf89b61f74d1f401, 0x18583a8c57e6cb7f, 0x607279105fda3be, 0x905e9c0d58240c7, 0x1ed3c0319519fa7d, 0xa3227b6d1cc17a1, 0xf6cb7bb2aa84563, 0xdda77eb9b649e97, 0x15480a00ec829caf, 0x62cb6da6128c272});\n+constexpr StatTable61 SQR16_TABLE_61({0x1, 0x1c7cd18a3a216933, 0xd201ddad374eb4, 0xee4694049c47289, 0x40db9f51130a1e6, 0x134cab3c67ec43f4, 0x97823873a2fc00f, 0xc08b772e8161a43, 0x128159f3d3611eac, 0x1f002f36181d6c4, 0x9de899abbd8d18f, 0x1a6ecb093fbb558b, 0xa6a1251b5961643, 0x1b285c169fb6616d, 0x9c04f5fcf0a4ce5, 0xd050c0ab89025ad, 0xdab152bf63418d9, 0xad3e33af7686059, 0x1561180155ac0dc8, 0x1d9e862521ab7d29, 0xa21b06e1e7632b5, 0x29b84e35cfc95ac, 0x17a27c78dac90e2c, 0x1312fa5f7b1e4ea2, 0xfe66bf53de6a93d, 0x182041e17dde85e9, 0x1289eb06f1803a2e, 0x129449a509af818c, 0x1f308057c81ab449, 0x419981420870054, 0x19f853b859910eb1, 0x9b422c0e9d60871, 0x9e6aec92bfcfa99, 0x15a788f1748b8f44, 0x1fa9a9c171dd83a1, 0x14096af6c0840cc6, 0x1bbe256976515067, 0x14f853fd9e5c0002, 0xf6256b0235f7a8, 0x37e727448043cf6, 0xbb0f467dd137c3f, 0x2538d574ceec19e, 0x15ff26c652c82188, 0x1c22b1e2a9ed31f3, 0x1f56b4b705c21301, 0x1502df3e9aa51832, 0x89c3dec02a6a543, 0x15eac5a464a4f736, 0x1d5023636fc14fa7, 0x499c5d458f9699e, 0x355b147c1703428, 0x1864a11df3efee51, 0x9af0f612e9c1265, 0x9c613962a1c08d9, 0x1cee6fc68f73b3f7, 0x185720007e663719, 0x101dd90a4502bf06, 0x1569af254da87eb0, 0x1781376276013a90, 0x10d2bf3d5e191483, 0x6215713bdc7d250});\n+constexpr StatTable61 QRT_TABLE_61({0x171d34fcdac955d0, 0x12cfc8c049e1c96, 0x12cfc8c049e1c94, 0x71d34fcdac955c2, 0x12cfc8c049e1c90, 0x631c871de564852, 0x71d34fcdac955ca, 0x129fa6407f27300, 0x12cfc8c049e1c80, 0x7094f6fdd0a3b12, 0x631c871de564872, 0xdb28cee59c8256a, 0x71d34fcdac9558a, 0xc8a0be15a915472, 0x129fa6407f27380, 0x12dfcb4058e0b80, 0x12cfc8c049e1d80, 0x117d7f04ad0118, 0x7094f6fdd0a3912, 0x621b576dbe35b6a, 0x631c871de564c72, 0x13c808a013a1ee0, 0xdb28cee59c82d6a, 0x113d79842a0272, 0x71d34fcdac9458a, 0x719776b580b6a98, 0xc8a0be15a917472, 0x6633498d6db760a, 0x129fa6407f23380, 0xbd4ae9e8c3e7560, 0x12dfcb4058e8b80, 0x8000000a, 0x12cfc8c049f1d80, 0x634ce9add3b26ea, 0x117d7f04af0118, 0xda3f19c5d66258a, 0x7094f6fdd0e3912, 0xb87427e85e71560, 0x621b576dbeb5b6a, 0xc8b0b085b8c4e0a, 0x631c871de464c72, 0x1538fc8649458a, 0x13c808a011a1ee0, 0xcddbca6d1cfe360, 0xdb28cee59882d6a, 0xae80f550d1ffff2, 0x113d7984aa0272, 0xda7770f5f195912, 0x71d34fcdbc9458a, 0x137c8a049a1ee0, 0x719776b5a0b6a98, 0xded39a9d236ba78, 0xc8a0be15e917472, 0x6732488ca7ce0a, 0x6633498dedb760a, 0xc0406d0527cb80a, 0x129fa6417f23380, 0x3d4ae9eac3e756a, 0xbd4ae9eac3e7560, 0, 0x12dfcb4458e8b80});\n+typedef Field<uint64_t, 61, 39, StatTable61, &SQR_TABLE_61, &SQR2_TABLE_61, &SQR4_TABLE_61, &SQR8_TABLE_61, &SQR16_TABLE_61, &QRT_TABLE_61, IdTrans, &ID_TRANS, &ID_TRANS> Field61;\n+\n+// 62 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable62;\n+constexpr StatTable62 SQR_TABLE_62({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x20000001, 0x80000004, 0x200000010, 0x800000040, 0x2000000100, 0x8000000400, 0x20000001000, 0x80000004000, 0x200000010000, 0x800000040000, 0x2000000100000, 0x8000000400000, 0x20000001000000, 0x80000004000000, 0x200000010000000, 0x800000040000000, 0x2000000100000000, 0x440000002, 0x1100000008, 0x4400000020, 0x11000000080, 0x44000000200, 0x110000000800, 0x440000002000, 0x1100000008000, 0x4400000020000, 0x11000000080000, 0x44000000200000, 0x110000000800000, 0x440000002000000, 0x1100000008000000});\n+constexpr StatTable62 SQR2_TABLE_62({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x80000004, 0x800000040, 0x8000000400, 0x80000004000, 0x800000040000, 0x8000000400000, 0x80000004000000, 0x800000040000000, 0x440000002, 0x4400000020, 0x44000000200, 0x440000002000, 0x4400000020000, 0x44000000200000, 0x440000002000000, 0x400000000000001, 0x20000011, 0x200000110, 0x2000001100, 0x20000011000, 0x200000110000, 0x2000001100000, 0x20000011000000, 0x200000110000000, 0x2000001100000000, 0x11100000008, 0x111000000080, 0x1110000000800, 0x11100000008000, 0x111000000080000, 0x1110000000800000, 0x1100000088000004, 0x1000000800000044, 0x8080000444, 0x80800004440, 0x808000044400, 0x8080000444000, 0x80800004440000, 0x808000044400000, 0x80000404000002, 0x800004040000020, 0x40440000202, 0x404400002020, 0x4044000020200, 0x40440000202000, 0x404400002020000});\n+constexpr StatTable62 SQR4_TABLE_62({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x80000004, 0x800000040000, 0x440000002, 0x4400000020000, 0x20000011, 0x200000110000, 0x2000001100000000, 0x11100000008000, 0x1000000800000044, 0x8080000444000, 0x800004040000020, 0x40440000202000, 0x400000000000101, 0x20001011000, 0x200010110000000, 0x101110000000800, 0x1100008088000404, 0x80808004044400, 0x80044404000202, 0x444044002020200, 0x440002002001110, 0x20002011101100, 0x20110011000080, 0x1100111000800080, 0x1110080000804400, 0x800080844004440, 0x808400044402000, 0x404400002021, 0x44000000210001, 0x300010110, 0x3000101100000, 0x101118000000c, 0x1118000800c0004, 0x8084c0040446, 0x84c00444460002, 0x4440460020213, 0x404600022130011, 0x2000201120111011, 0x2011301110118000, 0x3011001900008044, 0x1918080044c044, 0x1808004840440064, 0x484c4000646020, 0xc40004040200121, 0x40460001213100, 0x600010111000101, 0x101120001011800, 0x1200018198000404, 0x181910004044800, 0x110004c488000606, 0x4c4808006064400, 0x80046404001312, 0x464044013120200, 0x440112002001190, 0x1120002011901100, 0x20190011004480, 0x1900111044800080, 0x1110480000806400});\n+constexpr StatTable62 SQR8_TABLE_62({0x1, 0x400000000000101, 0x44000000210001, 0x40460001213100, 0x404500002021, 0xe40014150200121, 0x80b400145512000, 0x1495c4000646820, 0x8000808c4004445, 0xd0800c8c8440561, 0x1045c80080ad6405, 0x1988b0805419944, 0x190110048480008e, 0x2891049dcc008662, 0x8ac190411026482, 0x241574511233a020, 0x1120002031901110, 0x3040203922110044, 0x1110792020b25580, 0x282a4830647355, 0x2c60001037102032, 0x26e4507065221080, 0x2036c57040579390, 0x3450409552c0cc02, 0x5c4000c66824017, 0x5508ce8e2845301, 0x4934eca8d59343, 0x1c28a918f7c9c0d1, 0xb080581194c8e4, 0x1018495dc440e46a, 0x1ac80985d8604226, 0xc7044545722023, 0x145120003031900, 0x4440003a0200005, 0x134447a19a002514, 0x510e645a31f1135, 0xae4834446175200, 0x264f451435730311, 0x7220c2004155891, 0x2153045891358c65, 0x154154800ca02904, 0x54dc0c88ce92565, 0xdc54bc04d28bc20, 0x8c54b0401283d8b, 0x29088e8109411f28, 0x12d0dc41982620a, 0xc0030c89a712640, 0x1dc8192422907592, 0x145554681022a075, 0x470792013225580, 0x346c6a7130667300, 0x39147d7004b077b2, 0x6c83e2d354461c6, 0xcf6d0046247a030, 0x3221c0f063a45c80, 0x303645fc20539787, 0x21004cf150409b10, 0x1dd380444d78042, 0x1c709df8b7145381, 0x185834a4e8d51327, 0x1420e118b389a4d1, 0xf0c41811b4e8c4});\n+constexpr StatTable62 SQR16_TABLE_62({0x1, 0x147095f0731417c5, 0x3189fad107702e11, 0x3d3937fd86a460ab, 0x3ff26c959b47c587, 0x1e2ecbec4bf22bd6, 0x168ebaeceaf71b82, 0x216d6c4471f75c10, 0x1f6d31ccabfaee58, 0x1652ef2066ec0c61, 0x3d62ef6847f808fc, 0x26a33c99ec1b43d4, 0x32f26e79367c91ed, 0x361dcdd0d1e73240, 0xe2d494d081269e2, 0x33d231b9098b6045, 0x3c4e93c22fb78a3, 0x2f655fa56e578df3, 0x3a2b9600532c2609, 0x864e125951bbdb7, 0x2e2fca705bb62c58, 0x28e0629106401eaa, 0x7ac20f0ed6cdc1f, 0x3bd50add28a35850, 0x1a6e5ea19a59ab5d, 0x2add6d1d8c0aaefb, 0x2c3cf9842e6956a3, 0x1906944685f2c7c, 0x925997c95ed1de2, 0xcb9eb5d43c6f2e9, 0x1795f2b48a0fa71d, 0x19de5de41acc2100, 0x2e30c3a8444ef165, 0x29433812a3c4b1cd, 0xcbfa65dcdae6d63, 0x2580f2100e56c068, 0x25ce14544acc08cb, 0x24fa7059a7c87e18, 0x2a01d608b5d57d70, 0x3cefa2f54bdabc51, 0x29225fd40de84dea, 0x2d2276d8df087f20, 0x1a077580d9c5e840, 0x33b71879319b7de1, 0x16017e84617bddf4, 0x2596d6b0bd1a954c, 0x10267caddadbf666, 0x22c43bd90eaa3e05, 0xcaf6704a39c29fc, 0x25a0b38132106551, 0x1a78d1fcfd98f2a2, 0x1924d0b08fe1cc34, 0x3ea0a05c4cb14ee5, 0xa9b505540022072, 0x1e65cd1d5556d710, 0x3682cccd684103f1, 0x20a58fb864d70967, 0x35bfeeacb88f9b9b, 0x3b72dce9c4b09b87, 0x839908c285aaa64, 0x2ed676dc722e9732, 0x3dd67b08dc071450});\n+constexpr StatTable62 QRT_TABLE_62({0x30268b6fba455d2c, 0x200000006, 0x200000004, 0x3d67cb6c1fe66c76, 0x200000000, 0x3fc4f1901abfa400, 0x3d67cb6c1fe66c7e, 0x35e79b6c0a66bcbe, 0x200000010, 0x1e9372bc57a9941e, 0x3fc4f1901abfa420, 0x21ec9d424957a5b0, 0x3d67cb6c1fe66c3e, 0x1cb35a6e52f5fb0e, 0x35e79b6c0a66bc3e, 0x215481024c13a730, 0x200000110, 0x1c324a6c52f75b08, 0x1e9372bc57a9961e, 0x3764a9d00f676820, 0x3fc4f1901abfa020, 0x355481020e132730, 0x21ec9d424957adb0, 0x3c43c32c0f34301e, 0x3d67cb6c1fe67c3e, 0x1496122c45259728, 0x1cb35a6e52f5db0e, 0x15e418405b72ec20, 0x35e79b6c0a66fc3e, 0x30268b6e3a445c38, 0x215481024c132730, 0x100010114, 0x200010110, 0, 0x1c324a6c52f55b08, 0x215581044d133776, 0x1e9372bc57ad961e, 0x2155810e4d133766, 0x3764a9d00f6f6820, 0x2157833c4d12323e, 0x3fc4f1901aafa020, 0x1c324a4252f55b58, 0x355481020e332730, 0x28332fc0509d41e, 0x21ec9d424917adb0, 0x215783be4d12332e, 0x3c43c32c0fb4301e, 0x2157822c4d06363e, 0x3d67cb6c1ee67c3e, 0x23f6b9d2484afb78, 0x1496122c47259728, 0x14b8184047648a80, 0x1cb35a6e56f5db0e, 0x3fe4f1901aefa820, 0x15e418405372ec20, 0x3d5fd72c1be276be, 0x35e79b6c1a66fc3e, 0x14b038d24774cf10, 0x30268b6e1a445c38, 0x1d17022e43a7172e, 0x215481020c132730, 0x2157022e4d07372e});\n+typedef Field<uint64_t, 62, 536870913, StatTable62, &SQR_TABLE_62, &SQR2_TABLE_62, &SQR4_TABLE_62, &SQR8_TABLE_62, &SQR16_TABLE_62, &QRT_TABLE_62, IdTrans, &ID_TRANS, &ID_TRANS> Field62;\n+typedef FieldTri<uint64_t, 62, 29, RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5>, &SQR_TABLE_62, &SQR2_TABLE_62, &SQR4_TABLE_62, &SQR8_TABLE_62, &SQR16_TABLE_62, &QRT_TABLE_62, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri62;\n+\n+// 63 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTableTRI63;\n+constexpr StatTableTRI63 SQR_TABLE_TRI63({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000, 0x18000, 0x60000, 0x180000, 0x600000, 0x1800000, 0x6000000, 0x18000000, 0x60000000, 0x180000000, 0x600000000, 0x1800000000, 0x6000000000, 0x18000000000, 0x60000000000, 0x180000000000, 0x600000000000, 0x1800000000000, 0x6000000000000, 0x18000000000000, 0x60000000000000, 0x180000000000000, 0x600000000000000, 0x1800000000000000, 0x6000000000000000});\n+constexpr StatTableTRI63 SQR2_TABLE_TRI63({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x6, 0x60, 0x600, 0x6000, 0x60000, 0x600000, 0x6000000, 0x60000000, 0x600000000, 0x6000000000, 0x60000000000, 0x600000000000, 0x6000000000000, 0x60000000000000, 0x600000000000000, 0x6000000000000000, 0x14, 0x140, 0x1400, 0x14000, 0x140000, 0x1400000, 0x14000000, 0x140000000, 0x1400000000, 0x14000000000, 0x140000000000, 0x1400000000000, 0x14000000000000, 0x140000000000000, 0x1400000000000000, 0x4000000000000006, 0x78, 0x780, 0x7800, 0x78000, 0x780000, 0x7800000, 0x78000000, 0x780000000, 0x7800000000, 0x78000000000, 0x780000000000, 0x7800000000000, 0x78000000000000, 0x780000000000000, 0x7800000000000000});\n+constexpr StatTableTRI63 SQR4_TABLE_TRI63({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x6, 0x60000, 0x600000000, 0x6000000000000, 0x14, 0x140000, 0x1400000000, 0x14000000000000, 0x78, 0x780000, 0x7800000000, 0x78000000000000, 0x110, 0x1100000, 0x11000000000, 0x110000000000000, 0x660, 0x6600000, 0x66000000000, 0x660000000000000, 0x1540, 0x15400000, 0x154000000000, 0x1540000000000000, 0x7f80, 0x7f800000, 0x7f8000000000, 0x7f80000000000000, 0x10100, 0x101000000, 0x1010000000000, 0x100000000000006, 0x60600, 0x606000000, 0x6060000000000, 0x600000000000014, 0x141400, 0x1414000000, 0x14140000000000, 0x1400000000000078, 0x787800, 0x7878000000, 0x78780000000000, 0x7800000000000110, 0x1111000, 0x11110000000, 0x111100000000000, 0x1000000000000666, 0x6666000, 0x66660000000, 0x666600000000000, 0x6000000000001554, 0x15554000, 0x155540000000, 0x1555400000000000, 0x4000000000007ffe, 0x7fff8000, 0x7fff80000000, 0x7fff800000000000});\n+constexpr StatTableTRI63 SQR8_TABLE_TRI63({0x1, 0x110, 0x10100, 0x1111000, 0x100010000, 0x11001100000, 0x1010101000000, 0x111111110000000, 0x100000006, 0x11000000660, 0x1010000060600, 0x111100006666000, 0x1000600060006, 0x110066006600660, 0x106060606060606, 0x1666666666666666, 0x12, 0x1320, 0x121200, 0x13332000, 0x1200120000, 0x132013200000, 0x12121212000000, 0x1333333320000000, 0x120000006c, 0x132000006ac0, 0x121200006c6c00, 0x133320006aaac000, 0x12006c006c006c, 0x13206ac06ac06ac0, 0x126c6c6c6c6c6c6c, 0x4aaaaaaaaaaaaaaa, 0x104, 0x11440, 0x1050400, 0x115544000, 0x10401040000, 0x1144114400000, 0x105050504000000, 0x1555555440000006, 0x10400000618, 0x1144000067980, 0x1050400061e1800, 0x155440067ff98006, 0x104061806180618, 0x1446798679867986, 0x21e1e1e1e1e1e1e, 0x3fffffffffffffec, 0x1248, 0x136c80, 0x125a4800, 0x137fec8000, 0x124812480000, 0x136c936c800000, 0x125a5a5a48000000, 0x7fffffec8000006a, 0x124800006db0, 0x136c80006b6b00, 0x125a48006dddb000, 0x7fec806b006b006a, 0x12486db06db06db0, 0x6ceb6b6b6b6b6b6a, 0x25dddddddddddddc});\n+constexpr StatTableTRI63 SQR16_TABLE_TRI63({0x1, 0x10006, 0x100000014, 0x1000600140078, 0x116, 0x1160674, 0x11600001538, 0x116067415387e90, 0x10114, 0x101120678, 0x1011400141510, 0x112066c15687e66, 0x1170338, 0x117054a0a90, 0x1170338152c3f60, 0x54a1fbc41888532, 0x100010110, 0x1000701160660, 0x1010400141546, 0x102060c153e7f92, 0x11601170760, 0x116076301121340, 0x1171258152c6df4, 0x142a78fc131d6a4a, 0x1011500050540, 0x113067b055e1f86, 0x1110440042477e, 0x102261da46f39362, 0x117022e054b0b80, 0x45c09af143a3f72, 0x106721d847ee9ae4, 0x408a833f0a833f0a, 0x100010106, 0x1000701000614, 0x101120014147e, 0x114067814067902, 0x11601171074, 0x116076316066138, 0x117054c152d40e4, 0x33e0a853e0b842a, 0x1011500131278, 0x113066d12126d16, 0x7077c017b681e, 0x76e12736f057056, 0x117022e12493290, 0x45c1ead5f26a912, 0x76518c96bc5efa4, 0xb97397297387286, 0x1700171666, 0x17006516147554, 0x17174a012d3f8a, 0x173872913964814e, 0x160216157534, 0x16026219014b3eb8, 0x16144d1d3902f39c, 0x3964974c65925d30, 0x17163b005d59f8, 0x164974c75837d462, 0x17062a404d28cfa, 0x65854b0a96152d3c, 0x16152c2a5943b390, 0x5854b1be6419dd1e, 0x6045c19c854b1fba});\n+constexpr StatTableTRI63 QRT_TABLE_TRI63({0, 0x100010114, 0x100010116, 0x1001701051372, 0x100010112, 0x1000040220, 0x100170105137a, 0x5107703453bba, 0x100010102, 0x101130117155a, 0x1000040200, 0x40000200800, 0x100170105133a, 0x103151a137276d8, 0x5107703453b3a, 0x134e65fc7c222be0, 0x100010002, 0x100030103115a, 0x101130117175a, 0x106052d103f4de2, 0x1000040600, 0x15122707691d3a, 0x40000200000, 0x4530770bc57b3a, 0x100170105033a, 0x103011a131256d8, 0x103151a137256d8, 0x176f29eb55c7a8da, 0x5107703457b3a, 0x130b158b7767d0da, 0x134e65fc7c22abe0, 0x7bcaf59d2f62d3e2, 0x100000002, 0x1001401041260, 0x100030101115a, 0x5107e03443ab8, 0x101130113175a, 0x1043701251b3a, 0x106052d10374de2, 0x134e657d7c232be2, 0x1000140600, 0x106073d103b4be2, 0x15122707491d3a, 0x4438600ac07800, 0x40000600000, 0x176a199c5682d3e0, 0x4530770b457b3a, 0x7bca759c2f62d3e0, 0x100170005033a, 0x6116d02572de2, 0x103011a111256d8, 0x1346656d7c372de2, 0x103151a177256d8, 0x643c600aa07800, 0x176f29eb5dc7a8da, 0x7b4b758b2f67d0da, 0x5107713457b3a, 0x104570776b457b3a, 0x130b158b5767d0da, 0x734e65fc3c22abe0, 0x134e65fc3c22abe0, 0x4000000000000000, 0x7bcaf59daf62d3e2});\n+typedef FieldTri<uint64_t, 63, 1, StatTableTRI63, &SQR_TABLE_TRI63, &SQR2_TABLE_TRI63, &SQR4_TABLE_TRI63, &SQR8_TABLE_TRI63, &SQR16_TABLE_TRI63, &QRT_TABLE_TRI63, IdTrans, &ID_TRANS, &ID_TRANS> FieldTri63;\n+\n+// 64 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable64;\n+constexpr StatTable64 SQR_TABLE_64({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x6c00000, 0x1b000000, 0x6c000000, 0x1b0000000, 0x6c0000000, 0x1b00000000, 0x6c00000000, 0x1b000000000, 0x6c000000000, 0x1b0000000000, 0x6c0000000000, 0x1b00000000000, 0x6c00000000000, 0x1b000000000000, 0x6c000000000000, 0x1b0000000000000, 0x6c0000000000000, 0x1b00000000000000, 0x6c00000000000000, 0xb00000000000001b, 0xc00000000000005a});\n+constexpr StatTable64 SQR2_TABLE_64({0x1, 0x10, 0x100, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x100000000, 0x1000000000, 0x10000000000, 0x100000000000, 0x1000000000000, 0x10000000000000, 0x100000000000000, 0x1000000000000000, 0x1b, 0x1b0, 0x1b00, 0x1b000, 0x1b0000, 0x1b00000, 0x1b000000, 0x1b0000000, 0x1b00000000, 0x1b000000000, 0x1b0000000000, 0x1b00000000000, 0x1b000000000000, 0x1b0000000000000, 0x1b00000000000000, 0xb00000000000001b, 0x145, 0x1450, 0x14500, 0x145000, 0x1450000, 0x14500000, 0x145000000, 0x1450000000, 0x14500000000, 0x145000000000, 0x1450000000000, 0x14500000000000, 0x145000000000000, 0x1450000000000000, 0x450000000000001b, 0x50000000000001dc, 0x1db7, 0x1db70, 0x1db700, 0x1db7000, 0x1db70000, 0x1db700000, 0x1db7000000, 0x1db70000000, 0x1db700000000, 0x1db7000000000, 0x1db70000000000, 0x1db700000000000, 0x1db7000000000000, 0xdb7000000000001b, 0xb70000000000011f, 0x7000000000001105});\n+constexpr StatTable64 SQR4_TABLE_64({0x1, 0x10000, 0x100000000, 0x1000000000000, 0x1b, 0x1b0000, 0x1b00000000, 0x1b000000000000, 0x145, 0x1450000, 0x14500000000, 0x145000000000000, 0x1db7, 0x1db70000, 0x1db700000000, 0x1db7000000000000, 0x11011, 0x110110000, 0x1101100000000, 0x101100000000001b, 0x1ab1ab, 0x1ab1ab0000, 0x1ab1ab00000000, 0xb1ab00000000015e, 0x1514515, 0x15145150000, 0x151451500000000, 0x4515000000001c6b, 0x1c6db6c7, 0x1c6db6c70000, 0x1c6db6c700000000, 0xb6c700000001010f, 0x101000101, 0x1010001010000, 0x10001010000001b, 0x1010000001b1b00, 0x1b1b001b1b, 0x1b1b001b1b0000, 0x1b001b1b00000145, 0x1b1b000001444500, 0x14445014445, 0x144450144450000, 0x4501444500001dac, 0x444500001daab71b, 0x1daab71daab7, 0x1daab71daab70000, 0xb71daab70001110e, 0xaab700011101101f, 0x1110110110111, 0x110110110111001b, 0x10110111001aab1b, 0x111001aab1ab1ab, 0x1aab1ab1ab1aab, 0xab1ab1ab1aab015e, 0xb1ab1aab0150145e, 0x1aab015014514515, 0x150145145145015, 0x1451451450151c70, 0x451450151c71db6b, 0x50151c71db6db6dc, 0x1c71db6db6db71c7, 0xdb6db6db71c6000b, 0xb6db71c60001000f, 0x71c6000100000005});\n+constexpr StatTable64 SQR8_TABLE_64({0x1, 0x11011, 0x101000101, 0x1110110110111, 0x100000001001a, 0x10110001100aa1a1, 0x100011a1b1a011a, 0x100baa100bb1aa0a, 0x1a00000144, 0x1ba1ba01505504, 0x1a001b5f4401441a, 0xa0eb1eea544fee41, 0x15e0144001a1ce8, 0xf5ee551fbc9d4f5d, 0x1b4543b0eee81b44, 0xb89a98b89a98b894, 0x10dbc, 0x11d76167c, 0x10cb1bd0cb1bc, 0x1c6b617617606a67, 0xdbc00010da6ad43, 0x167d1d6d105be392, 0xbd170ae2484f0af7, 0x162bc80d36e8d468, 0x1aad58014ae5f0, 0x63df9865e4bbbb5, 0x43fc5a4cbafe0d17, 0xe3d18fd6f8de2666, 0x49e2e5eab134a710, 0x1c78a1664f19bdd8, 0xf0829cea9886f08a, 0x4d8f634d8f625cdd, 0x100514550, 0x1104554401050, 0x15115140114154b, 0x10050551444aec57, 0x4551004b4277f24b, 0xef2afe861bdfb, 0x1d64ceb6c85ed2c9, 0x4975810172576524, 0x73cf4644451101e, 0x4fd1b234005fb6a7, 0x1bddd12e486f9a6f, 0xaa3c6f23ad5e9724, 0xa02b0a9206ef4923, 0x18a08533d5a4e65e, 0x1fc83ef027d0132b, 0x5e54f45f48c9a13c, 0x10deeff7bf8c0, 0x1d21c38d4f8874db, 0x10886029449884cd, 0xfe25b26c0190be86, 0xf5345525adfcb67e, 0xb606f05c0f274ae6, 0x49303a49c3147e89, 0xe3dec1f0cb3467b8, 0xf3dd197b59b91bb7, 0x6e062ec482dfc7e, 0xc24c087e94b8c9c, 0x42e75f2649a63926, 0x4646807e89775aa9, 0xca57e67631079503, 0xf738d302cd26e621, 0xda8702da9702da9d});\n+constexpr StatTable64 SQR16_TABLE_64({0x1, 0x15f0144001a114f, 0x1aad43011ba1e5, 0xe34916e80106e21d, 0x11cefef6be466, 0xab943b855d3d776b, 0x1c77b6cf4edf1bd0, 0x46923ddea5ce4e34, 0x5455145e48670f13, 0xfb7d34d8e2b804bb, 0xbbe0dfe164a4d5b4, 0x431d528b1f73a8a2, 0xc259794b79e2607, 0x5945c54c76a8d132, 0xf5cb8b3860386917, 0xb345180ffd7a5551, 0xbaf1bebe1ae4ad02, 0x45562dad588c6260, 0x55b2852b76a728c4, 0xb5908b73d457d739, 0xa5a058173d115951, 0x11e605f10dd49e16, 0xb122096fef2a82a8, 0xfb95933559736ac7, 0x42652cf9ded5daa5, 0xe9a56590d5ab5301, 0xb8cef5ec20abb26f, 0xb50edcd1421d92e0, 0x12ac73f1d2f67094, 0x1c5815d4c184bd2, 0xe227a4ef0cd1165c, 0xe8d4a3a319b07491, 0xb0ef530df44bb042, 0xfbcbf52ff08d7ea3, 0xa0eaea8c7f69bf70, 0xedc22185164a14b1, 0xbfb9f37fc5eb3abc, 0x3712083e323193a, 0xe7bdca1397a3c26c, 0xf2d44dcbd1d02306, 0xa8fcad00bc810b9c, 0x4f7014f9d2186ea, 0x1b4d4ccc40f8060f, 0xe9ecf1e0105dab78, 0xe34e682846de9f1d, 0xace6cd21bf5ef658, 0x10f0cfa8cf3326ff, 0x71a97b1c73b8a63, 0xe1398cba3a3345d1, 0xa439e4c62ecb0615, 0x4bcce9efcca8db40, 0x176e95394759914e, 0xb5c7335e43a80f7f, 0xeb5439d8e177d64d, 0xa6af064a2d733f41, 0x5efc52c7e2f99007, 0x4a6efe65d270460b, 0xfe0ff44f5baa9a6a, 0x104c70edd05ffd6f, 0xf07d029f554aa763, 0x1c3c3cc0aca30a16, 0x7a0a5f6c85237d50, 0x1b862fb6b961ed37, 0xdcd1bd32f8a7d3ba});\n+constexpr StatTable64 QRT_TABLE_64({0x19c9369f278adc02, 0x84b2b22ab2383ee4, 0x84b2b22ab2383ee6, 0x9d7b84b495b3e3f6, 0x84b2b22ab2383ee2, 0x37c470b49213f790, 0x9d7b84b495b3e3fe, 0x1000a0105137c, 0x84b2b22ab2383ef2, 0x368e964a8edce1fc, 0x37c470b49213f7b0, 0x19c9368e278fdf4c, 0x9d7b84b495b3e3be, 0x2e4da23cbc7d4570, 0x1000a010513fc, 0x84f35772bac24232, 0x84b2b22ab2383ff2, 0x37c570ba9314e4fc, 0x368e964a8edce3fc, 0xb377c390213cdb0e, 0x37c470b49213f3b0, 0x85ed5a3aa99c24f2, 0x19c9368e278fd74c, 0xaabff0000780000e, 0x9d7b84b495b3f3be, 0x84b6b3dab03038f2, 0x2e4da23cbc7d6570, 0x511ea03494ffc, 0x1000a010553fc, 0xae0c0220343c6c0e, 0x84f35772bac2c232, 0x800000008000000e, 0x84b2b22ab2393ff2, 0xb376c29c202bc97e, 0x37c570ba9316e4fc, 0x9c3062488879e6ce, 0x368e964a8ed8e3fc, 0x41e42c08e47e70, 0xb377c3902134db0e, 0x85b9b108a60f56ce, 0x37c470b49203f3b0, 0x19dd3b6e21f3cb4c, 0x85ed5a3aa9bc24f2, 0x198ddf682c428ac0, 0x19c9368e27cfd74c, 0x4b7c68431ca84b0, 0xaabff0000700000e, 0x8040655489ffefbe, 0x9d7b84b494b3f3be, 0x18c1354e32bfa74c, 0x84b6b3dab23038f2, 0xaaf613cc0f74627e, 0x2e4da23cb87d6570, 0x3248b3d6b3342a8c, 0x511ea0b494ffc, 0xb60813c00e70700e, 0x1000a110553fc, 0x1e0d022a05393ffc, 0xae0c0220143c6c0e, 0xe0c0220143c6c00, 0x84f35772fac2c232, 0xc041e55948fbfdce, 0x800000000000000e, 0});\n+typedef Field<uint64_t, 64, 27, StatTable64, &SQR_TABLE_64, &SQR2_TABLE_64, &SQR4_TABLE_64, &SQR8_TABLE_64, &SQR16_TABLE_64, &QRT_TABLE_64, IdTrans, &ID_TRANS, &ID_TRANS> Field64;\n+}\n+\n+Sketch* ConstructClMul8Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 57: return new SketchImpl<Field57>(implementation, 57);\n+    case 58: return new SketchImpl<Field58>(implementation, 58);\n+    case 59: return new SketchImpl<Field59>(implementation, 59);\n+    case 61: return new SketchImpl<Field61>(implementation, 61);\n+    case 62: return new SketchImpl<Field62>(implementation, 62);\n+    case 64: return new SketchImpl<Field64>(implementation, 63);\n+    }\n+    return nullptr;\n+}\n+\n+Sketch* ConstructClMulTri8Bytes(int bits, int implementation) {\n+    switch (bits) {\n+    case 57: return new SketchImpl<FieldTri57>(implementation, 57);\n+    case 58: return new SketchImpl<FieldTri58>(implementation, 58);\n+    case 60: return new SketchImpl<FieldTri60>(implementation, 60);\n+    case 62: return new SketchImpl<FieldTri62>(implementation, 62);\n+    case 63: return new SketchImpl<FieldTri63>(implementation, 63);\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "37598c361236c0d20891d755a70ab35d6b34482a",
        "filename": "src/minisketch/src/fields/clmul_common_impl.h",
        "status": "added",
        "additions": 157,
        "deletions": 0,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_common_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/clmul_common_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/clmul_common_impl.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,157 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FIELDS_CLMUL_COMMON_IMPL_H_\n+#define _MINISKETCH_FIELDS_CLMUL_COMMON_IMPL_H_ 1\n+\n+#include <stdint.h>\n+#include <x86intrin.h>\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+\n+namespace {\n+\n+template<typename I, int BITS, I MOD> I MulWithClMulReduce(I a, I b)\n+{\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+    const __m128i MOD128 = _mm_cvtsi64_si128(MOD);\n+    __m128i product = _mm_clmulepi64_si128(_mm_cvtsi64_si128((uint64_t)a), _mm_cvtsi64_si128((uint64_t)b), 0x00);\n+    if (BITS <= 32) {\n+        __m128i high1 = _mm_srli_epi64(product, BITS);\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00); \n+        __m128i high2 = _mm_srli_epi64(red1, BITS);\n+        __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+    } else if (BITS == 64) {\n+        __m128i red1 = _mm_clmulepi64_si128(product, MOD128, 0x01);\n+        __m128i red2 = _mm_clmulepi64_si128(red1, MOD128, 0x01);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2));\n+    } else if ((BITS % 8) == 0) {\n+        __m128i high1 = _mm_srli_si128(product, BITS / 8);\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+        __m128i high2 = _mm_srli_si128(red1, BITS / 8);\n+        __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+        return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+    } else {\n+        __m128i high1 = _mm_or_si128(_mm_srli_epi64(product, BITS), _mm_srli_si128(_mm_slli_epi64(product, 64 - BITS), 8));\n+        __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+        if ((uint64_t(MOD) >> (66 - BITS)) == 0) {\n+            __m128i high2 = _mm_srli_epi64(red1, BITS);\n+            __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        } else {\n+            __m128i high2 = _mm_or_si128(_mm_srli_epi64(red1, BITS), _mm_srli_si128(_mm_slli_epi64(red1, 64 - BITS), 8));\n+            __m128i red2 = _mm_clmulepi64_si128(high2, MOD128, 0x00);\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    }\n+}\n+\n+template<typename I, int BITS, int POS> I MulTrinomial(I a, I b)\n+{\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+    __m128i product = _mm_clmulepi64_si128(_mm_cvtsi64_si128((uint64_t)a), _mm_cvtsi64_si128((uint64_t)b), 0x00);\n+    if (BITS <= 32) {\n+        __m128i high1 = _mm_srli_epi64(product, BITS);\n+        __m128i red1 = _mm_xor_si128(high1, _mm_slli_epi64(high1, POS));\n+        if (POS == 1) {\n+            return _mm_cvtsi128_si64(_mm_xor_si128(product, red1)) & MASK;\n+        } else {\n+            __m128i high2 = _mm_srli_epi64(red1, BITS);\n+            __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    } else {\n+        __m128i high1 = _mm_or_si128(_mm_srli_epi64(product, BITS), _mm_srli_si128(_mm_slli_epi64(product, 64 - BITS), 8));\n+        if (BITS + POS <= 66) {\n+            __m128i red1 = _mm_xor_si128(high1, _mm_slli_epi64(high1, POS));\n+            if (POS == 1) {\n+                return _mm_cvtsi128_si64(_mm_xor_si128(product, red1)) & MASK;\n+            } else if (BITS + POS <= 66) {\n+                __m128i high2 = _mm_srli_epi64(red1, BITS);\n+                __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+                return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+            }\n+        } else {\n+            const __m128i MOD128 = _mm_cvtsi64_si128(1 + (((uint64_t)1) << POS));\n+            __m128i red1 = _mm_clmulepi64_si128(high1, MOD128, 0x00);\n+            __m128i high2 = _mm_or_si128(_mm_srli_epi64(red1, BITS), _mm_srli_si128(_mm_slli_epi64(red1, 64 - BITS), 8));\n+            __m128i red2 = _mm_xor_si128(high2, _mm_slli_epi64(high2, POS));\n+            return _mm_cvtsi128_si64(_mm_xor_si128(_mm_xor_si128(product, red1), red2)) & MASK;\n+        }\n+    }\n+}\n+\n+/** Implementation of fields that use the SSE clmul intrinsic for multiplication. */\n+template<typename I, int B, I MOD, I (*MUL)(I, I), typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE> struct GenField\n+{\n+    typedef BitsInt<I, B> O;\n+    typedef LFSR<O, MOD> L;\n+\n+    static inline constexpr I Sqr1(I a) { return SQR->template Map<O>(a); }\n+    static inline constexpr I Sqr2(I a) { return SQR2->template Map<O>(a); }\n+    static inline constexpr I Sqr4(I a) { return SQR4->template Map<O>(a); }\n+    static inline constexpr I Sqr8(I a) { return SQR8->template Map<O>(a); }\n+    static inline constexpr I Sqr16(I a) { return SQR16->template Map<O>(a); }\n+\n+public:\n+    typedef I Elem;\n+\n+    inline constexpr int Bits() const { return B; }\n+\n+    inline constexpr Elem Mul2(Elem val) const { return L::Call(val); }\n+\n+    inline Elem Mul(Elem a, Elem b) const { return MUL(a, b); }\n+\n+    class Multiplier\n+    {\n+        Elem m_val;\n+    public:\n+        inline constexpr explicit Multiplier(const GenField&, Elem a) : m_val(a) {}\n+        constexpr Elem operator()(Elem a) const { return MUL(m_val, a); }\n+    };\n+\n+    /** Compute the square of a. */\n+    inline constexpr Elem Sqr(Elem val) const { return SQR->template Map<O>(val); }\n+\n+    /** Compute x such that x^2 + x = a (undefined result if no solution exists). */\n+    inline constexpr Elem Qrt(Elem val) const { return QRT->template Map<O>(val); }\n+\n+    /** Compute the inverse of x1. */\n+    inline Elem Inv(Elem val) const { return InvLadder<I, O, B, MUL, Sqr1, Sqr2, Sqr4, Sqr8, Sqr16>(val); }\n+\n+    /** Generate a random field element. */\n+    Elem FromSeed(uint64_t seed) const {\n+        uint64_t k0 = 0x434c4d554c466c64ull; // \"CLMULFld\"\n+        uint64_t k1 = seed;\n+        uint64_t count = ((uint64_t)B) << 32;\n+        I ret;\n+        do {\n+            ret = O::Mask(I(SipHash(k0, k1, count++)));\n+        } while(ret == 0);\n+        return LOAD->template Map<O>(ret);\n+    }\n+\n+    Elem Deserialize(BitReader& in) const { return LOAD->template Map<O>(in.Read<B, I>()); }\n+\n+    void Serialize(BitWriter& out, Elem val) const { out.Write<B, I>(SAVE->template Map<O>(val)); }\n+\n+    constexpr Elem FromUint64(uint64_t x) const { return LOAD->template Map<O>(O::Mask(I(x))); }\n+    constexpr uint64_t ToUint64(Elem val) const { return uint64_t(SAVE->template Map<O>(val)); }\n+};\n+\n+template<typename I, int B, I MOD, typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE>\n+using Field = GenField<I, B, MOD, MulWithClMulReduce<I, B, MOD>, F, SQR, SQR2, SQR4, SQR8, SQR16, QRT, T, LOAD, SAVE>;\n+\n+template<typename I, int B, int POS, typename F, const F* SQR, const F* SQR2, const F* SQR4, const F* SQR8, const F* SQR16, const F* QRT, typename T, const T* LOAD, const T* SAVE>\n+using FieldTri = GenField<I, B, I(1) + (I(1) << POS), MulTrinomial<I, B, POS>, F, SQR, SQR2, SQR4, SQR8, SQR16, QRT, T, LOAD, SAVE>;\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "5da96ce5eb5870d3256aa4320c4294f3c7074b7d",
        "filename": "src/minisketch/src/fields/generic_1byte.cpp",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_1byte.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_1byte.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_1byte.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,83 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 2 bit field\n+typedef RecLinTrans<uint8_t, 2> StatTable2;\n+typedef RecLinTrans<uint8_t, 2> DynTable2;\n+constexpr StatTable2 SQR_TABLE_2({0x1, 0x3});\n+constexpr StatTable2 QRT_TABLE_2({0x2, 0});\n+typedef Field<uint8_t, 2, 3, StatTable2, DynTable2, &SQR_TABLE_2, &QRT_TABLE_2> Field2;\n+\n+// 3 bit field\n+typedef RecLinTrans<uint8_t, 3> StatTable3;\n+typedef RecLinTrans<uint8_t, 3> DynTable3;\n+constexpr StatTable3 SQR_TABLE_3({0x1, 0x4, 0x6});\n+constexpr StatTable3 QRT_TABLE_3({0, 0x4, 0x6});\n+typedef Field<uint8_t, 3, 3, StatTable3, DynTable3, &SQR_TABLE_3, &QRT_TABLE_3> Field3;\n+\n+// 4 bit field\n+typedef RecLinTrans<uint8_t, 4> StatTable4;\n+typedef RecLinTrans<uint8_t, 4> DynTable4;\n+constexpr StatTable4 SQR_TABLE_4({0x1, 0x4, 0x3, 0xc});\n+constexpr StatTable4 QRT_TABLE_4({0x6, 0xa, 0x8, 0});\n+typedef Field<uint8_t, 4, 3, StatTable4, DynTable4, &SQR_TABLE_4, &QRT_TABLE_4> Field4;\n+\n+// 5 bit field\n+typedef RecLinTrans<uint8_t, 5> StatTable5;\n+typedef RecLinTrans<uint8_t, 3, 2> DynTable5;\n+constexpr StatTable5 SQR_TABLE_5({0x1, 0x4, 0x10, 0xa, 0xd});\n+constexpr StatTable5 QRT_TABLE_5({0x14, 0x8, 0xa, 0, 0xe});\n+typedef Field<uint8_t, 5, 5, StatTable5, DynTable5, &SQR_TABLE_5, &QRT_TABLE_5> Field5;\n+\n+// 6 bit field\n+typedef RecLinTrans<uint8_t, 6> StatTable6;\n+typedef RecLinTrans<uint8_t, 3, 3> DynTable6;\n+constexpr StatTable6 SQR_TABLE_6({0x1, 0x4, 0x10, 0x3, 0xc, 0x30});\n+constexpr StatTable6 QRT_TABLE_6({0x3a, 0x26, 0x24, 0x14, 0x20, 0});\n+typedef Field<uint8_t, 6, 3, StatTable6, DynTable6, &SQR_TABLE_6, &QRT_TABLE_6> Field6;\n+\n+// 7 bit field\n+typedef RecLinTrans<uint8_t, 4, 3> StatTable7;\n+typedef RecLinTrans<uint8_t, 4, 3> DynTable7;\n+constexpr StatTable7 SQR_TABLE_7({0x1, 0x4, 0x10, 0x40, 0x6, 0x18, 0x60});\n+constexpr StatTable7 QRT_TABLE_7({0, 0x14, 0x16, 0x72, 0x12, 0x40, 0x7a});\n+typedef Field<uint8_t, 7, 3, StatTable7, DynTable7, &SQR_TABLE_7, &QRT_TABLE_7> Field7;\n+\n+// 8 bit field\n+typedef RecLinTrans<uint8_t, 4, 4> StatTable8;\n+typedef RecLinTrans<uint8_t, 4, 4> DynTable8;\n+constexpr StatTable8 SQR_TABLE_8({0x1, 0x4, 0x10, 0x40, 0x1b, 0x6c, 0xab, 0x9a});\n+constexpr StatTable8 QRT_TABLE_8({0xbc, 0x2a, 0x28, 0x86, 0x2c, 0xde, 0x8e, 0});\n+typedef Field<uint8_t, 8, 27, StatTable8, DynTable8, &SQR_TABLE_8, &QRT_TABLE_8> Field8;\n+\n+}\n+\n+Sketch* ConstructGeneric1Byte(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 2: return new SketchImpl<Field2>(implementation, 2);\n+    case 3: return new SketchImpl<Field3>(implementation, 3);\n+    case 4: return new SketchImpl<Field4>(implementation, 4);\n+    case 5: return new SketchImpl<Field5>(implementation, 5);\n+    case 6: return new SketchImpl<Field6>(implementation, 6);\n+    case 7: return new SketchImpl<Field7>(implementation, 7);\n+    case 8: return new SketchImpl<Field8>(implementation, 8);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "6641f0c298e37ccb95b0e839a94e30394a4fbdcd",
        "filename": "src/minisketch/src/fields/generic_2bytes.cpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_2bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_2bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_2bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,91 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 9 bit field\n+typedef RecLinTrans<uint16_t, 5, 4> StatTable9;\n+typedef RecLinTrans<uint16_t, 3, 3, 3> DynTable9;\n+constexpr StatTable9 SQR_TABLE_9({0x1, 0x4, 0x10, 0x40, 0x100, 0x6, 0x18, 0x60, 0x180});\n+constexpr StatTable9 QRT_TABLE_9({0, 0x4e, 0x4c, 0x1aa, 0x48, 0x22, 0x1a2, 0x100, 0x58});\n+typedef Field<uint16_t, 9, 3, StatTable9, DynTable9, &SQR_TABLE_9, &QRT_TABLE_9> Field9;\n+\n+// 10 bit field\n+typedef RecLinTrans<uint16_t, 5, 5> StatTable10;\n+typedef RecLinTrans<uint16_t, 4, 3, 3> DynTable10;\n+constexpr StatTable10 SQR_TABLE_10({0x1, 0x4, 0x10, 0x40, 0x100, 0x9, 0x24, 0x90, 0x240, 0x112});\n+constexpr StatTable10 QRT_TABLE_10({0xec, 0x86, 0x84, 0x30e, 0x80, 0x3c2, 0x306, 0, 0x90, 0x296});\n+typedef Field<uint16_t, 10, 9, StatTable10, DynTable10, &SQR_TABLE_10, &QRT_TABLE_10> Field10;\n+\n+// 11 bit field\n+typedef RecLinTrans<uint16_t, 6, 5> StatTable11;\n+typedef RecLinTrans<uint16_t, 4, 4, 3> DynTable11;\n+constexpr StatTable11 SQR_TABLE_11({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0xa, 0x28, 0xa0, 0x280, 0x205});\n+constexpr StatTable11 QRT_TABLE_11({0x734, 0x48, 0x4a, 0x1de, 0x4e, 0x35e, 0x1d6, 0x200, 0x5e, 0, 0x37e});\n+typedef Field<uint16_t, 11, 5, StatTable11, DynTable11, &SQR_TABLE_11, &QRT_TABLE_11> Field11;\n+\n+// 12 bit field\n+typedef RecLinTrans<uint16_t, 6, 6> StatTable12;\n+typedef RecLinTrans<uint16_t, 4, 4, 4> DynTable12;\n+constexpr StatTable12 SQR_TABLE_12({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x9, 0x24, 0x90, 0x240, 0x900, 0x412});\n+constexpr StatTable12 QRT_TABLE_12({0x48, 0xc10, 0xc12, 0x208, 0xc16, 0xd82, 0x200, 0x110, 0xc06, 0, 0xda2, 0x5a4});\n+typedef Field<uint16_t, 12, 9, StatTable12, DynTable12, &SQR_TABLE_12, &QRT_TABLE_12> Field12;\n+\n+// 13 bit field\n+typedef RecLinTrans<uint16_t, 5, 4, 4> StatTable13;\n+typedef RecLinTrans<uint16_t, 4, 3, 3, 3> DynTable13;\n+constexpr StatTable13 SQR_TABLE_13({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x36, 0xd8, 0x360, 0xd80, 0x161b, 0x185a});\n+constexpr StatTable13 QRT_TABLE_13({0xcfc, 0x1500, 0x1502, 0x382, 0x1506, 0x149c, 0x38a, 0x118, 0x1516, 0, 0x14bc, 0x100e, 0x3ca});\n+typedef Field<uint16_t, 13, 27, StatTable13, DynTable13, &SQR_TABLE_13, &QRT_TABLE_13> Field13;\n+\n+// 14 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 4> StatTable14;\n+typedef RecLinTrans<uint16_t, 4, 4, 3, 3> DynTable14;\n+constexpr StatTable14 SQR_TABLE_14({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x442, 0x1108});\n+constexpr StatTable14 QRT_TABLE_14({0x13f2, 0x206, 0x204, 0x3e06, 0x200, 0x1266, 0x3e0e, 0x114, 0x210, 0, 0x1246, 0x2848, 0x3e4e, 0x2258});\n+typedef Field<uint16_t, 14, 33, StatTable14, DynTable14, &SQR_TABLE_14, &QRT_TABLE_14> Field14;\n+\n+// 15 bit field\n+typedef RecLinTrans<uint16_t, 5, 5, 5> StatTable15;\n+typedef RecLinTrans<uint16_t, 4, 4, 4, 3> DynTable15;\n+constexpr StatTable15 SQR_TABLE_15({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000});\n+constexpr StatTable15 QRT_TABLE_15({0, 0x114, 0x116, 0x428, 0x112, 0x137a, 0x420, 0x6d62, 0x102, 0x73a, 0x135a, 0x6460, 0x460, 0x4000, 0x6de2});\n+typedef Field<uint16_t, 15, 3, StatTable15, DynTable15, &SQR_TABLE_15, &QRT_TABLE_15> Field15;\n+\n+// 16 bit field\n+typedef RecLinTrans<uint16_t, 6, 5, 5> StatTable16;\n+typedef RecLinTrans<uint16_t, 4, 4, 4, 4> DynTable16;\n+constexpr StatTable16 SQR_TABLE_16({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x2b, 0xac, 0x2b0, 0xac0, 0x2b00, 0xac00, 0xb056, 0xc10e});\n+constexpr StatTable16 QRT_TABLE_16({0x732, 0x72b8, 0x72ba, 0x7e96, 0x72be, 0x78b2, 0x7e9e, 0x8cba, 0x72ae, 0xfa24, 0x7892, 0x5892, 0x7ede, 0xbec6, 0x8c3a, 0});\n+typedef Field<uint16_t, 16, 43, StatTable16, DynTable16, &SQR_TABLE_16, &QRT_TABLE_16> Field16;\n+\n+}\n+\n+Sketch* ConstructGeneric2Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 9: return new SketchImpl<Field9>(implementation, 9);\n+    case 10: return new SketchImpl<Field10>(implementation, 10);\n+    case 11: return new SketchImpl<Field11>(implementation, 11);\n+    case 12: return new SketchImpl<Field12>(implementation, 12);\n+    case 13: return new SketchImpl<Field13>(implementation, 13);\n+    case 14: return new SketchImpl<Field14>(implementation, 14);\n+    case 15: return new SketchImpl<Field15>(implementation, 15);\n+    case 16: return new SketchImpl<Field16>(implementation, 16);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "a86f37cbf5033ef514fc28fe554f453ee8ade2d2",
        "filename": "src/minisketch/src/fields/generic_3bytes.cpp",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_3bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_3bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_3bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,91 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 17 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5> StatTable17;\n+typedef RecLinTrans<uint32_t, 4, 4, 3, 3, 3> DynTable17;\n+constexpr StatTable17 SQR_TABLE_17({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x8012});\n+constexpr StatTable17 QRT_TABLE_17({0, 0x4c3e, 0x4c3c, 0x1a248, 0x4c38, 0x428, 0x1a240, 0x1b608, 0x4c28, 0x206, 0x408, 0x4000, 0x1a200, 0x18006, 0x1b688, 0x14d2e, 0x4d28});\n+typedef Field<uint32_t, 17, 9, StatTable17, DynTable17, &SQR_TABLE_17, &QRT_TABLE_17> Field17;\n+\n+// 18 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6> StatTable18;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 3, 3> DynTable18;\n+constexpr StatTable18 SQR_TABLE_18({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x10012});\n+constexpr StatTable18 QRT_TABLE_18({0x9208, 0x422, 0x420, 0x8048, 0x424, 0x68b0, 0x8040, 0x30086, 0x434, 0x1040, 0x6890, 0x30ca2, 0x8000, 0x32896, 0x30006, 0, 0x534, 0x20532});\n+typedef Field<uint32_t, 18, 9, StatTable18, DynTable18, &SQR_TABLE_18, &QRT_TABLE_18> Field18;\n+\n+// 19 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 4> StatTable19;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3> DynTable19;\n+constexpr StatTable19 SQR_TABLE_19({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x3804e, 0x6011f});\n+constexpr StatTable19 QRT_TABLE_19({0x5d6b0, 0x2f476, 0x2f474, 0x1d6a2, 0x2f470, 0x42a, 0x1d6aa, 0x1060, 0x2f460, 0x19e92, 0x40a, 0x1da98, 0x1d6ea, 0x28c78, 0x10e0, 0xf56a, 0x2f560, 0, 0x19c92});\n+typedef Field<uint32_t, 19, 39, StatTable19, DynTable19, &SQR_TABLE_19, &QRT_TABLE_19> Field19;\n+\n+// 20 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5> StatTable20;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4> DynTable20;\n+constexpr StatTable20 SQR_TABLE_20({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x40012});\n+constexpr StatTable20 QRT_TABLE_20({0xc5dea, 0xc0110, 0xc0112, 0xe11de, 0xc0116, 0x24814, 0xe11d6, 0x20080, 0xc0106, 0xfe872, 0x24834, 0xe4106, 0xe1196, 0x1d9a4, 0x20000, 0x31190, 0xc0006, 0, 0xfea72, 0x7ea74});\n+typedef Field<uint32_t, 20, 9, StatTable20, DynTable20, &SQR_TABLE_20, &QRT_TABLE_20> Field20;\n+\n+// 21 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5> StatTable21;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 3, 3, 3> DynTable21;\n+constexpr StatTable21 SQR_TABLE_21({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x80005});\n+constexpr StatTable21 QRT_TABLE_21({0x1bd5fc, 0xbc196, 0xbc194, 0x74b96, 0xbc190, 0x1048, 0x74b9e, 0x672c8, 0xbc180, 0x4080, 0x1068, 0xc8200, 0x74bde, 0x64280, 0x67248, 0xc4280, 0xbc080, 0x80000, 0x4280, 0, 0x1468});\n+typedef Field<uint32_t, 21, 5, StatTable21, DynTable21, &SQR_TABLE_21, &QRT_TABLE_21> Field21;\n+\n+// 22 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5> StatTable22;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3, 3> DynTable22;\n+constexpr StatTable22 SQR_TABLE_22({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000});\n+constexpr StatTable22 QRT_TABLE_22({0x210d16, 0x104a, 0x1048, 0x4088, 0x104c, 0x200420, 0x4080, 0x492dc, 0x105c, 0x1a67f0, 0x200400, 0x21155c, 0x40c0, 0x20346c, 0x4925c, 0x1af7ac, 0x115c, 0x2274ac, 0x1a65f0, 0x2a65f0, 0x200000, 0});\n+typedef Field<uint32_t, 22, 3, StatTable22, DynTable22, &SQR_TABLE_22, &QRT_TABLE_22> Field22;\n+\n+// 23 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5> StatTable23;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3> DynTable23;\n+constexpr StatTable23 SQR_TABLE_23({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x80042, 0x200108});\n+constexpr StatTable23 QRT_TABLE_23({0, 0x1040, 0x1042, 0x43056, 0x1046, 0x121d76, 0x4305e, 0x40a0, 0x1056, 0x15176, 0x121d56, 0x7ee1f6, 0x4301e, 0x40000, 0x4020, 0x4f0be, 0x1156, 0x7cf0a0, 0x15376, 0x1ee9e8, 0x121956, 0x3ac9f6, 0x7ee9f6});\n+typedef Field<uint32_t, 23, 33, StatTable23, DynTable23, &SQR_TABLE_23, &QRT_TABLE_23> Field23;\n+\n+// 24 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6> StatTable24;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4> DynTable24;\n+constexpr StatTable24 SQR_TABLE_24({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0xb0001b, 0xc0005a});\n+constexpr StatTable24 QRT_TABLE_24({0x104e, 0xaf42a8, 0xaf42aa, 0xb78186, 0xaf42ae, 0x4090, 0xb7818e, 0x4a37c, 0xaf42be, 0x3688c0, 0x40b0, 0x80080e, 0xb781ce, 0xaf2232, 0x4a3fc, 0x856a82, 0xaf43be, 0x29c970, 0x368ac0, 0x968ace, 0x44b0, 0x77d570, 0x80000e, 0});\n+typedef Field<uint32_t, 24, 27, StatTable24, DynTable24, &SQR_TABLE_24, &QRT_TABLE_24> Field24;\n+\n+}\n+\n+Sketch* ConstructGeneric3Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 17: return new SketchImpl<Field17>(implementation, 17);\n+    case 18: return new SketchImpl<Field18>(implementation, 18);\n+    case 19: return new SketchImpl<Field19>(implementation, 19);\n+    case 20: return new SketchImpl<Field20>(implementation, 20);\n+    case 21: return new SketchImpl<Field21>(implementation, 21);\n+    case 22: return new SketchImpl<Field22>(implementation, 22);\n+    case 23: return new SketchImpl<Field23>(implementation, 23);\n+    case 24: return new SketchImpl<Field24>(implementation, 24);\n+    default: return nullptr;\n+    }\n+}\n+"
      },
      {
        "sha": "9383472bac49fbbd8784a6ac4b5be510f1ed5f9b",
        "filename": "src/minisketch/src/fields/generic_4bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_4bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_4bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_4bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 25 bit field\n+typedef RecLinTrans<uint32_t, 5, 5, 5, 5, 5> StatTable25;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 3, 3, 3> DynTable25;\n+constexpr StatTable25 SQR_TABLE_25({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x800012});\n+constexpr StatTable25 QRT_TABLE_25({0, 0x482110, 0x482112, 0x1b3c3e6, 0x482116, 0x4960ae, 0x1b3c3ee, 0x4088, 0x482106, 0x58a726, 0x49608e, 0x5ce52e, 0x1b3c3ae, 0x2006, 0x4008, 0x1c1a8, 0x482006, 0x1e96488, 0x58a526, 0x400000, 0x49648e, 0x1800006, 0x5ced2e, 0xb3d3a8, 0x1b3d3ae});\n+typedef Field<uint32_t, 25, 9, StatTable25, DynTable25, &SQR_TABLE_25, &QRT_TABLE_25> Field25;\n+\n+// 26 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5> StatTable26;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3, 3> DynTable26;\n+constexpr StatTable26 SQR_TABLE_26({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x2c0001b, 0x300005a});\n+constexpr StatTable26 QRT_TABLE_26({0x217b530, 0x2ae82a8, 0x2ae82aa, 0x2001046, 0x2ae82ae, 0x2de032e, 0x200104e, 0x70c10c, 0x2ae82be, 0x20151f2, 0x2de030e, 0xbc1400, 0x200100e, 0x178570, 0x70c18c, 0x2ae4232, 0x2ae83be, 0x211d742, 0x20153f2, 0x21f54f2, 0x2de070e, 0x5e0700, 0xbc1c00, 0x3abb97e, 0x200000e, 0});\n+typedef Field<uint32_t, 26, 27, StatTable26, DynTable26, &SQR_TABLE_26, &QRT_TABLE_26> Field26;\n+\n+// 27 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5> StatTable27;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 3> DynTable27;\n+constexpr StatTable27 SQR_TABLE_27({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x380004e, 0x600011f});\n+constexpr StatTable27 QRT_TABLE_27({0x6bf0530, 0x2be4496, 0x2be4494, 0x2bf0522, 0x2be4490, 0x1896cca, 0x2bf052a, 0x408a, 0x2be4480, 0x368ae72, 0x1896cea, 0x18d2ee0, 0x2bf056a, 0x1c76d6a, 0x400a, 0x336e9f8, 0x2be4580, 0x36baf12, 0x368ac72, 0x430360, 0x18968ea, 0x34a6b80, 0x18d26e0, 0xbf1560, 0x2bf156a, 0, 0x1c74d6a});\n+typedef Field<uint32_t, 27, 39, StatTable27, DynTable27, &SQR_TABLE_27, &QRT_TABLE_27> Field27;\n+\n+// 28 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 5, 5> StatTable28;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4> DynTable28;\n+constexpr StatTable28 SQR_TABLE_28({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000});\n+constexpr StatTable28 QRT_TABLE_28({0x121d57a, 0x40216, 0x40214, 0x8112578, 0x40210, 0x10110, 0x8112570, 0x12597ec, 0x40200, 0x6983e00, 0x10130, 0x972b99c, 0x8112530, 0x8002000, 0x125976c, 0x815a76c, 0x40300, 0x936b29c, 0x6983c00, 0x97bb8ac, 0x10530, 0x9103000, 0x972b19c, 0xf6384ac, 0x8113530, 0x4113530, 0x8000000, 0});\n+typedef Field<uint32_t, 28, 3, StatTable28, DynTable28, &SQR_TABLE_28, &QRT_TABLE_28> Field28;\n+\n+// 29 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 5> StatTable29;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 3, 3, 3> DynTable29;\n+constexpr StatTable29 SQR_TABLE_29({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x8000005});\n+constexpr StatTable29 QRT_TABLE_29({0x1b8351dc, 0xb87135e, 0xb87135c, 0xda7b35e, 0xb871358, 0x621a116, 0xda7b356, 0x40200, 0xb871348, 0xc9e2620, 0x621a136, 0x478b16, 0xda7b316, 0x6762e20, 0x40280, 0x6202000, 0xb871248, 0x627a316, 0xc9e2420, 0xcd1ad36, 0x621a536, 0x760e20, 0x478316, 0xa760e20, 0xda7a316, 0x8000000, 0x6760e20, 0, 0x44280});\n+typedef Field<uint32_t, 29, 5, StatTable29, DynTable29, &SQR_TABLE_29, &QRT_TABLE_29> Field29;\n+\n+// 30 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 6, 6, 6> StatTable30;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 3, 3> DynTable30;\n+constexpr StatTable30 SQR_TABLE_30({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000});\n+constexpr StatTable30 QRT_TABLE_30({0x2159df4a, 0x109134a, 0x1091348, 0x10114, 0x109134c, 0x3a203420, 0x1011c, 0x20004080, 0x109135c, 0x2005439c, 0x3a203400, 0x100400, 0x1015c, 0x3eb21930, 0x20004000, 0x20504c00, 0x109125c, 0x3b2b276c, 0x2005419c, 0x210450c0, 0x3a203000, 0x3e93186c, 0x100c00, 0x3aa23530, 0x1115c, 0x6b3286c, 0x3eb23930, 0xeb23930, 0x20000000, 0});\n+typedef Field<uint32_t, 30, 3, StatTable30, DynTable30, &SQR_TABLE_30, &QRT_TABLE_30> Field30;\n+\n+// 31 bit field\n+typedef RecLinTrans<uint32_t, 6, 5, 5, 5, 5, 5> StatTable31;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4, 3> DynTable31;\n+constexpr StatTable31 SQR_TABLE_31({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x20000012});\n+constexpr StatTable31 QRT_TABLE_31({0, 0x10110, 0x10112, 0x15076e, 0x10116, 0x117130e, 0x150766, 0x4743fa0, 0x10106, 0x1121008, 0x117132e, 0x176b248e, 0x150726, 0x172a2c88, 0x4743f20, 0x7eb81e86, 0x10006, 0x20008, 0x1121208, 0x56b2c8e, 0x117172e, 0x133f1bae, 0x176b2c8e, 0x7f2a0c8e, 0x151726, 0x10000000, 0x172a0c88, 0x60000006, 0x4747f20, 0x3eb89e80, 0x7eb89e86});\n+typedef Field<uint32_t, 31, 9, StatTable31, DynTable31, &SQR_TABLE_31, &QRT_TABLE_31> Field31;\n+\n+// 32 bit field\n+typedef RecLinTrans<uint32_t, 6, 6, 5, 5, 5, 5> StatTable32;\n+typedef RecLinTrans<uint32_t, 4, 4, 4, 4, 4, 4, 4, 4> DynTable32;\n+constexpr StatTable32 SQR_TABLE_32({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x8d, 0x234, 0x8d0, 0x2340, 0x8d00, 0x23400, 0x8d000, 0x234000, 0x8d0000, 0x2340000, 0x8d00000, 0x23400000, 0x8d000000, 0x3400011a, 0xd0000468, 0x40001037});\n+constexpr StatTable32 QRT_TABLE_32({0x54fd1264, 0xc26fcd64, 0xc26fcd66, 0x238a7462, 0xc26fcd62, 0x973bccaa, 0x238a746a, 0x77766712, 0xc26fcd72, 0xc1bdd556, 0x973bcc8a, 0x572a094c, 0x238a742a, 0xb693be84, 0x77766792, 0x9555c03e, 0xc26fcc72, 0x568419f8, 0xc1bdd756, 0x96c3d2ca, 0x973bc88a, 0x54861fdc, 0x572a014c, 0xb79badc4, 0x238a642a, 0xb9b99fe0, 0xb6939e84, 0xc519fa86, 0x77762792, 0, 0x9555403e, 0x377627ba});\n+typedef Field<uint32_t, 32, 141, StatTable32, DynTable32, &SQR_TABLE_32, &QRT_TABLE_32> Field32;\n+\n+}\n+\n+Sketch* ConstructGeneric4Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 25: return new SketchImpl<Field25>(implementation, 25);\n+    case 26: return new SketchImpl<Field26>(implementation, 26);\n+    case 27: return new SketchImpl<Field27>(implementation, 27);\n+    case 28: return new SketchImpl<Field28>(implementation, 28);\n+    case 29: return new SketchImpl<Field29>(implementation, 29);\n+    case 30: return new SketchImpl<Field30>(implementation, 30);\n+    case 31: return new SketchImpl<Field31>(implementation, 31);\n+    case 32: return new SketchImpl<Field32>(implementation, 32);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "e7fc9cce5780a945129fd00ffc01af217adbeff7",
        "filename": "src/minisketch/src/fields/generic_5bytes.cpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_5bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_5bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_5bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,89 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+// 33 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5> StatTable33;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable33;\n+constexpr StatTable33 SQR_TABLE_33({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x802, 0x2008, 0x8020, 0x20080, 0x80200, 0x200800, 0x802000, 0x2008000, 0x8020000, 0x20080000, 0x80200000, 0x800401, 0x2001004, 0x8004010, 0x20010040, 0x80040100});\n+constexpr StatTable33 QRT_TABLE_33({0xba504dd4, 0x1e2798ef2, 0x1e2798ef0, 0x6698a4ec, 0x1e2798ef4, 0x1c7f1bef0, 0x6698a4e4, 0x16da1b384, 0x1e2798ee4, 0x661ca6ec, 0x1c7f1bed0, 0x1483b87a6, 0x6698a4a4, 0x800000, 0x16da1b304, 0x1a185101c, 0x1e2798fe4, 0xaa400954, 0x661ca4ec, 0x667caeec, 0x1c7f1bad0, 0x400800, 0x1483b8fa6, 0, 0x6698b4a4, 0x1c61da4b8, 0x802000, 0x16e5dadec, 0x16da1f304, 0x62fc8eec, 0x1a185901c, 0x1661da5ec, 0x1e2788fe4});\n+typedef Field<uint64_t, 33, 1025, StatTable33, DynTable33, &SQR_TABLE_33, &QRT_TABLE_33> Field33;\n+\n+// 34 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5> StatTable34;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable34;\n+constexpr StatTable34 SQR_TABLE_34({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x10000102, 0x40000408, 0x100001020});\n+constexpr StatTable34 QRT_TABLE_34({0x2f973a1f6, 0x40202, 0x40200, 0x348102060, 0x40204, 0x8000420, 0x348102068, 0x1092195c8, 0x40214, 0x3f6881b6e, 0x8000400, 0x3f810383e, 0x348102028, 0x340002068, 0x109219548, 0x24015a774, 0x40314, 0x3f050343e, 0x3f688196e, 0x3f81c3a3a, 0x8000000, 0x24031a560, 0x3f810303e, 0xb08c1a12, 0x348103028, 0xb2881906, 0x340000068, 0, 0x10921d548, 0x2e131e576, 0x240152774, 0x18921d55e, 0x50314, 0x14015271c});\n+typedef Field<uint64_t, 34, 129, StatTable34, DynTable34, &SQR_TABLE_34, &QRT_TABLE_34> Field34;\n+\n+// 35 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5> StatTable35;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable35;\n+constexpr StatTable35 SQR_TABLE_35({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0xa, 0x28, 0xa0, 0x280, 0xa00, 0x2800, 0xa000, 0x28000, 0xa0000, 0x280000, 0xa00000, 0x2800000, 0xa000000, 0x28000000, 0xa0000000, 0x280000000, 0x200000005});\n+constexpr StatTable35 QRT_TABLE_35({0x5c2038114, 0x2bf547ee8, 0x2bf547eea, 0x2bf1074e8, 0x2bf547eee, 0x1883d0736, 0x2bf1074e0, 0x100420, 0x2bf547efe, 0x400800, 0x1883d0716, 0x5e90e4a0, 0x2bf1074a0, 0x4e70ac20, 0x1004a0, 0x2f060c880, 0x2bf547ffe, 0x37d55fffe, 0x400a00, 0x3372573de, 0x1883d0316, 0x700c20, 0x5e90eca0, 0x10604880, 0x2bf1064a0, 0x18f35377e, 0x4e708c20, 0x33f557ffe, 0x1044a0, 0x1bf557ffe, 0x2f0604880, 0x200000000, 0x2bf557ffe, 0, 0x37d57fffe});\n+typedef Field<uint64_t, 35, 5, StatTable35, DynTable35, &SQR_TABLE_35, &QRT_TABLE_35> Field35;\n+\n+// 36 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6> StatTable36;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable36;\n+constexpr StatTable36 SQR_TABLE_36({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x10000402, 0x40001008, 0x100004020, 0x400010080});\n+constexpr StatTable36 QRT_TABLE_36({0x40200, 0x8b0526186, 0x8b0526184, 0x240001000, 0x8b0526180, 0xcb6894d94, 0x240001008, 0xdb6880c22, 0x8b0526190, 0x8000200, 0xcb6894db4, 0x500424836, 0x240001048, 0x406cb2834, 0xdb6880ca2, 0x241200008, 0x8b0526090, 0xdb05021a6, 0x8000000, 0xdb01829b2, 0xcb68949b4, 0x1001000, 0x500424036, 0x106116406, 0x240000048, 0xcb29968a4, 0x406cb0834, 0, 0xdb6884ca2, 0x110010516, 0x241208008, 0x430434520, 0x8b0536090, 0x41208040, 0xdb05221a6, 0xb6884d14});\n+typedef Field<uint64_t, 36, 513, StatTable36, DynTable36, &SQR_TABLE_36, &QRT_TABLE_36> Field36;\n+\n+// 37 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 5, 5, 5, 5, 5> StatTable37;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable37;\n+constexpr StatTable37 SQR_TABLE_37({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0xa6, 0x298, 0xa60, 0x2980, 0xa600, 0x29800, 0xa6000, 0x298000, 0xa60000, 0x2980000, 0xa600000, 0x29800000, 0xa6000000, 0x298000000, 0xa60000000, 0x980000053, 0x60000011f, 0x180000047c});\n+constexpr StatTable37 QRT_TABLE_37({0xa3c62e7ba, 0xdc7a0c16a, 0xdc7a0c168, 0x12f7484546, 0xdc7a0c16c, 0xa9803a20, 0x12f748454e, 0xda07064a4, 0xdc7a0c17c, 0x123908de8e, 0xa9803a00, 0x122a888a8e, 0x12f748450e, 0x6790add8, 0xda0706424, 0x12e0a0384c, 0xdc7a0c07c, 0xcb28a2c2, 0x123908dc8e, 0xd09f85e86, 0xa9803e00, 0x124d682b6e, 0x122a88828e, 0x1738711a, 0x12f748550e, 0x73035b8, 0x67908dd8, 0xa0702438, 0xda0702424, 0xe0a0b860, 0x12e0a0b84c, 0x1c7a1c060, 0xdc7a1c07c, 0, 0xcb2aa2c2, 0x100000002c, 0x12390cdc8e});\n+typedef Field<uint64_t, 37, 83, StatTable37, DynTable37, &SQR_TABLE_37, &QRT_TABLE_37> Field37;\n+\n+// 38 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5> StatTable38;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable38;\n+constexpr StatTable38 SQR_TABLE_38({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x63, 0x18c, 0x630, 0x18c0, 0x6300, 0x18c00, 0x63000, 0x18c000, 0x630000, 0x18c0000, 0x6300000, 0x18c00000, 0x63000000, 0x18c000000, 0x630000000, 0x18c0000000, 0x2300000063, 0xc0000014a, 0x3000000528});\n+constexpr StatTable38 QRT_TABLE_38({0x34b0ac6430, 0x2223262fa, 0x2223262f8, 0x35554405fe, 0x2223262fc, 0x355514098a, 0x35554405f6, 0x400840, 0x2223262ec, 0x1777726532, 0x35551409aa, 0x15c06fc0, 0x35554405b6, 0x1f5303fec, 0x4008c0, 0x236a21030, 0x2223263ec, 0x1a9008c00, 0x1777726732, 0x3692c60ab6, 0x3555140daa, 0x15556007ee, 0x15c067c0, 0x14a0b030f2, 0x35554415b6, 0x227c06d168, 0x1f5301fec, 0x16c3928fc2, 0x4048c0, 0x3a942c4c0, 0x236a29030, 0x1636a2902e, 0x2223363ec, 0x3a6e898276, 0x1a9028c00, 0x6de74eb2c, 0x1777766732, 0});\n+typedef Field<uint64_t, 38, 99, StatTable38, DynTable38, &SQR_TABLE_38, &QRT_TABLE_38> Field38;\n+\n+// 39 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5> StatTable39;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable39;\n+constexpr StatTable39 SQR_TABLE_39({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x800000011, 0x2000000044});\n+constexpr StatTable39 QRT_TABLE_39({0x66b02a408c, 0x100420, 0x100422, 0x14206080, 0x100426, 0x5dccefab1c, 0x14206088, 0x9fc11e5b6, 0x100436, 0x5466bea62a, 0x5dccefab3c, 0x9aa110536, 0x142060c8, 0x54739ed6e2, 0x9fc11e536, 0xe7a82c080, 0x100536, 0x4002000, 0x5466bea42a, 0x6a4022000, 0x5dccefaf3c, 0x9e8118536, 0x9aa110d36, 0x5680e080, 0x142070c8, 0x7d293c5b6, 0x54739ef6e2, 0x8d680e080, 0x9fc11a536, 0x6d282c080, 0xe7a824080, 0x800000000, 0x110536, 0x2d680e080, 0x4022000, 0, 0x5466baa42a, 0x46b03a44aa, 0x6a40a2000});\n+typedef Field<uint64_t, 39, 17, StatTable39, DynTable39, &SQR_TABLE_39, &QRT_TABLE_39> Field39;\n+\n+// 40 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5> StatTable40;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable40;\n+constexpr StatTable40 SQR_TABLE_40({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x39, 0xe4, 0x390, 0xe40, 0x3900, 0xe400, 0x39000, 0xe4000, 0x390000, 0xe40000, 0x3900000, 0xe400000, 0x39000000, 0xe4000000, 0x390000000, 0xe40000000, 0x3900000000, 0xe400000000, 0x900000004b, 0x400000015e});\n+constexpr StatTable40 QRT_TABLE_40({0x624b3cecc, 0xbc5c3f4c6, 0xbc5c3f4c4, 0xde1603e2c, 0xbc5c3f4c0, 0xaabec06cea, 0xde1603e24, 0x6cd9f724c2, 0xbc5c3f4d0, 0xcde1743818, 0xaabec06cca, 0xa138c314ca, 0xde1603e64, 0xaafc00f01a, 0x6cd9f72442, 0xcdca11bb4, 0xbc5c3f5d0, 0xa00002001a, 0xcde1743a18, 0xdf1407b90, 0xaabec068ca, 0xc043b482c8, 0xa138c31cca, 0xcb86977e3c, 0xde1602e64, 0x604596a326, 0xaafc00d01a, 0xcc1c165d0, 0x6cd9f76442, 0x673c94da26, 0xcdca19bb4, 0x67c0940a26, 0xbc5c2f5d0, 0xa4dca19bae, 0xa00000001a, 0x1bc5c2f5d0, 0xcde1703a18, 0, 0xdf1487b90, 0x8df1487b8a});\n+typedef Field<uint64_t, 40, 57, StatTable40, DynTable40, &SQR_TABLE_40, &QRT_TABLE_40> Field40;\n+\n+}\n+\n+Sketch* ConstructGeneric5Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 33: return new SketchImpl<Field33>(implementation, 33);\n+    case 34: return new SketchImpl<Field34>(implementation, 34);\n+    case 35: return new SketchImpl<Field35>(implementation, 35);\n+    case 36: return new SketchImpl<Field36>(implementation, 36);\n+    case 37: return new SketchImpl<Field37>(implementation, 37);\n+    case 38: return new SketchImpl<Field38>(implementation, 38);\n+    case 39: return new SketchImpl<Field39>(implementation, 39);\n+    case 40: return new SketchImpl<Field40>(implementation, 40);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "ec5526ec346819bf7d588e22784be3660deddaab",
        "filename": "src/minisketch/src/fields/generic_6bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_6bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_6bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_6bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 41 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5> StatTable41;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable41;\n+constexpr StatTable41 SQR_TABLE_41({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x12, 0x48, 0x120, 0x480, 0x1200, 0x4800, 0x12000, 0x48000, 0x120000, 0x480000, 0x1200000, 0x4800000, 0x12000000, 0x48000000, 0x120000000, 0x480000000, 0x1200000000, 0x4800000000, 0x12000000000, 0x8000000012});\n+constexpr StatTable41 QRT_TABLE_41({0, 0x1599a5e0b0, 0x1599a5e0b2, 0x105c119e0, 0x1599a5e0b6, 0x1a2030452a6, 0x105c119e8, 0x1a307c55b2e, 0x1599a5e0a6, 0x1ee3f47bc8e, 0x1a203045286, 0x400808, 0x105c119a8, 0x1a3038573a6, 0x1a307c55bae, 0x4d2882a520, 0x1599a5e1a6, 0x1ffbaa0b720, 0x1ee3f47be8e, 0x4d68c22528, 0x1a203045686, 0x200006, 0x400008, 0x1b79a21b200, 0x105c109a8, 0x1ef3886a526, 0x1a3038553a6, 0x1b692209200, 0x1a307c51bae, 0x5d99a4e1a6, 0x4d28822520, 0x185e109ae, 0x1599a4e1a6, 0x4e3f43be88, 0x1ffbaa2b720, 0x4000000000, 0x1ee3f43be8e, 0x18000000006, 0x4d68ca2528, 0xa203145680, 0x1a203145686});\n+typedef Field<uint64_t, 41, 9, StatTable41, DynTable41, &SQR_TABLE_41, &QRT_TABLE_41> Field41;\n+\n+// 42 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6> StatTable42;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable42;\n+constexpr StatTable42 SQR_TABLE_42({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x81, 0x204, 0x810, 0x2040, 0x8100, 0x20400, 0x81000, 0x204000, 0x810000, 0x2040000, 0x8100000, 0x20400000, 0x81000000, 0x204000000, 0x810000000, 0x2040000000, 0x8100000000, 0x20400000000, 0x1000000102, 0x4000000408, 0x10000001020});\n+constexpr StatTable42 QRT_TABLE_42({0x810200080, 0x120810806, 0x120810804, 0x1068c1a1000, 0x120810800, 0x34005023008, 0x1068c1a1008, 0x800004080, 0x120810810, 0x162818a10, 0x34005023028, 0x42408a14, 0x1068c1a1048, 0x1001040, 0x800004000, 0xb120808906, 0x120810910, 0x34000020068, 0x162818810, 0x68c021400, 0x34005023428, 0x10004000, 0x42408214, 0x162418214, 0x1068c1a0048, 0xb002018116, 0x1003040, 0x10008180448, 0x800000000, 0x62c08b04, 0xb120800906, 0x2408d1a3060, 0x120800910, 0x34401003028, 0x34000000068, 0, 0x162858810, 0xa042058116, 0x68c0a1400, 0x8162858806, 0x34005123428, 0x3068c0a1468});\n+typedef Field<uint64_t, 42, 129, StatTable42, DynTable42, &SQR_TABLE_42, &QRT_TABLE_42> Field42;\n+\n+// 43 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 5, 5, 5, 5, 5> StatTable43;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable43;\n+constexpr StatTable43 SQR_TABLE_43({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0xb2, 0x2c8, 0xb20, 0x2c80, 0xb200, 0x2c800, 0xb2000, 0x2c8000, 0xb20000, 0x2c80000, 0xb200000, 0x2c800000, 0xb2000000, 0x2c8000000, 0xb20000000, 0x2c80000000, 0xb200000000, 0x2c800000000, 0x32000000059, 0x4800000013d, 0x20000000446});\n+constexpr StatTable43 QRT_TABLE_43({0x2bccc2d6f6c, 0x4bccc2d6f54, 0x4bccc2d6f56, 0x7cc7bc61df0, 0x4bccc2d6f52, 0x7d13b404b10, 0x7cc7bc61df8, 0x37456e9ac5a, 0x4bccc2d6f42, 0x4e042c6a6, 0x7d13b404b30, 0x4a56de9ef4c, 0x7cc7bc61db8, 0x14bc18d8e, 0x37456e9acda, 0x7c89f84fb1e, 0x4bccc2d6e42, 0x7ffae40d210, 0x4e042c4a6, 0x366f45dd06, 0x7d13b404f30, 0x496fcaf8cca, 0x4a56de9e74c, 0x370b62b6af4, 0x7cc7bc60db8, 0x1498185a8, 0x14bc1ad8e, 0x7e602c46a98, 0x37456e9ecda, 0x36ccc2c6e74, 0x7c89f847b1e, 0x7e27d06d516, 0x4bccc2c6e42, 0x7f93302c396, 0x7ffae42d210, 0x3dd3440706, 0x4e046c4a6, 0x78bbc09da36, 0x366f4ddd06, 0, 0x7d13b504f30, 0x8bbc09da00, 0x496fc8f8cca});\n+typedef Field<uint64_t, 43, 89, StatTable43, DynTable43, &SQR_TABLE_43, &QRT_TABLE_43> Field43;\n+\n+// 44 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5> StatTable44;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable44;\n+constexpr StatTable44 SQR_TABLE_44({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x21, 0x84, 0x210, 0x840, 0x2100, 0x8400, 0x21000, 0x84000, 0x210000, 0x840000, 0x2100000, 0x8400000, 0x21000000, 0x84000000, 0x210000000, 0x840000000, 0x2100000000, 0x8400000000, 0x21000000000, 0x84000000000, 0x10000000042, 0x40000000108});\n+constexpr StatTable44 QRT_TABLE_44({0xf05334f4f6e, 0x4002016, 0x4002014, 0xf04350e6246, 0x4002010, 0x4935b379a26, 0xf04350e624e, 0xf84250c228e, 0x4002000, 0xf04300e521e, 0x4935b379a06, 0xb966838dd48, 0xf04350e620e, 0xf7b8b80feda, 0xf84250c220e, 0xf972e097d5e, 0x4002100, 0x8000020000, 0xf04300e501e, 0x430025000, 0x4935b379e06, 0xf976a09dc5e, 0xb966838d548, 0xf84218c029a, 0xf04350e720e, 0x4925f36bf06, 0xf7b8b80deda, 0xb047d3ee758, 0xf84250c620e, 0xf80350e720e, 0xf972e09fd5e, 0x8091825284, 0x4012100, 0x9015063210, 0x8000000000, 0xff31a028c5e, 0xf04300a501e, 0x44340b7100, 0x4300a5000, 0, 0x4935b279e06, 0xa976b2dce18, 0xf976a29dc5e, 0x8935b279e18});\n+typedef Field<uint64_t, 44, 33, StatTable44, DynTable44, &SQR_TABLE_44, &QRT_TABLE_44> Field44;\n+\n+// 45 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5> StatTable45;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable45;\n+constexpr StatTable45 SQR_TABLE_45({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x36, 0xd8, 0x360, 0xd80, 0x3600, 0xd800, 0x36000, 0xd8000, 0x360000, 0xd80000, 0x3600000, 0xd800000, 0x36000000, 0xd8000000, 0x360000000, 0xd80000000, 0x3600000000, 0xd800000000, 0x36000000000, 0xd8000000000, 0x16000000001b, 0x18000000005a});\n+constexpr StatTable45 QRT_TABLE_45({0xede34e3e0fc, 0x1554148191aa, 0x1554148191a8, 0x1767be1dc4a6, 0x1554148191ac, 0x26bd4931492, 0x1767be1dc4ae, 0x233ab9c454a, 0x1554148191bc, 0x16939e8bb3dc, 0x26bd49314b2, 0x3c6ca8bac52, 0x1767be1dc4ee, 0x16caa5054c16, 0x233ab9c45ca, 0x14a1649628bc, 0x1554148190bc, 0x3c382881252, 0x16939e8bb1dc, 0x3c7ca0aa160, 0x26bd49310b2, 0x27f40158000, 0x3c6ca8ba452, 0x173fc092853c, 0x1767be1dd4ee, 0x16cbe284f25c, 0x16caa5056c16, 0x155559002f96, 0x233ab9c05ca, 0x26eb8908b32, 0x14a16496a8bc, 0x15440885333c, 0x1554148090bc, 0x17d60702e0, 0x3c3828a1252, 0x54548d10b2, 0x16939e8fb1dc, 0x3ac1e81b1d2, 0x3c7ca02a160, 0x166bd48310bc, 0x26bd48310b2, 0, 0x27f40358000, 0x10000000000e, 0x3c6cacba452});\n+typedef Field<uint64_t, 45, 27, StatTable45, DynTable45, &SQR_TABLE_45, &QRT_TABLE_45> Field45;\n+\n+// 46 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5> StatTable46;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable46;\n+constexpr StatTable46 SQR_TABLE_46({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000});\n+constexpr StatTable46 QRT_TABLE_46({0x211c4fd486ba, 0x100104a, 0x1001048, 0x104d0492d4, 0x100104c, 0x20005040c820, 0x104d0492dc, 0x40008080, 0x100105c, 0x24835068ce00, 0x20005040c800, 0x200000400800, 0x104d04929c, 0x100904325c, 0x40008000, 0x25da9e77daf0, 0x100115c, 0x1184e1696f0, 0x24835068cc00, 0x24825169dd5c, 0x20005040cc00, 0x3ea3241c60c0, 0x200000400000, 0x211c4e5496f0, 0x104d04829c, 0x20005340d86c, 0x100904125c, 0x24835968de5c, 0x4000c000, 0x6400a0c0, 0x25da9e775af0, 0x118cf1687ac, 0x101115c, 0x1ea1745cacc0, 0x1184e1496f0, 0x20181e445af0, 0x2483506ccc00, 0x20240060c0, 0x24825161dd5c, 0x1e21755dbd9c, 0x20005050cc00, 0x26a3746cacc0, 0x3ea3243c60c0, 0xea3243c60c0, 0x200000000000, 0});\n+typedef Field<uint64_t, 46, 3, StatTable46, DynTable46, &SQR_TABLE_46, &QRT_TABLE_46> Field46;\n+\n+// 47 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5> StatTable47;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable47;\n+constexpr StatTable47 SQR_TABLE_47({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x42, 0x108, 0x420, 0x1080, 0x4200, 0x10800, 0x42000, 0x108000, 0x420000, 0x1080000, 0x4200000, 0x10800000, 0x42000000, 0x108000000, 0x420000000, 0x1080000000, 0x4200000000, 0x10800000000, 0x42000000000, 0x108000000000, 0x420000000000, 0x80000000042, 0x200000000108});\n+constexpr StatTable47 QRT_TABLE_47({0, 0x1001040, 0x1001042, 0x1047043076, 0x1001046, 0x112471c241e, 0x104704307e, 0x4304e052168, 0x1001056, 0x10004000, 0x112471c243e, 0x172a09c949d6, 0x104704303e, 0x4002020, 0x4304e0521e8, 0x5400e220, 0x1001156, 0x172b08c85080, 0x10004200, 0x41200b0800, 0x112471c203e, 0x172f0cca50a0, 0x172a09c941d6, 0x7eb88a11c1d6, 0x104704203e, 0x1044042020, 0x4000020, 0x42001011156, 0x4304e0561e8, 0x172a28c95880, 0x54006220, 0x112931cc21e, 0x1011156, 0x53670f283e, 0x172b08ca5080, 0x7a80c414a03e, 0x10044200, 0x40000000000, 0x4120030800, 0x1928318801e, 0x112470c203e, 0x799283188000, 0x172f0cea50a0, 0x1eb88a91c1c8, 0x172a098941d6, 0x3ea8cc95e1f6, 0x7eb88a91c1d6});\n+typedef Field<uint64_t, 47, 33, StatTable47, DynTable47, &SQR_TABLE_47, &QRT_TABLE_47> Field47;\n+\n+// 48 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6> StatTable48;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable48;\n+constexpr StatTable48 SQR_TABLE_48({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x2d, 0xb4, 0x2d0, 0xb40, 0x2d00, 0xb400, 0x2d000, 0xb4000, 0x2d0000, 0xb40000, 0x2d00000, 0xb400000, 0x2d000000, 0xb4000000, 0x2d0000000, 0xb40000000, 0x2d00000000, 0xb400000000, 0x2d000000000, 0xb4000000000, 0x2d0000000000, 0xb40000000000, 0xd0000000005a, 0x40000000011f});\n+constexpr StatTable48 QRT_TABLE_48({0xc00442c284f0, 0xc16b7fda410a, 0xc16b7fda4108, 0xada3b5c79fbe, 0xc16b7fda410c, 0x16f3c18d5b0, 0xada3b5c79fb6, 0x7090a381f64, 0xc16b7fda411c, 0xcafc15d179f8, 0x16f3c18d590, 0x6630880e534e, 0xada3b5c79ff6, 0xa13dd1f49826, 0x7090a381fe4, 0xb87560f6a74, 0xc16b7fda401c, 0xaaaaffff0012, 0xcafc15d17bf8, 0xaafd15f07bf6, 0x16f3c18d190, 0x60000020000e, 0x6630880e5b4e, 0xcb977fcb401c, 0xada3b5c78ff6, 0x6663420cad0, 0xa13dd1f4b826, 0xc0045fc2f41c, 0x7090a385fe4, 0x6762e24b834, 0xb87560fea74, 0xc6351fed241c, 0xc16b7fdb401c, 0x60065622ea7a, 0xaaaafffd0012, 0xdf9562bea74, 0xcafc15d57bf8, 0x6657ea057bea, 0xaafd15f87bf6, 0xa79329ddaa66, 0x16f3c08d190, 0xa39229f0aa66, 0x60000000000e, 0x175fb4468ad0, 0x6630884e5b4e, 0, 0xcb977f4b401c, 0x2630884e5b40});\n+typedef Field<uint64_t, 48, 45, StatTable48, DynTable48, &SQR_TABLE_48, &QRT_TABLE_48> Field48;\n+\n+}\n+\n+Sketch* ConstructGeneric6Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 41: return new SketchImpl<Field41>(implementation, 41);\n+    case 42: return new SketchImpl<Field42>(implementation, 42);\n+    case 43: return new SketchImpl<Field43>(implementation, 43);\n+    case 44: return new SketchImpl<Field44>(implementation, 44);\n+    case 45: return new SketchImpl<Field45>(implementation, 45);\n+    case 46: return new SketchImpl<Field46>(implementation, 46);\n+    case 47: return new SketchImpl<Field47>(implementation, 47);\n+    case 48: return new SketchImpl<Field48>(implementation, 48);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "4fb3f3c11298925f97e1a321169a87221cc62748",
        "filename": "src/minisketch/src/fields/generic_7bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_7bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_7bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_7bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 49 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable49;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable49;\n+constexpr StatTable49 SQR_TABLE_49({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x402, 0x1008, 0x4020, 0x10080, 0x40200, 0x100800, 0x402000, 0x1008000, 0x4020000, 0x10080000, 0x40200000, 0x100800000, 0x402000000, 0x1008000000, 0x4020000000, 0x10080000000, 0x40200000000, 0x100800000000, 0x402000000000, 0x1008000000000, 0x20000000402, 0x80000001008, 0x200000004020, 0x800000010080});\n+constexpr StatTable49 QRT_TABLE_49({0, 0x10004196, 0x10004194, 0x5099461f080, 0x10004190, 0x40840600c20, 0x5099461f088, 0x58a56349cfde, 0x10004180, 0x48641a0c03fe, 0x40840600c00, 0x10084002848, 0x5099461f0c8, 0x4002048, 0x58a56349cf5e, 0x5088460a048, 0x10004080, 0x4c2852624dde, 0x48641a0c01fe, 0x14893129c280, 0x40840600800, 0x1eb23c323ace8, 0x10084002048, 0x48740a09417e, 0x5099461e0c8, 0x40852604d96, 0x4000048, 0x5cad2b29c37e, 0x58a563498f5e, 0x20000200, 0x50884602048, 0x10000000000, 0x10014080, 0x4c2a56624d96, 0x4c2852604dde, 0x1ee2347438ca0, 0x48641a0801fe, 0x480000000048, 0x14893121c280, 0x14091121c080, 0x40840700800, 0x1a5099561e17e, 0x1eb23c303ace8, 0x8740a894136, 0x10084402048, 0x18101c501ace8, 0x48740a89417e, 0x15dace6286f96, 0x5099561e0c8});\n+typedef Field<uint64_t, 49, 513, StatTable49, DynTable49, &SQR_TABLE_49, &QRT_TABLE_49> Field49;\n+\n+// 50 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable50;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable50;\n+constexpr StatTable50 SQR_TABLE_50({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x1d, 0x74, 0x1d0, 0x740, 0x1d00, 0x7400, 0x1d000, 0x74000, 0x1d0000, 0x740000, 0x1d00000, 0x7400000, 0x1d000000, 0x74000000, 0x1d0000000, 0x740000000, 0x1d00000000, 0x7400000000, 0x1d000000000, 0x74000000000, 0x1d0000000000, 0x740000000000, 0x1d00000000000, 0x340000000001d, 0x1000000000053});\n+constexpr StatTable50 QRT_TABLE_50({0xfbdfa3ae9d4c, 0x38143245a4878, 0x38143245a487a, 0x38527487e7492, 0x38143245a487e, 0x3124c61f56d2a, 0x38527487e749a, 0xfa8c91b087c0, 0x38143245a486e, 0x3eca48c6196be, 0x3124c61f56d0a, 0x380000040080a, 0x38527487e74da, 0x976b2d8b39b4, 0xfa8c91b08740, 0xfa8cd5b02724, 0x38143245a496e, 0x316291dd013fe, 0x3eca48c6194be, 0x10344122064, 0x3124c61f5690a, 0x68c5f006ee40, 0x380000040000a, 0x852749fe64d0, 0x38527487e64da, 0x37ef8e9d0e9da, 0x976b2d8b19b4, 0x37fabd1cef34a, 0xfa8c91b0c740, 0x96282d9159b4, 0xfa8cd5b0a724, 0x464a8249dd0, 0x38143245b496e, 0x37eaa8ddc94be, 0x316291dd213fe, 0x392446035690a, 0x3eca48c6594be, 0x974b258b4964, 0x103441a2064, 0x385a7c87fb4da, 0x3124c61e5690a, 0xeb8ad5d9a724, 0x68c5f026ee40, 0x3724c61e5690a, 0x380000000000a, 0x3a8c5f026ee4a, 0x8527497e64d0, 0, 0x38527497e64da, 0x2fbdfa2ae8d0a});\n+typedef Field<uint64_t, 50, 29, StatTable50, DynTable50, &SQR_TABLE_50, &QRT_TABLE_50> Field50;\n+\n+// 51 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable51;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable51;\n+constexpr StatTable51 SQR_TABLE_51({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x96, 0x258, 0x960, 0x2580, 0x9600, 0x25800, 0x96000, 0x258000, 0x960000, 0x2580000, 0x9600000, 0x25800000, 0x96000000, 0x258000000, 0x960000000, 0x2580000000, 0x9600000000, 0x25800000000, 0x96000000000, 0x258000000000, 0x960000000000, 0x2580000000000, 0x160000000004b, 0x580000000012c, 0x6000000000426});\n+constexpr StatTable51 QRT_TABLE_51({0x778bf2703d152, 0x2aaaafbff2092, 0x2aaaafbff2090, 0x4d2119c7e7780, 0x2aaaafbff2094, 0x65de1df8ae194, 0x4d2119c7e7788, 0x67d63d7ba262c, 0x2aaaafbff2084, 0x28ff003f4167c, 0x65de1df8ae1b4, 0x658397fb1d034, 0x4d2119c7e77c8, 0x4d7c9284526ba, 0x67d63d7ba26ac, 0x6666333fc0cbe, 0x2aaaafbff2184, 0x295b807ab55ee, 0x28ff003f4147c, 0x2aaabfffe0016, 0x65de1df8ae5b4, 0x209210349d60, 0x658397fb1d834, 0x4d215dc7cf1c8, 0x4d2119c7e67c8, 0x662b2b3d7b4be, 0x4d7c9284506ba, 0x255af00b36e0, 0x67d63d7ba66ac, 0x65de1fb8ac1a6, 0x6666333fc8cbe, 0x662f3b3ded4be, 0x2aaaafbfe2184, 0x663a9dbc3a426, 0x295b807a955ee, 0x4cdc9ec128928, 0x28ff003f0147c, 0x28a0c93cd511c, 0x2aaabfff60016, 0x65d73cf8e78d4, 0x65de1df9ae5b4, 0x4d5eddc44f1c8, 0x209210149d60, 0x357fcc506c8a, 0x658397ff1d834, 0, 0x4d215dcfcf1c8, 0x63f536f5d4554, 0x4d2119d7e67c8, 0x4000000000022, 0x662b2b1d7b4be});\n+typedef Field<uint64_t, 51, 75, StatTable51, DynTable51, &SQR_TABLE_51, &QRT_TABLE_51> Field51;\n+\n+// 52 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable52;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable52;\n+constexpr StatTable52 SQR_TABLE_52({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x9, 0x24, 0x90, 0x240, 0x900, 0x2400, 0x9000, 0x24000, 0x90000, 0x240000, 0x900000, 0x2400000, 0x9000000, 0x24000000, 0x90000000, 0x240000000, 0x900000000, 0x2400000000, 0x9000000000, 0x24000000000, 0x90000000000, 0x240000000000, 0x900000000000, 0x2400000000000, 0x9000000000000, 0x4000000000012});\n+constexpr StatTable52 QRT_TABLE_52({0xc108165459b0e, 0x10004086, 0x10004084, 0xc00000100104e, 0x10004080, 0x2041810a545b0, 0xc000001001046, 0x1181e055efc0, 0x10004090, 0x40810214390, 0x2041810a54590, 0xc000141019106, 0xc000001001006, 0x10816045ab40, 0x1181e055ef40, 0xc000111015196, 0x10004190, 0xe045c19af44a2, 0x40810214190, 0xe045809ad0532, 0x2041810a54190, 0xdb387a03fe646, 0xc000141019906, 0x2000000800000, 0xc000001000006, 0x2486548199c34, 0x108160458b40, 0x2041808a50534, 0x1181e055af40, 0xc0408312153d6, 0xc00011101d196, 0x21499f0e0eed0, 0x10014190, 0xe15dff9faabe2, 0xe045c19ad44a2, 0xdb787b01ea7d6, 0x40810254190, 0xe484409180532, 0xe045809a50532, 0xc14095164d896, 0x2041810b54190, 0x217dee8fb7a74, 0xdb387a01fe646, 0x441810b54190, 0xc000141419906, 0xc3386e15e7f46, 0x2000000000000, 0x1000141419900, 0xc000000000006, 0, 0x248654a199c34, 0xa48654a199c32});\n+typedef Field<uint64_t, 52, 9, StatTable52, DynTable52, &SQR_TABLE_52, &QRT_TABLE_52> Field52;\n+\n+// 53 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable53;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable53;\n+constexpr StatTable53 SQR_TABLE_53({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x8e, 0x238, 0x8e0, 0x2380, 0x8e00, 0x23800, 0x8e000, 0x238000, 0x8e0000, 0x2380000, 0x8e00000, 0x23800000, 0x8e000000, 0x238000000, 0x8e0000000, 0x2380000000, 0x8e00000000, 0x23800000000, 0x8e000000000, 0x238000000000, 0x8e0000000000, 0x2380000000000, 0x8e00000000000, 0x3800000000047, 0xe00000000011c, 0x18000000000437});\n+constexpr StatTable53 QRT_TABLE_53({0xf940b90844076, 0x1f940b90844052, 0x1f940b90844050, 0x9d2a063b43e64, 0x1f940b90844054, 0x936f69323ec14, 0x9d2a063b43e6c, 0xe12270a88898, 0x1f940b90844044, 0x1f917f00bb5a3c, 0x936f69323ec34, 0x1f622df85b46ee, 0x9d2a063b43e2c, 0x9bc65ab040b66, 0xe12270a88818, 0x958330b931986, 0x1f940b90844144, 0x98e2a06e32e0, 0x1f917f00bb583c, 0x1f877970dc1024, 0x936f69323e834, 0x16cc3c9b1558c2, 0x1f622df85b4eee, 0x16de1c3351dae8, 0x9d2a063b42e2c, 0x1fecdc7855f8ee, 0x9bc65ab042b66, 0x933821b1cb6fe, 0xe12270a8c818, 0x1f675958641c0e, 0x958330b939986, 0x9d97e050e960, 0x1f940b90854144, 0x1f820fa0e38adc, 0x98e2a06c32e0, 0x1650f0e358a010, 0x1f917f00bf583c, 0x1643af4b037a3a, 0x1f877970d41024, 0x1ffe2c281d8c16, 0x936f69333e834, 0xf00d50ffccf8, 0x16cc3c9b3558c2, 0x16bc31cbca943a, 0x1f622df81b4eee, 0xa6cbd8007232, 0x16de1c33d1dae8, 0x15d2a062b42e10, 0x9d2a062b42e2c, 0x1aa77896586ca, 0x1fecdc7a55f8ee, 0, 0x9bc65af042b66});\n+typedef Field<uint64_t, 53, 71, StatTable53, DynTable53, &SQR_TABLE_53, &QRT_TABLE_53> Field53;\n+\n+// 54 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable54;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable54;\n+constexpr StatTable54 SQR_TABLE_54({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x201, 0x804, 0x2010, 0x8040, 0x20100, 0x80400, 0x201000, 0x804000, 0x2010000, 0x8040000, 0x20100000, 0x80400000, 0x201000000, 0x804000000, 0x2010000000, 0x8040000000, 0x20100000000, 0x80400000000, 0x201000000000, 0x804000000000, 0x2010000000000, 0x8040000000000, 0x20100000000000, 0x400000000402, 0x1000000001008, 0x4000000004020, 0x10000000010080});\n+constexpr StatTable54 QRT_TABLE_54({0x201008000200, 0x26c10916494994, 0x26c10916494996, 0x40008008, 0x26c10916494992, 0x141a2434c12d12, 0x40008000, 0x36c00110594c22, 0x26c10916494982, 0x200000040200, 0x141a2434c12d32, 0x10010816104534, 0x40008040, 0x36da60b01308b2, 0x36c00110594ca2, 0x48200209000, 0x26c10916494882, 0x41b6da2d86106, 0x200000040000, 0x32db2c228965b0, 0x141a2434c12932, 0x9000000200048, 0x10010816104d34, 0x32db68b2832da4, 0x40009040, 0x40045928b4902, 0x36da60b01328b2, 0x1000040000, 0x36c00110590ca2, 0x101b69865a4120, 0x48200201000, 0x22da6434912884, 0x26c10916484882, 0x9000240208008, 0x41b6da2da6106, 0x22c14484c20180, 0x200000000000, 0x4016db29b6812, 0x32db2c228165b0, 0x9008200201048, 0x141a2434d12932, 0x32c36ca2c264b0, 0x9000000000048, 0x140a65b48a2c32, 0x10010816504d34, 0, 0x32db68b2032da4, 0x404490824814, 0x41009040, 0x14da60a4536126, 0x40045908b4902, 0x8000041009008, 0x36da60b41328b2, 0x6db68b2032c12});\n+typedef Field<uint64_t, 54, 513, StatTable54, DynTable54, &SQR_TABLE_54, &QRT_TABLE_54> Field54;\n+\n+// 55 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable55;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable55;\n+constexpr StatTable55 SQR_TABLE_55({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x102, 0x408, 0x1020, 0x4080, 0x10200, 0x40800, 0x102000, 0x408000, 0x1020000, 0x4080000, 0x10200000, 0x40800000, 0x102000000, 0x408000000, 0x1020000000, 0x4080000000, 0x10200000000, 0x40800000000, 0x102000000000, 0x408000000000, 0x1020000000000, 0x4080000000000, 0x10200000000000, 0x40800000000000, 0x2000000000102, 0x8000000000408, 0x20000000001020});\n+constexpr StatTable55 QRT_TABLE_55({0, 0x121d57b6623fde, 0x121d57b6623fdc, 0x68908340d10e00, 0x121d57b6623fd8, 0x100300510e20, 0x68908340d10e08, 0x10004096, 0x121d57b6623fc8, 0x100010000, 0x100300510e00, 0x7ea8c890a088e8, 0x68908340d10e48, 0x68809540871648, 0x10004016, 0x68808000808068, 0x121d57b6623ec8, 0x68909240d41c48, 0x100010200, 0x6884c170ad0216, 0x100300510a00, 0x68848160a50200, 0x7ea8c890a080e8, 0x7eecbca04ab4b6, 0x68908340d11e48, 0x120c54b62234c8, 0x68809540873648, 0x69929240d61c48, 0x10000016, 0x68808060800000, 0x68808000800068, 0x80000080, 0x121d57b6633ec8, 0x7ea8cb90a18ae8, 0x68909240d61c48, 0x16284090200080, 0x100050200, 0x474302a345e, 0x6884c170a50216, 0x166cbca0cab4de, 0x100300410a00, 0x1000000000000, 0x68848160850200, 0x688cc1f0a50296, 0x7ea8c890e080e8, 0x7e8cc1f0a50280, 0x7eecbca0cab4b6, 0x68000000000068, 0x68908341d11e48, 0x7880954487365e, 0x120c54b42234c8, 0x9929248d61c20, 0x68809544873648, 0x41121208561c20, 0x69929248d61c48});\n+typedef Field<uint64_t, 55, 129, StatTable55, DynTable55, &SQR_TABLE_55, &QRT_TABLE_55> Field55;\n+\n+// 56 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable56;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable56;\n+constexpr StatTable56 SQR_TABLE_56({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x95, 0x254, 0x950, 0x2540, 0x9500, 0x25400, 0x95000, 0x254000, 0x950000, 0x2540000, 0x9500000, 0x25400000, 0x95000000, 0x254000000, 0x950000000, 0x2540000000, 0x9500000000, 0x25400000000, 0x95000000000, 0x254000000000, 0x950000000000, 0x2540000000000, 0x9500000000000, 0x25400000000000, 0x95000000000000, 0x5400000000012a, 0x5000000000043d, 0x40000000001061});\n+constexpr StatTable56 QRT_TABLE_56({0x10004084, 0xd058f12fd5925e, 0xd058f12fd5925c, 0x41a60b5566d9f0, 0xd058f12fd59258, 0xbda60a142740ba, 0x41a60b5566d9f8, 0xd059f1afc5e688, 0xd058f12fd59248, 0xfc040841615a22, 0xbda60a1427409a, 0xbda60b5426c1ca, 0x41a60b5566d9b8, 0x1a60b4166b950, 0xd059f1afc5e608, 0xfc000041409822, 0xd058f12fd59348, 0xd1ee7a4ef4185c, 0xfc040841615822, 0x9049759b80b4a4, 0xbda60a1427449a, 0xd258e06f301e18, 0xbda60b5426c9ca, 0x6dfeeb3bf6d7d2, 0x41a60b5566c9b8, 0xbdef3ed4ae398a, 0x1a60b41669950, 0xd1ef3f8eeff04c, 0xd059f1afc5a608, 0xbda203340783de, 0xfc000041401822, 0x2dfefbaff2b27a, 0xd058f12fd49348, 0xfdb788a0706776, 0xd1ee7a4ef6185c, 0x2e5de0ae41337a, 0xfc040841655822, 0x41eb17d5ceecf8, 0x9049759b88b4a4, 0x40048874211afc, 0xbda60a1437449a, 0xd04a720f93400c, 0xd258e06f101e18, 0xbc559cf5ac7fce, 0xbda60b5466c9ca, 0x6dc9759b88b4d6, 0x6dfeeb3b76d7d2, 0x92feea7b275af0, 0x41a60b5466c9b8, 0, 0xbdef3ed6ae398a, 0x2811d5edd8ee2a, 0x1a60b45669950, 0xb1a60b5466c9ca, 0xd1ef3f86eff04c, 0xec493582c8f032});\n+typedef Field<uint64_t, 56, 149, StatTable56, DynTable56, &SQR_TABLE_56, &QRT_TABLE_56> Field56;\n+\n+}\n+\n+Sketch* ConstructGeneric7Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 49: return new SketchImpl<Field49>(implementation, 49);\n+    case 50: return new SketchImpl<Field50>(implementation, 50);\n+    case 51: return new SketchImpl<Field51>(implementation, 51);\n+    case 52: return new SketchImpl<Field52>(implementation, 52);\n+    case 53: return new SketchImpl<Field53>(implementation, 53);\n+    case 54: return new SketchImpl<Field54>(implementation, 54);\n+    case 55: return new SketchImpl<Field55>(implementation, 55);\n+    case 56: return new SketchImpl<Field56>(implementation, 56);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "bbde7337039b6ca679765fab16ace3ac71bbe2af",
        "filename": "src/minisketch/src/fields/generic_8bytes.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_8bytes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_8bytes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_8bytes.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,90 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* This file was substantially auto-generated by doc/gen_params.sage. */\n+\n+#include <stdint.h>\n+\n+#include \"generic_common_impl.h\"\n+\n+#include \"../lintrans.h\"\n+#include \"../sketch_impl.h\"\n+#include \"../sketch.h\"\n+\n+namespace {\n+\n+// 57 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable57;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable57;\n+constexpr StatTable57 SQR_TABLE_57({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x22, 0x88, 0x220, 0x880, 0x2200, 0x8800, 0x22000, 0x88000, 0x220000, 0x880000, 0x2200000, 0x8800000, 0x22000000, 0x88000000, 0x220000000, 0x880000000, 0x2200000000, 0x8800000000, 0x22000000000, 0x88000000000, 0x220000000000, 0x880000000000, 0x2200000000000, 0x8800000000000, 0x22000000000000, 0x88000000000000, 0x20000000000011, 0x80000000000044});\n+constexpr StatTable57 QRT_TABLE_57({0xd0c3a82c902426, 0x232aa54103915e, 0x232aa54103915c, 0x1763e291e61699c, 0x232aa541039158, 0x1f424d678bb15e, 0x1763e291e616994, 0x26fd8122f10d36, 0x232aa541039148, 0x1e0a0206002000, 0x1f424d678bb17e, 0x5d72563f39d7e, 0x1763e291e6169d4, 0x1519beb9d597df4, 0x26fd8122f10db6, 0x150c3a87c90e4aa, 0x232aa541039048, 0x15514891f6179d4, 0x1e0a0206002200, 0x14ec9ba7a94c6aa, 0x1f424d678bb57e, 0x1e0f4286382420, 0x5d72563f3957e, 0x4000080000, 0x1763e291e6179d4, 0x1ac0e804882000, 0x1519beb9d595df4, 0x1f430d6793b57e, 0x26fd8122f14db6, 0x3c68e806882000, 0x150c3a87c9064aa, 0x1484fe18b915e, 0x232aa541029048, 0x14f91eb9b595df4, 0x15514891f6379d4, 0x48f6a82380420, 0x1e0a0206042200, 0x14b1beb99595df4, 0x14ec9ba7a9cc6aa, 0x4cf2a82b00420, 0x1f424d679bb57e, 0x26aa0002000000, 0x1e0f4286182420, 0x173f1039dd17df4, 0x5d72563b3957e, 0x4aa0002000000, 0x4000880000, 0x16d31eb9b595df4, 0x1763e291f6179d4, 0x20000000000000, 0x1ac0e806882000, 0x2caa0002000000, 0x1519beb99595df4, 0, 0x1f430d6f93b57e, 0x73e90d6d93b57e, 0x26fd8132f14db6});\n+typedef Field<uint64_t, 57, 17, StatTable57, DynTable57, &SQR_TABLE_57, &QRT_TABLE_57> Field57;\n+\n+// 58 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable58;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable58;\n+constexpr StatTable58 SQR_TABLE_58({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x80001, 0x200004, 0x800010, 0x2000040, 0x8000100, 0x20000400, 0x80001000, 0x200004000, 0x800010000, 0x2000040000, 0x8000100000, 0x20000400000, 0x80001000000, 0x200004000000, 0x800010000000, 0x2000040000000, 0x8000100000000, 0x20000400000000, 0x80001000000000, 0x200004000000000, 0x10000100002, 0x40000400008, 0x100001000020, 0x400004000080, 0x1000010000200, 0x4000040000800, 0x10000100002000, 0x40000400008000, 0x100001000020000});\n+constexpr StatTable58 QRT_TABLE_58({0x2450096792a5c5c, 0x610014271011c, 0x610014271011e, 0x1f0cb811314ea88, 0x610014271011a, 0x8000000420, 0x1f0cb811314ea80, 0x265407ad8a20bcc, 0x610014271010a, 0x3d18be98392ebd0, 0x8000000400, 0xc29b930e407056, 0x1f0cb811314eac0, 0x1fcef001154dee8, 0x265407ad8a20b4c, 0xc69b924c61f94a, 0x610014271000a, 0x211006895845190, 0x3d18be98392e9d0, 0x54007accac09cc, 0x8000000000, 0xc08b934e107854, 0xc29b930e407856, 0x275407adc220bcc, 0x1f0cb811314fac0, 0x1f6db815164ea8a, 0x1fcef001154fee8, 0x1b2db801945e396, 0x265407ad8a24b4c, 0x21100ec95865590, 0xc69b924c61794a, 0x273507b1e530ad6, 0x610014270000a, 0x1b4cb835b34e29c, 0x211006895865190, 0x3839bf20d47e016, 0x3d18be98396e9d0, 0x3858bd34f36e01c, 0x54007acca409cc, 0, 0x8000100000, 0xc29a130e507856, 0xc08b934e307854, 0x13253921d448296, 0xc29b930e007856, 0x13c60935f6486bc, 0x275407adca20bcc, 0x3571be8c5e6c9da, 0x1f0cb811214fac0, 0x410014261011c, 0x1f6db815364ea8a, 0x13a50921d1486b6, 0x1fcef001554fee8, 0x64001249245a5c, 0x1b2db801145e396, 0x8610014670200a, 0x265407ac8a24b4c, 0x1a5cbfbdeb0f30c});\n+typedef Field<uint64_t, 58, 524289, StatTable58, DynTable58, &SQR_TABLE_58, &QRT_TABLE_58> Field58;\n+\n+// 59 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5> StatTable59;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable59;\n+constexpr StatTable59 SQR_TABLE_59({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x12a, 0x4a8, 0x12a0, 0x4a80, 0x12a00, 0x4a800, 0x12a000, 0x4a8000, 0x12a0000, 0x4a80000, 0x12a00000, 0x4a800000, 0x12a000000, 0x4a8000000, 0x12a0000000, 0x4a80000000, 0x12a00000000, 0x4a800000000, 0x12a000000000, 0x4a8000000000, 0x12a0000000000, 0x4a80000000000, 0x12a00000000000, 0x4a800000000000, 0x12a000000000000, 0x4a8000000000000, 0x2a000000000012a, 0x28000000000043d, 0x200000000001061});\n+constexpr StatTable59 QRT_TABLE_59({0x38d905ab028567a, 0x789fa6ed3b44d72, 0x789fa6ed3b44d70, 0x74ec857e93d828c, 0x789fa6ed3b44d74, 0x116b3c1203c96, 0x74ec857e93d8284, 0xc25ebc3871e280, 0x789fa6ed3b44d64, 0x47a37c3d910b6, 0x116b3c1203cb6, 0xc7322d7a8f48de, 0x74ec857e93d82c4, 0xb509a0ea52e496, 0xc25ebc3871e200, 0x74fdee4681d3e0c, 0x789fa6ed3b44c64, 0x7ffbbd080b2f09a, 0x47a37c3d912b6, 0xd5c937bae506c8, 0x116b3c12038b6, 0xb173c76987625e, 0xc7322d7a8f40de, 0x7591ff36b3a682c, 0x74ec857e93d92c4, 0x72b253bfbfc90c4, 0xb509a0ea52c496, 0x79f2e7b10e6d452, 0xc25ebc3871a200, 0x78c86e951086aac, 0x74fdee4681dbe0c, 0x78c96eb514c602c, 0x789fa6ed3b54c64, 0xc34818b95658e8, 0x7ffbbd080b0f09a, 0x7399f563b1980f2, 0x47a37c3dd12b6, 0xa29e0e28c58880, 0xd5c937baed06c8, 0x788ac23520ac82c, 0x116b3c13038b6, 0xa2c857e83d92b6, 0xb173c769a7625e, 0x608da990122e48, 0xc7322d7acf40de, 0xa3a89269eebefe, 0x7591ff36bba682c, 0xa25ebc2871a200, 0x74ec857e83d92c4, 0x11f62e419f1cfe, 0x72b253bf9fc90c4, 0x7425ebc2871a272, 0xb509a0ee52c496, 0x4ed8555979c8de, 0x79f2e7b18e6d452, 0x6c3580d5915d4d2, 0xc25ebc2871a200, 0, 0x78c86e971086aac});\n+typedef Field<uint64_t, 59, 149, StatTable59, DynTable59, &SQR_TABLE_59, &QRT_TABLE_59> Field59;\n+\n+// 60 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6> StatTable60;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable60;\n+constexpr StatTable60 SQR_TABLE_60({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x3, 0xc, 0x30, 0xc0, 0x300, 0xc00, 0x3000, 0xc000, 0x30000, 0xc0000, 0x300000, 0xc00000, 0x3000000, 0xc000000, 0x30000000, 0xc0000000, 0x300000000, 0xc00000000, 0x3000000000, 0xc000000000, 0x30000000000, 0xc0000000000, 0x300000000000, 0xc00000000000, 0x3000000000000, 0xc000000000000, 0x30000000000000, 0xc0000000000000, 0x300000000000000, 0xc00000000000000});\n+constexpr StatTable60 QRT_TABLE_60({0x6983c00fe00104a, 0x804570322e054e6, 0x804570322e054e4, 0x15673387e0a4e4, 0x804570322e054e0, 0x100010110, 0x15673387e0a4ec, 0x920d01f34442a70, 0x804570322e054f0, 0x7a8dc0f2e4058f0, 0x100010130, 0x120c01f140462f0, 0x15673387e0a4ac, 0x7bdbb2ca9a4fe5c, 0x920d01f34442af0, 0xe9c6b039ce0c4ac, 0x804570322e055f0, 0xfac8b080ca20c00, 0x7a8dc0f2e405af0, 0x7a8dc4b2e4a59f0, 0x100010530, 0x10000100000, 0x120c01f14046af0, 0x131a02d91c5db6c, 0x15673387e0b4ac, 0x15623387d0b4ac, 0x7bdbb2ca9a4de5c, 0x7ffbbbca0a8ee5c, 0x920d01f34446af0, 0x800000020000000, 0xe9c6b039ce044ac, 0x81130302500f000, 0x804570322e155f0, 0x935b72eb3a48e9c, 0xfac8b080ca00c00, 0x120c016140563c0, 0x7a8dc0f2e445af0, 0x7bcbb3ca8a4ee5c, 0x7a8dc4b2e4259f0, 0xc4000a0300, 0x100110530, 0x11623285c1b19c, 0x10000300000, 0x420890090c3000, 0x120c01f14446af0, 0x68d7b33b9e0b4ac, 0x131a02d9145db6c, 0xe8ccb1e18a56fc0, 0x15673386e0b4ac, 0x7aadc8f2e485af0, 0x15623385d0b4ac, 0x4a0990093c3000, 0x7bdbb2cada4de5c, 0xf9d6b3389e0b4ac, 0x7ffbbbca8a8ee5c, 0xdf6ba38cec84ac, 0x920d01f24446af0, 0x520d01f24446af0, 0x800000000000000, 0});\n+typedef Field<uint64_t, 60, 3, StatTable60, DynTable60, &SQR_TABLE_60, &QRT_TABLE_60> Field60;\n+\n+// 61 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable61;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable61;\n+constexpr StatTable61 SQR_TABLE_61({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4e, 0x138, 0x4e0, 0x1380, 0x4e00, 0x13800, 0x4e000, 0x138000, 0x4e0000, 0x1380000, 0x4e00000, 0x13800000, 0x4e000000, 0x138000000, 0x4e0000000, 0x1380000000, 0x4e00000000, 0x13800000000, 0x4e000000000, 0x138000000000, 0x4e0000000000, 0x1380000000000, 0x4e00000000000, 0x13800000000000, 0x4e000000000000, 0x138000000000000, 0x4e0000000000000, 0x1380000000000000, 0xe0000000000004e, 0x180000000000011f});\n+constexpr StatTable61 QRT_TABLE_61({0x171d34fcdac955d0, 0x12cfc8c049e1c96, 0x12cfc8c049e1c94, 0x71d34fcdac955c2, 0x12cfc8c049e1c90, 0x631c871de564852, 0x71d34fcdac955ca, 0x129fa6407f27300, 0x12cfc8c049e1c80, 0x7094f6fdd0a3b12, 0x631c871de564872, 0xdb28cee59c8256a, 0x71d34fcdac9558a, 0xc8a0be15a915472, 0x129fa6407f27380, 0x12dfcb4058e0b80, 0x12cfc8c049e1d80, 0x117d7f04ad0118, 0x7094f6fdd0a3912, 0x621b576dbe35b6a, 0x631c871de564c72, 0x13c808a013a1ee0, 0xdb28cee59c82d6a, 0x113d79842a0272, 0x71d34fcdac9458a, 0x719776b580b6a98, 0xc8a0be15a917472, 0x6633498d6db760a, 0x129fa6407f23380, 0xbd4ae9e8c3e7560, 0x12dfcb4058e8b80, 0x8000000a, 0x12cfc8c049f1d80, 0x634ce9add3b26ea, 0x117d7f04af0118, 0xda3f19c5d66258a, 0x7094f6fdd0e3912, 0xb87427e85e71560, 0x621b576dbeb5b6a, 0xc8b0b085b8c4e0a, 0x631c871de464c72, 0x1538fc8649458a, 0x13c808a011a1ee0, 0xcddbca6d1cfe360, 0xdb28cee59882d6a, 0xae80f550d1ffff2, 0x113d7984aa0272, 0xda7770f5f195912, 0x71d34fcdbc9458a, 0x137c8a049a1ee0, 0x719776b5a0b6a98, 0xded39a9d236ba78, 0xc8a0be15e917472, 0x6732488ca7ce0a, 0x6633498dedb760a, 0xc0406d0527cb80a, 0x129fa6417f23380, 0x3d4ae9eac3e756a, 0xbd4ae9eac3e7560, 0, 0x12dfcb4458e8b80});\n+typedef Field<uint64_t, 61, 39, StatTable61, DynTable61, &SQR_TABLE_61, &QRT_TABLE_61> Field61;\n+\n+// 62 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable62;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable62;\n+constexpr StatTable62 SQR_TABLE_62({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x20000001, 0x80000004, 0x200000010, 0x800000040, 0x2000000100, 0x8000000400, 0x20000001000, 0x80000004000, 0x200000010000, 0x800000040000, 0x2000000100000, 0x8000000400000, 0x20000001000000, 0x80000004000000, 0x200000010000000, 0x800000040000000, 0x2000000100000000, 0x440000002, 0x1100000008, 0x4400000020, 0x11000000080, 0x44000000200, 0x110000000800, 0x440000002000, 0x1100000008000, 0x4400000020000, 0x11000000080000, 0x44000000200000, 0x110000000800000, 0x440000002000000, 0x1100000008000000});\n+constexpr StatTable62 QRT_TABLE_62({0x30268b6fba455d2c, 0x200000006, 0x200000004, 0x3d67cb6c1fe66c76, 0x200000000, 0x3fc4f1901abfa400, 0x3d67cb6c1fe66c7e, 0x35e79b6c0a66bcbe, 0x200000010, 0x1e9372bc57a9941e, 0x3fc4f1901abfa420, 0x21ec9d424957a5b0, 0x3d67cb6c1fe66c3e, 0x1cb35a6e52f5fb0e, 0x35e79b6c0a66bc3e, 0x215481024c13a730, 0x200000110, 0x1c324a6c52f75b08, 0x1e9372bc57a9961e, 0x3764a9d00f676820, 0x3fc4f1901abfa020, 0x355481020e132730, 0x21ec9d424957adb0, 0x3c43c32c0f34301e, 0x3d67cb6c1fe67c3e, 0x1496122c45259728, 0x1cb35a6e52f5db0e, 0x15e418405b72ec20, 0x35e79b6c0a66fc3e, 0x30268b6e3a445c38, 0x215481024c132730, 0x100010114, 0x200010110, 0, 0x1c324a6c52f55b08, 0x215581044d133776, 0x1e9372bc57ad961e, 0x2155810e4d133766, 0x3764a9d00f6f6820, 0x2157833c4d12323e, 0x3fc4f1901aafa020, 0x1c324a4252f55b58, 0x355481020e332730, 0x28332fc0509d41e, 0x21ec9d424917adb0, 0x215783be4d12332e, 0x3c43c32c0fb4301e, 0x2157822c4d06363e, 0x3d67cb6c1ee67c3e, 0x23f6b9d2484afb78, 0x1496122c47259728, 0x14b8184047648a80, 0x1cb35a6e56f5db0e, 0x3fe4f1901aefa820, 0x15e418405372ec20, 0x3d5fd72c1be276be, 0x35e79b6c1a66fc3e, 0x14b038d24774cf10, 0x30268b6e1a445c38, 0x1d17022e43a7172e, 0x215481020c132730, 0x2157022e4d07372e});\n+typedef Field<uint64_t, 62, 536870913, StatTable62, DynTable62, &SQR_TABLE_62, &QRT_TABLE_62> Field62;\n+\n+// 63 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable63;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable63;\n+constexpr StatTable63 SQR_TABLE_63({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x6, 0x18, 0x60, 0x180, 0x600, 0x1800, 0x6000, 0x18000, 0x60000, 0x180000, 0x600000, 0x1800000, 0x6000000, 0x18000000, 0x60000000, 0x180000000, 0x600000000, 0x1800000000, 0x6000000000, 0x18000000000, 0x60000000000, 0x180000000000, 0x600000000000, 0x1800000000000, 0x6000000000000, 0x18000000000000, 0x60000000000000, 0x180000000000000, 0x600000000000000, 0x1800000000000000, 0x6000000000000000});\n+constexpr StatTable63 QRT_TABLE_63({0, 0x100010114, 0x100010116, 0x1001701051372, 0x100010112, 0x1000040220, 0x100170105137a, 0x5107703453bba, 0x100010102, 0x101130117155a, 0x1000040200, 0x40000200800, 0x100170105133a, 0x103151a137276d8, 0x5107703453b3a, 0x134e65fc7c222be0, 0x100010002, 0x100030103115a, 0x101130117175a, 0x106052d103f4de2, 0x1000040600, 0x15122707691d3a, 0x40000200000, 0x4530770bc57b3a, 0x100170105033a, 0x103011a131256d8, 0x103151a137256d8, 0x176f29eb55c7a8da, 0x5107703457b3a, 0x130b158b7767d0da, 0x134e65fc7c22abe0, 0x7bcaf59d2f62d3e2, 0x100000002, 0x1001401041260, 0x100030101115a, 0x5107e03443ab8, 0x101130113175a, 0x1043701251b3a, 0x106052d10374de2, 0x134e657d7c232be2, 0x1000140600, 0x106073d103b4be2, 0x15122707491d3a, 0x4438600ac07800, 0x40000600000, 0x176a199c5682d3e0, 0x4530770b457b3a, 0x7bca759c2f62d3e0, 0x100170005033a, 0x6116d02572de2, 0x103011a111256d8, 0x1346656d7c372de2, 0x103151a177256d8, 0x643c600aa07800, 0x176f29eb5dc7a8da, 0x7b4b758b2f67d0da, 0x5107713457b3a, 0x104570776b457b3a, 0x130b158b5767d0da, 0x734e65fc3c22abe0, 0x134e65fc3c22abe0, 0x4000000000000000, 0x7bcaf59daf62d3e2});\n+typedef Field<uint64_t, 63, 3, StatTable63, DynTable63, &SQR_TABLE_63, &QRT_TABLE_63> Field63;\n+\n+// 64 bit field\n+typedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5> StatTable64;\n+typedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4> DynTable64;\n+constexpr StatTable64 SQR_TABLE_64({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x10000000000000, 0x40000000000000, 0x100000000000000, 0x400000000000000, 0x1000000000000000, 0x4000000000000000, 0x1b, 0x6c, 0x1b0, 0x6c0, 0x1b00, 0x6c00, 0x1b000, 0x6c000, 0x1b0000, 0x6c0000, 0x1b00000, 0x6c00000, 0x1b000000, 0x6c000000, 0x1b0000000, 0x6c0000000, 0x1b00000000, 0x6c00000000, 0x1b000000000, 0x6c000000000, 0x1b0000000000, 0x6c0000000000, 0x1b00000000000, 0x6c00000000000, 0x1b000000000000, 0x6c000000000000, 0x1b0000000000000, 0x6c0000000000000, 0x1b00000000000000, 0x6c00000000000000, 0xb00000000000001b, 0xc00000000000005a});\n+constexpr StatTable64 QRT_TABLE_64({0x19c9369f278adc02, 0x84b2b22ab2383ee4, 0x84b2b22ab2383ee6, 0x9d7b84b495b3e3f6, 0x84b2b22ab2383ee2, 0x37c470b49213f790, 0x9d7b84b495b3e3fe, 0x1000a0105137c, 0x84b2b22ab2383ef2, 0x368e964a8edce1fc, 0x37c470b49213f7b0, 0x19c9368e278fdf4c, 0x9d7b84b495b3e3be, 0x2e4da23cbc7d4570, 0x1000a010513fc, 0x84f35772bac24232, 0x84b2b22ab2383ff2, 0x37c570ba9314e4fc, 0x368e964a8edce3fc, 0xb377c390213cdb0e, 0x37c470b49213f3b0, 0x85ed5a3aa99c24f2, 0x19c9368e278fd74c, 0xaabff0000780000e, 0x9d7b84b495b3f3be, 0x84b6b3dab03038f2, 0x2e4da23cbc7d6570, 0x511ea03494ffc, 0x1000a010553fc, 0xae0c0220343c6c0e, 0x84f35772bac2c232, 0x800000008000000e, 0x84b2b22ab2393ff2, 0xb376c29c202bc97e, 0x37c570ba9316e4fc, 0x9c3062488879e6ce, 0x368e964a8ed8e3fc, 0x41e42c08e47e70, 0xb377c3902134db0e, 0x85b9b108a60f56ce, 0x37c470b49203f3b0, 0x19dd3b6e21f3cb4c, 0x85ed5a3aa9bc24f2, 0x198ddf682c428ac0, 0x19c9368e27cfd74c, 0x4b7c68431ca84b0, 0xaabff0000700000e, 0x8040655489ffefbe, 0x9d7b84b494b3f3be, 0x18c1354e32bfa74c, 0x84b6b3dab23038f2, 0xaaf613cc0f74627e, 0x2e4da23cb87d6570, 0x3248b3d6b3342a8c, 0x511ea0b494ffc, 0xb60813c00e70700e, 0x1000a110553fc, 0x1e0d022a05393ffc, 0xae0c0220143c6c0e, 0xe0c0220143c6c00, 0x84f35772fac2c232, 0xc041e55948fbfdce, 0x800000000000000e, 0});\n+typedef Field<uint64_t, 64, 27, StatTable64, DynTable64, &SQR_TABLE_64, &QRT_TABLE_64> Field64;\n+\n+}\n+\n+Sketch* ConstructGeneric8Bytes(int bits, int implementation)\n+{\n+    switch (bits) {\n+    case 57: return new SketchImpl<Field57>(implementation, 57);\n+    case 58: return new SketchImpl<Field58>(implementation, 58);\n+    case 59: return new SketchImpl<Field59>(implementation, 59);\n+    case 60: return new SketchImpl<Field60>(implementation, 60);\n+    case 61: return new SketchImpl<Field61>(implementation, 61);\n+    case 62: return new SketchImpl<Field62>(implementation, 62);\n+    case 63: return new SketchImpl<Field63>(implementation, 63);\n+    case 64: return new SketchImpl<Field64>(implementation, 64);\n+    default: return nullptr;\n+    }\n+}"
      },
      {
        "sha": "c98f11b14beae4d753fc7ac8c0515eaa87e61542",
        "filename": "src/minisketch/src/fields/generic_common_impl.h",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_common_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/fields/generic_common_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/fields/generic_common_impl.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,71 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_FIELDS_GENERIC_COMMON_IMPL_H_\n+#define _MINISKETCH_FIELDS_GENERIC_COMMON_IMPL_H_ 1\n+\n+#include <stdint.h>\n+#include <random>\n+\n+#include \"../int_utils.h\"\n+#include \"../lintrans.h\"\n+\n+namespace {\n+\n+/** Generic implementation for fields whose elements can be represented by an integer type. */\n+template<typename I, int B, uint32_t MOD, typename F, typename T, const F* SQR, const F* QRT> class Field\n+{\n+    typedef BitsInt<I, B> O;\n+    typedef LFSR<O, MOD> L;\n+\n+public:\n+    typedef I Elem;\n+    constexpr int Bits() const { return B; }\n+\n+    constexpr inline Elem Mul2(Elem val) const { return L::Call(val); }\n+\n+    class Multiplier\n+    {\n+        T table;\n+    public:\n+        explicit Multiplier(const Field&, Elem a) { table.template Build<L::Call>(a); }\n+        constexpr inline Elem operator()(Elem a) const { return table.template Map<O>(a); }\n+    };\n+\n+    Elem Mul(Elem a, Elem b) const { return GFMul<I, B, L, O>(a, b); }\n+\n+    /** Compute the square of a. */\n+    inline constexpr Elem Sqr(Elem a) const { return SQR->template Map<O>(a); }\n+\n+    /** Compute x such that x^2 + x = a (undefined result if no solution exists). */\n+    inline constexpr Elem Qrt(Elem a) const { return QRT->template Map<O>(a); }\n+\n+    /** Compute the inverse of x1. */\n+    Elem Inv(Elem a) const { return InvExtGCD<I, O, B, MOD>(a); }\n+\n+    /** Generate a random field element. */\n+    Elem FromSeed(uint64_t seed) const {\n+        uint64_t k0 = 0x496e744669656c64ull; // \"IntField\"\n+        uint64_t k1 = seed;\n+        uint64_t count = ((uint64_t)B) << 32;\n+        Elem ret;\n+        do {\n+            ret = O::Mask(I(SipHash(k0, k1, count++)));\n+        } while(ret == 0);\n+        return ret;\n+    }\n+\n+    Elem Deserialize(BitReader& in) const { return in.template Read<B, I>(); }\n+\n+    void Serialize(BitWriter& out, Elem val) const { out.template Write<B, I>(val); }\n+\n+    constexpr Elem FromUint64(uint64_t x) const { return O::Mask(I(x)); }\n+    constexpr uint64_t ToUint64(Elem val) const { return uint64_t(val); }\n+};\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "a2762f6a8be308fdeec128c55b2016ad7aa0512d",
        "filename": "src/minisketch/src/int_utils.h",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/int_utils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/int_utils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/int_utils.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,275 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_INT_UTILS_H_\n+#define _MINISKETCH_INT_UTILS_H_\n+\n+#include <stdlib.h>\n+\n+#include <limits>\n+#include <algorithm>\n+#include <type_traits>\n+\n+template<int bits>\n+static constexpr inline uint64_t Rot(uint64_t x) { return (x << bits) | (x >> (64 - bits)); }\n+\n+static inline void SipHashRound(uint64_t& v0, uint64_t& v1, uint64_t& v2, uint64_t& v3) {\n+    v0 += v1; v1 = Rot<13>(v1); v1 ^= v0;\n+    v0 = Rot<32>(v0);\n+    v2 += v3; v3 = Rot<16>(v3); v3 ^= v2;\n+    v0 += v3; v3 = Rot<21>(v3); v3 ^= v0;\n+    v2 += v1; v1 = Rot<17>(v1); v1 ^= v2;\n+    v2 = Rot<32>(v2);\n+}\n+\n+inline uint64_t SipHash(uint64_t k0, uint64_t k1, uint64_t data) {\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ data;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    v0 ^= data;\n+    v3 ^= 0x800000000000000ULL;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    v0 ^= 0x800000000000000ULL;\n+    v2 ^= 0xFF;\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    SipHashRound(v0, v1, v2, v3);\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}\n+\n+class BitWriter {\n+    unsigned char state = 0;\n+    int offset = 0;\n+    unsigned char* out;\n+\n+public:\n+    BitWriter(unsigned char* output) : out(output) {}\n+\n+    template<int BITS, typename I>\n+    inline void Write(I val) {\n+        int bits = BITS;\n+        if (bits + offset >= 8) {\n+            state |= ((val & ((I(1) << (8 - offset)) - 1)) << offset);\n+            *(out++) = state;\n+            val >>= (8 - offset);\n+            bits -= 8 - offset;\n+            offset = 0;\n+            state = 0;\n+        }\n+        while (bits >= 8) {\n+            *(out++) = val & 255;\n+            val >>= 8;\n+            bits -= 8;\n+        }\n+        state |= ((val & ((I(1) << bits) - 1)) << offset);\n+        offset += bits;\n+    }\n+\n+    inline void Flush() {\n+        if (offset) {\n+            *(out++) = state;\n+            state = 0;\n+            offset = 0;\n+        }\n+    }\n+};\n+\n+class BitReader {\n+    unsigned char state = 0;\n+    int offset = 0;\n+    const unsigned char* in;\n+\n+public:\n+    BitReader(const unsigned char* input) : in(input) {}\n+\n+    template<int BITS, typename I>\n+    inline I Read() {\n+        int bits = BITS;\n+        if (offset >= bits) {\n+            I ret = state & ((1 << bits) - 1);\n+            state >>= bits;\n+            offset -= bits;\n+            return ret;\n+        }\n+        I val = state;\n+        int out = offset;\n+        while (out + 8 <= bits) {\n+            val |= ((I(*(in++))) << out);\n+            out += 8;\n+        }\n+        if (out < bits) {\n+            unsigned char c = *(in++);\n+            val |= (c & ((I(1) << (bits - out)) - 1)) << out;\n+            state = c >> (bits - out);\n+            offset = 8 - (bits - out);\n+        } else {\n+            state = 0;\n+            offset = 0;\n+        }\n+        return val;\n+    }\n+};\n+\n+/** Return a value of type I with its `bits` lowest bits set (bits must be > 0). */\n+template<int BITS, typename I>\n+constexpr inline I Mask() { return ((I((I(-1)) << (std::numeric_limits<I>::digits - BITS))) >> (std::numeric_limits<I>::digits - BITS)); }\n+\n+/** Compute the smallest power of two that is larger than val. */\n+template<typename I>\n+static inline int CountBits(I val, int max) {\n+#ifdef HAVE_CLZ\n+    (void)max;\n+    if (val == 0) return 0;\n+    if (std::numeric_limits<unsigned>::digits >= std::numeric_limits<I>::digits) {\n+        return std::numeric_limits<unsigned>::digits - __builtin_clz(val);\n+    } else if (std::numeric_limits<unsigned long>::digits >= std::numeric_limits<I>::digits) {\n+        return std::numeric_limits<unsigned long>::digits - __builtin_clzl(val);\n+    } else {\n+        return std::numeric_limits<unsigned long long>::digits - __builtin_clzll(val);\n+    }\n+#else\n+    while (max && (val >> (max - 1) == 0)) --max;\n+    return max;\n+#endif\n+}\n+\n+template<typename I, int BITS>\n+class BitsInt {\n+private:\n+    static_assert(std::is_integral<I>::value && std::is_unsigned<I>::value, \"BitsInt requires an unsigned integer type\");\n+    static_assert(BITS > 0 && BITS <= std::numeric_limits<I>::digits, \"BitsInt requires 1 <= Bits <= representation type size\");\n+\n+    static constexpr I MASK = Mask<BITS, I>();\n+\n+public:\n+\n+    typedef I Repr;\n+\n+    static constexpr int SIZE = BITS;\n+\n+    static void inline Swap(I& a, I& b) {\n+        std::swap(a, b);\n+    }\n+\n+    static constexpr inline bool IsZero(I a) { return a == 0; }\n+    static constexpr inline I Mask(I val) { return val & MASK; }\n+    static constexpr inline I Shift(I val, int bits) { return ((val << bits) & MASK); }\n+    static constexpr inline I UnsafeShift(I val, int bits) { return (val << bits); }\n+\n+    template<int Offset, int Count>\n+    static constexpr inline int MidBits(I val) {\n+        static_assert(Count > 0, \"BITSInt::MidBits needs Count > 0\");\n+        static_assert(Count + Offset <= BITS, \"BitsInt::MidBits overflow of Count+Offset\");\n+        return (val >> Offset) & ((I(1) << Count) - 1);\n+    }\n+\n+    template<int Count>\n+    static constexpr inline int TopBits(I val) {\n+        static_assert(Count > 0, \"BitsInt::TopBits needs Count > 0\");\n+        static_assert(Count <= BITS, \"BitsInt::TopBits needs Offset <= BITS\");\n+        return val >> (BITS - Count);\n+    }\n+\n+    static inline constexpr I CondXorWith(I val, bool cond, I v) {\n+        return val ^ (-I(cond) & v);\n+    }\n+\n+    template<I MOD>\n+    static inline constexpr I CondXorWith(I val, bool cond) {\n+        return val ^ (-I(cond) & MOD);\n+    }\n+\n+    static inline int Bits(I val, int max) { return CountBits<I>(val, max); }\n+};\n+\n+/** Class which implements a stateless LFSR for generic moduli. */\n+template<typename F, uint32_t MOD>\n+struct LFSR {\n+    typedef typename F::Repr I;\n+    /** Shift a value `a` up once, treating it as an `N`-bit LFSR, with pattern `MOD`. */\n+    static inline constexpr I Call(const I& a) {\n+        return F::template CondXorWith<MOD>(F::Shift(a, 1), F::template TopBits<1>(a));\n+    }\n+};\n+\n+/** Helper class for carryless multiplications. */\n+template<typename I, int N, typename L, typename F, int K> struct GFMulHelper;\n+template<typename I, int N, typename L, typename F> struct GFMulHelper<I, N, L, F, 0>\n+{\n+    static inline constexpr I Run(const I& a, const I& b) { return I(0); }\n+};\n+template<typename I, int N, typename L, typename F, int K> struct GFMulHelper\n+{\n+    static inline constexpr I Run(const I& a, const I& b) { return F::CondXorWith(GFMulHelper<I, N, L, F, K - 1>::Run(L::Call(a), b), F::template MidBits<N - K, 1>(b), a); }\n+};\n+\n+/** Compute the carry-less multiplication of a and b, with N bits, using L as LFSR type. */\n+template<typename I, int N, typename L, typename F> inline constexpr I GFMul(const I& a, const I& b) { return GFMulHelper<I, N, L, F, N>::Run(a, b); }\n+\n+/** Compute the inverse of x using an extgcd algorithm. */\n+template<typename I, typename F, int BITS, uint32_t MOD>\n+inline I InvExtGCD(I x)\n+{\n+    if (F::IsZero(x)) return x;\n+    I t(0), newt(1);\n+    I r(MOD), newr = x;\n+    int rlen = BITS + 1, newrlen = F::Bits(newr, BITS);\n+    while (newr) {\n+        int q = rlen - newrlen;\n+        r ^= F::Shift(newr, q);\n+        t ^= F::UnsafeShift(newt, q);\n+        rlen = F::Bits(r, rlen - 1);\n+        if (r < newr) {\n+            F::Swap(t, newt);\n+            F::Swap(r, newr);\n+            std::swap(rlen, newrlen);\n+        }\n+    }\n+    return t;\n+}\n+\n+/** Compute the inverse of x1 using an exponentiation ladder.\n+ *\n+ * The `MUL` argument is a multiplication function, `SQR` is a squaring function, and the `SQRi` arguments\n+ * compute x**(2**i).\n+ */\n+template<typename I, typename F, int BITS, I (*MUL)(I, I), I (*SQR)(I), I (*SQR2)(I), I(*SQR4)(I), I(*SQR8)(I), I(*SQR16)(I)>\n+inline I InvLadder(I x1)\n+{\n+    static constexpr int INV_EXP = BITS - 1;\n+    I x2 = (INV_EXP >= 2) ? MUL(SQR(x1), x1) : I();\n+    I x4 = (INV_EXP >= 4) ? MUL(SQR2(x2), x2) : I();\n+    I x8 = (INV_EXP >= 8) ? MUL(SQR4(x4), x4) : I();\n+    I x16 = (INV_EXP >= 16) ? MUL(SQR8(x8), x8) : I();\n+    I x32 = (INV_EXP >= 32) ? MUL(SQR16(x16), x16) : I();\n+    I r;\n+    if (INV_EXP >= 32) {\n+        r = x32;\n+    } else if (INV_EXP >= 16) {\n+        r = x16;\n+    } else if (INV_EXP >= 8) {\n+        r = x8;\n+    } else if (INV_EXP >= 4) {\n+        r = x4;\n+    } else if (INV_EXP >= 2) {\n+        r = x2;\n+    } else {\n+        r = x1;\n+    }\n+    if (INV_EXP >= 32 && (INV_EXP & 16)) r = MUL(SQR16(r), x16);\n+    if (INV_EXP >= 16 && (INV_EXP & 8)) r = MUL(SQR8(r), x8);\n+    if (INV_EXP >= 8 && (INV_EXP & 4)) r = MUL(SQR4(r), x4);\n+    if (INV_EXP >= 4 && (INV_EXP & 2)) r = MUL(SQR2(r), x2);\n+    if (INV_EXP >= 2 && (INV_EXP & 1)) r = MUL(SQR(r), x1);\n+    return SQR(r);\n+}\n+\n+#endif"
      },
      {
        "sha": "b9d8ea8e1da3cb949571d62ff32d06ce97ce617e",
        "filename": "src/minisketch/src/lintrans.h",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/lintrans.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/lintrans.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/lintrans.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,150 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_LINTRANS_H_\n+#define _MINISKETCH_LINTRANS_H_\n+\n+#include \"int_utils.h\"\n+\n+/** A type to represent integers in the type system. */\n+template<int N> struct Num {};\n+\n+/** A Linear N-bit transformation over the field I. */\n+template<typename I, int N> class LinTrans {\n+private:\n+    I table[1 << N];\n+public:\n+    LinTrans() = default;\n+\n+    /* Construct a transformation over 3 to 8 bits, using the images of each bit. */\n+    constexpr LinTrans(I a, I b) : table{I(0), I(a), I(b), I(a ^ b)} {}\n+    constexpr LinTrans(I a, I b, I c) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c)} {}\n+    constexpr LinTrans(I a, I b, I c, I d) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f, I g) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f), I(g), I(a ^ g), I(b ^ g), I(a ^ b ^ g), I(c ^ g), I(a ^ c ^ g), I(b ^ c ^ g), I(a ^ b ^ c ^ g), I(d ^ g), I(a ^ d ^ g), I(b ^ d ^ g), I(a ^ b ^ d ^ g), I(c ^ d ^ g), I(a ^ c ^ d ^ g), I(b ^ c ^ d ^ g), I(a ^ b ^ c ^ d ^ g), I(e ^ g), I(a ^ e ^ g), I(b ^ e ^ g), I(a ^ b ^ e ^ g), I(c ^ e ^ g), I(a ^ c ^ e ^ g), I(b ^ c ^ e ^ g), I(a ^ b ^ c ^ e ^ g), I(d ^ e ^ g), I(a ^ d ^ e ^ g), I(b ^ d ^ e ^ g), I(a ^ b ^ d ^ e ^ g), I(c ^ d ^ e ^ g), I(a ^ c ^ d ^ e ^ g), I(b ^ c ^ d ^ e ^ g), I(a ^ b ^ c ^ d ^ e ^ g), I(f ^ g), I(a ^ f ^ g), I(b^ f ^ g), I(a ^ b ^ f ^ g), I(c^ f ^ g), I(a ^ c ^ f ^ g), I(b ^ c ^ f ^ g), I(a ^ b ^ c ^ f ^ g), I(d ^ f ^ g), I(a ^ d ^ f ^ g), I(b ^ d ^ f ^ g), I(a ^ b ^ d ^ f ^ g), I(c ^ d ^ f ^ g), I(a ^ c ^ d ^ f ^ g), I(b ^ c ^ d ^ f ^ g), I(a ^ b ^ c ^ d ^ f ^ g), I(e ^ f ^ g), I(a ^ e ^ f ^ g), I(b ^ e ^ f ^ g), I(a ^ b ^ e ^ f ^ g), I(c ^ e ^ f ^ g), I(a ^ c ^ e ^ f ^ g), I(b ^ c ^ e ^ f ^ g), I(a ^ b ^ c ^ e ^ f ^ g), I(d ^ e ^ f ^ g), I(a ^ d ^ e ^ f ^ g), I(b ^ d ^ e ^ f ^ g), I(a ^ b ^ d ^ e ^ f ^ g), I(c ^ d ^ e ^ f ^ g), I(a ^ c ^ d ^ e ^ f ^ g), I(b ^ c ^ d ^ e ^ f ^ g), I(a ^ b ^ c ^ d ^ e ^ f ^ g)} {}\n+    constexpr LinTrans(I a, I b, I c, I d, I e, I f, I g, I h) : table{I(0), I(a), I(b), I(a ^ b), I(c), I(a ^ c), I(b ^ c), I(a ^ b ^ c), I(d), I(a ^ d), I(b ^ d), I(a ^ b ^ d), I(c ^ d), I(a ^ c ^ d), I(b ^ c ^ d), I(a ^ b ^ c ^ d), I(e), I(a ^ e), I(b ^ e), I(a ^ b ^ e), I(c ^ e), I(a ^ c ^ e), I(b ^ c ^ e), I(a ^ b ^ c ^ e), I(d ^ e), I(a ^ d ^ e), I(b ^ d ^ e), I(a ^ b ^ d ^ e), I(c ^ d ^ e), I(a ^ c ^ d ^ e), I(b ^ c ^ d ^ e), I(a ^ b ^ c ^ d ^ e), I(f), I(a ^ f), I(b^ f), I(a ^ b ^ f), I(c^ f), I(a ^ c ^ f), I(b ^ c ^ f), I(a ^ b ^ c ^ f), I(d ^ f), I(a ^ d ^ f), I(b ^ d ^ f), I(a ^ b ^ d ^ f), I(c ^ d ^ f), I(a ^ c ^ d ^ f), I(b ^ c ^ d ^ f), I(a ^ b ^ c ^ d ^ f), I(e ^ f), I(a ^ e ^ f), I(b ^ e ^ f), I(a ^ b ^ e ^ f), I(c ^ e ^ f), I(a ^ c ^ e ^ f), I(b ^ c ^ e ^ f), I(a ^ b ^ c ^ e ^ f), I(d ^ e ^ f), I(a ^ d ^ e ^ f), I(b ^ d ^ e ^ f), I(a ^ b ^ d ^ e ^ f), I(c ^ d ^ e ^ f), I(a ^ c ^ d ^ e ^ f), I(b ^ c ^ d ^ e ^ f), I(a ^ b ^ c ^ d ^ e ^ f), I(g), I(a ^ g), I(b ^ g), I(a ^ b ^ g), I(c ^ g), I(a ^ c ^ g), I(b ^ c ^ g), I(a ^ b ^ c ^ g), I(d ^ g), I(a ^ d ^ g), I(b ^ d ^ g), I(a ^ b ^ d ^ g), I(c ^ d ^ g), I(a ^ c ^ d ^ g), I(b ^ c ^ d ^ g), I(a ^ b ^ c ^ d ^ g), I(e ^ g), I(a ^ e ^ g), I(b ^ e ^ g), I(a ^ b ^ e ^ g), I(c ^ e ^ g), I(a ^ c ^ e ^ g), I(b ^ c ^ e ^ g), I(a ^ b ^ c ^ e ^ g), I(d ^ e ^ g), I(a ^ d ^ e ^ g), I(b ^ d ^ e ^ g), I(a ^ b ^ d ^ e ^ g), I(c ^ d ^ e ^ g), I(a ^ c ^ d ^ e ^ g), I(b ^ c ^ d ^ e ^ g), I(a ^ b ^ c ^ d ^ e ^ g), I(f ^ g), I(a ^ f ^ g), I(b^ f ^ g), I(a ^ b ^ f ^ g), I(c^ f ^ g), I(a ^ c ^ f ^ g), I(b ^ c ^ f ^ g), I(a ^ b ^ c ^ f ^ g), I(d ^ f ^ g), I(a ^ d ^ f ^ g), I(b ^ d ^ f ^ g), I(a ^ b ^ d ^ f ^ g), I(c ^ d ^ f ^ g), I(a ^ c ^ d ^ f ^ g), I(b ^ c ^ d ^ f ^ g), I(a ^ b ^ c ^ d ^ f ^ g), I(e ^ f ^ g), I(a ^ e ^ f ^ g), I(b ^ e ^ f ^ g), I(a ^ b ^ e ^ f ^ g), I(c ^ e ^ f ^ g), I(a ^ c ^ e ^ f ^ g), I(b ^ c ^ e ^ f ^ g), I(a ^ b ^ c ^ e ^ f ^ g), I(d ^ e ^ f ^ g), I(a ^ d ^ e ^ f ^ g), I(b ^ d ^ e ^ f ^ g), I(a ^ b ^ d ^ e ^ f ^ g), I(c ^ d ^ e ^ f ^ g), I(a ^ c ^ d ^ e ^ f ^ g), I(b ^ c ^ d ^ e ^ f ^ g), I(a ^ b ^ c ^ d ^ e ^ f ^ g), I(h), I(a ^ h), I(b ^ h), I(a ^ b ^ h), I(c ^ h), I(a ^ c ^ h), I(b ^ c ^ h), I(a ^ b ^ c ^ h), I(d ^ h), I(a ^ d ^ h), I(b ^ d ^ h), I(a ^ b ^ d ^ h), I(c ^ d ^ h), I(a ^ c ^ d ^ h), I(b ^ c ^ d ^ h), I(a ^ b ^ c ^ d ^ h), I(e ^ h), I(a ^ e ^ h), I(b ^ e ^ h), I(a ^ b ^ e ^ h), I(c ^ e ^ h), I(a ^ c ^ e ^ h), I(b ^ c ^ e ^ h), I(a ^ b ^ c ^ e ^ h), I(d ^ e ^ h), I(a ^ d ^ e ^ h), I(b ^ d ^ e ^ h), I(a ^ b ^ d ^ e ^ h), I(c ^ d ^ e ^ h), I(a ^ c ^ d ^ e ^ h), I(b ^ c ^ d ^ e ^ h), I(a ^ b ^ c ^ d ^ e ^ h), I(f ^ h), I(a ^ f ^ h), I(b^ f ^ h), I(a ^ b ^ f ^ h), I(c^ f ^ h), I(a ^ c ^ f ^ h), I(b ^ c ^ f ^ h), I(a ^ b ^ c ^ f ^ h), I(d ^ f ^ h), I(a ^ d ^ f ^ h), I(b ^ d ^ f ^ h), I(a ^ b ^ d ^ f ^ h), I(c ^ d ^ f ^ h), I(a ^ c ^ d ^ f ^ h), I(b ^ c ^ d ^ f ^ h), I(a ^ b ^ c ^ d ^ f ^ h), I(e ^ f ^ h), I(a ^ e ^ f ^ h), I(b ^ e ^ f ^ h), I(a ^ b ^ e ^ f ^ h), I(c ^ e ^ f ^ h), I(a ^ c ^ e ^ f ^ h), I(b ^ c ^ e ^ f ^ h), I(a ^ b ^ c ^ e ^ f ^ h), I(d ^ e ^ f ^ h), I(a ^ d ^ e ^ f ^ h), I(b ^ d ^ e ^ f ^ h), I(a ^ b ^ d ^ e ^ f ^ h), I(c ^ d ^ e ^ f ^ h), I(a ^ c ^ d ^ e ^ f ^ h), I(b ^ c ^ d ^ e ^ f ^ h), I(a ^ b ^ c ^ d ^ e ^ f ^ h), I(g ^ h), I(a ^ g ^ h), I(b ^ g ^ h), I(a ^ b ^ g ^ h), I(c ^ g ^ h), I(a ^ c ^ g ^ h), I(b ^ c ^ g ^ h), I(a ^ b ^ c ^ g ^ h), I(d ^ g ^ h), I(a ^ d ^ g ^ h), I(b ^ d ^ g ^ h), I(a ^ b ^ d ^ g ^ h), I(c ^ d ^ g ^ h), I(a ^ c ^ d ^ g ^ h), I(b ^ c ^ d ^ g ^ h), I(a ^ b ^ c ^ d ^ g ^ h), I(e ^ g ^ h), I(a ^ e ^ g ^ h), I(b ^ e ^ g ^ h), I(a ^ b ^ e ^ g ^ h), I(c ^ e ^ g ^ h), I(a ^ c ^ e ^ g ^ h), I(b ^ c ^ e ^ g ^ h), I(a ^ b ^ c ^ e ^ g ^ h), I(d ^ e ^ g ^ h), I(a ^ d ^ e ^ g ^ h), I(b ^ d ^ e ^ g ^ h), I(a ^ b ^ d ^ e ^ g ^ h), I(c ^ d ^ e ^ g ^ h), I(a ^ c ^ d ^ e ^ g ^ h), I(b ^ c ^ d ^ e ^ g ^ h), I(a ^ b ^ c ^ d ^ e ^ g ^ h), I(f ^ g ^ h), I(a ^ f ^ g ^ h), I(b^ f ^ g ^ h), I(a ^ b ^ f ^ g ^ h), I(c^ f ^ g ^ h), I(a ^ c ^ f ^ g ^ h), I(b ^ c ^ f ^ g ^ h), I(a ^ b ^ c ^ f ^ g ^ h), I(d ^ f ^ g ^ h), I(a ^ d ^ f ^ g ^ h), I(b ^ d ^ f ^ g ^ h), I(a ^ b ^ d ^ f ^ g ^ h), I(c ^ d ^ f ^ g ^ h), I(a ^ c ^ d ^ f ^ g ^ h), I(b ^ c ^ d ^ f ^ g ^ h), I(a ^ b ^ c ^ d ^ f ^ g ^ h), I(e ^ f ^ g ^ h), I(a ^ e ^ f ^ g ^ h), I(b ^ e ^ f ^ g ^ h), I(a ^ b ^ e ^ f ^ g ^ h), I(c ^ e ^ f ^ g ^ h), I(a ^ c ^ e ^ f ^ g ^ h), I(b ^ c ^ e ^ f ^ g ^ h), I(a ^ b ^ c ^ e ^ f ^ g ^ h), I(d ^ e ^ f ^ g ^ h), I(a ^ d ^ e ^ f ^ g ^ h), I(b ^ d ^ e ^ f ^ g ^ h), I(a ^ b ^ d ^ e ^ f ^ g ^ h), I(c ^ d ^ e ^ f ^ g ^ h), I(a ^ c ^ d ^ e ^ f ^ g ^ h), I(b ^ c ^ d ^ e ^ f ^ g ^ h), I(a ^ b ^ c ^ d ^ e ^ f ^ g ^ h)} {}\n+\n+    /* Construct a transformation over 3 to 8 bits, using a pointer to the bit's images. */\n+    constexpr LinTrans(const I* p, Num<2>) : LinTrans(I(p[0]), I(p[1])) {}\n+    constexpr LinTrans(const I* p, Num<3>) : LinTrans(I(p[0]), I(p[1]), I(p[2])) {}\n+    constexpr LinTrans(const I* p, Num<4>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3])) {}\n+    constexpr LinTrans(const I* p, Num<5>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4])) {}\n+    constexpr LinTrans(const I* p, Num<6>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5])) {}\n+    constexpr LinTrans(const I* p, Num<7>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5]), I(p[6])) {}\n+    constexpr LinTrans(const I* p, Num<8>) : LinTrans(I(p[0]), I(p[1]), I(p[2]), I(p[3]), I(p[4]), I(p[5]), I(p[6]), I(p[7])) {}\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<1>, I a)\n+    {\n+        table[0] = I(); table[1] = a;\n+        return a;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<2>, I a)\n+    {\n+        I b = F(a);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b;\n+        return b;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<3>, I a)\n+    {\n+        I b = F(a), c = F(b);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        return c;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<4>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        return d;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<5>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c), e = F(d);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        table[16] = e; table[17] = a ^ e; table[18] = b ^ e; table[19] = a ^ b ^ e; table[20] = c ^ e; table[21] = a ^ c ^ e; table[22] = b ^ c ^ e; table[23] = a ^ b ^ c ^ e;\n+        table[24] = d ^ e; table[25] = a ^ d ^ e; table[26] = b ^ d ^ e; table[27] = a ^ b ^ d ^ e; table[28] = c ^ d ^ e; table[29] = a ^ c ^ d ^ e; table[30] = b ^ c ^ d ^ e; table[31] = a ^ b ^ c ^ d ^ e;\n+        return e;\n+    }\n+\n+    template<I (*F)(const I&)>\n+    inline I Build(Num<6>, I a)\n+    {\n+        I b = F(a), c = F(b), d = F(c), e = F(d), f = F(e);\n+        table[0] = I(); table[1] = a; table[2] = b; table[3] = a ^ b; table[4] = c; table[5] = a ^ c; table[6] = b ^ c; table[7] = a ^ b ^ c;\n+        table[8] = d; table[9] = a ^ d; table[10] = b ^ d; table[11] = a ^ b ^ d; table[12] = c ^ d; table[13] = a ^ c ^ d; table[14] = b ^ c ^ d; table[15] = a ^ b ^ c ^ d;\n+        table[16] = e; table[17] = a ^ e; table[18] = b ^ e; table[19] = a ^ b ^ e; table[20] = c ^ e; table[21] = a ^ c ^ e; table[22] = b ^ c ^ e; table[23] = a ^ b ^ c ^ e;\n+        table[24] = d ^ e; table[25] = a ^ d ^ e; table[26] = b ^ d ^ e; table[27] = a ^ b ^ d ^ e; table[28] = c ^ d ^ e; table[29] = a ^ c ^ d ^ e; table[30] = b ^ c ^ d ^ e; table[31] = a ^ b ^ c ^ d ^ e;\n+        table[32] = f; table[33] = a ^ f; table[34] = b ^ f; table[35] = a ^ b ^ f; table[36] = c ^ f; table[37] = a ^ c ^ f; table[38] = b ^ c ^ f; table[39] = a ^ b ^ c ^ f;\n+        table[40] = d ^ f; table[41] = a ^ d ^ f; table[42] = b ^ d ^ f; table[43] = a ^ b ^ d ^ f; table[44] = c ^ d ^ f; table[45] = a ^ c ^ d ^ f; table[46] = b ^ c ^ d ^ f; table[47] = a ^ b ^ c ^ d ^ f;\n+        table[48] = e ^ f; table[49] = a ^ e ^ f; table[50] = b ^ e ^ f; table[51] = a ^ b ^ e ^ f; table[52] = c ^ e ^ f; table[53] = a ^ c ^ e ^ f; table[54] = b ^ c ^ e ^ f; table[55] = a ^ b ^ c ^ e ^ f;\n+        table[56] = d ^ e ^ f; table[57] = a ^ d ^ e ^ f; table[58] = b ^ d ^ e ^ f; table[59] = a ^ b ^ d ^ e ^ f; table[60] = c ^ d ^ e ^ f; table[61] = a ^ c ^ d ^ e ^ f; table[62] = b ^ c ^ d ^ e ^ f; table[63] = a ^ b ^ c ^ d ^ e ^ f;\n+        return f;\n+    }\n+\n+    template<typename O, int P>\n+    inline I constexpr Map(I a) const { return table[O::template MidBits<P, N>(a)]; }\n+\n+    template<typename O, int P>\n+    inline I constexpr TopMap(I a) const { static_assert(P + N == O::SIZE, \"TopMap inconsistency\"); return table[O::template TopBits<N>(a)]; }\n+};\n+\n+\n+/** A linear transformation constructed using LinTrans tables for sections of bits. */\n+template<typename I, int... N> class RecLinTrans;\n+\n+template<typename I, int N> class RecLinTrans<I, N> {\n+    LinTrans<I, N> trans;\n+public:\n+    static constexpr int BITS = N;\n+    constexpr RecLinTrans(const I* p, Num<BITS>) : trans(p, Num<N>()) {}\n+    constexpr RecLinTrans() = default;\n+    constexpr RecLinTrans(const I (&init)[BITS]) : RecLinTrans(init, Num<BITS>()) {}\n+\n+    template<typename O, int P = 0>\n+    inline I constexpr Map(I a) const { return trans.template TopMap<O, P>(a); }\n+\n+    template<I (*F)(const I&)>\n+    inline void Build(I a) { trans.template Build<F>(Num<N>(), a); }\n+};\n+\n+template<typename I, int N, int... X> class RecLinTrans<I, N, X...> {\n+    LinTrans<I, N> trans;\n+    RecLinTrans<I, X...> rec;\n+public:\n+    static constexpr int BITS = RecLinTrans<I, X...>::BITS + N;\n+    constexpr RecLinTrans(const I* p, Num<BITS>) : trans(p, Num<N>()), rec(p + N, Num<BITS - N>()) {}\n+    constexpr RecLinTrans() = default;\n+    constexpr RecLinTrans(const I (&init)[BITS]) : RecLinTrans(init, Num<BITS>()) {}\n+\n+    template<typename O, int P = 0>\n+    inline I constexpr Map(I a) const { return trans.template Map<O, P>(a) ^ rec.template Map<O, P + N>(a); }\n+\n+    template<I (*F)(const I&)>\n+    inline void Build(I a) { I n = trans.template Build<F>(Num<N>(), a); rec.template Build<F>(F(n)); }\n+};\n+\n+/** The identity transformation. */\n+class IdTrans {\n+public:\n+    template<typename O, typename I>\n+    inline I constexpr Map(I a) const { return a; }\n+};\n+\n+/** A singleton for the identity transformation. */\n+constexpr IdTrans ID_TRANS{};\n+\n+#endif"
      },
      {
        "sha": "e04cba89d9524d9d3b9accf5da73e8c6f1c7f314",
        "filename": "src/minisketch/src/minisketch.cpp",
        "status": "added",
        "additions": 263,
        "deletions": 0,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/minisketch.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/minisketch.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/minisketch.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,263 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <new>\n+\n+#include \"../include/minisketch.h\"\n+\n+#include \"false_positives.h\"\n+#include \"sketch.h\"\n+\n+#ifdef HAVE_CLMUL\n+#include <cpuid.h>\n+#endif\n+\n+Sketch* ConstructGeneric1Byte(int bits, int implementation);\n+Sketch* ConstructGeneric2Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric3Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric4Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric5Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric6Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric7Bytes(int bits, int implementation);\n+Sketch* ConstructGeneric8Bytes(int bits, int implementation);\n+\n+#ifdef HAVE_CLMUL\n+Sketch* ConstructClMul1Byte(int bits, int implementation);\n+Sketch* ConstructClMul2Bytes(int bits, int implementation);\n+Sketch* ConstructClMul3Bytes(int bits, int implementation);\n+Sketch* ConstructClMul4Bytes(int bits, int implementation);\n+Sketch* ConstructClMul5Bytes(int bits, int implementation);\n+Sketch* ConstructClMul6Bytes(int bits, int implementation);\n+Sketch* ConstructClMul7Bytes(int bits, int implementation);\n+Sketch* ConstructClMul8Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri1Byte(int bits, int implementation);\n+Sketch* ConstructClMulTri2Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri3Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri4Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri5Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri6Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri7Bytes(int bits, int implementation);\n+Sketch* ConstructClMulTri8Bytes(int bits, int implementation);\n+#endif\n+\n+namespace {\n+\n+enum class FieldImpl {\n+    GENERIC = 0,\n+#ifdef HAVE_CLMUL\n+    CLMUL,\n+    CLMUL_TRI,\n+#endif\n+};\n+\n+Sketch* Construct(int bits, int impl)\n+{\n+    switch (FieldImpl(impl)) {\n+    case FieldImpl::GENERIC:\n+        switch ((bits + 7) / 8) {\n+        case 1:\n+            return ConstructGeneric1Byte(bits, impl);\n+        case 2:\n+            return ConstructGeneric2Bytes(bits, impl);\n+        case 3:\n+            return ConstructGeneric3Bytes(bits, impl);\n+        case 4:\n+            return ConstructGeneric4Bytes(bits, impl);\n+        case 5:\n+            return ConstructGeneric5Bytes(bits, impl);\n+        case 6:\n+            return ConstructGeneric6Bytes(bits, impl);\n+        case 7:\n+            return ConstructGeneric7Bytes(bits, impl);\n+        case 8:\n+            return ConstructGeneric8Bytes(bits, impl);\n+        default:\n+            return nullptr;\n+        }\n+#ifdef HAVE_CLMUL\n+    case FieldImpl::CLMUL:\n+    case FieldImpl::CLMUL_TRI: {\n+        uint32_t eax, ebx, ecx, edx;\n+        if (__get_cpuid(1, &eax, &ebx, &ecx, &edx) && (ecx & 0x2)) {\n+            switch ((bits + 7) / 8) {\n+            case 1:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul1Byte(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri1Byte(bits, impl);\n+            case 2:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul2Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri2Bytes(bits, impl);\n+            case 3:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul3Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri3Bytes(bits, impl);\n+            case 4:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul4Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri4Bytes(bits, impl);\n+            case 5:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul5Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri5Bytes(bits, impl);\n+            case 6:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul6Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri6Bytes(bits, impl);\n+            case 7:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul7Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri7Bytes(bits, impl);\n+            case 8:\n+                if (FieldImpl(impl) == FieldImpl::CLMUL) return ConstructClMul8Bytes(bits, impl);\n+                if (FieldImpl(impl) == FieldImpl::CLMUL_TRI) return ConstructClMulTri8Bytes(bits, impl);\n+            default:\n+                return nullptr;\n+            }\n+        }\n+    }\n+#endif\n+    }\n+    return nullptr;\n+}\n+\n+}\n+\n+extern \"C\" {\n+\n+int minisketch_bits_supported(uint32_t bits) {\n+    return (bits >= 2) && (bits <= 64);\n+}\n+\n+uint32_t minisketch_implementation_max() {\n+    uint32_t ret = 0;\n+#ifdef HAVE_CLMUL\n+    ret += 2;\n+#endif\n+    return ret;\n+}\n+\n+int minisketch_implementation_supported(uint32_t bits, uint32_t implementation) {\n+    if (!minisketch_bits_supported(bits) || implementation > minisketch_implementation_max()) {\n+        return 0;\n+    }\n+    try {\n+        Sketch* sketch = Construct(bits, implementation);\n+        if (sketch) {\n+            delete sketch;\n+            return 1;\n+        }\n+    } catch (std::bad_alloc& ba) {}\n+    return 0;\n+}\n+\n+minisketch* minisketch_create(uint32_t bits, uint32_t implementation, size_t capacity) {\n+    if (capacity == 0) {\n+        return nullptr;\n+    }\n+    try {\n+        Sketch* sketch = Construct(bits, implementation);\n+        if (sketch) {\n+            try {\n+                sketch->Init(capacity);\n+            } catch (std::bad_alloc& ba) {\n+                delete sketch;\n+                throw;\n+            }\n+            sketch->Ready();\n+        }\n+        return (minisketch*)sketch;\n+    } catch (std::bad_alloc& ba) {\n+        return nullptr;\n+    }\n+}\n+\n+uint32_t minisketch_bits(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Bits();\n+}\n+\n+size_t minisketch_capacity(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Syndromes();\n+}\n+\n+uint32_t minisketch_implementation(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Implementation();\n+}\n+\n+minisketch* minisketch_clone(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    Sketch* r = (Sketch*) minisketch_create(s->Bits(), s->Implementation(), s->Syndromes());\n+    if (r) {\n+        r->Merge(s);\n+    }\n+    return (minisketch*) r;\n+}\n+\n+void minisketch_destroy(minisketch* sketch) {\n+    if (sketch) {\n+        Sketch* s = (Sketch*)sketch;\n+        s->UnReady();\n+        delete s;\n+    }\n+}\n+\n+size_t minisketch_serialized_size(const minisketch* sketch) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    size_t bits = s->Bits();\n+    size_t syndromes = s->Syndromes();\n+    return (bits * syndromes + 7) / 8;\n+}\n+\n+void minisketch_serialize(const minisketch* sketch, unsigned char* output) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    s->Serialize(output);\n+}\n+\n+void minisketch_deserialize(minisketch* sketch, const unsigned char* input) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->Deserialize(input);\n+}\n+\n+void minisketch_add_uint64(minisketch* sketch, uint64_t element) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->Add(element);\n+}\n+\n+size_t minisketch_merge(minisketch* sketch, const minisketch* other_sketch) {\n+    Sketch* s1 = (Sketch*)sketch;\n+    const Sketch* s2 = (const Sketch*)other_sketch;\n+    s1->Check();\n+    s2->Check();\n+    if (s1->Bits() != s2->Bits()) return 0;\n+    if (s1->Implementation() != s2->Implementation()) return 0;\n+    return s1->Merge(s2);\n+}\n+\n+ssize_t minisketch_decode(const minisketch* sketch, size_t max_elements, uint64_t* output) {\n+    const Sketch* s = (const Sketch*)sketch;\n+    s->Check();\n+    return s->Decode(max_elements, output);\n+}\n+\n+void minisketch_set_seed(minisketch* sketch, uint64_t seed) {\n+    Sketch* s = (Sketch*)sketch;\n+    s->Check();\n+    s->SetSeed(seed);\n+}\n+\n+size_t minisketch_compute_capacity(uint32_t bits, size_t max_elements, uint32_t fpbits) {\n+    return ComputeCapacity(bits, max_elements, fpbits);\n+}\n+\n+size_t minisketch_compute_max_elements(uint32_t bits, size_t capacity, uint32_t fpbits) {\n+    return ComputeMaxElements(bits, capacity, fpbits);\n+}\n+\n+}"
      },
      {
        "sha": "3e9bad793d5210f87462573786baabb104e77109",
        "filename": "src/minisketch/src/sketch.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/sketch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/sketch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/sketch.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,42 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_STATE_H_\n+#define _MINISKETCH_STATE_H_\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** Abstract class for internal representation of a minisketch object. */\n+class Sketch\n+{\n+    uint64_t m_canary;\n+    const int m_implementation;\n+    const int m_bits;\n+\n+public:\n+    Sketch(int implementation, int bits) : m_implementation(implementation), m_bits(bits) {}\n+\n+    void Ready() { m_canary = 0x6d496e536b65LU; }\n+    void Check() const { if (m_canary != 0x6d496e536b65LU) abort(); }\n+    void UnReady() { m_canary = 1; }\n+    int Implementation() const { return m_implementation; }\n+    int Bits() const { return m_bits; }\n+\n+    virtual ~Sketch() {}\n+    virtual size_t Syndromes() const = 0;\n+\n+    virtual void Init(int syndromes) = 0;\n+    virtual void Add(uint64_t element) = 0;\n+    virtual void Serialize(unsigned char*) const = 0;\n+    virtual void Deserialize(const unsigned char*) = 0;\n+    virtual size_t Merge(const Sketch* other_sketch) = 0;\n+    virtual void SetSeed(uint64_t seed) = 0;\n+\n+    virtual int Decode(int max_count, uint64_t* roots) const = 0;\n+};\n+\n+#endif"
      },
      {
        "sha": "e4392da1cd596fc8899aad497def7f76209604f2",
        "filename": "src/minisketch/src/sketch_impl.h",
        "status": "added",
        "additions": 432,
        "deletions": 0,
        "changes": 432,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/sketch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/sketch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/sketch_impl.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,432 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_SKETCH_IMPL_H_\n+#define _MINISKETCH_SKETCH_IMPL_H_\n+\n+#include <random>\n+\n+#include \"util.h\"\n+#include \"sketch.h\"\n+#include \"int_utils.h\"\n+\n+/** Compute the remainder of a polynomial division of val by mod, putting the result in mod. */\n+template<typename F>\n+void PolyMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& val, const F& field) {\n+    size_t modsize = mod.size();\n+    CHECK_SAFE(modsize > 0 && mod.back() == 1);\n+    if (val.size() < modsize) return;\n+    CHECK_SAFE(val.back() != 0);\n+    while (val.size() >= modsize) {\n+        auto term = val.back();\n+        val.pop_back();\n+        if (term != 0) {\n+            typename F::Multiplier mul(field, term);\n+            for (size_t x = 0; x < mod.size() - 1; ++x) {\n+                val[val.size() - modsize + 1 + x] ^= mul(mod[x]);\n+            }\n+        }\n+    }\n+    while (val.size() > 0 && val.back() == 0) val.pop_back();\n+}\n+\n+/** Compute the quotient of a polynomial division of val by mod, putting the quotient in div and the remainder in val. */\n+template<typename F>\n+void DivMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& val, std::vector<typename F::Elem>& div, const F& field) {\n+    size_t modsize = mod.size();\n+    CHECK_SAFE(mod.size() > 0 && mod.back() == 1);\n+    if (val.size() < mod.size()) {\n+        div.clear();\n+        return;\n+    }\n+    CHECK_SAFE(val.back() != 0);\n+    div.resize(val.size() - mod.size() + 1);\n+    while (val.size() >= modsize) {\n+        auto term = val.back();\n+        div[val.size() - modsize] = term;\n+        val.pop_back();\n+        if (term != 0) {\n+            typename F::Multiplier mul(field, term);\n+            for (size_t x = 0; x < mod.size() - 1; ++x) {\n+                val[val.size() - modsize + 1 + x] ^= mul(mod[x]);\n+            }\n+        }\n+    }\n+}\n+\n+/** Make a polynomial monic. */\n+template<typename F>\n+typename F::Elem MakeMonic(std::vector<typename F::Elem>& a, const F& field) {\n+    CHECK_SAFE(a.back() != 0);\n+    if (a.back() == 1) return 0;\n+    auto inv = field.Inv(a.back());\n+    typename F::Multiplier mul(field, inv);\n+    a.back() = 1;\n+    for (size_t i = 0; i < a.size() - 1; ++i) {\n+        a[i] = mul(a[i]);\n+    }\n+    return inv;\n+}\n+\n+/** Compute the GCD of two polynomials, putting the result in a. b will be cleared. */\n+template<typename F>\n+void GCD(std::vector<typename F::Elem>& a, std::vector<typename F::Elem>& b, const F& field) {\n+    if (a.size() < b.size()) std::swap(a, b);\n+    while (b.size() > 0) {\n+        if (b.size() == 1) {\n+            a.resize(1);\n+            a[0] = 1;\n+            return;\n+        }\n+        MakeMonic(b, field);\n+        PolyMod(b, a, field);\n+        std::swap(a, b);\n+    }\n+}\n+\n+/** Square a polynomial. */\n+template<typename F>\n+void Sqr(std::vector<typename F::Elem>& poly, const F& field) {\n+    if (poly.size() == 0) return;\n+    poly.resize(poly.size() * 2 - 1);\n+    for (int x = poly.size() - 1; x >= 0; --x) {\n+        poly[x] = (x & 1) ? 0 : field.Sqr(poly[x / 2]);\n+    }\n+}\n+\n+/** Compute the trace map of (param*x) modulo mod, putting the result in out. */\n+template<typename F>\n+void TraceMod(const std::vector<typename F::Elem>& mod, std::vector<typename F::Elem>& out, const typename F::Elem& param, const F& field) {\n+    out.reserve(mod.size() * 2);\n+    out.resize(2);\n+    out[0] = 0;\n+    out[1] = param;\n+\n+    for (int i = 0; i < field.Bits() - 1; ++i) {\n+        Sqr(out, field);\n+        if (out.size() < 2) out.resize(2);\n+        out[1] = param;\n+        PolyMod(mod, out, field);\n+    }\n+}\n+\n+/** One step of the root finding algorithm; finds roots of stack[pos] and adds them to roots. Stack elements >= pos are destroyed.\n+ *\n+ * It operates on a stack of polynomials. The polynomial operated on is `stack[pos]`, where elements of `stack` with index higher\n+ * than `pos` are used as scratch space.\n+ *\n+ * `stack[pos]` is assumed to be square-free polynomial. If `fully_factorizable` is true, it is also assumed to have no irreducible\n+ * factors of degree higher than 1.\n+\n+ * This implements the Berlekamp trace algorithm, plus an efficient test to fail fast in\n+ * case the polynomial cannot be fully factored.\n+ */\n+template<typename F>\n+bool RecFindRoots(std::vector<std::vector<typename F::Elem>>& stack, size_t pos, std::vector<typename F::Elem>& roots, bool fully_factorizable, int depth, typename F::Elem randv, const F& field) {\n+    auto& ppoly = stack[pos];\n+    // We assert ppoly.size() > 1 (instead of just ppoly.size() > 0) to additionally exclude\n+    // constants polynomials because\n+    //  - ppoly is not constant initially (this is ensured by FindRoots()), and\n+    //  - we never recurse on a constant polynomial.\n+    CHECK_SAFE(ppoly.size() > 1 && ppoly.back() == 1);\n+    /* 1st degree input: constant term is the root. */\n+    if (ppoly.size() == 2) {\n+        roots.push_back(ppoly[0]);\n+        return true;\n+    }\n+    /* 2nd degree input: use direct quadratic solver. */\n+    if (ppoly.size() == 3) {\n+        CHECK_RETURN(ppoly[1] != 0, false); // Equations of the form (x^2 + a) have two identical solutions; contradicts square-free assumption. */\n+        auto input = field.Mul(ppoly[0], field.Sqr(field.Inv(ppoly[1])));\n+        auto root = field.Qrt(input);\n+        if ((field.Sqr(root) ^ root) != input) {\n+            CHECK_SAFE(!fully_factorizable);\n+            return false; // No root found.\n+        }\n+        auto sol = field.Mul(root, ppoly[1]);\n+        roots.push_back(sol);\n+        roots.push_back(sol ^ ppoly[1]);\n+        return true;\n+    }\n+    /* 3rd degree input and more: recurse further. */\n+    if (pos + 3 > stack.size()) {\n+        // Allocate memory if necessary.\n+        stack.resize((pos + 3) * 2);\n+    }\n+    auto& poly = stack[pos];\n+    auto& tmp = stack[pos + 1];\n+    auto& trace = stack[pos + 2];\n+    trace.clear();\n+    tmp.clear();\n+    for (int iter = 0;; ++iter) {\n+        // Compute the polynomial (trace(x*randv) mod poly(x)) symbolically,\n+        // and put the result in `trace`.\n+        TraceMod(poly, trace, randv, field);\n+\n+        if (iter >= 1 && !fully_factorizable) {\n+            // If the polynomial cannot be factorized completely (it has an\n+            // irreducible factor of degree higher than 1), we want to avoid\n+            // the case where this is only detected after trying all BITS\n+            // independent split attempts fail (see the assert below).\n+            //\n+            // Observe that if we call y = randv*x, it is true that:\n+            //\n+            //   trace = y + y^2 + y^4 + y^8 + ... y^(FIELDSIZE/2) mod poly\n+            //\n+            // Due to the Frobenius endomorphism, this means:\n+            //\n+            //   trace^2 = y^2 + y^4 + y^8 + ... + y^FIELDSIZE mod poly\n+            //\n+            // Or, adding them up:\n+            //\n+            //   trace + trace^2 = y + y^FIELDSIZE mod poly.\n+            //                   = randv*x + randv^FIELDSIZE*x^FIELDSIZE\n+            //                   = randv*x + randv*x^FIELDSIZE\n+            //                   = randv*(x + x^FIELDSIZE).\n+            //     (all mod poly)\n+            //\n+            // x + x^FIELDSIZE is the polynomial which has every field element\n+            // as root once. Whenever x + x^FIELDSIZE is multiple of poly,\n+            // this means it only has unique first degree factors. The same\n+            // holds for its constant multiple randv*(x + x^FIELDSIZE) =\n+            // trace + trace^2.\n+            //\n+            // We use this test to quickly verify whether the polynomial is\n+            // fully factorizable after already having computed a trace.\n+            // We don't invoke it immediately; only when splitting has failed\n+            // at least once, which avoids it for most polynomials that are\n+            // fully factorizable (or at least pushes the test down the\n+            // recursion to factors which are smaller and thus faster).\n+            tmp = trace;\n+            Sqr(tmp, field);\n+            for (size_t i = 0; i < trace.size(); ++i) {\n+                tmp[i] ^= trace[i];\n+            }\n+            while (tmp.size() && tmp.back() == 0) tmp.pop_back();\n+            PolyMod(poly, tmp, field);\n+\n+            // Whenever the test fails, we can immediately abort the root\n+            // finding. Whenever it succeeds, we can remember and pass down\n+            // the information that it is in fact fully factorizable, avoiding\n+            // the need to run the test again.\n+            if (tmp.size() != 0) return false;\n+            fully_factorizable = true;\n+        }\n+\n+        if (fully_factorizable) {\n+            // Every succesful iteration of this algorithm splits the input\n+            // polynomial further into buckets, each corresponding to a subset\n+            // of 2^(BITS-depth) roots. If after depth splits the degree of\n+            // the polynomial is >= 2^(BITS-depth), something is wrong.\n+            CHECK_RETURN((poly.size() - 2) >> (field.Bits() - depth) == 0, false);\n+        }\n+\n+        depth++;\n+        // In every iteration we multiply randv by 2. As a result, the set\n+        // of randv values forms a GF(2)-linearly independent basis of splits.\n+        randv = field.Mul2(randv);\n+        tmp = poly;\n+        GCD(trace, tmp, field);\n+        if (trace.size() != poly.size() && trace.size() > 1) break;\n+    }\n+    MakeMonic(trace, field);\n+    DivMod(trace, poly, tmp, field);\n+    // At this point, the stack looks like [... (poly) tmp trace], and we want to recursively\n+    // find roots of trace and tmp (= poly/trace). As we don't care about poly anymore, move\n+    // trace into its position first.\n+    std::swap(poly, trace);\n+    // Now the stack is [... (trace) tmp ...]. First we factor tmp (at pos = pos+1), and then\n+    // we factor trace (at pos = pos).\n+    if (!RecFindRoots(stack, pos + 1, roots, fully_factorizable, depth, randv, field)) return false;\n+    // The stack position pos contains trace, the polynomial with all of poly's roots which (after\n+    // multiplication with randv) have trace 0. This is never the case for irreducible factors\n+    // (which always end up in tmp), so we can set fully_factorizable to true when recursing.\n+    bool ret = RecFindRoots(stack, pos, roots, true, depth, randv, field);\n+    // Because of the above, recursion can never fail here.\n+    CHECK_SAFE(ret);\n+    return ret;\n+}\n+\n+/** Returns the roots of a fully factorizable polynomial\n+ *\n+ * This function assumes that the input polynomial is square-free\n+ * and not the zero polynomial (represented by an empty vector).\n+ *\n+ * In case the square-free polynomial is not fully factorizable, i.e., it\n+ * has fewer roots than its degree, the empty vector is returned.\n+ */\n+template<typename F>\n+std::vector<typename F::Elem> FindRoots(const std::vector<typename F::Elem>& poly, typename F::Elem basis, const F& field) {\n+    std::vector<typename F::Elem> roots;\n+    CHECK_RETURN(poly.size() != 0, {});\n+    CHECK_RETURN(basis != 0, {});\n+    if (poly.size() == 1) return roots; // No roots when the polynomial is a constant.\n+    roots.reserve(poly.size() - 1);\n+    std::vector<std::vector<typename F::Elem>> stack = {poly};\n+\n+    // Invoke the recursive factorization algorithm.\n+    if (!RecFindRoots(stack, 0, roots, false, 0, basis, field)) {\n+        // Not fully factorizable.\n+        return {};\n+    }\n+    CHECK_RETURN(poly.size() - 1 == roots.size(), {});\n+    return roots;\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> BerlekampMassey(const std::vector<typename F::Elem>& syndromes, size_t max_degree, const F& field) {\n+    std::vector<typename F::Multiplier> table;\n+    std::vector<typename F::Elem> current, prev, tmp;\n+    current.reserve(syndromes.size() / 2 + 1);\n+    prev.reserve(syndromes.size() / 2 + 1);\n+    tmp.reserve(syndromes.size() / 2 + 1);\n+    current.resize(1);\n+    current[0] = 1;\n+    prev.resize(1);\n+    prev[0] = 1;\n+    typename F::Elem b = 1, b_inv = 1;\n+    bool b_have_inv = true;\n+    table.reserve(syndromes.size());\n+\n+    for (size_t n = 0; n != syndromes.size(); ++n) {\n+        table.emplace_back(field, syndromes[n]);\n+        auto discrepancy = syndromes[n];\n+        for (size_t i = 1; i < current.size(); ++i) discrepancy ^= table[n - i](current[i]);\n+        if (discrepancy != 0) {\n+            int x = n + 1 - (current.size() - 1) - (prev.size() - 1);\n+            if (!b_have_inv) {\n+                b_inv = field.Inv(b);\n+                b_have_inv = true;\n+            }\n+            bool swap = 2 * (current.size() - 1) <= n;\n+            if (swap) {\n+                if (prev.size() + x - 1 > max_degree) return {}; // We'd exceed maximum degree\n+                tmp = current;\n+                current.resize(prev.size() + x);\n+            }\n+            typename F::Multiplier mul(field, field.Mul(discrepancy, b_inv));\n+            for (size_t i = 0; i < prev.size(); ++i) current[i + x] ^= mul(prev[i]);\n+            if (swap) {\n+                std::swap(prev, tmp);\n+                b = discrepancy;\n+                b_have_inv = false;\n+            }\n+        }\n+    }\n+    CHECK_RETURN(current.size() && current.back() != 0, {});\n+    return current;\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> ReconstructAllSyndromes(const std::vector<typename F::Elem>& odd_syndromes, const F& field) {\n+    std::vector<typename F::Elem> all_syndromes;\n+    all_syndromes.resize(odd_syndromes.size() * 2);\n+    for (size_t i = 0; i < odd_syndromes.size(); ++i) {\n+        all_syndromes[i * 2] = odd_syndromes[i];\n+        all_syndromes[i * 2 + 1] = field.Sqr(all_syndromes[i]);\n+    }\n+    return all_syndromes;\n+}\n+\n+template<typename F>\n+void AddToOddSyndromes(std::vector<typename F::Elem>& osyndromes, typename F::Elem data, const F& field) {\n+    auto sqr = field.Sqr(data);\n+    typename F::Multiplier mul(field, sqr);\n+    for (auto& osyndrome : osyndromes) {\n+        osyndrome ^= data;\n+        data = mul(data);\n+    }\n+}\n+\n+template<typename F>\n+std::vector<typename F::Elem> FullDecode(const std::vector<typename F::Elem>& osyndromes, const F& field) {\n+    auto asyndromes = ReconstructAllSyndromes<typename F::Elem>(osyndromes, field);\n+    auto poly = BerlekampMassey(asyndromes, field);\n+    std::reverse(poly.begin(), poly.end());\n+    return FindRoots(poly, field);\n+}\n+\n+template<typename F>\n+class SketchImpl final : public Sketch\n+{\n+    const F m_field;\n+    std::vector<typename F::Elem> m_syndromes;\n+    typename F::Elem m_basis;\n+\n+public:\n+    template<typename... Args>\n+    SketchImpl(int implementation, int bits, const Args&... args) : Sketch(implementation, bits), m_field(args...) {\n+        std::random_device rng;\n+        std::uniform_int_distribution<uint64_t> dist;\n+        m_basis = m_field.FromSeed(dist(rng));\n+    }\n+\n+    size_t Syndromes() const override { return m_syndromes.size(); }\n+    void Init(int count) override { m_syndromes.assign(count, 0); }\n+\n+    void Add(uint64_t val) override\n+    {\n+        auto elem = m_field.FromUint64(val);\n+        AddToOddSyndromes(m_syndromes, elem, m_field);\n+    }\n+\n+    void Serialize(unsigned char* ptr) const override\n+    {\n+        BitWriter writer(ptr);\n+        for (const auto& val : m_syndromes) {\n+            m_field.Serialize(writer, val);\n+        }\n+        writer.Flush();\n+    }\n+\n+    void Deserialize(const unsigned char* ptr) override\n+    {\n+        BitReader reader(ptr);\n+        for (auto& val : m_syndromes) {\n+            val = m_field.Deserialize(reader);\n+        }\n+    }\n+\n+    int Decode(int max_count, uint64_t* out) const override\n+    {\n+        auto all_syndromes = ReconstructAllSyndromes(m_syndromes, m_field);\n+        auto poly = BerlekampMassey(all_syndromes, max_count, m_field);\n+        if (poly.size() == 0) return -1;\n+        if (poly.size() == 1) return 0;\n+        if ((int)poly.size() > 1 + max_count) return -1;\n+        std::reverse(poly.begin(), poly.end());\n+        auto roots = FindRoots(poly, m_basis, m_field);\n+        if (roots.size() == 0) return -1;\n+\n+        for (const auto& root : roots) {\n+            *(out++) = m_field.ToUint64(root);\n+        }\n+        return roots.size();\n+    }\n+\n+    size_t Merge(const Sketch* other_sketch) override\n+    {\n+        // Sad cast. This is safe only because the caller code in minisketch.cpp checks\n+        // that implementation and field size match.\n+        const SketchImpl* other = static_cast<const SketchImpl*>(other_sketch);\n+        m_syndromes.resize(std::min(m_syndromes.size(), other->m_syndromes.size()));\n+        for (size_t i = 0; i < m_syndromes.size(); ++i) {\n+            m_syndromes[i] ^= other->m_syndromes[i];\n+        }\n+        return m_syndromes.size();\n+    }\n+\n+    void SetSeed(uint64_t seed) override\n+    {\n+        if (seed == (uint64_t)-1) {\n+            m_basis = 1;\n+        } else {\n+            m_basis = m_field.FromSeed(seed);\n+        }\n+    }\n+};\n+\n+#endif"
      },
      {
        "sha": "051d8431ef0a4804ae5597ec3b4cb36d8266087b",
        "filename": "src/minisketch/src/test-exhaust.cpp",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/test-exhaust.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/test-exhaust.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/test-exhaust.cpp?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,247 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <algorithm>\n+#include <random>\n+#include <iostream>\n+#include <thread>\n+#include \"util.h\"\n+\n+uint64_t Combination(uint64_t n, uint64_t k) {\n+    if (n - k < k) k = n - k;\n+    uint64_t ret = 1;\n+    for (uint64_t i = 1; i <= k; ++i) {\n+        ret = (ret * n) / i;\n+        --n;\n+    }\n+    return ret;\n+}\n+\n+void TestAll(int bits, int impl, int count, uint32_t threadid, uint32_t threads, std::vector<uint64_t>& ret) {\n+    bool supported = minisketch_implementation_supported(bits, impl);\n+    minisketch* state = minisketch_create(bits, impl, count);\n+    CHECK(supported == (state != nullptr));\n+    if (!state) return;\n+\n+    // Iterate over all (bits)-bit sketches with (count) syndromes.\n+    for (uint64_t x = threadid; (x >> (bits * count)) == 0; x += threads) {\n+        // Construct the serialization and load it.\n+        unsigned char ser[8];\n+        ser[0] = x;\n+        ser[1] = x >> 8;\n+        ser[2] = x >> 16;\n+        ser[3] = x >> 24;\n+        ser[4] = x >> 32;\n+        ser[5] = x >> 40;\n+        ser[6] = x >> 48;\n+        ser[7] = x >> 56;\n+\n+        minisketch_deserialize(state, ser);\n+\n+        // Compute all the solutions.\n+        uint64_t roots[64];\n+        int num_roots = minisketch_decode(state, 64, roots);\n+\n+        // If there are solutions:\n+        if (num_roots >= 0) {\n+            // Asking for one root less should fail.\n+            CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots) == -1);\n+            // Reconstruct the sketch from the solutions.\n+            minisketch* state2 = minisketch_create(bits, 0, count);\n+            for (int i = 0; i < num_roots; ++i) {\n+                minisketch_add_uint64(state2, roots[i]);\n+            }\n+            // Serialize it.\n+            unsigned char nser[8] = {0};\n+            minisketch_serialize(state2, nser);\n+            // Compare it to the original.\n+            CHECK(memcmp(ser, nser, 8) == 0);\n+            // Count it.\n+            if (num_roots +1 >= (int)ret.size()) ret.resize(num_roots + 2);\n+            ret[num_roots + 1]++;\n+            minisketch_destroy(state2);\n+        } else {\n+            if (ret.size() == 0) ret.resize(1);\n+            ret[0]++;\n+        }\n+    }\n+    minisketch_destroy(state);\n+}\n+\n+std::vector<uint64_t> TestAll(int bits, int impl, int count, uint32_t threads) {\n+    std::vector<std::vector<uint64_t>> outputs;\n+    std::vector<std::thread> thread_list;\n+    thread_list.reserve(threads);\n+    outputs.resize(threads);\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list.emplace_back([=,&outputs](){ TestAll(bits, impl, count, i, threads, outputs[i]); });\n+    }\n+    std::vector<uint64_t> ret;\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list[i].join();\n+        if (ret.size() < outputs[i].size()) ret.resize(outputs[i].size());\n+        for (size_t j = 0; j < outputs[i].size(); ++j) {\n+            ret[j] += outputs[i][j];\n+        }\n+    }\n+    if (ret.size()) {\n+        for (int i = 1; i <= count + 1; ++i) {\n+            CHECK(ret[i] == Combination((uint64_t(1) << bits) - 1, i - 1));\n+        }\n+    }\n+    return ret;\n+}\n+\n+void TestRand(int bits, int impl, int count, int iter) {\n+    std::vector<uint64_t> elems(count);\n+    std::vector<uint64_t> roots(count + 1);\n+    std::random_device rnd;\n+    std::uniform_int_distribution<uint64_t> dist(1, bits == 64 ? -1 : ((uint64_t(1) << bits) - 1));\n+\n+    for (int i = 0; i < iter; ++i) {\n+        bool overfill = iter & 1; // Test some cases with overfull sketches that may not decode.\n+        minisketch* state = minisketch_create(bits, impl, count);\n+        if (!state) return;\n+        minisketch* basestate = minisketch_create(bits, 0, count);\n+        for (int j = 0; j < count + 3*overfill; ++j) {\n+            uint64_t r = dist(rnd);\n+            if (!overfill) elems[j] = r;\n+            minisketch_add_uint64(state, r);\n+            minisketch_add_uint64(basestate, r);\n+        }\n+        roots.assign(count + 1, 0);\n+        std::vector<unsigned char> data, basedata;\n+        basedata.resize(((count + 1) * bits + 7) / 8);\n+        data.resize(((count + 1) * bits + 7) / 8);\n+        minisketch_serialize(basestate, basedata.data());\n+        minisketch_serialize(state, data.data());\n+        CHECK(data == basedata);\n+        minisketch_deserialize(state, basedata.data());\n+        int num_roots = minisketch_decode(state, count + 1, roots.data());\n+        CHECK(overfill || num_roots >= 0);\n+        CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots.data()) == -1); // Decoding with a too-low maximum should fail.\n+        if (!overfill) {\n+            std::sort(roots.begin(), roots.begin() + num_roots);\n+//            fprintf(stderr, \"Solut: \");\n+//            for (int j = 0; j < num_roots; ++j) {\n+//                fprintf(stderr, \"%016llx \", (unsigned long long)roots[j]);\n+//            }\n+//            fprintf(stderr, \"\\n\");\n+            std::sort(elems.begin(), elems.end());\n+            int expected = elems.size();\n+            for (size_t pos = 0; pos < elems.size(); ++pos) {\n+                if (pos + 1 < elems.size() && elems[pos] == elems[pos + 1]) {\n+                    expected -= 2;\n+                    elems[pos] = 0;\n+                    elems[pos + 1] = 0;\n+                    ++pos;\n+                }\n+            }\n+            CHECK(num_roots == expected);\n+            std::sort(elems.begin(), elems.end());\n+//            fprintf(stderr, \"Elems: \");\n+//            for (int j = 0; j < expected; ++j) {\n+//                fprintf(stderr, \"%016llx \", (unsigned long long)elems[j + elems.size() - expected]);\n+//            }\n+//            fprintf(stderr, \"\\n\");\n+            CHECK(std::equal(roots.begin(), roots.begin() + num_roots, elems.end() - expected));\n+        }\n+        minisketch_destroy(state);\n+        minisketch_destroy(basestate);\n+    }\n+}\n+\n+void TestComputeFunctions() {\n+    for (uint32_t bits = 0; bits <= 256; ++bits) {\n+        for (uint32_t fpbits = 0; fpbits <= 512; ++fpbits) {\n+            std::vector<size_t> table_max_elements(1025);\n+            for (size_t capacity = 0; capacity <= 1024; ++capacity) {\n+                table_max_elements[capacity] = minisketch_compute_max_elements(bits, capacity, fpbits);\n+                // Exception for bits==0\n+                if (bits == 0) CHECK(table_max_elements[capacity] == 0);\n+                // A sketch with capacity N cannot guarantee decoding more than N elements.\n+                CHECK(table_max_elements[capacity] <= capacity);\n+                // When asking for N bits of false positive protection, either no solution exists, or no more than ceil(N / bits) excess capacity should be needed.\n+                if (bits > 0) CHECK(table_max_elements[capacity] == 0 || capacity - table_max_elements[capacity] <= (fpbits + bits - 1) / bits);\n+                // Increasing capacity by one, if there is a solution, should always increment the max_elements by at least one as well.\n+                if (capacity > 0) CHECK(table_max_elements[capacity] == 0 || table_max_elements[capacity] > table_max_elements[capacity - 1]);\n+            }\n+\n+            std::vector<size_t> table_capacity(513);\n+            for (size_t max_elements = 0; max_elements <= 512; ++max_elements) {\n+                table_capacity[max_elements] = minisketch_compute_capacity(bits, max_elements, fpbits);\n+                // Exception for bits==0\n+                if (bits == 0) CHECK(table_capacity[max_elements] == 0);\n+                // To be able to decode N elements, capacity needs to be at least N.\n+                if (bits > 0) CHECK(table_capacity[max_elements] >= max_elements);\n+                // A sketch of N bits in total cannot have more than N bits of false positive protection;\n+                if (bits > 0) CHECK(bits * table_capacity[max_elements] >= fpbits);\n+                // When asking for N bits of false positive protection, no more than ceil(N / bits) excess capacity should be needed.\n+                if (bits > 0) CHECK(table_capacity[max_elements] - max_elements <= (fpbits + bits - 1) / bits);\n+                // Increasing max_elements by one can only increment the capacity by 0 or 1.\n+                if (max_elements > 0 && fpbits < 256) CHECK(table_capacity[max_elements] == table_capacity[max_elements - 1] || table_capacity[max_elements] == table_capacity[max_elements - 1] + 1);\n+                // Check round-tripping max_elements->capacity->max_elements (only a lower bound)\n+                CHECK(table_capacity[max_elements] <= 1024);\n+                CHECK(table_max_elements[table_capacity[max_elements]] == 0 || table_max_elements[table_capacity[max_elements]] >= max_elements);\n+            }\n+\n+            for (size_t capacity = 0; capacity <= 512; ++capacity) {\n+                // Check round-tripping capacity->max_elements->capacity (exact, if it exists)\n+                CHECK(table_max_elements[capacity] <= 512);\n+                CHECK(table_max_elements[capacity] == 0 || table_capacity[table_max_elements[capacity]] == capacity);\n+            }\n+        }\n+    }\n+}\n+\n+int main(void) {\n+    TestComputeFunctions();\n+\n+    for (int j = 2; j <= 64; j += 1) {\n+        fprintf(stderr, \"%i random tests with %i bits:\\n\", 500 / j, j);\n+        TestRand(j, 0, 150, 500 / j);\n+        TestRand(j, 1, 150, 500 / j);\n+        TestRand(j, 2, 150, 500 / j);\n+        fprintf(stderr, \"%i random tests with %i bits: done\\n\", 500 / j, j);\n+    }\n+\n+    int counts[65] = {0};\n+    // Initialize capacities to 1 because a 0 capacity is not allowed.\n+    for (int bits = 0; bits < 65; ++bits) {\n+        counts[bits] = 1;\n+    }\n+    for (int weight = 0; weight <= 40; weight += 1) {\n+        for (int bits = 2; bits <= 32; ++bits) {\n+            int count = counts[bits];\n+            while (count < (1 << bits) && count * bits <= weight) {\n+                auto ret = TestAll(bits, 0, count, 4);\n+                auto ret2 = TestAll(bits, 1, count, 4);\n+                auto ret3 = TestAll(bits, 2, count, 4);\n+                CHECK(ret2.empty() || ret == ret2);\n+                CHECK(ret3.empty() || ret == ret3);\n+                fprintf(stderr, \"bits=%i count=%i below_bound=[\", bits, count);\n+                for (int i = 0; i <= count; ++i) {\n+                    if (i) fprintf(stderr,  \",\");\n+                    fprintf(stderr, \"%llu\", (unsigned long long)ret[i + 1]);\n+                }\n+                fprintf(stderr, \"] above_bound=[\");\n+                for (int i = count + 1; i + 1 < (int)ret.size(); ++i) {\n+                    if (i > count + 1) fprintf(stderr,  \",\");\n+                    fprintf(stderr, \"%llu/%llu\", (unsigned long long)ret[i + 1], (unsigned long long)Combination((uint64_t(1) << bits) - 1, i));\n+                }\n+                fprintf(stderr, \"] nodecode=[%g]\\n\", (double)ret[0] * pow(0.5, bits * count));\n+                ++count;\n+            }\n+            counts[bits] = count;\n+        }\n+    }\n+\n+    return 0;\n+}"
      },
      {
        "sha": "fdb3f3a231d05f32b2fc10caed04733ac2f29651",
        "filename": "src/minisketch/src/util.h",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec47ad22dd25e319ffbfb9fe95a991a36d24427/src/minisketch/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/minisketch/src/util.h?ref=fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "patch": "@@ -0,0 +1,74 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _MINISKETCH_UTIL_H_\n+#define _MINISKETCH_UTIL_H_\n+\n+#ifdef MINISKETCH_VERIFY\n+#include <stdio.h>\n+#endif\n+\n+#if !defined(__GNUC_PREREQ)\n+# if defined(__GNUC__)&&defined(__GNUC_MINOR__)\n+#  define __GNUC_PREREQ(_maj,_min) \\\n+ ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))\n+# else\n+#  define __GNUC_PREREQ(_maj,_min) 0\n+# endif\n+#endif\n+\n+#if __GNUC_PREREQ(3, 0)\n+#define EXPECT(x,c) __builtin_expect((x),(c))\n+#else\n+#define EXPECT(x,c) (x)\n+#endif\n+\n+/* Assertion macros */\n+\n+/**\n+ * Unconditional failure on condition failure.\n+ * Primarily used in testing harnesses.\n+ */\n+#define CHECK(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, \"Check condition failed: \" #cond); \\\n+        abort(); \\\n+    } \\\n+} while(0)\n+\n+/**\n+ * Check macro that does nothing in normal non-verify builds but crashes in verify builds.\n+ * This is used to test conditions at runtime that should always be true, but are either\n+ * expensive to test or in locations where returning on failure would be messy.\n+ */\n+#ifdef MINISKETCH_VERIFY\n+#define CHECK_SAFE(cond) CHECK(cond)\n+#else\n+#define CHECK_SAFE(cond)\n+#endif\n+\n+/**\n+ * Check a condition and return on failure in non-verify builds, crash in verify builds.\n+ * Used for inexpensive conditions which believed to be always true in locations where\n+ * a graceful exit is possible.\n+ */\n+#ifdef MINISKETCH_VERIFY\n+#define CHECK_RETURN(cond, rvar) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, \"Check condition failed: \" #cond); \\\n+        abort(); \\\n+        return rvar; /* Does nothing, but causes compile to warn on incorrect return types. */ \\\n+    } \\\n+} while(0)\n+#else\n+#define CHECK_RETURN(cond, rvar) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        return rvar; \\\n+    } \\\n+} while(0)\n+#endif\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmM2FlYWVlNjM0MGY2Y2Q5MjUxOWMzOWQ2MWUxMWJmYWZlMjhhNjNl",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T14:45:13Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T12:47:56Z"
      },
      "message": "Announce reconciliation support\n\nIf a peer supports wtxid our node should notify them\nthat we are willing to participate in tx reconciliation.\nAt this point we generate a salt for computing\nshort tx IDs for reconciliations over this connection.",
      "tree": {
        "sha": "17d1b35f06ce17d54f788cb0b243e6985f202c5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17d1b35f06ce17d54f788cb0b243e6985f202c5b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec47ad22dd25e319ffbfb9fe95a991a36d24427",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fec47ad22dd25e319ffbfb9fe95a991a36d24427"
      }
    ],
    "stats": {
      "total": 99,
      "additions": 99,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b00e7ee0593c51542c6542bce4fde9864c892604",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -229,6 +229,7 @@ BITCOIN_CORE_H = \\\n   timedata.h \\\n   torcontrol.h \\\n   txdb.h \\\n+  txreconciliation.h \\\n   txrequest.h \\\n   txmempool.h \\\n   undo.h \\\n@@ -352,6 +353,7 @@ libbitcoin_server_a_SOURCES = \\\n   timedata.cpp \\\n   torcontrol.cpp \\\n   txdb.cpp \\\n+  txreconciliation.cpp \\\n   txrequest.cpp \\\n   txmempool.cpp \\\n   validation.cpp \\"
      },
      {
        "sha": "0a592ff7f31784364d437b1780f36bfb5c7a5e83",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -477,6 +477,21 @@ class CNode\n         assert(false);\n     }\n \n+    bool MightSupportTransactionRelay() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+                return true;\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n+\n+        assert(false);\n+    }\n+\n     bool IsFullOutboundConn() const {\n         return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n     }"
      },
      {
        "sha": "17cae3e05f4caef9704b0908ff509f4ac3d51cf2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -26,6 +26,7 @@\n #include <streams.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n+#include <txreconciliation.h>\n #include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n@@ -343,6 +344,7 @@ class PeerManagerImpl final : public PeerManager\n     ChainstateManager& m_chainman;\n     CTxMemPool& m_mempool;\n     TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n+    TxReconciliationTracker m_reconciliation;\n \n     /** The height of the best chain */\n     std::atomic<int> m_best_height{-1};\n@@ -2607,6 +2609,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         if (greatest_common_version >= WTXID_RELAY_VERSION) {\n             m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::WTXIDRELAY));\n+\n+            // Reconciliation is supported only when wtxid relay is supported for only\n+            // those connections which (at least might) support transaction relay.\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                auto recon_suggestion = m_reconciliation.SuggestReconciling(pfrom.GetId(), pfrom.IsInboundConn());\n+                m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::SENDRECON,\n+                    std::get<0>(recon_suggestion), std::get<1>(recon_suggestion),\n+                    std::get<2>(recon_suggestion), std::get<3>(recon_suggestion)));\n+            }\n         }\n \n         // Signal ADDRv2 support (BIP155)."
      },
      {
        "sha": "e4b64200669f67fd4ed06cc2242d6bfc286c9b21",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -44,6 +44,7 @@ const char *CFHEADERS=\"cfheaders\";\n const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n+const char *SENDRECON=\"sendrecon\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -84,6 +85,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::GETCFCHECKPT,\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n+    NetMsgType::SENDRECON,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "57f24fecce864f33faad613d74b71c537b368463",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -260,6 +260,13 @@ extern const char* CFCHECKPT;\n  * @since protocol version 70016 as described by BIP 339.\n  */\n extern const char* WTXIDRELAY;\n+/**\n+ * Contains 2 1-byte bools, a 4-byte version number and an 8-byte salt.\n+ * Indicates that a node is willing to participate in transaction reconciliation,\n+ * either as a sender or a receiver.\n+ * The salt is used to compute short txids needed for efficient reconciliation.\n+ */\n+extern const char *SENDRECON;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "647e46c6df029fd38070fe63b57a88719901567f",
        "filename": "src/txreconciliation.cpp",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+std::tuple<bool, bool, uint32_t, uint64_t> TxReconciliationTracker::SuggestReconciling(const NodeId peer_id, bool inbound)\n+{\n+    bool be_recon_requestor, be_recon_responder;\n+    // Currently reconciliation requests flow only in one direction inbound->outbound.\n+    if (inbound) {\n+        be_recon_requestor = false;\n+        be_recon_responder = true;\n+    } else {\n+        be_recon_requestor = true;\n+        be_recon_responder = false;\n+    }\n+\n+    uint32_t recon_version = 1;\n+    uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+    WITH_LOCK(m_local_salts_mutex, m_local_salts.emplace(peer_id, m_local_recon_salt));\n+\n+    return std::make_tuple(be_recon_requestor, be_recon_responder, recon_version, m_local_recon_salt);\n+}"
      },
      {
        "sha": "2c4bac9ad0242a5de8e27280ed9d67db28ae5a7b",
        "filename": "src/txreconciliation.h",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3aeaee6340f6cd92519c39d61e11bfafe28a63e/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "patch": "@@ -0,0 +1,38 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <tuple>\n+#include <unordered_map>\n+\n+/**\n+ * Used to track reconciliations across all peers.\n+ */\n+class TxReconciliationTracker {\n+    /**\n+     * Salt used to compute short IDs during transaction reconciliation.\n+     * Salt is generated randomly per-connection to prevent linking of\n+     * connections belonging to the same physical node.\n+     * Also, salts should be different per-connection to prevent halting\n+     * of relay of particular transactions due to collisions in short IDs.\n+     */\n+    Mutex m_local_salts_mutex;\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_local_salts_mutex);\n+\n+    public:\n+\n+    TxReconciliationTracker() {};\n+\n+    /**\n+     * TODO: document\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(const NodeId peer_id, bool inbound);\n+};\n+\n+#endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "e7d1293f762bb34417a4a882fb50706df8397c7b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplN2QxMjkzZjc2MmJiMzQ0MTdhNGE4ODJmYjUwNzA2ZGY4Mzk3Yzdi",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T12:03:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T12:47:57Z"
      },
      "message": "Count outbound tx relay peers except one\n\nThis helper will be used to determine whether we\nshould suggest our new peer reconciling with us.",
      "tree": {
        "sha": "f086043e3b1fc97be3e84f881f2e9bf74f721a04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f086043e3b1fc97be3e84f881f2e9bf74f721a04"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7d1293f762bb34417a4a882fb50706df8397c7b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7d1293f762bb34417a4a882fb50706df8397c7b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e7d1293f762bb34417a4a882fb50706df8397c7b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7d1293f762bb34417a4a882fb50706df8397c7b/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3aeaee6340f6cd92519c39d61e11bfafe28a63e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3aeaee6340f6cd92519c39d61e11bfafe28a63e"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 31,
      "deletions": 0
    },
    "files": [
      {
        "sha": "234a1337e92735fdd01b42a9996158a40f6b29f8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7d1293f762bb34417a4a882fb50706df8397c7b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7d1293f762bb34417a4a882fb50706df8397c7b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e7d1293f762bb34417a4a882fb50706df8397c7b",
        "patch": "@@ -330,6 +330,15 @@ class PeerManagerImpl final : public PeerManager\n     void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n+    /**\n+     * Return the number of outbound peers we\n+     * relay transactions to by flooding.\n+     * Used to determine whether we should flood to a new peer\n+     * which supports reconciliation, in case we haven't reached\n+     * the outbound flooding bandwidth-conserving limit.\n+     */\n+    size_t GetFloodingOutboundsCount(const CNode& skip_node) const;\n+\n     /** Send a version message to a peer */\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n@@ -961,6 +970,28 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     m_txrequest.ReceivedInv(nodeid, gtxid, preferred, current_time + delay);\n }\n \n+size_t PeerManagerImpl::GetFloodingOutboundsCount(const CNode& skip_node) const\n+{\n+    size_t result = 0;\n+    m_connman.ForEachNode([this, &result, &skip_node](const CNode* pnode) {\n+        if (!pnode->m_tx_relay) return;\n+        if (pnode->GetId() == skip_node.GetId()) return;\n+        if (!pnode->IsFullOutboundConn() && !pnode->IsManualConn()) return;\n+\n+        const auto recon_state = m_reconciliation.GetPeerState(pnode->GetId());\n+\n+        if (recon_state) {\n+            // Nodes supporting reconciliation still may be meant for flooding.\n+            if ((*recon_state).IsChosenForFlooding()) ++result;\n+        } else {\n+            // Nodes not supporting reconciliation are definitely meant for flooding,\n+            // unless they don't support tx relay, which is already checked above.\n+            ++result;\n+        }\n+    });\n+    return result;\n+}\n+\n // This function is used for testing the stale tip eviction logic, see\n // denialofservice_tests.cpp\n void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)"
      }
    ]
  },
  {
    "sha": "7ca561b7cf740feadb15fad7069d830b7517b910",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Y2E1NjFiN2NmNzQwZmVhZGIxNWZhZDcwNjlkODMwYjc1MTdiOTEw",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T12:06:42Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T12:48:33Z"
      },
      "message": "Handle reconciliation support announcement\n\nOnce we receive a message from a peer signalling\nreconciliation support, we initialize the data structures\nrequired to perform reconciliations. If we are planning to\ninitiate reconciliations with this peer (if it's an outbound connection),\nadd this peer to the reconciliation queue.",
      "tree": {
        "sha": "5c79a5ee3d9e54a0f4b3432938fcb50963dbb0ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c79a5ee3d9e54a0f4b3432938fcb50963dbb0ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ca561b7cf740feadb15fad7069d830b7517b910",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ca561b7cf740feadb15fad7069d830b7517b910",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7ca561b7cf740feadb15fad7069d830b7517b910",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ca561b7cf740feadb15fad7069d830b7517b910/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e7d1293f762bb34417a4a882fb50706df8397c7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7d1293f762bb34417a4a882fb50706df8397c7b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e7d1293f762bb34417a4a882fb50706df8397c7b"
      }
    ],
    "stats": {
      "total": 185,
      "additions": 185,
      "deletions": 0
    },
    "files": [
      {
        "sha": "56422a0188fc4f8216e43ed80624402bd63eefc1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ca561b7cf740feadb15fad7069d830b7517b910/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ca561b7cf740feadb15fad7069d830b7517b910/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7ca561b7cf740feadb15fad7069d830b7517b910",
        "patch": "@@ -4063,6 +4063,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from an inbound peer planning to reconcile transactions with us, or\n+    // from an outgoing peer demonstrating readiness to do reconciliations.\n+    // If received from outgoing, add the peer to the reconciliation queue.\n+    // Feature negotiation of tx reconciliation should happen between VERSION and\n+    // VERACK, to avoid relay problems from switching after a connection is up.\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (!pfrom.m_tx_relay) return;\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) return; // SENDRECON is allowed only after WTXIDRELAY.\n+\n+        bool recon_requestor, recon_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> recon_requestor >> recon_responder >> recon_version >> remote_salt;\n+\n+        size_t outbound_flooders = GetFloodingOutboundsCount(pfrom);\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            recon_requestor, recon_responder, recon_version, remote_salt, outbound_flooders);\n+\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "2b548985e09b8c81681e85b7292cd68405d6be4e",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ca561b7cf740feadb15fad7069d830b7517b910/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ca561b7cf740feadb15fad7069d830b7517b910/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=7ca561b7cf740feadb15fad7069d830b7517b910",
        "patch": "@@ -4,6 +4,17 @@\n \n #include <txreconciliation.h>\n \n+/** Static component of the salt used to compute short txids for transaction reconciliation. */\n+static const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+\n+static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n std::tuple<bool, bool, uint32_t, uint64_t> TxReconciliationTracker::SuggestReconciling(const NodeId peer_id, bool inbound)\n {\n     bool be_recon_requestor, be_recon_responder;\n@@ -22,3 +33,50 @@ std::tuple<bool, bool, uint32_t, uint64_t> TxReconciliationTracker::SuggestRecon\n \n     return std::make_tuple(be_recon_requestor, be_recon_responder, recon_version, m_local_recon_salt);\n }\n+\n+bool TxReconciliationTracker::EnableReconciliationSupport(const NodeId peer_id, bool inbound,\n+    bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt,\n+    size_t outbound_flooders)\n+{\n+    // Do not support reconciliation salt/version updates\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state != m_states.end()) return false;\n+\n+    if (recon_version != 1) return false;\n+\n+    // Do not flood through inbound connections which support reconciliation to save bandwidth.\n+    // Flood only through a limited number of outbound connections.\n+    bool flood_to = false;\n+    if (inbound) {\n+        // We currently don't support reconciliations with inbound peers which\n+        // don't want to be reconciliation senders (request our sketches),\n+        // or want to be reconciliation responders (send us their sketches).\n+        // Just ignore SENDRECON and use normal flooding for transaction relay with them.\n+        if (!recon_requestor) return false;\n+        if (recon_responder) return false;\n+    } else {\n+        // We currently don't support reconciliations with outbound peers which\n+        // don't want to be reconciliation responders (send us their sketches),\n+        // or want to be reconciliation senders (request our sketches).\n+        // Just ignore SENDRECON and use normal flooding for transaction relay with them.\n+        if (recon_requestor) return false;\n+        if (!recon_responder) return false;\n+        // TODO: Flood only through a limited number of outbound connections.\n+        flood_to = true;\n+    }\n+\n+    // Reconcile with all outbound peers supporting reconciliation (even if we flood to them),\n+    // to not miss transactions they have for us but won't flood.\n+    if (recon_responder) {\n+        LOCK(m_queue_mutex);\n+        m_queue.push_back(peer_id);\n+    }\n+\n+    uint64_t local_peer_salt = WITH_LOCK(m_local_salts_mutex, return m_local_salts.at(peer_id));\n+    uint256 full_salt = ComputeSalt(local_peer_salt, remote_salt);\n+\n+    m_states.emplace(peer_id, ReconciliationState(recon_requestor, recon_responder,\n+                        flood_to, full_salt.GetUint64(0), full_salt.GetUint64(1)));\n+    return true;\n+}"
      },
      {
        "sha": "b0d05606804632d6e33b57152caa1275e5d15e61",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ca561b7cf740feadb15fad7069d830b7517b910/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ca561b7cf740feadb15fad7069d830b7517b910/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=7ca561b7cf740feadb15fad7069d830b7517b910",
        "patch": "@@ -11,6 +11,77 @@\n #include <tuple>\n #include <unordered_map>\n \n+/** Default coefficient used to estimate set difference for tx reconciliation. */\n+static constexpr double DEFAULT_RECON_Q = 0.02;\n+\n+/**\n+ * This struct is used to keep track of the reconciliations with a given peer,\n+ * and also short transaction IDs for the next reconciliation round.\n+ * Transaction reconciliation means an efficient synchronization of the known\n+ * transactions between a pair of peers.\n+ * One reconciliation round consists of a sequence of messages. The sequence is\n+ * asymmetrical, there is always a requestor and a responder. At the end of the\n+ * sequence, nodes are supposed to exchange transactions, so that both of them\n+ * have all relevant transactions. For more protocol details, refer to BIP-0330.\n+ */\n+class ReconciliationState {\n+    /** Whether this peer will send reconciliation requests. */\n+    bool m_requestor;\n+\n+    /** Whether this peer will respond to reconciliation requests. */\n+    bool m_responder;\n+\n+    /**\n+     * Since reconciliation-only approach makes transaction relay\n+     * significantly slower, we also announce some of the transactions\n+     * (currently, transactions received from inbound links)\n+     * to some of the peers:\n+     * - all pre-reconciliation peers supporting transaction relay;\n+     * - a limited number of outbound reconciling peers *for which this flag is enabled*.\n+     * We enable this flag based on whether we have a\n+     * sufficient number of outbound transaction relay peers.\n+     * This flooding makes transaction relay across the network faster\n+     * without introducing high the bandwidth overhead.\n+     * Transactions announced via flooding should not be added to\n+     * the reconciliation set.\n+     */\n+    bool m_flood_to;\n+\n+    /**\n+     * Reconciliation involves computing and transmitting sketches,\n+     * which is a bandwidth-efficient representation of transaction IDs.\n+     * Since computing sketches over full txID is too CPU-expensive,\n+     * they will be computed over shortened IDs instead.\n+     * These short IDs will be salted so that they are not the same\n+     * across all pairs of peers, because otherwise it would enable network-wide\n+     * collisions which may (intentionally or not) halt relay of certain transactions.\n+     * Both of the peers contribute to the salt.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on its previous reconciliations,\n+     * to better predict future set size differences.\n+     */\n+    double m_local_q;\n+\n+public:\n+\n+    ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :\n+        m_requestor(requestor), m_responder(responder), m_flood_to(flood_to),\n+        m_k0(k0), m_k1(k1), m_local_q(DEFAULT_RECON_Q) {}\n+\n+    bool IsChosenForFlooding() const\n+    {\n+        return m_flood_to;\n+    }\n+};\n+\n /**\n  * Used to track reconciliations across all peers.\n  */\n@@ -25,6 +96,20 @@ class TxReconciliationTracker {\n     Mutex m_local_salts_mutex;\n     std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_local_salts_mutex);\n \n+    /**\n+     * Used to keep track of ongoing reconciliations (or lack of them) per peer.\n+     */\n+    Mutex m_states_mutex;\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_states_mutex);\n+\n+    /**\n+     * Reconciliation should happen with peers in the same order, because the efficiency gain is the\n+     * highest when reconciliation set difference is predictable. This queue is used to maintain the\n+     * order of peers chosen for reconciliation.\n+     */\n+    Mutex m_queue_mutex;\n+    std::deque<NodeId> m_queue GUARDED_BY(m_queue_mutex);\n+\n     public:\n \n     TxReconciliationTracker() {};\n@@ -33,6 +118,26 @@ class TxReconciliationTracker {\n      * TODO: document\n      */\n     std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(const NodeId peer_id, bool inbound);\n+\n+    /**\n+     * If a peer was previously initiated for reconciliations, get its current reconciliation state.\n+     * Note that the returned instance is read-only and modifying it won't alter the actual state.\n+     */\n+    bool EnableReconciliationSupport(const NodeId peer_id, bool inbound,\n+        bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders);\n+\n+    Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n+    {\n+        // This does not compile if this function is marked const. Not sure how to fix this.\n+        // LOCK(m_states_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state != m_states.end()) {\n+            return recon_state->second;\n+        } else {\n+            return nullopt;\n+        }\n+    }\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZDRmM2UxZjliMGFiYzZhODA3OGVhMmU4ZGUyOGVmMmEwMGM5Y2Yw",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T11:58:31Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T12:48:35Z"
      },
      "message": "Limit transaction flooding\n\nSee how many flooding and how many reconciling\noutbound peers we have, which is useful to see whether our new\npeer should be using flooding or reconciliation.\n\nIt helps to save bandwidth and presumably reduces privacy leak.",
      "tree": {
        "sha": "53ad8595ea825145a335e90ac6acd68c1a84c8d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/53ad8595ea825145a335e90ac6acd68c1a84c8d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7ca561b7cf740feadb15fad7069d830b7517b910",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ca561b7cf740feadb15fad7069d830b7517b910",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7ca561b7cf740feadb15fad7069d830b7517b910"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 7,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a6f96e4921a966408c15fbd5a813b638803de8d3",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
        "patch": "@@ -6,6 +6,12 @@\n \n /** Static component of the salt used to compute short txids for transaction reconciliation. */\n static const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+static constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n \n static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n {\n@@ -63,7 +69,7 @@ bool TxReconciliationTracker::EnableReconciliationSupport(const NodeId peer_id,\n         if (recon_requestor) return false;\n         if (!recon_responder) return false;\n         // TODO: Flood only through a limited number of outbound connections.\n-        flood_to = true;\n+        flood_to = outbound_flooders < MAX_OUTBOUND_FLOOD_TO;\n     }\n \n     // Reconcile with all outbound peers supporting reconciliation (even if we flood to them),"
      }
    ]
  },
  {
    "sha": "f49b144f71c5efa4404fd742b6772db0e2f98dff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDliMTQ0ZjcxYzVlZmE0NDA0ZmQ3NDJiNjc3MmRiMGUyZjk4ZGZm",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-11-09T08:22:23Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:21Z"
      },
      "message": "Remove node from reconciliation queue when disconnecting",
      "tree": {
        "sha": "79ce331adc9b79a5dc4eabf4e004c76eb479a950",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79ce331adc9b79a5dc4eabf4e004c76eb479a950"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f49b144f71c5efa4404fd742b6772db0e2f98dff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f49b144f71c5efa4404fd742b6772db0e2f98dff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f49b144f71c5efa4404fd742b6772db0e2f98dff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f49b144f71c5efa4404fd742b6772db0e2f98dff/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ed4f3e1f9b0abc6a8078ea2e8de28ef2a00c9cf0"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cade8dc7c35f951c6bf310da377e0a73fbec631e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f49b144f71c5efa4404fd742b6772db0e2f98dff/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f49b144f71c5efa4404fd742b6772db0e2f98dff/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f49b144f71c5efa4404fd742b6772db0e2f98dff",
        "patch": "@@ -1075,6 +1075,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     }\n     EraseOrphansFor(nodeid);\n     m_txrequest.DisconnectedPeer(nodeid);\n+    m_reconciliation.RemovePeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);"
      },
      {
        "sha": "0b962608de6181eaa7853f390b7f8e396b043e2e",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f49b144f71c5efa4404fd742b6772db0e2f98dff/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f49b144f71c5efa4404fd742b6772db0e2f98dff/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=f49b144f71c5efa4404fd742b6772db0e2f98dff",
        "patch": "@@ -138,6 +138,16 @@ class TxReconciliationTracker {\n             return nullopt;\n         }\n     }\n+\n+    void RemovePeer(const NodeId peer_id)\n+    {\n+        LOCK(m_queue_mutex);\n+        m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+        LOCK(m_local_salts_mutex);\n+        m_local_salts.erase(peer_id);\n+        LOCK(m_states_mutex);\n+        m_states.erase(peer_id);\n+    }\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "bcc795dbe3461a80c1f054594e66ab38094b684c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiY2M3OTVkYmUzNDYxYTgwYzFmMDU0NTk0ZTY2YWIzODA5NGI2ODRj",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-11-09T11:24:57Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add a function to announce transactions after reconciliation\n\nHave a separate function to announce transactions to a peer (via INVs)\nconsidering INV message limitations.",
      "tree": {
        "sha": "f92463e98fbe37a56272352c70faa561ff9aa363",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f92463e98fbe37a56272352c70faa561ff9aa363"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bcc795dbe3461a80c1f054594e66ab38094b684c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcc795dbe3461a80c1f054594e66ab38094b684c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bcc795dbe3461a80c1f054594e66ab38094b684c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcc795dbe3461a80c1f054594e66ab38094b684c/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f49b144f71c5efa4404fd742b6772db0e2f98dff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f49b144f71c5efa4404fd742b6772db0e2f98dff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f49b144f71c5efa4404fd742b6772db0e2f98dff"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 27,
      "deletions": 0
    },
    "files": [
      {
        "sha": "834ddc6007aaf698f1e657d4b20ef68b56cac3d7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcc795dbe3461a80c1f054594e66ab38094b684c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcc795dbe3461a80c1f054594e66ab38094b684c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=bcc795dbe3461a80c1f054594e66ab38094b684c",
        "patch": "@@ -339,6 +339,9 @@ class PeerManagerImpl final : public PeerManager\n      */\n     size_t GetFloodingOutboundsCount(const CNode& skip_node) const;\n \n+    /** Announce transactions a peer is missing after reconciliation is done. */\n+    void AnnounceTxs(const std::vector<uint256>& remote_missing_wtxids, CNode& pto);\n+\n     /** Send a version message to a peer */\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n@@ -2554,6 +2557,30 @@ static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainPar\n     connman.PushMessage(&peer, std::move(msg));\n }\n \n+void PeerManagerImpl::AnnounceTxs(const std::vector<uint256>& remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    // No need to add transactions to peer's filter or do checks\n+    // because it was already done when adding to the reconciliation set.\n+    for (const auto& wtxid: remote_missing_wtxids) {\n+        CInv winv(MSG_WTX, wtxid);\n+        remote_missing_invs.push_back(winv);\n+        if (remote_missing_invs.size() == MAX_INV_SZ) {\n+            m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\n+            remote_missing_invs.clear();\n+        }\n+    }\n+\n+    if (remote_missing_invs.size() != 0) {\n+        m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\n+    }\n+}\n+\n void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n                                      const std::chrono::microseconds time_received,\n                                      const std::atomic<bool>& interruptMsgProc)"
      }
    ]
  },
  {
    "sha": "b41b4674c27132622bd0611851d0161b3fae530d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDFiNDY3NGMyNzEzMjYyMmJkMDYxMTg1MWQwMTYxYjNmYWU1MzBk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-01-19T10:13:15Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Prepare to distinguish transactions to flood and to reconcile\n\nWe need assign and keep track of the way we're going to relay a transaction\nbased on the connection type the transaction arrived from, to\nenable transaction reconciliation protocol.",
      "tree": {
        "sha": "65c1cf37f9a271691a8588d486f405ba9304251b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65c1cf37f9a271691a8588d486f405ba9304251b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b41b4674c27132622bd0611851d0161b3fae530d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b41b4674c27132622bd0611851d0161b3fae530d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b41b4674c27132622bd0611851d0161b3fae530d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b41b4674c27132622bd0611851d0161b3fae530d/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bcc795dbe3461a80c1f054594e66ab38094b684c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcc795dbe3461a80c1f054594e66ab38094b684c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bcc795dbe3461a80c1f054594e66ab38094b684c"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 16,
      "deletions": 14
    },
    "files": [
      {
        "sha": "33674a0c0df75edd3de76b86deccb611794b0bf2",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b41b4674c27132622bd0611851d0161b3fae530d/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b41b4674c27132622bd0611851d0161b3fae530d/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b41b4674c27132622bd0611851d0161b3fae530d",
        "patch": "@@ -575,9 +575,11 @@ class CNode\n \n         mutable RecursiveMutex cs_tx_inventory;\n         CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n+        // Transaction ids we still have to announce, and whether we may flood them:\n+        // - true: flood unless peer correctly negotiated reconciliation and we didn't choose that peer for flooding.\n+        // - false: use reconciliation unless it's not supported by the peer, flood otherwise.\n+        // Transactions are sorted by the mempool before relay, so the order is not important.\n+        std::map<uint256, bool> m_transactions_to_announce;\n         // Used for BIP35 mempool sending\n         bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n         // Last time a \"MEMPOOL\" request was serviced.\n@@ -712,7 +714,7 @@ class CNode\n         if (m_tx_relay == nullptr) return;\n         LOCK(m_tx_relay->cs_tx_inventory);\n         if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n+            m_tx_relay->m_transactions_to_announce.emplace(hash, true);\n         }\n     }\n "
      },
      {
        "sha": "7942f479416240fbe9359f6be69cef2c35fcb36e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b41b4674c27132622bd0611851d0161b3fae530d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b41b4674c27132622bd0611851d0161b3fae530d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b41b4674c27132622bd0611851d0161b3fae530d",
        "patch": "@@ -4470,11 +4470,11 @@ class CompareInvMempoolOrder\n         m_wtxid_relay = use_wtxid;\n     }\n \n-    bool operator()(std::set<uint256>::iterator a, std::set<uint256>::iterator b)\n+    bool operator()(std::map<uint256, bool>::iterator a, std::map<uint256, bool>::iterator b)\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */\n-        return mp->CompareDepthAndScore(*b, *a, m_wtxid_relay);\n+        return mp->CompareDepthAndScore(b->first, a->first, m_wtxid_relay);\n     }\n };\n }\n@@ -4768,7 +4768,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n                     LOCK(pto->m_tx_relay->cs_filter);\n-                    if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n+                    if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->m_transactions_to_announce.clear();\n                 }\n \n                 // Respond to BIP35 mempool requests\n@@ -4782,7 +4782,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     for (const auto& txinfo : vtxinfo) {\n                         const uint256& hash = state.m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n+                        pto->m_tx_relay->m_transactions_to_announce.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n@@ -4804,9 +4804,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // Determine transactions to relay\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n-                    std::vector<std::set<uint256>::iterator> vInvTx;\n-                    vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n-                    for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n+                    std::vector<std::map<uint256, bool>::iterator> vInvTx;\n+                    vInvTx.reserve(pto->m_tx_relay->m_transactions_to_announce.size());\n+                    for (std::map<uint256, bool>::iterator it = pto->m_tx_relay->m_transactions_to_announce.begin(); it != pto->m_tx_relay->m_transactions_to_announce.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n                     const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n@@ -4821,12 +4821,12 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                        std::set<uint256>::iterator it = vInvTx.back();\n+                        std::map<uint256, bool>::iterator it = vInvTx.back();\n                         vInvTx.pop_back();\n-                        uint256 hash = *it;\n+                        uint256 hash = it->first;\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        pto->m_tx_relay->m_transactions_to_announce.erase(it);\n                         // Check if not in the filter already\n                         if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n                             continue;"
      }
    ]
  },
  {
    "sha": "2fb3d6950901b7c08d3381c729c0a436f8fa707d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZmIzZDY5NTA5MDFiN2MwOGQzMzgxYzcyOWMwYTQzNmY4ZmE3MDdk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-11-09T12:43:05Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Distinguish transactions to flood and to reconcile\n\nFlooding and reconciliation are two different ways to announce\ntransactions to the peers.\nFor transactions received from inbound links, use flooding to enable\na rapid relay across the reachable nodes.\n\nUse reconciliation (add transactions to the reconciliation sets) for\nall transactions which were received from outbound links to enable\nan slower but more efficient relay to unreachable nodes.",
      "tree": {
        "sha": "9280a3751ed916d2bb1b8d8157a4f0a9573508b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9280a3751ed916d2bb1b8d8157a4f0a9573508b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2fb3d6950901b7c08d3381c729c0a436f8fa707d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fb3d6950901b7c08d3381c729c0a436f8fa707d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2fb3d6950901b7c08d3381c729c0a436f8fa707d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fb3d6950901b7c08d3381c729c0a436f8fa707d/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b41b4674c27132622bd0611851d0161b3fae530d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b41b4674c27132622bd0611851d0161b3fae530d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b41b4674c27132622bd0611851d0161b3fae530d"
      }
    ],
    "stats": {
      "total": 140,
      "additions": 120,
      "deletions": 20
    },
    "files": [
      {
        "sha": "442e7eddd12224f7e418c157d86298707450fb0a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -709,12 +709,12 @@ class CNode\n         }\n     }\n \n-    void PushTxInventory(const uint256& hash)\n+    void PushTxInventory(const uint256& hash, bool flood)\n     {\n         if (m_tx_relay == nullptr) return;\n         LOCK(m_tx_relay->cs_tx_inventory);\n         if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->m_transactions_to_announce.emplace(hash, true);\n+            m_tx_relay->m_transactions_to_announce.emplace(hash, flood);\n         }\n     }\n "
      },
      {
        "sha": "adcccc7564c139c07ef3d2c57de12bde463aeb7a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 15,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -80,7 +80,14 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n /** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n  *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n  *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n- *  the actual transaction (from any peer) in response to requests for them. */\n+ *  the actual transaction (from any peer) in response to requests for them.\n+ *  Also limits a maximum number of elements to store in the reconciliation set. After the limit is reached,\n+ *  the remaining transactions are set to be flooded to that peer.\n+ *  W.r.t set reconciliation, sets the bound on the following objects:\n+ *  - reconciliation set;\n+ *  - reconciliation set snapshot;\n+ *  - reconciliation short-full id mapping.\n+ */\n static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr auto TXID_RELAY_DELAY = std::chrono::seconds{2};\n@@ -1033,7 +1040,15 @@ void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler) const\n \n         if (tx != nullptr) {\n             LOCK(cs_main);\n-            RelayTransaction(txid, tx->GetWitnessHash(), m_connman);\n+            // We re-relay these transactions via reconciliation (same as for initial broadcast),\n+            // instead of flooding, to hide the origin of transactions.\n+            // Since in Erlay transactions are flooded only inbound->outbound,\n+            // non-reachable nodes never flood transactions from other nodes (they have no inbounds).\n+            // Thus, making them flood these would tell a receiver that these indeed belong to the\n+            // flooding non-reachable nodes. Instead, we relay them via reconciliation,\n+            // in which case a receiver can't distinguish them from transactions we reconciled\n+            // with some other peer.\n+            RelayTransaction(txid, tx->GetWitnessHash(), m_connman, false);\n         } else {\n             m_mempool.RemoveUnbroadcastTx(txid, true);\n         }\n@@ -1695,17 +1710,19 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n+void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman, bool flood)\n {\n-    connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    connman.ForEachNode([&txid, &wtxid, flood](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n         CNodeState* state = State(pnode->GetId());\n         if (state == nullptr) return;\n         if (state->m_wtxid_relay) {\n-            pnode->PushTxInventory(wtxid);\n+            pnode->PushTxInventory(wtxid, flood);\n         } else {\n-            pnode->PushTxInventory(txid);\n+            // Reconciliations are not supported for non-wtxid peers,\n+            // so we always use flooding.\n+            pnode->PushTxInventory(txid, true);\n         }\n     });\n }\n@@ -2278,7 +2295,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n+            RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman, true);\n             for (unsigned int i = 0; i < porphanTx->vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(orphanHash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -3322,7 +3339,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman, true);\n                 }\n             }\n             return;\n@@ -3337,7 +3354,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // requests for it.\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n-            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+\n+            // Flood those transactions which were received either via flooding, or inbound reconciliation,\n+            // but NOT via outbound reconciliation. Flooding then is mainly used for initial propagation\n+            // of new transactions across a network of reachable nodes quickly.\n+            const auto recon_state = m_reconciliation.GetPeerState(pfrom.GetId());\n+            bool flood = !(recon_state && (*recon_state).IsResponder());\n+\n+            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman, flood);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(txid, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -4751,17 +4775,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             }\n             peer->m_blocks_for_inv_relay.clear();\n \n+            const auto recon_state = m_reconciliation.GetPeerState(pto->GetId());\n+\n             if (pto->m_tx_relay != nullptr) {\n                 LOCK(pto->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n-                    if (pto->IsInboundConn()) {\n-                        pto->m_tx_relay->nNextInvSend = std::chrono::microseconds{m_connman.PoissonNextSendInbound(count_microseconds(current_time), INVENTORY_BROADCAST_INTERVAL)};\n-                    } else {\n-                        // Use half the delay for outbound peers, as there is less privacy concern for them.\n+                    if (recon_state || !pto->IsInboundConn()) {\n+                        // Use half the delay as there is less privacy concern.\n                         pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, std::chrono::seconds{INVENTORY_BROADCAST_INTERVAL >> 1});\n+                    } else {\n+                        pto->m_tx_relay->nNextInvSend = std::chrono::microseconds{m_connman.PoissonNextSendInbound(count_microseconds(current_time), INVENTORY_BROADCAST_INTERVAL)};\n                     }\n                 }\n \n@@ -4806,6 +4832,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     // Produce a vector with all candidates for sending\n                     std::vector<std::map<uint256, bool>::iterator> vInvTx;\n                     vInvTx.reserve(pto->m_tx_relay->m_transactions_to_announce.size());\n+                    std::vector<uint256> txs_to_reconcile;\n                     for (std::map<uint256, bool>::iterator it = pto->m_tx_relay->m_transactions_to_announce.begin(); it != pto->m_tx_relay->m_transactions_to_announce.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n@@ -4843,9 +4870,18 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             continue;\n                         }\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n-                        // Send\n+\n+                        bool flood_tx = it->second;\n+                        if (!recon_state || ((*recon_state).IsChosenForFlooding() && flood_tx)) {\n+                            // Always flood to non-reconciliation nodes supporting tx relay.\n+                            // For reconciliation nodes, flood if flood_to is set up and transaction is meant for flooding.\n+                            vInv.push_back(inv);\n+                        } else {\n+                            // Storing to populate the reconciliation set.\n+                            txs_to_reconcile.push_back(txinfo.tx->GetWitnessHash());\n+                        }\n+\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n                         nRelayedTransactions++;\n                         {\n                             // Expire old relay messages\n@@ -4879,6 +4915,29 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (recon_state && txs_to_reconcile.size() != 0) {\n+                        std::vector<uint256> txs_to_flood;\n+                        int32_t recon_set_overflow = recon_state->GetLocalSetSize() + txs_to_reconcile.size() - MAX_PEER_TX_ANNOUNCEMENTS;\n+                        if (recon_set_overflow > 0) {\n+                            LogPrint(BCLog::NET, \"Reconciliation set for the peer=%d is at capacity, not adding %i new transactions. \\n\", pto->GetId(), recon_set_overflow);\n+                            // Since we reconcile frequently, it either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            // Since computing a sketch over too many elements is too expensive, we will just flood some transactions here.\n+                            txs_to_flood = std::vector<uint256>(txs_to_reconcile.end() - recon_set_overflow, txs_to_reconcile.end());\n+                            txs_to_reconcile.resize(txs_to_reconcile.size() - recon_set_overflow);\n+                        }\n+                        // Do not use recon_state here because it's meant for read-only and\n+                        // not going to be stored anywhere.\n+                        m_reconciliation.StoreTxsToAnnounce(pto->GetId(), txs_to_reconcile);\n+                        if (txs_to_flood.size() > 0) {\n+                            AnnounceTxs(txs_to_flood, *pto);\n+                        }\n+                    }\n                 }\n             }\n         }"
      },
      {
        "sha": "039e5b3c892b86b3c0e459824f038244aafc2af4",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -73,6 +73,6 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n };\n \n /** Relay transaction to every node */\n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman, bool flood) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "ad6a3b9062c60e7fe07e1b8e344b66ea1e7b1245",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -99,8 +99,16 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         // best-effort of initial broadcast\n         node.mempool->AddUnbroadcastTx(hashTx);\n \n+        // We relay these transactions via reconciliation,\n+        // instead of flooding, to hide the origin of transactions.\n+        // Since in Erlay transactions are flooded only inbound->outbound,\n+        // non-reachable nodes never flood transactions from other nodes (they have no inbounds).\n+        // Thus, making them flood these would tell a receiver that these indeed belong to the\n+        // flooding non-reachable nodes. Instead, we relay them via reconciliation,\n+        // in which case a receiver can't distinguish them from transactions we reconciled\n+        // with some other peer.\n         LOCK(cs_main);\n-        RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n+        RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman, false);\n     }\n \n     return TransactionError::OK;"
      },
      {
        "sha": "8475f25d43d471bca5608da609fd9c6ac3ace49d",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -86,7 +86,7 @@ FUZZ_TARGET_INIT(net, initialize_net)\n                 node.AddKnownTx(inv_opt->hash);\n             },\n             [&] {\n-                node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider));\n+                node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider), fuzzed_data_provider.ConsumeBool());\n             },\n             [&] {\n                 const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);"
      },
      {
        "sha": "8861b265585ea6f78f768b956c4042b6b0b61be0",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fb3d6950901b7c08d3381c729c0a436f8fa707d/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "patch": "@@ -70,6 +70,14 @@ class ReconciliationState {\n      */\n     double m_local_q;\n \n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    std::set<uint256> m_local_set;\n+\n public:\n \n     ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :\n@@ -80,6 +88,23 @@ class ReconciliationState {\n     {\n         return m_flood_to;\n     }\n+\n+    bool IsResponder() const\n+    {\n+        return m_responder;\n+    }\n+\n+    uint16_t GetLocalSetSize() const\n+    {\n+        return m_local_set.size();\n+    }\n+\n+    void AddToReconSet(const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        for (const auto& wtxid: txs_to_reconcile) {\n+            m_local_set.insert(wtxid);\n+        }\n+    }\n };\n \n /**\n@@ -139,6 +164,14 @@ class TxReconciliationTracker {\n         }\n     }\n \n+    void StoreTxsToAnnounce(const NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        LOCK(m_states_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+        recon_state->second.AddToReconSet(txs_to_reconcile);\n+    }\n+\n     void RemovePeer(const NodeId peer_id)\n     {\n         LOCK(m_queue_mutex);"
      }
    ]
  },
  {
    "sha": "a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMjhiZTU2OWRkODUyMWRmZDMzMWNmOGRjMDliYmVlMDEwY2NiYjNk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-11-13T08:18:15Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Reduce tx broadcast interval\n\nSince reconciliation is naturally slower than flooding, and also\nsince we limit the flooding aspect, we should reduce the intervals\nbetween broadcasts (flooding out or adding to reconciliation sets).\nOtherwise, transaction relay will be too slow\n(and probably less inefficient).\n\nNote that for privacy reasons the ratio between inbound and outbound\ndelays matter much more than the actual delays. That ratio is preserved\nhere, so it is not a privacy degradation.",
      "tree": {
        "sha": "b798ae4850e12374f6e0474858aedc8cb35e5ab3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b798ae4850e12374f6e0474858aedc8cb35e5ab3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a28be569dd8521dfd331cf8dc09bbee010ccbb3d/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fb3d6950901b7c08d3381c729c0a436f8fa707d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2fb3d6950901b7c08d3381c729c0a436f8fa707d"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "03d62e13fd675a57b53fa51a9bba3f34f16b9a1c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a28be569dd8521dfd331cf8dc09bbee010ccbb3d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a28be569dd8521dfd331cf8dc09bbee010ccbb3d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
        "patch": "@@ -132,12 +132,12 @@ static constexpr std::chrono::hours AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL{24};\n static constexpr std::chrono::seconds AVG_ADDRESS_BROADCAST_INTERVAL{30};\n /** Average delay between trickled inventory transmissions in seconds.\n  *  Blocks and peers with noban permission bypass this, outbound peers get half this delay. */\n-static const unsigned int INVENTORY_BROADCAST_INTERVAL = 5;\n+static const unsigned int INVENTORY_BROADCAST_INTERVAL = 2;\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * INVENTORY_BROADCAST_INTERVAL;\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * INVENTORY_BROADCAST_INTERVAL * 4;\n /** The number of most recently announced transactions a peer can request. */\n static constexpr unsigned int INVENTORY_MAX_RECENT_RELAY = 3500;\n /** Verify that INVENTORY_MAX_RECENT_RELAY is enough to cache everything typically"
      }
    ]
  },
  {
    "sha": "60d59a449e74e4d3751b4090ffae6abb19c893a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MGQ1OWE0NDllNzRlNGQzNzUxYjQwOTBmZmFlNmFiYjE5Yzg5M2E5",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T16:51:22Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Request tx reconciliation as scheduled\n\nIf the peer is next in the queue for reconciliation,\nand enough time is passed from the previous\nreconciliation, consider a peer for reconciliation.\n\nIf there is no pending reconciliation request to the peer,\nsend one, otherwise just move to the end of queue and\nupdate global next reconciliation request time.",
      "tree": {
        "sha": "d06644b108179cf05578ecb4ffc401f9f3a2f2a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d06644b108179cf05578ecb4ffc401f9f3a2f2a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/60d59a449e74e4d3751b4090ffae6abb19c893a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d59a449e74e4d3751b4090ffae6abb19c893a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/60d59a449e74e4d3751b4090ffae6abb19c893a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d59a449e74e4d3751b4090ffae6abb19c893a9/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a28be569dd8521dfd331cf8dc09bbee010ccbb3d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a28be569dd8521dfd331cf8dc09bbee010ccbb3d"
      }
    ],
    "stats": {
      "total": 100,
      "additions": 100,
      "deletions": 0
    },
    "files": [
      {
        "sha": "37216c5037da25217d59ef24ee7983b0dea23df0",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "patch": "@@ -4944,6 +4944,17 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+            if (reconciliation_request_data) {\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON,\n+                    (*reconciliation_request_data).first, (*reconciliation_request_data).second));\n+            }\n+        }\n+\n         // Detect whether we're stalling\n         current_time = GetTime<std::chrono::microseconds>();\n         if (state.nStallingSince && state.nStallingSince < count_microseconds(current_time) - 1000000 * BLOCK_STALLING_TIMEOUT) {"
      },
      {
        "sha": "4353fbfcfc32c1c5840d374b391a0b7839670dbd",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "patch": "@@ -45,6 +45,7 @@ const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n+ const char *REQRECON=\"reqrecon\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -86,6 +87,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n     NetMsgType::SENDRECON,\n+    NetMsgType::REQRECON,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "2b4710d1793efb61bc349d2893bcd1415c7903ba",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "patch": "@@ -267,6 +267,13 @@ extern const char* WTXIDRELAY;\n  * The salt is used to compute short txids needed for efficient reconciliation.\n  */\n extern const char *SENDRECON;\n+/**\n+ * Requests a reconciliation, and provides local reconciliation set size\n+ * and coefficient used to accurately estimate reconciliation set difference\n+ * for a peer to construct a set sketch.\n+ * Peer should respond with \"sketch\" message.\n+ */\n+extern const char *REQRECON;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "149a1c9f78058b13c3cf5e5e8f3af41a0ef50056",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "patch": "@@ -86,3 +86,27 @@ bool TxReconciliationTracker::EnableReconciliationSupport(const NodeId peer_id,\n                         flood_to, full_salt.GetUint64(0), full_salt.GetUint64(1)));\n     return true;\n }\n+\n+Optional<std::pair<uint16_t, uint16_t>> TxReconciliationTracker::MaybeRequestReconciliation(const NodeId peer_id)\n+{\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return nullopt;\n+    if (recon_state->second.GetOutgoingPhase() != RECON_NONE) return nullopt;\n+\n+    LOCK(m_queue_mutex);\n+    if (m_queue.size() > 0) {\n+        // Request transaction reconciliation periodically to efficiently exchange transactions.\n+        // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+        // and with a delay between requests.\n+        auto current_time = GetTime<std::chrono::seconds>();\n+        if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+            recon_state->second.UpdateOutgoingPhase(RECON_INIT_REQUESTED);\n+            m_queue.pop_back();\n+            m_queue.push_front(peer_id);\n+            UpdateNextReconRequest(current_time);\n+            return std::make_pair(recon_state->second.GetLocalSetSize(), recon_state->second.GetLocalQ());\n+        }\n+    }\n+    return nullopt;\n+}"
      },
      {
        "sha": "145982cd090c65b512aa9a3e99baf6cca4095a2d",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d59a449e74e4d3751b4090ffae6abb19c893a9/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "patch": "@@ -13,6 +13,26 @@\n \n /** Default coefficient used to estimate set difference for tx reconciliation. */\n static constexpr double DEFAULT_RECON_Q = 0.02;\n+/** Used to convert a floating point reconciliation coefficient q to an int for transmission.\n+  * Specified by BIP-330.\n+  */\n+static constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between sending reconciliation request to the same peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation\n+ * at capacity. More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+static constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum ReconciliationPhase {\n+    RECON_NONE,\n+    RECON_INIT_REQUESTED,\n+};\n \n /**\n  * This struct is used to keep track of the reconciliations with a given peer,\n@@ -78,6 +98,9 @@ class ReconciliationState {\n      */\n     std::set<uint256> m_local_set;\n \n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationPhase m_outgoing_recon{RECON_NONE};\n+\n public:\n \n     ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :\n@@ -99,12 +122,28 @@ class ReconciliationState {\n         return m_local_set.size();\n     }\n \n+    uint16_t GetLocalQ() const\n+    {\n+        return m_local_q * Q_PRECISION;\n+    }\n+\n+    ReconciliationPhase GetOutgoingPhase() const\n+    {\n+        return m_outgoing_recon;\n+    }\n+\n     void AddToReconSet(const std::vector<uint256>& txs_to_reconcile)\n     {\n         for (const auto& wtxid: txs_to_reconcile) {\n             m_local_set.insert(wtxid);\n         }\n     }\n+\n+    void UpdateOutgoingPhase(ReconciliationPhase phase)\n+    {\n+        assert(m_responder);\n+        m_outgoing_recon = phase;\n+    }\n };\n \n /**\n@@ -135,6 +174,16 @@ class TxReconciliationTracker {\n     Mutex m_queue_mutex;\n     std::deque<NodeId> m_queue GUARDED_BY(m_queue_mutex);\n \n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request{0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_queue_mutex)\n+    {\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n     public:\n \n     TxReconciliationTracker() {};\n@@ -152,6 +201,13 @@ class TxReconciliationTracker {\n         bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt,\n         size_t outbound_flooders);\n \n+    /**\n+     * If a it's time to request a reconciliation from the peer, this function will return the\n+     * details of our local state, which should be communicated to the peer so that they better\n+     * know what we need.\n+     */\n+    Optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(const NodeId peer_id);\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "b0659c36b79523596687c13c7b6adf86a5799ad3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDY1OWMzNmI3OTUyMzU5NjY4N2MxM2M3YjZhZGY4NmE1Nzk5YWQz",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-24T17:03:09Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Process incoming reconciliation request\n\nUpon receiving a reconciliation request, a node stores\nit and schedules a response.\nDo not respond to a request right away as it would enable\na DoS attack and allow monitoring of transaction a node has.\nInstead, respond to all reconciliation requests at a same time\nafter a small delay.",
      "tree": {
        "sha": "27a4d4980f74b13afffdedfae127c74e956777e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27a4d4980f74b13afffdedfae127c74e956777e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0659c36b79523596687c13c7b6adf86a5799ad3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0659c36b79523596687c13c7b6adf86a5799ad3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0659c36b79523596687c13c7b6adf86a5799ad3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0659c36b79523596687c13c7b6adf86a5799ad3/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d59a449e74e4d3751b4090ffae6abb19c893a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60d59a449e74e4d3751b4090ffae6abb19c893a9"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 95,
      "deletions": 0
    },
    "files": [
      {
        "sha": "73c9723b45e83e2bd2dcb2fc44301c168ae1efed",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0659c36b79523596687c13c7b6adf86a5799ad3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0659c36b79523596687c13c7b6adf86a5799ad3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b0659c36b79523596687c13c7b6adf86a5799ad3",
        "patch": "@@ -4137,6 +4137,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "a030bfee0215672be8a9bbfbcbb52674133b784e",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0659c36b79523596687c13c7b6adf86a5799ad3/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0659c36b79523596687c13c7b6adf86a5799ad3/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=b0659c36b79523596687c13c7b6adf86a5799ad3",
        "patch": "@@ -110,3 +110,18 @@ Optional<std::pair<uint16_t, uint16_t>> TxReconciliationTracker::MaybeRequestRec\n     }\n     return nullopt;\n }\n+\n+void TxReconciliationTracker::HandleReconciliationRequest(const NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+{\n+    double peer_q_converted = double(peer_q * Q_PRECISION);\n+    if (peer_q_converted < 0 || peer_q_converted > 2) return;\n+\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return;\n+    if (recon_state->second.GetIncomingPhase() != RECON_NONE) return;\n+    if (!recon_state->second.IsRequestor()) return;\n+\n+    recon_state->second.PrepareIncoming(peer_recon_set_size, peer_q_converted, NextReconRespond());\n+    recon_state->second.UpdateIncomingPhase(RECON_INIT_REQUESTED);\n+}"
      },
      {
        "sha": "21f59c2464fa6aeff7e6aca6ac33709ecffd169c",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0659c36b79523596687c13c7b6adf86a5799ad3/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0659c36b79523596687c13c7b6adf86a5799ad3/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=b0659c36b79523596687c13c7b6adf86a5799ad3",
        "patch": "@@ -25,6 +25,12 @@ static constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n  * Less frequent reconciliations would introduce high transaction relay latency.\n  */\n static constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+static constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n \n /**\n  * Represents phase of the current reconciliation round with a peer.\n@@ -90,6 +96,13 @@ class ReconciliationState {\n      */\n     double m_local_q;\n \n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q;\n+\n     /**\n      * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n      * in this set instead of announcing them right away. When reconciliation time comes, we will\n@@ -98,7 +111,21 @@ class ReconciliationState {\n      */\n     std::set<uint256> m_local_set;\n \n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can\u2019t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n     /** Keep track of reconciliations with the peer. */\n+    ReconciliationPhase m_incoming_recon{RECON_NONE};\n     ReconciliationPhase m_outgoing_recon{RECON_NONE};\n \n public:\n@@ -112,6 +139,11 @@ class ReconciliationState {\n         return m_flood_to;\n     }\n \n+    bool IsRequestor() const\n+    {\n+        return m_requestor;\n+    }\n+\n     bool IsResponder() const\n     {\n         return m_responder;\n@@ -127,6 +159,11 @@ class ReconciliationState {\n         return m_local_q * Q_PRECISION;\n     }\n \n+    ReconciliationPhase GetIncomingPhase() const\n+    {\n+        return m_incoming_recon;\n+    }\n+\n     ReconciliationPhase GetOutgoingPhase() const\n     {\n         return m_outgoing_recon;\n@@ -139,11 +176,27 @@ class ReconciliationState {\n         }\n     }\n \n+    void UpdateIncomingPhase(ReconciliationPhase phase)\n+    {\n+        assert(m_requestor);\n+        m_incoming_recon = phase;\n+    }\n+\n     void UpdateOutgoingPhase(ReconciliationPhase phase)\n     {\n         assert(m_responder);\n         m_outgoing_recon = phase;\n     }\n+\n+    void PrepareIncoming(uint16_t remote_set_size, double remote_q, std::chrono::microseconds next_respond)\n+    {\n+        assert(m_requestor);\n+        assert(m_incoming_recon == RECON_NONE);\n+        assert(m_remote_q >= 0 && m_remote_q <= 2);\n+        m_remote_q = remote_q;\n+        m_remote_set_size = remote_set_size;\n+        m_next_recon_respond = next_respond;\n+    }\n };\n \n /**\n@@ -184,6 +237,20 @@ class TxReconciliationTracker {\n         m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n     }\n \n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n     public:\n \n     TxReconciliationTracker() {};\n@@ -208,6 +275,12 @@ class TxReconciliationTracker {\n      */\n     Optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(const NodeId peer_id);\n \n+    /**\n+     * Record an (expected) reconciliation request with parameters to respond when time comes. All\n+     * initial reconciliation responses will be done at the same time to prevent privacy leaks.\n+     */\n+    void HandleReconciliationRequest(const NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q);\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YWFkY2U3Y2RmNzI3NzFiOTY1MzNiYmUzNGY4MGZkMGY2YThkZDQ2",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:32:57Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add helper to compute reconciliation tx short id\n\nShort ids are used to compute reconciliation sketches.",
      "tree": {
        "sha": "46bccef38a49e67169f095d94c2a2db7d9bbc43e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/46bccef38a49e67169f095d94c2a2db7d9bbc43e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0659c36b79523596687c13c7b6adf86a5799ad3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0659c36b79523596687c13c7b6adf86a5799ad3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0659c36b79523596687c13c7b6adf86a5799ad3"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d0d3027e5f8cb3399cb8c1d0c63620237146a3d3",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
        "patch": "@@ -128,6 +128,17 @@ class ReconciliationState {\n     ReconciliationPhase m_incoming_recon{RECON_NONE};\n     ReconciliationPhase m_outgoing_recon{RECON_NONE};\n \n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n public:\n \n     ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :"
      }
    ]
  },
  {
    "sha": "244b59a48120a8fed7a378baf66b44efc5c14f01",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDRiNTlhNDgxMjBhOGZlZDdhMzc4YmFmNjZiNDRlZmM1YzE0ZjAx",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:41:11Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add helper to compute sketches for tx reconciliation\n\nSketch is a representation of list of transaction IDs,\nwhich enables reconciliation (an efficient sync of lists\nbetween peers).",
      "tree": {
        "sha": "99a515e1cd5fb0cf258d9df79b4aafd52197bd19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99a515e1cd5fb0cf258d9df79b4aafd52197bd19"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/244b59a48120a8fed7a378baf66b44efc5c14f01",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/244b59a48120a8fed7a378baf66b44efc5c14f01",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/244b59a48120a8fed7a378baf66b44efc5c14f01",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/244b59a48120a8fed7a378baf66b44efc5c14f01/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5aadce7cdf72771b96533bbe34f80fd0f6a8dd46"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 69,
      "deletions": 1
    },
    "files": [
      {
        "sha": "e5b4f30f73cf54b4d6fabddfd4a1956f9e8170bd",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b59a48120a8fed7a378baf66b44efc5c14f01/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b59a48120a8fed7a378baf66b44efc5c14f01/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=244b59a48120a8fed7a378baf66b44efc5c14f01",
        "patch": "@@ -45,7 +45,7 @@ const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n- const char *REQRECON=\"reqrecon\";\n+const char *REQRECON=\"reqrecon\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of"
      },
      {
        "sha": "ac0f2365647509d078f5079876e0eba5c217e1d5",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/244b59a48120a8fed7a378baf66b44efc5c14f01/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/244b59a48120a8fed7a378baf66b44efc5c14f01/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=244b59a48120a8fed7a378baf66b44efc5c14f01",
        "patch": "@@ -5,12 +5,31 @@\n #ifndef BITCOIN_TXRECONCILIATION_H\n #define BITCOIN_TXRECONCILIATION_H\n \n+#include <minisketch/include/minisketch.h>\n #include <net.h>\n #include <sync.h>\n \n #include <tuple>\n #include <unordered_map>\n \n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+static constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+static constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+static constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+static constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n /** Default coefficient used to estimate set difference for tx reconciliation. */\n static constexpr double DEFAULT_RECON_Q = 0.02;\n /** Used to convert a floating point reconciliation coefficient q to an int for transmission.\n@@ -111,6 +130,14 @@ class ReconciliationState {\n      */\n     std::set<uint256> m_local_set;\n \n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_local_short_id_mapping;\n+\n     /**\n      * A reconciliation request comes from a peer with a reconciliation set size from their side,\n      * which is supposed to help us to estimate set difference size. The value is stored here until\n@@ -208,6 +235,47 @@ class ReconciliationState {\n         m_remote_set_size = remote_set_size;\n         m_next_recon_respond = next_respond;\n     }\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity() const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(m_local_set.size()) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(m_local_set.size()), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.size() == 0 || capacity == 0) return sketch;\n+\n+        std::vector<uint32_t> short_ids;\n+        for (const auto& wtxid: m_local_set) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            short_ids.push_back(short_txid);\n+            m_local_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        if (sketch) {\n+            for (const uint32_t short_id: short_ids) {\n+                sketch.Add(short_id);\n+            }\n+        }\n+        return sketch;\n+    }\n };\n \n /**"
      }
    ]
  },
  {
    "sha": "0474bf74240a4caadf2860818548cd6d3f339c7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDc0YmY3NDI0MGE0Y2FhZGYyODYwODE4NTQ4Y2Q2ZDNmMzM5Yzdj",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:59:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Respond to a reconciliation request\n\nWhen the time comes, a node computes a sketch of the\nlocal transactions based on the parameters sent\nin the reconciliation request, and sends that sketch\nto the requestor. Clear local state.",
      "tree": {
        "sha": "6dc1e47dcbddfbd22079b6c0e8fa4e6d1ed610e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6dc1e47dcbddfbd22079b6c0e8fa4e6d1ed610e1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0474bf74240a4caadf2860818548cd6d3f339c7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474bf74240a4caadf2860818548cd6d3f339c7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0474bf74240a4caadf2860818548cd6d3f339c7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474bf74240a4caadf2860818548cd6d3f339c7c/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "244b59a48120a8fed7a378baf66b44efc5c14f01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/244b59a48120a8fed7a378baf66b44efc5c14f01",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/244b59a48120a8fed7a378baf66b44efc5c14f01"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 56,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f8d37037d7410d498ac07cdeffcc45fbc85033a7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474bf74240a4caadf2860818548cd6d3f339c7c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474bf74240a4caadf2860818548cd6d3f339c7c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0474bf74240a4caadf2860818548cd6d3f339c7c",
        "patch": "@@ -4962,6 +4962,16 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             }\n         }\n \n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            auto response_skdata = m_reconciliation.MaybeRespondToReconciliationRequest(pto->GetId());\n+            if (response_skdata) {\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::SKETCH, *response_skdata));\n+            }\n+        }\n+\n         // Detect whether we're stalling\n         current_time = GetTime<std::chrono::microseconds>();\n         if (state.nStallingSince && state.nStallingSince < count_microseconds(current_time) - 1000000 * BLOCK_STALLING_TIMEOUT) {"
      },
      {
        "sha": "e9e6da3d93a1fdf0f8d9492c4ebb4b962ffddfcf",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474bf74240a4caadf2860818548cd6d3f339c7c/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474bf74240a4caadf2860818548cd6d3f339c7c/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=0474bf74240a4caadf2860818548cd6d3f339c7c",
        "patch": "@@ -46,6 +46,7 @@ const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n+const char *SKETCH=\"sketch\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -88,6 +89,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::WTXIDRELAY,\n     NetMsgType::SENDRECON,\n     NetMsgType::REQRECON,\n+    NetMsgType::SKETCH,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "3438c6117d088df9e3d1ae4a855283b9d77d0f99",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474bf74240a4caadf2860818548cd6d3f339c7c/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474bf74240a4caadf2860818548cd6d3f339c7c/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=0474bf74240a4caadf2860818548cd6d3f339c7c",
        "patch": "@@ -274,6 +274,12 @@ extern const char *SENDRECON;\n  * Peer should respond with \"sketch\" message.\n  */\n extern const char *REQRECON;\n+/**\n+ * Contains a sketch of the local reconciliation set,\n+ * used to efficiently reconcile transactions.\n+ * Peer should respond with \"reconcildiff\" or \"reqsketchext\" message.\n+ */\n+extern const char *SKETCH;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "5570153787ffe56516ca5f30958d84964cfbf31f",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474bf74240a4caadf2860818548cd6d3f339c7c/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474bf74240a4caadf2860818548cd6d3f339c7c/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=0474bf74240a4caadf2860818548cd6d3f339c7c",
        "patch": "@@ -125,3 +125,30 @@ void TxReconciliationTracker::HandleReconciliationRequest(const NodeId peer_id,\n     recon_state->second.PrepareIncoming(peer_recon_set_size, peer_q_converted, NextReconRespond());\n     recon_state->second.UpdateIncomingPhase(RECON_INIT_REQUESTED);\n }\n+\n+Optional<std::vector<uint8_t>> TxReconciliationTracker::MaybeRespondToReconciliationRequest(const NodeId peer_id)\n+{\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return nullopt;\n+    if (!recon_state->second.IsRequestor()) return nullopt;\n+    // Respond to a requested reconciliation to enable efficient transaction exchange.\n+    // For initial requests, respond only periodically to a) limit CPU usage for sketch computation,\n+    // and, b) limit transaction possession privacy leak.\n+    // It's safe to respond to extension request without a delay because they are already limited by initial requests.\n+\n+    auto current_time = GetTime<std::chrono::microseconds>();\n+\n+    auto incoming_phase = recon_state->second.GetIncomingPhase();\n+    bool timely_initial_request = incoming_phase == RECON_INIT_REQUESTED && current_time > recon_state->second.GetNextRespond();\n+    if (!timely_initial_request) {\n+        return nullopt;\n+    }\n+\n+    std::vector<unsigned char> response_skdata;\n+    uint16_t sketch_capacity = recon_state->second.EstimateSketchCapacity();\n+    Minisketch sketch = recon_state->second.ComputeSketch(sketch_capacity);\n+    recon_state->second.UpdateIncomingPhase(RECON_INIT_RESPONDED);\n+    if (sketch) response_skdata = sketch.Serialize();\n+    return response_skdata;\n+}"
      },
      {
        "sha": "c142aa68f17794018be24a51110f01acaacac505",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474bf74240a4caadf2860818548cd6d3f339c7c/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474bf74240a4caadf2860818548cd6d3f339c7c/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=0474bf74240a4caadf2860818548cd6d3f339c7c",
        "patch": "@@ -57,6 +57,7 @@ static constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n enum ReconciliationPhase {\n     RECON_NONE,\n     RECON_INIT_REQUESTED,\n+    RECON_INIT_RESPONDED,\n };\n \n /**\n@@ -207,6 +208,11 @@ class ReconciliationState {\n         return m_outgoing_recon;\n     }\n \n+    std::chrono::microseconds GetNextRespond() const\n+    {\n+        return m_next_recon_respond;\n+    }\n+\n     void AddToReconSet(const std::vector<uint256>& txs_to_reconcile)\n     {\n         for (const auto& wtxid: txs_to_reconcile) {\n@@ -360,6 +366,11 @@ class TxReconciliationTracker {\n      */\n     void HandleReconciliationRequest(const NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q);\n \n+    /**\n+     * TODO document\n+     */\n+    Optional<std::vector<uint8_t>> MaybeRespondToReconciliationRequest(const NodeId peer_id);\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMTNiYzdmN2YxOWRiYWQzZjA2YjI5NTVmYzdjMGY3MDZmNjU4ZGNk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:22:01Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add a function to get wtxids by shortids\n\nAt the end of a reconciliation round, a peer may ask us\nfor transactions by their short id. Add a function for a local\nlookup short_id->wtxid.",
      "tree": {
        "sha": "97795de352668d10fc8a5d61f92e8a98d117f96e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97795de352668d10fc8a5d61f92e8a98d117f96e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0474bf74240a4caadf2860818548cd6d3f339c7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474bf74240a4caadf2860818548cd6d3f339c7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0474bf74240a4caadf2860818548cd6d3f339c7c"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 16,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3be5be7d54bced77f2b67ac5cf38f99473fdb117",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
        "patch": "@@ -282,6 +282,22 @@ class ReconciliationState {\n         }\n         return sketch;\n     }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_local_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_local_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n };\n \n /**"
      }
    ]
  },
  {
    "sha": "b99eded333bbc3895f21e10fad8cf5d973a5e877",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTllZGVkMzMzYmJjMzg5NWYyMWUxMGZhZDhjZjVkOTczYTVlODc3",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:07:43Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add a finalize reconciliation function\n\nThis currently unused function is supposed to be used once\na reconciliation round is done. It cleans the state corresponding\nto the passed reconciliation.",
      "tree": {
        "sha": "c08df2ead4fcc6c8a28158f1fc81087a9605f1fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c08df2ead4fcc6c8a28158f1fc81087a9605f1fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b99eded333bbc3895f21e10fad8cf5d973a5e877",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b99eded333bbc3895f21e10fad8cf5d973a5e877",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b99eded333bbc3895f21e10fad8cf5d973a5e877",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b99eded333bbc3895f21e10fad8cf5d973a5e877/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b13bc7f7f19dbad3f06b2955fc7c0f706f658dcd"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 60,
      "deletions": 0
    },
    "files": [
      {
        "sha": "efc5e2709b258e75dd3ec575e97fa9f19cde1e49",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b99eded333bbc3895f21e10fad8cf5d973a5e877/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b99eded333bbc3895f21e10fad8cf5d973a5e877/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=b99eded333bbc3895f21e10fad8cf5d973a5e877",
        "patch": "@@ -152,3 +152,27 @@ Optional<std::vector<uint8_t>> TxReconciliationTracker::MaybeRespondToReconcilia\n     if (sketch) response_skdata = sketch.Serialize();\n     return response_skdata;\n }\n+\n+std::vector<uint256> TxReconciliationTracker::FinalizeIncomingReconciliation(const NodeId peer_id,\n+    bool recon_result, const std::vector<uint32_t>& ask_shortids)\n+{\n+    std::vector<uint256> remote_missing;\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return remote_missing;\n+\n+    assert(recon_state->second.IsRequestor());\n+    const auto incoming_phase = recon_state->second.GetIncomingPhase();\n+    const bool phase_init_responded = incoming_phase == RECON_INIT_RESPONDED;\n+\n+    if (!phase_init_responded) return remote_missing;\n+\n+    if (recon_result) {\n+        remote_missing = recon_state->second.GetWTXIDsFromShortIDs(ask_shortids);\n+    } else {\n+        remote_missing = recon_state->second.GetLocalSet();\n+    }\n+    recon_state->second.FinalizeIncomingReconciliation();\n+    recon_state->second.UpdateIncomingPhase(RECON_NONE);\n+    return remote_missing;\n+}"
      },
      {
        "sha": "acf7d9b7b6f42b459b524f74bd48ad72f6006810",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b99eded333bbc3895f21e10fad8cf5d973a5e877/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b99eded333bbc3895f21e10fad8cf5d973a5e877/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=b99eded333bbc3895f21e10fad8cf5d973a5e877",
        "patch": "@@ -167,6 +167,11 @@ class ReconciliationState {\n         return short_txid;\n     }\n \n+    void ClearState()\n+    {\n+        m_local_short_id_mapping.clear();\n+    }\n+\n public:\n \n     ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :\n@@ -188,6 +193,11 @@ class ReconciliationState {\n         return m_responder;\n     }\n \n+    std::vector<uint256> GetLocalSet() const\n+    {\n+        return std::vector<uint256>(m_local_set.begin(), m_local_set.end());\n+    }\n+\n     uint16_t GetLocalSetSize() const\n     {\n         return m_local_set.size();\n@@ -298,6 +308,26 @@ class ReconciliationState {\n         }\n         return remote_missing;\n     }\n+\n+    /**\n+     * TODO document\n+     */\n+    void FinalizeIncomingReconciliation()\n+    {\n+        assert(m_requestor);\n+        ClearState();\n+    }\n+\n+    /**\n+     * TODO document\n+     */\n+    void FinalizeOutgoingReconciliation(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_responder);\n+        m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.clear();\n+        ClearState();\n+    }\n };\n \n /**\n@@ -387,6 +417,12 @@ class TxReconciliationTracker {\n      */\n     Optional<std::vector<uint8_t>> MaybeRespondToReconciliationRequest(const NodeId peer_id);\n \n+    /**\n+     * TODO document\n+     */\n+    std::vector<uint256> FinalizeIncomingReconciliation(const NodeId peer_id,\n+        bool recon_result, const std::vector<uint32_t>& ask_shortids);\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "05d7e5a21f0e64252724c860db6617919fcec1d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNWQ3ZTVhMjFmMGU2NDI1MjcyNGM4NjBkYjY2MTc5MTlmY2VjMWQ0",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:09:06Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add a function to identify local/remote missing txs\n\nWhen the sketches from both sides are combined successfully,\nthe diff is produced. Then this diff can (together with the local txs)\nbe used to identified which transactions are missing locally and remotely.",
      "tree": {
        "sha": "a12f67aec5138bee26b5d6561dbde95792422681",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a12f67aec5138bee26b5d6561dbde95792422681"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05d7e5a21f0e64252724c860db6617919fcec1d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d7e5a21f0e64252724c860db6617919fcec1d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05d7e5a21f0e64252724c860db6617919fcec1d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d7e5a21f0e64252724c860db6617919fcec1d4/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b99eded333bbc3895f21e10fad8cf5d973a5e877",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b99eded333bbc3895f21e10fad8cf5d973a5e877",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b99eded333bbc3895f21e10fad8cf5d973a5e877"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "33c461aa4b137e63ca2ce472db53a86524db5096",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05d7e5a21f0e64252724c860db6617919fcec1d4/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05d7e5a21f0e64252724c860db6617919fcec1d4/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=05d7e5a21f0e64252724c860db6617919fcec1d4",
        "patch": "@@ -328,6 +328,26 @@ class ReconciliationState {\n         if (clear_local_set) m_local_set.clear();\n         ClearState();\n     }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    std::pair<std::vector<uint32_t>, std::vector<uint256>> GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff) const\n+    {\n+        std::vector<uint32_t> local_missing;\n+        std::vector<uint256> remote_missing;\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_local_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_local_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+        return std::make_pair(local_missing, remote_missing);\n+    }\n };\n \n /**"
      }
    ]
  },
  {
    "sha": "c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDk4YTdmMGM5NTEwOTJmYjUzZjNmZDZlZjhkNTRhNDNkOWQxMDBj",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T17:08:54Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Handle reconciliation sketch and successful decoding\n\nSend/request missing transactions, clear the state,\nand send a finalization message.",
      "tree": {
        "sha": "9419215b508ccb33b97b226dca4cf9c552d6707d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9419215b508ccb33b97b226dca4cf9c552d6707d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05d7e5a21f0e64252724c860db6617919fcec1d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05d7e5a21f0e64252724c860db6617919fcec1d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05d7e5a21f0e64252724c860db6617919fcec1d4"
      }
    ],
    "stats": {
      "total": 127,
      "additions": 127,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f0961e498af30d2c3b1b287018a91bf6ce97afd8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "patch": "@@ -4144,6 +4144,21 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        auto result = m_reconciliation.HandleSketch(pfrom.GetId(), pfrom.GetCommonVersion(), skdata);\n+        if (result) {\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                std::get<0>(*result), std::get<1>(*result)));\n+            AnnounceTxs(std::get<2>(*result), pfrom);\n+        } else {\n+            pfrom.fDisconnect = true;\n+        }\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "169bb5a862ad9c8f0c02d7ce1f3f571b1a9038d0",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "patch": "@@ -47,6 +47,7 @@ const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n const char *SKETCH=\"sketch\";\n+const char *RECONCILDIFF=\"reconcildiff\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -90,6 +91,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::SENDRECON,\n     NetMsgType::REQRECON,\n     NetMsgType::SKETCH,\n+    NetMsgType::RECONCILDIFF,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "3cb3e8c2ee1178ba96af8534a2d56fc4d301d5ba",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "patch": "@@ -280,6 +280,11 @@ extern const char *REQRECON;\n  * Peer should respond with \"reconcildiff\" or \"reqsketchext\" message.\n  */\n extern const char *SKETCH;\n+/**\n+ * Indicates whether ongoing reconciliation has succeeded,\n+ * and requests the missing transactions by short ids.\n+ */\n+extern const char *RECONCILDIFF;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "a265202c7afd385b037bc088388badbf95cc3116",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "patch": "@@ -21,6 +21,43 @@ static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n     return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n }\n \n+\n+/**\n+* After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+* better accuracy of future set difference estimations.\n+* Recompute q in case of full reconciliation success (both initially or after extension).\n+* In case reconciliation completely failed (initial and extension), fallback to the default q,\n+* set to cause an overestimation, but should converge to the reasonable q in the next round.\n+* Note that accurate recompute in case of complete failure is difficult,\n+* because it requires waiting for GETDATA/INV the peer would send to us, and find\n+* the actual difference from there (also may be inaccurate due to the latencies).\n+*/\n+static double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    const uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    const uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    const uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    const uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        double result = double(actual_difference - set_size_diff) / min_size;\n+        assert(result >= 0 && result <= 2);\n+        return result;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+static Optional<std::pair<Minisketch, uint16_t>> ParseRemoteSketch(const ReconciliationState& recon_state,\n+    const std::vector<uint8_t>& skdata)\n+{\n+    uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+    if (remote_sketch_capacity != 0) {\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        return std::make_pair(remote_sketch, remote_sketch_capacity);\n+    } else {\n+        return nullopt;\n+    }\n+}\n+\n std::tuple<bool, bool, uint32_t, uint64_t> TxReconciliationTracker::SuggestReconciling(const NodeId peer_id, bool inbound)\n {\n     bool be_recon_requestor, be_recon_responder;\n@@ -176,3 +213,62 @@ std::vector<uint256> TxReconciliationTracker::FinalizeIncomingReconciliation(con\n     recon_state->second.UpdateIncomingPhase(RECON_NONE);\n     return remote_missing;\n }\n+\n+Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> TxReconciliationTracker::HandleSketch(\n+    const NodeId peer_id, int common_version, std::vector<uint8_t>& skdata)\n+{\n+    if (skdata.size() / BYTES_PER_SKETCH_CAPACITY > MAX_SKETCH_CAPACITY) {\n+        return nullopt;\n+    }\n+\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return nullopt;\n+\n+    assert(recon_state->second.IsResponder());\n+\n+    const auto outgoing_phase = recon_state->second.GetOutgoingPhase();\n+    const bool phase_init_requested = outgoing_phase == RECON_INIT_REQUESTED;\n+\n+    if (!phase_init_requested) return nullopt;\n+\n+    Minisketch remote_sketch;\n+    uint16_t remote_sketch_capacity = 0;\n+    auto parsed_remote_sketch = ParseRemoteSketch(recon_state->second, skdata);\n+    if (parsed_remote_sketch) {\n+        remote_sketch = (*parsed_remote_sketch).first;\n+        remote_sketch_capacity = (*parsed_remote_sketch).second;\n+    }\n+\n+    Minisketch local_sketch = recon_state->second.ComputeSketch(remote_sketch_capacity);\n+\n+    if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+        LogPrint(BCLog::NET, \"Outgoing reconciliation failed due to %s \\n\",\n+            remote_sketch_capacity == 0 ? \"empty sketch\" : \"minisketch API failure\");\n+        std::vector<uint256> remote_missing = recon_state->second.GetLocalSet();\n+        recon_state->second.FinalizeOutgoingReconciliation(true, DEFAULT_RECON_Q);\n+        recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n+        return std::make_tuple(false, std::vector<uint32_t>(), remote_missing);\n+    }\n+\n+    assert(remote_sketch);\n+    assert(local_sketch);\n+    // Attempt to decode the set difference\n+    std::vector<uint64_t> differences(remote_sketch_capacity);\n+    if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+        // Reconciliation over the current working sketch succeeded\n+        LogPrint(BCLog::NET, \"Outgoing reconciliation succeeded\\n\");\n+        auto missing_txs = recon_state->second.GetRelevantIDsFromShortIDs(differences);\n+        std::vector<uint32_t> local_missing = missing_txs.first;\n+        std::vector<uint256> remote_missing = missing_txs.second;\n+\n+        size_t local_set_size = recon_state->second.GetLocalSetSize();\n+        recon_state->second.FinalizeOutgoingReconciliation(true, RecomputeQ(local_set_size, local_missing.size(), remote_missing.size()));\n+        recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n+        return std::make_tuple(true, local_missing, remote_missing);\n+    } else {\n+        // Reconciliation over the current working sketch failed.\n+        // TODO handle failure.\n+        return nullopt;\n+    }\n+}"
      },
      {
        "sha": "b1cdb0335931c5ef81ca88c6fffa93eba81e05a4",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "patch": "@@ -443,6 +443,15 @@ class TxReconciliationTracker {\n     std::vector<uint256> FinalizeIncomingReconciliation(const NodeId peer_id,\n         bool recon_result, const std::vector<uint32_t>& ask_shortids);\n \n+    /**\n+     * Received a response to the reconciliation request. May leak tx-related privacy if we announce\n+     * local transactions right away, in case the peer is strategic about sending sketches to us via\n+     * different connections (requires attacker to occupy multiple outgoing connections).\n+     * Returns a response we should send to the peer, and the transactions we should announce.\n+     */\n+    Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> HandleSketch(\n+        const NodeId peer_id, int common_version, std::vector<uint8_t>& skdata);\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTM2N2I3MGJhMGQ0YzAzMDJkNDVkNDk0ZGMwNGVjYjFlYjdjZWEw",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T19:15:50Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Request extension if decoding failed\n\nIf after decoding a reconciliation sketch it turned out\nto be insufficient to find set difference, request extension.\nStore the initial sketches so that we are able to process\nextension sketch.",
      "tree": {
        "sha": "950a0290237e621d2fa39472f04e155e4ba71f81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/950a0290237e621d2fa39472f04e155e4ba71f81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c498a7f0c951092fb53f3fd6ef8d54a43d9d100c"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 61,
      "deletions": 10
    },
    "files": [
      {
        "sha": "84d8b54d80a05af69ed41a282d30d55d93352a57",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "patch": "@@ -4150,9 +4150,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         auto result = m_reconciliation.HandleSketch(pfrom.GetId(), pfrom.GetCommonVersion(), skdata);\n         if (result) {\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n-                std::get<0>(*result), std::get<1>(*result)));\n-            AnnounceTxs(std::get<2>(*result), pfrom);\n+            if (std::get<0>(*result)) {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    std::get<1>(*result), std::get<2>(*result)));\n+                AnnounceTxs(std::get<3>(*result), pfrom);\n+            } else {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n         } else {\n             pfrom.fDisconnect = true;\n         }"
      },
      {
        "sha": "9ceea093e6dacc8e599f95773d803e92fa4fd76f",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "patch": "@@ -48,6 +48,7 @@ const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n const char *SKETCH=\"sketch\";\n const char *RECONCILDIFF=\"reconcildiff\";\n+const char *REQSKETCHEXT=\"reqsketchext\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -92,6 +93,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::REQRECON,\n     NetMsgType::SKETCH,\n     NetMsgType::RECONCILDIFF,\n+    NetMsgType::REQSKETCHEXT,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "80bc5359d78a4f3c602dadbbaa8ba9336afd23ad",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "patch": "@@ -285,6 +285,10 @@ extern const char *SKETCH;\n  * and requests the missing transactions by short ids.\n  */\n extern const char *RECONCILDIFF;\n+/**\n+ * Requests a sketch extension for ongoing reconciliation.\n+ */\n+extern const char *REQSKETCHEXT;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "e43c1df73272d76f276cc890e4b196462b65e3db",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "patch": "@@ -214,7 +214,7 @@ std::vector<uint256> TxReconciliationTracker::FinalizeIncomingReconciliation(con\n     return remote_missing;\n }\n \n-Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> TxReconciliationTracker::HandleSketch(\n+Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> TxReconciliationTracker::HandleSketch(\n     const NodeId peer_id, int common_version, std::vector<uint8_t>& skdata)\n {\n     if (skdata.size() / BYTES_PER_SKETCH_CAPACITY > MAX_SKETCH_CAPACITY) {\n@@ -248,7 +248,7 @@ Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> TxReconc\n         std::vector<uint256> remote_missing = recon_state->second.GetLocalSet();\n         recon_state->second.FinalizeOutgoingReconciliation(true, DEFAULT_RECON_Q);\n         recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n-        return std::make_tuple(false, std::vector<uint32_t>(), remote_missing);\n+        return std::make_tuple(true, false, std::vector<uint32_t>(), remote_missing);\n     }\n \n     assert(remote_sketch);\n@@ -265,10 +265,13 @@ Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> TxReconc\n         size_t local_set_size = recon_state->second.GetLocalSetSize();\n         recon_state->second.FinalizeOutgoingReconciliation(true, RecomputeQ(local_set_size, local_missing.size(), remote_missing.size()));\n         recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n-        return std::make_tuple(true, local_missing, remote_missing);\n+        return std::make_tuple(true, true, local_missing, remote_missing);\n     } else {\n-        // Reconciliation over the current working sketch failed.\n-        // TODO handle failure.\n-        return nullopt;\n+        // Initial reconciliation failed.\n+        // Store the received sketch and the local sketch, request extension.\n+        LogPrint(BCLog::NET, \"Outgoing reconciliation initially failed, requesting extension sketch\\n\");\n+        recon_state->second.UpdateOutgoingPhase(RECON_EXT_REQUESTED);\n+        recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+        return std::make_tuple(false, false, std::vector<uint32_t>(), std::vector<uint256>());\n     }\n }"
      },
      {
        "sha": "becf29e14718531f387650e2457fae47a471d641",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "patch": "@@ -58,6 +58,7 @@ enum ReconciliationPhase {\n     RECON_NONE,\n     RECON_INIT_REQUESTED,\n     RECON_INIT_RESPONDED,\n+    RECON_EXT_REQUESTED,\n };\n \n /**\n@@ -131,6 +132,22 @@ class ReconciliationState {\n      */\n     std::set<uint256> m_local_set;\n \n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    std::set<uint256> m_local_set_snapshot;\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n     /**\n      * Reconciliation sketches are computed over short transaction IDs.\n      * This is a cache of these IDs enabling faster lookups of full wtxids,\n@@ -146,6 +163,13 @@ class ReconciliationState {\n      */\n     uint16_t m_remote_set_size;\n \n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n     /**\n      * When a reconciliation request is received, instead of responding to it right away,\n      * we schedule a response for later, so that a spy can\u2019t monitor our reconciliation sets.\n@@ -170,6 +194,8 @@ class ReconciliationState {\n     void ClearState()\n     {\n         m_local_short_id_mapping.clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_remote_sketch_snapshot.clear();\n     }\n \n public:\n@@ -348,6 +374,18 @@ class ReconciliationState {\n         }\n         return std::make_pair(local_missing, remote_missing);\n     }\n+\n+    /**\n+     * TODO document\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_responder);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.clear();\n+    }\n };\n \n /**\n@@ -449,7 +487,7 @@ class TxReconciliationTracker {\n      * different connections (requires attacker to occupy multiple outgoing connections).\n      * Returns a response we should send to the peer, and the transactions we should announce.\n      */\n-    Optional<std::tuple<bool, std::vector<uint32_t>, std::vector<uint256>>> HandleSketch(\n+    Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> HandleSketch(\n         const NodeId peer_id, int common_version, std::vector<uint8_t>& skdata);\n \n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const"
      }
    ]
  },
  {
    "sha": "7db69870b6d96ea84fea922cb5b974536853f4a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZGI2OTg3MGI2ZDk2ZWE4NGZlYTkyMmNiNWI5NzQ1MzY4NTNmNGEz",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T19:22:15Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Handle reconciliation extension request\n\nIf peer failed to reconcile based on our initial response sketch,\nthey will ask us for a sketch extension. Store this request to respond later.",
      "tree": {
        "sha": "46216477170cf8e734f3d7ea943ced6a05b21962",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/46216477170cf8e734f3d7ea943ced6a05b21962"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7db69870b6d96ea84fea922cb5b974536853f4a3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7db69870b6d96ea84fea922cb5b974536853f4a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7db69870b6d96ea84fea922cb5b974536853f4a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7db69870b6d96ea84fea922cb5b974536853f4a3/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be367b70ba0d4c0302d45d494dc04ecb1eb7cea0"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 21,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dbb8cdcd81c905492943a8d34743f175083ef6af",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7db69870b6d96ea84fea922cb5b974536853f4a3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7db69870b6d96ea84fea922cb5b974536853f4a3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7db69870b6d96ea84fea922cb5b974536853f4a3",
        "patch": "@@ -4163,6 +4163,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQSKETCHEXT) {\n+        m_reconciliation.HandleIncomingExtensionRequest(pfrom.GetId());\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "12fda5e12ea45e6c74b596604ebfc02c588ed1f9",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7db69870b6d96ea84fea922cb5b974536853f4a3/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7db69870b6d96ea84fea922cb5b974536853f4a3/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=7db69870b6d96ea84fea922cb5b974536853f4a3",
        "patch": "@@ -275,3 +275,12 @@ Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> Tx\n         return std::make_tuple(false, false, std::vector<uint32_t>(), std::vector<uint256>());\n     }\n }\n+\n+void TxReconciliationTracker::HandleIncomingExtensionRequest(const NodeId peer_id)\n+{\n+    LOCK(m_states_mutex);\n+    auto recon_state = m_states.find(peer_id);\n+    if (recon_state == m_states.end()) return;\n+    if (recon_state->second.GetIncomingPhase() != RECON_INIT_RESPONDED) return;\n+    recon_state->second.UpdateIncomingPhase(RECON_EXT_REQUESTED);\n+}"
      },
      {
        "sha": "f7746379803c0d6f5c959b21e747728a55ab9561",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7db69870b6d96ea84fea922cb5b974536853f4a3/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7db69870b6d96ea84fea922cb5b974536853f4a3/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=7db69870b6d96ea84fea922cb5b974536853f4a3",
        "patch": "@@ -490,6 +490,13 @@ class TxReconciliationTracker {\n     Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> HandleSketch(\n         const NodeId peer_id, int common_version, std::vector<uint8_t>& skdata);\n \n+    /**\n+     * Peer requesting extension after initial reconciliation failed on their side.\n+     * No privacy leak can happen here because sketch extension is constructed over the snapshot.\n+     */\n+    void HandleIncomingExtensionRequest(const NodeId peer_id);\n+\n+\n     Optional<ReconciliationState> GetPeerState(const NodeId peer_id) const\n     {\n         // This does not compile if this function is marked const. Not sure how to fix this."
      }
    ]
  },
  {
    "sha": "15f9a956cd2104cf53eb326b31a8abf054732349",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNWY5YTk1NmNkMjEwNGNmNTNlYjMyNmIzMWE4YWJmMDU0NzMyMzQ5",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T19:29:00Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Prepare to responding to extension requests\n\nAdd 2 variables tracking reconciliation state:\n(1) recon set snapshot and (2) capacity snapshot.\n(1) is used to store transactions arrived after we sent out\nan initial sketch, but before the reconciliation is over, since\nthese transactions should not go into a sketch extension.\n(2) is used to set the capacity of the extended sketch because\nit provides good estimation (efficiency/failure tradeoff).",
      "tree": {
        "sha": "0743c5e683477dfd15b489edc425cf0232a2c719",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0743c5e683477dfd15b489edc425cf0232a2c719"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/15f9a956cd2104cf53eb326b31a8abf054732349",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15f9a956cd2104cf53eb326b31a8abf054732349",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/15f9a956cd2104cf53eb326b31a8abf054732349",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15f9a956cd2104cf53eb326b31a8abf054732349/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7db69870b6d96ea84fea922cb5b974536853f4a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7db69870b6d96ea84fea922cb5b974536853f4a3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7db69870b6d96ea84fea922cb5b974536853f4a3"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 17,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1b9745f85277a7b463cd1fa5d315299b719ea6ce",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15f9a956cd2104cf53eb326b31a8abf054732349/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15f9a956cd2104cf53eb326b31a8abf054732349/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=15f9a956cd2104cf53eb326b31a8abf054732349",
        "patch": "@@ -186,6 +186,7 @@ Optional<std::vector<uint8_t>> TxReconciliationTracker::MaybeRespondToReconcilia\n     uint16_t sketch_capacity = recon_state->second.EstimateSketchCapacity();\n     Minisketch sketch = recon_state->second.ComputeSketch(sketch_capacity);\n     recon_state->second.UpdateIncomingPhase(RECON_INIT_RESPONDED);\n+    recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n     if (sketch) response_skdata = sketch.Serialize();\n     return response_skdata;\n }"
      },
      {
        "sha": "f8ce97993507d3ed3a8b531d3780838d21e3e0d3",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15f9a956cd2104cf53eb326b31a8abf054732349/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15f9a956cd2104cf53eb326b31a8abf054732349/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=15f9a956cd2104cf53eb326b31a8abf054732349",
        "patch": "@@ -196,6 +196,8 @@ class ReconciliationState {\n         m_local_short_id_mapping.clear();\n         // This is currently belt-and-suspenders, as the code should work even without these calls.\n         m_remote_sketch_snapshot.clear();\n+        m_local_set_snapshot.clear();\n+        m_capacity_snapshot = 0;\n     }\n \n public:\n@@ -375,6 +377,20 @@ class ReconciliationState {\n         return std::make_pair(local_missing, remote_missing);\n     }\n \n+    /**\n+     * TODO document\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        // Be ready to respond to extension request, to compute the extended sketch over\n+        // the same initial set (without transactions received during the reconciliation).\n+        // Allow to store new transactions separately in the original set.\n+        assert(m_requestor);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.clear();\n+    }\n+\n     /**\n      * TODO document\n      */"
      }
    ]
  },
  {
    "sha": "5b0303a631674a6206e895db5ab14c41cfd53ec4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjAzMDNhNjMxNjc0YTYyMDZlODk1ZGI1YWIxNGM0MWNmZDUzZWM0",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T10:12:35Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Respond to an extension request\n\nCompute a sketch with extra capacity and send\nthose extra syndromes to the peer.\nIt is safe to respond to an extension request without a delay\nbecause these requests are already limited by initial requests.",
      "tree": {
        "sha": "28a3f1cc916deba3965908212c12b4c5defc412c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28a3f1cc916deba3965908212c12b4c5defc412c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b0303a631674a6206e895db5ab14c41cfd53ec4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b0303a631674a6206e895db5ab14c41cfd53ec4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b0303a631674a6206e895db5ab14c41cfd53ec4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b0303a631674a6206e895db5ab14c41cfd53ec4/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "15f9a956cd2104cf53eb326b31a8abf054732349",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15f9a956cd2104cf53eb326b31a8abf054732349",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/15f9a956cd2104cf53eb326b31a8abf054732349"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 75,
      "deletions": 31
    },
    "files": [
      {
        "sha": "818240ecb8f77aa5264fcbfc6e7d3207902ef036",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 7,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b0303a631674a6206e895db5ab14c41cfd53ec4/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b0303a631674a6206e895db5ab14c41cfd53ec4/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=5b0303a631674a6206e895db5ab14c41cfd53ec4",
        "patch": "@@ -178,16 +178,32 @@ Optional<std::vector<uint8_t>> TxReconciliationTracker::MaybeRespondToReconcilia\n \n     auto incoming_phase = recon_state->second.GetIncomingPhase();\n     bool timely_initial_request = incoming_phase == RECON_INIT_REQUESTED && current_time > recon_state->second.GetNextRespond();\n-    if (!timely_initial_request) {\n+    bool extension_request = incoming_phase == RECON_EXT_REQUESTED;\n+    if (!timely_initial_request && !extension_request) {\n         return nullopt;\n     }\n \n     std::vector<unsigned char> response_skdata;\n-    uint16_t sketch_capacity = recon_state->second.EstimateSketchCapacity();\n-    Minisketch sketch = recon_state->second.ComputeSketch(sketch_capacity);\n-    recon_state->second.UpdateIncomingPhase(RECON_INIT_RESPONDED);\n-    recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n-    if (sketch) response_skdata = sketch.Serialize();\n+    Minisketch sketch;\n+    if (timely_initial_request) {\n+        uint16_t sketch_capacity = recon_state->second.EstimateSketchCapacity();\n+        sketch = recon_state->second.GetLocalBaseSketch(sketch_capacity);\n+        recon_state->second.UpdateIncomingPhase(RECON_INIT_RESPONDED);\n+        recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n+        if (sketch) response_skdata = sketch.Serialize();\n+    } else {\n+        sketch = recon_state->second.GetLocalExtendedSketch();\n+        recon_state->second.UpdateIncomingPhase(RECON_EXT_RESPONDED);\n+        // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+        // in which case we would have terminated reconciliation already.\n+        assert(sketch);\n+        response_skdata = sketch.Serialize();\n+        // For the sketch extension, send only the higher sketch elements.\n+        size_t lower_bytes_to_drop = recon_state->second.GetCapacitySnapshot() * BYTES_PER_SKETCH_CAPACITY;\n+        // Extended sketch is twice the size of the initial sketch (which is m_capacity_snapshot).\n+        assert(lower_bytes_to_drop <= response_skdata.size());\n+        response_skdata.erase(response_skdata.begin(), response_skdata.begin() + lower_bytes_to_drop);\n+    }\n     return response_skdata;\n }\n \n@@ -241,7 +257,7 @@ Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> Tx\n         remote_sketch_capacity = (*parsed_remote_sketch).second;\n     }\n \n-    Minisketch local_sketch = recon_state->second.ComputeSketch(remote_sketch_capacity);\n+    Minisketch local_sketch = recon_state->second.GetLocalBaseSketch(remote_sketch_capacity);\n \n     if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n         LogPrint(BCLog::NET, \"Outgoing reconciliation failed due to %s \\n\","
      },
      {
        "sha": "83985efc3d04c10fb9223f7186b10c1021a31374",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 52,
        "deletions": 24,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b0303a631674a6206e895db5ab14c41cfd53ec4/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b0303a631674a6206e895db5ab14c41cfd53ec4/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=5b0303a631674a6206e895db5ab14c41cfd53ec4",
        "patch": "@@ -59,6 +59,7 @@ enum ReconciliationPhase {\n     RECON_INIT_REQUESTED,\n     RECON_INIT_RESPONDED,\n     RECON_EXT_REQUESTED,\n+    RECON_EXT_RESPONDED\n };\n \n /**\n@@ -200,6 +201,42 @@ class ReconciliationState {\n         m_capacity_snapshot = 0;\n     }\n \n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330). Considering whether we are going to send a sketch to a peer or use\n+     * locally, we estimate the set difference.\n+     */\n+    Minisketch ComputeSketch(uint16_t capacity, bool use_snapshot=false)\n+    {\n+        Minisketch sketch;\n+        std::set<uint256> working_set;\n+        if (use_snapshot) {\n+            working_set = m_local_set_snapshot;\n+        } else {\n+            working_set = m_local_set;\n+            m_capacity_snapshot = capacity;\n+        }\n+        // Avoid serializing/sending an empty sketch.\n+        if (working_set.size() == 0 || capacity == 0) return sketch;\n+\n+        std::vector<uint32_t> short_ids;\n+        for (const auto& wtxid: working_set) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            short_ids.push_back(short_txid);\n+            m_local_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        if (sketch) {\n+            for (const uint32_t short_id: short_ids) {\n+                sketch.Add(short_id);\n+            }\n+        }\n+        return sketch;\n+    }\n+\n public:\n \n     ReconciliationState(bool requestor, bool responder, bool flood_to, uint64_t k0, uint64_t k1) :\n@@ -236,6 +273,11 @@ class ReconciliationState {\n         return m_local_q * Q_PRECISION;\n     }\n \n+    uint16_t GetCapacitySnapshot() const\n+    {\n+        return m_capacity_snapshot;\n+    }\n+\n     ReconciliationPhase GetIncomingPhase() const\n     {\n         return m_incoming_recon;\n@@ -293,32 +335,18 @@ class ReconciliationState {\n         return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n     }\n \n-    /**\n-     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n-     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n-     * of elements (see BIP-330).\n-     */\n-    Minisketch ComputeSketch(uint16_t capacity)\n+    Minisketch GetLocalBaseSketch(uint16_t capacity)\n     {\n-        Minisketch sketch;\n-        // Avoid serializing/sending an empty sketch.\n-        if (m_local_set.size() == 0 || capacity == 0) return sketch;\n-\n-        std::vector<uint32_t> short_ids;\n-        for (const auto& wtxid: m_local_set) {\n-            uint32_t short_txid = ComputeShortID(wtxid);\n-            short_ids.push_back(short_txid);\n-            m_local_short_id_mapping.emplace(short_txid, wtxid);\n-        }\n+        return ComputeSketch(capacity, false);\n+    }\n \n-        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n-        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n-        if (sketch) {\n-            for (const uint32_t short_id: short_ids) {\n-                sketch.Add(short_id);\n-            }\n-        }\n-        return sketch;\n+    Minisketch GetLocalExtendedSketch()\n+    {\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        const uint16_t extended_capacity = m_capacity_snapshot * 2;\n+        return ComputeSketch(extended_capacity, true);\n     }\n \n     /**"
      }
    ]
  },
  {
    "sha": "ea6b07b84d42ef7574c4bd46b28c22570841d376",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYTZiMDdiODRkNDJlZjc1NzRjNGJkNDZiMjhjMjI1NzA4NDFkMzc2",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T10:27:03Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Handle extension sketch\n\nIf a peer responded to our request with a sketch extension,\nattempt to decode it to find missing transactions by combining\nit with the initial sketch.\nIf success, share/request missing transactions.\nIf failure, send all the transactions we had for the peer.",
      "tree": {
        "sha": "889219bf8edbadbac7284ddc9d7b682f643bd52f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/889219bf8edbadbac7284ddc9d7b682f643bd52f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ea6b07b84d42ef7574c4bd46b28c22570841d376",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea6b07b84d42ef7574c4bd46b28c22570841d376",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ea6b07b84d42ef7574c4bd46b28c22570841d376",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea6b07b84d42ef7574c4bd46b28c22570841d376/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b0303a631674a6206e895db5ab14c41cfd53ec4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b0303a631674a6206e895db5ab14c41cfd53ec4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b0303a631674a6206e895db5ab14c41cfd53ec4"
      }
    ],
    "stats": {
      "total": 81,
      "additions": 62,
      "deletions": 19
    },
    "files": [
      {
        "sha": "b05bda33075b405691154f88bda676bb60edbb22",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ea6b07b84d42ef7574c4bd46b28c22570841d376",
        "patch": "@@ -4950,7 +4950,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     // Populating local reconciliation set.\n                     if (recon_state && txs_to_reconcile.size() != 0) {\n                         std::vector<uint256> txs_to_flood;\n-                        int32_t recon_set_overflow = recon_state->GetLocalSetSize() + txs_to_reconcile.size() - MAX_PEER_TX_ANNOUNCEMENTS;\n+                        int32_t recon_set_overflow = recon_state->GetLocalSetSize(false) + txs_to_reconcile.size() - MAX_PEER_TX_ANNOUNCEMENTS;\n                         if (recon_set_overflow > 0) {\n                             LogPrint(BCLog::NET, \"Reconciliation set for the peer=%d is at capacity, not adding %i new transactions. \\n\", pto->GetId(), recon_set_overflow);\n                             // Since we reconcile frequently, it either means:"
      },
      {
        "sha": "0e4fe432b4509a029a62ddeba206fe95f645c058",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 15,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=ea6b07b84d42ef7574c4bd46b28c22570841d376",
        "patch": "@@ -47,8 +47,15 @@ static double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, u\n }\n \n static Optional<std::pair<Minisketch, uint16_t>> ParseRemoteSketch(const ReconciliationState& recon_state,\n-    const std::vector<uint8_t>& skdata)\n+    std::vector<uint8_t> skdata)\n {\n+    std::vector<uint8_t> remote_sketch_snapshot = recon_state.GetRemoteSketchSnapshot();\n+\n+    if (remote_sketch_snapshot.size() > 0) {\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        skdata.insert(skdata.begin(), remote_sketch_snapshot.begin(), remote_sketch_snapshot.end());\n+    }\n     uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n     if (remote_sketch_capacity != 0) {\n         Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n@@ -142,7 +149,7 @@ Optional<std::pair<uint16_t, uint16_t>> TxReconciliationTracker::MaybeRequestRec\n             m_queue.pop_back();\n             m_queue.push_front(peer_id);\n             UpdateNextReconRequest(current_time);\n-            return std::make_pair(recon_state->second.GetLocalSetSize(), recon_state->second.GetLocalQ());\n+            return std::make_pair(recon_state->second.GetLocalSetSize(false), recon_state->second.GetLocalQ());\n         }\n     }\n     return nullopt;\n@@ -218,13 +225,14 @@ std::vector<uint256> TxReconciliationTracker::FinalizeIncomingReconciliation(con\n     assert(recon_state->second.IsRequestor());\n     const auto incoming_phase = recon_state->second.GetIncomingPhase();\n     const bool phase_init_responded = incoming_phase == RECON_INIT_RESPONDED;\n+    const bool phase_ext_responded = incoming_phase == RECON_EXT_RESPONDED;\n \n-    if (!phase_init_responded) return remote_missing;\n+    if (!phase_init_responded && !phase_ext_responded) return remote_missing;\n \n     if (recon_result) {\n         remote_missing = recon_state->second.GetWTXIDsFromShortIDs(ask_shortids);\n     } else {\n-        remote_missing = recon_state->second.GetLocalSet();\n+        remote_missing = recon_state->second.GetLocalSet(phase_ext_responded);\n     }\n     recon_state->second.FinalizeIncomingReconciliation();\n     recon_state->second.UpdateIncomingPhase(RECON_NONE);\n@@ -246,8 +254,9 @@ Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> Tx\n \n     const auto outgoing_phase = recon_state->second.GetOutgoingPhase();\n     const bool phase_init_requested = outgoing_phase == RECON_INIT_REQUESTED;\n+    const bool phase_ext_requested = outgoing_phase == RECON_EXT_REQUESTED;\n \n-    if (!phase_init_requested) return nullopt;\n+    if (!phase_init_requested && !phase_ext_requested) return nullopt;\n \n     Minisketch remote_sketch;\n     uint16_t remote_sketch_capacity = 0;\n@@ -257,13 +266,23 @@ Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> Tx\n         remote_sketch_capacity = (*parsed_remote_sketch).second;\n     }\n \n-    Minisketch local_sketch = recon_state->second.GetLocalBaseSketch(remote_sketch_capacity);\n+    Minisketch local_sketch;\n+\n+    if (phase_init_requested) {\n+        local_sketch = recon_state->second.GetLocalBaseSketch(remote_sketch_capacity);\n+    } else {\n+        local_sketch = recon_state->second.GetLocalExtendedSketch();\n+    }\n \n     if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n         LogPrint(BCLog::NET, \"Outgoing reconciliation failed due to %s \\n\",\n             remote_sketch_capacity == 0 ? \"empty sketch\" : \"minisketch API failure\");\n-        std::vector<uint256> remote_missing = recon_state->second.GetLocalSet();\n-        recon_state->second.FinalizeOutgoingReconciliation(true, DEFAULT_RECON_Q);\n+        std::vector<uint256> remote_missing = recon_state->second.GetLocalSet(phase_ext_requested);\n+        if (phase_init_requested) {\n+            recon_state->second.FinalizeOutgoingReconciliation(true, DEFAULT_RECON_Q);\n+        } else {\n+            recon_state->second.FinalizeOutgoingReconciliation(false, DEFAULT_RECON_Q);\n+        }\n         recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n         return std::make_tuple(true, false, std::vector<uint32_t>(), remote_missing);\n     }\n@@ -279,17 +298,31 @@ Optional<std::tuple<bool, bool, std::vector<uint32_t>, std::vector<uint256>>> Tx\n         std::vector<uint32_t> local_missing = missing_txs.first;\n         std::vector<uint256> remote_missing = missing_txs.second;\n \n-        size_t local_set_size = recon_state->second.GetLocalSetSize();\n+        size_t local_set_size = recon_state->second.GetLocalSetSize(phase_ext_requested);\n         recon_state->second.FinalizeOutgoingReconciliation(true, RecomputeQ(local_set_size, local_missing.size(), remote_missing.size()));\n         recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n         return std::make_tuple(true, true, local_missing, remote_missing);\n     } else {\n-        // Initial reconciliation failed.\n-        // Store the received sketch and the local sketch, request extension.\n-        LogPrint(BCLog::NET, \"Outgoing reconciliation initially failed, requesting extension sketch\\n\");\n-        recon_state->second.UpdateOutgoingPhase(RECON_EXT_REQUESTED);\n-        recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n-        return std::make_tuple(false, false, std::vector<uint32_t>(), std::vector<uint256>());\n+        // Reconciliation over the current working sketch failed.\n+        if (recon_state->second.GetOutgoingPhase() == RECON_INIT_REQUESTED) {\n+            // Initial reconciliation failed.\n+            // Store the received sketch and the local sketch, request extension.\n+            LogPrint(BCLog::NET, \"Outgoing reconciliation initially failed, requesting extension sketch\\n\");\n+            recon_state->second.UpdateOutgoingPhase(RECON_EXT_REQUESTED);\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            return std::make_tuple(false, false, std::vector<uint32_t>(), std::vector<uint256>());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer due to the reconciliation\n+            // failure flag.\n+\n+            LogPrint(BCLog::NET, \"Outgoing reconciliation failed after extension\\n\");\n+            std::vector<uint256> remote_missing = recon_state->second.GetLocalSet(true);\n+            recon_state->second.FinalizeOutgoingReconciliation(false, DEFAULT_RECON_Q);\n+            recon_state->second.UpdateOutgoingPhase(RECON_NONE);\n+            return std::make_tuple(true, false, std::vector<uint32_t>(), remote_missing);\n+        }\n     }\n }\n "
      },
      {
        "sha": "a0b554872f2b0ae1e4101fcfb0b1b8db1c0b24f8",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea6b07b84d42ef7574c4bd46b28c22570841d376/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=ea6b07b84d42ef7574c4bd46b28c22570841d376",
        "patch": "@@ -258,13 +258,18 @@ class ReconciliationState {\n         return m_responder;\n     }\n \n-    std::vector<uint256> GetLocalSet() const\n+    std::vector<uint256> GetLocalSet(bool snapshot) const\n     {\n-        return std::vector<uint256>(m_local_set.begin(), m_local_set.end());\n+        if (snapshot) {\n+            return std::vector<uint256>(m_local_set_snapshot.begin(), m_local_set_snapshot.end());\n+        } else {\n+            return std::vector<uint256>(m_local_set.begin(), m_local_set.end());\n+        }\n     }\n \n-    uint16_t GetLocalSetSize() const\n+    uint16_t GetLocalSetSize(bool snapshot) const\n     {\n+        if (snapshot) return m_local_set_snapshot.size();\n         return m_local_set.size();\n     }\n \n@@ -273,6 +278,11 @@ class ReconciliationState {\n         return m_local_q * Q_PRECISION;\n     }\n \n+    std::vector<uint8_t> GetRemoteSketchSnapshot() const\n+    {\n+        return m_remote_sketch_snapshot;\n+    }\n+\n     uint16_t GetCapacitySnapshot() const\n     {\n         return m_capacity_snapshot;"
      }
    ]
  },
  {
    "sha": "d578090d977385f8bac4c1bd052942ab570e8d7b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTc4MDkwZDk3NzM4NWY4YmFjNGMxYmQwNTI5NDJhYjU3MGU4ZDdi",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T10:29:31Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Handle reconciliation finalization message\n\nOnce a peer tells us reconciliation is done, we should behave as follows:\n- if it was successful, just respond them with the transactions they asked\n  by short ID.\n- if it was a full failure, respond with all local transactions from the reconciliation\n  set snapshot\n- if it was a partial failure (only low or high part was failed after a bisection),\n  respond with all transactions which were asked for by short id,\n  and announce local txs which belong to the failed chunk.",
      "tree": {
        "sha": "4134abe0ffb183d5cf8119467c7c7f1414a54115",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4134abe0ffb183d5cf8119467c7c7f1414a54115"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d578090d977385f8bac4c1bd052942ab570e8d7b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d578090d977385f8bac4c1bd052942ab570e8d7b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d578090d977385f8bac4c1bd052942ab570e8d7b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d578090d977385f8bac4c1bd052942ab570e8d7b/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ea6b07b84d42ef7574c4bd46b28c22570841d376",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea6b07b84d42ef7574c4bd46b28c22570841d376",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ea6b07b84d42ef7574c4bd46b28c22570841d376"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "06f0e792119531f6e8ccafff9f8d165520546705",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d578090d977385f8bac4c1bd052942ab570e8d7b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d578090d977385f8bac4c1bd052942ab570e8d7b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d578090d977385f8bac4c1bd052942ab570e8d7b",
        "patch": "@@ -4168,6 +4168,19 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Among transactions requested by short ID here, we should send only those transactions\n+    // sketched (stored in local set snapshot), because otherwise we would leak privacy (mempool content).\n+    if (msg_type == NetMsgType::RECONCILDIFF) {\n+        bool recon_result;\n+        std::vector<uint32_t> ask_shortids;\n+        vRecv >> recon_result >> ask_shortids;\n+\n+        std::vector<uint256> remote_missing =\n+            m_reconciliation.FinalizeIncomingReconciliation(pfrom.GetId(), recon_result, ask_shortids);\n+        AnnounceTxs(remote_missing, pfrom);\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      }
    ]
  },
  {
    "sha": "b843662818a3ef54ab0ad75b108717c190be8812",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODQzNjYyODE4YTNlZjU0YWIwYWQ3NWIxMDg3MTdjMTkwYmU4ODEy",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-07-24T13:16:48Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "tests: support (inbound) connecting to mininode",
      "tree": {
        "sha": "b8a7ea639974bb598404bba9aa3950482c92e7cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b8a7ea639974bb598404bba9aa3950482c92e7cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b843662818a3ef54ab0ad75b108717c190be8812",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b843662818a3ef54ab0ad75b108717c190be8812",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b843662818a3ef54ab0ad75b108717c190be8812",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b843662818a3ef54ab0ad75b108717c190be8812/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d578090d977385f8bac4c1bd052942ab570e8d7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d578090d977385f8bac4c1bd052942ab570e8d7b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d578090d977385f8bac4c1bd052942ab570e8d7b"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 20,
      "deletions": 2
    },
    "files": [
      {
        "sha": "5b8a1512bf57d4bff9af11e6064e1b0b278e69c9",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 19,
        "deletions": 2,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b843662818a3ef54ab0ad75b108717c190be8812/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b843662818a3ef54ab0ad75b108717c190be8812/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=b843662818a3ef54ab0ad75b108717c190be8812",
        "patch": "@@ -24,6 +24,7 @@\n from collections import defaultdict\n from io import BytesIO\n import logging\n+import socket\n import struct\n import sys\n import threading\n@@ -164,12 +165,28 @@ def peer_connect_helper(self, dstaddr, dstport, net, timeout_factor):\n         self.recvbuf = b\"\"\n         self.magic_bytes = MAGIC_BYTES[net]\n \n-    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor):\n+    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor, node_outgoing=False):\n         self.peer_connect_helper(dstaddr, dstport, net, timeout_factor)\n \n         loop = NetworkThread.network_event_loop\n         logger.debug('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n-        coroutine = loop.create_connection(lambda: self, host=self.dstaddr, port=self.dstport)\n+        self.node_outgoing = node_outgoing\n+\n+        if self.node_outgoing:\n+            listen_sock = socket.socket()\n+            listen_sock.bind(('127.0.0.1', 0))\n+            listen_sock.listen(1)\n+            listen_port = listen_sock.getsockname()[1]\n+            self.rpc.addnode('127.0.0.1:%u' % (listen_port,), 'onetry')\n+            (sock, addr) = listen_sock.accept()\n+            assert sock\n+            listen_sock.close()\n+            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n+            sock.setblocking(False)\n+            coroutine = loop.create_connection(lambda: self, sock=sock)\n+        else:\n+            coroutine = loop.create_connection(lambda: self, host=self.dstaddr, port=self.dstport)\n+\n         return lambda: loop.call_soon_threadsafe(loop.create_task, coroutine)\n \n     def peer_accept_connection(self, connect_id, connect_cb=lambda: None, *, net, timeout_factor):"
      },
      {
        "sha": "3fc4f589c45d269b89cb80b92b606e1bca53d57e",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b843662818a3ef54ab0ad75b108717c190be8812/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b843662818a3ef54ab0ad75b108717c190be8812/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=b843662818a3ef54ab0ad75b108717c190be8812",
        "patch": "@@ -530,6 +530,7 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, **kwargs):\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n+        p2p_conn.rpc = self\n         p2p_conn.peer_connect(**kwargs, net=self.chain, timeout_factor=self.timeout_factor)()\n         self.p2ps.append(p2p_conn)\n         p2p_conn.wait_until(lambda: p2p_conn.is_connected, check_connected=False)"
      }
    ]
  },
  {
    "sha": "108748f1ebf3b1f81375eefbc4a4a124b8234145",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDg3NDhmMWViZjNiMWY4MTM3NWVlZmJjNGE0YTEyNGI4MjM0MTQ1",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-03-05T21:19:37Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-02T13:03:23Z"
      },
      "message": "Add tests for set reconciliation",
      "tree": {
        "sha": "274e077759c508056ae64d00144b214a1d78197a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/274e077759c508056ae64d00144b214a1d78197a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/108748f1ebf3b1f81375eefbc4a4a124b8234145",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108748f1ebf3b1f81375eefbc4a4a124b8234145",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/108748f1ebf3b1f81375eefbc4a4a124b8234145",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108748f1ebf3b1f81375eefbc4a4a124b8234145/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b843662818a3ef54ab0ad75b108717c190be8812",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b843662818a3ef54ab0ad75b108717c190be8812",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b843662818a3ef54ab0ad75b108717c190be8812"
      }
    ],
    "stats": {
      "total": 736,
      "additions": 736,
      "deletions": 0
    },
    "files": [
      {
        "sha": "526a128b6920b2af3e88bcf533468bb0a82e0267",
        "filename": "test/functional/p2p_erlay.py",
        "status": "added",
        "additions": 586,
        "deletions": 0,
        "changes": 586,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/p2p_erlay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/p2p_erlay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_erlay.py?ref=108748f1ebf3b1f81375eefbc4a4a124b8234145",
        "patch": "@@ -0,0 +1,586 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+from enum import IntEnum\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import hashlib\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata,\n+    msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    CTransaction, CInv\n+)\n+from test_framework.p2p import P2PDataStore, p2p_lock\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+MSG_WTX = 5\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INVENTORY_BROADCAST_INTERVAL = 2\n+PENALIZED_INVENTORY_BROADCAST_INTERVAL = INVENTORY_BROADCAST_INTERVAL * 2\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def maybe_add_checksum(capacity):\n+    if capacity < 10:\n+        capacity += 1\n+    return capacity\n+\n+def GetShortID(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness = True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PDataStore):\n+    def __init__(self, recon_version, local_salt):\n+        super().__init__()\n+        self.recon_version = recon_version\n+        self.local_salt = local_salt\n+        self.remote_salt = 0\n+        self.last_sendrecon = []\n+        self.last_sketch = []\n+        self.last_inv = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+        self.last_getdata = []\n+        self.remote_q = DEFAULT_Q\n+        self.last_wtxidrelay = []\n+\n+    def on_sendrecon(self, message):\n+        self.last_sendrecon.append(message)\n+        self.remote_salt = message.salt\n+\n+    def on_wtxidrelay(self, message):\n+        self.last_wtxidrelay.append(message)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def on_inv(self, message):\n+        MSG_BLOCK = 2\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK: # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sendrecon(self, sender, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.local_salt\n+        msg.version = self.recon_version\n+        msg.sender = sender\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.blocks_offset = 0\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        time.sleep(0.01) # We usually need the node to process some messages first.\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def generate_txs(self, n_local_unique, n_remote_unique, n_shared, blocks, send=True):\n+        local_unique = []\n+        remote_unique = []\n+        shared = []\n+\n+        for i in range(n_local_unique):\n+            tx = self.generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            local_unique.append(tx)\n+\n+        for i in range(n_local_unique, n_local_unique + n_remote_unique):\n+            tx = self.generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            remote_unique.append(tx)\n+\n+        for i in range(n_local_unique + n_remote_unique, n_local_unique + n_remote_unique + n_shared):\n+            tx = self.generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            shared.append(tx)\n+\n+        if send:\n+            self.nodes[0].p2ps[0].send_txs_and_test(remote_unique + shared, self.nodes[0], success = True)\n+            self.blocks_offset += (n_local_unique + n_remote_unique + n_shared)\n+\n+        return local_unique, remote_unique, shared\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.remote_salt, self.test_node.local_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def generate_transaction(self, node, coinbase):\n+        amount = 0.001\n+        to_address = node.getnewaddress()\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        signresult = node.signrawtransactionwithwallet(rawtx)\n+        tx = CTransaction()\n+        tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+        tx.rehash()\n+        return tx\n+\n+    # - No reconciliation messages until sendrecon is sent.\n+    def announce_reconciliation_support(self, test_node, sender, responder):\n+        def received_wtxidrelay():\n+            return (len(test_node.last_wtxidrelay) == 1)\n+        self.wait_until(received_wtxidrelay, timeout=30)\n+\n+        def received_sendrecon():\n+            return (len(test_node.last_sendrecon) == 1)\n+        self.wait_until(received_sendrecon, timeout=30)\n+\n+        with p2p_lock:\n+            assert_equal(test_node.last_sendrecon[0].version, test_node.recon_version)\n+            self.remote_salt = test_node.last_sendrecon[0].salt\n+            test_node.last_sendrecon = []\n+        test_node.send_sendrecon(sender, responder)\n+\n+    def request_reconciliation(self, test_node, expected_sketch):\n+        local_set_size = 0\n+        q_to_send = int(DEFAULT_Q * Q_PRECISION)\n+        test_node.send_reqrecon(local_set_size, q_to_send)\n+        self.proceed_in_time(3) # Hit sending sketches out (m_next_recon_respond)\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def transmit_sketch(self, test_node, txs_to_sketch, extension, capacity, expected_announced_txs):\n+        short_txids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            test_node.last_full_local_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        test_node.send_sketch(sketch)\n+        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]\n+        if len(expected_wtxds) > 0:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(expected_wtxds))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxds))\n+            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute remote q later\n+            test_node.last_inv = []\n+        else:\n+            assert_equal(test_node.last_inv, [])\n+\n+    def handle_reconciliation_finalization(self, test_node, expected_success, expected_requested_txs, after_extension=False):\n+        expected_requested_shortids = [GetShortID(tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))\n+        if success:\n+            local_missing = test_node.last_inv_size\n+            remote_missing = len(test_node.last_reconcildiff[0].ask_shortids)\n+            total_missing = local_missing + remote_missing\n+            local_size = test_node.last_full_local_size\n+            remote_size = local_size + local_missing - remote_missing\n+            min_size = min(local_size, remote_size)\n+            if min_size != 0:\n+                test_node.remote_q = (total_missing - abs(local_missing - remote_missing)) / min_size\n+        else:\n+            test_node.remote_q = DEFAULT_Q\n+        test_node.last_reconcildiff = []\n+\n+    def handle_extension_request(self, test_node):\n+        def received_reqsketchext():\n+            return (len(test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        test_node.last_reqsketchext = []\n+\n+    def request_sketchext(self, test_node, expected_sketch):\n+        test_node.send_reqsketchext()\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) > 0)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(len(test_node.last_sketch), 1)\n+        assert_equal(test_node.last_sketch[0].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def finalize_reconciliation(self, test_node, success, txs_to_request, txs_to_expect):\n+        ask_shortids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_request]\n+        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]\n+        test_node.send_reconcildiff(success, ask_shortids)\n+        if txs_to_expect != []:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(txs_to_expect))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxids))\n+            test_node.last_inv = []\n+\n+    def request_transactions(self, test_node, txs_to_request):\n+        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before\n+        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]\n+        test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))\n+        test_node.last_tx = []\n+\n+    # The mininode is an inbound connection to the actual node being tested.\n+    # The mininode will initiate reconciliations.\n+    def test_incoming_recon(self):\n+        LOCAL_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # Needed to submit txs\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT))\n+        self.test_node0.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT))\n+        self.test_node.wait_for_verack()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.announce_reconciliation_support(self.test_node, True, False)\n+        self.request_reconciliation(self.test_node, expected_sketch=[])\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+        blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        # Initial reconciliation succeeds\n+        local_txs, remote_txs, _ = self.generate_txs(10, 20, 0, blocks)\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_remote_txs = []\n+        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1\n+        remote_short_ids = [GetShortID(tx, self.compute_salt()) for tx in remote_txs]\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        txs_to_request = random.sample(remote_txs, 3)\n+        self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        self.request_transactions(self.test_node, txs_to_request)\n+        self.check_remote_recon_set_incoming(more_remote_txs)\n+        more_remote_txs = []\n+\n+        # Initial reconciliation succeeds (0 txs on initiator side)\n+        local_txs, remote_txs, _ = self.generate_txs(0, 20, 0, blocks)\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1\n+        remote_short_ids = [GetShortID(tx, self.compute_salt()) for tx in remote_txs]\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        txs_to_request = random.sample(remote_txs, 3)\n+        self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        self.request_transactions(self.test_node, txs_to_request)\n+\n+        # Initial reconciliation succeeds (0 txs on initiator side, small sketch requires extra checksum syndrome)\n+        local_txs, remote_txs, _ = self.generate_txs(0, 1, 0, blocks, self)\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1 + 1\n+        remote_short_ids = [GetShortID(tx, self.compute_salt()) for tx in remote_txs]\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        txs_to_request = random.sample(remote_txs, 1)\n+        self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        self.request_transactions(self.test_node, txs_to_request)\n+\n+        # Initial reconciliation fails, extension succeeds\n+        _, remote_txs, _ = self.generate_txs(0, 20, 0, blocks, self)\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_remote_txs = []\n+        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1\n+        remote_short_ids = [GetShortID(tx, self.compute_salt()) for tx in remote_txs]\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity * 2)[int(expected_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        self.request_sketchext(self.test_node, expected_sketch)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        txs_to_request = random.sample(remote_txs, 3)\n+        self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        self.request_transactions(self.test_node, txs_to_request)\n+        self.check_remote_recon_set_incoming(more_remote_txs)\n+\n+        # Initial reconciliation fails, extension fails\n+        _, remote_txs, _ = self.generate_txs(0, 20, 0, blocks, self)\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_remote_txs = []\n+        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1\n+        remote_short_ids = [GetShortID(tx, self.compute_salt()) for tx in remote_txs]\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        expected_sketch = create_sketch(remote_short_ids, expected_capacity * 2)[int(expected_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        self.request_sketchext(self.test_node, expected_sketch)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        self.finalize_reconciliation(self.test_node, False, txs_to_request=[], txs_to_expect=remote_txs)\n+        self.request_transactions(self.test_node, remote_txs)\n+        self.check_remote_recon_set_incoming(more_remote_txs)\n+\n+    def check_remote_recon_set_incoming(self, txs_to_expect):\n+        expected_capacity = int(abs(len(txs_to_expect) - 0) + DEFAULT_Q * min(len(txs_to_expect), 0)) + 1\n+        expected_capacity = maybe_add_checksum(expected_capacity)\n+        short_ids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_expect]\n+        expected_sketch = create_sketch(short_ids, expected_capacity)\n+        self.request_reconciliation(self.test_node, expected_sketch)\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+\n+\n+    def receive_reqreconcil(self, test_node, expected_set_size):\n+        def received_reqreconcil():\n+            return (len(test_node.last_reqreconcil) == 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)\n+        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.remote_q * Q_PRECISION))\n+        test_node.last_reqreconcil = []\n+\n+    # Mininode is an outgoing connection to the actual node being tested.\n+    # The actual node will initiate reconciliations.\n+    def test_outgoing_recon(self):\n+        LOCAL_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+        # These nodes will consume regular tx flood forwarding\n+        for i in range(MAX_OUTBOUND_FLOOD_TO):\n+            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT), node_outgoing=True)\n+            flooding_node.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT), node_outgoing=True)\n+        self.test_node.wait_for_verack()\n+\n+        blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.announce_reconciliation_support(self.test_node, False, True)\n+        self.check_remote_recon_set_outgoing([], 1) # Delay should be small here (1 sec), so that only 1 extra recon is triggered.\n+\n+        # 20 on their side, 0 on our side, 0 shared, initial reconciliation succeeds (test for 0 on init side)\n+        local_unique_txs, remote_unique_txs, shared_txs = self.generate_txs(0, 20, 0, blocks, self)\n+        local_txs = local_unique_txs + shared_txs\n+        remote_txs = remote_unique_txs + shared_txs\n+        more_remote_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=False,\n+            capacity=0, expected_announced_txs=remote_unique_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=local_unique_txs, after_extension=False)\n+        self.request_transactions(self.test_node, remote_unique_txs)\n+        self.check_remote_recon_set_outgoing([])\n+\n+        # 20 on their side, 20 on our side, 10 shared, initial reconciliation succeeds\n+        local_unique_txs, remote_unique_txs, shared_txs = self.generate_txs(20, 20, 10, blocks, self)\n+        local_txs = local_unique_txs + shared_txs\n+        remote_txs = remote_unique_txs + shared_txs\n+        more_remote_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=False,\n+            capacity=51, expected_announced_txs=remote_unique_txs)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+            expected_requested_txs=local_unique_txs, after_extension=False)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.request_transactions(self.test_node, remote_unique_txs)\n+        self.check_remote_recon_set_outgoing(more_remote_txs)\n+\n+        # 20 on their side, 20 on our side, 10 shared, initial reconciliation fails, extension succeeds\n+        local_unique_txs, remote_unique_txs, shared_txs = self.generate_txs(20, 20, 10, blocks, self)\n+        local_txs = local_unique_txs + shared_txs\n+        remote_txs = remote_unique_txs + shared_txs\n+        more_remote_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=False,\n+            capacity=30, expected_announced_txs=[])\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_extension_request(self.test_node)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=True,\n+            capacity=30, expected_announced_txs=remote_unique_txs)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+            expected_requested_txs=local_unique_txs, after_extension=True)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.request_transactions(self.test_node, remote_unique_txs)\n+        self.check_remote_recon_set_outgoing(more_remote_txs)\n+\n+        # 20 their side, 20 on our side, 10 shared, initial reconciliation fails, extension fails\n+        local_unique_txs, remote_unique_txs, shared_txs = self.generate_txs(20, 20, 10, blocks, self)\n+        local_txs = local_unique_txs + shared_txs\n+        remote_txs = remote_unique_txs + shared_txs\n+        more_remote_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=False,\n+            capacity=10, expected_announced_txs=[])\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_extension_request(self.test_node)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=True,\n+            capacity=10, expected_announced_txs=remote_txs)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[], after_extension=True)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.request_transactions(self.test_node, remote_unique_txs)\n+        self.check_remote_recon_set_outgoing(more_remote_txs)\n+\n+        # Transactions are not lost if empty sketch is sent initially\n+        _, remote_txs, _ = self.generate_txs(0, 5, 0, blocks, self)\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        # These txs won't be in the set being reconciled here, because they will sit in setInventoryTxToSend for a bit\n+        remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1) # Let them flow from setInventoryTxToSend to the recon set\n+        time.sleep(0.1) # Moving to the recon set should happen before processing the sketch\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False,\n+            capacity=0, expected_announced_txs=remote_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[], after_extension=False)\n+        self.check_remote_recon_set_outgoing([])\n+\n+        # Transactions are not lost if empty sketch is sent during extension\n+        local_txs, remote_txs, _ = self.generate_txs(5, 5, 0, blocks, self)\n+        more_remote_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(remote_txs))\n+        # These txs won't be in the set being reconciled here, because they will sit in setInventoryTxToSend for a bit\n+        remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.proceed_in_time(PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1) # Let them flow from setInventoryTxToSend to the recon set\n+        time.sleep(0.1) # Moving to the recon set should happen before processing the sketch\n+        self.transmit_sketch(self.test_node, txs_to_sketch=local_txs, extension=False,\n+            capacity=5, expected_announced_txs=[])\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_extension_request(self.test_node)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=True, capacity=0,\n+            expected_announced_txs=remote_txs)\n+        more_remote_txs.extend(self.generate_txs(0, 1, 0, blocks, self)[1])\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[], after_extension=True)\n+        self.check_remote_recon_set_outgoing(more_remote_txs)\n+\n+    def check_remote_recon_set_outgoing(self, txs_to_expect, delay=RECON_REQUEST_INTERVAL + 1):\n+        self.proceed_in_time(delay)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(txs_to_expect))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False, capacity=0, expected_announced_txs=txs_to_expect)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[], after_extension=False)\n+\n+    def run_test(self):\n+        self.test_incoming_recon()\n+        self.restart_node(0)\n+        self.test_outgoing_recon()\n+\n+if __name__ == '__main__':\n+    ReconciliationTest().main()"
      },
      {
        "sha": "911eef59cb359781101f7c8a7e25bc2d27cfab82",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=108748f1ebf3b1f81375eefbc4a4a124b8234145",
        "patch": "@@ -115,6 +115,11 @@ def ser_uint256(u):\n         u >>= 32\n     return rs\n \n+def deser_uint32(f):\n+    return struct.unpack(\"<I\", f.read(4))[0]\n+\n+def ser_uint32(u):\n+    return b\"\" + struct.pack(\"<I\", u & 0xFFFFFFFF)\n \n def uint256_from_str(s):\n     r = 0\n@@ -173,6 +178,34 @@ def ser_uint256_vector(l):\n         r += ser_uint256(i)\n     return r\n \n+def deser_uint32_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_uint32(f)\n+        r.append(t)\n+    return r\n+\n+def ser_uint32_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += ser_uint32(i)\n+    return r\n+\n+def deser_uint8_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = struct.unpack(\"<B\", f.read(1))[0]\n+        r.append(t)\n+    return r\n+\n+def ser_uint8_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += struct.pack(\"<B\", i & 0xff)\n+    return r\n+\n \n def deser_string_vector(f):\n     nit = deser_compact_size(f)\n@@ -1783,3 +1816,108 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_cfcheckpt(filter_type={:#x}, stop_hash={:x})\".format(\n             self.filter_type, self.stop_hash)\n+\n+class msg_sendrecon:\n+    __slots__ = (\"sender\", \"responder\", \"version\", \"salt\")\n+    msgtype = b\"sendrecon\"\n+\n+    def __init__(self):\n+        self.sender = False\n+        self.responder = False\n+        self.version = 0\n+        self.salt = 0\n+\n+    def deserialize(self, f):\n+        self.sender = struct.unpack(\"<?\", f.read(1))[0]\n+        self.responder = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<I\", f.read(4))[0]\n+        self.salt = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.sender)\n+        r += struct.pack(\"<?\", self.responder)\n+        r += struct.pack(\"<I\", self.version)\n+        r += struct.pack(\"<Q\", self.salt)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendrecon(sender=%i, responder=%i, version=%lu, salt=%lu)\" %\\\n+            (self.sender, self.responder, self.version, self.salt)\n+\n+class msg_reqrecon:\n+    __slots__ = (\"set_size\", \"q\")\n+    msgtype = b\"reqrecon\"\n+\n+    def __init__(self):\n+        self.set_size = 0\n+        self.q = 0\n+\n+    def deserialize(self, f):\n+        self.set_size = struct.unpack(\"<H\", f.read(2))[0]\n+        self.q = struct.unpack(\"<H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<I\", self.set_size)\n+        r += struct.pack(\"<I\", self.q)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reqrecon(set_size=%i, q=%i)\" % (self.set_size, self.q)\n+\n+class msg_sketch:\n+    __slots__ = (\"skdata\")\n+    msgtype = b\"sketch\"\n+\n+    def __init__(self):\n+        self.skdata = []\n+\n+    def deserialize(self, f):\n+        self.skdata = deser_uint8_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint8_vector(self.skdata)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sketch(sketch_size=%i)\" % (len(self.skdata))\n+\n+class msg_reqsketchext:\n+    __slots__ = ()\n+    msgtype = b\"reqsketchext\"\n+\n+    def __init__(self):\n+        return\n+\n+    def deserialize(self, f):\n+        return\n+\n+    def serialize(self):\n+        r = b\"\"\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reqsketchext\"\n+\n+class msg_reconcildiff:\n+    __slots__ = (\"success\", \"ask_shortids\")\n+    msgtype = b\"reconcildiff\"\n+\n+    def __init__(self):\n+        self.success = 0\n+        self.ask_shortids = []\n+\n+    def deserialize(self, f):\n+        self.success = struct.unpack(\"<B\", f.read(1))[0]\n+        self.ask_shortids = deser_uint32_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<B\", self.success)\n+        r += ser_uint32_vector(self.ask_shortids)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reconcildiff(success=%i,ask_shortids=%i)\" % (self.success, len(self.ask_shortids))"
      },
      {
        "sha": "6924434fc0c55a34210680b5407c11af5c77c2e6",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=108748f1ebf3b1f81375eefbc4a4a124b8234145",
        "patch": "@@ -57,8 +57,13 @@\n     msg_notfound,\n     msg_ping,\n     msg_pong,\n+    msg_reconcildiff,\n+    msg_reqrecon,\n+    msg_reqsketchext,\n     msg_sendaddrv2,\n     msg_sendcmpct,\n+    msg_sendrecon,\n+    msg_sketch,\n     msg_sendheaders,\n     msg_tx,\n     MSG_TX,\n@@ -116,9 +121,14 @@\n     b\"notfound\": msg_notfound,\n     b\"ping\": msg_ping,\n     b\"pong\": msg_pong,\n+    b\"reconcildiff\": msg_reconcildiff,\n+    b\"reqrecon\": msg_reqrecon,\n+    b\"reqsketchext\": msg_reqsketchext,\n     b\"sendaddrv2\": msg_sendaddrv2,\n     b\"sendcmpct\": msg_sendcmpct,\n     b\"sendheaders\": msg_sendheaders,\n+    b\"sendrecon\": msg_sendrecon,\n+    b\"sketch\": msg_sketch,\n     b\"tx\": msg_tx,\n     b\"verack\": msg_verack,\n     b\"version\": msg_version,\n@@ -430,6 +440,7 @@ def on_pong(self, message): pass\n     def on_sendaddrv2(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n+    def on_sendrecon(self, message): pass\n     def on_tx(self, message): pass\n     def on_wtxidrelay(self, message): pass\n "
      },
      {
        "sha": "b501984add2b3aeabd807b667355cde49949b8d5",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/108748f1ebf3b1f81375eefbc4a4a124b8234145/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=108748f1ebf3b1f81375eefbc4a4a124b8234145",
        "patch": "@@ -97,6 +97,7 @@\n     'rpc_fundrawtransaction.py --legacy-wallet',\n     'rpc_fundrawtransaction.py --descriptors',\n     'p2p_compactblocks.py',\n+    'p2p_erlay.py',\n     'feature_segwit.py --legacy-wallet',\n     # vv Tests less than 2m vv\n     'wallet_basic.py --legacy-wallet',"
      }
    ]
  }
]