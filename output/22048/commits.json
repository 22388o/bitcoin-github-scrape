[
  {
    "sha": "6cebac598e5e85eadd60eb1274d7f33d63ce1108",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Y2ViYWM1OThlNWU4NWVhZGQ2MGViMTI3NGQ3ZjMzZDYzY2UxMTA4",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-24T13:54:52Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-05-24T14:10:49Z"
      },
      "message": "test: MiniWallet: introduce enum type for output mode\n\nFor the MiniWallet constructor, the two boolean parameters\n\"raw_script\" and \"use_p2pk\" are replaced by a single parameter of the\nnewly introduced type MiniWalletMode (derived by enum.Enum), which can\nhold the following values:\n\t- ADDRESS_OP_TRUE\n\t- RAW_OP_TRUE\n\t- RAW_P2PK",
      "tree": {
        "sha": "5d9cd75da82f259488afe777379c9b53447681d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5d9cd75da82f259488afe777379c9b53447681d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6cebac598e5e85eadd60eb1274d7f33d63ce1108",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cebac598e5e85eadd60eb1274d7f33d63ce1108",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6cebac598e5e85eadd60eb1274d7f33d63ce1108",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cebac598e5e85eadd60eb1274d7f33d63ce1108/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce4a852475fc445be88685197ea48c19256e0401",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce4a852475fc445be88685197ea48c19256e0401",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce4a852475fc445be88685197ea48c19256e0401"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 39,
      "deletions": 8
    },
    "files": [
      {
        "sha": "d25aaa070dafc4c856cb35c104a9b9bc9887228e",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=6cebac598e5e85eadd60eb1274d7f33d63ce1108",
        "patch": "@@ -26,7 +26,10 @@\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n-from test_framework.wallet import MiniWallet\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n \n CLTV_HEIGHT = 1351\n \n@@ -97,7 +100,7 @@ def test_cltv_info(self, *, is_active):\n \n     def run_test(self):\n         peer = self.nodes[0].add_p2p_connection(P2PInterface())\n-        wallet = MiniWallet(self.nodes[0], raw_script=True)\n+        wallet = MiniWallet(self.nodes[0], mode=MiniWalletMode.RAW_OP_TRUE)\n \n         self.test_cltv_info(is_active=False)\n "
      },
      {
        "sha": "5081867319376c71baba93c60e03608dbc4babc1",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=6cebac598e5e85eadd60eb1274d7f33d63ce1108",
        "patch": "@@ -55,7 +55,10 @@\n     assert_equal,\n     softfork_active,\n )\n-from test_framework.wallet import MiniWallet\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n \n TESTING_TX_COUNT = 83  # Number of testing transactions: 1 BIP113 tx, 16 BIP68 txs, 66 BIP112 txs (see comments above)\n COINBASE_BLOCK_COUNT = TESTING_TX_COUNT  # Number of coinbase blocks we need to generate as inputs for our txs\n@@ -181,7 +184,7 @@ def send_blocks(self, blocks, success=True, reject_reason=None):\n \n     def run_test(self):\n         self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())\n-        self.miniwallet = MiniWallet(self.nodes[0], use_p2pk=True)\n+        self.miniwallet = MiniWallet(self.nodes[0], mode=MiniWalletMode.RAW_P2PK)\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future"
      },
      {
        "sha": "05bda5d899d1fddacc03e8310d10ecac6ab8e58b",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 29,
        "deletions": 4,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cebac598e5e85eadd60eb1274d7f33d63ce1108/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=6cebac598e5e85eadd60eb1274d7f33d63ce1108",
        "patch": "@@ -5,6 +5,7 @@\n \"\"\"A limited-functionality wallet, which may replace a real wallet in tests\"\"\"\n \n from decimal import Decimal\n+from enum import Enum\n from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.key import ECKey\n from test_framework.messages import (\n@@ -30,22 +31,46 @@\n )\n \n \n+class MiniWalletMode(Enum):\n+    \"\"\"Determines the transaction type the MiniWallet is creating and spending.\n+\n+    For most purposes, the default mode ADDRESS_OP_TRUE should be sufficient;\n+    it simply uses a fixed bech32 P2WSH address whose coins are spent with a\n+    witness stack of OP_TRUE, i.e. following an anyone-can-spend policy.\n+    However, if the transactions need to be modified by the user (e.g. prepending\n+    scriptSig for testing opcodes that are activated by a soft-fork), or the txs\n+    should contain an actual signature, the raw modes RAW_OP_TRUE and RAW_P2PK\n+    can be useful. Summary of modes:\n+\n+                    |      output       |           |  tx is   | can modify |  needs\n+         mode       |    description    |  address  | standard | scriptSig  | signing\n+    ----------------+-------------------+-----------+----------+------------+----------\n+    ADDRESS_OP_TRUE | anyone-can-spend  |  bech32   |   yes    |    no      |   no\n+    RAW_OP_TRUE     | anyone-can-spend  |  - (raw)  |   no     |    yes     |   no\n+    RAW_P2PK        | pay-to-public-key |  - (raw)  |   yes    |    yes     |   yes\n+    \"\"\"\n+    ADDRESS_OP_TRUE = 1\n+    RAW_OP_TRUE = 2\n+    RAW_P2PK = 3\n+\n+\n class MiniWallet:\n-    def __init__(self, test_node, *, raw_script=False, use_p2pk=False):\n+    def __init__(self, test_node, *, mode=MiniWalletMode.ADDRESS_OP_TRUE):\n         self._test_node = test_node\n         self._utxos = []\n         self._priv_key = None\n         self._address = None\n \n-        if raw_script:\n+        assert isinstance(mode, MiniWalletMode)\n+        if mode == MiniWalletMode.RAW_OP_TRUE:\n             self._scriptPubKey = bytes(CScript([OP_TRUE]))\n-        elif use_p2pk:\n+        elif mode == MiniWalletMode.RAW_P2PK:\n             # use simple deterministic private key (k=1)\n             self._priv_key = ECKey()\n             self._priv_key.set((1).to_bytes(32, 'big'), True)\n             pub_key = self._priv_key.get_pubkey()\n             self._scriptPubKey = bytes(CScript([pub_key.get_bytes(), OP_CHECKSIG]))\n-        else:\n+        elif mode == MiniWalletMode.ADDRESS_OP_TRUE:\n             self._address = ADDRESS_BCRT1_P2WSH_OP_TRUE\n             self._scriptPubKey = hex_str_to_bytes(self._test_node.validateaddress(self._address)['scriptPubKey'])\n "
      }
    ]
  }
]