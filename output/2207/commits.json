[
  {
    "sha": "4786302fb99f930afca1e778255b72c6999ca480",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Nzg2MzAyZmI5OWY5MzBhZmNhMWU3NzgyNTViNzJjNjk5OWNhNDgw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-12T01:17:17Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:41:44Z"
      },
      "message": "Replace leveldb/ with vanilla 1.7.0",
      "tree": {
        "sha": "8c92a473f0c8772d152561d909fedce4b8ed5d2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c92a473f0c8772d152561d909fedce4b8ed5d2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4786302fb99f930afca1e778255b72c6999ca480",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4786302fb99f930afca1e778255b72c6999ca480",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4786302fb99f930afca1e778255b72c6999ca480",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4786302fb99f930afca1e778255b72c6999ca480/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c429f2b062140843f42b78d70278279c6be74441",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c429f2b062140843f42b78d70278279c6be74441",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c429f2b062140843f42b78d70278279c6be74441"
      }
    ],
    "stats": {
      "total": 1697,
      "additions": 481,
      "deletions": 1216
    },
    "files": [
      {
        "sha": "fdc66f9a2b2cb0fc93a52cc91366cbde2d5b0547",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 36,
        "deletions": 37,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -2,9 +2,6 @@\n # Use of this source code is governed by a BSD-style license that can be\n # found in the LICENSE file. See the AUTHORS file for names of contributors.\n \n-# Inherit some settings from environment variables, if available\n-INSTALL_PATH ?= $(CURDIR)\n-\n #-----------------------------------------------\n # Uncomment exactly one of the lines labelled (A), (B), and (C) below\n # to switch between compilation modes.\n@@ -15,14 +12,16 @@ OPT ?= -O2 -DNDEBUG       # (A) Production use (optimized mode)\n #-----------------------------------------------\n \n # detect what platform we're building on\n-$(shell ./build_detect_platform build_config.mk)\n+$(shell CC=$(CC) CXX=$(CXX) TARGET_OS=$(TARGET_OS) \\\n+    ./build_detect_platform build_config.mk ./)\n # this file is generated by the previous line to set build flags and sources\n include build_config.mk\n \n-xCFLAGS = -I. -I./include $(PLATFORM_CCFLAGS) $(OPT) $(CFLAGS)\n-xCXXFLAGS = -I. -I./include $(PLATFORM_CXXFLAGS) $(OPT) $(CXXFLAGS)\n+CFLAGS += -I. -I./include $(PLATFORM_CCFLAGS) $(OPT)\n+CXXFLAGS += -I. -I./include $(PLATFORM_CXXFLAGS) $(OPT)\n \n-xLDFLAGS = $(PLATFORM_LDFLAGS) $(LDFLAGS)\n+LDFLAGS += $(PLATFORM_LDFLAGS)\n+LIBS += $(PLATFORM_LIBS)\n \n LIBOBJECTS = $(SOURCES:.cc=.o)\n MEMENVOBJECTS = $(MEMENV_SOURCES:.cc=.o)\n@@ -70,7 +69,7 @@ SHARED = $(SHARED1)\n else\n # Update db.h if you change these.\n SHARED_MAJOR = 1\n-SHARED_MINOR = 5\n+SHARED_MINOR = 7\n SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)\n@@ -82,7 +81,7 @@ $(SHARED2): $(SHARED3)\n endif\n \n $(SHARED3):\n-\t$(CXX) $(xLDFLAGS) $(PLATFORM_SHARED_LDFLAGS)$(SHARED2) $(xCXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(SOURCES) $(PLATFORM_EXTRALIBS) -o $(SHARED3)\n+\t$(CXX) $(LDFLAGS) $(PLATFORM_SHARED_LDFLAGS)$(SHARED2) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(SOURCES) -o $(SHARED3) $(LIBS)\n \n endif  # PLATFORM_SHARED_EXT\n \n@@ -100,74 +99,74 @@ $(LIBRARY): $(LIBOBJECTS)\n \t$(AR) -rs $@ $(LIBOBJECTS)\n \n db_bench: db/db_bench.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) db/db_bench.o $(LIBOBJECTS) $(TESTUTIL) -o $@  $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/db_bench.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LIBS)\n \n db_bench_sqlite3: doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS) -lsqlite3\n+\t$(CXX) $(LDFLAGS) doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL) -o $@ -lsqlite3 $(LIBS)\n \n db_bench_tree_db: doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS) -lkyotocabinet\n+\t$(CXX) $(LDFLAGS) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ -lkyotocabinet $(LIBS)\n \n arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n bloom_test: util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n c_test: db/c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n cache_test: util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n coding_test: util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n corruption_test: db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n crc32c_test: util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n db_test: db/db_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/db_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/db_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n dbformat_test: db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n env_test: util/env_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/env_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) util/env_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n filename_test: db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n filter_block_test: table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n log_test: db/log_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/log_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/log_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n table_test: table/table_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) table/table_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) table/table_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n skiplist_test: db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n version_edit_test: db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n version_set_test: db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n write_batch_test: db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n $(MEMENVLIBRARY) : $(MEMENVOBJECTS)\n \trm -f $@\n \t$(AR) -rs $@ $(MEMENVOBJECTS)\n \n memenv_test : helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS)\n-\t$(CXX) helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS) -o $@ $(xLDFLAGS) $(PLATFORM_EXTRALIBS)\n+\t$(CXX) $(LDFLAGS) helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS) -o $@ $(LIBS)\n \n ifeq ($(PLATFORM), IOS)\n # For iOS, create universal object files to be used on both the simulator and\n@@ -179,22 +178,22 @@ IOSVERSION=$(shell defaults read $(PLATFORMSROOT)/iPhoneOS.platform/version CFBu\n \n .cc.o:\n \tmkdir -p ios-x86/$(dir $@)\n-\t$(SIMULATORROOT)/usr/bin/$(CXX) $(xCXXFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n+\t$(CXX) $(CXXFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n \tmkdir -p ios-arm/$(dir $@)\n-\t$(DEVICEROOT)/usr/bin/$(CXX) $(xCXXFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n+\t$(DEVICEROOT)/usr/bin/$(CXX) $(CXXFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n \tlipo ios-x86/$@ ios-arm/$@ -create -output $@\n \n .c.o:\n \tmkdir -p ios-x86/$(dir $@)\n-\t$(SIMULATORROOT)/usr/bin/$(CC) $(xCFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n+\t$(CC) $(CFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n \tmkdir -p ios-arm/$(dir $@)\n-\t$(DEVICEROOT)/usr/bin/$(CC) $(xCFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n+\t$(DEVICEROOT)/usr/bin/$(CC) $(CFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n \tlipo ios-x86/$@ ios-arm/$@ -create -output $@\n \n else\n .cc.o:\n-\t$(CXX) $(xCXXFLAGS) -c $< -o $@\n+\t$(CXX) $(CXXFLAGS) -c $< -o $@\n \n .c.o:\n-\t$(CC) $(xCFLAGS) -c $< -o $@\n+\t$(CC) $(CFLAGS) -c $< -o $@\n endif"
      },
      {
        "sha": "3fd99242d7bbcfeffecfd01c0870f89382766baf",
        "filename": "src/leveldb/NEWS",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/NEWS",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/NEWS",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/NEWS?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -0,0 +1,17 @@\n+Release 1.2 2011-05-16\n+----------------------\n+\n+Fixes for larger databases (tested up to one billion 100-byte entries,\n+i.e., ~100GB).\n+\n+(1) Place hard limit on number of level-0 files.  This fixes errors\n+of the form \"too many open files\".\n+\n+(2) Fixed memtable management.  Before the fix, a heavy write burst\n+could cause unbounded memory usage.\n+\n+A fix for a logging bug where the reader would incorrectly complain\n+about corruption.\n+\n+Allow public access to WriteBatch contents so that users can easily\n+wrap a DB."
      },
      {
        "sha": "3618adeeedbea04a14e00d5a1ef33dd4f0a7be06",
        "filename": "src/leveldb/README",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/README",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/README",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/README?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -1,11 +1,3 @@\n-LevelDB is a third party library used for the transaction database.\n-It is imported into the Bitcoin codebase due to being relatively new\n-and not widely packaged.\n-\n-\n-\n----------------------------------------------------------------------\n-\n leveldb: A key-value store\n Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n "
      },
      {
        "sha": "e603c07137f1ea198a3de9ca3bbb369e1c069f61",
        "filename": "src/leveldb/TODO",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/TODO?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -7,6 +7,7 @@ db\n   within [start_key..end_key]?  For Chrome, deletion of obsolete\n   object stores, etc. can be done in the background anyway, so\n   probably not that important.\n+- There have been requests for MultiGet.\n \n After a range is completely deleted, what gets rid of the\n corresponding files if we do no future changes to that range.  Make"
      },
      {
        "sha": "7cdb793a19040b9dcbe00df7b2862885f819552e",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 63,
        "deletions": 52,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -7,8 +7,11 @@\n #   CC                          C Compiler path\n #   CXX                         C++ Compiler path\n #   PLATFORM_LDFLAGS            Linker flags\n+#   PLATFORM_LIBS               Libraries flags\n #   PLATFORM_SHARED_EXT         Extension for shared libraries\n #   PLATFORM_SHARED_LDFLAGS     Flags for building shared library\n+#                               This flag is embedded just before the name\n+#                               of the shared library without intervening spaces\n #   PLATFORM_SHARED_CFLAGS      Flags for compiling objects for shared library\n #   PLATFORM_CCFLAGS            C compiler flags\n #   PLATFORM_CXXFLAGS           C++ compiler flags.  Will contain:\n@@ -23,8 +26,9 @@\n #\n \n OUTPUT=$1\n-if test -z \"$OUTPUT\"; then\n-  echo \"usage: $0 <output-filename>\" >&2\n+PREFIX=$2\n+if test -z \"$OUTPUT\" || test -z \"$PREFIX\"; then\n+  echo \"usage: $0 <output-filename> <directory_prefix>\" >&2\n   exit 1\n fi\n \n@@ -50,85 +54,79 @@ CROSS_COMPILE=\n PLATFORM_CCFLAGS=\n PLATFORM_CXXFLAGS=\n PLATFORM_LDFLAGS=\n-PLATFORM_EXTRALIBS=\n-PLATFORM_SOURCES=\n+PLATFORM_LIBS=\n PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n PLATFORM_SHARED_VERSIONED=true\n \n-# On GCC, we pick libc's memcmp over GCC's memcmp via -fno-builtin-memcmp\n+MEMCMP_FLAG=\n+if [ \"$CXX\" = \"g++\" ]; then\n+    # Use libc's memcmp instead of GCC's memcmp.  This results in ~40%\n+    # performance improvement on readrandom under gcc 4.4.3 on Linux/x86.\n+    MEMCMP_FLAG=\"-fno-builtin-memcmp\"\n+fi\n+\n case \"$TARGET_OS\" in\n     Darwin)\n         PLATFORM=OS_MACOSX\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -DOS_MACOSX\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n         PLATFORM_SHARED_EXT=dylib\n-        PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name \"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n+        PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -pthread -DOS_LINUX\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_SOLARIS\"\n-        PLATFORM_LDFLAGS=\"-lpthread -lrt\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n+        PLATFORM_LIBS=\"-lpthread -lrt\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_FREEBSD\"\n-        PLATFORM_LDFLAGS=\"-lpthread\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n+        PLATFORM_LIBS=\"-lpthread\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     NetBSD)\n         PLATFORM=OS_NETBSD\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_NETBSD\"\n-        PLATFORM_LDFLAGS=\"-lpthread -lgcc_s\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n+        PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_OPENBSD\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_DRAGONFLYBSD\"\n-        PLATFORM_LDFLAGS=\"-lpthread\"\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n+        PLATFORM_LIBS=\"-lpthread\"\n+        PORT_FILE=port/port_posix.cc\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n-        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        PORT_FILE=port/port_posix.cc\n         CROSS_COMPILE=true\n         ;;\n-    OS_WINDOWS_CROSSCOMPILE)\n-        PLATFORM=OS_WINDOWS\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS -DBOOST_THREAD_USE_LIB\"\n-        PLATFORM_CXXFLAGS=\"\"\n-        PLATFORM_LDFLAGS=\"\"\n-        PLATFORM_SHARED_CFLAGS=\"\"\n-        PLATFORM_SOURCES=\"port/port_win.cc util/env_boost.cc util/win_logger.cc\"\n-        PLATFORM_EXTRALIBS=\"-lboost_system-mt-s -lboost_filesystem-mt-s -lboost_thread_win32-mt-s\"\n-        CROSS_COMPILE=true\n+    HP-UX)\n+        PLATFORM=OS_HPUX\n+        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n+        PLATFORM_LDFLAGS=\"-pthread\"\n+        PORT_FILE=port/port_posix.cc\n+        # man ld: +h internal_name\n+        PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n-    NATIVE_WINDOWS)\n-        PLATFORM=OS_WINDOWS\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS -DBOOST_THREAD_USE_LIB\"\n-        PLATFORM_CXXFLAGS=\"\"\n-        PLATFORM_LDFLAGS=\"\"\n-        PLATFORM_SHARED_CFLAGS=\"\"\n-        PLATFORM_SOURCES=\"port/port_win.cc util/env_boost.cc util/win_logger.cc\"\n-        PLATFORM_EXTRALIBS=\"-lboost_system-mgw45-mt-s-1_50 -lboost_filesystem-mgw45-mt-s-1_50 -lboost_thread-mgw45-mt-s-1_50 -lboost_chrono-mgw45-mt-s-1_50\"\n-        CROSS_COMPILE=true\n-\t    ;;\n     *)\n         echo \"Unknown platform!\" >&2\n         exit 1\n@@ -138,24 +136,26 @@ esac\n # except for the test and benchmark files. By default, find will output a list\n # of all files matching either rule, so we need to append -print to make the\n # prune take effect.\n-DIRS=\"util db table\"\n+DIRS=\"$PREFIX/db $PREFIX/util $PREFIX/table\"\n+\n set -f # temporarily disable globbing so that our patterns aren't expanded\n PRUNE_TEST=\"-name *test*.cc -prune\"\n PRUNE_BENCH=\"-name *_bench.cc -prune\"\n-PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -not -name 'env_*.cc' -not -name '*_logger.cc' -print | sort | tr \"\\n\" \" \"`\n+PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -print | sort | sed \"s,^$PREFIX/,,\" | tr \"\\n\" \" \"`\n+\n set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PLATFORM_SOURCES\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n     # Cross-compiling; do not try any compilation tests.\n     true\n else\n     # If -std=c++0x works, use <cstdatomic>.  Otherwise use port_posix.h.\n-    $CXX $CFLAGS -std=c++0x -x c++ - -o /dev/null 2>/dev/null  <<EOF\n+    $CXX $CXXFLAGS -std=c++0x -x c++ - -o /dev/null 2>/dev/null  <<EOF\n       #include <cstdatomic>\n       int main() {}\n EOF\n@@ -166,12 +166,23 @@ EOF\n         COMMON_FLAGS=\"$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX\"\n     fi\n \n+    # Test whether Snappy library is installed\n+    # http://code.google.com/p/snappy/\n+    $CXX $CXXFLAGS -x c++ - -o /dev/null 2>/dev/null  <<EOF\n+      #include <snappy.h>\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        COMMON_FLAGS=\"$COMMON_FLAGS -DSNAPPY\"\n+        PLATFORM_LIBS=\"$PLATFORM_LIBS -lsnappy\"\n+    fi\n+\n     # Test whether tcmalloc is available\n-    $CXX $CFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF\n+    $CXX $CXXFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF\n       int main() {}\n EOF\n     if [ \"$?\" = 0 ]; then\n-        PLATFORM_LDFLAGS=\"$PLATFORM_LDFLAGS -ltcmalloc\"\n+        PLATFORM_LIBS=\"$PLATFORM_LIBS -ltcmalloc\"\n     fi\n fi\n \n@@ -182,9 +193,9 @@ echo \"CC=$CC\" >> $OUTPUT\n echo \"CXX=$CXX\" >> $OUTPUT\n echo \"PLATFORM=$PLATFORM\" >> $OUTPUT\n echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n-echo \"PLATFORM_EXTRALIBS=$PLATFORM_EXTRALIBS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "08ff0ad90ac00d63f05d5d71fb89f9f701894058",
        "filename": "src/leveldb/db/c.cc",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/c.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -24,6 +24,8 @@ using leveldb::Env;\n using leveldb::FileLock;\n using leveldb::FilterPolicy;\n using leveldb::Iterator;\n+using leveldb::kMajorVersion;\n+using leveldb::kMinorVersion;\n using leveldb::Logger;\n using leveldb::NewBloomFilterPolicy;\n using leveldb::NewLRUCache;\n@@ -578,4 +580,16 @@ void leveldb_env_destroy(leveldb_env_t* env) {\n   delete env;\n }\n \n+void leveldb_free(void* ptr) {\n+  free(ptr);\n+}\n+\n+int leveldb_major_version() {\n+  return kMajorVersion;\n+}\n+\n+int leveldb_minor_version() {\n+  return kMinorVersion;\n+}\n+\n }  // end extern \"C\""
      },
      {
        "sha": "7cd5ee02076ab96303a2b1f25dbabbe721caaba7",
        "filename": "src/leveldb/db/c_test.c",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/c_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/c_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/c_test.c?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -165,6 +165,9 @@ int main(int argc, char** argv) {\n   char* err = NULL;\n   int run = -1;\n \n+  CheckCondition(leveldb_major_version() >= 1);\n+  CheckCondition(leveldb_minor_version() >= 1);\n+\n   snprintf(dbname, sizeof(dbname),\n            \"%s/leveldb_c_test-%d\",\n            GetTempDir(),\n@@ -204,6 +207,12 @@ int main(int argc, char** argv) {\n   CheckCondition(err != NULL);\n   Free(&err);\n \n+  StartPhase(\"leveldb_free\");\n+  db = leveldb_open(options, dbname, &err);\n+  CheckCondition(err != NULL);\n+  leveldb_free(err);\n+  err = NULL;\n+\n   StartPhase(\"open\");\n   leveldb_options_set_create_if_missing(options, 1);\n   db = leveldb_open(options, dbname, &err);"
      },
      {
        "sha": "7abdf87587dfc8d4fa0287d8ad45d82b2142d7fc",
        "filename": "src/leveldb/db/db_bench.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_bench.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -693,6 +693,7 @@ class Benchmark {\n     options.create_if_missing = !FLAGS_use_existing_db;\n     options.block_cache = cache_;\n     options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.max_open_files = FLAGS_open_files;\n     options.filter_policy = filter_policy_;\n     Status s = DB::Open(options, FLAGS_db, &db_);\n     if (!s.ok()) {"
      },
      {
        "sha": "c9de169f29f6cad112f8427006bb7ba0391cb29e",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -609,7 +609,11 @@ void DBImpl::BackgroundCall() {\n   assert(bg_compaction_scheduled_);\n   if (!shutting_down_.Acquire_Load()) {\n     Status s = BackgroundCompaction();\n-    if (!s.ok()) {\n+    if (s.ok()) {\n+      // Success\n+    } else if (shutting_down_.Acquire_Load()) {\n+      // Error most likely due to shutdown; do not wait\n+    } else {\n       // Wait a little bit before retrying background compaction in\n       // case this is an environmental problem and we do not want to\n       // chew up resources for failed compactions for the duration of"
      },
      {
        "sha": "bd29dd80554be1358f73039e293fd44d1e437827",
        "filename": "src/leveldb/db/db_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 10,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -13,6 +13,7 @@\n #include \"leveldb/db.h\"\n #include \"leveldb/env.h\"\n #include \"port/port.h\"\n+#include \"port/thread_annotations.h\"\n \n namespace leveldb {\n \n@@ -71,7 +72,7 @@ class DBImpl : public DB {\n   // Recover the descriptor from persistent storage.  May do a significant\n   // amount of work to recover recently logged updates.  Any changes to\n   // be made to the descriptor are added to *edit.\n-  Status Recover(VersionEdit* edit);\n+  Status Recover(VersionEdit* edit) EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n   void MaybeIgnoreError(Status* s) const;\n \n@@ -80,27 +81,34 @@ class DBImpl : public DB {\n \n   // Compact the in-memory write buffer to disk.  Switches to a new\n   // log-file/memtable and writes a new descriptor iff successful.\n-  Status CompactMemTable();\n+  Status CompactMemTable()\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n   Status RecoverLogFile(uint64_t log_number,\n                         VersionEdit* edit,\n-                        SequenceNumber* max_sequence);\n+                        SequenceNumber* max_sequence)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n-  Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base);\n+  Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n-  Status MakeRoomForWrite(bool force /* compact even if there is room? */);\n+  Status MakeRoomForWrite(bool force /* compact even if there is room? */)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n   WriteBatch* BuildBatchGroup(Writer** last_writer);\n \n-  void MaybeScheduleCompaction();\n+  void MaybeScheduleCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n   static void BGWork(void* db);\n   void BackgroundCall();\n-  Status BackgroundCompaction();\n-  void CleanupCompaction(CompactionState* compact);\n-  Status DoCompactionWork(CompactionState* compact);\n+  Status BackgroundCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n+  void CleanupCompaction(CompactionState* compact)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n+  Status DoCompactionWork(CompactionState* compact)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n   Status OpenCompactionOutputFile(CompactionState* compact);\n   Status FinishCompactionOutputFile(CompactionState* compact, Iterator* input);\n-  Status InstallCompactionResults(CompactionState* compact);\n+  Status InstallCompactionResults(CompactionState* compact)\n+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);\n \n   // Constant after construction\n   Env* const env_;"
      },
      {
        "sha": "74abd13e5cb112dcaa8262d40c89be0841450100",
        "filename": "src/leveldb/db/db_test.cc",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/db_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_test.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -1442,6 +1442,12 @@ TEST(DBTest, DBOpen_Options) {\n   db = NULL;\n }\n \n+TEST(DBTest, Locking) {\n+  DB* db2 = NULL;\n+  Status s = DB::Open(CurrentOptions(), dbname_, &db2);\n+  ASSERT_TRUE(!s.ok()) << \"Locking did not prevent re-opening db\";\n+}\n+\n // Check that number of files does not grow when we are out of space\n TEST(DBTest, NoSpace) {\n   Options options = CurrentOptions();"
      },
      {
        "sha": "bdd4a579b7e663aff7f0fd4a8e5cbfb7a8bb0b5a",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -865,7 +865,7 @@ Status VersionSet::Recover() {\n         if (edit.has_comparator_ &&\n             edit.comparator_ != icmp_.user_comparator()->Name()) {\n           s = Status::InvalidArgument(\n-              edit.comparator_ + \"does not match existing comparator \",\n+              edit.comparator_ + \" does not match existing comparator \",\n               icmp_.user_comparator()->Name());\n         }\n       }"
      },
      {
        "sha": "792899b7f8ff67e968d1b03912c4226c5731651c",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -21,6 +21,7 @@\n #include \"db/dbformat.h\"\n #include \"db/version_edit.h\"\n #include \"port/port.h\"\n+#include \"port/thread_annotations.h\"\n \n namespace leveldb {\n \n@@ -159,7 +160,8 @@ class VersionSet {\n   // current version.  Will release *mu while actually writing to the file.\n   // REQUIRES: *mu is held on entry.\n   // REQUIRES: no other thread concurrently calls LogAndApply()\n-  Status LogAndApply(VersionEdit* edit, port::Mutex* mu);\n+  Status LogAndApply(VersionEdit* edit, port::Mutex* mu)\n+      EXCLUSIVE_LOCKS_REQUIRED(mu);\n \n   // Recover the last saved descriptor from persistent storage.\n   Status Recover();"
      },
      {
        "sha": "e63aaa8dcc289915176b12749dd9ec21b50aba02",
        "filename": "src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/bench/db_bench_sqlite3.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -618,7 +618,7 @@ class Benchmark {\n         ErrorCheck(status);\n \n         // Execute read statement\n-        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW);\n+        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}\n         StepErrorCheck(status);\n \n         // Reset SQLite statement for another use"
      },
      {
        "sha": "3ed0ed9d9e305ed630f39a201e3034e00d815b43",
        "filename": "src/leveldb/doc/index.html",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.html?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -408,7 +408,7 @@ <h2>Filters</h2>\n the number of disk reads substantially.\n <pre>\n    leveldb::Options options;\n-   options.filter_policy = NewBloomFilter(10);\n+   options.filter_policy = NewBloomFilterPolicy(10);\n    leveldb::DB* db;\n    leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n    ... use the database ...\n@@ -420,7 +420,7 @@ <h2>Filters</h2>\n based filtering policy with the database.  Bloom filter based\n filtering relies on keeping some number of bits of data in memory per\n key (in this case 10 bits per key since that is the argument we passed\n-to NewBloomFilter).  This filter will reduce the number of unnecessary\n+to NewBloomFilterPolicy).  This filter will reduce the number of unnecessary\n disk reads needed for <code>Get()</code> calls by a factor of\n approximately a 100.  Increasing the bits per key will lead to a\n larger reduction at the cost of more memory usage.  We recommend that\n@@ -430,15 +430,15 @@ <h2>Filters</h2>\n If you are using a custom comparator, you should ensure that the filter\n policy you are using is compatible with your comparator.  For example,\n consider a comparator that ignores trailing spaces when comparing keys.\n-<code>NewBloomFilter</code> must not be used with such a comparator.\n+<code>NewBloomFilterPolicy</code> must not be used with such a comparator.\n Instead, the application should provide a custom filter policy that\n also ignores trailing spaces.  For example:\n <pre>\n   class CustomFilterPolicy : public leveldb::FilterPolicy {\n    private:\n     FilterPolicy* builtin_policy_;\n    public:\n-    CustomFilterPolicy() : builtin_policy_(NewBloomFilter(10)) { }\n+    CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) { }\n     ~CustomFilterPolicy() { delete builtin_policy_; }\n \n     const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }"
      },
      {
        "sha": "5228f624de4347c114b87520c12a1ae39425d411",
        "filename": "src/leveldb/doc/log_format.txt",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.txt?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -4,8 +4,8 @@ exception is that the tail of the file may contain a partial block.\n Each block consists of a sequence of records:\n    block := record* trailer?\n    record :=\n-\tchecksum: uint32\t// crc32c of type and data[]\n-\tlength: uint16\n+\tchecksum: uint32\t// crc32c of type and data[] ; little-endian\n+\tlength: uint16\t\t// little-endian\n \ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n \tdata: uint8[length]\n "
      },
      {
        "sha": "ca8f9b4460ad85d9e09f14a959ed47bd2812edb5",
        "filename": "src/leveldb/doc/table_format.txt",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.txt?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -18,6 +18,8 @@ The file contains internal pointers.  Each such pointer is called\n a BlockHandle and contains the following information:\n   offset:\t    varint64\n   size:\t\t    varint64\n+See https://developers.google.com/protocol-buffers/docs/encoding#varints\n+for an explanation of varint64 format.\n \n (1) The sequence of key/value pairs in the file are stored in sorted\n order and partitioned into a sequence of data blocks.  These blocks\n@@ -41,11 +43,11 @@ BlockHandle for the data block.\n \n (6) At the very end of the file is a fixed length footer that contains\n the BlockHandle of the metaindex and index blocks as well as a magic number.\n-       metaindex_handle:       char[p];    // Block handle for metaindex\n-       index_handle:\t       char[q];    // Block handle for index\n-       padding:\t\t       char[40-p-q]; // 0 bytes to make fixed length\n-       \t\t\t \t       // (40==2*BlockHandle::kMaxEncodedLength)\n-       magic:\t\t       fixed64;    // == 0xdb4775248b80fb57\n+       metaindex_handle: char[p];    // Block handle for metaindex\n+       index_handle:     char[q];    // Block handle for index\n+       padding:          char[40-p-q]; // zeroed bytes to make fixed length\n+                                       // (40==2*BlockHandle::kMaxEncodedLength)\n+       magic:            fixed64;    // == 0xdb4775248b80fb57 (little-endian)\n \n \"filter\" Meta Block\n -------------------"
      },
      {
        "sha": "5879de121456a7c5c16457eb36d85c64ad0a1b61",
        "filename": "src/leveldb/helpers/memenv/memenv.cc",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/helpers/memenv/memenv.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/helpers/memenv/memenv.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/helpers/memenv/memenv.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -221,6 +221,11 @@ class WritableFileImpl : public WritableFile {\n   FileState* file_;\n };\n \n+class NoOpLogger : public Logger {\n+ public:\n+  virtual void Logv(const char* format, va_list ap) { }\n+};\n+\n class InMemoryEnv : public EnvWrapper {\n  public:\n   explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }\n@@ -358,6 +363,11 @@ class InMemoryEnv : public EnvWrapper {\n     return Status::OK();\n   }\n \n+  virtual Status NewLogger(const std::string& fname, Logger** result) {\n+    *result = new NoOpLogger;\n+    return Status::OK();\n+  }\n+\n  private:\n   // Map from filenames to FileState objects, representing a simple file system.\n   typedef std::map<std::string, FileState*> FileSystem;"
      },
      {
        "sha": "1fa58866c3958c66d7c68b264aa4ee4ccdf51c68",
        "filename": "src/leveldb/include/leveldb/c.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/c.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/c.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/c.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -28,6 +28,7 @@\n   be true on entry:\n      *errptr == NULL\n      *errptr points to a malloc()ed null-terminated error message\n+       (On Windows, *errptr must have been malloc()-ed by this library.)\n   On success, a leveldb routine leaves *errptr unchanged.\n   On failure, leveldb frees the old value of *errptr and\n   set *errptr to a malloc()ed error message.\n@@ -268,6 +269,21 @@ extern void leveldb_cache_destroy(leveldb_cache_t* cache);\n extern leveldb_env_t* leveldb_create_default_env();\n extern void leveldb_env_destroy(leveldb_env_t*);\n \n+/* Utility */\n+\n+/* Calls free(ptr).\n+   REQUIRES: ptr was malloc()-ed and returned by one of the routines\n+   in this file.  Note that in certain cases (typically on Windows), you\n+   may need to call this routine instead of free(ptr) to dispose of\n+   malloc()-ed memory returned by this library. */\n+extern void leveldb_free(void* ptr);\n+\n+/* Return the major version number for this release. */\n+extern int leveldb_major_version();\n+\n+/* Return the minor version number for this release. */\n+extern int leveldb_minor_version();\n+\n #ifdef __cplusplus\n }  /* end extern \"C\" */\n #endif"
      },
      {
        "sha": "79142f5b254543261d4cbc8570a91de16a208df5",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 5;\n+static const int kMinorVersion = 7;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "fa32289f581fd4d222dc74ea177a78138b71fbc2",
        "filename": "src/leveldb/include/leveldb/env.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/env.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/include/leveldb/env.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/env.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -175,6 +175,11 @@ class SequentialFile {\n   //\n   // REQUIRES: External synchronization\n   virtual Status Skip(uint64_t n) = 0;\n+\n+ private:\n+  // No copying allowed\n+  SequentialFile(const SequentialFile&);\n+  void operator=(const SequentialFile&);\n };\n \n // A file abstraction for randomly reading the contents of a file.\n@@ -194,6 +199,11 @@ class RandomAccessFile {\n   // Safe for concurrent use by multiple threads.\n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const = 0;\n+\n+ private:\n+  // No copying allowed\n+  RandomAccessFile(const RandomAccessFile&);\n+  void operator=(const RandomAccessFile&);\n };\n \n // A file abstraction for sequential writing.  The implementation"
      },
      {
        "sha": "e17bf435eab33e55a87046e705a1ecb04dad7e24",
        "filename": "src/leveldb/port/atomic_pointer.h",
        "status": "modified",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/atomic_pointer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/atomic_pointer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/atomic_pointer.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -36,6 +36,8 @@\n #define ARCH_CPU_X86_FAMILY 1\n #elif defined(__ARMEL__)\n #define ARCH_CPU_ARM_FAMILY 1\n+#elif defined(__ppc__) || defined(__powerpc__) || defined(__powerpc64__)\n+#define ARCH_CPU_PPC_FAMILY 1\n #endif\n \n namespace leveldb {\n@@ -91,6 +93,15 @@ inline void MemoryBarrier() {\n }\n #define LEVELDB_HAVE_MEMORY_BARRIER\n \n+// PPC\n+#elif defined(ARCH_CPU_PPC_FAMILY) && defined(__GNUC__)\n+inline void MemoryBarrier() {\n+  // TODO for some powerpc expert: is there a cheaper suitable variant?\n+  // Perhaps by having separate barriers for acquire and release ops.\n+  asm volatile(\"sync\" : : : \"memory\");\n+}\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n #endif\n \n // AtomicPointer built using platform-specific MemoryBarrier()\n@@ -136,6 +147,66 @@ class AtomicPointer {\n   }\n };\n \n+// Atomic pointer based on sparc memory barriers\n+#elif defined(__sparcv9) && defined(__GNUC__)\n+class AtomicPointer {\n+ private:\n+  void* rep_;\n+ public:\n+  AtomicPointer() { }\n+  explicit AtomicPointer(void* v) : rep_(v) { }\n+  inline void* Acquire_Load() const {\n+    void* val;\n+    __asm__ __volatile__ (\n+        \"ldx [%[rep_]], %[val] \\n\\t\"\n+         \"membar #LoadLoad|#LoadStore \\n\\t\"\n+        : [val] \"=r\" (val)\n+        : [rep_] \"r\" (&rep_)\n+        : \"memory\");\n+    return val;\n+  }\n+  inline void Release_Store(void* v) {\n+    __asm__ __volatile__ (\n+        \"membar #LoadStore|#StoreStore \\n\\t\"\n+        \"stx %[v], [%[rep_]] \\n\\t\"\n+        :\n+        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n+        : \"memory\");\n+  }\n+  inline void* NoBarrier_Load() const { return rep_; }\n+  inline void NoBarrier_Store(void* v) { rep_ = v; }\n+};\n+\n+// Atomic pointer based on ia64 acq/rel\n+#elif defined(__ia64) && defined(__GNUC__)\n+class AtomicPointer {\n+ private:\n+  void* rep_;\n+ public:\n+  AtomicPointer() { }\n+  explicit AtomicPointer(void* v) : rep_(v) { }\n+  inline void* Acquire_Load() const {\n+    void* val    ;\n+    __asm__ __volatile__ (\n+        \"ld8.acq %[val] = [%[rep_]] \\n\\t\"\n+        : [val] \"=r\" (val)\n+        : [rep_] \"r\" (&rep_)\n+        : \"memory\"\n+        );\n+    return val;\n+  }\n+  inline void Release_Store(void* v) {\n+    __asm__ __volatile__ (\n+        \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n+        :\n+        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n+        : \"memory\"\n+        );\n+  }\n+  inline void* NoBarrier_Load() const { return rep_; }\n+  inline void NoBarrier_Store(void* v) { rep_ = v; }\n+};\n+\n // We have neither MemoryBarrier(), nor <cstdatomic>\n #else\n #error Please implement AtomicPointer for this platform.\n@@ -145,6 +216,7 @@ class AtomicPointer {\n #undef LEVELDB_HAVE_MEMORY_BARRIER\n #undef ARCH_CPU_X86_FAMILY\n #undef ARCH_CPU_ARM_FAMILY\n+#undef ARCH_CPU_PPC_FAMILY\n \n }  // namespace port\n }  // namespace leveldb"
      },
      {
        "sha": "e667db40d0d5046da2d68d45f1e83f8529cefa4e",
        "filename": "src/leveldb/port/port.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/port.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/port.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -14,8 +14,6 @@\n #  include \"port/port_posix.h\"\n #elif defined(LEVELDB_PLATFORM_CHROMIUM)\n #  include \"port/port_chromium.h\"\n-#elif defined(LEVELDB_PLATFORM_WINDOWS)\n-#  include \"port/port_win.h\"\n #endif\n \n #endif  // STORAGE_LEVELDB_PORT_PORT_H_"
      },
      {
        "sha": "786cd6018a50e3882848f32d7d51794027eeb086",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "removed",
        "additions": 0,
        "deletions": 182,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=c429f2b062140843f42b78d70278279c6be74441",
        "patch": "@@ -1,182 +0,0 @@\n-// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file. See the AUTHORS file for names of contributors.\n-//\n-// See port_example.h for documentation for the following types/functions.\n-\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions are met:\n-// \n-//  * Redistributions of source code must retain the above copyright\n-//    notice, this list of conditions and the following disclaimer.\n-//  * Redistributions in binary form must reproduce the above copyright\n-//    notice, this list of conditions and the following disclaimer in the\n-//    documentation and/or other materials provided with the distribution.\n-//  * Neither the name of the University of California, Berkeley nor the\n-//    names of its contributors may be used to endorse or promote products\n-//    derived from this software without specific prior written permission.\n-// \n-// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n-// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n-// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n-// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-//\n-\n-#include \"port/port_win.h\"\n-\n-#include <windows.h>\n-#include <cassert>\n-\n-namespace leveldb {\n-namespace port {\n-\n-Mutex::Mutex() :\n-    mutex_(::CreateMutex(NULL, FALSE, NULL)) {\n-  assert(mutex_);\n-}\n-\n-Mutex::~Mutex() {\n-  assert(mutex_);\n-  ::CloseHandle(mutex_);\n-}\n-\n-void Mutex::Lock() {\n-  assert(mutex_);\n-  ::WaitForSingleObject(mutex_, INFINITE);\n-}\n-\n-void Mutex::Unlock() {\n-  assert(mutex_);\n-  ::ReleaseMutex(mutex_);\n-}\n-\n-void Mutex::AssertHeld() {\n-  assert(mutex_);\n-  assert(1);\n-}\n-\n-CondVar::CondVar(Mutex* mu) :\n-    waiting_(0), \n-    mu_(mu), \n-    sema_(::CreateSemaphore(NULL, 0, 0x7fffffff, NULL)), \n-    event_(::CreateEvent(NULL, FALSE, FALSE, NULL)),\n-    broadcasted_(false){\n-  assert(mu_);\n-}\n-\n-CondVar::~CondVar() {\n-  ::CloseHandle(sema_);\n-  ::CloseHandle(event_);\n-}\n-\n-void CondVar::Wait() {\n-  wait_mtx_.Lock();\n-  ++waiting_;\n-  assert(waiting_ > 0);\n-  wait_mtx_.Unlock();\n-\n-  ::SignalObjectAndWait(mu_->mutex_, sema_, INFINITE, FALSE);\n-\n-  wait_mtx_.Lock();\n-  bool last = broadcasted_ && (--waiting_ == 0);\n-  assert(waiting_ >= 0);\n-  wait_mtx_.Unlock();\n-\n-  // we leave this function with the mutex held\n-  if (last)\n-  {\n-    ::SignalObjectAndWait(event_, mu_->mutex_, INFINITE, FALSE);\n-  }\n-  else\n-  {\n-    ::WaitForSingleObject(mu_->mutex_, INFINITE);\n-  }\n-}\n-\n-void CondVar::Signal() {\n-  wait_mtx_.Lock();\n-  bool waiters = waiting_ > 0;\n-  wait_mtx_.Unlock();\n-\n-  if (waiters)\n-  {\n-    ::ReleaseSemaphore(sema_, 1, 0);\n-  }\n-}\n-\n-void CondVar::SignalAll() {\n-  wait_mtx_.Lock();\n-\n-  broadcasted_ = (waiting_ > 0);\n-\n-  if (broadcasted_)\n-  {\n-      // release all\n-    ::ReleaseSemaphore(sema_, waiting_, 0);\n-    wait_mtx_.Unlock();\n-    ::WaitForSingleObject(event_, INFINITE);\n-    broadcasted_ = false;\n-  }\n-  else\n-  {\n-    wait_mtx_.Unlock();\n-  }\n-}\n-\n-AtomicPointer::AtomicPointer(void* v) {\n-  Release_Store(v);\n-}\n-\n-void* AtomicPointer::Acquire_Load() const {\n-  void * p = NULL;\n-  InterlockedExchangePointer(&p, rep_);\n-  return p;\n-}\n-\n-void AtomicPointer::Release_Store(void* v) {\n-  InterlockedExchangePointer(&rep_, v);\n-}\n-\n-void* AtomicPointer::NoBarrier_Load() const {\n-  return rep_;\n-}\n-\n-void AtomicPointer::NoBarrier_Store(void* v) {\n-  rep_ = v;\n-}\n-\n-enum InitializationState\n-{\n-    Uninitialized = 0,\n-    Running = 1,\n-    Initialized = 2\n-};\n-\n-void InitOnce(OnceType* once, void (*initializer)()) {\n-\n-  assert(Uninitialized == LEVELDB_ONCE_INIT);\n-\n-  InitializationState state = static_cast<InitializationState>(InterlockedCompareExchange(once, Running, Uninitialized));\n-\n-  if (state == Uninitialized) {\n-      initializer();\n-      *once = Initialized;\n-  }\n-\n-  if (state == Running) {\n-      while(*once != Initialized) {\n-          Sleep(0); // yield\n-      }\n-  }\n-\n-  assert(*once == Initialized);\n-}\n-\n-}\n-}"
      },
      {
        "sha": "893919998ce71e7e830a43d63743ee8cc67e316b",
        "filename": "src/leveldb/port/port_win.h",
        "status": "removed",
        "additions": 0,
        "deletions": 161,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=c429f2b062140843f42b78d70278279c6be74441",
        "patch": "@@ -1,161 +0,0 @@\n-// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file. See the AUTHORS file for names of contributors.\n-//\n-// See port_example.h for documentation for the following types/functions.\n-\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions are met:\n-// \n-//  * Redistributions of source code must retain the above copyright\n-//    notice, this list of conditions and the following disclaimer.\n-//  * Redistributions in binary form must reproduce the above copyright\n-//    notice, this list of conditions and the following disclaimer in the\n-//    documentation and/or other materials provided with the distribution.\n-//  * Neither the name of the University of California, Berkeley nor the\n-//    names of its contributors may be used to endorse or promote products\n-//    derived from this software without specific prior written permission.\n-// \n-// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n-// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n-// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n-// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-//\n-\n-#ifndef STORAGE_LEVELDB_PORT_PORT_WIN_H_\n-#define STORAGE_LEVELDB_PORT_PORT_WIN_H_\n-\n-#ifdef _MSC_VER\n-#define snprintf _snprintf\n-#define close _close\n-#define fread_unlocked _fread_nolock\n-#endif\n-\n-\n-#ifdef SNAPPY\n-#include <snappy/snappy.h>\n-#endif\n-\n-#include <string>\n-\n-#include <stdint.h>\n-\n-namespace leveldb {\n-namespace port {\n-\n-// Windows is little endian (for now :p)\n-static const bool kLittleEndian = true;\n-\n-class CondVar;\n-\n-class Mutex {\n- public:\n-  Mutex();\n-  ~Mutex();\n-\n-  void Lock();\n-  void Unlock();\n-  void AssertHeld();\n-\n- private:\n-  friend class CondVar;\n-  // critical sections are more efficient than mutexes\n-  // but they are not recursive and can only be used to synchronize threads within the same process\n-  // additionnaly they cannot be used with SignalObjectAndWait that we use for CondVar\n-  // we use opaque void * to avoid including windows.h in port_win.h\n-  void * mutex_;\n-\n-  // No copying\n-  Mutex(const Mutex&);\n-  void operator=(const Mutex&);\n-};\n-\n-// the Win32 API offers a dependable condition variable mechanism, but only starting with\n-// Windows 2008 and Vista\n-// no matter what we will implement our own condition variable with a semaphore\n-// implementation as described in a paper written by Douglas C. Schmidt and Irfan Pyarali\n-class CondVar {\n- public:\n-  explicit CondVar(Mutex* mu);\n-  ~CondVar();\n-  void Wait();\n-  void Signal();\n-  void SignalAll();\n- private:\n-  Mutex* mu_;\n-  \n-  Mutex wait_mtx_;\n-  long waiting_;\n-  \n-  void * sema_;\n-  void * event_;\n-\n-  bool broadcasted_;  \n-};\n-\n-// Storage for a lock-free pointer\n-class AtomicPointer {\n- private:\n-  void * rep_;\n- public:\n-  AtomicPointer() : rep_(NULL) { }\n-  explicit AtomicPointer(void* v); \n-  void* Acquire_Load() const;\n-\n-  void Release_Store(void* v);\n-\n-  void* NoBarrier_Load() const;\n-\n-  void NoBarrier_Store(void* v);\n-};\n-\n-typedef volatile long OnceType;\n-#define LEVELDB_ONCE_INIT (0)\n-\n-extern void InitOnce(OnceType* once, void (*initializer)());\n-\n-inline bool Snappy_Compress(const char* input, size_t length,\n-                            ::std::string* output) {\n-#ifdef SNAPPY\n-  output->resize(snappy::MaxCompressedLength(length));\n-  size_t outlen;\n-  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n-  output->resize(outlen);\n-  return true;\n-#endif\n-\n-  return false;\n-}\n-\n-inline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n-                                         size_t* result) {\n-#ifdef SNAPPY\n-  return snappy::GetUncompressedLength(input, length, result);\n-#else\n-  return false;\n-#endif\n-}\n-\n-inline bool Snappy_Uncompress(const char* input, size_t length,\n-                              char* output) {\n-#ifdef SNAPPY\n-  return snappy::RawUncompress(input, length, output);\n-#else\n-  return false;\n-#endif\n-}\n-\n-inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n-  return false;\n-}\n-\n-}\n-}\n-\n-#endif  // STORAGE_LEVELDB_PORT_PORT_WIN_H_"
      },
      {
        "sha": "6f9b6a7924d68e16940254d6d21888eaae2a240d",
        "filename": "src/leveldb/port/thread_annotations.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/thread_annotations.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/port/thread_annotations.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/thread_annotations.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_PORT_THREAD_ANNOTATIONS_H\n+\n+// Some environments provide custom macros to aid in static thread-safety\n+// analysis.  Provide empty definitions of such macros unless they are already\n+// defined.\n+\n+#ifndef EXCLUSIVE_LOCKS_REQUIRED\n+#define EXCLUSIVE_LOCKS_REQUIRED(...)\n+#endif\n+\n+#ifndef SHARED_LOCKS_REQUIRED\n+#define SHARED_LOCKS_REQUIRED(...)\n+#endif\n+\n+#ifndef LOCKS_EXCLUDED\n+#define LOCKS_EXCLUDED(...)\n+#endif\n+\n+#ifndef LOCK_RETURNED\n+#define LOCK_RETURNED(x)\n+#endif\n+\n+#ifndef LOCKABLE\n+#define LOCKABLE\n+#endif\n+\n+#ifndef SCOPED_LOCKABLE\n+#define SCOPED_LOCKABLE\n+#endif\n+\n+#ifndef EXCLUSIVE_LOCK_FUNCTION\n+#define EXCLUSIVE_LOCK_FUNCTION(...)\n+#endif\n+\n+#ifndef SHARED_LOCK_FUNCTION\n+#define SHARED_LOCK_FUNCTION(...)\n+#endif\n+\n+#ifndef EXCLUSIVE_TRYLOCK_FUNCTION\n+#define EXCLUSIVE_TRYLOCK_FUNCTION(...)\n+#endif\n+\n+#ifndef SHARED_TRYLOCK_FUNCTION\n+#define SHARED_TRYLOCK_FUNCTION(...)\n+#endif\n+\n+#ifndef UNLOCK_FUNCTION\n+#define UNLOCK_FUNCTION(...)\n+#endif\n+\n+#ifndef NO_THREAD_SAFETY_ANALYSIS\n+#define NO_THREAD_SAFETY_ANALYSIS\n+#endif\n+\n+#endif  // STORAGE_LEVELDB_PORT_THREAD_ANNOTATIONS_H"
      },
      {
        "sha": "ab83c1112cc10c0ad65e628db91cdcc27dc9e8c4",
        "filename": "src/leveldb/table/block.cc",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/table/block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/table/block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/block.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -162,8 +162,8 @@ class Block::Iter : public Iterator {\n   }\n \n   virtual void Seek(const Slice& target) {\n-    // Binary search in restart array to find the first restart point\n-    // with a key >= target\n+    // Binary search in restart array to find the last restart point\n+    // with a key < target\n     uint32_t left = 0;\n     uint32_t right = num_restarts_ - 1;\n     while (left < right) {"
      },
      {
        "sha": "0bf8e8d6ebeae860d7d553538511ef2ac6e80f22",
        "filename": "src/leveldb/util/bloom_test.cc",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/bloom_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/bloom_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/bloom_test.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"leveldb/filter_policy.h\"\n \n+#include \"util/coding.h\"\n #include \"util/logging.h\"\n #include \"util/testharness.h\"\n #include \"util/testutil.h\"\n@@ -13,8 +14,8 @@ namespace leveldb {\n static const int kVerbose = 1;\n \n static Slice Key(int i, char* buffer) {\n-  memcpy(buffer, &i, sizeof(i));\n-  return Slice(buffer, sizeof(i));\n+  EncodeFixed32(buffer, i);\n+  return Slice(buffer, sizeof(uint32_t));\n }\n \n class BloomTest {"
      },
      {
        "sha": "21e3186d5dcff984a11563fd0d09c714426a29c3",
        "filename": "src/leveldb/util/coding.cc",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/coding.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/coding.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/coding.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -7,29 +7,29 @@\n namespace leveldb {\n \n void EncodeFixed32(char* buf, uint32_t value) {\n-#if __BYTE_ORDER == __LITTLE_ENDIAN\n-  memcpy(buf, &value, sizeof(value));\n-#else\n-  buf[0] = value & 0xff;\n-  buf[1] = (value >> 8) & 0xff;\n-  buf[2] = (value >> 16) & 0xff;\n-  buf[3] = (value >> 24) & 0xff;\n-#endif\n+  if (port::kLittleEndian) {\n+    memcpy(buf, &value, sizeof(value));\n+  } else {\n+    buf[0] = value & 0xff;\n+    buf[1] = (value >> 8) & 0xff;\n+    buf[2] = (value >> 16) & 0xff;\n+    buf[3] = (value >> 24) & 0xff;\n+  }\n }\n \n void EncodeFixed64(char* buf, uint64_t value) {\n-#if __BYTE_ORDER == __LITTLE_ENDIAN\n-  memcpy(buf, &value, sizeof(value));\n-#else\n-  buf[0] = value & 0xff;\n-  buf[1] = (value >> 8) & 0xff;\n-  buf[2] = (value >> 16) & 0xff;\n-  buf[3] = (value >> 24) & 0xff;\n-  buf[4] = (value >> 32) & 0xff;\n-  buf[5] = (value >> 40) & 0xff;\n-  buf[6] = (value >> 48) & 0xff;\n-  buf[7] = (value >> 56) & 0xff;\n-#endif\n+  if (port::kLittleEndian) {\n+    memcpy(buf, &value, sizeof(value));\n+  } else {\n+    buf[0] = value & 0xff;\n+    buf[1] = (value >> 8) & 0xff;\n+    buf[2] = (value >> 16) & 0xff;\n+    buf[3] = (value >> 24) & 0xff;\n+    buf[4] = (value >> 32) & 0xff;\n+    buf[5] = (value >> 40) & 0xff;\n+    buf[6] = (value >> 48) & 0xff;\n+    buf[7] = (value >> 56) & 0xff;\n+  }\n }\n \n void PutFixed32(std::string* dst, uint32_t value) {"
      },
      {
        "sha": "055c65743841a83b00ff8045160193da2250866e",
        "filename": "src/leveldb/util/env_boost.cc",
        "status": "removed",
        "additions": 0,
        "deletions": 591,
        "changes": 591,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/env_boost.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/env_boost.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_boost.cc?ref=c429f2b062140843f42b78d70278279c6be74441",
        "patch": "@@ -1,591 +0,0 @@\n-// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file. See the AUTHORS file for names of contributors.\n-\n-#include <deque>\n-\n-#ifdef LEVELDB_PLATFORM_WINDOWS\n-#include <windows.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/stat.h>\n-#include <sys/types.h>\n-#include <time.h>\n-#include <io.h>\n-#else\n-#include <dirent.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <pthread.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/mman.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <sys/param.h>\n-#include <time.h>\n-#include <unistd.h>\n-#endif\n-#if defined(LEVELDB_PLATFORM_ANDROID)\n-#include <sys/stat.h>\n-#endif\n-#include \"leveldb/env.h\"\n-#include \"leveldb/slice.h\"\n-\n-#ifdef LEVELDB_PLATFORM_WINDOWS\n-#include \"util/win_logger.h\"\n-#else\n-#include \"util/posix_logger.h\"\n-#endif\n-#include \"port/port.h\"\n-#include \"util/logging.h\"\n-\n-#ifdef __linux\n-#include <sys/sysinfo.h>\n-#include <linux/unistd.h>\n-#endif\n-\n-#include <fstream>\n-\n-// Boost includes - see WINDOWS file to see which modules to install\n-#include <boost/date_time/gregorian/gregorian.hpp>\n-#include <boost/date_time/posix_time/posix_time.hpp>\n-#include <boost/filesystem/convenience.hpp>\n-#include <boost/thread/once.hpp>\n-#include <boost/thread/thread.hpp>\n-#include <boost/bind.hpp>\n-#include <boost/scoped_ptr.hpp>\n-#include <boost/interprocess/sync/file_lock.hpp>\n-#include <boost/thread/condition_variable.hpp>\n-\n-namespace leveldb {\n-namespace {\n-\n-// returns the ID of the current process\n-static boost::uint32_t current_process_id(void) {\n-#ifdef _WIN32\n-  return static_cast<boost::uint32_t>(::GetCurrentProcessId());\n-#else\n-  return static_cast<boost::uint32_t>(::getpid());\n-#endif\n-}\n-\n-// returns the ID of the current thread\n-static boost::uint32_t current_thread_id(void) {\n-#ifdef _WIN32\n-  return static_cast<boost::uint32_t>(::GetCurrentThreadId());\n-#else\n-#ifdef __linux\n-  return static_cast<boost::uint32_t>(::syscall(__NR_gettid));\n-#else\n-  // just return the pid\n-  return current_process_id();\n-#endif\n-#endif\n-}\n-\n-static char global_read_only_buf[0x8000];\n-\n-class PosixSequentialFile: public SequentialFile {\n- private:\n-  std::string filename_;\n-  FILE* file_;\n-\n- public:\n-  PosixSequentialFile(const std::string& fname, FILE* f)\n-    : filename_(fname), file_(f) { }\n-  virtual ~PosixSequentialFile() { fclose(file_); }\n-\n-  virtual Status Read(size_t n, Slice* result, char* scratch) {\n-  Status s;\n-#if defined(BSD) || defined(__MINGW32__)\n-  // fread_unlocked doesn't exist on FreeBSD or MingW\n-  size_t r = fread(scratch, 1, n, file_);\n-#else\n-  size_t r = fread_unlocked(scratch, 1, n, file_);\n-#endif\n-  *result = Slice(scratch, r);\n-  if (r < n) {\n-    if (feof(file_)) {\n-    // We leave status as ok if we hit the end of the file\n-    } else {\n-    // A partial read with an error: return a non-ok status\n-    s = Status::IOError(filename_, strerror(errno));\n-    }\n-  }\n-  return s;\n-  }\n-\n-  virtual Status Skip(uint64_t n) {\n-  if (fseek(file_, n, SEEK_CUR)) {\n-    return Status::IOError(filename_, strerror(errno));\n-  }\n-  return Status::OK();\n-  }\n-};\n-\n-class PosixRandomAccessFile: public RandomAccessFile {\n- private:\n-  std::string filename_;\n-  int fd_;\n-  mutable boost::mutex mu_;\n-\n- public:\n-  PosixRandomAccessFile(const std::string& fname, int fd)\n-    : filename_(fname), fd_(fd) { }\n-  virtual ~PosixRandomAccessFile() { close(fd_); }\n-\n-  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n-            char* scratch) const {\n-    Status s;\n-#ifdef LEVELDB_PLATFORM_WINDOWS\n-    // no pread on Windows so we emulate it with a mutex\n-    boost::unique_lock<boost::mutex> lock(mu_);\n-\n-    if (::_lseeki64(fd_, offset, SEEK_SET) == -1L) {\n-      return Status::IOError(filename_, strerror(errno));\n-    }\n-\n-    int r = ::_read(fd_, scratch, n);\n-    *result = Slice(scratch, (r < 0) ? 0 : r);\n-    lock.unlock();\n-#else\n-    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n-    *result = Slice(scratch, (r < 0) ? 0 : r);\n-#endif\n-    if (r < 0) {\n-      // An error: return a non-ok status\n-      s = Status::IOError(filename_, strerror(errno));\n-    }\n-    return s;\n-  }\n-};\n-\n-// We preallocate up to an extra megabyte and use memcpy to append new\n-// data to the file.  This is safe since we either properly close the\n-// file before reading from it, or for log files, the reading code\n-// knows enough to skip zero suffixes.\n-\n-class BoostFile : public WritableFile {\n-\n-public:\n-  explicit BoostFile(std::string path) : path_(path), written_(0) {\n-    Open();\n-  }\n-\n-  virtual ~BoostFile() {\n-    Close();\n-  }\n-\n-private:\n-  void Open() {\n-    // we truncate the file as implemented in env_posix\n-     file_.open(path_.generic_string().c_str(), \n-         std::ios_base::trunc | std::ios_base::out | std::ios_base::binary);\n-     written_ = 0;\n-  }\n-\n-public:\n-  virtual Status Append(const Slice& data) {\n-    Status result;\n-    file_.write(data.data(), data.size());\n-    if (!file_.good()) {\n-      result = Status::IOError(\n-          path_.generic_string() + \" Append\", \"cannot write\");\n-    }\n-    return result;\n-  }\n-\n-  virtual Status Close() {\n-    Status result;\n-\n-    try {\n-      if (file_.is_open()) {\n-        Sync();\n-        file_.close();\n-      }\n-    } catch (const std::exception & e) {\n-      result = Status::IOError(path_.generic_string() + \" close\", e.what());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual Status Flush() {\n-    file_.flush();\n-    return Status::OK();\n-  }\n-\n-  virtual Status Sync() {\n-    Status result;\n-    try {\n-      Flush();\n-    } catch (const std::exception & e) {\n-      result = Status::IOError(path_.string() + \" sync\", e.what());\n-    }\n-\n-    return result;\n-  }\n-\n-private:\n-  boost::filesystem::path path_;\n-  boost::uint64_t written_;\n-  std::ofstream file_;\n-};\n-\n-\n-\n-class BoostFileLock : public FileLock {\n- public:\n-  boost::interprocess::file_lock fl_;\n-};\n-\n-class PosixEnv : public Env {\n- public:\n-  PosixEnv();\n-  virtual ~PosixEnv() {\n-    fprintf(stderr, \"Destroying Env::Default()\\n\");\n-    exit(1);\n-  }\n-\n-  virtual Status NewSequentialFile(const std::string& fname,\n-                   SequentialFile** result) {\n-    FILE* f = fopen(fname.c_str(), \"rb\");\n-    if (f == NULL) {\n-      *result = NULL;\n-      return Status::IOError(fname, strerror(errno));\n-    } else {\n-      *result = new PosixSequentialFile(fname, f);\n-      return Status::OK();\n-    }\n-  }\n-\n-  virtual Status NewRandomAccessFile(const std::string& fname,\n-                   RandomAccessFile** result) {\n-#ifdef LEVELDB_PLATFORM_WINDOWS\n-    int fd = _open(fname.c_str(), _O_RDONLY | _O_RANDOM | _O_BINARY);\n-#else\n-    int fd = open(fname.c_str(), O_RDONLY);\n-#endif\n-    if (fd < 0) {\n-      *result = NULL;\n-      return Status::IOError(fname, strerror(errno));\n-    }\n-    *result = new PosixRandomAccessFile(fname, fd);\n-    return Status::OK();\n-  }\n-\n-  virtual Status NewWritableFile(const std::string& fname,\n-                 WritableFile** result) {\n-    Status s;\n-    try {\n-      // will create a new empty file to write to\n-      *result = new BoostFile(fname);\n-    }\n-    catch (const std::exception & e) {\n-      s = Status::IOError(fname, e.what());\n-    }\n-\n-    return s;\n-  }\n-\n-  virtual bool FileExists(const std::string& fname) {\n-    return boost::filesystem::exists(fname);\n-  }\n-\n-  virtual Status GetChildren(const std::string& dir,\n-               std::vector<std::string>* result) {\n-    result->clear();\n-\n-    boost::system::error_code ec;\n-    boost::filesystem::directory_iterator current(dir, ec);\n-    if (ec != 0) {\n-      return Status::IOError(dir, ec.message());\n-    }\n-\n-    boost::filesystem::directory_iterator end;\n-\n-    for(; current != end; ++current) {\n-      result->push_back(current->path().filename().generic_string());\n-    }\n-\n-    return Status::OK();\n-  }\n-\n-  virtual Status DeleteFile(const std::string& fname) {\n-    boost::system::error_code ec;\n-\n-    boost::filesystem::remove(fname, ec);\n-\n-    Status result;\n-\n-    if (ec != 0) {\n-      result = Status::IOError(fname, ec.message());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual Status CreateDir(const std::string& name) {\n-      Status result;\n-\n-      if (boost::filesystem::exists(name) &&\n-          boost::filesystem::is_directory(name)) {\n-        return result;\n-      }\n-\n-      boost::system::error_code ec;\n-\n-      if (!boost::filesystem::create_directories(name, ec)) {\n-        result = Status::IOError(name, ec.message());\n-      }\n-\n-      return result;\n-    };\n-\n-    virtual Status DeleteDir(const std::string& name) {\n-    Status result;\n-\n-    boost::system::error_code ec;\n-    if (!boost::filesystem::remove_all(name, ec)) {\n-      result = Status::IOError(name, ec.message());\n-    }\n-\n-    return result;\n-  };\n-\n-  virtual Status GetFileSize(const std::string& fname, uint64_t* size) {\n-    boost::system::error_code ec;\n-\n-    Status result;\n-\n-    *size = static_cast<uint64_t>(boost::filesystem::file_size(fname, ec));\n-    if (ec != 0) {\n-      *size = 0;\n-       result = Status::IOError(fname, ec.message());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual Status RenameFile(const std::string& src, const std::string& target) {\n-    boost::system::error_code ec;\n-\n-    boost::filesystem::rename(src, target, ec);\n-\n-    Status result;\n-\n-    if (ec != 0) {\n-      result = Status::IOError(src, ec.message());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual Status LockFile(const std::string& fname, FileLock** lock) {\n-    *lock = NULL;\n-\n-    Status result;\n-\n-    try {\n-      if (!boost::filesystem::exists(fname)) {\n-        std::ofstream of(fname.c_str(), std::ios_base::trunc | std::ios_base::out);\n-      }\n-\n-      assert(boost::filesystem::exists(fname));\n-\n-      boost::interprocess::file_lock fl(fname.c_str());\n-      BoostFileLock * my_lock = new BoostFileLock();\n-      fl.swap(my_lock->fl_);\n-      if (!my_lock->fl_.try_lock()) {\n-          return Status::IOError(\"database already in use: could not acquire exclusive lock\");\n-      }\n-      *lock = my_lock;\n-    } catch (const std::exception & e) {\n-      result = Status::IOError(\"lock \" + fname, e.what());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual Status UnlockFile(FileLock* lock) {\n-\n-    Status result;\n-\n-    try {\n-      BoostFileLock * my_lock = static_cast<BoostFileLock *>(lock);\n-      my_lock->fl_.unlock();\n-      delete my_lock;\n-    } catch (const std::exception & e) {\n-      result = Status::IOError(\"unlock\", e.what());\n-    }\n-\n-    return result;\n-  }\n-\n-  virtual void Schedule(void (*function)(void*), void* arg);\n-\n-  virtual void StartThread(void (*function)(void* arg), void* arg);\n-\n-  virtual Status GetTestDirectory(std::string* result) {\n-    boost::system::error_code ec;\n-    boost::filesystem::path temp_dir = \n-        boost::filesystem::temp_directory_path(ec);\n-    if (ec != 0) {\n-      temp_dir = \"tmp\";\n-    }\n-\n-    temp_dir /= \"leveldb_tests\";\n-    temp_dir /= boost::lexical_cast<std::string>(current_process_id());\n-\n-    // Directory may already exist\n-    CreateDir(temp_dir.generic_string());\n-\n-    *result = temp_dir.generic_string();\n-\n-    return Status::OK();\n-  }\n-\n-#ifndef LEVELDB_PLATFORM_WINDOWS\n-  static uint64_t gettid() {\n-    pthread_t tid = pthread_self();\n-    uint64_t thread_id = 0;\n-    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n-    return thread_id;\n-  }\n-#endif\n-\n-  virtual Status NewLogger(const std::string& fname, Logger** result) {\n-  FILE* f = fopen(fname.c_str(), \"wt\");\n-  if (f == NULL) {\n-    *result = NULL;\n-    return Status::IOError(fname, strerror(errno));\n-  } else {\n-#ifdef LEVELDB_PLATFORM_WINDOWS\n-    *result = new WinLogger(f);\n-#else\n-    *result = new PosixLogger(f, &PosixEnv::gettid);\n-#endif\n-    return Status::OK();\n-  }\n-  }\n-\n-  virtual uint64_t NowMicros() {\n-    return static_cast<uint64_t>(\n-        boost::posix_time::microsec_clock::universal_time()\n-        .time_of_day().total_microseconds());\n-  }\n-\n-  virtual void SleepForMicroseconds(int micros) {\n-  boost::this_thread::sleep(boost::posix_time::microseconds(micros));\n-  }\n-\n- private:\n-  void PthreadCall(const char* label, int result) {\n-  if (result != 0) {\n-    fprintf(stderr, \"pthread %s: %s\\n\", label, strerror(result));\n-    exit(1);\n-  }\n-  }\n-\n-  // BGThread() is the body of the background thread\n-  void BGThread();\n-\n-  static void* BGThreadWrapper(void* arg) {\n-    reinterpret_cast<PosixEnv*>(arg)->BGThread();\n-    return NULL;\n-  }\n-\n-  boost::mutex mu_;\n-  boost::condition_variable bgsignal_;\n-  boost::scoped_ptr<boost::thread> bgthread_;\n-\n-  // Entry per Schedule() call\n-  struct BGItem { void* arg; void (*function)(void*); };\n-  typedef std::deque<BGItem> BGQueue;\n-  BGQueue queue_;\n-};\n-\n-PosixEnv::PosixEnv() { }\n-\n-void PosixEnv::Schedule(void (*function)(void*), void* arg) {\n-  boost::unique_lock<boost::mutex> lock(mu_);\n-\n-  // Start background thread if necessary\n-  if (!bgthread_) {\n-     bgthread_.reset(\n-         new boost::thread(boost::bind(&PosixEnv::BGThreadWrapper, this)));\n-  }\n-\n-  // Add to priority queue\n-  queue_.push_back(BGItem());\n-  queue_.back().function = function;\n-  queue_.back().arg = arg;\n-\n-  lock.unlock();\n-\n-  bgsignal_.notify_one();\n-\n-}\n-\n-void PosixEnv::BGThread() {\n-  while (true) {\n-  // Wait until there is an item that is ready to run\n-  boost::unique_lock<boost::mutex> lock(mu_);\n-\n-  while (queue_.empty()) {\n-    bgsignal_.wait(lock);\n-  }\n-\n-  void (*function)(void*) = queue_.front().function;\n-  void* arg = queue_.front().arg;\n-  queue_.pop_front();\n-\n-  lock.unlock();\n-  (*function)(arg);\n-  }\n-}\n-\n-namespace {\n-struct StartThreadState {\n-  void (*user_function)(void*);\n-  void* arg;\n-};\n-}\n-\n-static void* StartThreadWrapper(void* arg) {\n-  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n-  state->user_function(state->arg);\n-  delete state;\n-  return NULL;\n-}\n-\n-void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n-  StartThreadState* state = new StartThreadState;\n-  state->user_function = function;\n-  state->arg = arg;\n-\n-  boost::thread t(boost::bind(&StartThreadWrapper, state));\n-}\n-\n-}\n-\n-static boost::once_flag once = BOOST_ONCE_INIT;\n-static Env* default_env;\n-static void InitDefaultEnv() { \n-  ::memset(global_read_only_buf, 0, sizeof(global_read_only_buf));\n-  default_env = new PosixEnv;\n-}\n-\n-Env* Env::Default() {\n-  boost::call_once(once, InitDefaultEnv);\n-\n-  return default_env;\n-}\n-\n-}"
      },
      {
        "sha": "78e09c95c99902383b152a630d522f4620f56222",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 95,
        "deletions": 6,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -3,6 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n \n #include <deque>\n+#include <set>\n #include <dirent.h>\n #include <errno.h>\n #include <fcntl.h>\n@@ -23,6 +24,7 @@\n #include \"leveldb/slice.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n+#include \"util/mutexlock.h\"\n #include \"util/posix_logger.h\"\n \n namespace leveldb {\n@@ -90,18 +92,75 @@ class PosixRandomAccessFile: public RandomAccessFile {\n   }\n };\n \n+// Helper class to limit mmap file usage so that we do not end up\n+// running out virtual memory or running into kernel performance\n+// problems for very large databases.\n+class MmapLimiter {\n+ public:\n+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n+  MmapLimiter() {\n+    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);\n+  }\n+\n+  // If another mmap slot is available, acquire it and return true.\n+  // Else return false.\n+  bool Acquire() {\n+    if (GetAllowed() <= 0) {\n+      return false;\n+    }\n+    MutexLock l(&mu_);\n+    intptr_t x = GetAllowed();\n+    if (x <= 0) {\n+      return false;\n+    } else {\n+      SetAllowed(x - 1);\n+      return true;\n+    }\n+  }\n+\n+  // Release a slot acquired by a previous call to Acquire() that returned true.\n+  void Release() {\n+    MutexLock l(&mu_);\n+    SetAllowed(GetAllowed() + 1);\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  port::AtomicPointer allowed_;\n+\n+  intptr_t GetAllowed() const {\n+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n+  }\n+\n+  // REQUIRES: mu_ must be held\n+  void SetAllowed(intptr_t v) {\n+    allowed_.Release_Store(reinterpret_cast<void*>(v));\n+  }\n+\n+  MmapLimiter(const MmapLimiter&);\n+  void operator=(const MmapLimiter&);\n+};\n+\n // mmap() based random-access\n class PosixMmapReadableFile: public RandomAccessFile {\n  private:\n   std::string filename_;\n   void* mmapped_region_;\n   size_t length_;\n+  MmapLimiter* limiter_;\n \n  public:\n   // base[0,length-1] contains the mmapped contents of the file.\n-  PosixMmapReadableFile(const std::string& fname, void* base, size_t length)\n-      : filename_(fname), mmapped_region_(base), length_(length) { }\n-  virtual ~PosixMmapReadableFile() { munmap(mmapped_region_, length_); }\n+  PosixMmapReadableFile(const std::string& fname, void* base, size_t length,\n+                        MmapLimiter* limiter)\n+      : filename_(fname), mmapped_region_(base), length_(length),\n+        limiter_(limiter) {\n+  }\n+\n+  virtual ~PosixMmapReadableFile() {\n+    munmap(mmapped_region_, length_);\n+    limiter_->Release();\n+  }\n \n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n@@ -300,6 +359,25 @@ static int LockOrUnlock(int fd, bool lock) {\n class PosixFileLock : public FileLock {\n  public:\n   int fd_;\n+  std::string name_;\n+};\n+\n+// Set of locked files.  We keep a separate set instead of just\n+// relying on fcntrl(F_SETLK) since fcntl(F_SETLK) does not provide\n+// any protection against multiple uses from the same process.\n+class PosixLockTable {\n+ private:\n+  port::Mutex mu_;\n+  std::set<std::string> locked_files_;\n+ public:\n+  bool Insert(const std::string& fname) {\n+    MutexLock l(&mu_);\n+    return locked_files_.insert(fname).second;\n+  }\n+  void Remove(const std::string& fname) {\n+    MutexLock l(&mu_);\n+    locked_files_.erase(fname);\n+  }\n };\n \n class PosixEnv : public Env {\n@@ -329,19 +407,21 @@ class PosixEnv : public Env {\n     int fd = open(fname.c_str(), O_RDONLY);\n     if (fd < 0) {\n       s = IOError(fname, errno);\n-    } else if (sizeof(void*) >= 8) {\n-      // Use mmap when virtual address-space is plentiful.\n+    } else if (mmap_limit_.Acquire()) {\n       uint64_t size;\n       s = GetFileSize(fname, &size);\n       if (s.ok()) {\n         void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n         if (base != MAP_FAILED) {\n-          *result = new PosixMmapReadableFile(fname, base, size);\n+          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);\n         } else {\n           s = IOError(fname, errno);\n         }\n       }\n       close(fd);\n+      if (!s.ok()) {\n+        mmap_limit_.Release();\n+      }\n     } else {\n       *result = new PosixRandomAccessFile(fname, fd);\n     }\n@@ -430,12 +510,17 @@ class PosixEnv : public Env {\n     int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);\n     if (fd < 0) {\n       result = IOError(fname, errno);\n+    } else if (!locks_.Insert(fname)) {\n+      close(fd);\n+      result = Status::IOError(\"lock \" + fname, \"already held by process\");\n     } else if (LockOrUnlock(fd, true) == -1) {\n       result = IOError(\"lock \" + fname, errno);\n       close(fd);\n+      locks_.Remove(fname);\n     } else {\n       PosixFileLock* my_lock = new PosixFileLock;\n       my_lock->fd_ = fd;\n+      my_lock->name_ = fname;\n       *lock = my_lock;\n     }\n     return result;\n@@ -447,6 +532,7 @@ class PosixEnv : public Env {\n     if (LockOrUnlock(my_lock->fd_, false) == -1) {\n       result = IOError(\"unlock\", errno);\n     }\n+    locks_.Remove(my_lock->name_);\n     close(my_lock->fd_);\n     delete my_lock;\n     return result;\n@@ -523,6 +609,9 @@ class PosixEnv : public Env {\n   struct BGItem { void* arg; void (*function)(void*); };\n   typedef std::deque<BGItem> BGQueue;\n   BGQueue queue_;\n+\n+  PosixLockTable locks_;\n+  MmapLimiter mmap_limit_;\n };\n \n PosixEnv::PosixEnv() : page_size_(getpagesize()),"
      },
      {
        "sha": "1ff5a9efa15efa166b427ef9611ccc58c96a3984",
        "filename": "src/leveldb/util/mutexlock.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/mutexlock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4786302fb99f930afca1e778255b72c6999ca480/src/leveldb/util/mutexlock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/mutexlock.h?ref=4786302fb99f930afca1e778255b72c6999ca480",
        "patch": "@@ -6,6 +6,7 @@\n #define STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_\n \n #include \"port/port.h\"\n+#include \"port/thread_annotations.h\"\n \n namespace leveldb {\n \n@@ -19,12 +20,13 @@ namespace leveldb {\n //     ... some complex code, possibly with multiple return paths ...\n //   }\n \n-class MutexLock {\n+class SCOPED_LOCKABLE MutexLock {\n  public:\n-  explicit MutexLock(port::Mutex *mu) : mu_(mu) {\n+  explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)\n+      : mu_(mu)  {\n     this->mu_->Lock();\n   }\n-  ~MutexLock() { this->mu_->Unlock(); }\n+  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }\n \n  private:\n   port::Mutex *const mu_;"
      },
      {
        "sha": "834c98cc7669c9b03a0649b8ca75a877e89b0580",
        "filename": "src/leveldb/util/win_logger.cc",
        "status": "removed",
        "additions": 0,
        "deletions": 96,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/win_logger.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/win_logger.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/win_logger.cc?ref=c429f2b062140843f42b78d70278279c6be74441",
        "patch": "@@ -1,96 +0,0 @@\n-// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file. See the AUTHORS file for names of contributors.\n-\n-#include \"util/win_logger.h\"\n-\n-#include <windows.h>\n-\n-namespace leveldb {\n-\n-void WinLogger::Logv(const char* format, va_list ap) {\n-  const uint64_t thread_id = static_cast<uint64_t>(::GetCurrentThreadId());\n-\n-  // We try twice: the first time with a fixed-size stack allocated buffer,\n-  // and the second time with a much larger dynamically allocated buffer.\n-  char buffer[500];\n-\n-  for (int iter = 0; iter < 2; iter++) {\n-    char* base;\n-    int bufsize;\n-    if (iter == 0) {\n-      bufsize = sizeof(buffer);\n-      base = buffer;\n-    } else {\n-      bufsize = 30000;\n-      base = new char[bufsize];\n-    }\n-\n-    char* p = base;\n-    char* limit = base + bufsize;\n-\n-    SYSTEMTIME st;\n-\n-    // GetSystemTime returns UTC time, we want local time!\n-    ::GetLocalTime(&st);\n-\n-#ifdef _MSC_VER\n-    p += _snprintf_s(p, limit - p, _TRUNCATE,\n-      \"%04d/%02d/%02d-%02d:%02d:%02d.%03d %llx \",\n-      st.wYear,\n-      st.wMonth,\n-      st.wDay,\n-      st.wHour,\n-      st.wMinute,\n-      st.wSecond,\n-      st.wMilliseconds,\n-      static_cast<long long unsigned int>(thread_id));\n-#else\n-#ifdef __MINGW32__\n-    p += snprintf(p, limit - p,\n-      \"%04d/%02d/%02d-%02d:%02d:%02d.%03d %llx \",\n-      st.wYear,\n-      st.wMonth,\n-      st.wDay,\n-      st.wHour,\n-      st.wMinute,\n-      st.wSecond,\n-      st.wMilliseconds,\n-      static_cast<long long unsigned int>(thread_id));\n-#else\n-#error Unable to detect Windows compiler (neither _MSC_VER nor __MINGW32__ are set)\n-#endif\n-#endif\n-\n-    // Print the message\n-    if (p < limit) {\n-      va_list backup_ap = ap;\n-      p += vsnprintf(p, limit - p, format, backup_ap);\n-      va_end(backup_ap);\n-    }\n-\n-    // Truncate to available space if necessary\n-    if (p >= limit) {\n-      if (iter == 0) {\n-        continue; // Try again with larger buffer\n-      } else {\n-        p = limit - 1;\n-      }\n-    }\n-\n-    // Add newline if necessary\n-    if (p == base || p[-1] != '\\n') {\n-      *p++ = '\\n';\n-    }\n-\n-    assert(p <= limit);\n-    fwrite(base, 1, p - base, file_);\n-    fflush(file_);\n-    if (base != buffer) {\n-      delete[] base;\n-    }\n-    break;\n-  }\n-}\n-\n-}\n\\ No newline at end of file"
      },
      {
        "sha": "b155d5c3190c44594bde894ca7c02ea4c81cf7fc",
        "filename": "src/leveldb/util/win_logger.h",
        "status": "removed",
        "additions": 0,
        "deletions": 28,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/win_logger.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c429f2b062140843f42b78d70278279c6be74441/src/leveldb/util/win_logger.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/win_logger.h?ref=c429f2b062140843f42b78d70278279c6be74441",
        "patch": "@@ -1,28 +0,0 @@\n-// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file. See the AUTHORS file for names of contributors.\n-\n-// Logger implementation for Windows\n-\n-#ifndef STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_\n-#define STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_\n-\n-#include <stdio.h>\n-#include \"leveldb/env.h\"\n-\n-namespace leveldb {\n-\n-class WinLogger : public Logger {\n- private:\n-  FILE* file_;\n- public:\n-  explicit WinLogger(FILE* f) : file_(f) { assert(file_); }\n-  virtual ~WinLogger() {\n-    fclose(file_);\n-  }\n-  virtual void Logv(const char* format, va_list ap);\n-\n-};\n-\n-}\n-#endif  // STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_"
      }
    ]
  },
  {
    "sha": "00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGFiZmNjYzVkNzI2YjY0YzY5YmZiNWUzNjA3ZTJiMThkMTRkMTRl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-12T01:17:55Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:41:44Z"
      },
      "message": "Remove Snappy support",
      "tree": {
        "sha": "8c15681e097ac5f9d255b91175b4e0cec25c5dd0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c15681e097ac5f9d255b91175b4e0cec25c5dd0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00abfccc5d726b64c69bfb5e3607e2b18d14d14e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4786302fb99f930afca1e778255b72c6999ca480",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4786302fb99f930afca1e778255b72c6999ca480",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4786302fb99f930afca1e778255b72c6999ca480"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 0,
      "deletions": 11
    },
    "files": [
      {
        "sha": "5307c9a4fcb96d79c827dca8de38b3ec34686e04",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00abfccc5d726b64c69bfb5e3607e2b18d14d14e/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00abfccc5d726b64c69bfb5e3607e2b18d14d14e/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
        "patch": "@@ -166,17 +166,6 @@ EOF\n         COMMON_FLAGS=\"$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX\"\n     fi\n \n-    # Test whether Snappy library is installed\n-    # http://code.google.com/p/snappy/\n-    $CXX $CXXFLAGS -x c++ - -o /dev/null 2>/dev/null  <<EOF\n-      #include <snappy.h>\n-      int main() {}\n-EOF\n-    if [ \"$?\" = 0 ]; then\n-        COMMON_FLAGS=\"$COMMON_FLAGS -DSNAPPY\"\n-        PLATFORM_LIBS=\"$PLATFORM_LIBS -lsnappy\"\n-    fi\n-\n     # Test whether tcmalloc is available\n     $CXX $CXXFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF\n       int main() {}"
      }
    ]
  },
  {
    "sha": "21f2ae7563c8892cbb634ece6911de38dc7dff7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMWYyYWU3NTYzYzg4OTJjYmI2MzRlY2U2OTExZGUzOGRjN2RmZjdj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-13T01:21:49Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:41:44Z"
      },
      "message": "Native Windows LevelDB port\n\nImport native Windows LevelDB port by Hiram Chirino.\n\nExtracted from from https://github.com/chirino/leveldb.git using\ngit diff dd0d562..aea83b7",
      "tree": {
        "sha": "0cff518435e4494e2db9cdcbfca844ff850f181b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0cff518435e4494e2db9cdcbfca844ff850f181b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/21f2ae7563c8892cbb634ece6911de38dc7dff7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21f2ae7563c8892cbb634ece6911de38dc7dff7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/21f2ae7563c8892cbb634ece6911de38dc7dff7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21f2ae7563c8892cbb634ece6911de38dc7dff7c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00abfccc5d726b64c69bfb5e3607e2b18d14d14e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00abfccc5d726b64c69bfb5e3607e2b18d14d14e"
      }
    ],
    "stats": {
      "total": 1372,
      "additions": 1371,
      "deletions": 1
    },
    "files": [
      {
        "sha": "55ba072e0e9de524f2a1f977378de28b78f75e5f",
        "filename": "src/leveldb/.gitignore",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/.gitignore?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -6,3 +6,7 @@ build_config.mk\n *.so.*\n *_test\n db_bench\n+Release\n+Debug\n+Benchmark\n+vs2010.*"
      },
      {
        "sha": "5b76c2448fe1e475b97d12235bdff53b857557cf",
        "filename": "src/leveldb/WINDOWS.md",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/WINDOWS.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/WINDOWS.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/WINDOWS.md?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -0,0 +1,39 @@\n+# Building LevelDB On Windows\n+\n+## Prereqs \n+\n+Install the [Windows Software Development Kit version 7.1](http://www.microsoft.com/downloads/dlx/en-us/listdetailsview.aspx?FamilyID=6b6c21d2-2006-4afa-9702-529fa782d63b).\n+\n+Download and extract the [Snappy source distribution](http://snappy.googlecode.com/files/snappy-1.0.5.tar.gz)\n+\n+1. Open the \"Windows SDK 7.1 Command Prompt\" :\n+   Start Menu -> \"Microsoft Windows SDK v7.1\" > \"Windows SDK 7.1 Command Prompt\"\n+2. Change the directory to the leveldb project\n+\n+## Building the Static lib \n+\n+* 32 bit Version \n+\n+        setenv /x86\n+        msbuild.exe /p:Configuration=Release /p:Platform=Win32 /p:Snappy=..\\snappy-1.0.5\n+\n+* 64 bit Version \n+\n+        setenv /x64\n+        msbuild.exe /p:Configuration=Release /p:Platform=x64 /p:Snappy=..\\snappy-1.0.5\n+\n+\n+## Building and Running the Benchmark app\n+\n+* 32 bit Version \n+\n+\t    setenv /x86\n+\t    msbuild.exe /p:Configuration=Benchmark /p:Platform=Win32 /p:Snappy=..\\snappy-1.0.5\n+\t\tBenchmark\\leveldb.exe\n+\n+* 64 bit Version \n+\n+\t    setenv /x64\n+\t    msbuild.exe /p:Configuration=Benchmark /p:Platform=x64 /p:Snappy=..\\snappy-1.0.5\n+\t    x64\\Benchmark\\leveldb.exe\n+"
      },
      {
        "sha": "4baafa8e22fd290cfd73ad4daf0b5245e0d109c1",
        "filename": "src/leveldb/port/port.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port.h?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -14,6 +14,8 @@\n #  include \"port/port_posix.h\"\n #elif defined(LEVELDB_PLATFORM_CHROMIUM)\n #  include \"port/port_chromium.h\"\n+#elif defined(LEVELDB_PLATFORM_WINDOWS)\n+#  include \"port/port_win.h\"\n #endif\n \n #endif  // STORAGE_LEVELDB_PORT_PORT_H_"
      },
      {
        "sha": "7cf953793761b4937c5edcd6a33553360e7e4fc7",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "added",
        "additions": 154,
        "deletions": 0,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -0,0 +1,154 @@\n+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// See port_example.h for documentation for the following types/functions.\n+\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//  * Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+//  * Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//  * Neither the name of the University of California, Berkeley nor the\n+//    names of its contributors may be used to endorse or promote products\n+//    derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//\n+\n+#include \"port/port_win.h\"\n+\n+#include <windows.h>\n+#include <cassert>\n+\n+namespace leveldb {\n+namespace port {\n+\n+Mutex::Mutex() :\n+    cs_(nullptr) {\n+  assert(!cs_);\n+  cs_ = static_cast<void *>(new CRITICAL_SECTION());\n+  ::InitializeCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n+  assert(cs_);\n+}\n+\n+Mutex::~Mutex() {\n+  assert(cs_);\n+  ::DeleteCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n+  delete static_cast<CRITICAL_SECTION *>(cs_);\n+  cs_ = nullptr;\n+  assert(!cs_);\n+}\n+\n+void Mutex::Lock() {\n+  assert(cs_);\n+  ::EnterCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n+}\n+\n+void Mutex::Unlock() {\n+  assert(cs_);\n+  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n+}\n+\n+void Mutex::AssertHeld() {\n+  assert(cs_);\n+  assert(1);\n+}\n+\n+CondVar::CondVar(Mutex* mu) :\n+    waiting_(0), \n+    mu_(mu), \n+    sem1_(::CreateSemaphore(NULL, 0, 10000, NULL)), \n+    sem2_(::CreateSemaphore(NULL, 0, 10000, NULL)) {\n+  assert(mu_);\n+}\n+\n+CondVar::~CondVar() {\n+  ::CloseHandle(sem1_);\n+  ::CloseHandle(sem2_);\n+}\n+\n+void CondVar::Wait() {\n+  mu_->AssertHeld();\n+\n+  wait_mtx_.Lock();\n+  ++waiting_;\n+  wait_mtx_.Unlock();\n+\n+  mu_->Unlock();\n+\n+  // initiate handshake\n+  ::WaitForSingleObject(sem1_, INFINITE);\n+  ::ReleaseSemaphore(sem2_, 1, NULL);\n+  mu_->Lock();\n+}\n+\n+void CondVar::Signal() {\n+  wait_mtx_.Lock();\n+  if (waiting_ > 0) {\n+    --waiting_;\n+\n+    // finalize handshake\n+    ::ReleaseSemaphore(sem1_, 1, NULL);\n+    ::WaitForSingleObject(sem2_, INFINITE);\n+  }\n+  wait_mtx_.Unlock();\n+}\n+\n+void CondVar::SignalAll() {\n+  wait_mtx_.Lock();\n+  for(long i = 0; i < waiting_; ++i) {\n+    ::ReleaseSemaphore(sem1_, 1, NULL);\n+    while(waiting_ > 0) {\n+      --waiting_;\n+      ::WaitForSingleObject(sem2_, INFINITE);\n+    }\n+  }\n+  wait_mtx_.Unlock();\n+}\n+\n+AtomicPointer::AtomicPointer(void* v) {\n+  Release_Store(v);\n+}\n+\n+BOOL CALLBACK InitHandleFunction (PINIT_ONCE InitOnce, PVOID func, PVOID *lpContext) {\n+  ((void (*)())func)();\n+  return true;\n+}\n+\n+void InitOnce(OnceType* once, void (*initializer)()) {\n+  InitOnceExecuteOnce((PINIT_ONCE)once, InitHandleFunction, initializer, NULL);\n+}\n+\n+void* AtomicPointer::Acquire_Load() const {\n+  void * p = nullptr;\n+  InterlockedExchangePointer(&p, rep_);\n+  return p;\n+}\n+\n+void AtomicPointer::Release_Store(void* v) {\n+  InterlockedExchangePointer(&rep_, v);\n+}\n+\n+void* AtomicPointer::NoBarrier_Load() const {\n+  return rep_;\n+}\n+\n+void AtomicPointer::NoBarrier_Store(void* v) {\n+  rep_ = v;\n+}\n+\n+}\n+}"
      },
      {
        "sha": "c9e1cdad60d053098410aa7f30767728c0132121",
        "filename": "src/leveldb/port/port_win.h",
        "status": "added",
        "additions": 154,
        "deletions": 0,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -0,0 +1,154 @@\n+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// See port_example.h for documentation for the following types/functions.\n+\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//  * Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+//  * Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//  * Neither the name of the University of California, Berkeley nor the\n+//    names of its contributors may be used to endorse or promote products\n+//    derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//\n+\n+#ifndef STORAGE_LEVELDB_PORT_PORT_WIN_H_\n+#define STORAGE_LEVELDB_PORT_PORT_WIN_H_\n+\n+#define snprintf _snprintf\n+#define close _close\n+#define fread_unlocked _fread_nolock\n+\n+#include <string>\n+#include <stdint.h>\n+#ifdef SNAPPY\n+#include <snappy.h>\n+#endif\n+\n+namespace leveldb {\n+namespace port {\n+\n+// Windows is little endian (for now :p)\n+static const bool kLittleEndian = true;\n+\n+class CondVar;\n+\n+class Mutex {\n+ public:\n+  Mutex();\n+  ~Mutex();\n+\n+  void Lock();\n+  void Unlock();\n+  void AssertHeld();\n+\n+ private:\n+  friend class CondVar;\n+  // critical sections are more efficient than mutexes\n+  // but they are not recursive and can only be used to synchronize threads within the same process\n+  // we use opaque void * to avoid including windows.h in port_win.h\n+  void * cs_;\n+\n+  // No copying\n+  Mutex(const Mutex&);\n+  void operator=(const Mutex&);\n+};\n+\n+// the Win32 API offers a dependable condition variable mechanism, but only starting with\n+// Windows 2008 and Vista\n+// no matter what we will implement our own condition variable with a semaphore\n+// implementation as described in a paper written by Andrew D. Birrell in 2003\n+class CondVar {\n+ public:\n+  explicit CondVar(Mutex* mu);\n+  ~CondVar();\n+  void Wait();\n+  void Signal();\n+  void SignalAll();\n+ private:\n+  Mutex* mu_;\n+  \n+  Mutex wait_mtx_;\n+  long waiting_;\n+  \n+  void * sem1_;\n+  void * sem2_;\n+  \n+  \n+};\n+\n+typedef void* OnceType;\n+#define LEVELDB_ONCE_INIT 0\n+extern void InitOnce(port::OnceType*, void (*initializer)());\n+\n+// Storage for a lock-free pointer\n+class AtomicPointer {\n+ private:\n+  void * rep_;\n+ public:\n+  AtomicPointer() : rep_(nullptr) { }\n+  explicit AtomicPointer(void* v); \n+  void* Acquire_Load() const;\n+\n+  void Release_Store(void* v);\n+\n+  void* NoBarrier_Load() const;\n+\n+  void NoBarrier_Store(void* v);\n+};\n+\n+inline bool Snappy_Compress(const char* input, size_t length,\n+                            ::std::string* output) {\n+#ifdef SNAPPY\n+  output->resize(snappy::MaxCompressedLength(length));\n+  size_t outlen;\n+  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n+  output->resize(outlen);\n+  return true;\n+#endif\n+\n+  return false;\n+}\n+\n+inline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n+                                         size_t* result) {\n+#ifdef SNAPPY\n+  return snappy::GetUncompressedLength(input, length, result);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool Snappy_Uncompress(const char* input, size_t length,\n+                              char* output) {\n+#ifdef SNAPPY\n+  return snappy::RawUncompress(input, length, output);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n+  return false;\n+}\n+\n+}\n+}\n+\n+#endif  // STORAGE_LEVELDB_PORT_PORT_WIN_H_"
      },
      {
        "sha": "384331aec5143b7f3048c76c6c763b266afe6a0d",
        "filename": "src/leveldb/util/env_win.cc",
        "status": "added",
        "additions": 1017,
        "deletions": 0,
        "changes": 1017,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_win.cc?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -0,0 +1,1017 @@\n+// This file contains source that originates from:\n+// http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n+// http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n+// Those files dont' have any explict license headers but the \n+// project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n+// as the license.\n+#if defined(LEVELDB_PLATFORM_WINDOWS)\n+#include <map>\n+\n+\n+#include \"leveldb/env.h\"\n+\n+#include \"port/port.h\"\n+#include \"leveldb/slice.h\"\n+#include \"util/logging.h\"\n+\n+#include <shlwapi.h>\n+#include <process.h>\n+#include <cstring>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <io.h>\n+#include <dbghelp.h>\n+#include <algorithm>\n+#pragma comment(lib,\"DbgHelp.lib\")\n+\n+#ifdef max\n+#undef max\n+#endif\n+\n+#ifndef va_copy\n+#define va_copy(d,s) ((d) = (s))\n+#endif\n+\n+#if defined DeleteFile\n+#undef DeleteFile\n+#endif\n+\n+//Declarations\n+namespace leveldb\n+{\n+\n+namespace Win32\n+{\n+\n+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n+  TypeName(const TypeName&);               \\\n+  void operator=(const TypeName&)\n+\n+std::string GetCurrentDir();\n+std::wstring GetCurrentDirW();\n+\n+static const std::string CurrentDir = GetCurrentDir();\n+static const std::wstring CurrentDirW = GetCurrentDirW();\n+\n+std::string& ModifyPath(std::string& path);\n+std::wstring& ModifyPath(std::wstring& path);\n+\n+std::string GetLastErrSz();\n+std::wstring GetLastErrSzW();\n+\n+size_t GetPageSize();\n+\n+typedef void (*ScheduleProc)(void*) ;\n+\n+struct WorkItemWrapper\n+{\n+    WorkItemWrapper(ScheduleProc proc_,void* content_);\n+    ScheduleProc proc;\n+    void* pContent;\n+};\n+\n+DWORD WINAPI WorkItemWrapperProc(LPVOID pContent);\n+\n+class Win32SequentialFile : public SequentialFile\n+{\n+public:\n+    friend class Win32Env;\n+    virtual ~Win32SequentialFile();\n+    virtual Status Read(size_t n, Slice* result, char* scratch);\n+    virtual Status Skip(uint64_t n);\n+    BOOL isEnable();\n+private:\n+    BOOL _Init();\n+    void _CleanUp();\n+    Win32SequentialFile(const std::string& fname);\n+    std::string _filename;\n+    ::HANDLE _hFile;\n+    DISALLOW_COPY_AND_ASSIGN(Win32SequentialFile);\n+};\n+\n+class Win32RandomAccessFile : public RandomAccessFile\n+{\n+public:\n+    friend class Win32Env;\n+    virtual ~Win32RandomAccessFile();\n+    virtual Status Read(uint64_t offset, size_t n, Slice* result,char* scratch) const;\n+    BOOL isEnable();\n+private:\n+    BOOL _Init(LPCWSTR path);\n+    void _CleanUp();\n+    Win32RandomAccessFile(const std::string& fname);\n+    HANDLE _hFile;\n+    const std::string _filename;\n+    DISALLOW_COPY_AND_ASSIGN(Win32RandomAccessFile);\n+};\n+\n+class Win32MapFile : public WritableFile\n+{\n+public:\n+    Win32MapFile(const std::string& fname);\n+\n+    ~Win32MapFile();\n+    virtual Status Append(const Slice& data);\n+    virtual Status Close();\n+    virtual Status Flush();\n+    virtual Status Sync();\n+    BOOL isEnable();\n+private:\n+    std::string _filename;\n+    HANDLE _hFile;\n+    size_t _page_size;\n+    size_t _map_size;       // How much extra memory to map at a time\n+    char* _base;            // The mapped region\n+    HANDLE _base_handle;\t\n+    char* _limit;           // Limit of the mapped region\n+    char* _dst;             // Where to write next  (in range [base_,limit_])\n+    char* _last_sync;       // Where have we synced up to\n+    uint64_t _file_offset;  // Offset of base_ in file\n+    //LARGE_INTEGER file_offset_;\n+    // Have we done an munmap of unsynced data?\n+    bool _pending_sync;\n+\n+    // Roundup x to a multiple of y\n+    static size_t _Roundup(size_t x, size_t y);\n+    size_t _TruncateToPageBoundary(size_t s);\n+    bool _UnmapCurrentRegion();\n+    bool _MapNewRegion();\n+    DISALLOW_COPY_AND_ASSIGN(Win32MapFile);\n+    BOOL _Init(LPCWSTR Path);\n+};\n+\n+class Win32FileLock : public FileLock\n+{\n+public:\n+    friend class Win32Env;\n+    virtual ~Win32FileLock();\n+    BOOL isEnable();\n+private:\n+    BOOL _Init(LPCWSTR path);\n+    void _CleanUp();\n+    Win32FileLock(const std::string& fname);\n+    HANDLE _hFile;\n+    std::string _filename;\n+    DISALLOW_COPY_AND_ASSIGN(Win32FileLock);\n+};\n+\n+class Win32Logger : public Logger\n+{\n+public: \n+    friend class Win32Env;\n+    virtual ~Win32Logger();\n+    virtual void Logv(const char* format, va_list ap);\n+private:\n+    explicit Win32Logger(WritableFile* pFile);\n+    WritableFile* _pFileProxy;\n+    DISALLOW_COPY_AND_ASSIGN(Win32Logger);\n+};\n+\n+class Win32Env : public Env\n+{\n+public:\n+    Win32Env();\n+    virtual ~Win32Env();\n+    virtual Status NewSequentialFile(const std::string& fname,\n+        SequentialFile** result);\n+\n+    virtual Status NewRandomAccessFile(const std::string& fname,\n+        RandomAccessFile** result);\n+    virtual Status NewWritableFile(const std::string& fname,\n+        WritableFile** result);\n+\n+    virtual bool FileExists(const std::string& fname);\n+\n+    virtual Status GetChildren(const std::string& dir,\n+        std::vector<std::string>* result);\n+\n+    virtual Status DeleteFile(const std::string& fname);\n+\n+    virtual Status CreateDir(const std::string& dirname);\n+\n+    virtual Status DeleteDir(const std::string& dirname);\n+\n+    virtual Status GetFileSize(const std::string& fname, uint64_t* file_size);\n+\n+    virtual Status RenameFile(const std::string& src,\n+        const std::string& target);\n+\n+    virtual Status LockFile(const std::string& fname, FileLock** lock);\n+\n+    virtual Status UnlockFile(FileLock* lock);\n+\n+    virtual void Schedule(\n+        void (*function)(void* arg),\n+        void* arg);\n+\n+    virtual void StartThread(void (*function)(void* arg), void* arg);\n+\n+    virtual Status GetTestDirectory(std::string* path);\n+\n+    //virtual void Logv(WritableFile* log, const char* format, va_list ap);\n+\n+    virtual Status NewLogger(const std::string& fname, Logger** result);\n+\n+    virtual uint64_t NowMicros();\n+\n+    virtual void SleepForMicroseconds(int micros);\n+};\n+\n+void ToWidePath(const std::string& value, std::wstring& target) {\n+\twchar_t buffer[MAX_PATH];\n+\tMultiByteToWideChar(CP_ACP, 0, value.c_str(), -1, buffer, MAX_PATH);\n+\ttarget = buffer;\n+}\n+\n+void ToNarrowPath(const std::wstring& value, std::string& target) {\n+\tchar buffer[MAX_PATH];\n+\tWideCharToMultiByte(CP_ACP, 0, value.c_str(), -1, buffer, MAX_PATH, NULL, NULL);\n+\ttarget = buffer;\n+}\n+\n+std::string GetCurrentDir()\n+{\n+    CHAR path[MAX_PATH];\n+    ::GetModuleFileNameA(::GetModuleHandleA(NULL),path,MAX_PATH);\n+    *strrchr(path,'\\\\') = 0;\n+    return std::string(path);\n+}\n+\n+std::wstring GetCurrentDirW()\n+{\n+    WCHAR path[MAX_PATH];\n+    ::GetModuleFileNameW(::GetModuleHandleW(NULL),path,MAX_PATH);\n+    *wcsrchr(path,L'\\\\') = 0;\n+    return std::wstring(path);\n+}\n+\n+std::string& ModifyPath(std::string& path)\n+{\n+    if(path[0] == '/' || path[0] == '\\\\'){\n+        path = CurrentDir + path;\n+    }\n+    std::replace(path.begin(),path.end(),'/','\\\\');\n+\n+    return path;\n+}\n+\n+std::wstring& ModifyPath(std::wstring& path)\n+{\n+    if(path[0] == L'/' || path[0] == L'\\\\'){\n+        path = CurrentDirW + path;\n+    }\n+    std::replace(path.begin(),path.end(),L'/',L'\\\\');\n+    return path;\n+}\n+\n+std::string GetLastErrSz()\n+{\n+    LPWSTR lpMsgBuf;\n+    FormatMessageW( \n+        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n+        FORMAT_MESSAGE_FROM_SYSTEM | \n+        FORMAT_MESSAGE_IGNORE_INSERTS,\n+        NULL,\n+        GetLastError(),\n+        0, // Default language\n+        (LPWSTR) &lpMsgBuf,\n+        0,\n+        NULL \n+        );\n+    std::string Err;\n+\tToNarrowPath(lpMsgBuf, Err); \n+    LocalFree( lpMsgBuf );\n+    return Err;\n+}\n+\n+std::wstring GetLastErrSzW()\n+{\n+    LPVOID lpMsgBuf;\n+    FormatMessageW( \n+        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n+        FORMAT_MESSAGE_FROM_SYSTEM | \n+        FORMAT_MESSAGE_IGNORE_INSERTS,\n+        NULL,\n+        GetLastError(),\n+        0, // Default language\n+        (LPWSTR) &lpMsgBuf,\n+        0,\n+        NULL \n+        );\n+    std::wstring Err = (LPCWSTR)lpMsgBuf;\n+    LocalFree(lpMsgBuf);\n+    return Err;\n+}\n+\n+WorkItemWrapper::WorkItemWrapper( ScheduleProc proc_,void* content_ ) :\n+    proc(proc_),pContent(content_)\n+{\n+\n+}\n+\n+DWORD WINAPI WorkItemWrapperProc(LPVOID pContent)\n+{\n+    WorkItemWrapper* item = static_cast<WorkItemWrapper*>(pContent);\n+    ScheduleProc TempProc = item->proc;\n+    void* arg = item->pContent;\n+    delete item;\n+    TempProc(arg);\n+    return 0;\n+}\n+\n+size_t GetPageSize()\n+{\n+    SYSTEM_INFO si;\n+    GetSystemInfo(&si);\n+    return std::max(si.dwPageSize,si.dwAllocationGranularity);\n+}\n+\n+const size_t g_PageSize = GetPageSize();\n+\n+\n+Win32SequentialFile::Win32SequentialFile( const std::string& fname ) :\n+    _filename(fname),_hFile(NULL)\n+{\n+    _Init();\n+}\n+\n+Win32SequentialFile::~Win32SequentialFile()\n+{\n+    _CleanUp();\n+}\n+\n+Status Win32SequentialFile::Read( size_t n, Slice* result, char* scratch )\n+{\n+    Status sRet;\n+    DWORD hasRead = 0;\n+    if(_hFile && ReadFile(_hFile,scratch,n,&hasRead,NULL) ){\n+        *result = Slice(scratch,hasRead);\n+    } else {\n+        sRet = Status::IOError(_filename, Win32::GetLastErrSz() );\n+    }\n+    return sRet;\n+}\n+\n+Status Win32SequentialFile::Skip( uint64_t n )\n+{\n+    Status sRet;\n+    LARGE_INTEGER Move,NowPointer;\n+    Move.QuadPart = n;\n+    if(!SetFilePointerEx(_hFile,Move,&NowPointer,FILE_CURRENT)){\n+        sRet = Status::IOError(_filename,Win32::GetLastErrSz());\n+    }\n+    return sRet;\n+}\n+\n+BOOL Win32SequentialFile::isEnable()\n+{\n+    return _hFile ? TRUE : FALSE;\n+}\n+\n+BOOL Win32SequentialFile::_Init()\n+{\n+\tstd::wstring path;\n+\tToWidePath(_filename, path);\n+\t_hFile = CreateFileW(path.c_str(),\n+                         GENERIC_READ,\n+                         FILE_SHARE_READ,\n+                         NULL,\n+                         OPEN_EXISTING,\n+                         FILE_ATTRIBUTE_NORMAL,\n+                         NULL);\n+    return _hFile ? TRUE : FALSE;\n+}\n+\n+void Win32SequentialFile::_CleanUp()\n+{\n+    if(_hFile){\n+        CloseHandle(_hFile);\n+        _hFile = NULL;\n+    }\n+}\n+\n+Win32RandomAccessFile::Win32RandomAccessFile( const std::string& fname ) :\n+    _filename(fname),_hFile(NULL)\n+{\n+\tstd::wstring path;\n+\tToWidePath(fname, path);\n+    _Init( path.c_str() );\n+}\n+\n+Win32RandomAccessFile::~Win32RandomAccessFile()\n+{\n+    _CleanUp();\n+}\n+\n+Status Win32RandomAccessFile::Read(uint64_t offset,size_t n,Slice* result,char* scratch) const\n+{\n+    Status sRet;\n+    OVERLAPPED ol = {0};\n+    ZeroMemory(&ol,sizeof(ol));\n+    ol.Offset = (DWORD)offset;\n+    ol.OffsetHigh = (DWORD)(offset >> 32);\n+    DWORD hasRead = 0;\n+    if(!ReadFile(_hFile,scratch,n,&hasRead,&ol))\n+        sRet = Status::IOError(_filename,Win32::GetLastErrSz());\n+    else\n+        *result = Slice(scratch,hasRead);\n+    return sRet;\n+}\n+\n+BOOL Win32RandomAccessFile::_Init( LPCWSTR path )\n+{\n+    BOOL bRet = FALSE;\n+    if(!_hFile)\n+        _hFile = ::CreateFileW(path,GENERIC_READ,0,NULL,OPEN_EXISTING,\n+        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);\n+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE )\n+        _hFile = NULL;\n+    else\n+        bRet = TRUE;\n+    return bRet;\n+}\n+\n+BOOL Win32RandomAccessFile::isEnable()\n+{\n+    return _hFile ? TRUE : FALSE;\n+}\n+\n+void Win32RandomAccessFile::_CleanUp()\n+{\n+    if(_hFile){\n+        ::CloseHandle(_hFile);\n+        _hFile = NULL;\n+    }\n+}\n+\n+size_t Win32MapFile::_Roundup( size_t x, size_t y )\n+{\n+    return ((x + y - 1) / y) * y;\n+}\n+\n+size_t Win32MapFile::_TruncateToPageBoundary( size_t s )\n+{\n+    s -= (s & (_page_size - 1));\n+    assert((s % _page_size) == 0);\n+    return s;\n+}\n+\n+bool Win32MapFile::_UnmapCurrentRegion()\n+{\n+    bool result = true;\n+    if (_base != NULL) {\n+        if (_last_sync < _limit) {\n+            // Defer syncing this data until next Sync() call, if any\n+            _pending_sync = true;\n+        }\n+        UnmapViewOfFile(_base);\n+        CloseHandle(_base_handle);\n+        _file_offset += _limit - _base;\n+        _base = NULL;\n+        _base_handle = NULL;\n+        _limit = NULL;\n+        _last_sync = NULL;\n+        _dst = NULL;\n+        // Increase the amount we map the next time, but capped at 1MB\n+        if (_map_size < (1<<20)) {\n+            _map_size *= 2;\n+        }\n+    }\n+    return result;\n+}\n+\n+bool Win32MapFile::_MapNewRegion()\n+{\n+    assert(_base == NULL);\n+    //LONG newSizeHigh = (LONG)((file_offset_ + map_size_) >> 32);\n+    //LONG newSizeLow = (LONG)((file_offset_ + map_size_) & 0xFFFFFFFF);\n+    DWORD off_hi = (DWORD)(_file_offset >> 32);\n+    DWORD off_lo = (DWORD)(_file_offset & 0xFFFFFFFF);\n+    LARGE_INTEGER newSize;\n+    newSize.QuadPart = _file_offset + _map_size;\n+    SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN);\n+    SetEndOfFile(_hFile);\n+\n+    _base_handle = CreateFileMappingA(\n+        _hFile,\n+        NULL,\n+        PAGE_READWRITE,\n+        0,\n+        0,\n+        0);\n+    if (_base_handle != NULL) {\n+        _base = (char*) MapViewOfFile(_base_handle,\n+            FILE_MAP_ALL_ACCESS,\n+            off_hi,\n+            off_lo,\n+            _map_size);\n+        if (_base != NULL) {\n+            _limit = _base + _map_size;\n+            _dst = _base;\n+            _last_sync = _base;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+Win32MapFile::Win32MapFile( const std::string& fname) :\n+    _filename(fname),\n+    _hFile(NULL),\n+    _page_size(Win32::g_PageSize),\n+    _map_size(_Roundup(65536, Win32::g_PageSize)),\n+    _base(NULL),\n+    _base_handle(NULL),\n+    _limit(NULL),\n+    _dst(NULL),\n+    _last_sync(NULL),\n+    _file_offset(0),\n+    _pending_sync(false)\n+{\n+\tstd::wstring path;\n+\tToWidePath(fname, path);\n+    _Init(path.c_str());\n+    assert((Win32::g_PageSize & (Win32::g_PageSize - 1)) == 0);\n+}\n+\n+Status Win32MapFile::Append( const Slice& data )\n+{\n+    const char* src = data.data();\n+    size_t left = data.size();\n+    Status s;\n+    while (left > 0) {\n+        assert(_base <= _dst);\n+        assert(_dst <= _limit);\n+        size_t avail = _limit - _dst;\n+        if (avail == 0) {\n+            if (!_UnmapCurrentRegion() ||\n+                !_MapNewRegion()) {\n+                    return Status::IOError(\"WinMmapFile.Append::UnmapCurrentRegion or MapNewRegion: \", Win32::GetLastErrSz());\n+            }\n+        }\n+        size_t n = (left <= avail) ? left : avail;\n+        memcpy(_dst, src, n);\n+        _dst += n;\n+        src += n;\n+        left -= n;\n+    }\n+    return s;\n+}\n+\n+Status Win32MapFile::Close()\n+{\n+    Status s;\n+    size_t unused = _limit - _dst;\n+    if (!_UnmapCurrentRegion()) {\n+        s = Status::IOError(\"WinMmapFile.Close::UnmapCurrentRegion: \",Win32::GetLastErrSz());\n+    } else if (unused > 0) {\n+        // Trim the extra space at the end of the file\n+        LARGE_INTEGER newSize;\n+        newSize.QuadPart = _file_offset - unused;\n+        if (!SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN)) {\n+            s = Status::IOError(\"WinMmapFile.Close::SetFilePointer: \",Win32::GetLastErrSz());\n+        } else \n+            SetEndOfFile(_hFile);\n+    }\n+    if (!CloseHandle(_hFile)) {\n+        if (s.ok()) {\n+            s = Status::IOError(\"WinMmapFile.Close::CloseHandle: \", Win32::GetLastErrSz());\n+        }\n+    }\n+    _hFile = INVALID_HANDLE_VALUE;\n+    _base = NULL;\n+    _base_handle = NULL;\n+    _limit = NULL;\n+\n+    return s;\n+}\n+\n+Status Win32MapFile::Sync()\n+{\n+    Status s;\n+    if (_pending_sync) {\n+        // Some unmapped data was not synced\n+        _pending_sync = false;\n+        if (!FlushFileBuffers(_hFile)) {\n+            s = Status::IOError(\"WinMmapFile.Sync::FlushFileBuffers: \",Win32::GetLastErrSz());\n+        }\n+    }\n+    if (_dst > _last_sync) {\n+        // Find the beginnings of the pages that contain the first and last\n+        // bytes to be synced.\n+        size_t p1 = _TruncateToPageBoundary(_last_sync - _base);\n+        size_t p2 = _TruncateToPageBoundary(_dst - _base - 1);\n+        _last_sync = _dst;\n+        if (!FlushViewOfFile(_base + p1, p2 - p1 + _page_size)) {\n+            s = Status::IOError(\"WinMmapFile.Sync::FlushViewOfFile: \",Win32::GetLastErrSz());\n+        }\n+    }\n+    return s;\n+}\n+\n+Status Win32MapFile::Flush()\n+{\n+    return Status::OK();\n+}\n+\n+Win32MapFile::~Win32MapFile()\n+{\n+    if (_hFile != INVALID_HANDLE_VALUE) { \n+        Win32MapFile::Close();\n+    }\n+}\n+\n+BOOL Win32MapFile::_Init( LPCWSTR Path )\n+{\n+    DWORD Flag = PathFileExistsW(Path) ? OPEN_EXISTING : CREATE_ALWAYS;\n+    _hFile = CreateFileW(Path,\n+                         GENERIC_READ | GENERIC_WRITE,\n+                         FILE_SHARE_READ|FILE_SHARE_DELETE|FILE_SHARE_WRITE,\n+                         NULL,\n+                         Flag,\n+                         FILE_ATTRIBUTE_NORMAL,\n+                         NULL);\n+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE)\n+        return FALSE;\n+    else\n+        return TRUE;\n+}\n+\n+BOOL Win32MapFile::isEnable()\n+{\n+    return _hFile ? TRUE : FALSE;\n+}\n+\n+Win32FileLock::Win32FileLock( const std::string& fname ) :\n+    _hFile(NULL),_filename(fname)\n+{\n+\tstd::wstring path;\n+\tToWidePath(fname, path);\n+\t_Init(path.c_str());\n+}\n+\n+Win32FileLock::~Win32FileLock()\n+{\n+    _CleanUp();\n+}\n+\n+BOOL Win32FileLock::_Init( LPCWSTR path )\n+{\n+    BOOL bRet = FALSE;\n+    if(!_hFile)\n+        _hFile = ::CreateFileW(path,0,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);\n+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE ){\n+        _hFile = NULL;\n+    }\n+    else\n+        bRet = TRUE;\n+    return bRet;\n+}\n+\n+void Win32FileLock::_CleanUp()\n+{\n+    ::CloseHandle(_hFile);\n+    _hFile = NULL;\n+}\n+\n+BOOL Win32FileLock::isEnable()\n+{\n+    return _hFile ? TRUE : FALSE;\n+}\n+\n+Win32Logger::Win32Logger(WritableFile* pFile) : _pFileProxy(pFile)\n+{\n+    assert(_pFileProxy);\n+}\n+\n+Win32Logger::~Win32Logger()\n+{\n+    if(_pFileProxy)\n+        delete _pFileProxy;\n+}\n+\n+void Win32Logger::Logv( const char* format, va_list ap )\n+{\n+    uint64_t thread_id = ::GetCurrentThreadId();\n+\n+    // We try twice: the first time with a fixed-size stack allocated buffer,\n+    // and the second time with a much larger dynamically allocated buffer.\n+    char buffer[500];\n+    for (int iter = 0; iter < 2; iter++) {\n+        char* base;\n+        int bufsize;\n+        if (iter == 0) {\n+            bufsize = sizeof(buffer);\n+            base = buffer;\n+        } else {\n+            bufsize = 30000;\n+            base = new char[bufsize];\n+        }\n+        char* p = base;\n+        char* limit = base + bufsize;\n+\n+        SYSTEMTIME st;\n+        GetLocalTime(&st);\n+        p += snprintf(p, limit - p,\n+            \"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx \",\n+            int(st.wYear),\n+            int(st.wMonth),\n+            int(st.wDay),\n+            int(st.wHour),\n+            int(st.wMinute),\n+            int(st.wMinute),\n+            int(st.wMilliseconds),\n+            static_cast<long long unsigned int>(thread_id));\n+\n+        // Print the message\n+        if (p < limit) {\n+            va_list backup_ap;\n+            va_copy(backup_ap, ap);\n+            p += vsnprintf(p, limit - p, format, backup_ap);\n+            va_end(backup_ap);\n+        }\n+\n+        // Truncate to available space if necessary\n+        if (p >= limit) {\n+            if (iter == 0) {\n+                continue;       // Try again with larger buffer\n+            } else {\n+                p = limit - 1;\n+            }\n+        }\n+\n+        // Add newline if necessary\n+        if (p == base || p[-1] != '\\n') {\n+            *p++ = '\\n';\n+        }\n+\n+        assert(p <= limit);\n+        DWORD hasWritten = 0;\n+        if(_pFileProxy){\n+            _pFileProxy->Append(Slice(base, p - base));\n+            _pFileProxy->Flush();\n+        }\n+        if (base != buffer) {\n+            delete[] base;\n+        }\n+        break;\n+    }\n+}\n+\n+bool Win32Env::FileExists(const std::string& fname)\n+{\n+\tstd::string path = fname;\n+    std::wstring wpath;\n+\tToWidePath(ModifyPath(path), wpath);\n+    return ::PathFileExistsW(wpath.c_str()) ? true : false;\n+}\n+\n+Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n+{\n+    Status sRet;\n+    ::WIN32_FIND_DATAW wfd;\n+    std::string path = dir;\n+    ModifyPath(path);\n+    path += \"\\\\*.*\";\n+\tstd::wstring wpath;\n+\tToWidePath(path, wpath);\n+\n+\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n+    if(hFind && hFind != INVALID_HANDLE_VALUE){\n+        BOOL hasNext = TRUE;\n+        std::string child;\n+        while(hasNext){\n+            ToNarrowPath(wfd.cFileName, child); \n+            if(child != \"..\" && child != \".\")  {\n+                result->push_back(child);\n+            }\n+            hasNext = ::FindNextFileW(hFind,&wfd);\n+        }\n+        ::FindClose(hFind);\n+    }\n+    else\n+        sRet = Status::IOError(dir,\"Could not get children.\");\n+    return sRet;\n+}\n+\n+void Win32Env::SleepForMicroseconds( int micros )\n+{\n+    ::Sleep((micros + 999) /1000);\n+}\n+\n+\n+Status Win32Env::DeleteFile( const std::string& fname )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    std::wstring wpath;\n+\tToWidePath(ModifyPath(path), wpath);\n+\n+    if(!::DeleteFileW(wpath.c_str())) {\n+        sRet = Status::IOError(path, \"Could not delete file.\");\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    std::wstring wpath;\n+\tToWidePath(ModifyPath(path), wpath);\n+\n+    HANDLE file = ::CreateFileW(wpath.c_str(),\n+        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n+    LARGE_INTEGER li;\n+    if(::GetFileSizeEx(file,&li)){\n+        *file_size = (uint64_t)li.QuadPart;\n+    }else\n+        sRet = Status::IOError(path,\"Could not get the file size.\");\n+    CloseHandle(file);\n+    return sRet;\n+}\n+\n+Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n+{\n+    Status sRet;\n+    std::string src_path = src;\n+    std::wstring wsrc_path;\n+\tToWidePath(ModifyPath(src_path), wsrc_path);\n+\tstd::string target_path = target;\n+    std::wstring wtarget_path;\n+\tToWidePath(ModifyPath(target_path), wtarget_path);\n+\n+    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n+        DWORD err = GetLastError();\n+        if(err == 0x000000b7){\n+            if(!::DeleteFileW(wtarget_path.c_str() ) )\n+                sRet = Status::IOError(src, \"Could not rename file.\");\n+\t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n+                                 wtarget_path.c_str() ) )\n+                sRet = Status::IOError(src, \"Could not rename file.\");    \n+        }\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::LockFile( const std::string& fname, FileLock** lock )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    ModifyPath(path);\n+    Win32FileLock* _lock = new Win32FileLock(path);\n+    if(!_lock->isEnable()){\n+        delete _lock;\n+        *lock = NULL;\n+        sRet = Status::IOError(path, \"Could not lock file.\");\n+    }\n+    else\n+        *lock = _lock;\n+    return sRet;\n+}\n+\n+Status Win32Env::UnlockFile( FileLock* lock )\n+{\n+    Status sRet;\n+    delete lock;\n+    return sRet;\n+}\n+\n+void Win32Env::Schedule( void (*function)(void* arg), void* arg )\n+{\n+    QueueUserWorkItem(Win32::WorkItemWrapperProc,\n+                      new Win32::WorkItemWrapper(function,arg),\n+                      WT_EXECUTEDEFAULT);\n+}\n+\n+void Win32Env::StartThread( void (*function)(void* arg), void* arg )\n+{\n+    ::_beginthread(function,0,arg);\n+}\n+\n+Status Win32Env::GetTestDirectory( std::string* path )\n+{\n+    Status sRet;\n+    WCHAR TempPath[MAX_PATH];\n+    ::GetTempPathW(MAX_PATH,TempPath);\n+\tToNarrowPath(TempPath, *path);\n+    path->append(\"leveldb\\\\test\\\\\");\n+    ModifyPath(*path);\n+    return sRet;\n+}\n+\n+uint64_t Win32Env::NowMicros()\n+{\n+#ifndef USE_VISTA_API\n+#define GetTickCount64 GetTickCount\n+#endif\n+    return (uint64_t)(GetTickCount64()*1000);\n+}\n+\n+Status Win32Env::CreateDir( const std::string& dirname )\n+{\n+    Status sRet;\n+    std::string path = dirname;\n+    if(path[path.length() - 1] != '\\\\'){\n+        path += '\\\\';\n+    }\n+    ModifyPath(path);\n+    if(!::MakeSureDirectoryPathExists( path.c_str() ) ){\n+        sRet = Status::IOError(dirname, \"Could not create directory.\");\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::DeleteDir( const std::string& dirname )\n+{\n+    Status sRet;\n+    std::wstring path;\n+\tToWidePath(dirname, path);\n+    ModifyPath(path);\n+    if(!::RemoveDirectoryW( path.c_str() ) ){\n+        sRet = Status::IOError(dirname, \"Could not delete directory.\");\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    ModifyPath(path);\n+    Win32SequentialFile* pFile = new Win32SequentialFile(path);\n+    if(pFile->isEnable()){\n+        *result = pFile;\n+    }else {\n+        delete pFile;\n+        sRet = Status::IOError(path, Win32::GetLastErrSz());\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::NewRandomAccessFile( const std::string& fname, RandomAccessFile** result )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    Win32RandomAccessFile* pFile = new Win32RandomAccessFile(ModifyPath(path));\n+    if(!pFile->isEnable()){\n+        delete pFile;\n+        *result = NULL;\n+        sRet = Status::IOError(path,\"Could not create random access file.\");\n+    }else\n+        *result = pFile;\n+    return sRet;\n+}\n+\n+Status Win32Env::NewLogger( const std::string& fname, Logger** result )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    Win32MapFile* pMapFile = new Win32MapFile(ModifyPath(path));\n+    if(!pMapFile->isEnable()){\n+        delete pMapFile;\n+        *result = NULL;\n+        sRet = Status::IOError(path,\"could not create a logger.\");\n+    }else\n+        *result = new Win32Logger(pMapFile);\n+    return sRet;\n+}\n+\n+Status Win32Env::NewWritableFile( const std::string& fname, WritableFile** result )\n+{\n+    Status sRet;\n+    std::string path = fname;\n+    Win32MapFile* pFile = new Win32MapFile(ModifyPath(path));\n+    if(!pFile->isEnable()){\n+        *result = NULL;\n+        sRet = Status::IOError(fname,Win32::GetLastErrSz());\n+    }else\n+        *result = pFile;\n+    return sRet;\n+}\n+\n+Win32Env::Win32Env()\n+{\n+\n+}\n+\n+Win32Env::~Win32Env()\n+{\n+\n+}\n+\n+\n+}  // Win32 namespace\n+\n+static port::OnceType once = LEVELDB_ONCE_INIT;\n+static Env* default_env;\n+static void InitDefaultEnv() { default_env = new Win32::Win32Env(); }\n+\n+Env* Env::Default() {\n+  port::InitOnce(&once, InitDefaultEnv);\n+  return default_env;\n+}\n+\n+}  // namespace leveldb\n+\n+#endif // defined(LEVELDB_PLATFORM_WINDOWS)"
      },
      {
        "sha": "c063c2b7cb200dffa3c253fe76ee851910cfbe2f",
        "filename": "src/leveldb/util/posix_logger.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/util/posix_logger.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21f2ae7563c8892cbb634ece6911de38dc7dff7c/src/leveldb/util/posix_logger.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/posix_logger.h?ref=21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "patch": "@@ -3,7 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n //\n // Logger implementation that can be shared by all environments\n-// where enough posix functionality is available.\n+// where enough Posix functionality is available.\n \n #ifndef STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_\n #define STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_"
      }
    ]
  },
  {
    "sha": "960797a0de24454ce0c8c15cbb26cb6fc7683e47",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjA3OTdhMGRlMjQ0NTRjZTBjOGMxNWNiYjI2Y2I2ZmM3NjgzZTQ3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-12T01:20:18Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:41:44Z"
      },
      "message": "Pre-Vista leveldb::port::InitOnce implementation",
      "tree": {
        "sha": "ce8c663003e6eaed8cf7385f4523461af275aed5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ce8c663003e6eaed8cf7385f4523461af275aed5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/960797a0de24454ce0c8c15cbb26cb6fc7683e47",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960797a0de24454ce0c8c15cbb26cb6fc7683e47",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/960797a0de24454ce0c8c15cbb26cb6fc7683e47",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960797a0de24454ce0c8c15cbb26cb6fc7683e47/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21f2ae7563c8892cbb634ece6911de38dc7dff7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21f2ae7563c8892cbb634ece6911de38dc7dff7c"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 21,
      "deletions": 8
    },
    "files": [
      {
        "sha": "15dfde1f271f9aaecd4603aa24f9faf069688b76",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/960797a0de24454ce0c8c15cbb26cb6fc7683e47/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/960797a0de24454ce0c8c15cbb26cb6fc7683e47/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=960797a0de24454ce0c8c15cbb26cb6fc7683e47",
        "patch": "@@ -123,13 +123,8 @@ AtomicPointer::AtomicPointer(void* v) {\n   Release_Store(v);\n }\n \n-BOOL CALLBACK InitHandleFunction (PINIT_ONCE InitOnce, PVOID func, PVOID *lpContext) {\n-  ((void (*)())func)();\n-  return true;\n-}\n-\n void InitOnce(OnceType* once, void (*initializer)()) {\n-  InitOnceExecuteOnce((PINIT_ONCE)once, InitHandleFunction, initializer, NULL);\n+  once->InitOnce(initializer);\n }\n \n void* AtomicPointer::Acquire_Load() const {"
      },
      {
        "sha": "849b01705fa194125e62edd673bbd0c5c25bd96a",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/960797a0de24454ce0c8c15cbb26cb6fc7683e47/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/960797a0de24454ce0c8c15cbb26cb6fc7683e47/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=960797a0de24454ce0c8c15cbb26cb6fc7683e47",
        "patch": "@@ -93,8 +93,26 @@ class CondVar {\n   \n };\n \n-typedef void* OnceType;\n-#define LEVELDB_ONCE_INIT 0\n+class OnceType {\n+public:\n+//    OnceType() : init_(false) {}\n+    OnceType(const OnceType &once) : init_(once.init_) {}\n+    OnceType(bool f) : init_(f) {}\n+    void InitOnce(void (*initializer)()) {\n+        mutex_.Lock();\n+        if (!init_) {\n+            init_ = true;\n+            initializer();\n+        }\n+        mutex_.Unlock();\n+    }\n+\n+private:\n+    bool init_;\n+    Mutex mutex_;\n+};\n+\n+#define LEVELDB_ONCE_INIT false\n extern void InitOnce(port::OnceType*, void (*initializer)());\n \n // Storage for a lock-free pointer"
      }
    ]
  },
  {
    "sha": "8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YWVmMTE5ZjQzZWUzYjRlNzVlMGYzYmQ3ZWEyOGNmN2IyOWJiNTgy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-13T01:23:05Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:41:44Z"
      },
      "message": "Mingw support for Windows LevelDB port",
      "tree": {
        "sha": "af0e0dcf54dac2613d32708d25f899b3c78a5164",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af0e0dcf54dac2613d32708d25f899b3c78a5164"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "960797a0de24454ce0c8c15cbb26cb6fc7683e47",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960797a0de24454ce0c8c15cbb26cb6fc7683e47",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/960797a0de24454ce0c8c15cbb26cb6fc7683e47"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "caf2352f9342fd10f4c36cc543fbd7f5f63248e6",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
        "patch": "@@ -127,6 +127,16 @@ case \"$TARGET_OS\" in\n         # man ld: +h internal_name\n         PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n+    OS_WINDOWS_CROSSCOMPILE | NATIVE_WINDOWS)\n+        PLATFORM=OS_WINDOWS\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS\"\n+        PLATFORM_SHARED_CFLAGS=\"\"\n+        PLATFORM_SOURCES=\"util/env_win.cc\"\n+        PLATFORM_CXXFLAGS=\"-std=c++0x\"\n+        PLATFORM_LIBS=\"-lshlwapi -ldbghelp\"\n+        PORT_FILE=port/port_win.cc\n+        CROSS_COMPILE=true\n+        ;;\n     *)\n         echo \"Unknown platform!\" >&2\n         exit 1"
      },
      {
        "sha": "db81f56d11aa968b85ee45ecfef4dee37e578cbb",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
        "patch": "@@ -1,6 +1,7 @@\n // Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n+#if !defined(LEVELDB_PLATFORM_WINDOWS)\n \n #include <deque>\n #include <set>\n@@ -696,3 +697,5 @@ Env* Env::Default() {\n }\n \n }  // namespace leveldb\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "b1024662eafddd5560fbfbac29333e5e967ca0f8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMTAyNDY2MmVhZmRkZDU1NjBmYmZiYWMyOTMzM2U1ZTk2N2NhMGY4",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-12-21T19:41:48Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T15:42:46Z"
      },
      "message": "Port leveldb to MinGW32\n\nSeveral changes to make the native windows leveldb code compile\nwith mingw32 and run on 32-bit Windows:\n* Remove -std=c++0x dependency (modified code to use NULL instead of\n  nullptr)\n* Link with -lshlwapi\n* Only #define snprintf/etc if compiling with Visual Studio\n* Do not link against DbgHelp.lib (wrote a CreateDir instead of using\n  DbgHelp's MakeSureDirectoryPathExists\n* Define WINVER=0x0500 so MinGW32 can use the 64-bit-filesystem Windows\n  api calls\n* Define __USE_MINGW_ANSI_STDIO=1 to use MinGW's printf (which supports\n  %ll)\n\nI also cleaned up makefile.mingw, assuming that dependencies would be in\nthe standard /usr/local/{include,lib} by default but allowing overriding\nwith make DEPSDIR=... etc",
      "tree": {
        "sha": "a8bdd5a1adf525847c8f7df4b2b62268f8d0a738",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8bdd5a1adf525847c8f7df4b2b62268f8d0a738"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1024662eafddd5560fbfbac29333e5e967ca0f8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1024662eafddd5560fbfbac29333e5e967ca0f8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b1024662eafddd5560fbfbac29333e5e967ca0f8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1024662eafddd5560fbfbac29333e5e967ca0f8/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8aef119f43ee3b4e75e0f3bd7ea28cf7b29bb582"
      }
    ],
    "stats": {
      "total": 111,
      "additions": 71,
      "deletions": 40
    },
    "files": [
      {
        "sha": "6c1c4a78cc4ec57019133d4e100dd97f06ef3488",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -105,13 +105,14 @@ LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n     isEmpty(QMAKE_RANLIB) {\n         QMAKE_RANLIB = $$replace(QMAKE_STRIP, strip, ranlib)\n     }\n-    genleveldb.commands = cd $$PWD/src/leveldb && CC=$$QMAKE_CC CXX=$$QMAKE_CXX TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$$BOOST_INCLUDE_PATH\" LDFLAGS=\"-L$$BOOST_LIB_PATH\" $(MAKE) libleveldb.a libmemenv.a && $$QMAKE_RANLIB $$PWD/src/leveldb/libleveldb.a && $$QMAKE_RANLIB $$PWD/src/leveldb/libmemenv.a\n+    LIBS += -lshlwapi\n+    genleveldb.commands = cd $$PWD/src/leveldb && CC=$$QMAKE_CC CXX=$$QMAKE_CXX TARGET_OS=OS_WINDOWS_CROSSCOMPILE $(MAKE) libleveldb.a libmemenv.a && $$QMAKE_RANLIB $$PWD/src/leveldb/libleveldb.a && $$QMAKE_RANLIB $$PWD/src/leveldb/libmemenv.a\n }\n genleveldb.target = $$PWD/src/leveldb/libleveldb.a\n genleveldb.depends = FORCE\n PRE_TARGETDEPS += $$PWD/src/leveldb/libleveldb.a\n QMAKE_EXTRA_TARGETS += genleveldb\n-# Gross ugly hack that depends on qmake internals, unfortunately there's no other way to do it.\n+# Gross ugly hack that depends on qmake internals, unfortunately there is no other way to do it.\n QMAKE_CLEAN += $$PWD/src/leveldb/libleveldb.a; cd $$PWD/src/leveldb ; $(MAKE) clean\n \n # regenerate src/build.h"
      },
      {
        "sha": "1080df77f4f114583b1bf10245d9b4e03f385a99",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -129,11 +129,9 @@ case \"$TARGET_OS\" in\n         ;;\n     OS_WINDOWS_CROSSCOMPILE | NATIVE_WINDOWS)\n         PLATFORM=OS_WINDOWS\n-        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS\"\n-        PLATFORM_SHARED_CFLAGS=\"\"\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS -DWINVER=0x0500 -D__USE_MINGW_ANSI_STDIO=1\"\n         PLATFORM_SOURCES=\"util/env_win.cc\"\n-        PLATFORM_CXXFLAGS=\"-std=c++0x\"\n-        PLATFORM_LIBS=\"-lshlwapi -ldbghelp\"\n+        PLATFORM_LIBS=\"-lshlwapi\"\n         PORT_FILE=port/port_win.cc\n         CROSS_COMPILE=true\n         ;;"
      },
      {
        "sha": "99c1d8e3460ddf39dc7ab32914a20df9e5f35e8a",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -37,7 +37,7 @@ namespace leveldb {\n namespace port {\n \n Mutex::Mutex() :\n-    cs_(nullptr) {\n+    cs_(NULL) {\n   assert(!cs_);\n   cs_ = static_cast<void *>(new CRITICAL_SECTION());\n   ::InitializeCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n@@ -48,7 +48,7 @@ Mutex::~Mutex() {\n   assert(cs_);\n   ::DeleteCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n   delete static_cast<CRITICAL_SECTION *>(cs_);\n-  cs_ = nullptr;\n+  cs_ = NULL;\n   assert(!cs_);\n }\n \n@@ -128,7 +128,7 @@ void InitOnce(OnceType* once, void (*initializer)()) {\n }\n \n void* AtomicPointer::Acquire_Load() const {\n-  void * p = nullptr;\n+  void * p = NULL;\n   InterlockedExchangePointer(&p, rep_);\n   return p;\n }"
      },
      {
        "sha": "45bf2f0ea749d60abb2de3d7b357e7a70eac94de",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -31,9 +31,11 @@\n #ifndef STORAGE_LEVELDB_PORT_PORT_WIN_H_\n #define STORAGE_LEVELDB_PORT_PORT_WIN_H_\n \n+#ifdef _MSC_VER\n #define snprintf _snprintf\n #define close _close\n #define fread_unlocked _fread_nolock\n+#endif\n \n #include <string>\n #include <stdint.h>\n@@ -120,7 +122,7 @@ class AtomicPointer {\n  private:\n   void * rep_;\n  public:\n-  AtomicPointer() : rep_(nullptr) { }\n+  AtomicPointer() : rep_(NULL) { }\n   explicit AtomicPointer(void* v); \n   void* Acquire_Load() const;\n "
      },
      {
        "sha": "f1a76106247c241d04822b12f5d2d4ae2766558d",
        "filename": "src/leveldb/util/env_win.cc",
        "status": "modified",
        "additions": 21,
        "deletions": 7,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/leveldb/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_win.cc?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -20,9 +20,7 @@\n #include <stdio.h>\n #include <errno.h>\n #include <io.h>\n-#include <dbghelp.h>\n #include <algorithm>\n-#pragma comment(lib,\"DbgHelp.lib\")\n \n #ifdef max\n #undef max\n@@ -908,18 +906,34 @@ uint64_t Win32Env::NowMicros()\n     return (uint64_t)(GetTickCount64()*1000);\n }\n \n-Status Win32Env::CreateDir( const std::string& dirname )\n+static Status CreateDirInner( const std::string& dirname )\n {\n     Status sRet;\n+    DWORD attr = ::GetFileAttributes(dirname.c_str());\n+    if (attr == INVALID_FILE_ATTRIBUTES) { // doesn't exist:\n+      std::size_t slash = dirname.find_last_of(\"\\\\\");\n+      if (slash != std::string::npos){\n+\tsRet = CreateDirInner(dirname.substr(0, slash));\n+\tif (!sRet.ok()) return sRet;\n+      }\n+      BOOL result = ::CreateDirectory(dirname.c_str(), NULL);\n+      if (result == FALSE) {\n+\tsRet = Status::IOError(dirname, \"Could not create directory.\");\n+\treturn sRet;\n+      }\n+    }\n+    return sRet;\n+}\n+\n+Status Win32Env::CreateDir( const std::string& dirname )\n+{\n     std::string path = dirname;\n     if(path[path.length() - 1] != '\\\\'){\n         path += '\\\\';\n     }\n     ModifyPath(path);\n-    if(!::MakeSureDirectoryPathExists( path.c_str() ) ){\n-        sRet = Status::IOError(dirname, \"Could not create directory.\");\n-    }\n-    return sRet;\n+\n+    return CreateDirInner(path);\n }\n \n Status Win32Env::DeleteDir( const std::string& dirname )"
      },
      {
        "sha": "c3cbe90bcd5bdbb98c9028fa4ed7777bf8b8ac6c",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -21,6 +21,7 @@ LIBPATHS= \\\n  -L\"$(DEPSDIR)/openssl-1.0.1c\"\n \n LIBS= \\\n+  $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a \\\n  -l boost_system-mt-s \\\n  -l boost_filesystem-mt-s \\\n  -l boost_program_options-mt-s \\\n@@ -91,11 +92,10 @@ OBJS= \\\n \n all: bitcoind.exe\n \n-LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += -I\"$(CURDIR)/leveldb/include\"\n DEFS += -I\"$(CURDIR)/leveldb/helpers\"\n leveldb/libleveldb.a:\n-\t@echo \"Building LevelDB ...\" && cd leveldb && CC=i586-mingw32msvc-gcc CXX=i586-mingw32msvc-g++ TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$(INCLUDEPATHS)\" LDFLAGS=\"-L$(LIBPATHS)\" $(MAKE) libleveldb.a libmemenv.a && i586-mingw32msvc-ranlib libleveldb.a && i586-mingw32msvc-ranlib libmemenv.a && cd ..\n+\t@echo \"Building LevelDB ...\" && cd leveldb && CC=i586-mingw32msvc-gcc CXX=i586-mingw32msvc-g++ TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"$(INCLUDEPATHS)\" LDFLAGS=\"$(LIBPATHS)\" $(MAKE) libleveldb.a libmemenv.a && i586-mingw32msvc-ranlib libleveldb.a && i586-mingw32msvc-ranlib libmemenv.a && cd ..\n obj/leveldb.o: leveldb/libleveldb.a\n \n obj/build.h: FORCE\n@@ -124,5 +124,6 @@ clean:\n \t-rm -f obj-test/*.o\n \t-rm -f test_bitcoin.exe\n \t-rm -f obj/build.h\n+\tcd leveldb && TARGET_OS=OS_WINDOWS_CROSSCOMPILE $(MAKE) clean && cd ..\n \n FORCE:"
      },
      {
        "sha": "366d32bd86e6ccb7924f3507f935f6cf3f20c4bd",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 36,
        "deletions": 21,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1024662eafddd5560fbfbac29333e5e967ca0f8/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "patch": "@@ -2,25 +2,41 @@\n # Distributed under the MIT/X11 software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-USE_UPNP:=0\n+# Makefile for the MinGW g++ compiler/toolchain\n+#\n+# Assumes Berkeley DB, Boost, and OpenSSL have all been compiled and installed\n+# into /usr/local (/usr/local/include, /usr/local/lib).\n+#\n+# If dependencies are somewhere else, run 'make DEPSDIR=/path/'\n+#\n+# Boost libraries are given wacky names that include the particular version of\n+# boost you're using; set BOOST_SUFFIX appropriately.\n+#\n+# 'make clean' assumes it is running inside a MSYS shell, and uses 'rm'\n+# to remove files.\n+\n+USE_UPNP:=-\n USE_IPV6:=1\n \n+DEPSDIR?=/usr/local\n+BOOST_SUFFIX?=-mgw46-mt-sd-1_52\n+\n INCLUDEPATHS= \\\n- -I\"C:\\boost-1.50.0-mgw\" \\\n- -I\"C:\\db-4.8.30.NC-mgw\\build_unix\" \\\n- -I\"C:\\openssl-1.0.1c-mgw\\include\"\n+ -I\"$(CURDIR)\" \\\n+ -I\"$(DEPSDIR)/include\"\n \n LIBPATHS= \\\n- -L\"C:\\boost-1.50.0-mgw\\stage\\lib\" \\\n- -L\"C:\\db-4.8.30.NC-mgw\\build_unix\" \\\n- -L\"C:\\openssl-1.0.1c-mgw\"\n+ -L\"$(CURDIR)/leveldb\" \\\n+ -L\"$(DEPSDIR)/lib\"\n \n LIBS= \\\n- -l boost_system-mgw45-mt-s-1_50 \\\n- -l boost_filesystem-mgw45-mt-s-1_50 \\\n- -l boost_program_options-mgw45-mt-s-1_50 \\\n- -l boost_thread-mgw45-mt-s-1_50 \\\n- -l boost_chrono-mgw45-mt-s-1_50 \\\n+ -l leveldb \\\n+ -l memenv \\\n+ -l boost_system$(BOOST_SUFFIX) \\\n+ -l boost_filesystem$(BOOST_SUFFIX) \\\n+ -l boost_program_options$(BOOST_SUFFIX) \\\n+ -l boost_thread$(BOOST_SUFFIX) \\\n+ -l boost_chrono$(BOOST_SUFFIX) \\\n  -l db_cxx \\\n  -l ssl \\\n  -l crypto\n@@ -37,8 +53,6 @@ ifndef USE_UPNP\n \toverride USE_UPNP = -\n endif\n ifneq (${USE_UPNP}, -)\n- INCLUDEPATHS += -I\"C:\\miniupnpc-1.6-mgw\"\n- LIBPATHS += -L\"C:\\miniupnpc-1.6-mgw\"\n  LIBS += -l miniupnpc -l iphlpapi\n  DEFS += -DSTATICLIB -DUSE_UPNP=$(USE_UPNP)\n endif\n@@ -94,12 +108,12 @@ test check: test_bitcoin.exe FORCE\n #\n # LevelDB support\n #\n-LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include)\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-# TODO: If this fails, try adding a ranlib libleveldb.a && ranlib libmemenv.a\n+\n leveldb/libleveldb.a:\n-\tcd leveldb && $(MAKE) libleveldb.a libmemenv.a && cd ..\n+\tcd leveldb && $(MAKE) OPT=\"$(DEBUGFLAGS)\" TARGET_OS=NATIVE_WINDOWS libleveldb.a libmemenv.a && cd ..\n+\n obj/leveldb.o: leveldb/libleveldb.a\n \n obj/%.o: %.cpp $(HEADERS)\n@@ -114,11 +128,12 @@ obj-test/%.o: test/%.cpp $(HEADERS)\n \tg++ -c $(TESTDEFS) $(CFLAGS) -o $@ $<\n \n test_bitcoin.exe: $(TESTOBJS) $(filter-out obj/init.o,$(OBJS:obj/%=obj/%))\n-\tg++ $(CFLAGS) $(LDFLAGS) -o $@ $(LIBPATHS) $^ -lboost_unit_test_framework $(LIBS)\n+\tg++ $(CFLAGS) $(LDFLAGS) -o $@ $(LIBPATHS) $^ -lboost_unit_test_framework$(BOOST_SUFFIX) $(LIBS)\n \n clean:\n-\t-del /Q bitcoind test_bitcoin\n-\t-del /Q obj\\*\n-\t-del /Q obj-test\\*\n+\trm -f bitcoind.exe test_bitcoin.exe\n+\trm -f obj/*\n+\trm -f obj-test/*\n+\tcd leveldb && $(MAKE) TARGET_OS=NATIVE_WINDOWS clean && cd ..\n \n FORCE:"
      }
    ]
  },
  {
    "sha": "f79ddf24a967a0043270b2999921550c6c366ec4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNzlkZGYyNGE5NjdhMDA0MzI3MGIyOTk5OTIxNTUwYzZjMzY2ZWM0",
    "commit": {
      "author": {
        "name": "Sanjay Ghemawat",
        "email": "sanjay@google.com",
        "date": "2012-12-27T18:38:48Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T19:00:29Z"
      },
      "message": "added utility to dump leveldb files",
      "tree": {
        "sha": "2f4819b34a46cd15ef6b985a0d367d0b0cf3f77f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f4819b34a46cd15ef6b985a0d367d0b0cf3f77f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f79ddf24a967a0043270b2999921550c6c366ec4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f79ddf24a967a0043270b2999921550c6c366ec4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f79ddf24a967a0043270b2999921550c6c366ec4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f79ddf24a967a0043270b2999921550c6c366ec4/comments",
    "author": {
      "login": "ghemawat",
      "id": 8096977,
      "node_id": "MDQ6VXNlcjgwOTY5Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8096977?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ghemawat",
      "html_url": "https://github.com/ghemawat",
      "followers_url": "https://api.github.com/users/ghemawat/followers",
      "following_url": "https://api.github.com/users/ghemawat/following{/other_user}",
      "gists_url": "https://api.github.com/users/ghemawat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ghemawat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ghemawat/subscriptions",
      "organizations_url": "https://api.github.com/users/ghemawat/orgs",
      "repos_url": "https://api.github.com/users/ghemawat/repos",
      "events_url": "https://api.github.com/users/ghemawat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ghemawat/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1024662eafddd5560fbfbac29333e5e967ca0f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b1024662eafddd5560fbfbac29333e5e967ca0f8"
      }
    ],
    "stats": {
      "total": 258,
      "additions": 253,
      "deletions": 5
    },
    "files": [
      {
        "sha": "fef085b9c49b7526c4be01af626fbde9f067fac9",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=f79ddf24a967a0043270b2999921550c6c366ec4",
        "patch": "@@ -50,7 +50,7 @@ TESTS = \\\n \tversion_set_test \\\n \twrite_batch_test\n \n-PROGRAMS = db_bench $(TESTS)\n+PROGRAMS = db_bench leveldbutil $(TESTS)\n BENCHMARKS = db_bench_sqlite3 db_bench_tree_db\n \n LIBRARY = libleveldb.a\n@@ -69,7 +69,7 @@ SHARED = $(SHARED1)\n else\n # Update db.h if you change these.\n SHARED_MAJOR = 1\n-SHARED_MINOR = 7\n+SHARED_MINOR = 8\n SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)\n@@ -107,6 +107,9 @@ db_bench_sqlite3: doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL)\n db_bench_tree_db: doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL)\n \t$(CXX) $(LDFLAGS) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ -lkyotocabinet $(LIBS)\n \n+leveldbutil: db/leveldb_main.o $(LIBOBJECTS)\n+\t$(CXX) $(LDFLAGS) db/leveldb_main.o $(LIBOBJECTS) -o $@ $(LIBS)\n+\n arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n "
      },
      {
        "sha": "609cb512248dcc14c1a402338a3baa9a49df5bb6",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=f79ddf24a967a0043270b2999921550c6c366ec4",
        "patch": "@@ -149,7 +149,8 @@ DIRS=\"$PREFIX/db $PREFIX/util $PREFIX/table\"\n set -f # temporarily disable globbing so that our patterns aren't expanded\n PRUNE_TEST=\"-name *test*.cc -prune\"\n PRUNE_BENCH=\"-name *_bench.cc -prune\"\n-PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -print | sort | sed \"s,^$PREFIX/,,\" | tr \"\\n\" \" \"`\n+PRUNE_TOOL=\"-name leveldb_main.cc -prune\"\n+PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o $PRUNE_TOOL -o -name '*.cc' -print | sort | sed \"s,^$PREFIX/,,\" | tr \"\\n\" \" \"`\n \n set +f # re-enable globbing\n "
      },
      {
        "sha": "995d76107a16efd9677ec6d2c125c04502fcec3d",
        "filename": "src/leveldb/db/leveldb_main.cc",
        "status": "added",
        "additions": 238,
        "deletions": 0,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/db/leveldb_main.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/db/leveldb_main.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/leveldb_main.cc?ref=f79ddf24a967a0043270b2999921550c6c366ec4",
        "patch": "@@ -0,0 +1,238 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <stdio.h>\n+#include \"db/dbformat.h\"\n+#include \"db/filename.h\"\n+#include \"db/log_reader.h\"\n+#include \"db/version_edit.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/iterator.h\"\n+#include \"leveldb/options.h\"\n+#include \"leveldb/status.h\"\n+#include \"leveldb/table.h\"\n+#include \"leveldb/write_batch.h\"\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+\n+namespace {\n+\n+bool GuessType(const std::string& fname, FileType* type) {\n+  size_t pos = fname.rfind('/');\n+  std::string basename;\n+  if (pos == std::string::npos) {\n+    basename = fname;\n+  } else {\n+    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);\n+  }\n+  uint64_t ignored;\n+  return ParseFileName(basename, &ignored, type);\n+}\n+\n+// Notified when log reader encounters corruption.\n+class CorruptionReporter : public log::Reader::Reporter {\n+ public:\n+  virtual void Corruption(size_t bytes, const Status& status) {\n+    printf(\"corruption: %d bytes; %s\\n\",\n+            static_cast<int>(bytes),\n+            status.ToString().c_str());\n+  }\n+};\n+\n+// Print contents of a log file. (*func)() is called on every record.\n+bool PrintLogContents(Env* env, const std::string& fname,\n+                      void (*func)(Slice)) {\n+  SequentialFile* file;\n+  Status s = env->NewSequentialFile(fname, &file);\n+  if (!s.ok()) {\n+    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n+    return false;\n+  }\n+  CorruptionReporter reporter;\n+  log::Reader reader(file, &reporter, true, 0);\n+  Slice record;\n+  std::string scratch;\n+  while (reader.ReadRecord(&record, &scratch)) {\n+    printf(\"--- offset %llu; \",\n+           static_cast<unsigned long long>(reader.LastRecordOffset()));\n+    (*func)(record);\n+  }\n+  delete file;\n+  return true;\n+}\n+\n+// Called on every item found in a WriteBatch.\n+class WriteBatchItemPrinter : public WriteBatch::Handler {\n+ public:\n+  uint64_t offset_;\n+  uint64_t sequence_;\n+\n+  virtual void Put(const Slice& key, const Slice& value) {\n+    printf(\"  put '%s' '%s'\\n\",\n+           EscapeString(key).c_str(),\n+           EscapeString(value).c_str());\n+  }\n+  virtual void Delete(const Slice& key) {\n+    printf(\"  del '%s'\\n\",\n+           EscapeString(key).c_str());\n+  }\n+};\n+\n+\n+// Called on every log record (each one of which is a WriteBatch)\n+// found in a kLogFile.\n+static void WriteBatchPrinter(Slice record) {\n+  if (record.size() < 12) {\n+    printf(\"log record length %d is too small\\n\",\n+           static_cast<int>(record.size()));\n+    return;\n+  }\n+  WriteBatch batch;\n+  WriteBatchInternal::SetContents(&batch, record);\n+  printf(\"sequence %llu\\n\",\n+         static_cast<unsigned long long>(WriteBatchInternal::Sequence(&batch)));\n+  WriteBatchItemPrinter batch_item_printer;\n+  Status s = batch.Iterate(&batch_item_printer);\n+  if (!s.ok()) {\n+    printf(\"  error: %s\\n\", s.ToString().c_str());\n+  }\n+}\n+\n+bool DumpLog(Env* env, const std::string& fname) {\n+  return PrintLogContents(env, fname, WriteBatchPrinter);\n+}\n+\n+// Called on every log record (each one of which is a WriteBatch)\n+// found in a kDescriptorFile.\n+static void VersionEditPrinter(Slice record) {\n+  VersionEdit edit;\n+  Status s = edit.DecodeFrom(record);\n+  if (!s.ok()) {\n+    printf(\"%s\\n\", s.ToString().c_str());\n+    return;\n+  }\n+  printf(\"%s\", edit.DebugString().c_str());\n+}\n+\n+bool DumpDescriptor(Env* env, const std::string& fname) {\n+  return PrintLogContents(env, fname, VersionEditPrinter);\n+}\n+\n+bool DumpTable(Env* env, const std::string& fname) {\n+  uint64_t file_size;\n+  RandomAccessFile* file = NULL;\n+  Table* table = NULL;\n+  Status s = env->GetFileSize(fname, &file_size);\n+  if (s.ok()) {\n+    s = env->NewRandomAccessFile(fname, &file);\n+  }\n+  if (s.ok()) {\n+    // We use the default comparator, which may or may not match the\n+    // comparator used in this database. However this should not cause\n+    // problems since we only use Table operations that do not require\n+    // any comparisons.  In particular, we do not call Seek or Prev.\n+    s = Table::Open(Options(), file, file_size, &table);\n+  }\n+  if (!s.ok()) {\n+    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n+    delete table;\n+    delete file;\n+    return false;\n+  }\n+\n+  ReadOptions ro;\n+  ro.fill_cache = false;\n+  Iterator* iter = table->NewIterator(ro);\n+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+    ParsedInternalKey key;\n+    if (!ParseInternalKey(iter->key(), &key)) {\n+      printf(\"badkey '%s' => '%s'\\n\",\n+             EscapeString(iter->key()).c_str(),\n+             EscapeString(iter->value()).c_str());\n+    } else {\n+      char kbuf[20];\n+      const char* type;\n+      if (key.type == kTypeDeletion) {\n+        type = \"del\";\n+      } else if (key.type == kTypeValue) {\n+        type = \"val\";\n+      } else {\n+        snprintf(kbuf, sizeof(kbuf), \"%d\", static_cast<int>(key.type));\n+        type = kbuf;\n+      }\n+      printf(\"'%s' @ %8llu : %s => '%s'\\n\",\n+             EscapeString(key.user_key).c_str(),\n+             static_cast<unsigned long long>(key.sequence),\n+             type,\n+             EscapeString(iter->value()).c_str());\n+    }\n+  }\n+  s = iter->status();\n+  if (!s.ok()) {\n+    printf(\"iterator error: %s\\n\", s.ToString().c_str());\n+  }\n+\n+  delete iter;\n+  delete table;\n+  delete file;\n+  return true;\n+}\n+\n+bool DumpFile(Env* env, const std::string& fname) {\n+  FileType ftype;\n+  if (!GuessType(fname, &ftype)) {\n+    fprintf(stderr, \"%s: unknown file type\\n\", fname.c_str());\n+    return false;\n+  }\n+  switch (ftype) {\n+    case kLogFile:         return DumpLog(env, fname);\n+    case kDescriptorFile:  return DumpDescriptor(env, fname);\n+    case kTableFile:       return DumpTable(env, fname);\n+\n+    default: {\n+      fprintf(stderr, \"%s: not a dump-able file type\\n\", fname.c_str());\n+      break;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool HandleDumpCommand(Env* env, char** files, int num) {\n+  bool ok = true;\n+  for (int i = 0; i < num; i++) {\n+    ok &= DumpFile(env, files[i]);\n+  }\n+  return ok;\n+}\n+\n+}\n+}  // namespace leveldb\n+\n+static void Usage() {\n+  fprintf(\n+      stderr,\n+      \"Usage: leveldbutil command...\\n\"\n+      \"   dump files...         -- dump contents of specified files\\n\"\n+      );\n+}\n+\n+int main(int argc, char** argv) {\n+  leveldb::Env* env = leveldb::Env::Default();\n+  bool ok = true;\n+  if (argc < 2) {\n+    Usage();\n+    ok = false;\n+  } else {\n+    std::string command = argv[1];\n+    if (command == \"dump\") {\n+      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);\n+    } else {\n+      Usage();\n+      ok = false;\n+    }\n+  }\n+  return (ok ? 0 : 1);\n+}"
      },
      {
        "sha": "f1e70a01e97251e1ad7b8387a85b365ec7f6c97f",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=f79ddf24a967a0043270b2999921550c6c366ec4",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 7;\n+static const int kMinorVersion = 8;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "f2b89bffb99c232c03922806868b0ccf663bc111",
        "filename": "src/leveldb/port/port_posix.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f79ddf24a967a0043270b2999921550c6c366ec4/src/leveldb/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.h?ref=f79ddf24a967a0043270b2999921550c6c366ec4",
        "patch": "@@ -26,11 +26,17 @@\n   #include <sys/endian.h>\n   #define PLATFORM_IS_LITTLE_ENDIAN (_BYTE_ORDER == _LITTLE_ENDIAN)\n #elif defined(OS_OPENBSD) || defined(OS_NETBSD) ||\\\n-      defined(OS_DRAGONFLYBSD) || defined(OS_ANDROID)\n+      defined(OS_DRAGONFLYBSD)\n   #include <sys/types.h>\n   #include <sys/endian.h>\n #elif defined(OS_HPUX)\n   #define PLATFORM_IS_LITTLE_ENDIAN false\n+#elif defined(OS_ANDROID)\n+  // Due to a bug in the NDK x86 <sys/endian.h> definition,\n+  // _BYTE_ORDER must be used instead of __BYTE_ORDER on Android.\n+  // See http://code.google.com/p/android/issues/detail?id=39824\n+  #include <endian.h>\n+  #define PLATFORM_IS_LITTLE_ENDIAN  (_BYTE_ORDER == _LITTLE_ENDIAN)\n #else\n   #include <endian.h>\n #endif"
      }
    ]
  },
  {
    "sha": "36311b9a194e3546006478157279383ffa624cf0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjMxMWI5YTE5NGUzNTQ2MDA2NDc4MTU3Mjc5MzgzZmZhNjI0Y2Yw",
    "commit": {
      "author": {
        "name": "David Grogan",
        "email": "dgrogan@chromium.org",
        "date": "2013-01-07T21:17:43Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-23T19:00:29Z"
      },
      "message": "Fix corruption bug found and analyzed by dhruba@gmail.com\n\nhttps://groups.google.com/d/msg/leveldb/Kc9JxuIUu5A/9P0N9RL4ar8J",
      "tree": {
        "sha": "10874de5669607f5c2d3f443bdc23af5aafb3f25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10874de5669607f5c2d3f443bdc23af5aafb3f25"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36311b9a194e3546006478157279383ffa624cf0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36311b9a194e3546006478157279383ffa624cf0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/36311b9a194e3546006478157279383ffa624cf0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36311b9a194e3546006478157279383ffa624cf0/comments",
    "author": {
      "login": "davidsgrogan",
      "id": 1801875,
      "node_id": "MDQ6VXNlcjE4MDE4NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1801875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidsgrogan",
      "html_url": "https://github.com/davidsgrogan",
      "followers_url": "https://api.github.com/users/davidsgrogan/followers",
      "following_url": "https://api.github.com/users/davidsgrogan/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidsgrogan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidsgrogan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidsgrogan/subscriptions",
      "organizations_url": "https://api.github.com/users/davidsgrogan/orgs",
      "repos_url": "https://api.github.com/users/davidsgrogan/repos",
      "events_url": "https://api.github.com/users/davidsgrogan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidsgrogan/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f79ddf24a967a0043270b2999921550c6c366ec4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f79ddf24a967a0043270b2999921550c6c366ec4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f79ddf24a967a0043270b2999921550c6c366ec4"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 115,
      "deletions": 2
    },
    "files": [
      {
        "sha": "42c4952fec048deabc07a6ffff2b1b951a4fe52c",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=36311b9a194e3546006478157279383ffa624cf0",
        "patch": "@@ -69,7 +69,7 @@ SHARED = $(SHARED1)\n else\n # Update db.h if you change these.\n SHARED_MAJOR = 1\n-SHARED_MINOR = 8\n+SHARED_MINOR = 9\n SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)"
      },
      {
        "sha": "684ea3bdbc8ecc80d51cfecbfbe8be1d78711e6a",
        "filename": "src/leveldb/db/db_test.cc",
        "status": "modified",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/db_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/db_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_test.cc?ref=36311b9a194e3546006478157279383ffa624cf0",
        "patch": "@@ -59,6 +59,12 @@ class SpecialEnv : public EnvWrapper {\n   // Simulate non-writable file system while this pointer is non-NULL\n   port::AtomicPointer non_writable_;\n \n+  // Force sync of manifest files to fail while this pointer is non-NULL\n+  port::AtomicPointer manifest_sync_error_;\n+\n+  // Force write to manifest files to fail while this pointer is non-NULL\n+  port::AtomicPointer manifest_write_error_;\n+\n   bool count_random_reads_;\n   AtomicCounter random_read_counter_;\n \n@@ -69,6 +75,8 @@ class SpecialEnv : public EnvWrapper {\n     no_space_.Release_Store(NULL);\n     non_writable_.Release_Store(NULL);\n     count_random_reads_ = false;\n+    manifest_sync_error_.Release_Store(NULL);\n+    manifest_write_error_.Release_Store(NULL);\n   }\n \n   Status NewWritableFile(const std::string& f, WritableFile** r) {\n@@ -100,6 +108,30 @@ class SpecialEnv : public EnvWrapper {\n         return base_->Sync();\n       }\n     };\n+    class ManifestFile : public WritableFile {\n+     private:\n+      SpecialEnv* env_;\n+      WritableFile* base_;\n+     public:\n+      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n+      ~ManifestFile() { delete base_; }\n+      Status Append(const Slice& data) {\n+        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n+          return Status::IOError(\"simulated writer error\");\n+        } else {\n+          return base_->Append(data);\n+        }\n+      }\n+      Status Close() { return base_->Close(); }\n+      Status Flush() { return base_->Flush(); }\n+      Status Sync() {\n+        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n+          return Status::IOError(\"simulated sync error\");\n+        } else {\n+          return base_->Sync();\n+        }\n+      }\n+    };\n \n     if (non_writable_.Acquire_Load() != NULL) {\n       return Status::IOError(\"simulated write error\");\n@@ -109,6 +141,8 @@ class SpecialEnv : public EnvWrapper {\n     if (s.ok()) {\n       if (strstr(f.c_str(), \".sst\") != NULL) {\n         *r = new SSTableFile(this, *r);\n+      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n+        *r = new ManifestFile(this, *r);\n       }\n     }\n     return s;\n@@ -1492,6 +1526,47 @@ TEST(DBTest, NonWritableFileSystem) {\n   env_->non_writable_.Release_Store(NULL);\n }\n \n+TEST(DBTest, ManifestWriteError) {\n+  // Test for the following problem:\n+  // (a) Compaction produces file F\n+  // (b) Log record containing F is written to MANIFEST file, but Sync() fails\n+  // (c) GC deletes F\n+  // (d) After reopening DB, reads fail since deleted F is named in log record\n+\n+  // We iterate twice.  In the second iteration, everything is the\n+  // same except the log record never makes it to the MANIFEST file.\n+  for (int iter = 0; iter < 2; iter++) {\n+    port::AtomicPointer* error_type = (iter == 0)\n+        ? &env_->manifest_sync_error_\n+        : &env_->manifest_write_error_;\n+\n+    // Insert foo=>bar mapping\n+    Options options = CurrentOptions();\n+    options.env = env_;\n+    options.create_if_missing = true;\n+    options.error_if_exists = false;\n+    DestroyAndReopen(&options);\n+    ASSERT_OK(Put(\"foo\", \"bar\"));\n+    ASSERT_EQ(\"bar\", Get(\"foo\"));\n+\n+    // Memtable compaction (will succeed)\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"bar\", Get(\"foo\"));\n+    const int last = config::kMaxMemCompactLevel;\n+    ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo=>bar is now in last level\n+\n+    // Merging compaction (will fail)\n+    error_type->Release_Store(env_);\n+    dbfull()->TEST_CompactRange(last, NULL, NULL);  // Should fail\n+    ASSERT_EQ(\"bar\", Get(\"foo\"));\n+\n+    // Recovery: should not lose data\n+    error_type->Release_Store(NULL);\n+    Reopen(&options);\n+    ASSERT_EQ(\"bar\", Get(\"foo\"));\n+  }\n+}\n+\n TEST(DBTest, FilesDeletedAfterCompaction) {\n   ASSERT_OK(Put(\"foo\", \"v2\"));\n   Compact(\"a\", \"z\");"
      },
      {
        "sha": "7d0a5de2b9f3e0559417a73204e6668bbed1793b",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=36311b9a194e3546006478157279383ffa624cf0",
        "patch": "@@ -786,12 +786,23 @@ Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n       if (s.ok()) {\n         s = descriptor_file_->Sync();\n       }\n+      if (!s.ok()) {\n+        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n+        if (ManifestContains(record)) {\n+          Log(options_->info_log,\n+              \"MANIFEST contains log record despite error; advancing to new \"\n+              \"version to prevent mismatch between in-memory and logged state\");\n+          s = Status::OK();\n+        }\n+      }\n     }\n \n     // If we just created a new descriptor file, install it by writing a\n     // new CURRENT file that points to it.\n     if (s.ok() && !new_manifest_file.empty()) {\n       s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n+      // No need to double-check MANIFEST in case of error since it\n+      // will be discarded below.\n     }\n \n     mu->Lock();\n@@ -1025,6 +1036,31 @@ const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {\n   return scratch->buffer;\n }\n \n+// Return true iff the manifest contains the specified record.\n+bool VersionSet::ManifestContains(const std::string& record) const {\n+  std::string fname = DescriptorFileName(dbname_, manifest_file_number_);\n+  Log(options_->info_log, \"ManifestContains: checking %s\\n\", fname.c_str());\n+  SequentialFile* file = NULL;\n+  Status s = env_->NewSequentialFile(fname, &file);\n+  if (!s.ok()) {\n+    Log(options_->info_log, \"ManifestContains: %s\\n\", s.ToString().c_str());\n+    return false;\n+  }\n+  log::Reader reader(file, NULL, true/*checksum*/, 0);\n+  Slice r;\n+  std::string scratch;\n+  bool result = false;\n+  while (reader.ReadRecord(&r, &scratch)) {\n+    if (r == Slice(record)) {\n+      result = true;\n+      break;\n+    }\n+  }\n+  delete file;\n+  Log(options_->info_log, \"ManifestContains: result = %d\\n\", result ? 1 : 0);\n+  return result;\n+}\n+\n uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n   uint64_t result = 0;\n   for (int level = 0; level < config::kNumLevels; level++) {"
      },
      {
        "sha": "9d084fdb7d00574c627291b1a48e059a8093d5b4",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=36311b9a194e3546006478157279383ffa624cf0",
        "patch": "@@ -277,6 +277,8 @@ class VersionSet {\n \n   void AppendVersion(Version* v);\n \n+  bool ManifestContains(const std::string& record) const;\n+\n   Env* const env_;\n   const std::string dbname_;\n   const Options* const options_;"
      },
      {
        "sha": "29d367447907063975608d742c8a29a799848fb5",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36311b9a194e3546006478157279383ffa624cf0/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=36311b9a194e3546006478157279383ffa624cf0",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 8;\n+static const int kMinorVersion = 9;\n \n struct Options;\n struct ReadOptions;"
      }
    ]
  }
]