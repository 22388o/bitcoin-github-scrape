[
  {
    "sha": "2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjRhYjA1YzVhMzkxOWFmY2E1YTdmNGZkNjAwZmI2MWMxMDAzYjhh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-08T22:03:19Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Revert \"Merge #12694: Actually disable BnB when there are preset inputs\"\n\nThis reverts commit 9552dfb1f6326b97ae05efb8af503eb7776a2d59, reversing\nchanges made to f686002a8eba820a40ac2f34a6e8f57b2b5cc54c.",
      "tree": {
        "sha": "7e126599ffc9eabf27a42a203f08eb10f9a07fdd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e126599ffc9eabf27a42a203f08eb10f9a07fdd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1f470a8916aabbb7f03afda26d41ebfd8d1a2263",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f470a8916aabbb7f03afda26d41ebfd8d1a2263",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1f470a8916aabbb7f03afda26d41ebfd8d1a2263"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 11,
      "deletions": 25
    },
    "files": [
      {
        "sha": "2a9a07df5f1ace4c53d0e1b2774cd04f7e3b5a1c",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 15,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
        "patch": "@@ -4,7 +4,6 @@\n \n #include <wallet/wallet.h>\n #include <wallet/coinselection.h>\n-#include <wallet/coincontrol.h>\n #include <amount.h>\n #include <primitives/transaction.h>\n #include <random.h>\n@@ -28,7 +27,7 @@ std::vector<std::unique_ptr<CWalletTx>> wtxn;\n typedef std::set<CInputCoin> CoinSet;\n \n static std::vector<COutput> vCoins;\n-static CWallet testWallet(\"dummy\", WalletDatabase::CreateDummy());\n+static const CWallet testWallet(\"dummy\", WalletDatabase::CreateDummy());\n static CAmount balance = 0;\n \n CoinEligibilityFilter filter_standard(1, 6, 0);\n@@ -73,7 +72,6 @@ static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = fa\n     }\n     COutput output(wtx.get(), nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n     vCoins.push_back(output);\n-    testWallet.AddToWallet(*wtx.get());\n     wtxn.emplace_back(std::move(wtx));\n }\n \n@@ -240,18 +238,6 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n     BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n-\n-    // Make sure that we aren't using BnB when there are preset inputs\n-    empty_wallet();\n-    add_coin(5 * CENT);\n-    add_coin(3 * CENT);\n-    add_coin(2 * CENT);\n-    CCoinControl coin_control;\n-    coin_control.fAllowOtherInputs = true;\n-    coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n-    BOOST_CHECK(testWallet.SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb, bnb_used));\n-    BOOST_CHECK(!bnb_used);\n-    BOOST_CHECK(!coin_selection_params_bnb.use_bnb);\n }\n \n BOOST_AUTO_TEST_CASE(knapsack_solver_test)"
      },
      {
        "sha": "0060bd48acf8990875cc3fa75b80bc6939ff421b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
        "patch": "@@ -2469,7 +2469,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     }\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n@@ -2499,7 +2499,6 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     {\n         // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n         bnb_used = false;\n-        coin_selection_params.use_bnb = false;\n \n         std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())"
      },
      {
        "sha": "3e99c0c4a53731f1127a4fbde56c3916fd292140",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
        "patch": "@@ -670,6 +670,15 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::mutex mutexScanning;\n     friend class WalletRescanReserver;\n \n+\n+    /**\n+     * Select a set of coins such that nValueRet >= nTargetValue and at least\n+     * all coins from coinControl are selected; Never select unconfirmed coins\n+     * if they are not ours\n+     */\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n+                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+\n     WalletBatch *encrypted_batch = nullptr;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n@@ -782,14 +791,6 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n         return *database;\n     }\n \n-    /**\n-     * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coinControl are selected; Never select unconfirmed coins\n-     * if they are not ours\n-     */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n-\n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n     const std::string& GetName() const { return m_name; }"
      }
    ]
  },
  {
    "sha": "65b535b86266b29a33020244cfe7e057a7a2d5ca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NWI1MzViODYyNjZiMjlhMzMwMjAyNDRjZmU3ZTA1N2E3YTJkNWNh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-14T18:30:29Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Implement the SingleRandomDraw coin selection method\n\nSingleRandomDraw randomly chooses UTXOs until there is sufficient\neffective value.",
      "tree": {
        "sha": "9632abc412ec87060a296d18dc5eaeac96773fc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9632abc412ec87060a296d18dc5eaeac96773fc4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65b535b86266b29a33020244cfe7e057a7a2d5ca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65b535b86266b29a33020244cfe7e057a7a2d5ca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65b535b86266b29a33020244cfe7e057a7a2d5ca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65b535b86266b29a33020244cfe7e057a7a2d5ca/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f4ab05c5a3919afca5a7f4fd600fb61c1003b8a"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 32,
      "deletions": 1
    },
    "files": [
      {
        "sha": "300d23f826bea4495ed5642a7cb20f962a7008ee",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65b535b86266b29a33020244cfe7e057a7a2d5ca/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65b535b86266b29a33020244cfe7e057a7a2d5ca/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=65b535b86266b29a33020244cfe7e057a7a2d5ca",
        "patch": "@@ -324,3 +324,30 @@ bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter& eligibility_f\n         && m_ancestors <= eligibility_filter.max_ancestors\n         && m_descendants <= eligibility_filter.max_descendants;\n }\n+\n+bool SingleRandomDraw(const CAmount& recipient_value, std::vector<OutputGroup>& utxo_pool, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount non_input_fees)\n+{\n+    FastRandomContext random_ctx;\n+    CAmount curr_value = 0;\n+    value_ret = 0;\n+    out_set.clear();\n+    for (size_t i = 0; i < utxo_pool.size(); ++i) {\n+        size_t pos = i + random_ctx.randrange(utxo_pool.size() - i); // randomly pick one of the remaining elements\n+        std::swap(utxo_pool[i], utxo_pool[pos]);\n+        const OutputGroup& utxo = utxo_pool[i];\n+\n+        // Assert that this utxo is not negative. It should never be negative, effective value calculation should have removed it\n+        assert(utxo.effective_value > 0);\n+\n+        // Add this coin\n+        curr_value += utxo.effective_value;\n+        value_ret += utxo.m_value;\n+        util::insert(out_set, utxo.m_outputs);\n+\n+        // We have enough coins, stop selecting\n+        if (curr_value >= recipient_value + non_input_fees) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}"
      },
      {
        "sha": "1ccb408f02311ebbb5135f276f681316d0bdfe36",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65b535b86266b29a33020244cfe7e057a7a2d5ca/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65b535b86266b29a33020244cfe7e057a7a2d5ca/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=65b535b86266b29a33020244cfe7e057a7a2d5ca",
        "patch": "@@ -96,6 +96,10 @@ struct OutputGroup\n bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n \n // Original coin selection algorithm as a fallback\n-bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& groups, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);\n+bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);\n \n+/**\n+ * Randomly selects coins until the target value is exceeded. Uses effective values\n+ */\n+bool SingleRandomDraw(const CAmount& recipient_value, std::vector<OutputGroup>& utxo_pool, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount non_input_fees);\n #endif // BITCOIN_WALLET_COINSELECTION_H"
      }
    ]
  },
  {
    "sha": "ffd71565b37a046be1496e730d4579190f718f79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZmQ3MTU2NWIzN2EwNDZiZTE0OTZlNzMwZDQ1NzkxOTBmNzE4Zjc5",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T05:06:14Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Replace the coin selection fallback with SRD\n\nReplaces the knapsack solver fallback with the SRD fallback. Also\nchanges SelectCoinsMinConf to use exclusively effective value to\nwork with BnB and SRD",
      "tree": {
        "sha": "5dc17527c4b32590954656160c9b418ec2f4979b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5dc17527c4b32590954656160c9b418ec2f4979b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffd71565b37a046be1496e730d4579190f718f79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd71565b37a046be1496e730d4579190f718f79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ffd71565b37a046be1496e730d4579190f718f79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd71565b37a046be1496e730d4579190f718f79/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "65b535b86266b29a33020244cfe7e057a7a2d5ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65b535b86266b29a33020244cfe7e057a7a2d5ca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65b535b86266b29a33020244cfe7e057a7a2d5ca"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 34,
      "deletions": 38
    },
    "files": [
      {
        "sha": "a5544d61b992b562caea6fa578af9580a7d18d3b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 38,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffd71565b37a046be1496e730d4579190f718f79/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffd71565b37a046be1496e730d4579190f718f79/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=ffd71565b37a046be1496e730d4579190f718f79",
        "patch": "@@ -2421,51 +2421,47 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n+    // Get long term estimate\n+    FeeCalculation feeCalc;\n+    CCoinControl temp;\n+    temp.m_confirm_target = 1008;\n+    CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, ::mempool, ::feeEstimator, &feeCalc);\n+\n+    // Calculate cost of change\n+    CAmount cost_of_change = GetDiscardRate(*this, ::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n+\n+    // Filter by the min conf specs and add to utxo_pool and calculate effective value\n     std::vector<OutputGroup> utxo_pool;\n-    if (coin_selection_params.use_bnb) {\n-        // Get long term estimate\n-        FeeCalculation feeCalc;\n-        CCoinControl temp;\n-        temp.m_confirm_target = 1008;\n-        CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, ::mempool, ::feeEstimator, &feeCalc);\n-\n-        // Calculate cost of change\n-        CAmount cost_of_change = GetDiscardRate(*this, ::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n-\n-        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n-        for (OutputGroup& group : groups) {\n-            if (!group.EligibleForSpending(eligibility_filter)) continue;\n-\n-            group.fee = 0;\n-            group.long_term_fee = 0;\n-            group.effective_value = 0;\n-            for (auto it = group.m_outputs.begin(); it != group.m_outputs.end(); ) {\n-                const CInputCoin& coin = *it;\n-                CAmount effective_value = coin.txout.nValue - (coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes));\n-                // Only include outputs that are positive effective value (i.e. not dust)\n-                if (effective_value > 0) {\n-                    group.fee += coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n-                    group.long_term_fee += coin.m_input_bytes < 0 ? 0 : long_term_feerate.GetFee(coin.m_input_bytes);\n-                    group.effective_value += effective_value;\n-                    ++it;\n-                } else {\n-                    it = group.Discard(coin);\n-                }\n+    for (OutputGroup& group : groups) {\n+        if (!group.EligibleForSpending(eligibility_filter)) continue;\n+\n+        group.fee = 0;\n+        group.long_term_fee = 0;\n+        group.effective_value = 0;\n+        for (auto it = group.m_outputs.begin(); it != group.m_outputs.end(); ) {\n+            const CInputCoin& coin = *it;\n+            CAmount effective_value = coin.txout.nValue - (coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes));\n+            // Only include outputs that are positive effective value (i.e. not dust)\n+            if (effective_value > 0) {\n+                group.fee += coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n+                group.long_term_fee += coin.m_input_bytes < 0 ? 0 : long_term_feerate.GetFee(coin.m_input_bytes);\n+                group.effective_value += effective_value;\n+                ++it;\n+            } else {\n+                it = group.Discard(coin);\n             }\n-            if (group.effective_value > 0) utxo_pool.push_back(group);\n         }\n-        // Calculate the fees for things that aren't inputs\n-        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+        if (group.effective_value > 0) utxo_pool.push_back(group);\n+    }\n+    // Calculate the fees for things that aren't inputs\n+    CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+\n+    if (coin_selection_params.use_bnb) {\n         bnb_used = true;\n         return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        // Filter by the min conf specs and add to utxo_pool\n-        for (const OutputGroup& group : groups) {\n-            if (!group.EligibleForSpending(eligibility_filter)) continue;\n-            utxo_pool.push_back(group);\n-        }\n         bnb_used = false;\n-        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n+        return SingleRandomDraw(nTargetValue, utxo_pool, setCoinsRet, nValueRet, not_input_fees);\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "02b288f91fdbf8282cdf81f9639547c70a7b9d46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMmIyODhmOTFmZGJmODI4MmNkZjgxZjk2Mzk1NDdjNzBhN2I5ZDQ2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T05:07:25Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Remove KnapsackSolver and related tests",
      "tree": {
        "sha": "ab3600020ec0e8411765ff14024ef90e8006200c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab3600020ec0e8411765ff14024ef90e8006200c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02b288f91fdbf8282cdf81f9639547c70a7b9d46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02b288f91fdbf8282cdf81f9639547c70a7b9d46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/02b288f91fdbf8282cdf81f9639547c70a7b9d46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02b288f91fdbf8282cdf81f9639547c70a7b9d46/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ffd71565b37a046be1496e730d4579190f718f79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd71565b37a046be1496e730d4579190f718f79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ffd71565b37a046be1496e730d4579190f718f79"
      }
    ],
    "stats": {
      "total": 417,
      "additions": 0,
      "deletions": 417
    },
    "files": [
      {
        "sha": "6c4b1b0e759adf78e214321e2df5f02d94df81ab",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 124,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=02b288f91fdbf8282cdf81f9639547c70a7b9d46",
        "patch": "@@ -164,130 +164,6 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_v\n     return true;\n }\n \n-static void ApproximateBestSubset(const std::vector<OutputGroup>& groups, const CAmount& nTotalLower, const CAmount& nTargetValue,\n-                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n-{\n-    std::vector<char> vfIncluded;\n-\n-    vfBest.assign(groups.size(), true);\n-    nBest = nTotalLower;\n-\n-    FastRandomContext insecure_rand;\n-\n-    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(groups.size(), false);\n-        CAmount nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (unsigned int i = 0; i < groups.size(); i++)\n-            {\n-                //The solver here uses a randomized algorithm,\n-                //the randomness serves no real security purpose but is just\n-                //needed to prevent degenerate behavior and it is important\n-                //that the rng is fast. We do not use a constant random sequence,\n-                //because there may be some privacy improvement by making\n-                //the selection random.\n-                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n-                {\n-                    nTotal += groups[i].m_value;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= groups[i].m_value;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& groups, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet)\n-{\n-    setCoinsRet.clear();\n-    nValueRet = 0;\n-\n-    // List of values less than target\n-    boost::optional<OutputGroup> lowest_larger;\n-    std::vector<OutputGroup> applicable_groups;\n-    CAmount nTotalLower = 0;\n-\n-    random_shuffle(groups.begin(), groups.end(), GetRandInt);\n-\n-    for (const OutputGroup& group : groups) {\n-        if (group.m_value == nTargetValue) {\n-            util::insert(setCoinsRet, group.m_outputs);\n-            nValueRet += group.m_value;\n-            return true;\n-        } else if (group.m_value < nTargetValue + MIN_CHANGE) {\n-            applicable_groups.push_back(group);\n-            nTotalLower += group.m_value;\n-        } else if (!lowest_larger || group.m_value < lowest_larger->m_value) {\n-            lowest_larger = group;\n-        }\n-    }\n-\n-    if (nTotalLower == nTargetValue) {\n-        for (const auto& group : applicable_groups) {\n-            util::insert(setCoinsRet, group.m_outputs);\n-            nValueRet += group.m_value;\n-        }\n-        return true;\n-    }\n-\n-    if (nTotalLower < nTargetValue) {\n-        if (!lowest_larger) return false;\n-        util::insert(setCoinsRet, lowest_larger->m_outputs);\n-        nValueRet += lowest_larger->m_value;\n-        return true;\n-    }\n-\n-    // Solve subset sum by stochastic approximation\n-    std::sort(applicable_groups.begin(), applicable_groups.end(), descending);\n-    std::vector<char> vfBest;\n-    CAmount nBest;\n-\n-    ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue, vfBest, nBest);\n-    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE) {\n-        ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);\n-    }\n-\n-    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n-    //                                   or the next bigger coin is closer), return the bigger coin\n-    if (lowest_larger &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->m_value <= nBest)) {\n-        util::insert(setCoinsRet, lowest_larger->m_outputs);\n-        nValueRet += lowest_larger->m_value;\n-    } else {\n-        for (unsigned int i = 0; i < applicable_groups.size(); i++) {\n-            if (vfBest[i]) {\n-                util::insert(setCoinsRet, applicable_groups[i].m_outputs);\n-                nValueRet += applicable_groups[i].m_value;\n-            }\n-        }\n-\n-        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n-            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \"); /* Continued */\n-            for (unsigned int i = 0; i < applicable_groups.size(); i++) {\n-                if (vfBest[i]) {\n-                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(applicable_groups[i].m_value)); /* Continued */\n-                }\n-            }\n-            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n-        }\n-    }\n-\n-    return true;\n-}\n-\n /******************************************************************************\n \n  OutputGroup"
      },
      {
        "sha": "f091c511bd7f98b1d8c1773a14738662f1db7dbe",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=02b288f91fdbf8282cdf81f9639547c70a7b9d46",
        "patch": "@@ -95,9 +95,6 @@ struct OutputGroup\n \n bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n \n-// Original coin selection algorithm as a fallback\n-bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);\n-\n /**\n  * Randomly selects coins until the target value is exceeded. Uses effective values\n  */"
      },
      {
        "sha": "fc648a7cedebfe0cd947797c530216ab9c27ddd4",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 290,
        "changes": 290,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02b288f91fdbf8282cdf81f9639547c70a7b9d46/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=02b288f91fdbf8282cdf81f9639547c70a7b9d46",
        "patch": "@@ -240,296 +240,6 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n }\n \n-BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n-{\n-    CoinSet setCoinsRet, setCoinsRet2;\n-    CAmount nValueRet;\n-    bool bnb_used;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    // test multiple times to allow for differences in the shuffle order\n-    for (int i = 0; i < RUN_TESTS; i++)\n-    {\n-        empty_wallet();\n-\n-        // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-\n-        add_coin(1*CENT, 4);        // add a new 1 cent coin\n-\n-        // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-\n-        // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n-\n-        add_coin(2*CENT);           // add a mature 2 cent coin\n-\n-        // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-\n-        // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n-\n-        add_coin(5*CENT);           // add a mature 5 cent coin,\n-        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n-        add_coin(20*CENT);          // and a mature 20 cent coin\n-\n-        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n-\n-        // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n-        // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n-\n-        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n-\n-        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK(nValueRet == 8 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n-        empty_wallet();\n-\n-        add_coin( 6*CENT);\n-        add_coin( 7*CENT);\n-        add_coin( 8*CENT);\n-        add_coin(20*CENT);\n-        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n-\n-        // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-\n-        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n-\n-        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n-\n-        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n-\n-        // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // check that the smallest bigger coin is used\n-        add_coin( 1*COIN);\n-        add_coin( 2*COIN);\n-        add_coin( 3*COIN);\n-        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n-\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 1 / 10);\n-        add_coin(MIN_CHANGE * 2 / 10);\n-        add_coin(MIN_CHANGE * 3 / 10);\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 5 / 10);\n-\n-        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n-        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n-\n-        // but if we add a bigger coin, small change is avoided\n-        add_coin(1111*MIN_CHANGE);\n-\n-        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // if we add more small coins:\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-\n-        // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n-        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n-        empty_wallet();\n-        for (int j = 0; j < 20; j++)\n-            add_coin(50000 * COIN);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n-\n-        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n-        // we need to try finding an exact subset anyway\n-\n-        // sometimes it will fail, and so we use the next biggest coin:\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 8 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n-\n-        // test avoiding small change\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 100);\n-        add_coin(MIN_CHANGE * 1);\n-        add_coin(MIN_CHANGE * 100);\n-\n-        // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // test with many inputs\n-        for (CAmount amt=1500; amt < COIN; amt*=10) {\n-             empty_wallet();\n-             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n-             for (uint16_t j = 0; j < 676; j++)\n-                 add_coin(amt);\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-             if (amt - 2000 < MIN_CHANGE) {\n-                 // needs more than one input:\n-                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n-                 CAmount returnValue = amt * returnSize;\n-                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n-             } else {\n-                 // one input is sufficient:\n-                 BOOST_CHECK_EQUAL(nValueRet, amt);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-             }\n-        }\n-\n-        // test randomness\n-        {\n-            empty_wallet();\n-            for (int i2 = 0; i2 < 100; i2++)\n-                add_coin(COIN);\n-\n-            // picking 50 from 100 coins doesn't depend on the shuffle,\n-            // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n-            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n-\n-            int fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-\n-            // add 75 cents in small change.  not enough to make 90 cents,\n-            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n-            // one of which should be picked at random\n-            add_coin(5 * CENT);\n-            add_coin(10 * CENT);\n-            add_coin(15 * CENT);\n-            add_coin(20 * CENT);\n-            add_coin(25 * CENT);\n-\n-            fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-        }\n-    }\n-    empty_wallet();\n-}\n-\n-BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n-{\n-    CoinSet setCoinsRet;\n-    CAmount nValueRet;\n-    bool bnb_used;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    empty_wallet();\n-\n-    // Test vValue sort order\n-    for (int i = 0; i < 1000; i++)\n-        add_coin(1000 * COIN);\n-    add_coin(3 * COIN);\n-\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n-    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-    empty_wallet();\n-}\n-\n // Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n BOOST_AUTO_TEST_CASE(SelectCoins_test)\n {"
      }
    ]
  },
  {
    "sha": "33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzczN2E1YTcwMTQyOGY3YmRmN2JmZmQ1NTNlZjk4YWE2MWNkOGFi",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T05:37:36Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Have SelectCoinsMinConf figure out when to use BnB or SRD\n\nInstead of the caller telling SelectCoinsMinConf when to use BnB\nor the fallback, have SelectCoinsMinConf do it itself. This removes\nthe use_bnb field of coin_selection_params",
      "tree": {
        "sha": "6a962c2190488f9e7e3768b2630d6363dbf7ce34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a962c2190488f9e7e3768b2630d6363dbf7ce34"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "02b288f91fdbf8282cdf81f9639547c70a7b9d46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02b288f91fdbf8282cdf81f9639547c70a7b9d46",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/02b288f91fdbf8282cdf81f9639547c70a7b9d46"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 31,
      "deletions": 35
    },
    "files": [
      {
        "sha": "01f5c656c8ed50b5c2f0bde86d7899ca3c470ad0",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "patch": "@@ -44,12 +44,12 @@ static void CoinSelection(benchmark::State& state)\n     addCoin(3 * COIN, wallet, groups);\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n-    const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n+    const CoinSelectionParams coin_selection_params(34, 148, CFeeRate(0), 0);\n     while (state.KeepRunning()) {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "36ed55b273d33e7fa5f37d5a03bf7aea20b828f9",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "patch": "@@ -33,7 +33,7 @@ static CAmount balance = 0;\n CoinEligibilityFilter filter_standard(1, 6, 0);\n CoinEligibilityFilter filter_confirmed(1, 1, 0);\n CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n+CoinSelectionParams coin_selection_params(0, 0, CFeeRate(0), 0);\n \n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n@@ -230,14 +230,14 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n \n     // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n-    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0);\n+    CoinSelectionParams coin_selection_params(0, 0, CFeeRate(3000), 0);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n     bool bnb_used;\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used, true));\n }\n \n // Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n@@ -266,13 +266,13 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n \n         // Perform selection\n-        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0);\n-        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0);\n+\n+        CoinSelectionParams coin_selection_params(34, 148, CFeeRate(0), 0);\n         CoinSet out_set;\n         CAmount out_value = 0;\n         bool bnb_used = false;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params_knapsack, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "d67d4318022277d7387b394f3cc288b8b5ebdd60",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 23,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "patch": "@@ -2416,7 +2416,7 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n }\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_bnb) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -2456,9 +2456,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     // Calculate the fees for things that aren't inputs\n     CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n \n-    if (coin_selection_params.use_bnb) {\n+    // Start with BnB. If that fails, use SRD\n+    if (use_bnb && SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees)) {\n         bnb_used = true;\n-        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+        return true;\n     } else {\n         bnb_used = false;\n         return SingleRandomDraw(nTargetValue, utxo_pool, setCoinsRet, nValueRet, not_input_fees);\n@@ -2534,13 +2535,20 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n@@ -2771,9 +2779,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n             bool pick_new_inputs = true;\n             CAmount nValueIn = 0;\n \n-            // BnB selector is the only selector used when this is true.\n-            // That should only happen on the first pass through the loop.\n-            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n             // Start with no fee and loop until there is enough fee\n             while (true)\n             {\n@@ -2831,15 +2836,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n                     coin_selection_params.effective_fee = nFeeRateNeeded;\n                     if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n-                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n-                        if (bnb_used) {\n-                            coin_selection_params.use_bnb = false;\n-                            continue;\n-                        }\n-                        else {\n-                            strFailReason = _(\"Insufficient funds\");\n-                            return false;\n-                        }\n+                        strFailReason = _(\"Insufficient funds\");\n+                        return false;\n                     }\n                 }\n \n@@ -2964,7 +2962,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n \n                 // Include more fee and try again.\n                 nFeeRet = nFeeNeeded;\n-                coin_selection_params.use_bnb = false;\n                 continue;\n             }\n         }"
      },
      {
        "sha": "4029d7fe6f6cefeaeb943c2afa05dec8d9b32de3",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33737a5a701428f7bdf7bffd553ef98aa61cd8ab/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "patch": "@@ -647,13 +647,12 @@ class CAccountingEntry\n \n struct CoinSelectionParams\n {\n-    bool use_bnb = true;\n     size_t change_output_size = 0;\n     size_t change_spend_size = 0;\n     CFeeRate effective_fee = CFeeRate(0);\n     size_t tx_noinputs_size = 0;\n \n-    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size) : use_bnb(use_bnb), change_output_size(change_output_size), change_spend_size(change_spend_size), effective_fee(effective_fee), tx_noinputs_size(tx_noinputs_size) {}\n+    CoinSelectionParams(size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size) : change_output_size(change_output_size), change_spend_size(change_spend_size), effective_fee(effective_fee), tx_noinputs_size(tx_noinputs_size) {}\n     CoinSelectionParams() {}\n };\n \n@@ -860,7 +859,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * assembled\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_bnb) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n     std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin) const;"
      }
    ]
  },
  {
    "sha": "c1c24d60bc51a8f213dd13cab3a3489dd40db881",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMWMyNGQ2MGJjNTFhOGYyMTNkZDEzY2FiM2EzNDg5ZGQ0MGRiODgx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T05:43:08Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Remove the CreateTransaction loop and fee checking things\n\nWe are now using effective value for coin selection, so there is no\nneed for the loop or any of the fee checking things that were done\nwithin it. All fees ard handled by the effective value selection\n\nMove vout filling to after coins are selected so that the transaction\nfee is actually known to handle when users want to subtract the fee\nfrom the outputs.",
      "tree": {
        "sha": "414c55c784ae1985e6dbadb63ffed1638a14a4a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/414c55c784ae1985e6dbadb63ffed1638a14a4a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c1c24d60bc51a8f213dd13cab3a3489dd40db881",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c24d60bc51a8f213dd13cab3a3489dd40db881",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c1c24d60bc51a8f213dd13cab3a3489dd40db881",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c24d60bc51a8f213dd13cab3a3489dd40db881/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33737a5a701428f7bdf7bffd553ef98aa61cd8ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/33737a5a701428f7bdf7bffd553ef98aa61cd8ab"
      }
    ],
    "stats": {
      "total": 305,
      "additions": 117,
      "deletions": 188
    },
    "files": [
      {
        "sha": "26802d4c69e3fa6204ab71be3f726de6b677efcf",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c24d60bc51a8f213dd13cab3a3489dd40db881/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c24d60bc51a8f213dd13cab3a3489dd40db881/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=c1c24d60bc51a8f213dd13cab3a3489dd40db881",
        "patch": "@@ -36,6 +36,7 @@ class CInputCoin {\n     COutPoint outpoint;\n     CTxOut txout;\n     CAmount effective_value;\n+    CAmount fee;\n \n     /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n     int m_input_bytes{-1};"
      },
      {
        "sha": "f16bdc1913a2b65e96df072c0e5755f57efb7f5b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 188,
        "changes": 304,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c24d60bc51a8f213dd13cab3a3489dd40db881/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c24d60bc51a8f213dd13cab3a3489dd40db881/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=c1c24d60bc51a8f213dd13cab3a3489dd40db881",
        "patch": "@@ -2439,11 +2439,12 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         group.long_term_fee = 0;\n         group.effective_value = 0;\n         for (auto it = group.m_outputs.begin(); it != group.m_outputs.end(); ) {\n-            const CInputCoin& coin = *it;\n+            CInputCoin& coin = *it;\n             CAmount effective_value = coin.txout.nValue - (coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes));\n             // Only include outputs that are positive effective value (i.e. not dust)\n             if (effective_value > 0) {\n-                group.fee += coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n+                coin.fee = coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n+                group.fee += coin.fee;\n                 group.long_term_fee += coin.m_input_bytes < 0 ? 0 : long_term_feerate.GetFee(coin.m_input_bytes);\n                 group.effective_value += effective_value;\n                 ++it;\n@@ -2668,6 +2669,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n                          int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n {\n     CAmount nValue = 0;\n+    nFeeRet = 0;\n     int nChangePosRequest = nChangePosInOut;\n     unsigned int nSubtractFeeFromAmount = 0;\n     for (const auto& recipient : vecSend)\n@@ -2722,10 +2724,9 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n     FeeCalculation feeCalc;\n-    CAmount nFeeNeeded;\n-    int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n+        std::vector<CInputCoin> selected_coins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n@@ -2773,219 +2774,146 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n             CFeeRate discard_rate = GetDiscardRate(*this, ::feeEstimator);\n \n             // Get the fee rate to use effective values in coin selection\n-            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+            coin_selection_params.effective_fee = GetMinimumFeeRate(*this, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+                return false;\n+            }\n+\n \n-            nFeeRet = 0;\n-            bool pick_new_inputs = true;\n+            nChangePosInOut = nChangePosRequest;\n+            txNew.vin.clear();\n+            txNew.vout.clear();\n+\n+            CAmount nValueToSelect = nValue;\n+            // Calculate the size of things that aren't inputs\n+            coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            for (const auto& recipient : vecSend)\n+            {\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+                coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n+            }\n+\n+            // Choose coins to use\n+            bool bnb_used;\n             CAmount nValueIn = 0;\n+            setCoins.clear();\n+            coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n \n-            // Start with no fee and loop until there is enough fee\n-            while (true)\n+            if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n             {\n-                nChangePosInOut = nChangePosRequest;\n-                txNew.vin.clear();\n-                txNew.vout.clear();\n-                bool fFirst = true;\n-\n-                CAmount nValueToSelect = nValue;\n-                if (nSubtractFeeFromAmount == 0)\n-                    nValueToSelect += nFeeRet;\n-\n-                // vouts to the payees\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-                for (const auto& recipient : vecSend)\n-                {\n-                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+                strFailReason = _(\"Insufficient funds\");\n+                return false;\n+            }\n \n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        assert(nSubtractFeeFromAmount != 0);\n-                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n+            // Shuffle selected coins and fill in final vin\n+            txNew.vin.clear();\n+            selected_coins.clear();\n+            selected_coins.insert(selected_coins.begin(), setCoins.begin(), setCoins.end());\n+            std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+            // Note how the sequence number is set to non-maxint so that\n+            // the nLockTime set above actually works.\n+            //\n+            // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+            // we use the highest possible value in that range (maxint-2)\n+            // to avoid conflicting with other possible uses of nSequence,\n+            // and in the spirit of \"smallest possible change from prior\n+            // behavior.\"\n+            const uint32_t nSequence = coin_control.m_signal_bip125_rbf.get_value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+            for (const auto& coin : selected_coins) {\n+                txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+                nFeeRet += coin.fee;\n+            }\n \n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n-                        }\n-                    }\n-                    // Include the fee cost for outputs. Note this is only used for BnB right now\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n+            // Calculate non-input fees\n+            nFeeRet += coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n \n-                    if (IsDust(txout, ::dustRelayFee))\n-                    {\n-                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n-                        {\n-                            if (txout.nValue < 0)\n-                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n-                            else\n-                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                        }\n-                        else\n-                            strFailReason = _(\"Transaction amount too small\");\n-                        return false;\n-                    }\n-                    txNew.vout.push_back(txout);\n-                }\n+            // Calculate how large a change output's fee would be. If there is change, then we will need to include this in the fee value.\n+            // If the change is too small, this amount will also be included in the fee value.\n+            nFeeRet += coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n-                // Choose coins to use\n-                bool bnb_used;\n-                if (pick_new_inputs) {\n-                    nValueIn = 0;\n-                    setCoins.clear();\n-                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-                    coin_selection_params.effective_fee = nFeeRateNeeded;\n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n-                    {\n-                        strFailReason = _(\"Insufficient funds\");\n-                        return false;\n-                    }\n-                }\n+            // Determine if we need change and how much it will be\n+            CAmount nChange = nValueIn - nValueToSelect - (nSubtractFeeFromAmount == 0 ? nFeeRet : 0);\n+            if (nChange > 0)\n+            {\n+                // Fill a vout to ourself\n+                CTxOut newTxOut(nChange, scriptChange);\n \n-                const CAmount nChange = nValueIn - nValueToSelect;\n-                if (nChange > 0)\n+                // Never create dust outputs; if we would, just\n+                // add the dust to the fee.\n+                // The nChange when BnB is used is always going to go to fees.\n+                if (IsDust(newTxOut, discard_rate) || bnb_used)\n                 {\n-                    // Fill a vout to ourself\n-                    CTxOut newTxOut(nChange, scriptChange);\n-\n-                    // Never create dust outputs; if we would, just\n-                    // add the dust to the fee.\n-                    // The nChange when BnB is used is always going to go to fees.\n-                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n+                    nChangePosInOut = -1;\n+                    nFeeRet += nChange;\n+                }\n+                else\n+                {\n+                    if (nChangePosInOut == -1)\n                     {\n-                        nChangePosInOut = -1;\n-                        nFeeRet += nChange;\n+                        // Insert change txn at random position:\n+                        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                     }\n-                    else\n+                    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                     {\n-                        if (nChangePosInOut == -1)\n-                        {\n-                            // Insert change txn at random position:\n-                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                        }\n-                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                        {\n-                            strFailReason = _(\"Change index out of range\");\n-                            return false;\n-                        }\n-\n-                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n-                        txNew.vout.insert(position, newTxOut);\n+                        strFailReason = _(\"Change index out of range\");\n+                        return false;\n                     }\n-                } else {\n-                    nChangePosInOut = -1;\n-                }\n \n-                // Dummy fill vin for maximum size estimation\n-                //\n-                for (const auto& coin : setCoins) {\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+                    std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                    txNew.vout.insert(position, newTxOut);\n                 }\n-\n-                nBytes = CalculateMaximumSignedTxSize(txNew, this, coin_control.fAllowWatchOnly);\n-                if (nBytes < 0) {\n-                    strFailReason = _(\"Signing transaction failed\");\n-                    return false;\n+            } else {\n+                // The change value is negative or zero here, so subtract the negative value from nFeeRet because currently it is larger than it should be.\n+                nFeeRet += nChange;\n+                nChangePosInOut = -1;\n+\n+                if (nSubtractFeeFromAmount != 0) {\n+                    // If we are subtracting the fee from the amount, nChange cannot be less than 0 because nFeeRet is not involved.\n+                    // We need to decrease nFeeRet by the change output fee so that we do not overpay.\n+                    nFeeRet -= coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n                 }\n+            }\n \n-                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n-                if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                    // eventually allow a fallback fee\n-                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                    return false;\n-                }\n+            // Fill vout\n+            bool first_output = true;\n+            for (const auto& recipient : vecSend)\n+            {\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n-                // because we must be at the maximum allowed fee.\n-                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))\n+                if (recipient.fSubtractFeeFromAmount)\n                 {\n-                    strFailReason = _(\"Transaction too large for fee policy\");\n-                    return false;\n-                }\n-\n-                if (nFeeRet >= nFeeNeeded) {\n-                    // Reduce fee to only the needed amount if possible. This\n-                    // prevents potential overpayment in fees if the coins\n-                    // selected to meet nFeeNeeded result in a transaction that\n-                    // requires less fee than the prior iteration.\n-\n-                    // If we have no change and a big enough excess fee, then\n-                    // try to construct transaction again only without picking\n-                    // new inputs. We now know we only need the smaller fee\n-                    // (because of reduced tx size) and so we should add a\n-                    // change output. Only try this once.\n-                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n-                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n-                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n-                            pick_new_inputs = false;\n-                            nFeeRet = fee_needed_with_change;\n-                            continue;\n-                        }\n-                    }\n+                    assert(nSubtractFeeFromAmount != 0);\n+                    txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n \n-                    // If we have change output already, just increase it\n-                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                        change_position->nValue += extraFeePaid;\n-                        nFeeRet -= extraFeePaid;\n+                    if (first_output) // first receiver pays the remainder not divisible by output count\n+                    {\n+                        first_output = false;\n+                        txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                     }\n-                    break; // Done, enough fee included.\n-                }\n-                else if (!pick_new_inputs) {\n-                    // This shouldn't happen, we should have had enough excess\n-                    // fee to pay for the new output and still meet nFeeNeeded\n-                    // Or we should have just subtracted fee from recipients and\n-                    // nFeeNeeded should not have changed\n-                    strFailReason = _(\"Transaction fee and change calculation failed\");\n-                    return false;\n                 }\n \n-                // Try to reduce change to include necessary fee\n-                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n-                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                    // Only reduce change if remaining amount is still a large enough output.\n-                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n-                        change_position->nValue -= additionalFeeNeeded;\n-                        nFeeRet += additionalFeeNeeded;\n-                        break; // Done, able to increase fee from change\n+                if (IsDust(txout, ::dustRelayFee))\n+                {\n+                    if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n+                    {\n+                        if (txout.nValue < 0)\n+                            strFailReason = _(\"The transaction amount is too small to pay the fee\");\n+                        else\n+                            strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                     }\n+                    else\n+                        strFailReason = _(\"Transaction amount too small\");\n+                    return false;\n                 }\n-\n-                // If subtracting fee from recipients, we now know what fee we\n-                // need to subtract, we have no reason to reselect inputs\n-                if (nSubtractFeeFromAmount > 0) {\n-                    pick_new_inputs = false;\n-                }\n-\n-                // Include more fee and try again.\n-                nFeeRet = nFeeNeeded;\n-                continue;\n+                txNew.vout.push_back(txout);\n             }\n         }\n \n         if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n \n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.get_value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n-\n         if (sign)\n         {\n             int nIn = 0;\n@@ -3034,8 +2962,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n         }\n     }\n \n-    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n-              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n+    WalletLogPrintf(\"Fee Calculation: Fee:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+              nFeeRet, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n               feeCalc.est.pass.start, feeCalc.est.pass.end,\n               100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n               feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,"
      }
    ]
  },
  {
    "sha": "ae9a8e19f23cc250609be675f0148fa5ff0e6623",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZTlhOGUxOWYyM2NjMjUwNjA5YmU2NzVmMDE0OGZhNWZmMGU2NjIz",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T17:12:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Don't use effective values when we are subtracting the fee from the amount",
      "tree": {
        "sha": "7d5b3eb350cf387a1f97c4d82604633e7aabf890",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d5b3eb350cf387a1f97c4d82604633e7aabf890"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae9a8e19f23cc250609be675f0148fa5ff0e6623",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae9a8e19f23cc250609be675f0148fa5ff0e6623",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae9a8e19f23cc250609be675f0148fa5ff0e6623",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae9a8e19f23cc250609be675f0148fa5ff0e6623/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c1c24d60bc51a8f213dd13cab3a3489dd40db881",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c24d60bc51a8f213dd13cab3a3489dd40db881",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c1c24d60bc51a8f213dd13cab3a3489dd40db881"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 29,
      "deletions": 26
    },
    "files": [
      {
        "sha": "13a1ca4c133994352530e75b7d80d807333821d3",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "patch": "@@ -49,7 +49,7 @@ static void CoinSelection(benchmark::State& state)\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true, true);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "d81a118e33b080a8510671fd576111e813fd3bfe",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "patch": "@@ -237,7 +237,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used, true));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard,  GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used, true, true));\n }\n \n // Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n@@ -271,8 +271,8 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CoinSet out_set;\n         CAmount out_value = 0;\n         bool bnb_used = false;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard,  GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true, true) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard,  GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true, true));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "52ff5baa56e2e0c492f8a0f5f6099ffbafa2468b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 20,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "patch": "@@ -2416,7 +2416,8 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n }\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_bnb) const\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params,\n+                                 bool& bnb_used, bool use_effective, bool use_bnb) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -2440,7 +2441,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         group.effective_value = 0;\n         for (auto it = group.m_outputs.begin(); it != group.m_outputs.end(); ) {\n             CInputCoin& coin = *it;\n-            CAmount effective_value = coin.txout.nValue - (coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes));\n+            CAmount effective_value = coin.txout.nValue - ((coin.m_input_bytes < 0 || !use_effective) ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes));\n             // Only include outputs that are positive effective value (i.e. not dust)\n             if (effective_value > 0) {\n                 coin.fee = coin.m_input_bytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(coin.m_input_bytes);\n@@ -2455,7 +2456,8 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         if (group.effective_value > 0) utxo_pool.push_back(group);\n     }\n     // Calculate the fees for things that aren't inputs\n-    CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+    // The only situation we are not using effective values is when we are subtracting the fee from the outputs, so don't calculate not_input_fees in that case\n+    CAmount not_input_fees = use_effective ? coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size) : 0;\n \n     // Start with BnB. If that fails, use SRD\n     if (use_bnb && SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees)) {\n@@ -2467,7 +2469,9 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     }\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet,\n+                        CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params,\n+                        bool& bnb_used, bool use_effective) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n@@ -2536,20 +2540,20 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true)) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, false));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n@@ -2800,8 +2804,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n             CAmount nValueIn = 0;\n             setCoins.clear();\n             coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-\n-            if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n+            if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used, nSubtractFeeFromAmount == 0))\n             {\n                 strFailReason = _(\"Insufficient funds\");\n                 return false;"
      },
      {
        "sha": "fd9e4d08c710e03d1fbed772ff92b78e657fa9b0",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae9a8e19f23cc250609be675f0148fa5ff0e6623/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "patch": "@@ -676,7 +676,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * if they are not ours\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_effective = true) const;\n \n     WalletBatch *encrypted_batch = nullptr;\n \n@@ -859,7 +859,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * assembled\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_bnb) const;\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_effective, bool use_bnb) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n     std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin) const;"
      }
    ]
  },
  {
    "sha": "8ecb6340d6829c98da32f429414badd17cccf337",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZWNiNjM0MGQ2ODI5Yzk4ZGEzMmY0Mjk0MTRiYWRkMTdjY2NmMzM3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-15T21:05:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Remove bnb_used\n\nbnb_used is no longer necessary since we account for fees when\ncalculating how much change there is",
      "tree": {
        "sha": "0bd0b7f46602ced2f67f5b71500c3afecbd17d95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0bd0b7f46602ced2f67f5b71500c3afecbd17d95"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ecb6340d6829c98da32f429414badd17cccf337",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ecb6340d6829c98da32f429414badd17cccf337",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8ecb6340d6829c98da32f429414badd17cccf337",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ecb6340d6829c98da32f429414badd17cccf337/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae9a8e19f23cc250609be675f0148fa5ff0e6623",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae9a8e19f23cc250609be675f0148fa5ff0e6623"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 27,
      "deletions": 39
    },
    "files": [
      {
        "sha": "af0b770207b28ec638cda52531ea459d81d4e813",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ecb6340d6829c98da32f429414badd17cccf337/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ecb6340d6829c98da32f429414badd17cccf337/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=8ecb6340d6829c98da32f429414badd17cccf337",
        "patch": "@@ -48,8 +48,8 @@ static void CoinSelection(benchmark::State& state)\n     while (state.KeepRunning()) {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool bnb_used;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, true, true);\n+\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, true, true);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "aa80b61c03c91f38bde214afce1b1738e19bc3d2",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=8ecb6340d6829c98da32f429414badd17cccf337",
        "patch": "@@ -233,11 +233,10 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     CoinSelectionParams coin_selection_params(0, 0, CFeeRate(3000), 0);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n-    bool bnb_used;\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard,  GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used, true, true));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, true, true));\n }\n \n // Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n@@ -270,9 +269,8 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CoinSelectionParams coin_selection_params(34, 148, CFeeRate(0), 0);\n         CoinSet out_set;\n         CAmount out_value = 0;\n-        bool bnb_used = false;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard,  GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true, true) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard,  GroupCoins(vCoins), out_set, out_value, coin_selection_params, bnb_used, true, true));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, true, true) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params, true, true));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "e764534bd7d0ec351987520446c74de5128c4142",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 30,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=8ecb6340d6829c98da32f429414badd17cccf337",
        "patch": "@@ -2417,7 +2417,7 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n                                  std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params,\n-                                 bool& bnb_used, bool use_effective, bool use_bnb) const\n+                                 bool use_effective, bool use_bnb) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -2460,27 +2460,22 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     CAmount not_input_fees = use_effective ? coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size) : 0;\n \n     // Start with BnB. If that fails, use SRD\n-    if (use_bnb && SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees)) {\n-        bnb_used = true;\n-        return true;\n+    if (use_bnb) {\n+        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        bnb_used = false;\n         return SingleRandomDraw(nTargetValue, utxo_pool, setCoinsRet, nValueRet, not_input_fees);\n     }\n }\n \n bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet,\n                         CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params,\n-                        bool& bnb_used, bool use_effective) const\n+                        bool use_effective) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n     if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n     {\n-        // We didn't use BnB here, so set it to false.\n-        bnb_used = false;\n-\n         for (const COutput& out : vCoins)\n         {\n             if (!out.fSpendable)\n@@ -2499,9 +2494,6 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     coin_control.ListSelected(vPresetInputs);\n     for (const COutPoint& outpoint : vPresetInputs)\n     {\n-        // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n-        bnb_used = false;\n-\n         std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n         {\n@@ -2540,20 +2532,20 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, true)) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used, use_effective, false));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n@@ -2800,11 +2792,10 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n             }\n \n             // Choose coins to use\n-            bool bnb_used;\n             CAmount nValueIn = 0;\n             setCoins.clear();\n             coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used, nSubtractFeeFromAmount == 0))\n+            if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, nSubtractFeeFromAmount == 0))\n             {\n                 strFailReason = _(\"Insufficient funds\");\n                 return false;\n@@ -2846,8 +2837,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n \n                 // Never create dust outputs; if we would, just\n                 // add the dust to the fee.\n-                // The nChange when BnB is used is always going to go to fees.\n-                if (IsDust(newTxOut, discard_rate) || bnb_used)\n+                if (IsDust(newTxOut, discard_rate))\n                 {\n                     nChangePosInOut = -1;\n                     nFeeRet += nChange;"
      },
      {
        "sha": "a997a06ac0baf6b5b1cfcaf0eb76d9f7e84306cc",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ecb6340d6829c98da32f429414badd17cccf337/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=8ecb6340d6829c98da32f429414badd17cccf337",
        "patch": "@@ -676,7 +676,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * if they are not ours\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_effective = true) const;\n+                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool use_effective = true) const;\n \n     WalletBatch *encrypted_batch = nullptr;\n \n@@ -859,7 +859,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * assembled\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used, bool use_effective, bool use_bnb) const;\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool use_effective, bool use_bnb) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n     std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin) const;"
      }
    ]
  },
  {
    "sha": "6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OTg5YjlkZjgxMDI3M2RiNmE1M2NjMGViYWM1YzBhZTRmNTU0YmYx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-04-13T02:30:14Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "handle preset inputs\n\nFor preset inputs, use their effective values",
      "tree": {
        "sha": "39f4ce50124aeea693a2cb4f9dffa0114175d54e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/39f4ce50124aeea693a2cb4f9dffa0114175d54e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6989b9df810273db6a53cc0ebac5c0ae4f554bf1/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ecb6340d6829c98da32f429414badd17cccf337",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ecb6340d6829c98da32f429414badd17cccf337",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ecb6340d6829c98da32f429414badd17cccf337"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 32,
      "deletions": 24
    },
    "files": [
      {
        "sha": "212c4a5004211ab69639ee53ecdadbbce06a8f51",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6989b9df810273db6a53cc0ebac5c0ae4f554bf1/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6989b9df810273db6a53cc0ebac5c0ae4f554bf1/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
        "patch": "@@ -35,8 +35,8 @@ class CInputCoin {\n \n     COutPoint outpoint;\n     CTxOut txout;\n-    CAmount effective_value;\n-    CAmount fee;\n+    mutable CAmount effective_value;\n+    mutable CAmount fee;\n \n     /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n     int m_input_bytes{-1};"
      },
      {
        "sha": "9c5222a2c176600162711518f292c4f2a32f7037",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 22,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6989b9df810273db6a53cc0ebac5c0ae4f554bf1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6989b9df810273db6a53cc0ebac5c0ae4f554bf1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
        "patch": "@@ -2318,7 +2318,7 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n             if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                 continue;\n \n-            if (IsLockedCoin(entry.first, i))\n+            if (IsLockedCoin(entry.first, i) && (!coinControl || !coinControl->IsSelected(COutPoint(entry.first, i))))\n                 continue;\n \n             if (IsSpent(wtxid, i))\n@@ -2481,14 +2481,18 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(out.GetInputCoin());\n+            CInputCoin coin = out.GetInputCoin();\n+            coin.effective_value = coin.txout.nValue - ((out.nInputBytes < 0 || !use_effective) ? 0 : coin_selection_params.effective_fee.GetFee(out.nInputBytes));\n+            coin.fee = out.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(out.nInputBytes);\n+            setCoinsRet.insert(coin);\n         }\n         return (nValueRet >= nTargetValue);\n     }\n \n     // calculate value from preset inputs and store them\n     std::set<CInputCoin> setPresetCoins;\n     CAmount nValueFromPresetInputs = 0;\n+    CAmount effective_value_from_presets = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n     coin_control.ListSelected(vPresetInputs);\n@@ -2501,20 +2505,24 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             // Clearly invalid input, fail\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n-            // Just to calculate the marginal byte size\n-            nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n             setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n-    // remove preset inputs from vCoins\n+    // remove preset inputs from vCoins and set fee and effective value for preset coin\n     for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n-        if (setPresetCoins.count(it->GetInputCoin()))\n+        auto preset_it = setPresetCoins.find(it->GetInputCoin());\n+        if (preset_it != setPresetCoins.end()) {\n+            preset_it->fee = it->nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(it->nInputBytes);\n+            preset_it->effective_value = preset_it->txout.nValue - (use_effective ? preset_it->fee : 0);\n+            nValueFromPresetInputs += preset_it->txout.nValue;\n+            effective_value_from_presets += preset_it->effective_value;\n             it = vCoins.erase(it);\n-        else\n+        } else {\n             ++it;\n+        }\n     }\n \n     // form groups from remaining coins; note that preset coins will not\n@@ -2531,21 +2539,21 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     size_t max_descendants = (size_t)std::max<int64_t>(1, gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT));\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n-    bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false));\n+    bool res = (nTargetValue <= effective_value_from_presets && !vPresetInputs.empty()) ||\n+        SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n+        SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, true)) ||\n+        SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n+        SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - effective_value_from_presets, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, use_effective, false));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);"
      }
    ]
  },
  {
    "sha": "e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzkwM2YzYWE1Yzk0YzBkMTJhMWEyNmNlYTgzMmQ1ZGY4NGRjNDY5",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-04-13T05:03:14Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:20Z"
      },
      "message": "Split change output creation from fee calculation for change",
      "tree": {
        "sha": "85b3e27c1d886d899e40a50d3e149909c8b750fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/85b3e27c1d886d899e40a50d3e149909c8b750fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3903f3aa5c94c0d12a1a26cea832d5df84dc469/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6989b9df810273db6a53cc0ebac5c0ae4f554bf1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6989b9df810273db6a53cc0ebac5c0ae4f554bf1"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 21,
      "deletions": 19
    },
    "files": [
      {
        "sha": "4fe47079a2483b69d9578a9448b0bfbf646593b6",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 19,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3903f3aa5c94c0d12a1a26cea832d5df84dc469/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3903f3aa5c94c0d12a1a26cea832d5df84dc469/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
        "patch": "@@ -2840,31 +2840,14 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n             CAmount nChange = nValueIn - nValueToSelect - (nSubtractFeeFromAmount == 0 ? nFeeRet : 0);\n             if (nChange > 0)\n             {\n-                // Fill a vout to ourself\n-                CTxOut newTxOut(nChange, scriptChange);\n-\n                 // Never create dust outputs; if we would, just\n                 // add the dust to the fee.\n+                CTxOut newTxOut(nChange, scriptChange);\n                 if (IsDust(newTxOut, discard_rate))\n                 {\n                     nChangePosInOut = -1;\n                     nFeeRet += nChange;\n-                }\n-                else\n-                {\n-                    if (nChangePosInOut == -1)\n-                    {\n-                        // Insert change txn at random position:\n-                        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                    }\n-                    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                    {\n-                        strFailReason = _(\"Change index out of range\");\n-                        return false;\n-                    }\n-\n-                    std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n-                    txNew.vout.insert(position, newTxOut);\n+                    nChange = 0;\n                 }\n             } else {\n                 // The change value is negative or zero here, so subtract the negative value from nFeeRet because currently it is larger than it should be.\n@@ -2911,6 +2894,25 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n                 }\n                 txNew.vout.push_back(txout);\n             }\n+\n+            // Fill change output\n+            if (nChange > 0) {\n+                // Fill a vout to ourself\n+                CTxOut newTxOut(nChange, scriptChange);\n+                if (nChangePosInOut == -1)\n+                {\n+                    // Insert change txn at random position:\n+                    nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+                }\n+                else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+                {\n+                    strFailReason = _(\"Change index out of range\");\n+                    return false;\n+                }\n+\n+                std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                txNew.vout.insert(position, newTxOut);\n+            }\n         }\n \n         if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change"
      }
    ]
  },
  {
    "sha": "339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzlkOTc3ZmJkZGEwZmRkMWNmZDhlNTZmMGJkYzdhMzM3MTJiZDVj",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-05-23T03:07:02Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-08-17T21:14:24Z"
      },
      "message": "Make tests work with non-deterministic coin selection\n\nFix tests that relied on non-deterministic coin selection to be able\nto handle the random coin selection.",
      "tree": {
        "sha": "6911b5312c57e9275b2f154f68fefba3276dc0ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6911b5312c57e9275b2f154f68fefba3276dc0ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3903f3aa5c94c0d12a1a26cea832d5df84dc469",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3903f3aa5c94c0d12a1a26cea832d5df84dc469"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 82,
      "deletions": 36
    },
    "files": [
      {
        "sha": "95d9fb31ffabcac403ddb3f49337aea3d043867f",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -99,7 +99,7 @@ def set_test_params(self):\n         self.num_nodes = 2\n         # This test was written assuming SegWit is activated using BIP9 at height 432 (3x confirmation window).\n         # TODO: Rewrite this test to support SegWit being always active.\n-        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\", \"-deprecatedrpc=addwitnessaddress\", \"-changetype=legacy\"]]\n         self.utxos = []\n \n     def build_block_on_tip(self, node, segwit=False):\n@@ -258,7 +258,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Generate a bunch of transactions.\n         node.generate(101)\n         num_transactions = 25\n-        address = node.getnewaddress()\n+        address = node.getnewaddress(address_type='legacy')\n         if use_witness_address:\n             # Want at least one segwit spend, so move all funds to\n             # a witness address."
      },
      {
        "sha": "7dd283a082c93c2374c9abf227f0dae0615a5806",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 16,
        "deletions": 14,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -72,8 +72,6 @@ def run_test(self):\n         watchonly_vout = find_vout_for_address(self.nodes[0], watchonly_txid, watchonly_address)\n         self.nodes[0].lockunspent(False, [{\"txid\": watchonly_txid, \"vout\": watchonly_vout}])\n \n-        self.nodes[0].sendtoaddress(self.nodes[3].getnewaddress(), watchonly_amount / 10)\n-\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.5)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 5.0)\n@@ -356,10 +354,10 @@ def run_test(self):\n \n         #create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1.1)\n-        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+        mempool_tx = self.nodes[0].getrawmempool(True)[txId]\n \n-        #compare fee\n-        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n+        #compare feerates\n+        feeDelta = (Decimal(fundedTx['fee']) / Decimal(len(fundedTx['hex']) / 2)) - (Decimal(mempool_tx['fee']) / mempool_tx['size'])\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n@@ -371,10 +369,10 @@ def run_test(self):\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n         #create same transaction over sendtoaddress\n         txId = self.nodes[0].sendmany(\"\", outputs)\n-        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+        mempool_tx = self.nodes[0].getrawmempool(True)[txId]\n \n-        #compare fee\n-        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n+        #compare feerates\n+        feeDelta = (Decimal(fundedTx['fee']) / Decimal(len(fundedTx['hex']) / 2)) - (Decimal(mempool_tx['fee']) / mempool_tx['size'])\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n@@ -398,10 +396,10 @@ def run_test(self):\n \n         #create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.1)\n-        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+        mempool_tx = self.nodes[0].getrawmempool(True)[txId]\n \n-        #compare fee\n-        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n+        #compare feerates\n+        feeDelta = (Decimal(fundedTx['fee']) / Decimal(len(fundedTx['hex']) / 2)) - (Decimal(mempool_tx['fee']) / mempool_tx['size'])\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n@@ -431,10 +429,10 @@ def run_test(self):\n \n         #create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.1)\n-        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+        mempool_tx = self.nodes[0].getrawmempool(True)[txId]\n \n-        #compare fee\n-        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n+        #compare feerates\n+        feeDelta = (Decimal(fundedTx['fee']) / Decimal(len(fundedTx['hex']) / 2)) - (Decimal(mempool_tx['fee']) / mempool_tx['size'])\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n@@ -626,6 +624,10 @@ def run_test(self):\n         # test fundrawtransaction using the entirety of watched funds #\n         ###############################################################\n \n+        self.nodes[0].sendtoaddress(self.nodes[3].getnewaddress(), watchonly_amount / 10)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n         inputs = []\n         outputs = {self.nodes[2].getnewaddress() : watchonly_amount}\n         rawtx = self.nodes[3].createrawtransaction(inputs, outputs)"
      },
      {
        "sha": "5dc22fb422cf06792298f535c9998562ce6644fa",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -38,6 +38,9 @@ def run_test(self):\n         p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n         p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n         p2sh_p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"p2sh-segwit\")['address']\n+        self.nodes[1].importaddress(p2sh)\n+        self.nodes[1].importaddress(p2wsh)\n+        self.nodes[1].importaddress(p2sh_p2wsh)\n         p2wpkh = self.nodes[1].getnewaddress(\"\", \"bech32\")\n         p2pkh = self.nodes[1].getnewaddress(\"\", \"legacy\")\n         p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n@@ -101,7 +104,7 @@ def run_test(self):\n \n         # Make sure that a psbt with signatures cannot be converted\n         signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])\n-        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].converttopsbt, signedtx['hex'])\n+        assert_raises_rpc_error(-22, None, self.nodes[0].converttopsbt, signedtx['hex'])\n \n         # Explicilty allow converting non-empty txs\n         new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])"
      },
      {
        "sha": "2b3518ff7a4b080043e7f350b471c85fcb15c9b6",
        "filename": "test/functional/rpc_scantxoutset.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_scantxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/rpc_scantxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_scantxoutset.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -12,18 +12,18 @@\n \n class ScantxoutsetTest(BitcoinTestFramework):\n     def set_test_params(self):\n-        self.num_nodes = 1\n+        self.num_nodes = 2\n         self.setup_clean_chain = True\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(110)\n \n-        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n-        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n-        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n-        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n-        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n-        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        addr_P2SH_SEGWIT = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[1].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[1].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[1].getaddressinfo(addr_BECH32)['pubkey']\n         self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 0.001)\n         self.nodes[0].sendtoaddress(addr_LEGACY, 0.002)\n         self.nodes[0].sendtoaddress(addr_BECH32, 0.004)"
      },
      {
        "sha": "2fc3ad275ecbdd4242e61035e03b09a5a4ef9db2",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -10,11 +10,17 @@\n     assert_equal,\n )\n \n-def assert_approx(v, vexp, vspan=0.00001):\n+def is_approx(v, vexp, vspan=0.00001):\n     if v < vexp - vspan:\n-        raise AssertionError(\"%s < [%s..%s]\" % (str(v), str(vexp - vspan), str(vexp + vspan)))\n+        return (False, (\"%s < [%s..%s]\" % (str(v), str(vexp - vspan), str(vexp + vspan))))\n     if v > vexp + vspan:\n-        raise AssertionError(\"%s > [%s..%s]\" % (str(v), str(vexp - vspan), str(vexp + vspan)))\n+        return (False, (\"%s > [%s..%s]\" % (str(v), str(vexp - vspan), str(vexp + vspan))))\n+    return (True, \"\")\n+\n+def assert_approx(v, vexp, vspan=0.00001):\n+    res = is_approx(v, vexp, vspan)\n+    if not res[0]:\n+        raise AssertionError(res[1])\n \n class WalletGroupTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -40,19 +46,19 @@ def run_test (self):\n         self.sync_all()\n \n         # For each node, send 0.2 coins back to 0;\n-        # - node[1] should pick one 0.5 UTXO and leave the rest\n+        # - node[1] should pick one 0.5 UTXO or one 1.0 UTXO and leave the rest\n         # - node[2] should pick one (1.0 + 0.5) UTXO group corresponding to a\n         #   given address, and leave the rest\n         txid1 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n         tx1 = self.nodes[1].getrawtransaction(txid1, True)\n         # txid1 should have 1 input and 2 outputs\n         assert_equal(1, len(tx1[\"vin\"]))\n         assert_equal(2, len(tx1[\"vout\"]))\n-        # one output should be 0.2, the other should be ~0.3\n+        # one output should be 0.2, the other should be ~0.3 or ~0.8\n         v = [vout[\"value\"] for vout in tx1[\"vout\"]]\n         v.sort()\n         assert_approx(v[0], 0.2)\n-        assert_approx(v[1], 0.3, 0.0001)\n+        assert is_approx(v[1], 0.3, 0.0001) or is_approx(v[1], 0.8, 0.0001)\n \n         txid2 = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n         tx2 = self.nodes[2].getrawtransaction(txid2, True)"
      },
      {
        "sha": "d49cf9ec697ec6ab66bf1933fc12bfc78f9fda64",
        "filename": "test/functional/wallet_importprunedfunds.py",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importprunedfunds.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -9,6 +9,7 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n+    find_vout_for_address,\n )\n \n class ImportPrunedFundsTest(BitcoinTestFramework):\n@@ -57,16 +58,22 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         rawtxn1 = self.nodes[0].gettransaction(txnid1)['hex']\n         proof1 = self.nodes[0].gettxoutproof([txnid1])\n+        vout1 = find_vout_for_address(self.nodes[0], txnid1, address1)\n+        self.nodes[0].lockunspent(False, [{\"txid\" : txnid1, \"vout\" : vout1}])\n \n         txnid2 = self.nodes[0].sendtoaddress(address2, 0.05)\n         self.nodes[0].generate(1)\n         rawtxn2 = self.nodes[0].gettransaction(txnid2)['hex']\n         proof2 = self.nodes[0].gettxoutproof([txnid2])\n+        vout2 = find_vout_for_address(self.nodes[0], txnid2, address2)\n+        self.nodes[0].lockunspent(False, [{\"txid\" : txnid2, \"vout\" : vout2}])\n \n         txnid3 = self.nodes[0].sendtoaddress(address3, 0.025)\n         self.nodes[0].generate(1)\n         rawtxn3 = self.nodes[0].gettransaction(txnid3)['hex']\n         proof3 = self.nodes[0].gettxoutproof([txnid3])\n+        vout3 = find_vout_for_address(self.nodes[0], txnid3, address3)\n+        self.nodes[0].lockunspent(False, [{\"txid\" : txnid3, \"vout\" : vout3}])\n \n         self.sync_all()\n "
      },
      {
        "sha": "dd4a38d7539e96cb7555958cdb56a3f7984d0010",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -9,6 +9,7 @@\n     assert_equal,\n     connect_nodes,\n     disconnect_nodes,\n+    find_output,\n     sync_blocks,\n )\n \n@@ -46,25 +47,46 @@ def run_test(self):\n         node0_txid1 = self.nodes[0].sendtoaddress(node0_address1, 1219)\n         node0_tx1 = self.nodes[0].gettransaction(node0_txid1)\n \n+        # lock node0_tx1 output to prevent node0_tx2 from spending it\n+        self.nodes[0].lockunspent(False, [{'txid' : node0_txid1, 'vout' : find_output(self.nodes[0], node0_txid1, 1219)}])\n+\n         node0_address2 = self.nodes[0].getnewaddress(address_type=output_type)\n         node0_txid2 = self.nodes[0].sendtoaddress(node0_address2, 29)\n         node0_tx2 = self.nodes[0].gettransaction(node0_txid2)\n+        self.nodes[0].lockunspent(True)\n \n         assert_equal(self.nodes[0].getbalance(),\n                      starting_balance + node0_tx1[\"fee\"] + node0_tx2[\"fee\"])\n \n         # Coins are sent to node1_address\n         node1_address = self.nodes[1].getnewaddress()\n \n+        # Lock the outputs for node0_tx2 to avoid having that as a parent for tx1\n+        to_lock = []\n+        for vout in self.nodes[0].decoderawtransaction(node0_tx2['hex'])['vout']:\n+            to_lock.append({'txid' : node0_txid2, 'vout' : vout['n']})\n+        self.nodes[0].lockunspent(False, to_lock)\n+\n         # Send tx1, and another transaction tx2 that won't be cloned\n         txid1 = self.nodes[0].sendtoaddress(node1_address, 40)\n+        self.nodes[0].lockunspent(True) # Unlock locked outputs\n+\n+        # Lock the outputs for tx1 to avoid having that as a parent for tx2\n+        to_lock = []\n+        for vout in self.nodes[0].decoderawtransaction(self.nodes[0].getrawtransaction(txid1))['vout']:\n+            to_lock.append({'txid' : txid1, 'vout' : vout['n']})\n+        self.nodes[0].lockunspent(False, to_lock)\n         txid2 = self.nodes[0].sendtoaddress(node1_address, 20)\n+        self.nodes[0].lockunspent(True)\n \n         # Construct a clone of tx1, to be malleated\n         rawtx1 = self.nodes[0].getrawtransaction(txid1, 1)\n-        clone_inputs = [{\"txid\": rawtx1[\"vin\"][0][\"txid\"], \"vout\": rawtx1[\"vin\"][0][\"vout\"]}]\n-        clone_outputs = {rawtx1[\"vout\"][0][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][0][\"value\"],\n-                         rawtx1[\"vout\"][1][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][1][\"value\"]}\n+        clone_inputs = []\n+        for vin in rawtx1['vin']:\n+            clone_inputs.append({\"txid\": vin[\"txid\"], \"vout\": vin[\"vout\"]})\n+        clone_outputs = {}\n+        for vout in rawtx1['vout']:\n+            clone_outputs[vout[\"scriptPubKey\"][\"addresses\"][0]] = vout['value']\n         clone_locktime = rawtx1[\"locktime\"]\n         clone_raw = self.nodes[0].createrawtransaction(clone_inputs, clone_outputs, clone_locktime)\n \n@@ -108,8 +130,9 @@ def run_test(self):\n             assert_equal(tx1[\"confirmations\"], 0)\n             assert_equal(tx2[\"confirmations\"], 0)\n \n-        # Send clone and its parent to miner\n-        self.nodes[2].sendrawtransaction(node0_tx1[\"hex\"])\n+        # Send clone and its parents to miner\n+        for vin in rawtx1['vin']:\n+            self.nodes[2].sendrawtransaction(self.nodes[0].getrawtransaction(vin['txid']))\n         txid1_clone = self.nodes[2].sendrawtransaction(tx1_clone[\"hex\"])\n         if self.options.segwit:\n             assert_equal(txid1, txid1_clone)\n@@ -120,7 +143,8 @@ def run_test(self):\n \n         # Reconnect the split network, and sync chain:\n         connect_nodes(self.nodes[1], 2)\n-        self.nodes[2].sendrawtransaction(node0_tx2[\"hex\"])\n+        for vin in self.nodes[0].decoderawtransaction(tx2['hex'])['vin']:\n+            self.nodes[2].sendrawtransaction(self.nodes[0].getrawtransaction(vin['txid']))\n         self.nodes[2].sendrawtransaction(tx2[\"hex\"])\n         self.nodes[2].generate(1)  # Mine another block to make sure we sync\n         sync_blocks(self.nodes)"
      },
      {
        "sha": "836c3422730cbe7842633082a851ad836acfe705",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=339d977fbdda0fdd1cfd8e56f0bdc7a33712bd5c",
        "patch": "@@ -40,9 +40,13 @@ def run_test(self):\n         fund_foo_txid = self.nodes[0].sendtoaddress(node0_address_foo, 1219)\n         fund_foo_tx = self.nodes[0].gettransaction(fund_foo_txid)\n \n+        # lock fund_foo_tx output to prevent fund_bar_tx from spending it\n+        self.nodes[0].lockunspent(False, [{'txid' : fund_foo_txid, 'vout' : find_output(self.nodes[0], fund_foo_txid, 1219)}])\n+\n         node0_address_bar = self.nodes[0].getnewaddress()\n         fund_bar_txid = self.nodes[0].sendtoaddress(node0_address_bar, 29)\n         fund_bar_tx = self.nodes[0].gettransaction(fund_bar_txid)\n+        self.nodes[0].lockunspent(True)\n \n         assert_equal(self.nodes[0].getbalance(),\n                      starting_balance + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"])"
      }
    ]
  }
]