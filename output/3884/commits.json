[
  {
    "sha": "f457347053029d6a0248036a1ffeb7127108fd6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDU3MzQ3MDUzMDI5ZDZhMDI0ODAzNmExZmZlYjcxMjcxMDhmZDZk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-03-11T16:36:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-04-24T22:33:13Z"
      },
      "message": "Split up CheckBlock in a block and header version",
      "tree": {
        "sha": "ba7f669bed780bf241f58e03c3e523ef51123f24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba7f669bed780bf241f58e03c3e523ef51123f24"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f457347053029d6a0248036a1ffeb7127108fd6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f457347053029d6a0248036a1ffeb7127108fd6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f457347053029d6a0248036a1ffeb7127108fd6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f457347053029d6a0248036a1ffeb7127108fd6d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4765b8c11679aeb76efd9ce907a5c17661d4b018",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4765b8c11679aeb76efd9ce907a5c17661d4b018",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4765b8c11679aeb76efd9ce907a5c17661d4b018"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 18,
      "deletions": 9
    },
    "files": [
      {
        "sha": "66800cc2245274995ff56c6da7690e9f28cdb5be",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f457347053029d6a0248036a1ffeb7127108fd6d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f457347053029d6a0248036a1ffeb7127108fd6d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f457347053029d6a0248036a1ffeb7127108fd6d",
        "patch": "@@ -2288,16 +2288,8 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n }\n \n \n-bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)\n+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW)\n {\n-    // These are checks that are independent of context\n-    // that can be verified before saving an orphan block.\n-\n-    // Size limits\n-    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n-                         REJECT_INVALID, \"bad-blk-length\");\n-\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits))\n         return state.DoS(50, error(\"CheckBlock() : proof of work failed\"),\n@@ -2308,6 +2300,22 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         return state.Invalid(error(\"CheckBlock() : block timestamp too far in the future\"),\n                              REJECT_INVALID, \"time-too-new\");\n \n+    return true;\n+}\n+\n+bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)\n+{\n+    // These are checks that are independent of context\n+    // that can be verified before saving an orphan block.\n+\n+    if (!CheckBlockHeader(block, state, fCheckPOW))\n+        return false;\n+\n+    // Size limits\n+    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+        return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n+                         REJECT_INVALID, \"bad-blk-length\");\n+\n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0].IsCoinBase())\n         return state.DoS(100, error(\"CheckBlock() : first tx is not coinbase\"),"
      },
      {
        "sha": "8e3f1d95cecb82b6183f2ad6800e10fd3fd5066d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f457347053029d6a0248036a1ffeb7127108fd6d/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f457347053029d6a0248036a1ffeb7127108fd6d/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=f457347053029d6a0248036a1ffeb7127108fd6d",
        "patch": "@@ -603,6 +603,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos);\n \n // Context-independent validity checks\n+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n // Store block on disk"
      }
    ]
  },
  {
    "sha": "942b33a19d3aa96326acc044c1834c48beff777c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NDJiMzNhMTlkM2FhOTYzMjZhY2MwNDRjMTgzNGM0OGJlZmY3Nzdj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-03-13T02:48:27Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-04-24T22:35:58Z"
      },
      "message": "Split AcceptBlockHeader from AcceptBlock.\n\nAlso modify some connection logic to deal with non-full blocks in the index.",
      "tree": {
        "sha": "f44267b1c4d73b10452816e196d398f521c8b292",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f44267b1c4d73b10452816e196d398f521c8b292"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/942b33a19d3aa96326acc044c1834c48beff777c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/942b33a19d3aa96326acc044c1834c48beff777c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/942b33a19d3aa96326acc044c1834c48beff777c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/942b33a19d3aa96326acc044c1834c48beff777c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f457347053029d6a0248036a1ffeb7127108fd6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f457347053029d6a0248036a1ffeb7127108fd6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f457347053029d6a0248036a1ffeb7127108fd6d"
      }
    ],
    "stats": {
      "total": 226,
      "additions": 162,
      "deletions": 64
    },
    "files": [
      {
        "sha": "05f13dfda6adce56b1a8776a056e91a684c12296",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 137,
        "deletions": 63,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/942b33a19d3aa96326acc044c1834c48beff777c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/942b33a19d3aa96326acc044c1834c48beff777c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=942b33a19d3aa96326acc044c1834c48beff777c",
        "patch": "@@ -1849,8 +1849,13 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     if (fJustCheck)\n         return true;\n \n+    // Correct transaction counts.\n+    pindex->nTx = block.vtx.size();\n+    if (pindex->pprev)\n+        pindex->nChainTx = pindex->pprev->nChainTx + block.vtx.size();\n+\n     // Write undo information to disk\n-    if (pindex->GetUndoPos().IsNull() || (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_SCRIPTS)\n+    if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))\n     {\n         if (pindex->GetUndoPos().IsNull()) {\n             CDiskBlockPos pos;\n@@ -1864,7 +1869,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n             pindex->nStatus |= BLOCK_HAVE_UNDO;\n         }\n \n-        pindex->nStatus = (pindex->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_SCRIPTS;\n+        pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);\n \n         CDiskBlockIndex blockindex(pindex);\n         if (!pblocktree->WriteBlockIndex(blockindex))\n@@ -2058,10 +2063,11 @@ void static FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n-            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n+            if (!pindexTest->IsValid(BLOCK_VALID_TRANSACTIONS) || !(pindexTest->nStatus & BLOCK_HAVE_DATA)) {\n                 // Candidate has an invalid ancestor, remove entire chain from the set.\n                 if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n-                    pindexBestInvalid = pindexNew;                CBlockIndex *pindexFailed = pindexNew;\n+                    pindexBestInvalid = pindexNew;\n+                CBlockIndex *pindexFailed = pindexNew;\n                 while (pindexTest != pindexFailed) {\n                     pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n                     setBlockIndexValid.erase(pindexFailed);\n@@ -2135,12 +2141,14 @@ bool ActivateBestChain(CValidationState &state) {\n     return true;\n }\n \n-bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos)\n+\n+CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n {\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", hash.ToString()), 0, \"duplicate\");\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hash);\n+    if (it != mapBlockIndex.end())\n+        return it->second;\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n@@ -2157,14 +2165,38 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n     }\n-    pindexNew->nTx = block.vtx.size();\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + pindexNew->GetBlockWork().getuint256();\n-    pindexNew->nChainTx = (pindexNew->pprev ? pindexNew->pprev->nChainTx : 0) + pindexNew->nTx;\n+    pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n+\n+    return pindexNew;\n+}\n+\n+\n+// Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS).\n+bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos)\n+{\n+    pindexNew->nTx = block.vtx.size();\n+    if (pindexNew->pprev) {\n+        // Not the genesis block.\n+        if (pindexNew->pprev->nChainTx) {\n+            // This parent's block's total number transactions is known, so compute outs.\n+            pindexNew->nChainTx = pindexNew->pprev->nChainTx + pindexNew->nTx;\n+        } else {\n+            // The total number of transactions isn't known yet.\n+            // We will compute it when the block is connected.\n+            pindexNew->nChainTx = 0;\n+        }\n+    } else {\n+        // Genesis block.\n+        pindexNew->nChainTx = pindexNew->nTx;\n+    }\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n-    pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n-    setBlockIndexValid.insert(pindexNew);\n+    pindexNew->nStatus |= BLOCK_HAVE_DATA;\n+\n+    if (pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS))\n+        setBlockIndexValid.insert(pindexNew);\n \n     if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n         return state.Abort(_(\"Failed to write block index\"));\n@@ -2292,14 +2324,35 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits))\n-        return state.DoS(50, error(\"CheckBlock() : proof of work failed\"),\n+        return state.DoS(50, error(\"CheckBlockHeader() : proof of work failed\"),\n                          REJECT_INVALID, \"high-hash\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return state.Invalid(error(\"CheckBlock() : block timestamp too far in the future\"),\n+        return state.Invalid(error(\"CheckBlockHeader() : block timestamp too far in the future\"),\n                              REJECT_INVALID, \"time-too-new\");\n \n+    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n+    if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n+    {\n+        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n+        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n+        if (deltaTime < 0)\n+        {\n+            return state.DoS(100, error(\"CheckBlockHeader() : block with timestamp before last checkpoint\"),\n+                             REJECT_CHECKPOINT, \"time-too-old\");\n+        }\n+        CBigNum bnNewBlock;\n+        bnNewBlock.SetCompact(block.nBits);\n+        CBigNum bnRequired;\n+        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n+        if (bnNewBlock > bnRequired)\n+        {\n+            return state.DoS(100, error(\"CheckBlockHeader() : block with too little proof-of-work\"),\n+                             REJECT_INVALID, \"bad-diffbits\");\n+        }\n+    }\n+\n     return true;\n }\n \n@@ -2362,13 +2415,18 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     return true;\n }\n \n-bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n+bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AcceptBlock() : block already in mapBlockIndex\"), 0, \"duplicate\");\n+    std::map<uint256, CBlockIndex*>::iterator miSelf = mapBlockIndex.find(hash);\n+    CBlockIndex *pindex = NULL;\n+    if (miSelf != mapBlockIndex.end()) {\n+        pindex = miSelf->second;\n+        if (pindex->nStatus & BLOCK_FAILED_MASK)\n+            return state.Invalid(error(\"AcceptBlock() : block is marked invalid\"), 0, \"duplicate\");\n+    }\n \n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n@@ -2390,12 +2448,6 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n             return state.Invalid(error(\"AcceptBlock() : block's timestamp is too early\"),\n                                  REJECT_INVALID, \"time-too-old\");\n \n-        // Check that all transactions are finalized\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-            if (!IsFinalTx(tx, nHeight, block.GetBlockTime()))\n-                return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"),\n-                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n-\n         // Check that the block chain matches the known block chain up to a checkpoint\n         if (!Checkpoints::CheckBlock(nHeight, hash))\n             return state.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lock-in at %d\", nHeight),\n@@ -2416,18 +2468,57 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n                                      REJECT_OBSOLETE, \"bad-version\");\n             }\n         }\n-        // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n-        if (block.nVersion >= 2)\n+    }\n+\n+    if (pindex == NULL)\n+        pindex = AddToBlockIndex(block);\n+\n+    if (ppindex)\n+        *ppindex = pindex;\n+\n+    return true;\n+}\n+\n+bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex, CDiskBlockPos* dbp)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    CBlockIndex *&pindex = *ppindex;\n+\n+    if (!AcceptBlockHeader(block, state, &pindex))\n+        return false;\n+\n+    if (!CheckBlock(block, state)) {\n+        if (state.Invalid() && !state.CorruptionPossible()) {\n+            pindex->nStatus |= BLOCK_FAILED_VALID;\n+        }\n+        return false;\n+    }\n+\n+    int nHeight = pindex->nHeight;\n+    uint256 hash = pindex->GetBlockHash();\n+\n+    // Check that all transactions are finalized\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!IsFinalTx(tx, nHeight, block.GetBlockTime())) {\n+            pindex->nStatus |= BLOCK_FAILED_VALID;\n+            return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"),\n+                             REJECT_INVALID, \"bad-txns-nonfinal\");\n+        }\n+\n+    // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n+    if (block.nVersion >= 2)\n+    {\n+        // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):\n+        if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 750, 1000)) ||\n+            (TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 51, 100)))\n         {\n-            // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):\n-            if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 750, 1000)) ||\n-                (TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 51, 100)))\n-            {\n-                CScript expect = CScript() << nHeight;\n-                if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n-                    !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin()))\n-                    return state.DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"),\n-                                     REJECT_INVALID, \"bad-cb-height\");\n+            CScript expect = CScript() << nHeight;\n+            if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n+                !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin())) {\n+                pindex->nStatus |= BLOCK_FAILED_VALID;\n+                return state.DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"),\n+                                 REJECT_INVALID, \"bad-cb-height\");\n             }\n         }\n     }\n@@ -2443,8 +2534,8 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n         if (dbp == NULL)\n             if (!WriteBlockToDisk(block, blockPos))\n                 return state.Abort(_(\"Failed to write block\"));\n-        if (!AddToBlockIndex(block, state, blockPos))\n-            return error(\"AcceptBlock() : AddToBlockIndex failed\");\n+        if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n+            return error(\"AcceptBlock() : ReceivedBlockTransactions failed\");\n     } catch(std::runtime_error &e) {\n         return state.Abort(_(\"System error: \") + e.what());\n     }\n@@ -2514,30 +2605,9 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     if (!CheckBlock(*pblock, state))\n         return error(\"ProcessBlock() : CheckBlock FAILED\");\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n-    {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64_t deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n-        if (deltaTime < 0)\n-        {\n-            return state.DoS(100, error(\"ProcessBlock() : block with timestamp before last checkpoint\"),\n-                             REJECT_CHECKPOINT, \"time-too-old\");\n-        }\n-        CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n-        CBigNum bnRequired;\n-        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n-        if (bnNewBlock > bnRequired)\n-        {\n-            return state.DoS(100, error(\"ProcessBlock() : block with too little proof-of-work\"),\n-                             REJECT_INVALID, \"bad-diffbits\");\n-        }\n-    }\n-\n-\n-    // If we don't already have its previous block, shunt it off to holding area until we get it\n-    if (pblock->hashPrevBlock != 0 && !mapBlockIndex.count(pblock->hashPrevBlock))\n+    // If we don't already have its previous block (with full data), shunt it off to holding area until we get it\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(pblock->hashPrevBlock);\n+    if (pblock->hashPrevBlock != 0 && (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)))\n     {\n         LogPrintf(\"ProcessBlock: ORPHAN BLOCK %lu, prev=%s\\n\", (unsigned long)mapOrphanBlocks.size(), pblock->hashPrevBlock.ToString());\n \n@@ -2562,7 +2632,9 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     }\n \n     // Store to disk\n-    if (!AcceptBlock(*pblock, state, dbp))\n+    CBlockIndex *pindex = NULL;\n+    bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n+    if (!ret)\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n \n     // Recursively process any orphan blocks that depended on this one\n@@ -2583,7 +2655,8 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n             block.BuildMerkleTree();\n             // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan resolution (that is, feeding people an invalid block based on LegitBlockX in order to get anyone relaying LegitBlockX banned)\n             CValidationState stateDummy;\n-            if (AcceptBlock(block, stateDummy))\n+            CBlockIndex *pindexChild = NULL;\n+            if (AcceptBlock(block, stateDummy, &pindexChild))\n                 vWorkQueue.push_back(mi->second->hashBlock);\n             mapOrphanBlocks.erase(mi->second->hashBlock);\n             delete mi->second;\n@@ -2846,7 +2919,7 @@ bool static LoadBlockIndexDB()\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + pindex->GetBlockWork().getuint256();\n         pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS && !(pindex->nStatus & BLOCK_FAILED_MASK))\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS))\n             setBlockIndexValid.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n@@ -2993,7 +3066,8 @@ bool InitBlockIndex() {\n                 return error(\"LoadBlockIndex() : FindBlockPos failed\");\n             if (!WriteBlockToDisk(block, blockPos))\n                 return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n-            if (!AddToBlockIndex(block, state, blockPos))\n+            CBlockIndex *pindex = AddToBlockIndex(block);\n+            if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n                 return error(\"LoadBlockIndex() : genesis block not accepted\");\n         } catch(std::runtime_error &e) {\n             return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());"
      },
      {
        "sha": "77a6fbe9dcdd57c5ec66c009ea2a82e38ee772dc",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/942b33a19d3aa96326acc044c1834c48beff777c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/942b33a19d3aa96326acc044c1834c48beff777c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=942b33a19d3aa96326acc044c1834c48beff777c",
        "patch": "@@ -608,7 +608,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = t\n \n // Store block on disk\n // if dbp is provided, the file is known to already reside on disk\n-bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp = NULL);\n+bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n+bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n \n \n \n@@ -866,6 +867,29 @@ class CBlockIndex\n     {\n         LogPrintf(\"%s\\n\", ToString().c_str());\n     }\n+\n+    // Check whether this block index entry is valid up to the passed validity level.\n+    bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n+    {\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+        if (nStatus & BLOCK_FAILED_MASK)\n+            return false;\n+        return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n+    }\n+\n+    // Raise the validity level of this block index entry.\n+    // Returns true if the validity was changed.\n+    bool RaiseValidity(enum BlockStatus nUpTo)\n+    {\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+        if (nStatus & BLOCK_FAILED_MASK)\n+            return false;\n+        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n+            nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n+            return true;\n+        }\n+        return false;\n+    }\n };\n \n "
      }
    ]
  }
]