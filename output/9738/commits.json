[
  {
    "sha": "6294f3283a5b6919795621dc067ec80c0cd2a334",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Mjk0ZjMyODNhNWI2OTE5Nzk1NjIxZGMwNjdlYzgwYzBjZDJhMzM0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-10T16:04:13Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-07T21:38:21Z"
      },
      "message": "gettxoutproof() should return consistent result\n\nWe can call gettxoutproof() with a list of transactions. Currently, if\nthe first transaction is unspent (and all other transactions are in the\nsame block), then the call will succeed. If the first transaction has\nbeen spent, then the call will fail. The means that the following two\ncalls will return different results:\n\ngettxoutproof(unspent_tx1, spent_tx1)\ngettxoutproof(spent_tx1, unspent_tx1)\n\nThis commit makes behaviour independent of transaction ordering by looping\nthrough all transactions provided and trying to find which block they're in.\n\nThis commit also increases the test coverage and tests more failure\ncases for gettxoutproof()",
      "tree": {
        "sha": "794537d75a4a1fde5e0626ec098045dd64be57fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/794537d75a4a1fde5e0626ec098045dd64be57fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6294f3283a5b6919795621dc067ec80c0cd2a334",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6294f3283a5b6919795621dc067ec80c0cd2a334",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6294f3283a5b6919795621dc067ec80c0cd2a334",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6294f3283a5b6919795621dc067ec80c0cd2a334/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 23,
      "deletions": 14
    },
    "files": [
      {
        "sha": "fe56519e7454a5bb32f088bff71e1c44128b496c",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6294f3283a5b6919795621dc067ec80c0cd2a334/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6294f3283a5b6919795621dc067ec80c0cd2a334/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=6294f3283a5b6919795621dc067ec80c0cd2a334",
        "patch": "@@ -219,9 +219,13 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n-        const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n-        if (!coin.IsSpent() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n-            pblockindex = chainActive[coin.nHeight];\n+        // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n+        for (const auto& tx : setTxids) {\n+            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n+            if (!coin.IsSpent()) {\n+                pblockindex = chainActive[coin.nHeight];\n+                break;\n+            }\n         }\n     }\n \n@@ -244,7 +248,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         if (setTxids.count(tx->GetHash()))\n             ntxFound++;\n     if (ntxFound != setTxids.size())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"(Not all) transactions not found in specified block\");\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Not all transactions found in specified or retrieved block\");\n \n     CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n     CMerkleBlock mb(block, setTxids);"
      },
      {
        "sha": "bcc65c8408eeb7b3c3eec102d850a3b53ae824bc",
        "filename": "test/functional/merkle_blocks.py",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6294f3283a5b6919795621dc067ec80c0cd2a334/test/functional/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6294f3283a5b6919795621dc067ec80c0cd2a334/test/functional/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/merkle_blocks.py?ref=6294f3283a5b6919795621dc067ec80c0cd2a334",
        "patch": "@@ -39,7 +39,8 @@ def run_test(self):\n         txid1 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx1)[\"hex\"])\n         tx2 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 49.99})\n         txid2 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx2)[\"hex\"])\n-        assert_raises(JSONRPCException, self.nodes[0].gettxoutproof, [txid1])\n+        # This will raise an exception because the transaction is not yet in a block\n+        assert_raises_jsonrpc(-5, \"Transaction not yet in block\", self.nodes[0].gettxoutproof, [txid1])\n \n         self.nodes[0].generate(1)\n         blockhash = self.nodes[0].getblockhash(chain_height + 1)\n@@ -56,25 +57,29 @@ def run_test(self):\n \n         txin_spent = self.nodes[1].listunspent(1).pop()\n         tx3 = self.nodes[1].createrawtransaction([txin_spent], {self.nodes[0].getnewaddress(): 49.98})\n-        self.nodes[0].sendrawtransaction(self.nodes[1].signrawtransaction(tx3)[\"hex\"])\n+        txid3 = self.nodes[0].sendrawtransaction(self.nodes[1].signrawtransaction(tx3)[\"hex\"])\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n         txid_spent = txin_spent[\"txid\"]\n         txid_unspent = txid1 if txin_spent[\"txid\"] != txid1 else txid2\n \n         # We can't find the block from a fully-spent tx\n-        assert_raises(JSONRPCException, self.nodes[2].gettxoutproof, [txid_spent])\n-        # ...but we can if we specify the block\n+        assert_raises_jsonrpc(-5, \"Transaction not yet in block\", self.nodes[2].gettxoutproof, [txid_spent])\n+        # We can get the proof if we specify the block\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_spent], blockhash)), [txid_spent])\n-        # ...or if the first tx is not fully-spent\n+        # We can't get the proof if we specify a non-existent block\n+        assert_raises_jsonrpc(-5, \"Block not found\", self.nodes[2].gettxoutproof, [txid_spent], \"00000000000000000000000000000000\")\n+        # We can get the proof if the transaction is unspent\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_unspent])), [txid_unspent])\n-        try:\n-            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2])), txlist)\n-        except JSONRPCException:\n-            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid2, txid1])), txlist)\n-        # ...or if we have a -txindex\n+        # We can get the proof if we provide a list of transactions and one of them is unspent. The ordering of the list should not matter.\n+        assert_equal(sorted(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2]))), sorted(txlist))\n+        assert_equal(sorted(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid2, txid1]))), sorted(txlist))\n+        # We can always get a proof if we have a -txindex\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[3].gettxoutproof([txid_spent])), [txid_spent])\n+        # We can't get a proof if we specify transactions from different blocks\n+        assert_raises_jsonrpc(-5, \"Not all transactions found in specified or retrieved block\", self.nodes[2].gettxoutproof, [txid1, txid3])\n+\n \n if __name__ == '__main__':\n     MerkleBlockTest().main()"
      }
    ]
  }
]