[
  {
    "sha": "e3c866e3ca85f841671a828712e6207e24d0d996",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2M4NjZlM2NhODVmODQxNjcxYTgyODcxMmU2MjA3ZTI0ZDBkOTk2",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-05-27T05:29:48Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-06-01T10:00:00Z"
      },
      "message": "test: update nanobench from release 4.0.0 to 4.3.4\n\nThis updates the third-party library nanobench with the latest release. It contains mostly minor bugfixes, a new pyperf output format, ability to suppress warnings with environment variable `NANOBENCH_SUPPRESS_WARNINGS`. Full changelog:\n\nv4.0.2\n* Changed `doNotOptimizeAway` to what google benchmark is doing. The old code did not work on some machines.\n* fix: display correct \"total\" value\n* minor Documentation updates\n\nv4.1.0\n* Updated link to new pyperf home\n* Adds ability to configure console output time unit\n*  Add support for environment variable `NANOBENCH_SUPPRESS_WARNINGS`\n* Nanobench is now usable with CMake's FetchContent (see documentation: https://nanobench.ankerl.com/tutorial.html#cmake-integration)\n\nv4.2.0\n* Ability to store and later compare results added, through `pyperf`.\n* See https://nanobench.ankerl.com/tutorial.html#pyperf-python-pyperf-module-output\n* Added lots of build targets to travis, similar to bitcoin's build.\n* Some minor API & documentation improvements\n\nv4.3.0\n* `ankerl::nanobench::Rng` can now return the state with `std::vector<uint64_t> Rng::state()`, and this can also be used to initialize the Rng.\n\nv4.3.1\n* Minor cmake improvements when integrationg as a third-party library: add alias `nanobench::nanobench`, default to C++17\n\nv4.3.2\n* Fixed a MSVC 2015 build problem\n* updates license to 2021.\n* build should now work with very old linux headers\n* Also disable UBSAN (bitcoin needed to add a suppression)\n\nv4.3.3\n* Do not use locale-dependent `std::to_string`\n\nv4.3.4\n* Add missing sanitizer suppression to `rotl`",
      "tree": {
        "sha": "c14623b35023df369ce1256a2fac1ff4f9972a49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c14623b35023df369ce1256a2fac1ff4f9972a49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3c866e3ca85f841671a828712e6207e24d0d996",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3c866e3ca85f841671a828712e6207e24d0d996",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3c866e3ca85f841671a828712e6207e24d0d996",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3c866e3ca85f841671a828712e6207e24d0d996/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c91589dc2defdf0e193c2ebe383337c4008c47b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c91589dc2defdf0e193c2ebe383337c4008c47b5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c91589dc2defdf0e193c2ebe383337c4008c47b5"
      }
    ],
    "stats": {
      "total": 239,
      "additions": 187,
      "deletions": 52
    },
    "files": [
      {
        "sha": "030d6ebf6ac2eff303d1324eb7b589670016e67f",
        "filename": "src/bench/nanobench.h",
        "status": "modified",
        "additions": 187,
        "deletions": 52,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3c866e3ca85f841671a828712e6207e24d0d996/src/bench/nanobench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3c866e3ca85f841671a828712e6207e24d0d996/src/bench/nanobench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.h?ref=e3c866e3ca85f841671a828712e6207e24d0d996",
        "patch": "@@ -7,7 +7,7 @@\n //\n // Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n // SPDX-License-Identifier: MIT\n-// Copyright (c) 2019-2020 Martin Ankerl <martin.ankerl@gmail.com>\n+// Copyright (c) 2019-2021 Martin Ankerl <martin.ankerl@gmail.com>\n //\n // Permission is hereby granted, free of charge, to any person obtaining a copy\n // of this software and associated documentation files (the \"Software\"), to deal\n@@ -32,8 +32,8 @@\n \n // see https://semver.org/\n #define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n-#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n-#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 3 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 4 // backwards-compatible bug fixes\n \n ///////////////////////////////////////////////////////////////////////////////////////////////////\n // public facing api - as minimal as possible\n@@ -78,12 +78,20 @@\n \n #if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n #    include <iostream>\n-#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#    define ANKERL_NANOBENCH_LOG(x)                                                 \\\n+        do {                                                                        \\\n+            std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl; \\\n+        } while (0)\n #else\n-#    define ANKERL_NANOBENCH_LOG(x)\n+#    define ANKERL_NANOBENCH_LOG(x) \\\n+        do {                        \\\n+        } while (0)\n #endif\n \n-#if defined(__linux__) && !defined(ANKERL_NANOBENCH_DISABLE_PERF_COUNTERS)\n+#if defined(__linux__) && defined(PERF_EVENT_IOC_ID) && defined(PERF_COUNT_HW_REF_CPU_CYCLES) && defined(PERF_FLAG_FD_CLOEXEC) && \\\n+    !defined(ANKERL_NANOBENCH_DISABLE_PERF_COUNTERS)\n+// only enable perf counters on kernel 3.14 which seems to have all the necessary defines. The three PERF_... defines are not in\n+// kernel 2.6.32 (all others are).\n #    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n #else\n #    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n@@ -173,18 +181,19 @@ class BigO;\n  *    `contextswitches`, `instructions`, `branchinstructions`, and `branchmisses`. All the measuers (except `iterations`) are\n  *    provided for a single iteration (so `elapsed` is the time a single iteration took). The following tags are available:\n  *\n- *    * `{{median(<name>>)}}` Calculate median of a measurement data set, e.g. `{{median(elapsed)}}`.\n+ *    * `{{median(<name>)}}` Calculate median of a measurement data set, e.g. `{{median(elapsed)}}`.\n  *\n  *    * `{{average(<name>)}}` Average (mean) calculation.\n  *\n  *    * `{{medianAbsolutePercentError(<name>)}}` Calculates MdAPE, the Median Absolute Percentage Error. The MdAPE is an excellent\n  *      metric for the variation of measurements. It is more robust to outliers than the\n  *      [Mean absolute percentage error (M-APE)](https://en.wikipedia.org/wiki/Mean_absolute_percentage_error).\n  *      @f[\n- *       \\mathrm{medianAbsolutePercentError}(e) = \\mathrm{median}\\{| \\frac{e_i - \\mathrm{median}\\{e\\}}{e_i}| \\}\n+ *       \\mathrm{MdAPE}(e) = \\mathrm{med}\\{| \\frac{e_i - \\mathrm{med}\\{e\\}}{e_i}| \\}\n  *      @f]\n- *      E.g. for *elapsed*: First, @f$ \\mathrm{median}\\{elapsed\\} @f$ is calculated. This is used to calculate the absolute percentage\n- *      error to this median for each measurement, as in  @f$ | \\frac{e_i - \\mathrm{median}\\{e\\}}{e_i}| @f$. All these results\n+ *      E.g. for *elapsed*: First, @f$ \\mathrm{med}\\{e\\} @f$ calculates the median by sorting and then taking the middle element\n+ *      of all *elapsed* measurements. This is used to calculate the absolute percentage\n+ *      error to this median for each measurement, as in  @f$ | \\frac{e_i - \\mathrm{med}\\{e\\}}{e_i}| @f$. All these results\n  *      are sorted, and the middle value is chosen as the median absolute percent error.\n  *\n  *      This measurement is a bit hard to interpret, but it is very robust against outliers. E.g. a value of 5% means that half of the\n@@ -207,7 +216,7 @@ class BigO;\n  *\n  *    * `{{#measurement}}` To access individual measurement results, open the begin tag for measurements.\n  *\n- *       * `{{elapsed}}` Average elapsed time per iteration, in seconds.\n+ *       * `{{elapsed}}` Average elapsed wall clock time per iteration, in seconds.\n  *\n  *       * `{{iterations}}` Number of iterations in the measurement. The number of iterations will fluctuate due\n  *         to some applied randomness, to enhance accuracy.\n@@ -261,6 +270,7 @@ class BigO;\n    * :cpp:func:`templates::csv() <ankerl::nanobench::templates::csv()>`\n    * :cpp:func:`templates::json() <ankerl::nanobench::templates::json()>`\n    * :cpp:func:`templates::htmlBoxplot() <ankerl::nanobench::templates::htmlBoxplot()>`\n+   * :cpp:func:`templates::pyperf() <ankerl::nanobench::templates::pyperf()>`\n \n    @endverbatim\n  *\n@@ -269,6 +279,7 @@ class BigO;\n  * @param out Output for the generated output.\n  */\n void render(char const* mustacheTemplate, Bench const& bench, std::ostream& out);\n+void render(std::string const& mustacheTemplate, Bench const& bench, std::ostream& out);\n \n /**\n  * Same as render(char const* mustacheTemplate, Bench const& bench, std::ostream& out), but for when\n@@ -279,6 +290,7 @@ void render(char const* mustacheTemplate, Bench const& bench, std::ostream& out)\n  * @param out Output for the generated output.\n  */\n void render(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+void render(std::string const& mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n \n // Contains mustache-like templates\n namespace templates {\n@@ -297,7 +309,7 @@ char const* csv() noexcept;\n /*!\n   @brief HTML output that uses plotly to generate an interactive boxplot chart. See the tutorial for an example output.\n \n-  The output uses only the elapsed time, and displays each epoch as a single dot.\n+  The output uses only the elapsed wall clock time, and displays each epoch as a single dot.\n   @verbatim embed:rst\n   See the tutorial at :ref:`tutorial-template-html` for an example.\n   @endverbatim\n@@ -306,6 +318,14 @@ char const* csv() noexcept;\n  */\n char const* htmlBoxplot() noexcept;\n \n+/*!\n+ @brief Output in pyperf  compatible JSON format, which can be used for more analyzations.\n+ @verbatim embed:rst\n+ See the tutorial at :ref:`tutorial-template-pyperf` for an example how to further analyze the output.\n+ @endverbatim\n+ */\n+char const* pyperf() noexcept;\n+\n /*!\n   @brief Template to generate JSON data.\n \n@@ -369,6 +389,8 @@ struct Config {\n     uint64_t mEpochIterations{0}; // If not 0, run *exactly* these number of iterations per epoch.\n     uint64_t mWarmup = 0;\n     std::ostream* mOut = nullptr;\n+    std::chrono::duration<double> mTimeUnit = std::chrono::nanoseconds{1};\n+    std::string mTimeUnitName = \"ns\";\n     bool mShowPerformanceCounters = true;\n     bool mIsRelative = false;\n \n@@ -504,6 +526,7 @@ class Rng final {\n      */\n     explicit Rng(uint64_t seed) noexcept;\n     Rng(uint64_t x, uint64_t y) noexcept;\n+    Rng(std::vector<uint64_t> const& data);\n \n     /**\n      * Creates a copy of the Rng, thus the copy provides exactly the same random sequence as the original.\n@@ -558,6 +581,14 @@ class Rng final {\n     template <typename Container>\n     void shuffle(Container& container) noexcept;\n \n+    /**\n+     * Extracts the full state of the generator, e.g. for serialization. For this RNG this is just 2 values, but to stay API compatible\n+     * with future implementations that potentially use more state, we use a vector.\n+     *\n+     * @return Vector containing the full state:\n+     */\n+    std::vector<uint64_t> state() const;\n+\n private:\n     static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n \n@@ -666,6 +697,19 @@ class Bench {\n     Bench& unit(std::string const& unit);\n     ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n \n+    /**\n+     * @brief Sets the time unit to be used for the default output.\n+     *\n+     * Nanobench defaults to using ns (nanoseconds) as output in the markdown. For some benchmarks this is too coarse, so it is\n+     * possible to configure this. E.g. use `timeUnit(1ms, \"ms\")` to show `ms/op` instead of `ns/op`.\n+     *\n+     * @param tu Time unit to display the results in, default is 1ns.\n+     * @param tuName Name for the time unit, default is \"ns\"\n+     */\n+    Bench& timeUnit(std::chrono::duration<double> const& tu, std::string const& tuName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& timeUnitName() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::duration<double> const& timeUnit() const noexcept;\n+\n     /**\n      * @brief Set the output stream where the resulting markdown table will be printed to.\n      *\n@@ -916,6 +960,7 @@ class Bench {\n       @endverbatim\n      */\n     Bench& render(char const* templateContent, std::ostream& os);\n+    Bench& render(std::string const& templateContent, std::ostream& os);\n \n     Bench& config(Config const& benchmarkConfig);\n     ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n@@ -945,23 +990,24 @@ void doNotOptimizeAway(T const& val);\n \n #else\n \n-// see folly's Benchmark.h\n-template <typename T>\n-constexpr bool doNotOptimizeNeedsIndirect() {\n-    using Decayed = typename std::decay<T>::type;\n-    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n-}\n-\n+// These assembly magic is directly from what Google Benchmark is doing. I have previously used what facebook's folly was doing, but\n+// this seemd to have compilation problems in some cases. Google Benchmark seemed to be the most well tested anyways.\n+// see https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307\n template <typename T>\n-typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+void doNotOptimizeAway(T const& val) {\n     // NOLINTNEXTLINE(hicpp-no-assembler)\n-    asm volatile(\"\" ::\"r\"(val));\n+    asm volatile(\"\" : : \"r,m\"(val) : \"memory\");\n }\n \n template <typename T>\n-typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+void doNotOptimizeAway(T& val) {\n+#    if defined(__clang__)\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" : \"+r,m\"(val) : : \"memory\");\n+#    else\n     // NOLINTNEXTLINE(hicpp-no-assembler)\n-    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+    asm volatile(\"\" : \"+m,r\"(val) : : \"memory\");\n+#    endif\n }\n #endif\n \n@@ -1067,7 +1113,7 @@ constexpr uint64_t(Rng::max)() {\n     return (std::numeric_limits<uint64_t>::max)();\n }\n \n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n uint64_t Rng::operator()() noexcept {\n     auto x = mX;\n \n@@ -1077,7 +1123,7 @@ uint64_t Rng::operator()() noexcept {\n     return x;\n }\n \n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n uint32_t Rng::bounded(uint32_t range) noexcept {\n     uint64_t r32 = static_cast<uint32_t>(operator()());\n     auto multiresult = r32 * range;\n@@ -1103,6 +1149,7 @@ void Rng::shuffle(Container& container) noexcept {\n     }\n }\n \n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n     return (x << k) | (x >> (64U - k));\n }\n@@ -1306,6 +1353,30 @@ char const* htmlBoxplot() noexcept {\n </html>)DELIM\";\n }\n \n+char const* pyperf() noexcept {\n+    return R\"DELIM({\n+    \"benchmarks\": [\n+        {\n+            \"runs\": [\n+                {\n+                    \"values\": [\n+{{#measurement}}                        {{elapsed}}{{^-last}},\n+{{/last}}{{/measurement}}\n+                    ]\n+                }\n+            ]\n+        }\n+    ],\n+    \"metadata\": {\n+        \"loops\": {{sum(iterations)}},\n+        \"inner_loops\": {{batch}},\n+        \"name\": \"{{title}}\",\n+        \"unit\": \"second\"\n+    },\n+    \"version\": \"1.0\"\n+})DELIM\";\n+}\n+\n char const* json() noexcept {\n     return R\"DELIM({\n     \"results\": [\n@@ -1410,6 +1481,7 @@ static std::vector<Node> parseMustacheTemplate(char const** tpl) {\n }\n \n static bool generateFirstLast(Node const& n, size_t idx, size_t size, std::ostream& out) {\n+    ANKERL_NANOBENCH_LOG(\"n.type=\" << static_cast<int>(n.type));\n     bool matchFirst = n == \"-first\";\n     bool matchLast = n == \"-last\";\n     if (!matchFirst && !matchLast) {\n@@ -1632,6 +1704,7 @@ namespace detail {\n \n char const* getEnv(char const* name);\n bool isEndlessRunning(std::string const& name);\n+bool isWarningsEnabled();\n \n template <typename T>\n T parseFile(std::string const& filename);\n@@ -1770,25 +1843,49 @@ void render(char const* mustacheTemplate, std::vector<Result> const& results, st\n                 for (size_t i = 0; i < nbResults; ++i) {\n                     generateResult(n.children, i, results, out);\n                 }\n+            } else if (n == \"measurement\") {\n+                if (results.size() != 1) {\n+                    throw std::runtime_error(\n+                        \"render: can only use section 'measurement' here if there is a single result, but there are \" +\n+                        detail::fmt::to_s(results.size()));\n+                }\n+                // when we only have a single result, we can immediately go into its measurement.\n+                auto const& r = results.front();\n+                for (size_t i = 0; i < r.size(); ++i) {\n+                    generateResultMeasurement(n.children, i, r, out);\n+                }\n             } else {\n-                throw std::runtime_error(\"unknown section '\" + std::string(n.begin, n.end) + \"'\");\n+                throw std::runtime_error(\"render: unknown section '\" + std::string(n.begin, n.end) + \"'\");\n             }\n             break;\n \n         case templates::Node::Type::tag:\n-            // This just uses the last result's config.\n-            if (!generateConfigTag(n, results.back().config(), out)) {\n-                throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+            if (results.size() == 1) {\n+                // result & config are both supported there\n+                generateResultTag(n, results.front(), out);\n+            } else {\n+                // This just uses the last result's config.\n+                if (!generateConfigTag(n, results.back().config(), out)) {\n+                    throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+                }\n             }\n             break;\n         }\n     }\n }\n \n+void render(std::string const& mustacheTemplate, std::vector<Result> const& results, std::ostream& out) {\n+    render(mustacheTemplate.c_str(), results, out);\n+}\n+\n void render(char const* mustacheTemplate, const Bench& bench, std::ostream& out) {\n     render(mustacheTemplate, bench.results(), out);\n }\n \n+void render(std::string const& mustacheTemplate, const Bench& bench, std::ostream& out) {\n+    render(mustacheTemplate.c_str(), bench.results(), out);\n+}\n+\n namespace detail {\n \n PerformanceCounters& performanceCounters() {\n@@ -1837,6 +1934,12 @@ bool isEndlessRunning(std::string const& name) {\n     return nullptr != endless && endless == name;\n }\n \n+// True when environment variable NANOBENCH_SUPPRESS_WARNINGS is either not set at all, or set to \"0\"\n+bool isWarningsEnabled() {\n+    auto suppression = getEnv(\"NANOBENCH_SUPPRESS_WARNINGS\");\n+    return nullptr == suppression || suppression == std::string(\"0\");\n+}\n+\n void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations) {\n     warnings.clear();\n     recommendations.clear();\n@@ -1889,13 +1992,13 @@ void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<\n         recommendations.emplace_back(\"Make sure you compile for Release\");\n     }\n     if (recommendPyPerf) {\n-        recommendations.emplace_back(\"Use 'pyperf system tune' before benchmarking. See https://github.com/vstinner/pyperf\");\n+        recommendations.emplace_back(\"Use 'pyperf system tune' before benchmarking. See https://github.com/psf/pyperf\");\n     }\n }\n \n void printStabilityInformationOnce(std::ostream* outStream) {\n     static bool shouldPrint = true;\n-    if (shouldPrint && outStream) {\n+    if (shouldPrint && outStream && isWarningsEnabled()) {\n         auto& os = *outStream;\n         shouldPrint = false;\n         std::vector<std::string> warnings;\n@@ -1923,16 +2026,7 @@ uint64_t& singletonHeaderHash() noexcept {\n     return sHeaderHash;\n }\n \n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n-inline uint64_t fnv1a(std::string const& str) noexcept {\n-    auto val = UINT64_C(14695981039346656037);\n-    for (auto c : str) {\n-        val = (val ^ static_cast<uint8_t>(c)) * UINT64_C(1099511628211);\n-    }\n-    return val;\n-}\n-\n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n inline uint64_t hash_combine(uint64_t seed, uint64_t val) {\n     return seed ^ (val + UINT64_C(0x9e3779b9) + (seed << 6U) + (seed >> 2U));\n }\n@@ -2010,7 +2104,7 @@ struct IterationLogic::Impl {\n         return static_cast<uint64_t>(doubleNewIters + 0.5);\n     }\n \n-    ANKERL_NANOBENCH_NO_SANITIZE(\"integer\") void upscale(std::chrono::nanoseconds elapsed) {\n+    ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\") void upscale(std::chrono::nanoseconds elapsed) {\n         if (elapsed * 10 < mTargetRuntimePerEpoch) {\n             // we are far below the target runtime. Multiply iterations by 10 (with overflow check)\n             if (mNumIters * 10 < mNumIters) {\n@@ -2108,7 +2202,8 @@ struct IterationLogic::Impl {\n                 columns.emplace_back(14, 0, \"complexityN\", \"\", mBench.complexityN());\n             }\n \n-            columns.emplace_back(22, 2, \"ns/\" + mBench.unit(), \"\", 1e9 * rMedian / mBench.batch());\n+            columns.emplace_back(22, 2, mBench.timeUnitName() + \"/\" + mBench.unit(), \"\",\n+                                 rMedian / (mBench.timeUnit().count() * mBench.batch()));\n             columns.emplace_back(22, 2, mBench.unit() + \"/s\", \"\", rMedian <= 0.0 ? 0.0 : mBench.batch() / rMedian);\n \n             double rErrorMedian = mResult.medianAbsolutePercentError(Result::Measure::elapsed);\n@@ -2140,16 +2235,19 @@ struct IterationLogic::Impl {\n                 }\n             }\n \n-            columns.emplace_back(12, 2, \"total\", \"\", mResult.sum(Result::Measure::elapsed));\n+            columns.emplace_back(12, 2, \"total\", \"\", mResult.sumProduct(Result::Measure::iterations, Result::Measure::elapsed));\n \n             // write everything\n             auto& os = *mBench.output();\n \n+            // combine all elements that are relevant for printing the header\n             uint64_t hash = 0;\n-            hash = hash_combine(fnv1a(mBench.unit()), hash);\n-            hash = hash_combine(fnv1a(mBench.title()), hash);\n-            hash = hash_combine(mBench.relative(), hash);\n-            hash = hash_combine(mBench.performanceCounters(), hash);\n+            hash = hash_combine(std::hash<std::string>{}(mBench.unit()), hash);\n+            hash = hash_combine(std::hash<std::string>{}(mBench.title()), hash);\n+            hash = hash_combine(std::hash<std::string>{}(mBench.timeUnitName()), hash);\n+            hash = hash_combine(std::hash<double>{}(mBench.timeUnit().count()), hash);\n+            hash = hash_combine(std::hash<bool>{}(mBench.relative()), hash);\n+            hash = hash_combine(std::hash<bool>{}(mBench.performanceCounters()), hash);\n \n             if (hash != singletonHeaderHash()) {\n                 singletonHeaderHash() = hash;\n@@ -2177,7 +2275,7 @@ struct IterationLogic::Impl {\n                     os << col.value();\n                 }\n                 os << \"| \";\n-                auto showUnstable = rErrorMedian >= 0.05;\n+                auto showUnstable = isWarningsEnabled() && rErrorMedian >= 0.05;\n                 if (showUnstable) {\n                     os << \":wavy_dash: \";\n                 }\n@@ -2305,7 +2403,7 @@ class LinuxPerformanceCounters {\n     }\n \n     template <typename Op>\n-    ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+    ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n     void calibrate(Op&& op) {\n         // clear current calibration data,\n         for (auto& v : mCalibratedOverhead) {\n@@ -2411,7 +2509,7 @@ bool LinuxPerformanceCounters::monitor(perf_hw_id hwId, LinuxPerformanceCounters\n }\n \n // overflow is ok, it's checked\n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n void LinuxPerformanceCounters::updateResults(uint64_t numIters) {\n     // clear old data\n     for (auto& id_value : mIdToTarget) {\n@@ -2963,6 +3061,20 @@ std::string const& Bench::unit() const noexcept {\n     return mConfig.mUnit;\n }\n \n+Bench& Bench::timeUnit(std::chrono::duration<double> const& tu, std::string const& tuName) {\n+    mConfig.mTimeUnit = tu;\n+    mConfig.mTimeUnitName = tuName;\n+    return *this;\n+}\n+\n+std::string const& Bench::timeUnitName() const noexcept {\n+    return mConfig.mTimeUnitName;\n+}\n+\n+std::chrono::duration<double> const& Bench::timeUnit() const noexcept {\n+    return mConfig.mTimeUnit;\n+}\n+\n // If benchmarkTitle differs from currently set title, the stored results will be cleared.\n Bench& Bench::title(const char* benchmarkTitle) {\n     if (benchmarkTitle != mConfig.mBenchmarkTitle) {\n@@ -3083,6 +3195,11 @@ Bench& Bench::render(char const* templateContent, std::ostream& os) {\n     return *this;\n }\n \n+Bench& Bench::render(std::string const& templateContent, std::ostream& os) {\n+    ::ankerl::nanobench::render(templateContent, *this, os);\n+    return *this;\n+}\n+\n std::vector<BigO> Bench::complexityBigO() const {\n     std::vector<BigO> bigOs;\n     auto rangeMeasure = BigO::collectRangeMeasure(mResults);\n@@ -3119,7 +3236,7 @@ Rng::Rng()\n     } while (mX == 0 && mY == 0);\n }\n \n-ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\", \"undefined\")\n uint64_t splitMix64(uint64_t& state) noexcept {\n     uint64_t z = (state += UINT64_C(0x9e3779b97f4a7c15));\n     z = (z ^ (z >> 30U)) * UINT64_C(0xbf58476d1ce4e5b9);\n@@ -3145,6 +3262,24 @@ Rng Rng::copy() const noexcept {\n     return Rng{mX, mY};\n }\n \n+Rng::Rng(std::vector<uint64_t> const& data)\n+    : mX(0)\n+    , mY(0) {\n+    if (data.size() != 2) {\n+        throw std::runtime_error(\"ankerl::nanobench::Rng::Rng: needed exactly 2 entries in data, but got \" +\n+                                 detail::fmt::to_s(data.size()));\n+    }\n+    mX = data[0];\n+    mY = data[1];\n+}\n+\n+std::vector<uint64_t> Rng::state() const {\n+    std::vector<uint64_t> data(2);\n+    data[0] = mX;\n+    data[1] = mY;\n+    return data;\n+}\n+\n BigO::RangeMeasure BigO::collectRangeMeasure(std::vector<Result> const& results) {\n     BigO::RangeMeasure rangeMeasure;\n     for (auto const& result : results) {"
      }
    ]
  },
  {
    "sha": "44d05d0a69c14ed295b0a7f6c8ec4379d44155e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NGQwNWQwYTY5YzE0ZWQyOTViMGE3ZjZjOGVjNDM3OWQ0NDE1NWU0",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-06-01T05:47:16Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-06-01T10:00:21Z"
      },
      "message": "test: remove sanitizer suppression for nanobench\n\nIn #21738 an ASAN suppression for nanobench was added. This is not needed any more,as nanobench.h already includes the necessary suppressions for the relevant code.",
      "tree": {
        "sha": "9a5ec5eca92528706f854fa9771534d295bfc488",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a5ec5eca92528706f854fa9771534d295bfc488"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3c866e3ca85f841671a828712e6207e24d0d996",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3c866e3ca85f841671a828712e6207e24d0d996",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3c866e3ca85f841671a828712e6207e24d0d996"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 0,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2850cfcea5250339502aee36cf203ae1d873edf4",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/44d05d0a69c14ed295b0a7f6c8ec4379d44155e4/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=44d05d0a69c14ed295b0a7f6c8ec4379d44155e4",
        "patch": "@@ -98,7 +98,6 @@ implicit-unsigned-integer-truncation:crypto/\n implicit-unsigned-integer-truncation:leveldb/\n # std::variant warning fixed in https://github.com/gcc-mirror/gcc/commit/074436cf8cdd2a9ce75cadd36deb8301f00e55b9\n implicit-unsigned-integer-truncation:std::__detail::__variant::_Variant_storage\n-shift-base:nanobench.h\n shift-base:*/include/c++/\n shift-base:arith_uint256.cpp\n shift-base:crypto/"
      }
    ]
  }
]