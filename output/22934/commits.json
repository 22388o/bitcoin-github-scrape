[
  {
    "sha": "79fd28cacbbcb86ea03d3d468845001f84a76de3",
    "node_id": "C_kwDOABII59oAKDc5ZmQyOGNhY2JiY2I4NmVhMDNkM2Q0Njg4NDUwMDFmODRhNzZkZTM",
    "commit": {
      "author": {
        "name": "amadeuszpawlik",
        "email": "apawlik@protonmail.com",
        "date": "2021-09-09T18:18:50Z"
      },
      "committer": {
        "name": "amadeuszpawlik",
        "email": "apawlik@protonmail.com",
        "date": "2021-11-02T16:18:40Z"
      },
      "message": "Adds verification step to Schnorr and ECDSA signing\n\nAs defined in BIP340, a verification step should be executed after\n`secp256k1_schnorrsig_sign` to ensure that a potentially corrupted\nsignature isn't used; using corrupted signatures could reveal\ninformation about the private key used. This applies to ECSDA as\nwell.\n\nAdditionally clears schnorr signature if signing failed.",
      "tree": {
        "sha": "fc6920e8632b262c982eeac4ddb94feb4d484c3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc6920e8632b262c982eeac4ddb94feb4d484c3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79fd28cacbbcb86ea03d3d468845001f84a76de3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79fd28cacbbcb86ea03d3d468845001f84a76de3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/79fd28cacbbcb86ea03d3d468845001f84a76de3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79fd28cacbbcb86ea03d3d468845001f84a76de3/comments",
    "author": {
      "login": "amadeuszpawlik",
      "id": 35263201,
      "node_id": "MDQ6VXNlcjM1MjYzMjAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/35263201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amadeuszpawlik",
      "html_url": "https://github.com/amadeuszpawlik",
      "followers_url": "https://api.github.com/users/amadeuszpawlik/followers",
      "following_url": "https://api.github.com/users/amadeuszpawlik/following{/other_user}",
      "gists_url": "https://api.github.com/users/amadeuszpawlik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amadeuszpawlik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amadeuszpawlik/subscriptions",
      "organizations_url": "https://api.github.com/users/amadeuszpawlik/orgs",
      "repos_url": "https://api.github.com/users/amadeuszpawlik/repos",
      "events_url": "https://api.github.com/users/amadeuszpawlik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amadeuszpawlik/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amadeuszpawlik",
      "id": 35263201,
      "node_id": "MDQ6VXNlcjM1MjYzMjAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/35263201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amadeuszpawlik",
      "html_url": "https://github.com/amadeuszpawlik",
      "followers_url": "https://api.github.com/users/amadeuszpawlik/followers",
      "following_url": "https://api.github.com/users/amadeuszpawlik/following{/other_user}",
      "gists_url": "https://api.github.com/users/amadeuszpawlik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amadeuszpawlik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amadeuszpawlik/subscriptions",
      "organizations_url": "https://api.github.com/users/amadeuszpawlik/orgs",
      "repos_url": "https://api.github.com/users/amadeuszpawlik/repos",
      "events_url": "https://api.github.com/users/amadeuszpawlik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amadeuszpawlik/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "42fedb4acd3cfa813059fcc3f96b2a41f78d9074",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42fedb4acd3cfa813059fcc3f96b2a41f78d9074",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/42fedb4acd3cfa813059fcc3f96b2a41f78d9074"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 24,
      "deletions": 3
    },
    "files": [
      {
        "sha": "eb94aa537c236e470ee8e3e0712915e6de15cf32",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79fd28cacbbcb86ea03d3d468845001f84a76de3/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79fd28cacbbcb86ea03d3d468845001f84a76de3/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=79fd28cacbbcb86ea03d3d468845001f84a76de3",
        "patch": "@@ -229,6 +229,12 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool gr\n     assert(ret);\n     secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, vchSig.data(), &nSigLen, &sig);\n     vchSig.resize(nSigLen);\n+    // Additional verification step to prevent using a potentially corrupted signature\n+    secp256k1_pubkey pk;\n+    ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &pk, begin());\n+    assert(ret);\n+    ret = secp256k1_ecdsa_verify(GetVerifyContext(), &sig, hash.begin(), &pk);\n+    assert(ret);\n     return true;\n }\n \n@@ -251,13 +257,21 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n         return false;\n     vchSig.resize(CPubKey::COMPACT_SIGNATURE_SIZE);\n     int rec = -1;\n-    secp256k1_ecdsa_recoverable_signature sig;\n-    int ret = secp256k1_ecdsa_sign_recoverable(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, nullptr);\n+    secp256k1_ecdsa_recoverable_signature rsig;\n+    int ret = secp256k1_ecdsa_sign_recoverable(secp256k1_context_sign, &rsig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, nullptr);\n     assert(ret);\n-    ret = secp256k1_ecdsa_recoverable_signature_serialize_compact(secp256k1_context_sign, &vchSig[1], &rec, &sig);\n+    ret = secp256k1_ecdsa_recoverable_signature_serialize_compact(secp256k1_context_sign, &vchSig[1], &rec, &rsig);\n     assert(ret);\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n+    // Additional verification step to prevent using a potentially corrupted signature\n+    secp256k1_pubkey epk, rpk;\n+    ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &epk, begin());\n+    assert(ret);\n+    ret = secp256k1_ecdsa_recover(GetVerifyContext(), &rpk, &rsig, hash.begin());\n+    assert(ret);\n+    ret = secp256k1_ec_pubkey_cmp(GetVerifyContext(), &epk, &rpk);\n+    assert(ret == 0);\n     return true;\n }\n \n@@ -275,6 +289,13 @@ bool CKey::SignSchnorr(const uint256& hash, Span<unsigned char> sig, const uint2\n         if (!secp256k1_keypair_xonly_tweak_add(GetVerifyContext(), &keypair, tweak.data())) return false;\n     }\n     bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, aux ? (unsigned char*)aux->data() : nullptr);\n+    if (ret) {\n+        // Additional verification step to prevent using a potentially corrupted signature\n+        secp256k1_xonly_pubkey pubkey_verify;\n+        ret = secp256k1_keypair_xonly_pub(GetVerifyContext(), &pubkey_verify, nullptr, &keypair);\n+        ret &= secp256k1_schnorrsig_verify(GetVerifyContext(), sig.data(), hash.begin(), 32, &pubkey_verify);\n+    }\n+    if (!ret) memory_cleanse(sig.data(), sig.size());\n     memory_cleanse(&keypair, sizeof(keypair));\n     return ret;\n }"
      }
    ]
  }
]