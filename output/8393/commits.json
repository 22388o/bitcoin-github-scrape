[
  {
    "sha": "06128da751371797683eabb577298a4966b2ce28",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjEyOGRhNzUxMzcxNzk3NjgzZWFiYjU3NzI5OGE0OTY2YjJjZTI4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-03T17:00:14Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T16:24:10Z"
      },
      "message": "Make GetFetchFlags always request witness objects from witness peers\n\nThis fixes a bug where we might (in exceedingly rare circumstances)\naccidentally ban a node for sending us the first (potentially few)\nsegwit blocks in non-segwit mode.",
      "tree": {
        "sha": "278be3e422c3eba73e3df7dae463bc62b4938c0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/278be3e422c3eba73e3df7dae463bc62b4938c0a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06128da751371797683eabb577298a4966b2ce28",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06128da751371797683eabb577298a4966b2ce28",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06128da751371797683eabb577298a4966b2ce28",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06128da751371797683eabb577298a4966b2ce28/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7615af34e8e19920ed12bfdafb09e0e4b57c7c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7615af34e8e19920ed12bfdafb09e0e4b57c7c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7615af34e8e19920ed12bfdafb09e0e4b57c7c5"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "40c31b6ca6c76ef3f8d301ababdd533acda01a4a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06128da751371797683eabb577298a4966b2ce28/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06128da751371797683eabb577298a4966b2ce28/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=06128da751371797683eabb577298a4966b2ce28",
        "patch": "@@ -4922,7 +4922,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n \n uint32_t GetFetchFlags(CNode* pfrom, CBlockIndex* pprev, const Consensus::Params& chainparams) {\n     uint32_t nFetchFlags = 0;\n-    if (IsWitnessEnabled(pprev, chainparams) && State(pfrom->GetId())->fHaveWitness) {\n+    if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n     }\n     return nFetchFlags;"
      }
    ]
  },
  {
    "sha": "be7555f0c03057bb5537cc42ca9d4937389f0670",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTc1NTVmMGMwMzA1N2JiNTUzN2NjNDJjYTlkNDkzNzM4OWYwNjcw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-03T17:33:07Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T16:24:10Z"
      },
      "message": "Fix overly-prescriptive p2p-segwit test for new fetch logic",
      "tree": {
        "sha": "dd930b0b7c78cf8ef44a8af3f93db14df66ba5bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dd930b0b7c78cf8ef44a8af3f93db14df66ba5bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be7555f0c03057bb5537cc42ca9d4937389f0670",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be7555f0c03057bb5537cc42ca9d4937389f0670",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be7555f0c03057bb5537cc42ca9d4937389f0670",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be7555f0c03057bb5537cc42ca9d4937389f0670/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06128da751371797683eabb577298a4966b2ce28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06128da751371797683eabb577298a4966b2ce28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06128da751371797683eabb577298a4966b2ce28"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 1,
      "deletions": 9
    },
    "files": [
      {
        "sha": "c2ea20bb845c870552ac50d4c3c34b4870a3d4e3",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be7555f0c03057bb5537cc42ca9d4937389f0670/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be7555f0c03057bb5537cc42ca9d4937389f0670/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=be7555f0c03057bb5537cc42ca9d4937389f0670",
        "patch": "@@ -912,14 +912,6 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # But eliminating the witness should fix it\n         self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n \n-        # Verify that inv's to test_node come with getdata's for non-witness tx's\n-        # Just tweak the transaction, announce it, and verify we get a getdata\n-        # for a normal tx\n-        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n-        tx.rehash()\n-        self.test_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.test_node.last_getdata.inv[0].type == 1)\n-\n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n         assert_equal(len(self.nodes[0].getrawmempool()),  0)\n@@ -1025,7 +1017,7 @@ def test_tx_relay_after_segwit_activation(self):\n     def test_block_relay(self, segwit_activated):\n         print(\"\\tTesting block relay\")\n \n-        blocktype = 2|MSG_WITNESS_FLAG if segwit_activated else 2\n+        blocktype = 2|MSG_WITNESS_FLAG\n \n         # test_node has set NODE_WITNESS, so all getdata requests should be for\n         # witness blocks."
      }
    ]
  },
  {
    "sha": "6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YWEyOGFiZjUzZWY0Njk0NjkyNDc0YjRhM2IwYThmYTc1NTliNTBi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-25T17:17:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T17:10:41Z"
      },
      "message": "Use cmpctblock type 2 for segwit-enabled transfer\n\nContains version negotiation logic by Matt Corallo and bugfixes by\nSuhas Daftuar.",
      "tree": {
        "sha": "dca0f5961ecf9a1ddc75e642b5e862183f434fb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dca0f5961ecf9a1ddc75e642b5e862183f434fb9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be7555f0c03057bb5537cc42ca9d4937389f0670",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be7555f0c03057bb5537cc42ca9d4937389f0670",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be7555f0c03057bb5537cc42ca9d4937389f0670"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 64,
      "deletions": 30
    },
    "files": [
      {
        "sha": "93d3fa372b3c074b87400cfd43cb63c0cc7a52d2",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -17,15 +17,15 @@\n \n #define MIN_TRANSACTION_BASE_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS))\n \n-CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n         shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n     FillShortTxIDSelector();\n     //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n     prefilledtxn[0] = {0, block.vtx[0]};\n     for (size_t i = 1; i < block.vtx.size(); i++) {\n         const CTransaction& tx = block.vtx[i];\n-        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+        shorttxids[i - 1] = GetShortID(fUseWTXID ? tx.GetWitnessHash() : tx.GetHash());\n     }\n }\n "
      },
      {
        "sha": "99b1cb140d0a4c18484953d210b2d9d4bc16ec3c",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -146,7 +146,7 @@ class CBlockHeaderAndShortTxIDs {\n     // Dummy for deserialization\n     CBlockHeaderAndShortTxIDs() {}\n \n-    CBlockHeaderAndShortTxIDs(const CBlock& block);\n+    CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID);\n \n     uint64_t GetShortID(const uint256& txhash) const;\n "
      },
      {
        "sha": "c92a38be98f23f5bbdf59c8ee27b09f540d768a7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 22,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -289,10 +289,21 @@ struct CNodeState {\n     bool fPreferHeaders;\n     //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n     bool fPreferHeaderAndIDs;\n-    //! Whether this peer will send us cmpctblocks if we request them\n+    /**\n+      * Whether this peer will send us cmpctblocks if we request them.\n+      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n+      * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n+      */\n     bool fProvidesHeaderAndIDs;\n     //! Whether this peer can give us witnesses\n     bool fHaveWitness;\n+    //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n+    bool fWantsCmpctWitness;\n+    /**\n+     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n+     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n+     */\n+    bool fSupportsDesiredCmpctVersion;\n \n     CNodeState() {\n         fCurrentlyConnected = false;\n@@ -313,6 +324,8 @@ struct CNodeState {\n         fPreferHeaderAndIDs = false;\n         fProvidesHeaderAndIDs = false;\n         fHaveWitness = false;\n+        fWantsCmpctWitness = false;\n+        fSupportsDesiredCmpctVersion = false;\n     }\n };\n \n@@ -467,16 +480,16 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n }\n \n void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom, CConnman& connman) {\n-    if (pfrom->GetLocalServices() & NODE_WITNESS) {\n-        // Don't ever request compact blocks when segwit is enabled.\n+    if (!nodestate->fSupportsDesiredCmpctVersion) {\n+        // Never ask from peers who can't provide witnesses.\n         return;\n     }\n     if (nodestate->fProvidesHeaderAndIDs) {\n         BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n             if (nodeid == pfrom->GetId())\n                 return;\n         bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = 1;\n+        uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n         if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n             // As per BIP152, we only get 3 of our peers to announce\n             // blocks using compact encodings.\n@@ -4856,11 +4869,12 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // they wont have a useful mempool to match against a compact block,\n                         // and we don't feel like constructing the object for them, so\n                         // instead we respond with the full, non-compact block.\n+                        bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                         if (mi->second->nHeight >= chainActive.Height() - 10) {\n-                            CBlockHeaderAndShortTxIDs cmpctblock(block);\n-                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                            CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n+                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                         } else\n-                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -5128,13 +5142,16 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(NetMsgType::SENDHEADERS);\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n-            // Tell our peer we are willing to provide version-1 cmpctblocks\n+            // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n             // However, we do not request new block announcements using\n             // cmpctblock messages.\n             // We send this to non-NODE NETWORK peers as well, because\n             // they may wish to request compact blocks from us\n             bool fAnnounceUsingCMPCTBLOCK = false;\n-            uint64_t nCMPCTBLOCKVersion = 1;\n+            uint64_t nCMPCTBLOCKVersion = 2;\n+            if (pfrom->GetLocalServices() & NODE_WITNESS)\n+                pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+            nCMPCTBLOCKVersion = 1;\n             pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n         }\n     }\n@@ -5195,12 +5212,23 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     else if (strCommand == NetMsgType::SENDCMPCT)\n     {\n         bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = 1;\n+        uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1) {\n+        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n-            State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n-            State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n+            if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n+                State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n+                State(pfrom->GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            }\n+            if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n+                State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {\n+                if (pfrom->GetLocalServices() & NODE_WITNESS)\n+                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n+                else\n+                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+            }\n         }\n     }\n \n@@ -5258,7 +5286,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER &&\n                         (!IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                         inv.type |= nFetchFlags;\n-                        if (nodestate->fProvidesHeaderAndIDs && !(pfrom->GetLocalServices() & NODE_WITNESS))\n+                        if (nodestate->fSupportsDesiredCmpctVersion)\n                             vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n                         else\n                             vToFetch.push_back(inv);\n@@ -5386,7 +5414,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             resp.txn[i] = block.vtx[req.indexes[i]];\n         }\n-        pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n+        pfrom->PushMessageWithFlag(State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n     }\n \n \n@@ -5650,7 +5678,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                 pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n             }\n             return true;\n@@ -5662,6 +5690,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         CNodeState *nodestate = State(pfrom->GetId());\n \n+        if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n+            // Don't bother trying to process compact blocks from v1 peers\n+            // after segwit activates.\n+            return true;\n+        }\n+\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n@@ -5688,7 +5722,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                     pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n                     return true;\n                 }\n@@ -5715,7 +5749,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                 pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n                 return true;\n             } else {\n@@ -5757,7 +5791,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         } else if (status == READ_STATUS_FAILED) {\n             // Might have collided, fall back to getdata now :(\n             std::vector<CInv> invs;\n-            invs.push_back(CInv(MSG_BLOCK, resp.blockhash));\n+            invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n             pfrom->PushMessage(NetMsgType::GETDATA, invs);\n         } else {\n             CValidationState state;\n@@ -5906,7 +5940,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN) && !(pfrom->GetLocalServices() & NODE_WITNESS)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n                         // with this block! Let's get them to announce using compact blocks in the future.\n                         MaybeSetPeerAsAnnouncingHeaderAndIDs(nodestate, pfrom, connman);\n@@ -6536,8 +6570,8 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     //TODO: Shouldn't need to reload block from disk, but requires refactor\n                     CBlock block;\n                     assert(ReadBlockFromDisk(block, pBestIndex, consensusParams));\n-                    CBlockHeaderAndShortTxIDs cmpctblock(block);\n-                    pto->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                    CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n+                    pto->PushMessageWithFlag(state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {"
      },
      {
        "sha": "7530b013bd28517ce830cd14034e4e38c0f4d4ea",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -64,7 +64,7 @@ BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n \n     // Do a simple ShortTxIDs RT\n     {\n-        CBlockHeaderAndShortTxIDs shortIDs(block);\n+        CBlockHeaderAndShortTxIDs shortIDs(block, true);\n \n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n         stream << shortIDs;\n@@ -116,7 +116,7 @@ class TestHeaderAndShortIDs {\n         stream >> *this;\n     }\n     TestHeaderAndShortIDs(const CBlock& block) :\n-        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block)) {}\n+        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block, true)) {}\n \n     uint64_t GetShortID(const uint256& txhash) const {\n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n@@ -267,7 +267,7 @@ BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n \n     // Test simple header round-trip with only coinbase\n     {\n-        CBlockHeaderAndShortTxIDs shortIDs(block);\n+        CBlockHeaderAndShortTxIDs shortIDs(block, false);\n \n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n         stream << shortIDs;"
      },
      {
        "sha": "15fa6fbca3b09d41c23c9203d7371c08de874b2c",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -444,7 +444,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     totalTxSize += entry.GetTxSize();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n-    vTxHashes.emplace_back(hash, newit);\n+    vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n \n     return true;"
      },
      {
        "sha": "941644b2b21c1dbb729f6d5a9950c277c8b907d6",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6aa28abf53ef4694692474b4a3b0a8fa7559b50b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "patch": "@@ -465,7 +465,7 @@ class CTxMemPool\n     indexed_transaction_set mapTx;\n \n     typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n-    std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx hashes/entries in mapTx, in random order\n+    std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx witness hashes/entries in mapTx, in random order\n \n     struct CompareIteratorByHash {\n         bool operator()(const txiter &a, const txiter &b) const {"
      }
    ]
  },
  {
    "sha": "f5b9b8f437c040205896ad0d7a6656efa08b5601",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNWI5YjhmNDM3YzA0MDIwNTg5NmFkMGQ3YTY2NTZlZmEwOGI1NjAx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-18T02:11:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T17:10:49Z"
      },
      "message": "[qa] Fix bug in mininode witness deserialization\n\nAlso improve tx printing",
      "tree": {
        "sha": "45bf7ac6c8837f58becb3f50ac662ef6b2e6e7ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45bf7ac6c8837f58becb3f50ac662ef6b2e6e7ee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f5b9b8f437c040205896ad0d7a6656efa08b5601",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5b9b8f437c040205896ad0d7a6656efa08b5601",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f5b9b8f437c040205896ad0d7a6656efa08b5601",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5b9b8f437c040205896ad0d7a6656efa08b5601/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6aa28abf53ef4694692474b4a3b0a8fa7559b50b"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "34beb0d30d30ff1d2795ffea6b36977d3d69e3c4",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5b9b8f437c040205896ad0d7a6656efa08b5601/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5b9b8f437c040205896ad0d7a6656efa08b5601/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=f5b9b8f437c040205896ad0d7a6656efa08b5601",
        "patch": "@@ -452,7 +452,7 @@ def deserialize(self, f):\n         else:\n             self.vout = deser_vector(f, CTxOut)\n         if flags != 0:\n-            self.wit.vtxinwit = [CTxInWitness()]*len(self.vin)\n+            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n             self.wit.deserialize(f)\n         self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n         self.sha256 = None\n@@ -518,8 +518,8 @@ def is_valid(self):\n         return True\n \n     def __repr__(self):\n-        return \"CTransaction(nVersion=%i vin=%s vout=%s nLockTime=%i)\" \\\n-            % (self.nVersion, repr(self.vin), repr(self.vout), self.nLockTime)\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n \n \n class CBlockHeader(object):"
      }
    ]
  },
  {
    "sha": "422fac649f75c907cad6ab7e2768b9032b9eae42",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjJmYWM2NDlmNzVjOTA3Y2FkNmFiN2UyNzY4YjkwMzJiOWVhZTQy",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-15T01:00:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T17:10:49Z"
      },
      "message": "[qa] Add support for compactblocks v2 to mininode",
      "tree": {
        "sha": "1902dcb33a9c91d6655ac35de111b8672bb2f2fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1902dcb33a9c91d6655ac35de111b8672bb2f2fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/422fac649f75c907cad6ab7e2768b9032b9eae42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422fac649f75c907cad6ab7e2768b9032b9eae42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/422fac649f75c907cad6ab7e2768b9032b9eae42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422fac649f75c907cad6ab7e2768b9032b9eae42/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f5b9b8f437c040205896ad0d7a6656efa08b5601",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5b9b8f437c040205896ad0d7a6656efa08b5601",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f5b9b8f437c040205896ad0d7a6656efa08b5601"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 31,
      "deletions": 4
    },
    "files": [
      {
        "sha": "4d238c08d9c3fcd270725105bd8eabff2a28fadc",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/422fac649f75c907cad6ab7e2768b9032b9eae42/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/422fac649f75c907cad6ab7e2768b9032b9eae42/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=422fac649f75c907cad6ab7e2768b9032b9eae42",
        "patch": "@@ -755,6 +755,9 @@ def serialize(self, with_witness=False):\n             r += self.tx.serialize_without_witness()\n         return r\n \n+    def serialize_with_witness(self):\n+        return self.serialize(with_witness=True)\n+\n     def __repr__(self):\n         return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n \n@@ -779,6 +782,7 @@ def deserialize(self, f):\n         self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n         self.prefilled_txn_length = len(self.prefilled_txn)\n \n+    # When using version 2 compact blocks, we must serialize with_witness.\n     def serialize(self, with_witness=False):\n         r = b\"\"\n         r += self.header.serialize()\n@@ -787,12 +791,20 @@ def serialize(self, with_witness=False):\n         for x in self.shortids:\n             # We only want the first 6 bytes\n             r += struct.pack(\"<Q\", x)[0:6]\n-        r += ser_vector(self.prefilled_txn)\n+        if with_witness:\n+            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.prefilled_txn)\n         return r\n \n     def __repr__(self):\n         return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n \n+# P2P version of the above that will use witness serialization (for compact\n+# block version 2)\n+class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n+    def serialize(self):\n+        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n \n # Calculate the BIP 152-compact blocks shortid for a given transaction hash\n def calculate_shortid(k0, k1, tx_hash):\n@@ -808,6 +820,7 @@ def __init__(self, p2pheaders_and_shortids = None):\n         self.nonce = 0\n         self.shortids = []\n         self.prefilled_txn = []\n+        self.use_witness = False\n \n         if p2pheaders_and_shortids != None:\n             self.header = p2pheaders_and_shortids.header\n@@ -819,7 +832,10 @@ def __init__(self, p2pheaders_and_shortids = None):\n                 last_index = self.prefilled_txn[-1].index\n \n     def to_p2p(self):\n-        ret = P2PHeaderAndShortIDs()\n+        if self.use_witness:\n+            ret = P2PHeaderAndShortWitnessIDs()\n+        else:\n+            ret = P2PHeaderAndShortIDs()\n         ret.header = self.header\n         ret.nonce = self.nonce\n         ret.shortids_length = len(self.shortids)\n@@ -840,15 +856,20 @@ def get_siphash_keys(self):\n         key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n         return [ key0, key1 ]\n \n-    def initialize_from_block(self, block, nonce=0, prefill_list = [0]):\n+    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n         self.header = CBlockHeader(block)\n         self.nonce = nonce\n         self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n         self.shortids = []\n+        self.use_witness = use_witness\n         [k0, k1] = self.get_siphash_keys()\n         for i in range(len(block.vtx)):\n             if i not in prefill_list:\n-                self.shortids.append(calculate_shortid(k0, k1, block.vtx[i].sha256))\n+                tx_hash = block.vtx[i].sha256\n+                if use_witness:\n+                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n+                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n \n     def __repr__(self):\n         return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n@@ -1424,6 +1445,12 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n \n+class msg_witness_blocktxn(msg_blocktxn):\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize(with_witness=True)\n+        return r\n+\n # This is what a callback should look like for NodeConn\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):"
      }
    ]
  },
  {
    "sha": "27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyN2FjZmMxZDJlZTUzY2M1MmI1NGJlZmQyZDRiZmEyNGE3N2EyZWVm",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-17T00:48:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-04T17:10:49Z"
      },
      "message": "[qa] Update p2p-compactblocks.py for compactblocks v2",
      "tree": {
        "sha": "176c8355863249e3caaab03f445cd647c83b700b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/176c8355863249e3caaab03f445cd647c83b700b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "422fac649f75c907cad6ab7e2768b9032b9eae42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422fac649f75c907cad6ab7e2768b9032b9eae42",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/422fac649f75c907cad6ab7e2768b9032b9eae42"
      }
    ],
    "stats": {
      "total": 583,
      "additions": 389,
      "deletions": 194
    },
    "files": [
      {
        "sha": "d91e10d77cb4b96a74bc71da85f15ba5ee658176",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 389,
        "deletions": 194,
        "changes": 583,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
        "patch": "@@ -12,14 +12,16 @@\n \n '''\n CompactBlocksTest -- test compact blocks (BIP 152)\n-'''\n \n+Version 1 compact blocks are pre-segwit (txids)\n+Version 2 compact blocks are post-segwit (wtxids)\n+'''\n \n # TestNode: A peer we use to send messages to bitcoind, and store responses.\n class TestNode(SingleNodeConnCB):\n     def __init__(self):\n         SingleNodeConnCB.__init__(self)\n-        self.last_sendcmpct = None\n+        self.last_sendcmpct = []\n         self.last_headers = None\n         self.last_inv = None\n         self.last_cmpctblock = None\n@@ -30,7 +32,7 @@ def __init__(self):\n         self.last_blocktxn = None\n \n     def on_sendcmpct(self, conn, message):\n-        self.last_sendcmpct = message\n+        self.last_sendcmpct.append(message)\n \n     def on_block(self, conn, message):\n         self.last_block = message\n@@ -90,29 +92,31 @@ class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 1\n+        # Node0 = pre-segwit, node1 = segwit-aware\n+        self.num_nodes = 2\n         self.utxos = []\n \n     def setup_network(self):\n         self.nodes = []\n \n-        # Turn off segwit in this test, as compact blocks don't currently work\n-        # with segwit.  (After BIP 152 is updated to support segwit, we can\n-        # test behavior with and without segwit enabled by adding a second node\n-        # to the test.)\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"]])\n+        # Start up node0 to be a version 1, pre-segwit node.\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n+                [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"], \n+                 [\"-debug\", \"-logtimemicros\", \"-txindex\"]])\n+        connect_nodes(self.nodes[0], 1)\n \n-    def build_block_on_tip(self):\n-        height = self.nodes[0].getblockcount()\n-        tip = self.nodes[0].getbestblockhash()\n-        mtp = self.nodes[0].getblockheader(tip)['mediantime']\n+    def build_block_on_tip(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n         block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n         block.solve()\n         return block\n \n     # Create 10 more anyone-can-spend utxo's for testing.\n     def make_utxos(self):\n-        block = self.build_block_on_tip()\n+        # Doesn't matter which node we use, just use node0.\n+        block = self.build_block_on_tip(self.nodes[0])\n         self.test_node.send_and_ping(msg_block(block))\n         assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n         self.nodes[0].generate(100)\n@@ -125,7 +129,7 @@ def make_utxos(self):\n             tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n         tx.rehash()\n \n-        block2 = self.build_block_on_tip()\n+        block2 = self.build_block_on_tip(self.nodes[0])\n         block2.vtx.append(tx)\n         block2.hashMerkleRoot = block2.calc_merkle_root()\n         block2.solve()\n@@ -134,26 +138,30 @@ def make_utxos(self):\n         self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n         return\n \n-    # Test \"sendcmpct\":\n-    # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n-    #   sendcmpct is sent.\n-    # - If sendcmpct is sent with version > 1, the message is ignored.\n+    # Test \"sendcmpct\" (between peers preferring the same version):\n+    # - No compact block announcements unless sendcmpct is sent.\n+    # - If sendcmpct is sent with version > preferred_version, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n     # - If sendcmpct is then sent with boolean 1, then new block announcements\n     #   are made with compact blocks.\n-    def test_sendcmpct(self):\n-        print(\"Testing SENDCMPCT p2p message... \")\n-\n-        # Make sure we get a version 0 SENDCMPCT message from our peer\n+    # If old_node is passed in, request compact blocks with version=preferred-1\n+    # and verify that it receives block announcements via compact block.\n+    def test_sendcmpct(self, node, test_node, preferred_version, old_node=None):\n+        # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n-            return (self.test_node.last_sendcmpct is not None)\n+            return (len(test_node.last_sendcmpct) > 0)\n         got_message = wait_until(received_sendcmpct, timeout=30)\n         assert(received_sendcmpct())\n         assert(got_message)\n-        assert_equal(self.test_node.last_sendcmpct.version, 1)\n+        with mininode_lock:\n+            # Check that the first version received is the preferred one\n+            assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n+            # And that we receive versions down to 1.\n+            assert_equal(test_node.last_sendcmpct[-1].version, 1)\n+            test_node.last_sendcmpct = []\n \n-        tip = int(self.nodes[0].getbestblockhash(), 16)\n+        tip = int(node.getbestblockhash(), 16)\n \n         def check_announcement_of_new_block(node, peer, predicate):\n             peer.clear_block_announcement()\n@@ -165,56 +173,75 @@ def check_announcement_of_new_block(node, peer, predicate):\n                 assert(predicate(peer))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Try one more time, this time after requesting headers.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n+        test_node.request_headers_and_sync(locator=[tip])\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n \n         # Test a few ways of using sendcmpct that should NOT\n         # result in compact block announcements.\n         # Before each test, sync the headers chain.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n-        sendcmpct.version = 2\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        sendcmpct.version = preferred_version+1\n+        sendcmpct.announce = True\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Headers sync before next test.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with valid version, but announce=False\n-        self.test_node.send_and_ping(msg_sendcmpct())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        sendcmpct.version = preferred_version\n+        sendcmpct.announce = False\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Headers sync before next test.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Finally, try a SENDCMPCT message with announce=True\n-        sendcmpct.version = 1\n+        sendcmpct.version = preferred_version\n         sendcmpct.announce = True\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time (no headers sync should be needed!)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time, after turning on sendheaders\n-        self.test_node.send_and_ping(msg_sendheaders())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        test_node.send_and_ping(msg_sendheaders())\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+\n+        # Try one more time, after sending a version-1, announce=false message.\n+        sendcmpct.version = preferred_version-1\n+        sendcmpct.announce = False\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Now turn off announcements\n+        sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+\n+        if old_node is not None:\n+            # Verify that a peer using an older protocol version can receive\n+            # announcements from this node.\n+            sendcmpct.version = preferred_version-1\n+            sendcmpct.announce = True\n+            old_node.send_and_ping(sendcmpct)\n+            # Header sync\n+            old_node.request_headers_and_sync(locator=[tip])\n+            check_announcement_of_new_block(node, old_node, lambda p: p.last_cmpctblock is not None)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n-        print(\"Testing invalid index in cmpctblock message...\")\n         self.nodes[0].generate(101)\n-        block = self.build_block_on_tip()\n+        block = self.build_block_on_tip(self.nodes[0])\n \n         cmpct_block = P2PHeaderAndShortIDs()\n         cmpct_block.header = CBlockHeader(block)\n@@ -227,45 +254,61 @@ def test_invalid_cmpctblock_message(self):\n \n     # Compare the generated shortids to what we expect based on BIP 152, given\n     # bitcoind's choice of nonce.\n-    def test_compactblock_construction(self):\n-        print(\"Testing compactblock headers and shortIDs are correct...\")\n-\n+    def test_compactblock_construction(self, node, test_node, version, use_witness_address):\n         # Generate a bunch of transactions.\n-        self.nodes[0].generate(101)\n+        node.generate(101)\n         num_transactions = 25\n-        address = self.nodes[0].getnewaddress()\n+        address = node.getnewaddress()\n+        if use_witness_address:\n+            # Want at least one segwit spend, so move all funds to\n+            # a witness address.\n+            address = node.addwitnessaddress(address)\n+            value_to_send = node.getbalance()\n+            node.sendtoaddress(address, satoshi_round(value_to_send-Decimal(0.1)))\n+            node.generate(1)\n+\n+        segwit_tx_generated = False\n         for i in range(num_transactions):\n-            self.nodes[0].sendtoaddress(address, 0.1)\n+            txid = node.sendtoaddress(address, 0.1)\n+            hex_tx = node.gettransaction(txid)[\"hex\"]\n+            tx = FromHex(CTransaction(), hex_tx)\n+            if not tx.wit.is_null():\n+                segwit_tx_generated = True\n+\n+        if use_witness_address:\n+            assert(segwit_tx_generated) # check that our test is not broken\n \n         self.test_node.sync_with_ping()\n \n         # Now mine a block, and look at the resulting compact block.\n-        self.test_node.clear_block_announcement()\n-        block_hash = int(self.nodes[0].generate(1)[0], 16)\n+        test_node.clear_block_announcement()\n+        block_hash = int(node.generate(1)[0], 16)\n \n         # Store the raw block in our internal format.\n-        block = FromHex(CBlock(), self.nodes[0].getblock(\"%02x\" % block_hash, False))\n+        block = FromHex(CBlock(), node.getblock(\"%02x\" % block_hash, False))\n         [tx.calc_sha256() for tx in block.vtx]\n         block.rehash()\n \n         # Don't care which type of announcement came back for this test; just\n         # request the compact block if we didn't get one yet.\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        assert(test_node.received_block_announcement())\n \n         with mininode_lock:\n-            if self.test_node.last_cmpctblock is None:\n-                self.test_node.clear_block_announcement()\n+            if test_node.last_cmpctblock is None:\n+                test_node.clear_block_announcement()\n                 inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n-                self.test_node.send_message(msg_getdata([inv]))\n+                test_node.send_message(msg_getdata([inv]))\n \n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        assert(test_node.received_block_announcement())\n \n         # Now we should have the compactblock\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(self.test_node.last_cmpctblock is not None)\n+            assert(test_node.last_cmpctblock is not None)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(self.test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n \n         # Check that we got the right block!\n         header_and_shortids.header.calc_sha256()\n@@ -278,8 +321,17 @@ def test_compactblock_construction(self):\n         # Check that all prefilled_txn entries match what's in the block.\n         for entry in header_and_shortids.prefilled_txn:\n             entry.tx.calc_sha256()\n+            # This checks the non-witness parts of the tx agree\n             assert_equal(entry.tx.sha256, block.vtx[entry.index].sha256)\n \n+            # And this checks the witness\n+            wtxid = entry.tx.calc_sha256(True)\n+            if version == 2:\n+                assert_equal(wtxid, block.vtx[entry.index].calc_sha256(True))\n+            else:\n+                # Shouldn't have received a witness\n+                assert(entry.tx.wit.is_null())\n+\n         # Check that the cmpctblock message announced all the transactions.\n         assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n \n@@ -294,57 +346,61 @@ def test_compactblock_construction(self):\n                 # Already checked prefilled transactions above\n                 header_and_shortids.prefilled_txn.pop(0)\n             else:\n-                shortid = calculate_shortid(k0, k1, block.vtx[index].sha256)\n+                tx_hash = block.vtx[index].sha256\n+                if version == 2:\n+                    tx_hash = block.vtx[index].calc_sha256(True)\n+                shortid = calculate_shortid(k0, k1, tx_hash)\n                 assert_equal(shortid, header_and_shortids.shortids[0])\n                 header_and_shortids.shortids.pop(0)\n             index += 1\n \n     # Test that bitcoind requests compact blocks when we announce new blocks\n     # via header or inv, and that responding to getblocktxn causes the block\n     # to be successfully reconstructed.\n-    def test_compactblock_requests(self):\n-        print(\"Testing compactblock requests... \")\n-\n+    # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n+    # NODE_WITNESS peers.  Unupgraded nodes would still make this request of\n+    # any cb-version-1-supporting peer.\n+    def test_compactblock_requests(self, node, test_node):\n         # Try announcing a block with an inv or header, expect a compactblock\n         # request\n         for announce in [\"inv\", \"header\"]:\n-            block = self.build_block_on_tip()\n+            block = self.build_block_on_tip(node)\n             with mininode_lock:\n-                self.test_node.last_getdata = None\n+                test_node.last_getdata = None\n \n             if announce == \"inv\":\n-                self.test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n+                test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n             else:\n-                self.test_node.send_header_for_blocks([block])\n-            success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=30)\n+                test_node.send_header_for_blocks([block])\n+            success = wait_until(lambda: test_node.last_getdata is not None, timeout=30)\n             assert(success)\n-            assert_equal(len(self.test_node.last_getdata.inv), 1)\n-            assert_equal(self.test_node.last_getdata.inv[0].type, 4)\n-            assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+            assert_equal(len(test_node.last_getdata.inv), 1)\n+            assert_equal(test_node.last_getdata.inv[0].type, 4)\n+            assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n \n             # Send back a compactblock message that omits the coinbase\n             comp_block = HeaderAndShortIDs()\n             comp_block.header = CBlockHeader(block)\n             comp_block.nonce = 0\n             comp_block.shortids = [1]  # this is useless, and wrong\n-            self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+            test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+            assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n             with mininode_lock:\n-                assert(self.test_node.last_getblocktxn is not None)\n-                absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(test_node.last_getblocktxn is not None)\n+                absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n             msg = msg_blocktxn()\n             msg.block_transactions.blockhash = block.sha256\n             msg.block_transactions.transactions = [block.vtx[0]]\n-            self.test_node.send_and_ping(msg)\n-            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+            test_node.send_and_ping(msg)\n+            assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     # Create a chain of transactions from given utxo, and add to a new block.\n-    def build_block_with_transactions(self, utxo, num_transactions):\n-        block = self.build_block_on_tip()\n+    def build_block_with_transactions(self, node, utxo, num_transactions):\n+        block = self.build_block_on_tip(node)\n \n         for i in range(num_transactions):\n             tx = CTransaction()\n@@ -361,118 +417,113 @@ def build_block_with_transactions(self, utxo, num_transactions):\n     # Test that we only receive getblocktxn requests for transactions that the\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n-    def test_getblocktxn_requests(self):\n-        print(\"Testing getblocktxn requests...\")\n+    def test_getblocktxn_requests(self, node, test_node, version):\n+        with_witness = (version==2)\n+\n+        def test_getblocktxn_response(compact_block, peer, expected_result):\n+            msg = msg_cmpctblock(compact_block.to_p2p())\n+            peer.send_and_ping(msg)\n+            with mininode_lock:\n+                assert(peer.last_getblocktxn is not None)\n+                absolute_indexes = peer.last_getblocktxn.block_txn_request.to_absolute()\n+            assert_equal(absolute_indexes, expected_result)\n+\n+        def test_tip_after_message(node, peer, msg, tip):\n+            peer.send_and_ping(msg)\n+            assert_equal(int(node.getbestblockhash(), 16), tip)\n \n         # First try announcing compactblocks that won't reconstruct, and verify\n         # that we receive getblocktxn messages back.\n         utxo = self.utxos.pop(0)\n \n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n-\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block)\n+        comp_block.initialize_from_block(block, use_witness=with_witness)\n \n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [1, 2, 3, 4, 5])\n-        msg = msg_blocktxn()\n-        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        test_getblocktxn_response(comp_block, test_node, [1, 2, 3, 4, 5])\n+\n+        msg_bt = msg_blocktxn()\n+        if with_witness:\n+            msg_bt = msg_witness_blocktxn() # serialize with witnesses\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n \n         # Now try interspersing the prefilled transactions\n-        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [2, 3, 4])\n-        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5], use_witness=with_witness)\n+        test_getblocktxn_response(comp_block, test_node, [2, 3, 4])\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         # Now try giving one transaction ahead of time.\n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n-        self.test_node.send_and_ping(msg_tx(block.vtx[1]))\n-        assert(block.vtx[1].hash in self.nodes[0].getrawmempool())\n+        test_node.send_and_ping(msg_tx(block.vtx[1]))\n+        assert(block.vtx[1].hash in node.getrawmempool())\n \n         # Prefill 4 out of the 6 transactions, and verify that only the one\n         # that was not in the mempool is requested.\n-        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [5])\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4], use_witness=with_witness)\n+        test_getblocktxn_response(comp_block, test_node, [5])\n \n-        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         # Now provide all transactions to the node before the block is\n         # announced and verify reconstruction happens immediately.\n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 10)\n+        block = self.build_block_with_transactions(node, utxo, 10)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         for tx in block.vtx[1:]:\n-            self.test_node.send_message(msg_tx(tx))\n-        self.test_node.sync_with_ping()\n+            test_node.send_message(msg_tx(tx))\n+        test_node.sync_with_ping()\n         # Make sure all transactions were accepted.\n-        mempool = self.nodes[0].getrawmempool()\n+        mempool = node.getrawmempool()\n         for tx in block.vtx[1:]:\n             assert(tx.hash in mempool)\n \n         # Clear out last request.\n         with mininode_lock:\n-            self.test_node.last_getblocktxn = None\n+            test_node.last_getblocktxn = None\n \n         # Send compact block\n-        comp_block.initialize_from_block(block, prefill_list=[0])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)\n+        test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with mininode_lock:\n             # Shouldn't have gotten a request for any transaction\n-            assert(self.test_node.last_getblocktxn is None)\n-        # Tip should have updated\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+            assert(test_node.last_getblocktxn is None)\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n-    def test_incorrect_blocktxn_response(self):\n-        print(\"Testing handling of incorrect blocktxn responses...\")\n-\n+    def test_incorrect_blocktxn_response(self, node, test_node, version):\n         if (len(self.utxos) == 0):\n             self.make_utxos()\n         utxo = self.utxos.pop(0)\n \n-        block = self.build_block_with_transactions(utxo, 10)\n+        block = self.build_block_with_transactions(node, utxo, 10)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         # Relay the first 5 transactions from the block in advance\n         for tx in block.vtx[1:6]:\n-            self.test_node.send_message(msg_tx(tx))\n-        self.test_node.sync_with_ping()\n+            test_node.send_message(msg_tx(tx))\n+        test_node.sync_with_ping()\n         # Make sure all transactions were accepted.\n-        mempool = self.nodes[0].getrawmempool()\n+        mempool = node.getrawmempool()\n         for tx in block.vtx[1:6]:\n             assert(tx.hash in mempool)\n \n         # Send compact block\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, prefill_list=[0])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=(version == 2))\n+        test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert(test_node.last_getblocktxn is not None)\n+            absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n         # Now give an incorrect response.\n@@ -484,100 +535,107 @@ def test_incorrect_blocktxn_response(self):\n         # verifying that the block isn't marked bad permanently. This is good\n         # enough for now.\n         msg = msg_blocktxn()\n+        if version==2:\n+            msg = msg_witness_blocktxn()\n         msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n-        self.test_node.send_and_ping(msg)\n+        test_node.send_and_ping(msg)\n \n         # Tip should not have updated\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+        assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n \n         # We should receive a getdata request\n-        success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=10)\n+        success = wait_until(lambda: test_node.last_getdata is not None, timeout=10)\n         assert(success)\n-        assert_equal(len(self.test_node.last_getdata.inv), 1)\n-        assert_equal(self.test_node.last_getdata.inv[0].type, 2)\n-        assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+        assert_equal(len(test_node.last_getdata.inv), 1)\n+        assert(test_node.last_getdata.inv[0].type == 2 or test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n \n         # Deliver the block\n-        self.test_node.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n-\n-    def test_getblocktxn_handler(self):\n-        print(\"Testing getblocktxn handler...\")\n+        if version==2:\n+            test_node.send_and_ping(msg_witness_block(block))\n+        else:\n+            test_node.send_and_ping(msg_block(block))\n+        assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n+    def test_getblocktxn_handler(self, node, test_node, version):\n         # bitcoind won't respond for blocks whose height is more than 15 blocks\n         # deep.\n         MAX_GETBLOCKTXN_DEPTH = 15\n-        chain_height = self.nodes[0].getblockcount()\n+        chain_height = node.getblockcount()\n         current_height = chain_height\n         while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n-            block_hash = self.nodes[0].getblockhash(current_height)\n-            block = FromHex(CBlock(), self.nodes[0].getblock(block_hash, False))\n+            block_hash = node.getblockhash(current_height)\n+            block = FromHex(CBlock(), node.getblock(block_hash, False))\n \n             msg = msg_getblocktxn()\n             msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n-            self.test_node.send_message(msg)\n-            success = wait_until(lambda: self.test_node.last_blocktxn is not None, timeout=10)\n+            test_node.send_message(msg)\n+            success = wait_until(lambda: test_node.last_blocktxn is not None, timeout=10)\n             assert(success)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n-                assert_equal(self.test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                assert_equal(test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n                 all_indices = msg.block_txn_request.to_absolute()\n                 for index in all_indices:\n-                    tx = self.test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx = test_node.last_blocktxn.block_transactions.transactions.pop(0)\n                     tx.calc_sha256()\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n-                self.test_node.last_blocktxn = None\n+                    if version == 1:\n+                        # Witnesses should have been stripped\n+                        assert(tx.wit.is_null())\n+                    else:\n+                        # Check that the witness matches\n+                        assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n+                test_node.last_blocktxn = None\n             current_height -= 1\n \n         # Next request should be ignored, as we're past the allowed depth.\n-        block_hash = self.nodes[0].getblockhash(current_height)\n+        block_hash = node.getblockhash(current_height)\n         msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n-        self.test_node.send_and_ping(msg)\n+        test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert_equal(self.test_node.last_blocktxn, None)\n-\n-    def test_compactblocks_not_at_tip(self):\n-        print(\"Testing compactblock requests/announcements not at chain tip...\")\n+            assert_equal(test_node.last_blocktxn, None)\n \n+    def test_compactblocks_not_at_tip(self, node, test_node):\n         # Test that requesting old compactblocks doesn't work.\n         MAX_CMPCTBLOCK_DEPTH = 11\n         new_blocks = []\n         for i in range(MAX_CMPCTBLOCK_DEPTH):\n-            self.test_node.clear_block_announcement()\n-            new_blocks.append(self.nodes[0].generate(1)[0])\n-            wait_until(self.test_node.received_block_announcement, timeout=30)\n+            test_node.clear_block_announcement()\n+            new_blocks.append(node.generate(1)[0])\n+            wait_until(test_node.received_block_announcement, timeout=30)\n \n-        self.test_node.clear_block_announcement()\n-        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: self.test_node.last_cmpctblock is not None, timeout=30)\n+        test_node.clear_block_announcement()\n+        test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: test_node.last_cmpctblock is not None, timeout=30)\n         assert(success)\n \n-        self.test_node.clear_block_announcement()\n-        self.nodes[0].generate(1)\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n-        self.test_node.clear_block_announcement()\n-        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: self.test_node.last_block is not None, timeout=30)\n+        test_node.clear_block_announcement()\n+        node.generate(1)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        test_node.clear_block_announcement()\n+        test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: test_node.last_block is not None, timeout=30)\n         assert(success)\n         with mininode_lock:\n-            self.test_node.last_block.block.calc_sha256()\n-            assert_equal(self.test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+            test_node.last_block.block.calc_sha256()\n+            assert_equal(test_node.last_block.block.sha256, int(new_blocks[0], 16))\n \n         # Generate an old compactblock, and verify that it's not accepted.\n-        cur_height = self.nodes[0].getblockcount()\n-        hashPrevBlock = int(self.nodes[0].getblockhash(cur_height-5), 16)\n-        block = self.build_block_on_tip()\n+        cur_height = node.getblockcount()\n+        hashPrevBlock = int(node.getblockhash(cur_height-5), 16)\n+        block = self.build_block_on_tip(node)\n         block.hashPrevBlock = hashPrevBlock\n         block.solve()\n \n         comp_block = HeaderAndShortIDs()\n         comp_block.initialize_from_block(block)\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n \n-        tips = self.nodes[0].getchaintips()\n+        tips = node.getchaintips()\n         found = False\n         for x in tips:\n             if x[\"hash\"] == block.hash:\n@@ -591,18 +649,61 @@ def test_compactblocks_not_at_tip(self):\n         msg = msg_getblocktxn()\n         msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n         with mininode_lock:\n-            self.test_node.last_blocktxn = None\n-        self.test_node.send_and_ping(msg)\n+            test_node.last_blocktxn = None\n+        test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert(self.test_node.last_blocktxn is None)\n+            assert(test_node.last_blocktxn is None)\n+\n+    def activate_segwit(self, node):\n+        node.generate(144*3)\n+        assert_equal(get_bip9_status(node, \"segwit\")[\"status\"], 'active')\n+\n+    def test_end_to_end_block_relay(self, node, listeners):\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(node, utxo, 10)\n+\n+        [l.clear_block_announcement() for l in listeners]\n+\n+        # ToHex() won't serialize with witness, but this block has no witnesses\n+        # anyway. TODO: repeat this test with witness tx's to a segwit node.\n+        node.submitblock(ToHex(block))\n+\n+        for l in listeners:\n+            wait_until(lambda: l.received_block_announcement(), timeout=30)\n+        with mininode_lock:\n+            for l in listeners:\n+                assert(l.last_cmpctblock is not None)\n+                l.last_cmpctblock.header_and_shortids.header.calc_sha256()\n+                assert_equal(l.last_cmpctblock.header_and_shortids.header.sha256, block.sha256)\n+\n+    # Helper for enabling cb announcements\n+    # Send the sendcmpct request and sync headers\n+    def request_cb_announcements(self, peer, node, version):\n+        tip = node.getbestblockhash()\n+        peer.get_headers(locator=[int(tip, 16)], hashstop=0)\n+\n+        msg = msg_sendcmpct()\n+        msg.version = version\n+        msg.announce = True\n+        peer.send_and_ping(msg)\n+\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.test_node = TestNode()\n+        self.segwit_node = TestNode()\n+        self.old_node = TestNode()  # version 1 peer <--> segwit node\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n+                    self.segwit_node, services=NODE_NETWORK|NODE_WITNESS))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n+                    self.old_node, services=NODE_NETWORK))\n         self.test_node.add_connection(connections[0])\n+        self.segwit_node.add_connection(connections[1])\n+        self.old_node.add_connection(connections[2])\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n@@ -612,13 +713,107 @@ def run_test(self):\n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n-        self.test_sendcmpct()\n-        self.test_compactblock_construction()\n-        self.test_compactblock_requests()\n-        self.test_getblocktxn_requests()\n-        self.test_getblocktxn_handler()\n-        self.test_compactblocks_not_at_tip()\n-        self.test_incorrect_blocktxn_response()\n+        print(\"Running tests, pre-segwit activation:\")\n+\n+        print(\"\\tTesting SENDCMPCT p2p message... \")\n+        self.test_sendcmpct(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_sendcmpct(self.nodes[1], self.segwit_node, 2, old_node=self.old_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock construction...\")\n+        self.test_compactblock_construction(self.nodes[0], self.test_node, 1, False)\n+        sync_blocks(self.nodes)\n+        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, False)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests... \")\n+        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+        sync_blocks(self.nodes)\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn requests...\")\n+        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn handler...\")\n+        self.test_getblocktxn_handler(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n+        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests/announcements not at chain tip...\")\n+        self.test_compactblocks_not_at_tip(self.nodes[0], self.test_node)\n+        sync_blocks(self.nodes)\n+        self.test_compactblocks_not_at_tip(self.nodes[1], self.segwit_node)\n+        self.test_compactblocks_not_at_tip(self.nodes[1], self.old_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting handling of incorrect blocktxn responses...\")\n+        self.test_incorrect_blocktxn_response(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_incorrect_blocktxn_response(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        # End-to-end block relay tests\n+        print(\"\\tTesting end-to-end block relay...\")\n+        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n+        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n+        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n+        self.test_end_to_end_block_relay(self.nodes[0], [self.segwit_node, self.test_node, self.old_node])\n+        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n+\n+        # Advance to segwit activation\n+        print (\"\\nAdvancing to segwit activation\\n\")\n+        self.activate_segwit(self.nodes[1])\n+        print (\"Running tests, post-segwit activation...\")\n+\n+        print(\"\\tTesting compactblock construction...\")\n+        self.test_compactblock_construction(self.nodes[1], self.old_node, 1, True)\n+        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, True)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests (unupgraded node)... \")\n+        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+\n+        print(\"\\tTesting getblocktxn requests (unupgraded node)...\")\n+        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n+\n+        # Need to manually sync node0 and node1, because post-segwit activation,\n+        # node1 will not download blocks from node0.\n+        print(\"\\tSyncing nodes...\")\n+        assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n+        while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n+            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount()+1)\n+            self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n+        assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n+\n+        print(\"\\tTesting compactblock requests (segwit node)... \")\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+\n+        print(\"\\tTesting getblocktxn requests (segwit node)...\")\n+        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn handler (segwit node should return witnesses)...\")\n+        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n+        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n+\n+        # Test that if we submitblock to node1, we'll get a compact block\n+        # announcement to all peers.\n+        # (Post-segwit activation, blocks won't propagate from node0 to node1\n+        # automatically, so don't bother testing a block announced to node0.)\n+        print(\"\\tTesting end-to-end block relay...\")\n+        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n+        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n+        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n+        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n+\n+        print(\"\\tTesting invalid index in cmpctblock message...\")\n         self.test_invalid_cmpctblock_message()\n \n "
      }
    ]
  }
]