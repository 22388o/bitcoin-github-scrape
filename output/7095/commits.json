[
  {
    "sha": "4ec3561eb3473638230ef780b41343bc6284b460",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWMzNTYxZWIzNDczNjM4MjMwZWY3ODBiNDEzNDNiYzYyODRiNDYw",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-25T12:19:48Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-25T12:59:49Z"
      },
      "message": "Replace scriptnum_test's normative ScriptNum implementation\n\nCompare against the scriptnum from Bitcoin Core 0.10 instead of OpenSSL.\nCloses #7086.",
      "tree": {
        "sha": "b56e639d4133bbd1818fc9e97a354f124b993c38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b56e639d4133bbd1818fc9e97a354f124b993c38"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ec3561eb3473638230ef780b41343bc6284b460",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec3561eb3473638230ef780b41343bc6284b460",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ec3561eb3473638230ef780b41343bc6284b460",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec3561eb3473638230ef780b41343bc6284b460/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b2ddc558e1cddb5ff54fd2d9e375793021a908e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b2ddc558e1cddb5ff54fd2d9e375793021a908e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b2ddc558e1cddb5ff54fd2d9e375793021a908e"
      }
    ],
    "stats": {
      "total": 406,
      "additions": 206,
      "deletions": 200
    },
    "files": [
      {
        "sha": "fafc1a294473bffa39246debabb9c00a05995ec3",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec3561eb3473638230ef780b41343bc6284b460/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec3561eb3473638230ef780b41343bc6284b460/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=4ec3561eb3473638230ef780b41343bc6284b460",
        "patch": "@@ -35,7 +35,7 @@ GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.r\n \n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n-  test/bignum.h \\\n+  test/scriptnum10.h \\\n   test/addrman_tests.cpp \\\n   test/alert_tests.cpp \\\n   test/allocator_tests.cpp \\"
      },
      {
        "sha": "e7aeee9db606c870315542a50dca96b9eb7e2ff7",
        "filename": "src/test/bignum.h",
        "status": "removed",
        "additions": 0,
        "deletions": 180,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2ddc558e1cddb5ff54fd2d9e375793021a908e/src/test/bignum.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2ddc558e1cddb5ff54fd2d9e375793021a908e/src/test/bignum.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bignum.h?ref=2b2ddc558e1cddb5ff54fd2d9e375793021a908e",
        "patch": "@@ -1,180 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_TEST_BIGNUM_H\n-#define BITCOIN_TEST_BIGNUM_H\n-\n-#include <algorithm>\n-#include <limits>\n-#include <stdexcept>\n-#include <stdint.h>\n-#include <string>\n-#include <vector>\n-\n-#include <openssl/bn.h>\n-\n-class bignum_error : public std::runtime_error\n-{\n-public:\n-    explicit bignum_error(const std::string& str) : std::runtime_error(str) {}\n-};\n-\n-\n-/** C++ wrapper for BIGNUM (OpenSSL bignum) */\n-class CBigNum : public BIGNUM\n-{\n-public:\n-    CBigNum()\n-    {\n-        BN_init(this);\n-    }\n-\n-    CBigNum(const CBigNum& b)\n-    {\n-        BN_init(this);\n-        if (!BN_copy(this, &b))\n-        {\n-            BN_clear_free(this);\n-            throw bignum_error(\"CBigNum::CBigNum(const CBigNum&): BN_copy failed\");\n-        }\n-    }\n-\n-    CBigNum& operator=(const CBigNum& b)\n-    {\n-        if (!BN_copy(this, &b))\n-            throw bignum_error(\"CBigNum::operator=: BN_copy failed\");\n-        return (*this);\n-    }\n-\n-    ~CBigNum()\n-    {\n-        BN_clear_free(this);\n-    }\n-\n-    CBigNum(long long n)          { BN_init(this); setint64(n); }\n-\n-    explicit CBigNum(const std::vector<unsigned char>& vch)\n-    {\n-        BN_init(this);\n-        setvch(vch);\n-    }\n-\n-    int getint() const\n-    {\n-        BN_ULONG n = BN_get_word(this);\n-        if (!BN_is_negative(this))\n-            return (n > (BN_ULONG)std::numeric_limits<int>::max() ? std::numeric_limits<int>::max() : n);\n-        else\n-            return (n > (BN_ULONG)std::numeric_limits<int>::max() ? std::numeric_limits<int>::min() : -(int)n);\n-    }\n-\n-    void setint64(int64_t sn)\n-    {\n-        unsigned char pch[sizeof(sn) + 6];\n-        unsigned char* p = pch + 4;\n-        bool fNegative;\n-        uint64_t n;\n-\n-        if (sn < (int64_t)0)\n-        {\n-            // Since the minimum signed integer cannot be represented as positive so long as its type is signed, \n-            // and it's not well-defined what happens if you make it unsigned before negating it,\n-            // we instead increment the negative integer by 1, convert it, then increment the (now positive) unsigned integer by 1 to compensate\n-            n = -(sn + 1);\n-            ++n;\n-            fNegative = true;\n-        } else {\n-            n = sn;\n-            fNegative = false;\n-        }\n-\n-        bool fLeadingZeroes = true;\n-        for (int i = 0; i < 8; i++)\n-        {\n-            unsigned char c = (n >> 56) & 0xff;\n-            n <<= 8;\n-            if (fLeadingZeroes)\n-            {\n-                if (c == 0)\n-                    continue;\n-                if (c & 0x80)\n-                    *p++ = (fNegative ? 0x80 : 0);\n-                else if (fNegative)\n-                    c |= 0x80;\n-                fLeadingZeroes = false;\n-            }\n-            *p++ = c;\n-        }\n-        unsigned int nSize = p - (pch + 4);\n-        pch[0] = (nSize >> 24) & 0xff;\n-        pch[1] = (nSize >> 16) & 0xff;\n-        pch[2] = (nSize >> 8) & 0xff;\n-        pch[3] = (nSize) & 0xff;\n-        BN_mpi2bn(pch, p - pch, this);\n-    }\n-\n-    void setvch(const std::vector<unsigned char>& vch)\n-    {\n-        std::vector<unsigned char> vch2(vch.size() + 4);\n-        unsigned int nSize = vch.size();\n-        // BIGNUM's byte stream format expects 4 bytes of\n-        // big endian size data info at the front\n-        vch2[0] = (nSize >> 24) & 0xff;\n-        vch2[1] = (nSize >> 16) & 0xff;\n-        vch2[2] = (nSize >> 8) & 0xff;\n-        vch2[3] = (nSize >> 0) & 0xff;\n-        // swap data to big endian\n-        reverse_copy(vch.begin(), vch.end(), vch2.begin() + 4);\n-        BN_mpi2bn(&vch2[0], vch2.size(), this);\n-    }\n-\n-    std::vector<unsigned char> getvch() const\n-    {\n-        unsigned int nSize = BN_bn2mpi(this, NULL);\n-        if (nSize <= 4)\n-            return std::vector<unsigned char>();\n-        std::vector<unsigned char> vch(nSize);\n-        BN_bn2mpi(this, &vch[0]);\n-        vch.erase(vch.begin(), vch.begin() + 4);\n-        reverse(vch.begin(), vch.end());\n-        return vch;\n-    }\n-\n-    friend inline const CBigNum operator-(const CBigNum& a, const CBigNum& b);\n-};\n-\n-\n-\n-inline const CBigNum operator+(const CBigNum& a, const CBigNum& b)\n-{\n-    CBigNum r;\n-    if (!BN_add(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator+: BN_add failed\");\n-    return r;\n-}\n-\n-inline const CBigNum operator-(const CBigNum& a, const CBigNum& b)\n-{\n-    CBigNum r;\n-    if (!BN_sub(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator-: BN_sub failed\");\n-    return r;\n-}\n-\n-inline const CBigNum operator-(const CBigNum& a)\n-{\n-    CBigNum r(a);\n-    BN_set_negative(&r, !BN_is_negative(&r));\n-    return r;\n-}\n-\n-inline bool operator==(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) == 0); }\n-inline bool operator!=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) != 0); }\n-inline bool operator<=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) <= 0); }\n-inline bool operator>=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) >= 0); }\n-inline bool operator<(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) < 0); }\n-inline bool operator>(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) > 0); }\n-\n-#endif // BITCOIN_TEST_BIGNUM_H"
      },
      {
        "sha": "00419746b7ebfc946ee74ab9f14d65472f9e3902",
        "filename": "src/test/scriptnum10.h",
        "status": "added",
        "additions": 183,
        "deletions": 0,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec3561eb3473638230ef780b41343bc6284b460/src/test/scriptnum10.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec3561eb3473638230ef780b41343bc6284b460/src/test/scriptnum10.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum10.h?ref=4ec3561eb3473638230ef780b41343bc6284b460",
        "patch": "@@ -0,0 +1,183 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_SCRIPTNUM10_H\n+#define BITCOIN_TEST_SCRIPTNUM10_H\n+\n+#include <algorithm>\n+#include <limits>\n+#include <stdexcept>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+#include \"assert.h\"\n+\n+class scriptnum10_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum10_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum10\n+{\n+/**\n+ * The ScriptNum implementation from Bitcoin Core 0.10.0, for cross-comparison.\n+ */\n+public:\n+\n+    explicit CScriptNum10(const int64_t& n)\n+    {\n+        m_value = n;\n+    }\n+\n+    static const size_t nDefaultMaxNumSize = 4;\n+\n+    explicit CScriptNum10(const std::vector<unsigned char>& vch, bool fRequireMinimal,\n+                        const size_t nMaxNumSize = nDefaultMaxNumSize)\n+    {\n+        if (vch.size() > nMaxNumSize) {\n+            throw scriptnum10_error(\"script number overflow\");\n+        }\n+        if (fRequireMinimal && vch.size() > 0) {\n+            // Check that the number is encoded with the minimum possible\n+            // number of bytes.\n+            //\n+            // If the most-significant-byte - excluding the sign bit - is zero\n+            // then we're not minimal. Note how this test also rejects the\n+            // negative-zero encoding, 0x80.\n+            if ((vch.back() & 0x7f) == 0) {\n+                // One exception: if there's more than one byte and the most\n+                // significant bit of the second-most-significant-byte is set\n+                // it would conflict with the sign bit. An example of this case\n+                // is +-255, which encode to 0xff00 and 0xff80 respectively.\n+                // (big-endian).\n+                if (vch.size() <= 1 || (vch[vch.size() - 2] & 0x80) == 0) {\n+                    throw scriptnum10_error(\"non-minimally encoded script number\");\n+                }\n+            }\n+        }\n+        m_value = set_vch(vch);\n+    }\n+\n+    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+    inline bool operator==(const CScriptNum10& rhs) const { return operator==(rhs.m_value); }\n+    inline bool operator!=(const CScriptNum10& rhs) const { return operator!=(rhs.m_value); }\n+    inline bool operator<=(const CScriptNum10& rhs) const { return operator<=(rhs.m_value); }\n+    inline bool operator< (const CScriptNum10& rhs) const { return operator< (rhs.m_value); }\n+    inline bool operator>=(const CScriptNum10& rhs) const { return operator>=(rhs.m_value); }\n+    inline bool operator> (const CScriptNum10& rhs) const { return operator> (rhs.m_value); }\n+\n+    inline CScriptNum10 operator+(   const int64_t& rhs)    const { return CScriptNum10(m_value + rhs);}\n+    inline CScriptNum10 operator-(   const int64_t& rhs)    const { return CScriptNum10(m_value - rhs);}\n+    inline CScriptNum10 operator+(   const CScriptNum10& rhs) const { return operator+(rhs.m_value);   }\n+    inline CScriptNum10 operator-(   const CScriptNum10& rhs) const { return operator-(rhs.m_value);   }\n+\n+    inline CScriptNum10& operator+=( const CScriptNum10& rhs)       { return operator+=(rhs.m_value);  }\n+    inline CScriptNum10& operator-=( const CScriptNum10& rhs)       { return operator-=(rhs.m_value);  }\n+\n+    inline CScriptNum10 operator-()                         const\n+    {\n+        assert(m_value != std::numeric_limits<int64_t>::min());\n+        return CScriptNum10(-m_value);\n+    }\n+\n+    inline CScriptNum10& operator=( const int64_t& rhs)\n+    {\n+        m_value = rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum10& operator+=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n+                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n+        m_value += rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum10& operator-=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n+                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n+        m_value -= rhs;\n+        return *this;\n+    }\n+\n+    int getint() const\n+    {\n+        if (m_value > std::numeric_limits<int>::max())\n+            return std::numeric_limits<int>::max();\n+        else if (m_value < std::numeric_limits<int>::min())\n+            return std::numeric_limits<int>::min();\n+        return m_value;\n+    }\n+\n+    std::vector<unsigned char> getvch() const\n+    {\n+        return serialize(m_value);\n+    }\n+\n+    static std::vector<unsigned char> serialize(const int64_t& value)\n+    {\n+        if(value == 0)\n+            return std::vector<unsigned char>();\n+\n+        std::vector<unsigned char> result;\n+        const bool neg = value < 0;\n+        uint64_t absvalue = neg ? -value : value;\n+\n+        while(absvalue)\n+        {\n+            result.push_back(absvalue & 0xff);\n+            absvalue >>= 8;\n+        }\n+\n+//    - If the most significant byte is >= 0x80 and the value is positive, push a\n+//    new zero-byte to make the significant byte < 0x80 again.\n+\n+//    - If the most significant byte is >= 0x80 and the value is negative, push a\n+//    new 0x80 byte that will be popped off when converting to an integral.\n+\n+//    - If the most significant byte is < 0x80 and the value is negative, add\n+//    0x80 to it, since it will be subtracted and interpreted as a negative when\n+//    converting to an integral.\n+\n+        if (result.back() & 0x80)\n+            result.push_back(neg ? 0x80 : 0);\n+        else if (neg)\n+            result.back() |= 0x80;\n+\n+        return result;\n+    }\n+\n+private:\n+    static int64_t set_vch(const std::vector<unsigned char>& vch)\n+    {\n+      if (vch.empty())\n+          return 0;\n+\n+      int64_t result = 0;\n+      for (size_t i = 0; i != vch.size(); ++i)\n+          result |= static_cast<int64_t>(vch[i]) << 8*i;\n+\n+      // If the input vector's most significant byte is 0x80, remove it from\n+      // the result's msb and return a negative.\n+      if (vch.back() & 0x80)\n+          return -((int64_t)(result & ~(0x80ULL << (8 * (vch.size() - 1)))));\n+\n+      return result;\n+    }\n+\n+    int64_t m_value;\n+};\n+\n+\n+#endif // BITCOIN_TEST_BIGNUM_H"
      },
      {
        "sha": "2405ab3ffc0dcba7e8559c8de741ada8102a9174",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 19,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec3561eb3473638230ef780b41343bc6284b460/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec3561eb3473638230ef780b41343bc6284b460/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=4ec3561eb3473638230ef780b41343bc6284b460",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"bignum.h\"\n+#include \"scriptnum10.h\"\n #include \"script/script.h\"\n #include \"test/test_bitcoin.h\"\n \n@@ -16,45 +16,48 @@ static const int64_t values[] = \\\n { 0, 1, CHAR_MIN, CHAR_MAX, UCHAR_MAX, SHRT_MIN, USHRT_MAX, INT_MIN, INT_MAX, UINT_MAX, LONG_MIN, LONG_MAX };\n static const int64_t offsets[] = { 1, 0x79, 0x80, 0x81, 0xFF, 0x7FFF, 0x8000, 0xFFFF, 0x10000};\n \n-static bool verify(const CBigNum& bignum, const CScriptNum& scriptnum)\n+static bool verify(const CScriptNum10& bignum, const CScriptNum& scriptnum)\n {\n     return bignum.getvch() == scriptnum.getvch() && bignum.getint() == scriptnum.getint();\n }\n \n static void CheckCreateVch(const int64_t& num)\n {\n-    CBigNum bignum(num);\n+    CScriptNum10 bignum(num);\n     CScriptNum scriptnum(num);\n     BOOST_CHECK(verify(bignum, scriptnum));\n \n-    CBigNum bignum2(bignum.getvch());\n+    std::vector<unsigned char> vch = bignum.getvch();\n+\n+    CScriptNum10 bignum2(bignum.getvch(), false);\n+    vch = scriptnum.getvch();\n     CScriptNum scriptnum2(scriptnum.getvch(), false);\n     BOOST_CHECK(verify(bignum2, scriptnum2));\n \n-    CBigNum bignum3(scriptnum2.getvch());\n+    CScriptNum10 bignum3(scriptnum2.getvch(), false);\n     CScriptNum scriptnum3(bignum2.getvch(), false);\n     BOOST_CHECK(verify(bignum3, scriptnum3));\n }\n \n static void CheckCreateInt(const int64_t& num)\n {\n-    CBigNum bignum(num);\n+    CScriptNum10 bignum(num);\n     CScriptNum scriptnum(num);\n     BOOST_CHECK(verify(bignum, scriptnum));\n-    BOOST_CHECK(verify(bignum.getint(), CScriptNum(scriptnum.getint())));\n-    BOOST_CHECK(verify(scriptnum.getint(), CScriptNum(bignum.getint())));\n-    BOOST_CHECK(verify(CBigNum(scriptnum.getint()).getint(), CScriptNum(CScriptNum(bignum.getint()).getint())));\n+    BOOST_CHECK(verify(CScriptNum10(bignum.getint()), CScriptNum(scriptnum.getint())));\n+    BOOST_CHECK(verify(CScriptNum10(scriptnum.getint()), CScriptNum(bignum.getint())));\n+    BOOST_CHECK(verify(CScriptNum10(CScriptNum10(scriptnum.getint()).getint()), CScriptNum(CScriptNum(bignum.getint()).getint())));\n }\n \n \n static void CheckAdd(const int64_t& num1, const int64_t& num2)\n {\n-    const CBigNum bignum1(num1);\n-    const CBigNum bignum2(num2);\n+    const CScriptNum10 bignum1(num1);\n+    const CScriptNum10 bignum2(num2);\n     const CScriptNum scriptnum1(num1);\n     const CScriptNum scriptnum2(num2);\n-    CBigNum bignum3(num1);\n-    CBigNum bignum4(num1);\n+    CScriptNum10 bignum3(num1);\n+    CScriptNum10 bignum4(num1);\n     CScriptNum scriptnum3(num1);\n     CScriptNum scriptnum4(num1);\n \n@@ -71,7 +74,7 @@ static void CheckAdd(const int64_t& num1, const int64_t& num2)\n \n static void CheckNegate(const int64_t& num)\n {\n-    const CBigNum bignum(num);\n+    const CScriptNum10 bignum(num);\n     const CScriptNum scriptnum(num);\n \n     // -INT64_MIN is undefined\n@@ -81,8 +84,8 @@ static void CheckNegate(const int64_t& num)\n \n static void CheckSubtract(const int64_t& num1, const int64_t& num2)\n {\n-    const CBigNum bignum1(num1);\n-    const CBigNum bignum2(num2);\n+    const CScriptNum10 bignum1(num1);\n+    const CScriptNum10 bignum2(num2);\n     const CScriptNum scriptnum1(num1);\n     const CScriptNum scriptnum2(num2);\n     bool invalid = false;\n@@ -107,8 +110,8 @@ static void CheckSubtract(const int64_t& num1, const int64_t& num2)\n \n static void CheckCompare(const int64_t& num1, const int64_t& num2)\n {\n-    const CBigNum bignum1(num1);\n-    const CBigNum bignum2(num2);\n+    const CScriptNum10 bignum1(num1);\n+    const CScriptNum10 bignum2(num2);\n     const CScriptNum scriptnum1(num1);\n     const CScriptNum scriptnum2(num2);\n \n@@ -149,7 +152,7 @@ static void RunCreate(const int64_t& num)\n         CheckCreateVch(num);\n     else\n     {\n-        BOOST_CHECK_THROW (CheckCreateVch(num), scriptnum_error);\n+        BOOST_CHECK_THROW (CheckCreateVch(num), scriptnum10_error);\n     }\n }\n "
      }
    ]
  }
]