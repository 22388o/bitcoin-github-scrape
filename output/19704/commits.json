[
  {
    "sha": "c556770b5ef4306f10e980daff772bee87daaa30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNTU2NzcwYjVlZjQzMDZmMTBlOTgwZGFmZjc3MmJlZTg3ZGFhYTMw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T10:38:56Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T13:25:28Z"
      },
      "message": "[net_processing] Change PeerLogicValidation to hold a connman reference\n\nHold a reference to connman rather than a pointer because:\n\n- PeerLogicValidation can't run without a connman\n- The pointer never gets reseated\n\nThe alternative is to always assert that the pointer is non-null before\ndereferencing.\n\nChange the name from connman to m_connman at the same time to conform\nwith current style guidelines.",
      "tree": {
        "sha": "3f75227574331890f74d8e5e20e38e348c9d1896",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3f75227574331890f74d8e5e20e38e348c9d1896"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c556770b5ef4306f10e980daff772bee87daaa30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c556770b5ef4306f10e980daff772bee87daaa30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c556770b5ef4306f10e980daff772bee87daaa30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c556770b5ef4306f10e980daff772bee87daaa30/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd00d3b1f2036893419d1e8c514a8af2c4e4b1fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd00d3b1f2036893419d1e8c514a8af2c4e4b1fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd00d3b1f2036893419d1e8c514a8af2c4e4b1fb"
      }
    ],
    "stats": {
      "total": 100,
      "additions": 49,
      "deletions": 51
    },
    "files": [
      {
        "sha": "8fc7ad8f031af370d1c62ff53281af13669038f0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c556770b5ef4306f10e980daff772bee87daaa30/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c556770b5ef4306f10e980daff772bee87daaa30/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c556770b5ef4306f10e980daff772bee87daaa30",
        "patch": "@@ -1384,7 +1384,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node)\n     node.chainman = &g_chainman;\n     ChainstateManager& chainman = *Assert(node.chainman);\n \n-    node.peer_logic.reset(new PeerLogicValidation(node.connman.get(), node.banman.get(), *node.scheduler, chainman, *node.mempool));\n+    node.peer_logic.reset(new PeerLogicValidation(*node.connman, node.banman.get(), *node.scheduler, chainman, *node.mempool));\n     RegisterValidationInterface(node.peer_logic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "dc23f8e7be575c7282ce69a857859596426e0cad",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 43,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c556770b5ef4306f10e980daff772bee87daaa30/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c556770b5ef4306f10e980daff772bee87daaa30/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c556770b5ef4306f10e980daff772bee87daaa30",
        "patch": "@@ -844,7 +844,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->IsInboundConn(), pnode->IsManualConn()));\n     }\n     if(!pnode->IsInboundConn())\n-        PushNodeVersion(*pnode, *connman, GetTime());\n+        PushNodeVersion(*pnode, m_connman, GetTime());\n }\n \n void PeerLogicValidation::ReattemptInitialBroadcast(CScheduler& scheduler) const\n@@ -855,7 +855,7 @@ void PeerLogicValidation::ReattemptInitialBroadcast(CScheduler& scheduler) const\n         // Sanity check: all unbroadcast txns should exist in the mempool\n         if (m_mempool.exists(elem.first)) {\n             LOCK(cs_main);\n-            RelayTransaction(elem.first, elem.second, *connman);\n+            RelayTransaction(elem.first, elem.second, m_connman);\n         } else {\n             m_mempool.RemoveUnbroadcastTx(elem.first, true);\n         }\n@@ -1197,8 +1197,8 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool)\n-    : connman(connmanIn),\n+PeerLogicValidation::PeerLogicValidation(CConnman& connman, BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool)\n+    : m_connman(connman),\n       m_banman(banman),\n       m_chainman(chainman),\n       m_mempool(pool),\n@@ -1326,7 +1326,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n         fWitnessesPresentInMostRecentCompactBlock = fWitnessEnabled;\n     }\n \n-    connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n+    m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n         AssertLockHeld(cs_main);\n \n         // TODO: Avoid the repeated-serialization here\n@@ -1341,7 +1341,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                     hashBlock.ToString(), pnode->GetId());\n-            connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n+            m_connman.PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n         }\n     });\n@@ -1353,7 +1353,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n  */\n void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {\n     const int nNewHeight = pindexNew->nHeight;\n-    connman->SetBestHeight(nNewHeight);\n+    m_connman.SetBestHeight(nNewHeight);\n \n     SetServiceFlagsIBDCache(!fInitialDownload);\n     if (!fInitialDownload) {\n@@ -1370,15 +1370,15 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n             }\n         }\n         // Relay inventory, but don't relay old inventory during initial block download.\n-        connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n+        m_connman.ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n             LOCK(pnode->cs_inventory);\n             if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {\n                 for (const uint256& hash : reverse_iterate(vHashes)) {\n                     pnode->vBlockHashesToAnnounce.push_back(hash);\n                 }\n             }\n         });\n-        connman->WakeMessageHandler();\n+        m_connman.WakeMessageHandler();\n     }\n }\n \n@@ -1409,7 +1409,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const BlockValidatio\n              !::ChainstateActive().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n-            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n+            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, m_connman);\n         }\n     }\n     if (it != mapBlockSource.end())\n@@ -3803,7 +3803,7 @@ bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)\n     // Normal case: Disconnect the peer and discourage all nodes sharing the address\n     LogPrintf(\"Disconnecting and discouraging peer %d!\\n\", peer_id);\n     if (m_banman) m_banman->Discourage(pnode.addr);\n-    connman->DisconnectNode(pnode.addr);\n+    m_connman.DisconnectNode(pnode.addr);\n     return true;\n }\n \n@@ -3821,12 +3821,12 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fMoreWork = false;\n \n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(*pfrom, chainparams, *connman, m_mempool, interruptMsgProc);\n+        ProcessGetData(*pfrom, chainparams, m_connman, m_mempool, interruptMsgProc);\n \n     if (!pfrom->orphan_work_set.empty()) {\n         std::list<CTransactionRef> removed_txn;\n         LOCK2(cs_main, g_cs_orphans);\n-        ProcessOrphanTx(*connman, m_mempool, pfrom->orphan_work_set, removed_txn);\n+        ProcessOrphanTx(m_connman, m_mempool, pfrom->orphan_work_set, removed_txn);\n         for (const CTransactionRef& removedTx : removed_txn) {\n             AddToCompactExtraTransactions(removedTx);\n         }\n@@ -3852,7 +3852,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         // Just take one message\n         msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n         pfrom->nProcessQueueSize -= msgs.front().m_raw_message_size;\n-        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman->GetReceiveFloodSize();\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > m_connman.GetReceiveFloodSize();\n         fMoreWork = !pfrom->vProcessMsg.empty();\n     }\n     CNetMessage& msg(msgs.front());\n@@ -3886,7 +3886,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n \n     try {\n-        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, *connman, m_banman, interruptMsgProc);\n+        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, m_connman, m_banman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3939,7 +3939,7 @@ void PeerLogicValidation::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n                 LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto.GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n-                connman->PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n@@ -3956,7 +3956,7 @@ void PeerLogicValidation::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n {\n     // Check whether we have too many outbound peers\n-    int extra_peers = connman->GetExtraOutboundCount();\n+    int extra_peers = m_connman.GetExtraOutboundCount();\n     if (extra_peers > 0) {\n         // If we have more outbound peers than we target, disconnect one.\n         // Pick the outbound peer that least recently announced\n@@ -3965,7 +3965,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         NodeId worst_peer = -1;\n         int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n \n-        connman->ForEachNode([&](CNode* pnode) {\n+        m_connman.ForEachNode([&](CNode* pnode) {\n             AssertLockHeld(cs_main);\n \n             // Ignore non-outbound peers, or nodes marked for disconnect already\n@@ -3982,7 +3982,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             }\n         });\n         if (worst_peer != -1) {\n-            bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {\n+            bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) {\n                 AssertLockHeld(cs_main);\n \n                 // Only disconnect a peer that has been connected to us for\n@@ -4006,7 +4006,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n                 // detected a stale tip. Don't try any more extra peers until\n                 // we next detect a stale tip, to limit the load we put on the\n                 // network from these extra connections.\n-                connman->SetTryNewOutboundPeer(false);\n+                m_connman.SetTryNewOutboundPeer(false);\n             }\n         }\n     }\n@@ -4016,20 +4016,18 @@ void PeerLogicValidation::CheckForStaleTipAndEvictPeers(const Consensus::Params\n {\n     LOCK(cs_main);\n \n-    if (connman == nullptr) return;\n-\n     int64_t time_in_seconds = GetTime();\n \n     EvictExtraOutboundPeers(time_in_seconds);\n \n     if (time_in_seconds > m_stale_tip_check_time) {\n         // Check whether our tip is stale, and if so, allow using an extra\n         // outbound peer\n-        if (!fImporting && !fReindex && connman->GetNetworkActive() && connman->GetUseAddrmanOutgoing() && TipMayBeStale(consensusParams)) {\n+        if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale(consensusParams)) {\n             LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);\n-            connman->SetTryNewOutboundPeer(true);\n-        } else if (connman->GetTryNewOutboundPeer()) {\n-            connman->SetTryNewOutboundPeer(false);\n+            m_connman.SetTryNewOutboundPeer(true);\n+        } else if (m_connman.GetTryNewOutboundPeer()) {\n+            m_connman.SetTryNewOutboundPeer(false);\n         }\n         m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n     }\n@@ -4092,11 +4090,11 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         pto->m_ping_start = GetTime<std::chrono::microseconds>();\n         if (pto->nVersion > BIP0031_VERSION) {\n             pto->nPingNonceSent = nonce;\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n+            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n         } else {\n             // Peer is too old to support ping command with nonce, pong will never arrive.\n             pto->nPingNonceSent = 0;\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n+            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n         }\n     }\n \n@@ -4131,14 +4129,14 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     // receiver rejects addr messages larger than MAX_ADDR_TO_SEND\n                     if (vAddr.size() >= MAX_ADDR_TO_SEND)\n                     {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();\n@@ -4165,7 +4163,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -4249,10 +4247,10 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                             if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n-                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n+                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n-                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n                         }\n@@ -4262,7 +4260,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n                         CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n@@ -4275,7 +4273,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -4320,7 +4318,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             for (const uint256& hash : pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n             }\n@@ -4333,7 +4331,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        pto->m_tx_relay->nNextInvSend = std::chrono::microseconds{connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL)};\n+                        pto->m_tx_relay->nNextInvSend = std::chrono::microseconds{m_connman.PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL)};\n                     } else {\n                         // Use half the delay for outbound peers, as there is less privacy concern for them.\n                         pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, std::chrono::seconds{INVENTORY_BROADCAST_INTERVAL >> 1});\n@@ -4373,7 +4371,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                         vInv.push_back(inv);\n                         if (vInv.size() == MAX_INV_SZ) {\n-                            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                     }\n@@ -4449,7 +4447,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                             }\n                         }\n                         if (vInv.size() == MAX_INV_SZ) {\n-                            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                         pto->m_tx_relay->filterInventoryKnown.insert(hash);\n@@ -4466,7 +4464,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             }\n         }\n         if (!vInv.empty())\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n         current_time = GetTime<std::chrono::microseconds>();\n@@ -4594,7 +4592,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                     vGetData.push_back(inv);\n                     if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                         vGetData.clear();\n                     }\n                     UpdateTxRequestTime(gtxid, current_time);\n@@ -4624,7 +4622,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n \n         if (!vGetData.empty())\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n         //\n         // Message: feefilter\n@@ -4652,7 +4650,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n                 if (filterToSend != pto->m_tx_relay->lastSentFeeFilter) {\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n                     pto->m_tx_relay->lastSentFeeFilter = filterToSend;\n                 }\n                 pto->m_tx_relay->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);"
      },
      {
        "sha": "7ef048427812822383272b122e0250a7ea53a0e1",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c556770b5ef4306f10e980daff772bee87daaa30/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c556770b5ef4306f10e980daff772bee87daaa30/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=c556770b5ef4306f10e980daff772bee87daaa30",
        "patch": "@@ -28,7 +28,7 @@ static const int DISCOURAGEMENT_THRESHOLD{100};\n \n class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n-    CConnman* const connman;\n+    CConnman& m_connman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -37,7 +37,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     bool MaybeDiscourageAndDisconnect(CNode& pnode);\n \n public:\n-    PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool);\n+    PeerLogicValidation(CConnman& connman, BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool);\n \n     /**\n      * Overridden from CValidationInterface."
      },
      {
        "sha": "c0a2fca9ca1f37d33e94fe1e9acf0ea6ebf58135",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c556770b5ef4306f10e980daff772bee87daaa30/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c556770b5ef4306f10e980daff772bee87daaa30/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=c556770b5ef4306f10e980daff772bee87daaa30",
        "patch": "@@ -80,7 +80,7 @@ BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(*connman, nullptr, *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -150,7 +150,7 @@ static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidat\n BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(*connman, nullptr, *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n@@ -223,7 +223,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(*connman, banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -279,7 +279,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(*connman, banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "9d63aad672121775b518e51ba1183df321fc58bf",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c556770b5ef4306f10e980daff772bee87daaa30/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c556770b5ef4306f10e980daff772bee87daaa30/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=c556770b5ef4306f10e980daff772bee87daaa30",
        "patch": "@@ -168,7 +168,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     m_node.mempool->setSanityCheck(1.0);\n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n-    m_node.peer_logic = MakeUnique<PeerLogicValidation>(m_node.connman.get(), m_node.banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n+    m_node.peer_logic = MakeUnique<PeerLogicValidation>(*m_node.connman, m_node.banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peer_logic.get();"
      }
    ]
  },
  {
    "sha": "daed542a12e0a6a4692aca12a61b84cd55accc33",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWVkNTQyYTEyZTBhNmE0NjkyYWNhMTJhNjFiODRjZDU1YWNjYzMz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T11:13:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-21T12:10:41Z"
      },
      "message": "[net_processing] Move ProcessMessage to PeerLogicValidation",
      "tree": {
        "sha": "f500dae5c8231a805d2ceb31acfa783013944975",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f500dae5c8231a805d2ceb31acfa783013944975"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/daed542a12e0a6a4692aca12a61b84cd55accc33",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/daed542a12e0a6a4692aca12a61b84cd55accc33",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/daed542a12e0a6a4692aca12a61b84cd55accc33",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/daed542a12e0a6a4692aca12a61b84cd55accc33/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c556770b5ef4306f10e980daff772bee87daaa30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c556770b5ef4306f10e980daff772bee87daaa30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c556770b5ef4306f10e980daff772bee87daaa30"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 67,
      "deletions": 81
    },
    "files": [
      {
        "sha": "75bb33926fa1e2ba83b32ef8e3cf5bb82dd40ebe",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 65,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/daed542a12e0a6a4692aca12a61b84cd55accc33/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/daed542a12e0a6a4692aca12a61b84cd55accc33/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=daed542a12e0a6a4692aca12a61b84cd55accc33",
        "patch": "@@ -2303,17 +2303,9 @@ static void ProcessGetCFCheckPt(CNode& pfrom, CDataStream& vRecv, const CChainPa\n     connman.PushMessage(&pfrom, std::move(msg));\n }\n \n-void ProcessMessage(\n-    CNode& pfrom,\n-    const std::string& msg_type,\n-    CDataStream& vRecv,\n-    const std::chrono::microseconds time_received,\n-    const CChainParams& chainparams,\n-    ChainstateManager& chainman,\n-    CTxMemPool& mempool,\n-    CConnman& connman,\n-    BanMan* banman,\n-    const std::atomic<bool>& interruptMsgProc)\n+void PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                                         const std::chrono::microseconds time_received,\n+                                         const CChainParams& chainparams, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom.GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2349,7 +2341,7 @@ void ProcessMessage(\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom.IsInboundConn())\n         {\n-            connman.SetServices(pfrom.addr, nServices);\n+            m_connman.SetServices(pfrom.addr, nServices);\n         }\n         if (pfrom.ExpectServicesFromConn() && !HasAllDesirableServiceFlags(nServices))\n         {\n@@ -2378,7 +2370,7 @@ void ProcessMessage(\n         if (!vRecv.empty())\n             vRecv >> fRelay;\n         // Disconnect if we connected to ourself\n-        if (pfrom.IsInboundConn() && !connman.CheckIncomingNonce(nNonce))\n+        if (pfrom.IsInboundConn() && !m_connman.CheckIncomingNonce(nNonce))\n         {\n             LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom.addr.ToString());\n             pfrom.fDisconnect = true;\n@@ -2392,13 +2384,13 @@ void ProcessMessage(\n \n         // Be shy and don't send version until we hear\n         if (pfrom.IsInboundConn())\n-            PushNodeVersion(pfrom, connman, GetAdjustedTime());\n+            PushNodeVersion(pfrom, m_connman, GetAdjustedTime());\n \n         if (nVersion >= WTXID_RELAY_VERSION) {\n-            connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::WTXIDRELAY));\n+            m_connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::WTXIDRELAY));\n         }\n \n-        connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        m_connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom.nServices = nServices;\n         pfrom.SetAddrLocal(addrMe);\n@@ -2454,9 +2446,9 @@ void ProcessMessage(\n             }\n \n             // Get recent addresses\n-            connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n+            m_connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n             pfrom.fGetAddr = true;\n-            connman.MarkAddressGood(pfrom.addr);\n+            m_connman.MarkAddressGood(pfrom.addr);\n         }\n \n         std::string remoteAddr;\n@@ -2475,7 +2467,7 @@ void ProcessMessage(\n         // If the peer is old enough to have the old alert system, send it the final alert.\n         if (pfrom.nVersion <= 70012) {\n             CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);\n-            connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n+            m_connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n         }\n \n         // Feeler connections exist only to verify if address is online.\n@@ -2514,7 +2506,7 @@ void ProcessMessage(\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom.nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -2525,9 +2517,9 @@ void ProcessMessage(\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom.GetLocalServices() & NODE_WITNESS)\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom.fSuccessfullyConnected = true;\n         return;\n@@ -2591,21 +2583,21 @@ void ProcessMessage(\n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n             pfrom.AddAddressKnown(addr);\n-            if (banman && (banman->IsDiscouraged(addr) || banman->IsBanned(addr))) {\n+            if (m_banman && (m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr))) {\n                 // Do not process banned/discouraged addresses beyond remembering we received them\n                 continue;\n             }\n             bool fReachable = IsReachable(addr);\n             if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                RelayAddress(addr, fReachable, connman);\n+                RelayAddress(addr, fReachable, m_connman);\n             }\n             // Do not store addresses outside our network\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        connman.AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n+        m_connman.AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom.fGetAddr = false;\n         if (pfrom.IsAddrFetchConn())\n@@ -2681,7 +2673,7 @@ void ProcessMessage(\n                 if (inv.IsMsgWtx()) continue;\n             }\n \n-            bool fAlreadyHave = AlreadyHave(inv, mempool);\n+            bool fAlreadyHave = AlreadyHave(inv, m_mempool);\n             LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n             if (inv.IsMsgTx()) {\n@@ -2704,14 +2696,14 @@ void ProcessMessage(\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom.GetId());\n                     pfrom.fDisconnect = true;\n                     return;\n-                } else if (!fAlreadyHave && !chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                } else if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     RequestTx(State(pfrom.GetId()), ToGenTxid(inv), current_time);\n                 }\n             }\n         }\n \n         if (best_block != nullptr) {\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n             LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n@@ -2735,7 +2727,7 @@ void ProcessMessage(\n         }\n \n         pfrom.vRecvGetData.insert(pfrom.vRecvGetData.end(), vInv.begin(), vInv.end());\n-        ProcessGetData(pfrom, chainparams, connman, mempool, interruptMsgProc);\n+        ProcessGetData(pfrom, chainparams, m_connman, m_mempool, interruptMsgProc);\n         return;\n     }\n \n@@ -2819,7 +2811,7 @@ void ProcessMessage(\n             // Unlock cs_most_recent_block to avoid cs_main lock inversion\n         }\n         if (recent_block) {\n-            SendBlockTransactions(*recent_block, req, pfrom, connman);\n+            SendBlockTransactions(*recent_block, req, pfrom, m_connman);\n             return;\n         }\n \n@@ -2852,7 +2844,7 @@ void ProcessMessage(\n         bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());\n         assert(ret);\n \n-        SendBlockTransactions(block, req, pfrom, connman);\n+        SendBlockTransactions(block, req, pfrom, m_connman);\n         return;\n     }\n \n@@ -2919,7 +2911,7 @@ void ProcessMessage(\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n-        connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return;\n     }\n \n@@ -2978,10 +2970,10 @@ void ProcessMessage(\n         // already; and an adversary can already relay us old transactions\n         // (older than our recency filter) if trying to DoS us, without any need\n         // for witness malleation.\n-        if (!AlreadyHave(CInv(MSG_WTX, wtxid), mempool) &&\n-            AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-            mempool.check(&::ChainstateActive().CoinsTip());\n-            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), connman);\n+        if (!AlreadyHave(CInv(MSG_WTX, wtxid), m_mempool) &&\n+            AcceptToMemoryPool(m_mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+            m_mempool.check(&::ChainstateActive().CoinsTip());\n+            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(txid, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -2996,10 +2988,10 @@ void ProcessMessage(\n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n                 pfrom.GetId(),\n                 tx.GetHash().ToString(),\n-                mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n+                m_mempool.size(), m_mempool.DynamicMemoryUsage() / 1000);\n \n             // Recursively process any orphan transactions that depended on this one\n-            ProcessOrphanTx(connman, mempool, pfrom.orphan_work_set, lRemovedTxn);\n+            ProcessOrphanTx(m_connman, m_mempool, pfrom.orphan_work_set, lRemovedTxn);\n         }\n         else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n         {\n@@ -3033,7 +3025,7 @@ void ProcessMessage(\n                     // protocol for getting all unconfirmed parents.\n                     CInv _inv(MSG_TX | nFetchFlags, parent_txid);\n                     pfrom.AddKnownTx(parent_txid);\n-                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom.GetId()), ToGenTxid(_inv), current_time);\n+                    if (!AlreadyHave(_inv, m_mempool)) RequestTx(State(pfrom.GetId()), ToGenTxid(_inv), current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom.GetId());\n \n@@ -3094,11 +3086,11 @@ void ProcessMessage(\n                 // if they were already in the mempool,\n                 // allowing the node to function as a gateway for\n                 // nodes hidden behind it.\n-                if (!mempool.exists(tx.GetHash())) {\n+                if (!m_mempool.exists(tx.GetHash())) {\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), connman);\n+                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n                 }\n             }\n         }\n@@ -3151,7 +3143,7 @@ void ProcessMessage(\n         if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!::ChainstateActive().IsInitialBlockDownload())\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             return;\n         }\n \n@@ -3162,7 +3154,7 @@ void ProcessMessage(\n \n         const CBlockIndex *pindex = nullptr;\n         BlockValidationState state;\n-        if (!chainman.ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n+        if (!m_chainman.ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             if (state.IsInvalid()) {\n                 MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n                 return;\n@@ -3212,7 +3204,7 @@ void ProcessMessage(\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return;\n         }\n@@ -3233,9 +3225,9 @@ void ProcessMessage(\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(m_mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n-                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n                         // The block was already in flight using compact blocks from the same peer\n                         LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");\n@@ -3253,7 +3245,7 @@ void ProcessMessage(\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return;\n                 }\n \n@@ -3270,15 +3262,15 @@ void ProcessMessage(\n                     fProcessBLOCKTXN = true;\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n                 // This block is either already in flight from a different\n                 // peer, or this peer has too many blocks outstanding to\n                 // download from.\n                 // Optimistically try to reconstruct anyway since we might be\n                 // able to without any round trips.\n-                PartiallyDownloadedBlock tempBlock(&mempool);\n+                PartiallyDownloadedBlock tempBlock(&m_mempool);\n                 ReadStatus status = tempBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status != READ_STATUS_OK) {\n                     // TODO: don't ignore failures\n@@ -3296,7 +3288,7 @@ void ProcessMessage(\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -3306,15 +3298,15 @@ void ProcessMessage(\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, time_received, chainparams, chainman, mempool, connman, banman, interruptMsgProc);\n+            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, time_received, chainparams, interruptMsgProc);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n             // relayed before full validation (see BIP 152), so we don't want to disconnect\n             // the peer if the header turns out to be for an invalid block.\n             // Note that if a peer tries to build on an invalid chain, that\n             // will be detected and the peer will be disconnected/discouraged.\n-            return ProcessHeadersMessage(pfrom, connman, chainman, mempool, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n+            return ProcessHeadersMessage(pfrom, m_connman, m_chainman, m_mempool, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n         }\n \n         if (fBlockReconstructed) {\n@@ -3334,7 +3326,7 @@ void ProcessMessage(\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            m_chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom.nLastBlockTime = GetTime();\n             } else {\n@@ -3386,7 +3378,7 @@ void ProcessMessage(\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -3424,7 +3416,7 @@ void ProcessMessage(\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            m_chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom.nLastBlockTime = GetTime();\n             } else {\n@@ -3458,7 +3450,7 @@ void ProcessMessage(\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        return ProcessHeadersMessage(pfrom, connman, chainman, mempool, headers, chainparams, /*via_compact_block=*/false);\n+        return ProcessHeadersMessage(pfrom, m_connman, m_chainman, m_mempool, headers, chainparams, /*via_compact_block=*/false);\n     }\n \n     if (msg_type == NetMsgType::BLOCK)\n@@ -3487,7 +3479,7 @@ void ProcessMessage(\n             mapBlockSource.emplace(hash, std::make_pair(pfrom.GetId(), true));\n         }\n         bool fNewBlock = false;\n-        chainman.ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n+        m_chainman.ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n         if (fNewBlock) {\n             pfrom.nLastBlockTime = GetTime();\n         } else {\n@@ -3523,9 +3515,9 @@ void ProcessMessage(\n         pfrom.vAddrToSend.clear();\n         std::vector<CAddress> vAddr;\n         if (pfrom.HasPermission(PF_ADDR)) {\n-            vAddr = connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n+            vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         } else {\n-            vAddr = connman.GetAddresses(pfrom.addr.GetNetwork(), MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n+            vAddr = m_connman.GetAddresses(pfrom.addr.GetNetwork(), MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         }\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {\n@@ -3545,7 +3537,7 @@ void ProcessMessage(\n             return;\n         }\n \n-        if (connman.OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n+        if (m_connman.OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n         {\n             if (!pfrom.HasPermission(PF_NOBAN))\n             {\n@@ -3578,7 +3570,7 @@ void ProcessMessage(\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n         return;\n     }\n@@ -3718,17 +3710,17 @@ void ProcessMessage(\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n-        ProcessGetCFilters(pfrom, vRecv, chainparams, connman);\n+        ProcessGetCFilters(pfrom, vRecv, chainparams, m_connman);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n-        ProcessGetCFHeaders(pfrom, vRecv, chainparams, connman);\n+        ProcessGetCFHeaders(pfrom, vRecv, chainparams, m_connman);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n-        ProcessGetCFCheckPt(pfrom, vRecv, chainparams, connman);\n+        ProcessGetCFCheckPt(pfrom, vRecv, chainparams, m_connman);\n         return;\n     }\n \n@@ -3886,7 +3878,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n \n     try {\n-        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, m_connman, m_banman, interruptMsgProc);\n+        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())"
      },
      {
        "sha": "74d6603747baf2f71f712f7cd236587fe3b39a1c",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/daed542a12e0a6a4692aca12a61b84cd55accc33/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/daed542a12e0a6a4692aca12a61b84cd55accc33/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=daed542a12e0a6a4692aca12a61b84cd55accc33",
        "patch": "@@ -11,6 +11,7 @@\n #include <sync.h>\n #include <validationinterface.h>\n \n+class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n \n@@ -85,8 +86,14 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n     void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n \n+    /** Process a single message from a peer. Public for fuzz testing */\n+    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                        const std::chrono::microseconds time_received, const CChainParams& chainparams,\n+                        const std::atomic<bool>& interruptMsgProc);\n+\n private:\n     int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n+\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "ec09acc6c62939101a71a2d294e74be47ced4e3a",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 16,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/daed542a12e0a6a4692aca12a61b84cd55accc33/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/daed542a12e0a6a4692aca12a61b84cd55accc33/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=daed542a12e0a6a4692aca12a61b84cd55accc33",
        "patch": "@@ -30,18 +30,6 @@\n #include <string>\n #include <vector>\n \n-void ProcessMessage(\n-    CNode& pfrom,\n-    const std::string& msg_type,\n-    CDataStream& vRecv,\n-    const std::chrono::microseconds time_received,\n-    const CChainParams& chainparams,\n-    ChainstateManager& chainman,\n-    CTxMemPool& mempool,\n-    CConnman& connman,\n-    BanMan* banman,\n-    const std::atomic<bool>& interruptMsgProc);\n-\n namespace {\n \n #ifdef MESSAGE_TYPE\n@@ -87,10 +75,9 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     connman.AddTestNode(p2p_node);\n     g_setup->m_node.peer_logic->InitializeNode(&p2p_node);\n     try {\n-        ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream, GetTime<std::chrono::microseconds>(),\n-            Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool,\n-            *g_setup->m_node.connman, g_setup->m_node.banman.get(),\n-            std::atomic<bool>{false});\n+        g_setup->m_node.peer_logic->ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream,\n+                                                   GetTime<std::chrono::microseconds>(), Params(),\n+                                                   std::atomic<bool>{false});\n     } catch (const std::ios_base::failure&) {\n     }\n     SyncWithValidationInterfaceQueue();"
      }
    ]
  }
]