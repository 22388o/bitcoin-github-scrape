[
  {
    "sha": "1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYTRkZjhlNzQyY2ZmNWRjNWJkYjI1YWUyYjM3OTJmOTYzZGY0OWFk",
    "commit": {
      "author": {
        "name": "sandakersmann",
        "email": "mkjaerstad@yahoo.no",
        "date": "2014-11-08T22:46:09Z"
      },
      "committer": {
        "name": "sandakersmann",
        "email": "mkjaerstad@yahoo.no",
        "date": "2014-11-08T22:46:09Z"
      },
      "message": "Adoption of the word blockchain\n\nCryptocurrency was added to Oxford Dictionaries Online in May this year.\nI see no reason why the name of Satoshi\u2019s revolutionary invention should\nbe divided into two words. I propose that we adopt the word blockchain\nand merge this pull request.",
      "tree": {
        "sha": "c8333b20769442138ca0c5891eddd3506ef8bbe3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c8333b20769442138ca0c5891eddd3506ef8bbe3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "7b7c86616006a5047ae07085e26c40e3606f60c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b7c86616006a5047ae07085e26c40e3606f60c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b7c86616006a5047ae07085e26c40e3606f60c5"
      }
    ],
    "stats": {
      "total": 996,
      "additions": 926,
      "deletions": 70
    },
    "files": [
      {
        "sha": "85a9f80220a4ced04c2b3c0313362cefea42477b",
        "filename": "contrib/debian/manpages/bitcoin-qt.1",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/debian/manpages/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/debian/manpages/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin-qt.1?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -65,7 +65,7 @@ Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\n Discover own IP address (default: 1 when listening and no \\fB\\-externalip\\fR)\n .TP\n \\fB\\-checkpoints\\fR\n-Only accept block chain matching built\\-in checkpoints (default: 1)\n+Only accept blockchain matching built\\-in checkpoints (default: 1)\n .TP\n \\fB\\-listen\\fR\n Accept connections from outside (default: 1 if no \\fB\\-proxy\\fR or \\fB\\-connect\\fR)\n@@ -146,7 +146,7 @@ Upgrade wallet to latest format\n Set key pool size to <n> (default: 100)\n .TP\n \\fB\\-rescan\\fR\n-Rescan the block chain for missing wallet transactions\n+Rescan the blockchain for missing wallet transactions\n .TP\n \\fB\\-salvagewallet\\fR\n Attempt to recover private keys from a corrupt wallet.dat\n@@ -164,7 +164,7 @@ Maintain a full transaction index (default: 0)\n Imports blocks from external blk000??.dat file\n .TP\n \\fB\\-reindex\\fR\n-Rebuild block chain index from current blk000??.dat files\n+Rebuild blockchain index from current blk000??.dat files\n .TP\n \\fB\\-par=\\fR<n>\n Set the number of script verification threads (1\\-16, 0=auto, default: 0)"
      },
      {
        "sha": "7140b09210379ddf47ade3ba1dfb7b94fc8165dd",
        "filename": "contrib/debian/manpages/bitcoind.1",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/debian/manpages/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/debian/manpages/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoind.1?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-.TH BITCOIND \"1\" \"January 2011\" \"bitcoind 3.19\" \n+\ufeff.TH BITCOIND \"1\" \"January 2011\" \"bitcoind 3.19\" \n .SH NAME\n bitcoind \\- peer-to-peer network based digital currency\n .SH SYNOPSIS\n@@ -100,10 +100,10 @@ Returns the list of addresses associated with the given 'account'.\n Returns the server's available balance, or the balance for 'account'.\n .TP\n \\fBgetblockcount\\fR\n-Returns the number of blocks in the longest block chain.\n+Returns the number of blocks in the longest blockchain.\n .TP\n \\fBgetblocknumber\\fR\n-Returns the block number of the latest block in the longest block chain.\n+Returns the block number of the latest block in the longest blockchain.\n .TP\n \\fBgetconnectioncount\\fR\n Returns the number of connections to other nodes."
      },
      {
        "sha": "aeb71129ac0faaf4fc3dbc9c210c20bb560c89aa",
        "filename": "contrib/linearize/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/linearize/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/contrib/linearize/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/README.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -10,7 +10,7 @@ Required configuration file settings for linearize-hashes:\n \n Optional config file setting for linearize-hashes:\n * RPC: host, port\n-* Block chain: min_height, max_height\n+* Blockchain: min_height, max_height\n \n ## Step 2: Copy local block data\n "
      },
      {
        "sha": "114d325ca38717f45e6ccb0e13112ded005e9f55",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -5,17 +5,17 @@ Used in 0.8.0\n * blocks/blk000??.dat: block data (custom, 128 MiB per file); since 0.8.0\n * blocks/rev000??.dat; block undo data (custom); since 0.8.0 (format changed since pre-0.8)\n * blocks/index/*; block index (LevelDB); since 0.8.0\n-* chainstate/*; block chain state database (LevelDB); since 0.8.0\n+* chainstate/*; blockchain state database (LevelDB); since 0.8.0\n * database/*: BDB database environment; only used for wallet since 0.8.0\n \n Only used in pre-0.8.0\n ---------------------\n-* blktree/*; block chain index (LevelDB); since pre-0.8, replaced by blocks/index/* in 0.8.0\n+* blktree/*; blockchain index (LevelDB); since pre-0.8, replaced by blocks/index/* in 0.8.0\n * coins/*; unspent transaction output database (LevelDB); since pre-0.8, replaced by chainstate/* in 0.8.0\n \n Only used before 0.8.0\n ---------------------\n-* blkindex.dat: block chain index database (BDB); replaced by {chainstate/*,blocks/index/*,blocks/rev000??.dat} in 0.8.0\n+* blkindex.dat: blockchain index database (BDB); replaced by {chainstate/*,blocks/index/*,blocks/rev000??.dat} in 0.8.0\n * blk000?.dat: block data (custom, 2 GiB per file); replaced by blocks/blk000??.dat in 0.8.0\n \n Only used before 0.7.0"
      },
      {
        "sha": "579a222b549e35a830259b8442a4d0e37588b745",
        "filename": "doc/release-notes/release-notes-0.3.19.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.19.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.19.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.19.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -6,4 +6,4 @@ As Gavin and I have said clearly before, the software is not at all resistant to\n I'm leaving the -limitfreerelay part as a switch for now and it's there if you need it.\n \n - Removed \"safe mode\" alerts\n-\"safe mode\" alerts was a temporary measure after the 0.3.9 overflow bug.  We can say all we want that users can just run with \"-disablesafemode\", but it's better just not to have it for the sake of appearances.  It was never intended as a long term feature.  Safe mode can still be triggered by seeing a longer (greater total PoW) invalid block chain.\n+\"safe mode\" alerts was a temporary measure after the 0.3.9 overflow bug.  We can say all we want that users can just run with \"-disablesafemode\", but it's better just not to have it for the sake of appearances.  It was never intended as a long term feature.  Safe mode can still be triggered by seeing a longer (greater total PoW) invalid blockchain."
      },
      {
        "sha": "72ad3345e66d345b33e2b46e6d19f65927941103",
        "filename": "doc/release-notes/release-notes-0.3.20.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.20.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.20.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.20.2.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-The maxsendbuffer bug (0.3.20.1 clients not being able to download the block chain from other 0.3.20.1 clients) was only going to get\n+The maxsendbuffer bug (0.3.20.1 clients not being able to download the blockchain from other 0.3.20.1 clients) was only going to get\n worse as people upgraded, so I cherry-picked the bug fix and created a minor release yesterday.\n \n The Amazon Machine Images I used to do the builds are available:"
      },
      {
        "sha": "e9d2d1b5047cbdaa82de5081b8261fd0fbfa1dde",
        "filename": "doc/release-notes/release-notes-0.3.20.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.20.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.20.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.20.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -5,7 +5,7 @@ https://github.com/bitcoin/bitcoin\n ... and help test.  The new features that need testing are:\n \n * -nolisten : https://github.com/bitcoin/bitcoin/pull/11\n-* -rescan : scan block chain for missing wallet transactions\n+* -rescan : scan blockchain for missing wallet transactions\n * -printtoconsole : https://github.com/bitcoin/bitcoin/pull/37\n * RPC gettransaction details : https://github.com/bitcoin/bitcoin/pull/24\n * listtransactions new features : https://github.com/bitcoin/bitcoin/pull/10"
      },
      {
        "sha": "360b69cf11addabb6ba054eb7d2daa99e311f599",
        "filename": "doc/release-notes/release-notes-0.3.24.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.24.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.3.24.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.24.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -5,7 +5,7 @@ This is another bug fix release.  We had hoped to have wallet encryption ready f\n \n Notable fixes in v0.3.24, and the main reasons for this release:\n \n-F1) Block downloads were failing or taking unreasonable amounts of time to complete, because the increased size of the block chain was bumping up against some earlier buffer-size DoS limits.\n+F1) Block downloads were failing or taking unreasonable amounts of time to complete, because the increased size of the blockchain was bumping up against some earlier buffer-size DoS limits.\n \n F2) Fix crash caused by loss/lack of network connection.\n "
      },
      {
        "sha": "0a126aa49dee78c1392c1ca378ce8da8892d62e1",
        "filename": "doc/release-notes/release-notes-0.5.0.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.5.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.5.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.0.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -47,7 +47,7 @@ MAJOR GUI CHANGES\n \n \"Splash\" graphics at startup that show address/wallet/blockchain loading progress.\n \n-\"Synchronizing with network\" progress bar to show block-chain download progress.\n+\"Synchronizing with network\" progress bar to show blockchain download progress.\n \n Icons at the bottom of the window that show how well connected you are to the network, with tooltips to display details.\n "
      },
      {
        "sha": "1478e7f5cb06315043e42c803ae281fde4cce02d",
        "filename": "doc/release-notes/release-notes-0.5.3.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.5.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.5.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.3.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -12,7 +12,7 @@ http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.5.3#.tar.gz\n \n PROTOCOL UPDATES\n \n-BIP 30: Introduce a new network rule: \"a block is not valid if it contains a transaction whose hash already exists in the block chain, unless all that transaction's outputs were already spent before said block\" beginning on March 15, 2012, 00:00 UTC.\n+BIP 30: Introduce a new network rule: \"a block is not valid if it contains a transaction whose hash already exists in the blockchain, unless all that transaction's outputs were already spent before said block\" beginning on March 15, 2012, 00:00 UTC.\n On testnet, allow mining of min-difficulty blocks if 20 minutes have gone by without mining a regular-difficulty block. This is to make testing Bitcoin easier, and will not affect normal mode.\n \n BUG FIXES"
      },
      {
        "sha": "e450f9a342f07d0363f39f00d4cbaeb7990af3d7",
        "filename": "doc/release-notes/release-notes-0.6.3.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.6.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.6.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.6.3.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -17,7 +17,7 @@ speed up processing of new block messages and make propagating\n blocks across the network faster.\n \n Fixed an obscure bug that could cause the bitcoin process to get\n-stuck on an invalid block-chain, if the invalid chain was\n+stuck on an invalid blockchain, if the invalid chain was\n hundreds of blocks long.\n \n Bitcoin-Qt no longer automatically selects the first address"
      },
      {
        "sha": "ebd18ad4fb5d511cfdef2e1d63686aea0f046cbb",
        "filename": "doc/release-notes/release-notes-0.8.0.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.8.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.8.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.0.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -25,7 +25,7 @@ Incompatible Changes\n This release no longer maintains a full index of historical transaction ids\n by default, so looking up an arbitrary transaction using the getrawtransaction\n RPC call will not work. If you need that functionality, you must run once\n-with -txindex=1 -reindex=1 to rebuild block-chain indices (see below for more\n+with -txindex=1 -reindex=1 to rebuild blockchain indices (see below for more\n details).\n \n Improvements"
      },
      {
        "sha": "f9b3416803bcffdfff1203ef98e579845362a6bf",
        "filename": "doc/release-notes/release-notes-0.8.6.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.8.6.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.8.6.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.6.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -35,7 +35,7 @@ your machine.\n - Lower maximum size for free transaction creation\n   (see https://gist.github.com/gavinandresen/7670433#086-wallet)\n \n-- OSX block chain database corruption fixes\n+- OSX blockchain database corruption fixes\n   - Update leveldb to 1.13\n   - Use fcntl with `F_FULLSYNC` instead of fsync on OSX\n   - Use native Darwin memory barriers"
      },
      {
        "sha": "f4301c48eeb3bf86c60ccd1855e5869fc4e61f97",
        "filename": "doc/release-notes/release-notes-0.9.0.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.0.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core version 0.9.0 is now available from:\n+\ufeffBitcoin Core version 0.9.0 is now available from:\n \n   https://bitcoin.org/bin/0.9.0/\n \n@@ -66,7 +66,7 @@ To reduce confusion between Bitcoin-the-network and Bitcoin-the-software we\n have renamed the reference client to Bitcoin Core.\n \n \n-OP_RETURN and data in the block chain\n+OP_RETURN and data in the blockchain\n -------------------------------------\n On OP_RETURN:  There was been some confusion and misunderstanding in\n the community, regarding the OP_RETURN feature in 0.9 and data in the\n@@ -205,7 +205,7 @@ Command-line options:\n - Remove '-logtodebugger'\n - Allow `-noserver` with bitcoind\n \n-Block-chain handling and storage:\n+Blockchain handling and storage:\n \n - Update leveldb to 1.15\n - Check for correct genesis (prevent cases where a datadir from the wrong"
      },
      {
        "sha": "2c0fe568a6e0d9303ddab0ad30e05a4e36185c02",
        "filename": "doc/release-notes/release-notes-0.9.2.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.2.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.2.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.1.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core version 0.9.2.1 is now available from:\n+\ufeffBitcoin Core version 0.9.2.1 is now available from:\n \n   https://bitcoin.org/bin/0.9.2.1/\n \n@@ -78,7 +78,7 @@ Command-line options:\n - Fix `-printblocktree` output\n - Show error message if ReadConfigFile fails\n \n-Block-chain handling and storage:\n+Blockchain handling and storage:\n \n - Fix for GetBlockValue() after block 13,440,000 (BIP42)\n - Upgrade leveldb to 1.17"
      },
      {
        "sha": "76ab8b3c91aa295f5fdaa11cdebd6af2d50d635f",
        "filename": "doc/release-notes/release-notes-0.9.2.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/doc/release-notes/release-notes-0.9.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.md?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core version 0.9.2 is now available from:\n+\ufeffBitcoin Core version 0.9.2 is now available from:\n \n   https://bitcoin.org/bin/0.9.2/\n \n@@ -78,7 +78,7 @@ Command-line options:\n - Fix `-printblocktree` output\n - Show error message if ReadConfigFile fails\n \n-Block-chain handling and storage:\n+Blockchain handling and storage:\n \n - Fix for GetBlockValue() after block 13,440,000 (BIP42)\n - Upgrade leveldb to 1.17"
      },
      {
        "sha": "6ed1aab6873106a718864390471b49607478c1c7",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -87,7 +87,7 @@ enum BlockStatus {\n     BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n };\n \n-/** The block chain is a tree shaped structure starting with the\n+/** The blockchain is a tree shaped structure starting with the\n  * genesis block at the root, with each block potentially having multiple\n  * candidates to be the next block. A blockindex may have multiple pprev pointing\n  * to it, but at most one of them can be part of the currently active branch."
      },
      {
        "sha": "b3676b5f889e06e6d94fd9afcd6a8025827867f5",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -11,7 +11,7 @@\n \n class CBlockIndex;\n \n-/** Block-chain checkpoints are compiled-in sanity checks.\n+/** Blockchain checkpoints are compiled-in sanity checks.\n  * They are updated every release or three.\n  */\n namespace Checkpoints"
      },
      {
        "sha": "8e3217194bfd55a0676e65df0a245a851c70fbb1",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -77,7 +77,7 @@ class CCoins\n     // unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n     std::vector<CTxOut> vout;\n \n-    // at which height this transaction was included in the active block chain\n+    // at which height this transaction was included in the active blockchain\n     int nHeight;\n \n     // version of the CTransaction; accesses to this value should probably check for nHeight as well,"
      },
      {
        "sha": "d85e3934ebebdfd16dc3bfb86e81bbbc221582c4",
        "filename": "src/core/block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/core/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/core/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/block.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -13,7 +13,7 @@\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block\n- * to everyone and the block is added to the block chain.  The first transaction\n+ * to everyone and the block is added to the blockchain.  The first transaction\n  * in the block is a special one that creates a new coin owned by the creator\n  * of the block.\n  */\n@@ -130,7 +130,7 @@ class CBlock : public CBlockHeader\n };\n \n \n-/** Describes a place in the block chain to another node such that if the\n+/** Describes a place in the blockchain to another node such that if the\n  * other node doesn't have the same branch, it can find a recent common trunk.\n  * The further back it is, the further before the fork it may be.\n  */"
      },
      {
        "sha": "86c307cdd0ee59c22d744ea4900075b6b6104149",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -242,7 +242,7 @@ std::string HelpMessage(HelpMessageMode mode)\n #ifndef WIN32\n     strUsage += \"  -pid=<file>            \" + strprintf(_(\"Specify pid file (default: %s)\"), \"bitcoind.pid\") + \"\\n\";\n #endif\n-    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += \"  -reindex               \" + _(\"Rebuild blockchain index from current blk000??.dat files\") + \" \" + _(\"on startup\") + \"\\n\";\n #if !defined(WIN32)\n     strUsage += \"  -sysperms              \" + _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\") + \"\\n\";\n #endif\n@@ -288,7 +288,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     if (GetBoolArg(\"-help-debug\", false))\n         strUsage += \"  -mintxfee=<amt>        \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"), FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -paytxfee=<amt>        \" + strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += \"  -rescan                \" + _(\"Rescan the blockchain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -spendzeroconfchange   \" + strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1) + \"\\n\";\n     strUsage += \"  -txconfirmtarget=<n>   \" + strprintf(_(\"If paytxfee is not set, include enough fee so transactions are confirmed on average within n blocks (default: %u)\"), 1) + \"\\n\";\n@@ -302,7 +302,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += \"\\n\" + _(\"Debugging/Testing options:\") + \"\\n\";\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -checkpoints           \" + strprintf(_(\"Only accept block chain matching built-in checkpoints (default: %u)\"), 1) + \"\\n\";\n+        strUsage += \"  -checkpoints           \" + strprintf(_(\"Only accept blockchain matching built-in checkpoints (default: %u)\"), 1) + \"\\n\";\n         strUsage += \"  -dblogsize=<n>         \" + strprintf(_(\"Flush database activity from memory pool to disk log every <n> megabytes (default: %u)\"), 100) + \"\\n\";\n         strUsage += \"  -disablesafemode       \" + strprintf(_(\"Disable safemode, override a real safe mode event (default: %u)\"), 0) + \"\\n\";\n         strUsage += \"  -testsafemode          \" + strprintf(_(\"Force safe mode (default: %u)\"), 0) + \"\\n\";\n@@ -916,7 +916,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n         AddOneShot(strDest);\n \n-    // ********************************************************* Step 7: load block chain\n+    // ********************************************************* Step 7: load blockchain\n \n     fReindex = GetBoolArg(\"-reindex\", false);\n \n@@ -1226,7 +1226,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (mapArgs.count(\"-blocknotify\"))\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n-    // scan for better chains in the block chain database, that are not yet connected in the active best chain\n+    // scan for better chains in the blockchain database, that are not yet connected in the active best chain\n     CValidationState state;\n     if (!ActivateBestChain(state))\n         strErrors << \"Failed to connect best block\";"
      },
      {
        "sha": "c35274260a670fef4ec969a7f54ab3c0fb5aba97",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -148,7 +148,7 @@ struct CMainSignals {\n     boost::signals2::signal<void (const uint256 &)> EraseTransaction;\n     // Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible).\n     boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n-    // Notifies listeners of a new active block chain.\n+    // Notifies listeners of a new active blockchain.\n     boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n     // Notifies listeners about an inventory item being seen on the network.\n     boost::signals2::signal<void (const uint256 &)> Inventory;\n@@ -1424,7 +1424,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         // Helps prevent CPU exhaustion attacks.\n \n         // Skip ECDSA signature verification when connecting blocks\n-        // before the last block chain checkpoint. This is safe because block merkle hashes are\n+        // before the last blockchain checkpoint. This is safe because block merkle hashes are\n         // still computed and checked, and any change will be caught at the next checkpoint.\n         if (fScriptChecks) {\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n@@ -1742,7 +1742,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         if (!pblocktree->WriteTxIndex(vPos))\n             return state.Abort(\"Failed to write transaction index\");\n \n-    // add this block to the view's block chain\n+    // add this block to the view's blockchain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n     int64_t nTime3 = GetTimeMicros(); nTimeIndex += nTime3 - nTime2;\n@@ -2372,7 +2372,7 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n             return state.Invalid(error(\"%s : block's timestamp is too early\", __func__),\n                                  REJECT_INVALID, \"time-too-old\");\n \n-        // Check that the block chain matches the known block chain up to a checkpoint\n+        // Check that the blockchain matches the known blockchain up to a checkpoint\n         if (!Checkpoints::CheckBlock(nHeight, hash))\n             return state.DoS(100, error(\"%s : rejected by checkpoint lock-in at %d\", __func__, nHeight),\n                              REJECT_CHECKPOINT, \"checkpoint mismatch\");"
      },
      {
        "sha": "a846b732d96ca0c0d0082395db3e120b4ffaaa1a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -189,7 +189,7 @@ bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n-/** Find the best known block, and make it the tip of the block chain */\n+/** Find the best known block, and make it the tip of the blockchain */\n bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n CAmount GetBlockValue(int nHeight, const CAmount& nFees);\n "
      },
      {
        "sha": "3c6e5b60ba87531e515437660eec321f3d67bcd1",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -231,7 +231,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection send buffer, <n>*1000\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Need to specify a port with -whitebind: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Node relay options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Not enough file descriptors available.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only accept block chain matching built-in checkpoints (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only accept blockchain matching built-in checkpoints (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Password for JSON-RPC connections\"),\n@@ -242,10 +242,10 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC SSL options: (see the Bitcoin Wiki for SS\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC server options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly drop 1 of every <n> network messages\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly fuzz 1 of every <n> network messages\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild block chain index from current blk000??.dat files\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild blockchain index from current blk000??.dat files\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay and mine data carrier transactions (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay non-P2SH multisig (default: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the block chain for missing wallet transactions\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the blockchain for missing wallet transactions\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescanning...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run a thread to flush wallet periodically (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run in the background as a daemon and accept commands\"),"
      },
      {
        "sha": "1b9b44fd4d5799a087c04ba2a43f088754b94243",
        "filename": "src/qt/forms/intro.ui",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/forms/intro.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/forms/intro.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/intro.ui?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,4 +1,4 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <ui version=\"4.0\">\n  <class>Intro</class>\n  <widget class=\"QDialog\" name=\"Intro\">\n@@ -56,7 +56,7 @@\n    <item>\n     <widget class=\"QLabel\" name=\"sizeWarningLabel\">\n      <property name=\"text\">\n-      <string>Bitcoin Core will download and store a copy of the Bitcoin block chain. At least %1GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</string>\n+      <string>Bitcoin Core will download and store a copy of the Bitcoin blockchain. At least %1GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</string>\n      </property>\n      <property name=\"wordWrap\">\n       <bool>true</bool>"
      },
      {
        "sha": "07ddcd401e83250f9d7a73999d2c472d4004cb8e",
        "filename": "src/qt/forms/rpcconsole.ui",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/forms/rpcconsole.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/forms/rpcconsole.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/rpcconsole.ui?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -252,7 +252,7 @@\n           </font>\n          </property>\n          <property name=\"text\">\n-          <string>Block chain</string>\n+          <string>Blockchain</string>\n          </property>\n         </widget>\n        </item>"
      },
      {
        "sha": "5eb5e8114acfddb8c3729a3159d792ca5557d2bc",
        "filename": "src/qt/intro.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/intro.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/intro.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -17,7 +17,7 @@ namespace Ui {\n \n /** Introduction screen (pre-GUI startup).\n   Allows the user to choose a data directory,\n-  in which the wallet and block chain will be stored.\n+  in which the wallet and blockchain will be stored.\n  */\n class Intro : public QDialog\n {"
      },
      {
        "sha": "c2ba63417910e3788bb700821c826513719bac87",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1138,7 +1138,7 @@ Address: %4\n     </message>\n     <message>\n         <location line=\"+10\"/>\n-        <source>Bitcoin Core will download and store a copy of the Bitcoin block chain. At least %1GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</source>\n+        <source>Bitcoin Core will download and store a copy of the Bitcoin blockchain. At least %1GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -1868,8 +1868,8 @@ Address: %4\n     </message>\n     <message>\n         <location line=\"+29\"/>\n-        <source>Block chain</source>\n-        <translation>Block chain</translation>\n+        <source>Blockchain</source>\n+        <translation>Blockchain</translation>\n     </message>\n     <message>\n         <location line=\"+7\"/>\n@@ -3017,7 +3017,7 @@ Address: %4\n     </message>\n     <message>\n         <location line=\"+7\"/>\n-        <source>Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the block chain. If it fails to get into the chain, its state will change to &quot;not accepted&quot; and it won&apos;t be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.</source>\n+        <source>Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the blockchain. If it fails to get into the chain, its state will change to &quot;not accepted&quot; and it won&apos;t be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -3740,8 +3740,8 @@ for example: alertnotify=echo %%s | mail -s &quot;Bitcoin Alert&quot; admin@foo.\n     </message>\n     <message>\n         <location line=\"+10\"/>\n-        <source>Rebuild block chain index from current blk000??.dat files</source>\n-        <translation>Rebuild block chain index from current blk000??.dat files</translation>\n+        <source>Rebuild blockchain index from current blk000??.dat files</source>\n+        <translation>Rebuild blockchain index from current blk000??.dat files</translation>\n     </message>\n     <message>\n         <location line=\"+10\"/>\n@@ -4110,8 +4110,8 @@ for example: alertnotify=echo %%s | mail -s &quot;Bitcoin Alert&quot; admin@foo.\n     </message>\n     <message>\n         <location line=\"-34\"/>\n-        <source>Rescan the block chain for missing wallet transactions</source>\n-        <translation>Rescan the block chain for missing wallet transactions</translation>\n+        <source>Rescan the blockchain for missing wallet transactions</source>\n+        <translation>Rescan the blockchain for missing wallet transactions</translation>\n     </message>\n     <message>\n         <location line=\"+35\"/>\n@@ -4270,7 +4270,7 @@ for example: alertnotify=echo %%s | mail -s &quot;Bitcoin Alert&quot; admin@foo.\n     </message>\n     <message>\n         <location line=\"+4\"/>\n-        <source>Only accept block chain matching built-in checkpoints (default: %u)</source>\n+        <source>Only accept blockchain matching built-in checkpoints (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>"
      },
      {
        "sha": "c9e8add701c2af76bd0c3961f4595ec240e45db1",
        "filename": "src/qt/test/Checkpoints_tests.cpp",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/Checkpoints_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/Checkpoints_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/Checkpoints_tests.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -0,0 +1,38 @@\n+// Copyright (c) 2011-2013 The Bitcoin Core developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+//\n+// Unit tests for blockchain checkpoints\n+//\n+\n+#include \"checkpoints.h\"\n+\n+#include \"uint256.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+\n+BOOST_AUTO_TEST_SUITE(Checkpoints_tests)\n+\n+BOOST_AUTO_TEST_CASE(sanity)\n+{\n+    uint256 p11111 = uint256(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\");\n+    uint256 p134444 = uint256(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\");\n+    BOOST_CHECK(Checkpoints::CheckBlock(11111, p11111));\n+    BOOST_CHECK(Checkpoints::CheckBlock(134444, p134444));\n+\n+    \n+    // Wrong hashes at checkpoints should fail:\n+    BOOST_CHECK(!Checkpoints::CheckBlock(11111, p134444));\n+    BOOST_CHECK(!Checkpoints::CheckBlock(134444, p11111));\n+\n+    // ... but any hash not at a checkpoint should succeed:\n+    BOOST_CHECK(Checkpoints::CheckBlock(11111+1, p134444));\n+    BOOST_CHECK(Checkpoints::CheckBlock(134444+1, p11111));\n+\n+    BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate() >= 134444);\n+}    \n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d3e797b96a148796d00f1ad600d33831888100f8",
        "filename": "src/qt/test/script_tests.cpp",
        "status": "added",
        "additions": 818,
        "deletions": 0,
        "changes": 818,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/script_tests.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -0,0 +1,818 @@\n+// Copyright (c) 2011-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"data/script_invalid.json.h\"\n+#include \"data/script_valid.json.h\"\n+\n+#include \"core_io.h\"\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"main.h\"\n+#include \"script/script.h\"\n+#include \"script/sign.h\"\n+#include \"util.h\"\n+\n+#include <fstream>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/filesystem/operations.hpp>\n+#include <boost/filesystem/path.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/test/unit_test.hpp>\n+#include \"json/json_spirit_reader_template.h\"\n+#include \"json/json_spirit_utils.h\"\n+#include \"json/json_spirit_writer_template.h\"\n+\n+using namespace std;\n+using namespace json_spirit;\n+using namespace boost::algorithm;\n+\n+// Uncomment if you want to output updated JSON tests.\n+// #define UPDATE_JSON_TESTS\n+\n+static const unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n+\n+unsigned int ParseScriptFlags(string strFlags);\n+string FormatScriptFlags(unsigned int flags);\n+\n+Array\n+read_json(const std::string& jsondata)\n+{\n+    Value v;\n+\n+    if (!read_string(jsondata, v) || v.type() != array_type)\n+    {\n+        BOOST_ERROR(\"Parse error.\");\n+        return Array();\n+    }\n+    return v.get_array();\n+}\n+\n+BOOST_AUTO_TEST_SUITE(script_tests)\n+\n+CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n+{\n+    CMutableTransaction txCredit;\n+    txCredit.nVersion = 1;\n+    txCredit.nLockTime = 0;\n+    txCredit.vin.resize(1);\n+    txCredit.vout.resize(1);\n+    txCredit.vin[0].prevout.SetNull();\n+    txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n+    txCredit.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txCredit.vout[0].scriptPubKey = scriptPubKey;\n+    txCredit.vout[0].nValue = 0;\n+\n+    return txCredit;\n+}\n+\n+CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMutableTransaction& txCredit)\n+{\n+    CMutableTransaction txSpend;\n+    txSpend.nVersion = 1;\n+    txSpend.nLockTime = 0;\n+    txSpend.vin.resize(1);\n+    txSpend.vout.resize(1);\n+    txSpend.vin[0].prevout.hash = txCredit.GetHash();\n+    txSpend.vin[0].prevout.n = 0;\n+    txSpend.vin[0].scriptSig = scriptSig;\n+    txSpend.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txSpend.vout[0].scriptPubKey = CScript();\n+    txSpend.vout[0].nValue = 0;\n+\n+    return txSpend;\n+}\n+\n+void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, bool expect, const std::string& message)\n+{\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, SignatureChecker(BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey)), 0)) == expect, message);\n+}\n+\n+namespace\n+{\n+const unsigned char vchKey0[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n+const unsigned char vchKey1[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0};\n+const unsigned char vchKey2[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0};\n+\n+struct KeyData\n+{\n+    CKey key0, key0C, key1, key1C, key2, key2C;\n+    CPubKey pubkey0, pubkey0C, pubkey0H;\n+    CPubKey pubkey1, pubkey1C;\n+    CPubKey pubkey2, pubkey2C;\n+\n+    KeyData()\n+    {\n+\n+        key0.Set(vchKey0, vchKey0 + 32, false);\n+        key0C.Set(vchKey0, vchKey0 + 32, true);\n+        pubkey0 = key0.GetPubKey();\n+        pubkey0H = key0.GetPubKey();\n+        pubkey0C = key0C.GetPubKey();\n+        *const_cast<unsigned char*>(&pubkey0H[0]) = 0x06 | (pubkey0H[64] & 1);\n+\n+        key1.Set(vchKey1, vchKey1 + 32, false);\n+        key1C.Set(vchKey1, vchKey1 + 32, true);\n+        pubkey1 = key1.GetPubKey();\n+        pubkey1C = key1C.GetPubKey();\n+\n+        key2.Set(vchKey2, vchKey2 + 32, false);\n+        key2C.Set(vchKey2, vchKey2 + 32, true);\n+        pubkey2 = key2.GetPubKey();\n+        pubkey2C = key2C.GetPubKey();\n+    }\n+};\n+\n+const KeyData keys;\n+\n+class TestBuilder\n+{\n+private:\n+    CScript scriptPubKey;\n+    CTransaction creditTx;\n+    CMutableTransaction spendTx;\n+    bool havePush;\n+    std::vector<unsigned char> push;\n+    std::string comment;\n+    int flags;\n+\n+    void DoPush()\n+    {\n+        if (havePush) {\n+            spendTx.vin[0].scriptSig << push;\n+            havePush = false;\n+        }\n+    }\n+\n+    void DoPush(const std::vector<unsigned char>& data)\n+    {\n+         DoPush();\n+         push = data;\n+         havePush = true;\n+    }\n+\n+public:\n+    TestBuilder(const CScript& redeemScript, const std::string& comment_, int flags_, bool P2SH = false) : scriptPubKey(redeemScript), havePush(false), comment(comment_), flags(flags_)\n+    {\n+        if (P2SH) {\n+            creditTx = BuildCreditingTransaction(CScript() << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL);\n+        } else {\n+            creditTx = BuildCreditingTransaction(redeemScript);\n+        }\n+        spendTx = BuildSpendingTransaction(CScript(), creditTx);\n+    }\n+\n+    TestBuilder& Add(const CScript& script)\n+    {\n+        DoPush();\n+        spendTx.vin[0].scriptSig += script;\n+        return *this;\n+    }\n+\n+    TestBuilder& Num(int num)\n+    {\n+        DoPush();\n+        spendTx.vin[0].scriptSig << num;\n+        return *this;\n+    }\n+\n+    TestBuilder& Push(const std::string& hex)\n+    {\n+        DoPush(ParseHex(hex));\n+        return *this;\n+    }\n+\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32)\n+    {\n+        uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType);\n+        std::vector<unsigned char> vchSig, r, s;\n+        do {\n+            key.Sign(hash, vchSig, lenS <= 32);\n+            r = std::vector<unsigned char>(vchSig.begin() + 4, vchSig.begin() + 4 + vchSig[3]);\n+            s = std::vector<unsigned char>(vchSig.begin() + 6 + vchSig[3], vchSig.begin() + 6 + vchSig[3] + vchSig[5 + vchSig[3]]);\n+        } while (lenR != r.size() || lenS != s.size());\n+        vchSig.push_back(static_cast<unsigned char>(nHashType));\n+        DoPush(vchSig);\n+        return *this;\n+    }\n+\n+    TestBuilder& Push(const CPubKey& pubkey)\n+    {\n+        DoPush(std::vector<unsigned char>(pubkey.begin(), pubkey.end()));\n+        return *this;\n+    }\n+\n+    TestBuilder& PushRedeem()\n+    {\n+        DoPush(static_cast<std::vector<unsigned char> >(scriptPubKey));\n+        return *this;\n+    }\n+\n+    TestBuilder& EditPush(unsigned int pos, const std::string& hexin, const std::string& hexout)\n+    {\n+        assert(havePush);\n+        std::vector<unsigned char> datain = ParseHex(hexin);\n+        std::vector<unsigned char> dataout = ParseHex(hexout);\n+        assert(pos + datain.size() <= push.size());\n+        BOOST_CHECK_MESSAGE(std::vector<unsigned char>(push.begin() + pos, push.begin() + pos + datain.size()) == datain, comment);\n+        push.erase(push.begin() + pos, push.begin() + pos + datain.size());\n+        push.insert(push.begin() + pos, dataout.begin(), dataout.end());\n+        return *this;\n+    }\n+\n+    TestBuilder& DamagePush(unsigned int pos)\n+    {\n+        assert(havePush);\n+        assert(pos < push.size());\n+        push[pos] ^= 1;\n+        return *this;\n+    }\n+\n+    TestBuilder& Test(bool expect)\n+    {\n+        TestBuilder copy = *this; // Make a copy so we can rollback the push.\n+        DoPush();\n+        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, flags, expect, comment);\n+        *this = copy;\n+        return *this;\n+    }\n+\n+    Array GetJSON()\n+    {\n+        DoPush();\n+        Array array;\n+        array.push_back(FormatScript(spendTx.vin[0].scriptSig));\n+        array.push_back(FormatScript(creditTx.vout[0].scriptPubKey));\n+        array.push_back(FormatScriptFlags(flags));\n+        array.push_back(comment);\n+        return array;\n+    }\n+\n+    std::string GetComment()\n+    {\n+        return comment;\n+    }\n+\n+    const CScript& GetScriptPubKey()\n+    {\n+        return creditTx.vout[0].scriptPubKey;\n+    }\n+};\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_build)\n+{\n+    std::vector<TestBuilder> good;\n+    std::vector<TestBuilder> bad;\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                               \"P2PK\", 0\n+                              ).PushSig(keys.key0));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                              \"P2PK, bad sig\", 0\n+                             ).PushSig(keys.key0).DamagePush(10));\n+\n+    good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n+                               \"P2PKH\", 0\n+                              ).PushSig(keys.key1).Push(keys.pubkey1C));\n+    bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey2C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n+                              \"P2PKH, bad pubkey\", 0\n+                             ).PushSig(keys.key2).Push(keys.pubkey2C).DamagePush(5));\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                               \"P2PK anyonecanpay\", 0\n+                              ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                              \"P2PK anyonecanpay marked with normal hashtype\", 0\n+                             ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY).EditPush(70, \"81\", \"01\"));\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                               \"P2SH(P2PK)\", SCRIPT_VERIFY_P2SH, true\n+                              ).PushSig(keys.key0).PushRedeem());\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                              \"P2SH(P2PK), bad redeemscript\", SCRIPT_VERIFY_P2SH, true\n+                             ).PushSig(keys.key0).PushRedeem().DamagePush(10));\n+\n+    good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n+                               \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\", 0, true\n+                              ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n+    bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n+                              \"P2SH(P2PKH), bad sig\", SCRIPT_VERIFY_P2SH, true\n+                             ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n+\n+    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                               \"3-of-3\", 0\n+                              ).Num(0).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                              \"3-of-3, 2 sigs\", 0\n+                             ).Num(0).PushSig(keys.key0).PushSig(keys.key1).Num(0));\n+\n+    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                               \"P2SH(2-of-3)\", SCRIPT_VERIFY_P2SH, true\n+                              ).Num(0).PushSig(keys.key1).PushSig(keys.key2).PushRedeem());\n+    bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                              \"P2SH(2-of-3), 1 sig\", SCRIPT_VERIFY_P2SH, true\n+                             ).Num(0).PushSig(keys.key1).Num(0).PushRedeem());\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                               \"P2PK with too much R padding but no DERSIG\", 0\n+                              ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                              \"P2PK with too much R padding\", SCRIPT_VERIFY_DERSIG\n+                             ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                               \"P2PK with too much S padding but no DERSIG\", 0\n+                              ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                              \"P2PK with too much S padding\", SCRIPT_VERIFY_DERSIG\n+                             ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                               \"P2PK with too little R padding but no DERSIG\", 0\n+                              ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n+                              \"P2PK with too little R padding\", SCRIPT_VERIFY_DERSIG\n+                             ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n+                               \"P2PK NOT with bad sig with too much R padding but no DERSIG\", 0\n+                              ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n+                              \"P2PK NOT with bad sig with too much R padding\", SCRIPT_VERIFY_DERSIG\n+                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n+                              \"P2PK NOT with too much R padding but no DERSIG\", 0\n+                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n+                              \"P2PK NOT with too much R padding\", SCRIPT_VERIFY_DERSIG\n+                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n+                               \"P2PK with high S but no LOW_S\", 0\n+                              ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n+                              \"P2PK with high S\", SCRIPT_VERIFY_LOW_S\n+                             ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n+                               \"P2PK with hybrid pubkey but no STRICTENC\", 0\n+                              ).PushSig(keys.key0, SIGHASH_ALL));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n+                              \"P2PK with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n+                             ).PushSig(keys.key0, SIGHASH_ALL));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n+                              \"P2PK NOT with hybrid pubkey but no STRICTENC\", 0\n+                             ).PushSig(keys.key0, SIGHASH_ALL));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n+                               \"P2PK NOT with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n+                              ).PushSig(keys.key0, SIGHASH_ALL));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n+                               \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\", 0\n+                              ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n+                               \"P2PK NOT with invalid hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n+                              ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n+\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                               \"P2PK with undefined hashtype but no STRICTENC\", 0\n+                              ).PushSig(keys.key1, 5));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                              \"P2PK with undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n+                             ).PushSig(keys.key1, 5));\n+    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n+                               \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\", 0\n+                              ).PushSig(keys.key1, 5).DamagePush(10));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n+                              \"P2PK NOT with invalid sig and undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n+                             ).PushSig(keys.key1, 5).DamagePush(10));\n+\n+    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                               \"3-of-3 with nonzero dummy but no NULLDUMMY\", 0\n+                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n+                              \"3-of-3 with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n+                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n+    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n+                               \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\", 0\n+                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n+    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n+                              \"3-of-3 NOT with invalid sig with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n+                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n+\n+    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n+                               \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\", 0\n+                              ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n+    bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n+                              \"2-of-2 with two identical keys and sigs pushed using OP_DUP\", SCRIPT_VERIFY_SIGPUSHONLY\n+                             ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n+                              \"P2SH(P2PK) with non-push scriptSig but no SIGPUSHONLY\", 0\n+                             ).PushSig(keys.key2).PushRedeem());\n+    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n+                              \"P2SH(P2PK) with non-push scriptSig\", SCRIPT_VERIFY_SIGPUSHONLY\n+                             ).PushSig(keys.key2).PushRedeem());\n+    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n+                               \"2-of-2 with two identical keys and sigs pushed\", SCRIPT_VERIFY_SIGPUSHONLY\n+                              ).Num(0).PushSig(keys.key1).PushSig(keys.key1));\n+\n+\n+    std::map<std::string, Array> tests_good;\n+    std::map<std::string, Array> tests_bad;\n+\n+    {\n+        Array json_good = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n+        Array json_bad = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n+\n+        BOOST_FOREACH(Value& tv, json_good) {\n+            Array test = tv.get_array();\n+            if (test.size() >= 4) {\n+                tests_good[test[3].get_str()] = test;\n+            }\n+        }\n+        BOOST_FOREACH(Value& tv, json_bad) {\n+            Array test = tv.get_array();\n+            if (test.size() >= 4) {\n+                tests_bad[test[3].get_str()] = test;\n+            }\n+        }\n+    }\n+\n+    std::string strGood;\n+    std::string strBad;\n+\n+    BOOST_FOREACH(TestBuilder& test, good) {\n+        test.Test(true);\n+        if (tests_good.count(test.GetComment()) == 0) {\n+#ifndef UPDATE_JSON_TESTS\n+            BOOST_CHECK_MESSAGE(false, \"Missing auto script_valid test: \" + test.GetComment());\n+#endif\n+            strGood += write_string(Value(test.GetJSON()), true) + \",\\n\";\n+        } else {\n+            BOOST_CHECK_MESSAGE(ParseScript(tests_good[test.GetComment()][1].get_str()) == test.GetScriptPubKey(), \"ScriptPubKey mismatch in auto script_valid test: \" + test.GetComment());\n+            strGood += write_string(Value(tests_good[test.GetComment()]), true) + \",\\n\";\n+        }\n+    }\n+    BOOST_FOREACH(TestBuilder& test, bad) {\n+        test.Test(false);\n+        if (tests_bad.count(test.GetComment()) == 0) {\n+#ifndef UPDATE_JSON_TESTS\n+            BOOST_CHECK_MESSAGE(false, \"Missing auto script_invalid test: \" + test.GetComment());\n+#endif\n+            strBad += write_string(Value(test.GetJSON()), true) + \",\\n\";\n+        } else {\n+            BOOST_CHECK_MESSAGE(ParseScript(tests_bad[test.GetComment()][1].get_str()) == test.GetScriptPubKey(), \"ScriptPubKey mismatch in auto script_invalid test: \" + test.GetComment());\n+            strBad += write_string(Value(tests_bad[test.GetComment()]), true) + \",\\n\";\n+        }\n+    }\n+\n+#ifdef UPDATE_JSON_TESTS\n+    FILE* valid = fopen(\"script_valid.json.gen\", \"w\");\n+    fputs(strGood.c_str(), valid);\n+    fclose(valid);\n+    FILE* invalid = fopen(\"script_invalid.json.gen\", \"w\");\n+    fputs(strBad.c_str(), invalid);\n+    fclose(invalid);\n+#endif\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_valid)\n+{\n+    // Read tests from test/data/script_valid.json\n+    // Format is an array of arrays\n+    // Inner arrays are [ \"scriptSig\", \"scriptPubKey\", \"flags\" ]\n+    // ... where scriptSig and scriptPubKey are stringified\n+    // scripts.\n+    Array tests = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n+\n+    BOOST_FOREACH(Value& tv, tests)\n+    {\n+        Array test = tv.get_array();\n+        string strTest = write_string(tv, false);\n+        if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n+        {\n+            if (test.size() != 1) {\n+                BOOST_ERROR(\"Bad test: \" << strTest);\n+            }\n+            continue;\n+        }\n+        string scriptSigString = test[0].get_str();\n+        CScript scriptSig = ParseScript(scriptSigString);\n+        string scriptPubKeyString = test[1].get_str();\n+        CScript scriptPubKey = ParseScript(scriptPubKeyString);\n+        unsigned int scriptflags = ParseScriptFlags(test[2].get_str());\n+\n+        DoTest(scriptPubKey, scriptSig, scriptflags, true, strTest);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_invalid)\n+{\n+    // Scripts that should evaluate as invalid\n+    Array tests = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n+\n+    BOOST_FOREACH(Value& tv, tests)\n+    {\n+        Array test = tv.get_array();\n+        string strTest = write_string(tv, false);\n+        if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n+        {\n+            if (test.size() != 1) {\n+                BOOST_ERROR(\"Bad test: \" << strTest);\n+            }\n+            continue;\n+        }\n+        string scriptSigString = test[0].get_str();\n+        CScript scriptSig = ParseScript(scriptSigString);\n+        string scriptPubKeyString = test[1].get_str();\n+        CScript scriptPubKey = ParseScript(scriptPubKeyString);\n+        unsigned int scriptflags = ParseScriptFlags(test[2].get_str());\n+\n+        DoTest(scriptPubKey, scriptSig, scriptflags, false, strTest);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_PushData)\n+{\n+    // Check that PUSHDATA1, PUSHDATA2, and PUSHDATA4 create the same value on\n+    // the stack as the 1-75 opcodes do.\n+    static const unsigned char direct[] = { 1, 0x5a };\n+    static const unsigned char pushdata1[] = { OP_PUSHDATA1, 1, 0x5a };\n+    static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n+    static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n+\n+    vector<vector<unsigned char> > directStack;\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), true, BaseSignatureChecker()));\n+\n+    vector<vector<unsigned char> > pushdata1Stack;\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(pushdata1Stack == directStack);\n+\n+    vector<vector<unsigned char> > pushdata2Stack;\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(pushdata2Stack == directStack);\n+\n+    vector<vector<unsigned char> > pushdata4Stack;\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(pushdata4Stack == directStack);\n+}\n+\n+CScript\n+sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n+{\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL);\n+\n+    CScript result;\n+    //\n+    // NOTE: CHECKMULTISIG has an unfortunate bug; it requires\n+    // one extra item on the stack, before the signatures.\n+    // Putting OP_0 on the stack is the workaround;\n+    // fixing the bug would mean splitting the blockchain (old\n+    // clients would not accept new CHECKMULTISIG transactions,\n+    // and vice-versa)\n+    //\n+    result << OP_0;\n+    BOOST_FOREACH(const CKey &key, keys)\n+    {\n+        vector<unsigned char> vchSig;\n+        BOOST_CHECK(key.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        result << vchSig;\n+    }\n+    return result;\n+}\n+CScript\n+sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n+{\n+    std::vector<CKey> keys;\n+    keys.push_back(key);\n+    return sign_multisig(scriptPubKey, keys, transaction);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n+{\n+    CKey key1, key2, key3;\n+    key1.MakeNewKey(true);\n+    key2.MakeNewKey(false);\n+    key3.MakeNewKey(true);\n+\n+    CScript scriptPubKey12;\n+    scriptPubKey12 << OP_1 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n+\n+    CMutableTransaction txFrom12 = BuildCreditingTransaction(scriptPubKey12);\n+    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n+\n+    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+    txTo12.vout[0].nValue = 2;\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+\n+    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+\n+    CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n+{\n+    CKey key1, key2, key3, key4;\n+    key1.MakeNewKey(true);\n+    key2.MakeNewKey(false);\n+    key3.MakeNewKey(true);\n+    key4.MakeNewKey(false);\n+\n+    CScript scriptPubKey23;\n+    scriptPubKey23 << OP_2 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << ToByteVector(key3.GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n+\n+    CMutableTransaction txFrom23 = BuildCreditingTransaction(scriptPubKey23);\n+    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), txFrom23);\n+\n+    std::vector<CKey> keys;\n+    keys.push_back(key1); keys.push_back(key2);\n+    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key1); keys.push_back(key3);\n+    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key3);\n+    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n+    CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n+    CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n+    CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n+    CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear();\n+    keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n+    CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+\n+    keys.clear(); // Must have signatures\n+    CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+}    \n+\n+BOOST_AUTO_TEST_CASE(script_combineSigs)\n+{\n+    // Test the CombineSignatures function\n+    CBasicKeyStore keystore;\n+    vector<CKey> keys;\n+    vector<CPubKey> pubkeys;\n+    for (int i = 0; i < 3; i++)\n+    {\n+        CKey key;\n+        key.MakeNewKey(i%2 == 1);\n+        keys.push_back(key);\n+        pubkeys.push_back(key.GetPubKey());\n+        keystore.AddKey(key);\n+    }\n+\n+    CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n+    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), txFrom);\n+    CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n+    CScript& scriptSig = txTo.vin[0].scriptSig;\n+\n+    CScript empty;\n+    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, empty, empty);\n+    BOOST_CHECK(combined.empty());\n+\n+    // Single signature case:\n+    SignSignature(keystore, txFrom, txTo, 0); // changes scriptSig\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    CScript scriptSigCopy = scriptSig;\n+    // Signing again will give a different, valid signature:\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+\n+    // P2SH, single-signature case:\n+    CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n+    keystore.AddCScript(pkSingle);\n+    scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    scriptSigCopy = scriptSig;\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+    // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n+    scriptSigCopy = CScript() << OP_0 << static_cast<vector<unsigned char> >(pkSingle);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, scriptSigCopy);\n+    BOOST_CHECK(combined == scriptSig);\n+\n+    // Hardest case:  Multisig 2-of-3\n+    scriptPubKey = GetScriptForMultisig(2, pubkeys);\n+    keystore.AddCScript(scriptPubKey);\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+\n+    // A couple of partially-signed versions:\n+    vector<unsigned char> sig1;\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n+    sig1.push_back(SIGHASH_ALL);\n+    vector<unsigned char> sig2;\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE);\n+    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n+    sig2.push_back(SIGHASH_NONE);\n+    vector<unsigned char> sig3;\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE);\n+    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n+    sig3.push_back(SIGHASH_SINGLE);\n+\n+    // Not fussy about order (or even existence) of placeholders or signatures:\n+    CScript partial1a = CScript() << OP_0 << sig1 << OP_0;\n+    CScript partial1b = CScript() << OP_0 << OP_0 << sig1;\n+    CScript partial2a = CScript() << OP_0 << sig2;\n+    CScript partial2b = CScript() << sig2 << OP_0;\n+    CScript partial3a = CScript() << sig3;\n+    CScript partial3b = CScript() << OP_0 << OP_0 << sig3;\n+    CScript partial3c = CScript() << OP_0 << sig3 << OP_0;\n+    CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n+    CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n+    CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n+\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial1b);\n+    BOOST_CHECK(combined == partial1a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial2a);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial1a);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1b, partial2b);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial1b);\n+    BOOST_CHECK(combined == complete13);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial3a);\n+    BOOST_CHECK(combined == complete23);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial2b);\n+    BOOST_CHECK(combined == complete23);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial3a);\n+    BOOST_CHECK(combined == partial3c);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_push)\n+{\n+    for (int i=0; i<67000; i++) {\n+        CScript script;\n+        script << i;\n+        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Number \" << i << \" push is not minimal data.\");\n+    }\n+\n+    for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n+        std::vector<unsigned char> data(i, '\\111');\n+        CScript script;\n+        script << data;\n+        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Length \" << i << \" push is not minimal data.\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n+{\n+    // IsPushOnly returns false when given a script containing only pushes that\n+    // are invalid due to truncation. IsPushOnly() is consensus critical\n+    // because P2SH evaluation uses it, although this specific behavior should\n+    // not be consensus critical as the P2SH evaluation would fail first due to\n+    // the invalid push. Still, it doesn't hurt to test it explicitly.\n+    static const unsigned char direct[] = { 1 };\n+    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "21334806a5f95c84a4e90ba4569f0a3c1aba2171",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -265,7 +265,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     if (wtx.IsCoinBase())\n     {\n         quint32 numBlocksToMaturity = COINBASE_MATURITY +  1;\n-        strHTML += \"<br>\" + tr(\"Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the block chain. If it fails to get into the chain, its state will change to \\\"not accepted\\\" and it won't be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.\").arg(QString::number(numBlocksToMaturity)) + \"<br>\";\n+        strHTML += \"<br>\" + tr(\"Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the blockchain. If it fails to get into the chain, its state will change to \\\"not accepted\\\" and it won't be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.\").arg(QString::number(numBlocksToMaturity)) + \"<br>\";\n     }\n \n     //"
      },
      {
        "sha": "ca00be0e97cd2a08b9ce15569de6d43cdc4ffc50",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -119,7 +119,7 @@ class TransactionRecord\n     /** Subtransaction index, for sort key */\n     int idx;\n \n-    /** Status: can change with block chain update */\n+    /** Status: can change with blockchain update */\n     TransactionStatus status;\n \n     /** Whether the transaction was sent/received with a watch-only address */"
      },
      {
        "sha": "3ffe1cc6cdbcf3075db9bd2efc2a29451938fbbd",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -87,7 +87,7 @@ Value getblockcount(const Array& params, bool fHelp)\n     if (fHelp || params.size() != 0)\n         throw runtime_error(\n             \"getblockcount\\n\"\n-            \"\\nReturns the number of blocks in the longest block chain.\\n\"\n+            \"\\nReturns the number of blocks in the longest blockchain.\\n\"\n             \"\\nResult:\\n\"\n             \"n    (numeric) The current block count\\n\"\n             \"\\nExamples:\\n\"\n@@ -103,7 +103,7 @@ Value getbestblockhash(const Array& params, bool fHelp)\n     if (fHelp || params.size() != 0)\n         throw runtime_error(\n             \"getbestblockhash\\n\"\n-            \"\\nReturns the hash of the best (tip) block in the longest block chain.\\n\"\n+            \"\\nReturns the hash of the best (tip) block in the longest blockchain.\\n\"\n             \"\\nResult\\n\"\n             \"\\\"hex\\\"      (string) the block hash hex encoded\\n\"\n             \"\\nExamples\\n\"\n@@ -213,7 +213,7 @@ Value getblockhash(const Array& params, bool fHelp)\n     if (fHelp || params.size() != 1)\n         throw runtime_error(\n             \"getblockhash index\\n\"\n-            \"\\nReturns hash of block in best-block-chain at index provided.\\n\"\n+            \"\\nReturns hash of block in best-blockchain at index provided.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. index         (numeric, required) The block index\\n\"\n             \"\\nResult:\\n\"\n@@ -441,7 +441,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n     if (fHelp || params.size() != 0)\n         throw runtime_error(\n             \"getblockchaininfo\\n\"\n-            \"Returns an object containing various state info regarding block chain processing.\\n\"\n+            \"Returns an object containing various state info regarding blockchain processing.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"chain\\\": \\\"xxxx\\\",        (string) current network name as defined in BIP70 (main, test, regtest)\\n\""
      },
      {
        "sha": "58a5749693e2371aa3a2d7524d1337e947d6f036",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -491,7 +491,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\n             \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n             \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n-            \"this transaction depends on but may not yet be in the block chain.\\n\"\n+            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n             \"The third optional argument (may be null) is an array of base58-encoded private\\n\"\n             \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n #ifdef ENABLE_WALLET\n@@ -748,7 +748,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n                 throw JSONRPCError(RPC_TRANSACTION_ERROR, state.GetRejectReason());\n         }\n     } else if (fHaveChain) {\n-        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n+        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in blockchain\");\n     }\n     RelayTransaction(tx);\n "
      },
      {
        "sha": "fac1d3a4dbdee21a7246d838d50885f12d7c42f2",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -256,7 +256,7 @@ static const CRPCCommand vRPCCommands[] =\n     { \"network\",            \"getpeerinfo\",            &getpeerinfo,            true,      false,      false },\n     { \"network\",            \"ping\",                   &ping,                   true,      false,      false },\n \n-    /* Block chain and UTXO */\n+    /* Blockchain and UTXO */\n     { \"blockchain\",         \"getblockchaininfo\",      &getblockchaininfo,      true,      false,      false },\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,      false,      false },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,      false,      false },"
      },
      {
        "sha": "1f1388f0c49939a91829c9f3c4ce86cf79499b58",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -17,7 +17,7 @@ namespace {\n \n // Valid signature cache, to avoid doing expensive ECDSA signature checking\n // twice for every transaction (once when accepted into memory pool, and\n-// again when accepted into the block chain)\n+// again when accepted into the blockchain)\n class CSignatureCache\n {\n private:"
      },
      {
        "sha": "aff0ca556c52884d971deda5c294c10618a865e3",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -921,7 +921,7 @@ bool CWalletTx::WriteToDisk()\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the blockchain (starting in pindexStart) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  */"
      },
      {
        "sha": "9ef884bd6548936b36d6b824c0cd4cc7e8cadf9c",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -486,7 +486,7 @@ struct COutputEntry\n     int vout;\n };\n \n-/** A transaction with a merkle branch linking it to the block chain. */\n+/** A transaction with a merkle branch linking it to the blockchain. */\n class CMerkleTx : public CTransaction\n {\n private:\n@@ -547,7 +547,7 @@ class CMerkleTx : public CTransaction\n \n /** \n  * A transaction with a bunch of additional info that only the owner cares about.\n- * It includes any unrecorded transactions needed to link it back to the block chain.\n+ * It includes any unrecorded transactions needed to link it back to the blockchain.\n  */\n class CWalletTx : public CMerkleTx\n {"
      }
    ]
  },
  {
    "sha": "79cda9cbe1eae042e151734950b4842e2ee6dd2b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OWNkYTljYmUxZWFlMDQyZTE1MTczNDk1MGI0ODQyZTJlZTZkZDJi",
    "commit": {
      "author": {
        "name": "sandakersmann",
        "email": "mkjaerstad@yahoo.no",
        "date": "2014-11-09T00:09:54Z"
      },
      "committer": {
        "name": "sandakersmann",
        "email": "mkjaerstad@yahoo.no",
        "date": "2014-11-09T00:09:54Z"
      },
      "message": "Correction to: \"Adoption of the word blockchain\"\n\nWrong folder used.",
      "tree": {
        "sha": "0e80680db8a80536f354e23814dfa28e242d0cb8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e80680db8a80536f354e23814dfa28e242d0cb8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79cda9cbe1eae042e151734950b4842e2ee6dd2b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79cda9cbe1eae042e151734950b4842e2ee6dd2b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/79cda9cbe1eae042e151734950b4842e2ee6dd2b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79cda9cbe1eae042e151734950b4842e2ee6dd2b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad"
      }
    ],
    "stats": {
      "total": 860,
      "additions": 2,
      "deletions": 858
    },
    "files": [
      {
        "sha": "c9e8add701c2af76bd0c3961f4595ec240e45db1",
        "filename": "src/qt/test/Checkpoints_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 38,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/Checkpoints_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/Checkpoints_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/Checkpoints_tests.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,38 +0,0 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-//\n-// Unit tests for blockchain checkpoints\n-//\n-\n-#include \"checkpoints.h\"\n-\n-#include \"uint256.h\"\n-\n-#include <boost/test/unit_test.hpp>\n-\n-using namespace std;\n-\n-BOOST_AUTO_TEST_SUITE(Checkpoints_tests)\n-\n-BOOST_AUTO_TEST_CASE(sanity)\n-{\n-    uint256 p11111 = uint256(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\");\n-    uint256 p134444 = uint256(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\");\n-    BOOST_CHECK(Checkpoints::CheckBlock(11111, p11111));\n-    BOOST_CHECK(Checkpoints::CheckBlock(134444, p134444));\n-\n-    \n-    // Wrong hashes at checkpoints should fail:\n-    BOOST_CHECK(!Checkpoints::CheckBlock(11111, p134444));\n-    BOOST_CHECK(!Checkpoints::CheckBlock(134444, p11111));\n-\n-    // ... but any hash not at a checkpoint should succeed:\n-    BOOST_CHECK(Checkpoints::CheckBlock(11111+1, p134444));\n-    BOOST_CHECK(Checkpoints::CheckBlock(134444+1, p11111));\n-\n-    BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate() >= 134444);\n-}    \n-\n-BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d3e797b96a148796d00f1ad600d33831888100f8",
        "filename": "src/qt/test/script_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 818,
        "changes": 818,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a4df8e742cff5dc5bdb25ae2b3792f963df49ad/src/qt/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/script_tests.cpp?ref=1a4df8e742cff5dc5bdb25ae2b3792f963df49ad",
        "patch": "@@ -1,818 +0,0 @@\n-// Copyright (c) 2011-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"data/script_invalid.json.h\"\n-#include \"data/script_valid.json.h\"\n-\n-#include \"core_io.h\"\n-#include \"key.h\"\n-#include \"keystore.h\"\n-#include \"main.h\"\n-#include \"script/script.h\"\n-#include \"script/sign.h\"\n-#include \"util.h\"\n-\n-#include <fstream>\n-#include <stdint.h>\n-#include <string>\n-#include <vector>\n-\n-#include <boost/algorithm/string/classification.hpp>\n-#include <boost/algorithm/string/predicate.hpp>\n-#include <boost/algorithm/string/replace.hpp>\n-#include <boost/algorithm/string/split.hpp>\n-#include <boost/filesystem/operations.hpp>\n-#include <boost/filesystem/path.hpp>\n-#include <boost/foreach.hpp>\n-#include <boost/test/unit_test.hpp>\n-#include \"json/json_spirit_reader_template.h\"\n-#include \"json/json_spirit_utils.h\"\n-#include \"json/json_spirit_writer_template.h\"\n-\n-using namespace std;\n-using namespace json_spirit;\n-using namespace boost::algorithm;\n-\n-// Uncomment if you want to output updated JSON tests.\n-// #define UPDATE_JSON_TESTS\n-\n-static const unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n-\n-unsigned int ParseScriptFlags(string strFlags);\n-string FormatScriptFlags(unsigned int flags);\n-\n-Array\n-read_json(const std::string& jsondata)\n-{\n-    Value v;\n-\n-    if (!read_string(jsondata, v) || v.type() != array_type)\n-    {\n-        BOOST_ERROR(\"Parse error.\");\n-        return Array();\n-    }\n-    return v.get_array();\n-}\n-\n-BOOST_AUTO_TEST_SUITE(script_tests)\n-\n-CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n-{\n-    CMutableTransaction txCredit;\n-    txCredit.nVersion = 1;\n-    txCredit.nLockTime = 0;\n-    txCredit.vin.resize(1);\n-    txCredit.vout.resize(1);\n-    txCredit.vin[0].prevout.SetNull();\n-    txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n-    txCredit.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n-    txCredit.vout[0].scriptPubKey = scriptPubKey;\n-    txCredit.vout[0].nValue = 0;\n-\n-    return txCredit;\n-}\n-\n-CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMutableTransaction& txCredit)\n-{\n-    CMutableTransaction txSpend;\n-    txSpend.nVersion = 1;\n-    txSpend.nLockTime = 0;\n-    txSpend.vin.resize(1);\n-    txSpend.vout.resize(1);\n-    txSpend.vin[0].prevout.hash = txCredit.GetHash();\n-    txSpend.vin[0].prevout.n = 0;\n-    txSpend.vin[0].scriptSig = scriptSig;\n-    txSpend.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n-    txSpend.vout[0].scriptPubKey = CScript();\n-    txSpend.vout[0].nValue = 0;\n-\n-    return txSpend;\n-}\n-\n-void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, bool expect, const std::string& message)\n-{\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, SignatureChecker(BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey)), 0)) == expect, message);\n-}\n-\n-namespace\n-{\n-const unsigned char vchKey0[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-const unsigned char vchKey1[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0};\n-const unsigned char vchKey2[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0};\n-\n-struct KeyData\n-{\n-    CKey key0, key0C, key1, key1C, key2, key2C;\n-    CPubKey pubkey0, pubkey0C, pubkey0H;\n-    CPubKey pubkey1, pubkey1C;\n-    CPubKey pubkey2, pubkey2C;\n-\n-    KeyData()\n-    {\n-\n-        key0.Set(vchKey0, vchKey0 + 32, false);\n-        key0C.Set(vchKey0, vchKey0 + 32, true);\n-        pubkey0 = key0.GetPubKey();\n-        pubkey0H = key0.GetPubKey();\n-        pubkey0C = key0C.GetPubKey();\n-        *const_cast<unsigned char*>(&pubkey0H[0]) = 0x06 | (pubkey0H[64] & 1);\n-\n-        key1.Set(vchKey1, vchKey1 + 32, false);\n-        key1C.Set(vchKey1, vchKey1 + 32, true);\n-        pubkey1 = key1.GetPubKey();\n-        pubkey1C = key1C.GetPubKey();\n-\n-        key2.Set(vchKey2, vchKey2 + 32, false);\n-        key2C.Set(vchKey2, vchKey2 + 32, true);\n-        pubkey2 = key2.GetPubKey();\n-        pubkey2C = key2C.GetPubKey();\n-    }\n-};\n-\n-const KeyData keys;\n-\n-class TestBuilder\n-{\n-private:\n-    CScript scriptPubKey;\n-    CTransaction creditTx;\n-    CMutableTransaction spendTx;\n-    bool havePush;\n-    std::vector<unsigned char> push;\n-    std::string comment;\n-    int flags;\n-\n-    void DoPush()\n-    {\n-        if (havePush) {\n-            spendTx.vin[0].scriptSig << push;\n-            havePush = false;\n-        }\n-    }\n-\n-    void DoPush(const std::vector<unsigned char>& data)\n-    {\n-         DoPush();\n-         push = data;\n-         havePush = true;\n-    }\n-\n-public:\n-    TestBuilder(const CScript& redeemScript, const std::string& comment_, int flags_, bool P2SH = false) : scriptPubKey(redeemScript), havePush(false), comment(comment_), flags(flags_)\n-    {\n-        if (P2SH) {\n-            creditTx = BuildCreditingTransaction(CScript() << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL);\n-        } else {\n-            creditTx = BuildCreditingTransaction(redeemScript);\n-        }\n-        spendTx = BuildSpendingTransaction(CScript(), creditTx);\n-    }\n-\n-    TestBuilder& Add(const CScript& script)\n-    {\n-        DoPush();\n-        spendTx.vin[0].scriptSig += script;\n-        return *this;\n-    }\n-\n-    TestBuilder& Num(int num)\n-    {\n-        DoPush();\n-        spendTx.vin[0].scriptSig << num;\n-        return *this;\n-    }\n-\n-    TestBuilder& Push(const std::string& hex)\n-    {\n-        DoPush(ParseHex(hex));\n-        return *this;\n-    }\n-\n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32)\n-    {\n-        uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType);\n-        std::vector<unsigned char> vchSig, r, s;\n-        do {\n-            key.Sign(hash, vchSig, lenS <= 32);\n-            r = std::vector<unsigned char>(vchSig.begin() + 4, vchSig.begin() + 4 + vchSig[3]);\n-            s = std::vector<unsigned char>(vchSig.begin() + 6 + vchSig[3], vchSig.begin() + 6 + vchSig[3] + vchSig[5 + vchSig[3]]);\n-        } while (lenR != r.size() || lenS != s.size());\n-        vchSig.push_back(static_cast<unsigned char>(nHashType));\n-        DoPush(vchSig);\n-        return *this;\n-    }\n-\n-    TestBuilder& Push(const CPubKey& pubkey)\n-    {\n-        DoPush(std::vector<unsigned char>(pubkey.begin(), pubkey.end()));\n-        return *this;\n-    }\n-\n-    TestBuilder& PushRedeem()\n-    {\n-        DoPush(static_cast<std::vector<unsigned char> >(scriptPubKey));\n-        return *this;\n-    }\n-\n-    TestBuilder& EditPush(unsigned int pos, const std::string& hexin, const std::string& hexout)\n-    {\n-        assert(havePush);\n-        std::vector<unsigned char> datain = ParseHex(hexin);\n-        std::vector<unsigned char> dataout = ParseHex(hexout);\n-        assert(pos + datain.size() <= push.size());\n-        BOOST_CHECK_MESSAGE(std::vector<unsigned char>(push.begin() + pos, push.begin() + pos + datain.size()) == datain, comment);\n-        push.erase(push.begin() + pos, push.begin() + pos + datain.size());\n-        push.insert(push.begin() + pos, dataout.begin(), dataout.end());\n-        return *this;\n-    }\n-\n-    TestBuilder& DamagePush(unsigned int pos)\n-    {\n-        assert(havePush);\n-        assert(pos < push.size());\n-        push[pos] ^= 1;\n-        return *this;\n-    }\n-\n-    TestBuilder& Test(bool expect)\n-    {\n-        TestBuilder copy = *this; // Make a copy so we can rollback the push.\n-        DoPush();\n-        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, flags, expect, comment);\n-        *this = copy;\n-        return *this;\n-    }\n-\n-    Array GetJSON()\n-    {\n-        DoPush();\n-        Array array;\n-        array.push_back(FormatScript(spendTx.vin[0].scriptSig));\n-        array.push_back(FormatScript(creditTx.vout[0].scriptPubKey));\n-        array.push_back(FormatScriptFlags(flags));\n-        array.push_back(comment);\n-        return array;\n-    }\n-\n-    std::string GetComment()\n-    {\n-        return comment;\n-    }\n-\n-    const CScript& GetScriptPubKey()\n-    {\n-        return creditTx.vout[0].scriptPubKey;\n-    }\n-};\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_build)\n-{\n-    std::vector<TestBuilder> good;\n-    std::vector<TestBuilder> bad;\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                               \"P2PK\", 0\n-                              ).PushSig(keys.key0));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                              \"P2PK, bad sig\", 0\n-                             ).PushSig(keys.key0).DamagePush(10));\n-\n-    good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                               \"P2PKH\", 0\n-                              ).PushSig(keys.key1).Push(keys.pubkey1C));\n-    bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey2C.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                              \"P2PKH, bad pubkey\", 0\n-                             ).PushSig(keys.key2).Push(keys.pubkey2C).DamagePush(5));\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                               \"P2PK anyonecanpay\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                              \"P2PK anyonecanpay marked with normal hashtype\", 0\n-                             ).PushSig(keys.key1, SIGHASH_ALL | SIGHASH_ANYONECANPAY).EditPush(70, \"81\", \"01\"));\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                               \"P2SH(P2PK)\", SCRIPT_VERIFY_P2SH, true\n-                              ).PushSig(keys.key0).PushRedeem());\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK), bad redeemscript\", SCRIPT_VERIFY_P2SH, true\n-                             ).PushSig(keys.key0).PushRedeem().DamagePush(10));\n-\n-    good.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                               \"P2SH(P2PKH), bad sig but no VERIFY_P2SH\", 0, true\n-                              ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n-    bad.push_back(TestBuilder(CScript() << OP_DUP << OP_HASH160 << ToByteVector(keys.pubkey1.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG,\n-                              \"P2SH(P2PKH), bad sig\", SCRIPT_VERIFY_P2SH, true\n-                             ).PushSig(keys.key0).DamagePush(10).PushRedeem());\n-\n-    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"3-of-3\", 0\n-                              ).Num(0).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n-    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"3-of-3, 2 sigs\", 0\n-                             ).Num(0).PushSig(keys.key0).PushSig(keys.key1).Num(0));\n-\n-    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"P2SH(2-of-3)\", SCRIPT_VERIFY_P2SH, true\n-                              ).Num(0).PushSig(keys.key1).PushSig(keys.key2).PushRedeem());\n-    bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"P2SH(2-of-3), 1 sig\", SCRIPT_VERIFY_P2SH, true\n-                             ).Num(0).PushSig(keys.key1).Num(0).PushRedeem());\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too much R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too much S padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too much S padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL).EditPush(1, \"44\", \"45\").EditPush(37, \"20\", \"2100\"));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                               \"P2PK with too little R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1C) << OP_CHECKSIG,\n-                              \"P2PK with too little R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key1, SIGHASH_ALL, 33, 32).EditPush(1, \"45022100\", \"440220\"));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with bad sig with too much R padding but no DERSIG\", 0\n-                              ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with bad sig with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\").DamagePush(10));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with too much R padding but no DERSIG\", 0\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with too much R padding\", SCRIPT_VERIFY_DERSIG\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 31, 32).EditPush(1, \"43021F\", \"44022000\"));\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                               \"P2PK with high S but no LOW_S\", 0\n-                              ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2PK with high S\", SCRIPT_VERIFY_LOW_S\n-                             ).PushSig(keys.key2, SIGHASH_ALL, 32, 33));\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n-                               \"P2PK with hybrid pubkey but no STRICTENC\", 0\n-                              ).PushSig(keys.key0, SIGHASH_ALL));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG,\n-                              \"P2PK with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key0, SIGHASH_ALL));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with hybrid pubkey but no STRICTENC\", 0\n-                             ).PushSig(keys.key0, SIGHASH_ALL));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                              ).PushSig(keys.key0, SIGHASH_ALL));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with invalid hybrid pubkey but no STRICTENC\", 0\n-                              ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0H) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with invalid hybrid pubkey\", SCRIPT_VERIFY_STRICTENC\n-                              ).PushSig(keys.key0, SIGHASH_ALL).DamagePush(10));\n-\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                               \"P2PK with undefined hashtype but no STRICTENC\", 0\n-                              ).PushSig(keys.key1, 5));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                              \"P2PK with undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key1, 5));\n-    good.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n-                               \"P2PK NOT with invalid sig and undefined hashtype but no STRICTENC\", 0\n-                              ).PushSig(keys.key1, 5).DamagePush(10));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG << OP_NOT,\n-                              \"P2PK NOT with invalid sig and undefined hashtype\", SCRIPT_VERIFY_STRICTENC\n-                             ).PushSig(keys.key1, 5).DamagePush(10));\n-\n-    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                               \"3-of-3 with nonzero dummy but no NULLDUMMY\", 0\n-                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n-    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG,\n-                              \"3-of-3 with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n-                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2));\n-    good.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n-                               \"3-of-3 NOT with invalid sig and nonzero dummy but no NULLDUMMY\", 0\n-                              ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n-    bad.push_back(TestBuilder(CScript() << OP_3 << ToByteVector(keys.pubkey0C) << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey2C) << OP_3 << OP_CHECKMULTISIG << OP_NOT,\n-                              \"3-of-3 NOT with invalid sig with nonzero dummy\", SCRIPT_VERIFY_NULLDUMMY\n-                             ).Num(1).PushSig(keys.key0).PushSig(keys.key1).PushSig(keys.key2).DamagePush(10));\n-\n-    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"2-of-2 with two identical keys and sigs pushed using OP_DUP but no SIGPUSHONLY\", 0\n-                              ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n-    bad.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                              \"2-of-2 with two identical keys and sigs pushed using OP_DUP\", SCRIPT_VERIFY_SIGPUSHONLY\n-                             ).Num(0).PushSig(keys.key1).Add(CScript() << OP_DUP));\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK) with non-push scriptSig but no SIGPUSHONLY\", 0\n-                             ).PushSig(keys.key2).PushRedeem());\n-    bad.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey2C) << OP_CHECKSIG,\n-                              \"P2SH(P2PK) with non-push scriptSig\", SCRIPT_VERIFY_SIGPUSHONLY\n-                             ).PushSig(keys.key2).PushRedeem());\n-    good.push_back(TestBuilder(CScript() << OP_2 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey1C) << OP_2 << OP_CHECKMULTISIG,\n-                               \"2-of-2 with two identical keys and sigs pushed\", SCRIPT_VERIFY_SIGPUSHONLY\n-                              ).Num(0).PushSig(keys.key1).PushSig(keys.key1));\n-\n-\n-    std::map<std::string, Array> tests_good;\n-    std::map<std::string, Array> tests_bad;\n-\n-    {\n-        Array json_good = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n-        Array json_bad = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n-\n-        BOOST_FOREACH(Value& tv, json_good) {\n-            Array test = tv.get_array();\n-            if (test.size() >= 4) {\n-                tests_good[test[3].get_str()] = test;\n-            }\n-        }\n-        BOOST_FOREACH(Value& tv, json_bad) {\n-            Array test = tv.get_array();\n-            if (test.size() >= 4) {\n-                tests_bad[test[3].get_str()] = test;\n-            }\n-        }\n-    }\n-\n-    std::string strGood;\n-    std::string strBad;\n-\n-    BOOST_FOREACH(TestBuilder& test, good) {\n-        test.Test(true);\n-        if (tests_good.count(test.GetComment()) == 0) {\n-#ifndef UPDATE_JSON_TESTS\n-            BOOST_CHECK_MESSAGE(false, \"Missing auto script_valid test: \" + test.GetComment());\n-#endif\n-            strGood += write_string(Value(test.GetJSON()), true) + \",\\n\";\n-        } else {\n-            BOOST_CHECK_MESSAGE(ParseScript(tests_good[test.GetComment()][1].get_str()) == test.GetScriptPubKey(), \"ScriptPubKey mismatch in auto script_valid test: \" + test.GetComment());\n-            strGood += write_string(Value(tests_good[test.GetComment()]), true) + \",\\n\";\n-        }\n-    }\n-    BOOST_FOREACH(TestBuilder& test, bad) {\n-        test.Test(false);\n-        if (tests_bad.count(test.GetComment()) == 0) {\n-#ifndef UPDATE_JSON_TESTS\n-            BOOST_CHECK_MESSAGE(false, \"Missing auto script_invalid test: \" + test.GetComment());\n-#endif\n-            strBad += write_string(Value(test.GetJSON()), true) + \",\\n\";\n-        } else {\n-            BOOST_CHECK_MESSAGE(ParseScript(tests_bad[test.GetComment()][1].get_str()) == test.GetScriptPubKey(), \"ScriptPubKey mismatch in auto script_invalid test: \" + test.GetComment());\n-            strBad += write_string(Value(tests_bad[test.GetComment()]), true) + \",\\n\";\n-        }\n-    }\n-\n-#ifdef UPDATE_JSON_TESTS\n-    FILE* valid = fopen(\"script_valid.json.gen\", \"w\");\n-    fputs(strGood.c_str(), valid);\n-    fclose(valid);\n-    FILE* invalid = fopen(\"script_invalid.json.gen\", \"w\");\n-    fputs(strBad.c_str(), invalid);\n-    fclose(invalid);\n-#endif\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_valid)\n-{\n-    // Read tests from test/data/script_valid.json\n-    // Format is an array of arrays\n-    // Inner arrays are [ \"scriptSig\", \"scriptPubKey\", \"flags\" ]\n-    // ... where scriptSig and scriptPubKey are stringified\n-    // scripts.\n-    Array tests = read_json(std::string(json_tests::script_valid, json_tests::script_valid + sizeof(json_tests::script_valid)));\n-\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n-        Array test = tv.get_array();\n-        string strTest = write_string(tv, false);\n-        if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n-        {\n-            if (test.size() != 1) {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-            }\n-            continue;\n-        }\n-        string scriptSigString = test[0].get_str();\n-        CScript scriptSig = ParseScript(scriptSigString);\n-        string scriptPubKeyString = test[1].get_str();\n-        CScript scriptPubKey = ParseScript(scriptPubKeyString);\n-        unsigned int scriptflags = ParseScriptFlags(test[2].get_str());\n-\n-        DoTest(scriptPubKey, scriptSig, scriptflags, true, strTest);\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_invalid)\n-{\n-    // Scripts that should evaluate as invalid\n-    Array tests = read_json(std::string(json_tests::script_invalid, json_tests::script_invalid + sizeof(json_tests::script_invalid)));\n-\n-    BOOST_FOREACH(Value& tv, tests)\n-    {\n-        Array test = tv.get_array();\n-        string strTest = write_string(tv, false);\n-        if (test.size() < 3) // Allow size > 3; extra stuff ignored (useful for comments)\n-        {\n-            if (test.size() != 1) {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-            }\n-            continue;\n-        }\n-        string scriptSigString = test[0].get_str();\n-        CScript scriptSig = ParseScript(scriptSigString);\n-        string scriptPubKeyString = test[1].get_str();\n-        CScript scriptPubKey = ParseScript(scriptPubKeyString);\n-        unsigned int scriptflags = ParseScriptFlags(test[2].get_str());\n-\n-        DoTest(scriptPubKey, scriptSig, scriptflags, false, strTest);\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_PushData)\n-{\n-    // Check that PUSHDATA1, PUSHDATA2, and PUSHDATA4 create the same value on\n-    // the stack as the 1-75 opcodes do.\n-    static const unsigned char direct[] = { 1, 0x5a };\n-    static const unsigned char pushdata1[] = { OP_PUSHDATA1, 1, 0x5a };\n-    static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n-    static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n-\n-    vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), true, BaseSignatureChecker()));\n-\n-    vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), true, BaseSignatureChecker()));\n-    BOOST_CHECK(pushdata1Stack == directStack);\n-\n-    vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), true, BaseSignatureChecker()));\n-    BOOST_CHECK(pushdata2Stack == directStack);\n-\n-    vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), true, BaseSignatureChecker()));\n-    BOOST_CHECK(pushdata4Stack == directStack);\n-}\n-\n-CScript\n-sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n-{\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL);\n-\n-    CScript result;\n-    //\n-    // NOTE: CHECKMULTISIG has an unfortunate bug; it requires\n-    // one extra item on the stack, before the signatures.\n-    // Putting OP_0 on the stack is the workaround;\n-    // fixing the bug would mean splitting the blockchain (old\n-    // clients would not accept new CHECKMULTISIG transactions,\n-    // and vice-versa)\n-    //\n-    result << OP_0;\n-    BOOST_FOREACH(const CKey &key, keys)\n-    {\n-        vector<unsigned char> vchSig;\n-        BOOST_CHECK(key.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        result << vchSig;\n-    }\n-    return result;\n-}\n-CScript\n-sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n-{\n-    std::vector<CKey> keys;\n-    keys.push_back(key);\n-    return sign_multisig(scriptPubKey, keys, transaction);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n-{\n-    CKey key1, key2, key3;\n-    key1.MakeNewKey(true);\n-    key2.MakeNewKey(false);\n-    key3.MakeNewKey(true);\n-\n-    CScript scriptPubKey12;\n-    scriptPubKey12 << OP_1 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    CMutableTransaction txFrom12 = BuildCreditingTransaction(scriptPubKey12);\n-    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n-\n-    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n-    txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n-\n-    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n-\n-    CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n-{\n-    CKey key1, key2, key3, key4;\n-    key1.MakeNewKey(true);\n-    key2.MakeNewKey(false);\n-    key3.MakeNewKey(true);\n-    key4.MakeNewKey(false);\n-\n-    CScript scriptPubKey23;\n-    scriptPubKey23 << OP_2 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << ToByteVector(key3.GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-\n-    CMutableTransaction txFrom23 = BuildCreditingTransaction(scriptPubKey23);\n-    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), txFrom23);\n-\n-    std::vector<CKey> keys;\n-    keys.push_back(key1); keys.push_back(key2);\n-    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key1); keys.push_back(key3);\n-    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key3);\n-    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n-    CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n-    CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n-    CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n-    CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear();\n-    keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n-    CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-\n-    keys.clear(); // Must have signatures\n-    CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n-}    \n-\n-BOOST_AUTO_TEST_CASE(script_combineSigs)\n-{\n-    // Test the CombineSignatures function\n-    CBasicKeyStore keystore;\n-    vector<CKey> keys;\n-    vector<CPubKey> pubkeys;\n-    for (int i = 0; i < 3; i++)\n-    {\n-        CKey key;\n-        key.MakeNewKey(i%2 == 1);\n-        keys.push_back(key);\n-        pubkeys.push_back(key.GetPubKey());\n-        keystore.AddKey(key);\n-    }\n-\n-    CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n-    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), txFrom);\n-    CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n-    CScript& scriptSig = txTo.vin[0].scriptSig;\n-\n-    CScript empty;\n-    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, empty, empty);\n-    BOOST_CHECK(combined.empty());\n-\n-    // Single signature case:\n-    SignSignature(keystore, txFrom, txTo, 0); // changes scriptSig\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n-    CScript scriptSigCopy = scriptSig;\n-    // Signing again will give a different, valid signature:\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n-\n-    // P2SH, single-signature case:\n-    CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n-    keystore.AddCScript(pkSingle);\n-    scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n-    scriptSigCopy = scriptSig;\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n-    // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n-    scriptSigCopy = CScript() << OP_0 << static_cast<vector<unsigned char> >(pkSingle);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, scriptSigCopy);\n-    BOOST_CHECK(combined == scriptSig);\n-\n-    // Hardest case:  Multisig 2-of-3\n-    scriptPubKey = GetScriptForMultisig(2, pubkeys);\n-    keystore.AddCScript(scriptPubKey);\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n-\n-    // A couple of partially-signed versions:\n-    vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL);\n-    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n-    sig1.push_back(SIGHASH_ALL);\n-    vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE);\n-    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n-    sig2.push_back(SIGHASH_NONE);\n-    vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE);\n-    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n-    sig3.push_back(SIGHASH_SINGLE);\n-\n-    // Not fussy about order (or even existence) of placeholders or signatures:\n-    CScript partial1a = CScript() << OP_0 << sig1 << OP_0;\n-    CScript partial1b = CScript() << OP_0 << OP_0 << sig1;\n-    CScript partial2a = CScript() << OP_0 << sig2;\n-    CScript partial2b = CScript() << sig2 << OP_0;\n-    CScript partial3a = CScript() << sig3;\n-    CScript partial3b = CScript() << OP_0 << OP_0 << sig3;\n-    CScript partial3c = CScript() << OP_0 << sig3 << OP_0;\n-    CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n-    CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n-    CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n-\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial1b);\n-    BOOST_CHECK(combined == partial1a);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial2a);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial1a);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1b, partial2b);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial1b);\n-    BOOST_CHECK(combined == complete13);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial3a);\n-    BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial2b);\n-    BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial3a);\n-    BOOST_CHECK(combined == partial3c);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_standard_push)\n-{\n-    for (int i=0; i<67000; i++) {\n-        CScript script;\n-        script << i;\n-        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Number \" << i << \" push is not minimal data.\");\n-    }\n-\n-    for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n-        std::vector<unsigned char> data(i, '\\111');\n-        CScript script;\n-        script << data;\n-        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Length \" << i << \" push is not minimal data.\");\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n-{\n-    // IsPushOnly returns false when given a script containing only pushes that\n-    // are invalid due to truncation. IsPushOnly() is consensus critical\n-    // because P2SH evaluation uses it, although this specific behavior should\n-    // not be consensus critical as the P2SH evaluation would fail first due to\n-    // the invalid push. Still, it doesn't hurt to test it explicitly.\n-    static const unsigned char direct[] = { 1 };\n-    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c9e8add701c2af76bd0c3961f4595ec240e45db1",
        "filename": "src/test/Checkpoints_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79cda9cbe1eae042e151734950b4842e2ee6dd2b/src/test/Checkpoints_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79cda9cbe1eae042e151734950b4842e2ee6dd2b/src/test/Checkpoints_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/Checkpoints_tests.cpp?ref=79cda9cbe1eae042e151734950b4842e2ee6dd2b",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n //\n-// Unit tests for block-chain checkpoints\n+// Unit tests for blockchain checkpoints\n //\n \n #include \"checkpoints.h\""
      },
      {
        "sha": "d3e797b96a148796d00f1ad600d33831888100f8",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79cda9cbe1eae042e151734950b4842e2ee6dd2b/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79cda9cbe1eae042e151734950b4842e2ee6dd2b/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=79cda9cbe1eae042e151734950b4842e2ee6dd2b",
        "patch": "@@ -571,7 +571,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     // NOTE: CHECKMULTISIG has an unfortunate bug; it requires\n     // one extra item on the stack, before the signatures.\n     // Putting OP_0 on the stack is the workaround;\n-    // fixing the bug would mean splitting the block chain (old\n+    // fixing the bug would mean splitting the blockchain (old\n     // clients would not accept new CHECKMULTISIG transactions,\n     // and vice-versa)\n     //"
      }
    ]
  }
]