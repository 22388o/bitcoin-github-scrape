[
  {
    "sha": "5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2QwMWQyMzVhNmE4ZmI4NmFlNjkzY2RlZDc4YjU1MzVjZGM5NGIz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T17:57:58Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-19T13:33:37Z"
      },
      "message": "[tests] Fix flake8 warnings in feature_block.py",
      "tree": {
        "sha": "1ccc9e16e6e3dc38b3a9126fed40a0cf1b6c6372",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ccc9e16e6e3dc38b3a9126fed40a0cf1b6c6372"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd01d235a6a8fb86ae693cded78b5535cdc94b3/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00d1680498c5550e7db1f359202d3433a092fafd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00d1680498c5550e7db1f359202d3433a092fafd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00d1680498c5550e7db1f359202d3433a092fafd"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 109,
      "deletions": 100
    },
    "files": [
      {
        "sha": "59c336e11dbb6c4772301a4e45282026186cc91c",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 109,
        "deletions": 100,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cd01d235a6a8fb86ae693cded78b5535cdc94b3/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cd01d235a6a8fb86ae693cded78b5535cdc94b3/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
        "patch": "@@ -2,27 +2,59 @@\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test block processing.\n-\n-This reimplements tests from the bitcoinj/FullBlockTestGenerator used\n-by the pull-tester.\n-\n-We use the testing framework in which we expect a particular answer from\n-each test.\n-\"\"\"\n+\"\"\"Test block processing.\"\"\"\n+import copy\n+import struct\n+import time\n \n+from test_framework.blocktools import create_block, create_coinbase, create_transaction, get_legacy_sigopcount_block\n+from test_framework.comptool import RejectResult, TestInstance, TestManager\n+from test_framework.key import CECKey\n+from test_framework.messages import (\n+    CBlock,\n+    CBlockHeader,\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+    MAX_BLOCK_BASE_SIZE,\n+    uint256_from_compact,\n+    uint256_from_str,\n+)\n+from test_framework.mininode import network_thread_start\n+from test_framework.script import (\n+    CScript,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGVERIFY,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_FALSE,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_INVALIDOPCODE,\n+    OP_RETURN,\n+    OP_TRUE,\n+    SIGHASH_ALL,\n+    SignatureHash,\n+    hash160,\n+)\n from test_framework.test_framework import ComparisonTestFramework\n from test_framework.util import *\n from test_framework.comptool import TestManager, TestInstance, RejectResult\n from test_framework.blocktools import *\n import time\n from test_framework.key import CECKey\n from test_framework.script import *\n-from test_framework.mininode import network_thread_start\n import struct\n \n class PreviousSpendableOutput():\n-    def __init__(self, tx = CTransaction(), n = -1):\n+    def __init__(self, tx=CTransaction(), n=-1):\n         self.tx = tx\n         self.n = n  # the output we're spending\n \n@@ -76,7 +108,7 @@ def run_test(self):\n         self.test.run()\n \n     def add_transactions_to_block(self, block, tx_list):\n-        [ tx.rehash() for tx in tx_list ]\n+        [tx.rehash() for tx in tx_list]\n         block.vtx.extend(tx_list)\n \n     # this is a little handier to use than the version in blocktools.py\n@@ -101,9 +133,9 @@ def create_and_sign_transaction(self, spend_tx, n, value, script=CScript([OP_TRU\n         return tx\n \n     def next_block(self, number, spend=None, additional_coinbase_value=0, script=CScript([OP_TRUE]), solve=True):\n-        if self.tip == None:\n+        if self.tip is None:\n             base_block_hash = self.genesis_hash\n-            block_time = int(time.time())+1\n+            block_time = int(time.time()) + 1\n         else:\n             base_block_hash = self.tip.sha256\n             block_time = self.tip.nTime + 1\n@@ -112,10 +144,10 @@ def next_block(self, number, spend=None, additional_coinbase_value=0, script=CSc\n         coinbase = create_coinbase(height, self.coinbase_pubkey)\n         coinbase.vout[0].nValue += additional_coinbase_value\n         coinbase.rehash()\n-        if spend == None:\n+        if spend is None:\n             block = create_block(base_block_hash, coinbase, block_time)\n         else:\n-            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1 # all but one satoshi to fees\n+            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1  # all but one satoshi to fees\n             coinbase.rehash()\n             block = create_block(base_block_hash, coinbase, block_time)\n             tx = create_transaction(spend.tx, spend.n, b\"\", 1, script)  # spend 1 satoshi\n@@ -148,7 +180,7 @@ def accepted():\n             return TestInstance([[self.tip, True]])\n \n         # returns a test case that asserts that the current tip was rejected\n-        def rejected(reject = None):\n+        def rejected(reject=None):\n             if reject is None:\n                 return TestInstance([[self.tip, False]])\n             else:\n@@ -181,14 +213,12 @@ def update_block(block_number, new_transactions):\n         # these must be updated if consensus changes\n         MAX_BLOCK_SIGOPS = 20000\n \n-\n         # Create a new block\n         block(0)\n         save_spendable_output()\n         yield accepted()\n \n-\n-        # Now we need that block to mature so we can spend the coinbase.\n+        #  Now we need that block to mature so we can spend the coinbase.\n         test = TestInstance(sync_every_block=False)\n         for i in range(99):\n             block(5000 + i)\n@@ -223,15 +253,13 @@ def update_block(block_number, new_transactions):\n         txout_b3 = PreviousSpendableOutput(b3.vtx[1], 0)\n         yield rejected()\n \n-\n         # Now we add another block to make the alternative chain longer.\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1) -> b4 (2)\n         block(4, spend=out[2])\n         yield accepted()\n \n-\n         # ... and back to the first chain.\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                      \\-> b3 (1) -> b4 (2)\n@@ -273,7 +301,6 @@ def update_block(block_number, new_transactions):\n         block(11, spend=out[4], additional_coinbase_value=1)\n         yield rejected(RejectResult(16, b'bad-cb-amount'))\n \n-\n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b14 (5)\n@@ -293,7 +320,7 @@ def update_block(block_number, new_transactions):\n         block(14, spend=out[5], additional_coinbase_value=1)\n         yield rejected()\n \n-        yield TestInstance([[b12, True, b13.sha256]]) # New tip should be b13.\n+        yield TestInstance([[b12, True, b13.sha256]])  # New tip should be b13.\n \n         # Add a block with MAX_BLOCK_SIGOPS and one with one more sigop\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -307,13 +334,11 @@ def update_block(block_number, new_transactions):\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Test that a block with too many checksigs is rejected\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n         block(16, spend=out[6], script=too_many_checksigs)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n-\n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b17 (b3.vtx[1])\n@@ -376,10 +401,10 @@ def update_block(block_number, new_transactions):\n         tip(15)\n         b24 = block(24, spend=out[6])\n         script_length = MAX_BLOCK_BASE_SIZE - len(b24.serialize()) - 69\n-        script_output = CScript([b'\\x00' * (script_length+1)])\n+        script_output = CScript([b'\\x00' * (script_length + 1)])\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = update_block(24, [tx])\n-        assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE+1)\n+        assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n         yield rejected(RejectResult(16, b'bad-blk-length'))\n \n         block(25, spend=out[7])\n@@ -433,7 +458,7 @@ def update_block(block_number, new_transactions):\n         #\n \n         # MULTISIG: each op code counts as 20 sigops.  To create the edge case, pack another 19 sigops at the end.\n-        lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS-1) // 20) + [OP_CHECKSIG] * 19)\n+        lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n         b31 = block(31, spend=out[8], script=lots_of_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b31), MAX_BLOCK_SIGOPS)\n         yield accepted()\n@@ -445,10 +470,9 @@ def update_block(block_number, new_transactions):\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n-\n         # CHECKMULTISIGVERIFY\n         tip(31)\n-        lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS-1) // 20) + [OP_CHECKSIG] * 19)\n+        lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n         block(33, spend=out[9], script=lots_of_multisigs)\n         yield accepted()\n         save_spendable_output()\n@@ -457,7 +481,6 @@ def update_block(block_number, new_transactions):\n         block(34, spend=out[10], script=too_many_multisigs)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n-\n         # CHECKSIGVERIFY\n         tip(33)\n         lots_of_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS - 1))\n@@ -469,7 +492,6 @@ def update_block(block_number, new_transactions):\n         block(36, spend=out[11], script=too_many_checksigs)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n-\n         # Check spending of a transaction in a block which failed to connect\n         #\n         # b6  (3)\n@@ -508,7 +530,7 @@ def update_block(block_number, new_transactions):\n         b39_sigops_per_output = 6\n \n         # Build the redeem script, hash it, use hash to create the p2sh script\n-        redeem_script = CScript([self.coinbase_pubkey] + [OP_2DUP, OP_CHECKSIGVERIFY]*5 + [OP_CHECKSIG])\n+        redeem_script = CScript([self.coinbase_pubkey] + [OP_2DUP, OP_CHECKSIGVERIFY] * 5 + [OP_CHECKSIG])\n         redeem_script_hash = hash160(redeem_script)\n         p2sh_script = CScript([OP_HASH160, redeem_script_hash, OP_EQUAL])\n \n@@ -525,23 +547,22 @@ def update_block(block_number, new_transactions):\n         # Until block is full, add tx's with 1 satoshi to p2sh_script, the rest to OP_TRUE\n         tx_new = None\n         tx_last = tx\n-        total_size=len(b39.serialize())\n+        total_size = len(b39.serialize())\n         while(total_size < MAX_BLOCK_BASE_SIZE):\n             tx_new = create_tx(tx_last, 1, 1, p2sh_script)\n             tx_new.vout.append(CTxOut(tx_last.vout[1].nValue - 1, CScript([OP_TRUE])))\n             tx_new.rehash()\n             total_size += len(tx_new.serialize())\n             if total_size >= MAX_BLOCK_BASE_SIZE:\n                 break\n-            b39.vtx.append(tx_new) # add tx to block\n+            b39.vtx.append(tx_new)  # add tx to block\n             tx_last = tx_new\n             b39_outputs += 1\n \n         b39 = update_block(39, [])\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Test sigops in P2SH redeem scripts\n         #\n         # b40 creates 3333 tx's spending the 6-sigop P2SH outputs from b39 for a total of 19998 sigops.\n@@ -557,7 +578,7 @@ def update_block(block_number, new_transactions):\n \n         lastOutpoint = COutPoint(b40.vtx[1].sha256, 0)\n         new_txs = []\n-        for i in range(1, numTxes+1):\n+        for i in range(1, numTxes + 1):\n             tx = CTransaction()\n             tx.vout.append(CTxOut(1, CScript([OP_TRUE])))\n             tx.vin.append(CTxIn(lastOutpoint, b''))\n@@ -608,7 +629,6 @@ def update_block(block_number, new_transactions):\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Test a number of really invalid scenarios\n         #\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b44 (14)\n@@ -640,32 +660,31 @@ def update_block(block_number, new_transactions):\n         b45.hashMerkleRoot = b45.calc_merkle_root()\n         b45.calc_sha256()\n         b45.solve()\n-        self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256]+1\n+        self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n         yield rejected(RejectResult(16, b'bad-cb-missing'))\n \n         # A block with no txns\n         tip(44)\n         b46 = CBlock()\n-        b46.nTime = b44.nTime+1\n+        b46.nTime = b44.nTime + 1\n         b46.hashPrevBlock = b44.sha256\n         b46.nBits = 0x207fffff\n         b46.vtx = []\n         b46.hashMerkleRoot = 0\n         b46.solve()\n-        self.block_heights[b46.sha256] = self.block_heights[b44.sha256]+1\n+        self.block_heights[b46.sha256] = self.block_heights[b44.sha256] + 1\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        s = ser_uint256(b46.hashMerkleRoot)\n         yield rejected(RejectResult(16, b'bad-blk-length'))\n \n         # A block with invalid work\n         tip(44)\n         b47 = block(47, solve=False)\n         target = uint256_from_compact(b47.nBits)\n-        while b47.sha256 < target: #changed > to <\n+        while b47.sha256 < target:  # changed > to <\n             b47.nNonce += 1\n             b47.rehash()\n         yield rejected(RejectResult(16, b'high-hash'))\n@@ -693,9 +712,9 @@ def update_block(block_number, new_transactions):\n \n         # A block with two coinbase txns\n         tip(44)\n-        b51 = block(51)\n+        block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n-        b51 = update_block(51, [cb2])\n+        update_block(51, [cb2])\n         yield rejected(RejectResult(16, b'bad-cb-multiple'))\n \n         # A block w/ duplicate txns\n@@ -712,7 +731,7 @@ def update_block(block_number, new_transactions):\n         #\n         tip(43)\n         block(53, spend=out[14])\n-        yield rejected() # rejected since b44 is at same height\n+        yield rejected()  # rejected since b44 is at same height\n         save_spendable_output()\n \n         # invalid timestamp (b35 is 5 blocks back, so its time is MedianTimePast)\n@@ -729,15 +748,14 @@ def update_block(block_number, new_transactions):\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Test CVE-2012-2459\n         #\n         # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57p2 (16)\n         #                                                \\-> b57   (16)\n         #                                                \\-> b56p2 (16)\n         #                                                \\-> b56   (16)\n         #\n-        # Merkle tree malleability (CVE-2012-2459): repeating sequences of transactions in a block without \n+        # Merkle tree malleability (CVE-2012-2459): repeating sequences of transactions in a block without\n         #                           affecting the merkle root of a block, while still invalidating it.\n         #                           See:  src/consensus/merkle.h\n         #\n@@ -768,7 +786,7 @@ def update_block(block_number, new_transactions):\n         tip(55)\n         b56 = copy.deepcopy(b57)\n         self.blocks[56] = b56\n-        assert_equal(len(b56.vtx),3)\n+        assert_equal(len(b56.vtx), 3)\n         b56 = update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n         yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n@@ -788,15 +806,15 @@ def update_block(block_number, new_transactions):\n         b56p2 = copy.deepcopy(b57p2)\n         self.blocks[\"b56p2\"] = b56p2\n         assert_equal(b56p2.hash, b57p2.hash)\n-        assert_equal(len(b56p2.vtx),6)\n+        assert_equal(len(b56p2.vtx), 6)\n         b56p2 = update_block(\"b56p2\", [tx3, tx4])\n         yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n \n         tip(\"57p2\")\n         yield accepted()\n \n         tip(57)\n-        yield rejected()  #rejected because 57p2 seen first\n+        yield rejected()  # rejected because 57p2 seen first\n         save_spendable_output()\n \n         # Test a few invalid tx types\n@@ -807,20 +825,20 @@ def update_block(block_number, new_transactions):\n \n         # tx with prevout.n out of range\n         tip(57)\n-        b58 = block(58, spend=out[17])\n+        block(58, spend=out[17])\n         tx = CTransaction()\n         assert(len(out[17].tx.vout) < 42)\n         tx.vin.append(CTxIn(COutPoint(out[17].tx.sha256, 42), CScript([OP_TRUE]), 0xffffffff))\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n-        b58 = update_block(58, [tx])\n+        update_block(58, [tx])\n         yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # tx with output value > input value out of range\n         tip(57)\n-        b59 = block(59)\n-        tx = create_and_sign_tx(out[17].tx, out[17].n, 51*COIN)\n-        b59 = update_block(59, [tx])\n+        block(59)\n+        tx = create_and_sign_tx(out[17].tx, out[17].n, 51 * COIN)\n+        update_block(59, [tx])\n         yield rejected(RejectResult(16, b'bad-txns-in-belowout'))\n \n         # reset to good chain\n@@ -840,31 +858,29 @@ def update_block(block_number, new_transactions):\n         #\n         tip(60)\n         b61 = block(61, spend=out[18])\n-        b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  #equalize the coinbases\n+        b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  # equalize the coinbases\n         b61.vtx[0].rehash()\n         b61 = update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n         yield rejected(RejectResult(16, b'bad-txns-BIP30'))\n \n-\n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n         #                                                                                     \\-> b62 (18)\n         #\n         tip(60)\n-        b62 = block(62)\n+        block(62)\n         tx = CTransaction()\n-        tx.nLockTime = 0xffffffff  #this locktime is non-final\n+        tx.nLockTime = 0xffffffff  # this locktime is non-final\n         assert(out[18].n < len(out[18].tx.vout))\n-        tx.vin.append(CTxIn(COutPoint(out[18].tx.sha256, out[18].n))) # don't set nSequence\n+        tx.vin.append(CTxIn(COutPoint(out[18].tx.sha256, out[18].n)))  # don't set nSequence\n         tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n-        b62 = update_block(62, [tx])\n+        update_block(62, [tx])\n         yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n \n-\n         # Test a non-final coinbase is also rejected\n         #\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n@@ -878,7 +894,6 @@ def update_block(block_number, new_transactions):\n         b63 = update_block(63, [])\n         yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n \n-\n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n         #  does not cause a subsequent, identical block with canonical encoding to be rejected.  The test does not\n@@ -976,13 +991,13 @@ def update_block(block_number, new_transactions):\n         #\n         tip(65)\n         block(68, additional_coinbase_value=10)\n-        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue-9)\n+        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 9)\n         update_block(68, [tx])\n         yield rejected(RejectResult(16, b'bad-cb-amount'))\n \n         tip(65)\n         b69 = block(69, additional_coinbase_value=10)\n-        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue-10)\n+        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 10)\n         update_block(69, [tx])\n         yield accepted()\n         save_spendable_output()\n@@ -1002,7 +1017,6 @@ def update_block(block_number, new_transactions):\n         update_block(70, [tx])\n         yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n-\n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n         #  -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20) -> b72 (21)\n@@ -1031,7 +1045,6 @@ def update_block(block_number, new_transactions):\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Test some invalid scripts and MAX_BLOCK_SIGOPS\n         #\n         # -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20) -> b72 (21)\n@@ -1053,17 +1066,17 @@ def update_block(block_number, new_transactions):\n         b73 = block(73)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1\n         a = bytearray([OP_CHECKSIG] * size)\n-        a[MAX_BLOCK_SIGOPS - 1] = int(\"4e\",16) # OP_PUSHDATA4\n+        a[MAX_BLOCK_SIGOPS - 1] = int(\"4e\", 16)  # OP_PUSHDATA4\n \n         element_size = MAX_SCRIPT_ELEMENT_SIZE + 1\n         a[MAX_BLOCK_SIGOPS] = element_size % 256\n-        a[MAX_BLOCK_SIGOPS+1] = element_size // 256\n-        a[MAX_BLOCK_SIGOPS+2] = 0\n-        a[MAX_BLOCK_SIGOPS+3] = 0\n+        a[MAX_BLOCK_SIGOPS + 1] = element_size // 256\n+        a[MAX_BLOCK_SIGOPS + 2] = 0\n+        a[MAX_BLOCK_SIGOPS + 3] = 0\n \n         tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n         b73 = update_block(73, [tx])\n-        assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS+1)\n+        assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n@@ -1079,40 +1092,40 @@ def update_block(block_number, new_transactions):\n         #\n         #\n         tip(72)\n-        b74 = block(74)\n-        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42 # total = 20,561\n+        block(74)\n+        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42  # total = 20,561\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS] = 0x4e\n-        a[MAX_BLOCK_SIGOPS+1] = 0xfe\n-        a[MAX_BLOCK_SIGOPS+2] = 0xff\n-        a[MAX_BLOCK_SIGOPS+3] = 0xff\n-        a[MAX_BLOCK_SIGOPS+4] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 1] = 0xfe\n+        a[MAX_BLOCK_SIGOPS + 2] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 3] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 4] = 0xff\n         tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n-        b74 = update_block(74, [tx])\n+        update_block(74, [tx])\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         tip(72)\n-        b75 = block(75)\n+        block(75)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42\n         a = bytearray([OP_CHECKSIG] * size)\n-        a[MAX_BLOCK_SIGOPS-1] = 0x4e\n+        a[MAX_BLOCK_SIGOPS - 1] = 0x4e\n         a[MAX_BLOCK_SIGOPS] = 0xff\n-        a[MAX_BLOCK_SIGOPS+1] = 0xff\n-        a[MAX_BLOCK_SIGOPS+2] = 0xff\n-        a[MAX_BLOCK_SIGOPS+3] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 1] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 2] = 0xff\n+        a[MAX_BLOCK_SIGOPS + 3] = 0xff\n         tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n-        b75 = update_block(75, [tx])\n+        update_block(75, [tx])\n         yield accepted()\n         save_spendable_output()\n \n         # Check that if we push an element filled with CHECKSIGs, they are not counted\n         tip(75)\n-        b76 = block(76)\n+        block(76)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5\n         a = bytearray([OP_CHECKSIG] * size)\n-        a[MAX_BLOCK_SIGOPS-1] = 0x4e # PUSHDATA4, but leave the following bytes as just checksigs\n+        a[MAX_BLOCK_SIGOPS - 1] = 0x4e  # PUSHDATA4, but leave the following bytes as just checksigs\n         tx = create_and_sign_tx(out[23].tx, 0, 1, CScript(a))\n-        b76 = update_block(76, [tx])\n+        update_block(76, [tx])\n         yield accepted()\n         save_spendable_output()\n \n@@ -1136,18 +1149,18 @@ def update_block(block_number, new_transactions):\n         #\n         tip(76)\n         block(77)\n-        tx77 = create_and_sign_tx(out[24].tx, out[24].n, 10*COIN)\n+        tx77 = create_and_sign_tx(out[24].tx, out[24].n, 10 * COIN)\n         update_block(77, [tx77])\n         yield accepted()\n         save_spendable_output()\n \n         block(78)\n-        tx78 = create_tx(tx77, 0, 9*COIN)\n+        tx78 = create_tx(tx77, 0, 9 * COIN)\n         update_block(78, [tx78])\n         yield accepted()\n \n         block(79)\n-        tx79 = create_tx(tx78, 0, 8*COIN)\n+        tx79 = create_tx(tx78, 0, 8 * COIN)\n         update_block(79, [tx79])\n         yield accepted()\n \n@@ -1160,7 +1173,7 @@ def update_block(block_number, new_transactions):\n         save_spendable_output()\n \n         block(81, spend=out[26])\n-        yield rejected() # other chain is same length\n+        yield rejected()  # other chain is same length\n         save_spendable_output()\n \n         block(82, spend=out[27])\n@@ -1173,7 +1186,6 @@ def update_block(block_number, new_transactions):\n         assert(tx78.hash in mempool)\n         assert(tx79.hash in mempool)\n \n-\n         # Test invalid opcodes in dead execution paths.\n         #\n         #  -> b81 (26) -> b82 (27) -> b83 (28)\n@@ -1191,7 +1203,6 @@ def update_block(block_number, new_transactions):\n         yield accepted()\n         save_spendable_output()\n \n-\n         # Reorg on/off blocks that have OP_RETURN in them (and try to spend them)\n         #\n         #  -> b81 (26) -> b82 (27) -> b83 (28) -> b84 (29) -> b87 (30) -> b88 (31)\n@@ -1215,7 +1226,7 @@ def update_block(block_number, new_transactions):\n         tx4.vout.append(CTxOut(0, CScript([OP_RETURN])))\n         tx5 = create_tx(tx1, 4, 0, CScript([OP_RETURN]))\n \n-        update_block(84, [tx1,tx2,tx3,tx4,tx5])\n+        update_block(84, [tx1, tx2, tx3, tx4, tx5])\n         yield accepted()\n         save_spendable_output()\n \n@@ -1241,15 +1252,14 @@ def update_block(block_number, new_transactions):\n         update_block(\"89a\", [tx])\n         yield rejected()\n \n-\n         #  Test re-org of a week's worth of blocks (1088 blocks)\n         #  This test takes a minute or two and can be accomplished in memory\n         #\n         if self.options.runbarelyexpensive:\n             tip(88)\n             LARGE_REORG_SIZE = 1088\n             test1 = TestInstance(sync_every_block=False)\n-            spend=out[32]\n+            spend = out[32]\n             for i in range(89, LARGE_REORG_SIZE + 89):\n                 b = block(i, spend)\n                 tx = CTransaction()\n@@ -1270,7 +1280,7 @@ def update_block(block_number, new_transactions):\n             tip(88)\n             test2 = TestInstance(sync_every_block=False)\n             for i in range(89, LARGE_REORG_SIZE + 89):\n-                block(\"alt\"+str(i))\n+                block(\"alt\" + str(i))\n                 test2.blocks_and_transactions.append([self.tip, False])\n             yield test2\n \n@@ -1288,6 +1298,5 @@ def update_block(block_number, new_transactions):\n             chain1_tip += 2\n \n \n-\n if __name__ == '__main__':\n     FullBlockTest().main()"
      }
    ]
  },
  {
    "sha": "3898c4f3d7afa0abf876831bf479c3b8f1514070",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozODk4YzRmM2Q3YWZhMGFiZjg3NjgzMWJmNDc5YzNiOGYxNTE0MDcw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T18:47:03Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-19T13:33:37Z"
      },
      "message": "[tests] Tidy up feature_block.py\n\n- move all helper methods to the end\n- remove block, create_tx and create_and_sign_tx shortcuts\n- remove --runbarelyexpensive option, since it defaults to True and it's\nunlikely that anyone ever runs the test with this option set to false.",
      "tree": {
        "sha": "0c5ebf957a5d438a20294387e6dd10547bf229f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c5ebf957a5d438a20294387e6dd10547bf229f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3898c4f3d7afa0abf876831bf479c3b8f1514070",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3898c4f3d7afa0abf876831bf479c3b8f1514070",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3898c4f3d7afa0abf876831bf479c3b8f1514070",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3898c4f3d7afa0abf876831bf479c3b8f1514070/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd01d235a6a8fb86ae693cded78b5535cdc94b3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd01d235a6a8fb86ae693cded78b5535cdc94b3"
      }
    ],
    "stats": {
      "total": 1005,
      "additions": 497,
      "deletions": 508
    },
    "files": [
      {
        "sha": "e026e85a3cd24dcde91488a00d125e3b174edd5b",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 497,
        "deletions": 508,
        "changes": 1005,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3898c4f3d7afa0abf876831bf479c3b8f1514070/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3898c4f3d7afa0abf876831bf479c3b8f1514070/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=3898c4f3d7afa0abf876831bf479c3b8f1514070",
        "patch": "@@ -53,6 +53,8 @@\n from test_framework.script import *\n import struct\n \n+MAX_BLOCK_SIGOPS = 20000\n+\n class PreviousSpendableOutput():\n     def __init__(self, tx=CTransaction(), n=-1):\n         self.tx = tx\n@@ -97,228 +99,123 @@ def set_test_params(self):\n         self.tip = None\n         self.blocks = {}\n \n-    def add_options(self, parser):\n-        super().add_options(parser)\n-        parser.add_option(\"--runbarelyexpensive\", dest=\"runbarelyexpensive\", default=True)\n-\n     def run_test(self):\n         self.test = TestManager(self, self.options.tmpdir)\n         self.test.add_all_connections(self.nodes)\n         network_thread_start()\n         self.test.run()\n \n-    def add_transactions_to_block(self, block, tx_list):\n-        [tx.rehash() for tx in tx_list]\n-        block.vtx.extend(tx_list)\n-\n-    # this is a little handier to use than the version in blocktools.py\n-    def create_tx(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n-        tx = create_transaction(spend_tx, n, b\"\", value, script)\n-        return tx\n-\n-    # sign a transaction, using the key we know about\n-    # this signs input 0 in tx, which is assumed to be spending output n in spend_tx\n-    def sign_tx(self, tx, spend_tx, n):\n-        scriptPubKey = bytearray(spend_tx.vout[n].scriptPubKey)\n-        if (scriptPubKey[0] == OP_TRUE):  # an anyone-can-spend\n-            tx.vin[0].scriptSig = CScript()\n-            return\n-        (sighash, err) = SignatureHash(spend_tx.vout[n].scriptPubKey, tx, 0, SIGHASH_ALL)\n-        tx.vin[0].scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n-\n-    def create_and_sign_transaction(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n-        tx = self.create_tx(spend_tx, n, value, script)\n-        self.sign_tx(tx, spend_tx, n)\n-        tx.rehash()\n-        return tx\n-\n-    def next_block(self, number, spend=None, additional_coinbase_value=0, script=CScript([OP_TRUE]), solve=True):\n-        if self.tip is None:\n-            base_block_hash = self.genesis_hash\n-            block_time = int(time.time()) + 1\n-        else:\n-            base_block_hash = self.tip.sha256\n-            block_time = self.tip.nTime + 1\n-        # First create the coinbase\n-        height = self.block_heights[base_block_hash] + 1\n-        coinbase = create_coinbase(height, self.coinbase_pubkey)\n-        coinbase.vout[0].nValue += additional_coinbase_value\n-        coinbase.rehash()\n-        if spend is None:\n-            block = create_block(base_block_hash, coinbase, block_time)\n-        else:\n-            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1  # all but one satoshi to fees\n-            coinbase.rehash()\n-            block = create_block(base_block_hash, coinbase, block_time)\n-            tx = create_transaction(spend.tx, spend.n, b\"\", 1, script)  # spend 1 satoshi\n-            self.sign_tx(tx, spend.tx, spend.n)\n-            self.add_transactions_to_block(block, [tx])\n-            block.hashMerkleRoot = block.calc_merkle_root()\n-        if solve:\n-            block.solve()\n-        self.tip = block\n-        self.block_heights[block.sha256] = height\n-        assert number not in self.blocks\n-        self.blocks[number] = block\n-        return block\n-\n     def get_tests(self):\n         self.genesis_hash = int(self.nodes[0].getbestblockhash(), 16)\n         self.block_heights[self.genesis_hash] = 0\n-        spendable_outputs = []\n-\n-        # save the current tip so it can be spent by a later block\n-        def save_spendable_output():\n-            spendable_outputs.append(self.tip)\n-\n-        # get an output that we previously marked as spendable\n-        def get_spendable_output():\n-            return PreviousSpendableOutput(spendable_outputs.pop(0).vtx[0], 0)\n-\n-        # returns a test case that asserts that the current tip was accepted\n-        def accepted():\n-            return TestInstance([[self.tip, True]])\n-\n-        # returns a test case that asserts that the current tip was rejected\n-        def rejected(reject=None):\n-            if reject is None:\n-                return TestInstance([[self.tip, False]])\n-            else:\n-                return TestInstance([[self.tip, reject]])\n-\n-        # move the tip back to a previous block\n-        def tip(number):\n-            self.tip = self.blocks[number]\n-\n-        # adds transactions to the block and updates state\n-        def update_block(block_number, new_transactions):\n-            block = self.blocks[block_number]\n-            self.add_transactions_to_block(block, new_transactions)\n-            old_sha256 = block.sha256\n-            block.hashMerkleRoot = block.calc_merkle_root()\n-            block.solve()\n-            # Update the internal state just like in next_block\n-            self.tip = block\n-            if block.sha256 != old_sha256:\n-                self.block_heights[block.sha256] = self.block_heights[old_sha256]\n-                del self.block_heights[old_sha256]\n-            self.blocks[block_number] = block\n-            return block\n-\n-        # shorthand for functions\n-        block = self.next_block\n-        create_tx = self.create_tx\n-        create_and_sign_tx = self.create_and_sign_transaction\n-\n-        # these must be updated if consensus changes\n-        MAX_BLOCK_SIGOPS = 20000\n+        self.spendable_outputs = []\n \n         # Create a new block\n-        block(0)\n-        save_spendable_output()\n-        yield accepted()\n+        self.next_block(0)\n+        self.save_spendable_output()\n+        yield self.accepted()\n \n         #  Now we need that block to mature so we can spend the coinbase.\n         test = TestInstance(sync_every_block=False)\n         for i in range(99):\n-            block(5000 + i)\n+            self.next_block(5000 + i)\n             test.blocks_and_transactions.append([self.tip, True])\n-            save_spendable_output()\n+            self.save_spendable_output()\n         yield test\n \n         # collect spendable outputs now to avoid cluttering the code later on\n         out = []\n         for i in range(33):\n-            out.append(get_spendable_output())\n+            out.append(self.get_spendable_output())\n \n         # Start by building a couple of blocks on top (which output is spent is\n         # in parentheses):\n         #     genesis -> b1 (0) -> b2 (1)\n-        block(1, spend=out[0])\n-        save_spendable_output()\n-        yield accepted()\n+        self.next_block(1, spend=out[0])\n+        self.save_spendable_output()\n+        yield self.accepted()\n \n-        block(2, spend=out[1])\n-        yield accepted()\n-        save_spendable_output()\n+        self.next_block(2, spend=out[1])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # so fork like this:\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1)\n         #\n         # Nothing should happen at this point. We saw b2 first so it takes priority.\n-        tip(1)\n-        b3 = block(3, spend=out[1])\n+        self.move_tip(1)\n+        b3 = self.next_block(3, spend=out[1])\n         txout_b3 = PreviousSpendableOutput(b3.vtx[1], 0)\n-        yield rejected()\n+        yield self.rejected()\n \n         # Now we add another block to make the alternative chain longer.\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1) -> b4 (2)\n-        block(4, spend=out[2])\n-        yield accepted()\n+        self.next_block(4, spend=out[2])\n+        yield self.accepted()\n \n         # ... and back to the first chain.\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(2)\n-        block(5, spend=out[2])\n-        save_spendable_output()\n-        yield rejected()\n+        self.move_tip(2)\n+        self.next_block(5, spend=out[2])\n+        self.save_spendable_output()\n+        yield self.rejected()\n \n-        block(6, spend=out[3])\n-        yield accepted()\n+        self.next_block(6, spend=out[3])\n+        yield self.accepted()\n \n         # Try to create a fork that double-spends\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                          \\-> b7 (2) -> b8 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(5)\n-        block(7, spend=out[2])\n-        yield rejected()\n+        self.move_tip(5)\n+        self.next_block(7, spend=out[2])\n+        yield self.rejected()\n \n-        block(8, spend=out[4])\n-        yield rejected()\n+        self.next_block(8, spend=out[4])\n+        yield self.rejected()\n \n         # Try to create a block that has too much fee\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                                    \\-> b9 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(6)\n-        block(9, spend=out[4], additional_coinbase_value=1)\n-        yield rejected(RejectResult(16, b'bad-cb-amount'))\n+        self.move_tip(6)\n+        self.next_block(9, spend=out[4], additional_coinbase_value=1)\n+        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b10 (3) -> b11 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(5)\n-        block(10, spend=out[3])\n-        yield rejected()\n+        self.move_tip(5)\n+        self.next_block(10, spend=out[3])\n+        yield self.rejected()\n \n-        block(11, spend=out[4], additional_coinbase_value=1)\n-        yield rejected(RejectResult(16, b'bad-cb-amount'))\n+        self.next_block(11, spend=out[4], additional_coinbase_value=1)\n+        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n \n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b14 (5)\n         #                                              (b12 added last)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(5)\n-        b12 = block(12, spend=out[3])\n-        save_spendable_output()\n-        b13 = block(13, spend=out[4])\n+        self.move_tip(5)\n+        b12 = self.next_block(12, spend=out[3])\n+        self.save_spendable_output()\n+        b13 = self.next_block(13, spend=out[4])\n         # Deliver the block header for b12, and the block b13.\n         # b13 should be accepted but the tip won't advance until b12 is delivered.\n         yield TestInstance([[CBlockHeader(b12), None], [b13, False]])\n \n-        save_spendable_output()\n+        self.save_spendable_output()\n         # b14 is invalid, but the node won't know that until it tries to connect\n         # Tip still can't advance because b12 is missing\n-        block(14, spend=out[5], additional_coinbase_value=1)\n-        yield rejected()\n+        self.next_block(14, spend=out[5], additional_coinbase_value=1)\n+        yield self.rejected()\n \n         yield TestInstance([[b12, True, b13.sha256]])  # New tip should be b13.\n \n@@ -329,125 +226,125 @@ def update_block(block_number, new_transactions):\n \n         # Test that a block with a lot of checksigs is okay\n         lots_of_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS - 1))\n-        tip(13)\n-        block(15, spend=out[5], script=lots_of_checksigs)\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(13)\n+        self.next_block(15, spend=out[5], script=lots_of_checksigs)\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test that a block with too many checksigs is rejected\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n-        block(16, spend=out[6], script=too_many_checksigs)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.next_block(16, spend=out[6], script=too_many_checksigs)\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b17 (b3.vtx[1])\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(15)\n-        block(17, spend=txout_b3)\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.move_tip(15)\n+        self.next_block(17, spend=txout_b3)\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # Attempt to spend a transaction created on a different fork (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5)\n         #                                                                \\-> b18 (b3.vtx[1]) -> b19 (6)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(13)\n-        block(18, spend=txout_b3)\n-        yield rejected()\n+        self.move_tip(13)\n+        self.next_block(18, spend=txout_b3)\n+        yield self.rejected()\n \n-        block(19, spend=out[6])\n-        yield rejected()\n+        self.next_block(19, spend=out[6])\n+        yield self.rejected()\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b20 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(15)\n-        block(20, spend=out[7])\n-        yield rejected(RejectResult(16, b'bad-txns-premature-spend-of-coinbase'))\n+        self.move_tip(15)\n+        self.next_block(20, spend=out[7])\n+        yield self.rejected(RejectResult(16, b'bad-txns-premature-spend-of-coinbase'))\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5)\n         #                                                                \\-> b21 (6) -> b22 (5)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(13)\n-        block(21, spend=out[6])\n-        yield rejected()\n+        self.move_tip(13)\n+        self.next_block(21, spend=out[6])\n+        yield self.rejected()\n \n-        block(22, spend=out[5])\n-        yield rejected()\n+        self.next_block(22, spend=out[5])\n+        yield self.rejected()\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b23 (6)\n         #                                                                           \\-> b24 (6) -> b25 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(15)\n-        b23 = block(23, spend=out[6])\n+        self.move_tip(15)\n+        b23 = self.next_block(23, spend=out[6])\n         tx = CTransaction()\n         script_length = MAX_BLOCK_BASE_SIZE - len(b23.serialize()) - 69\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n         tx.vin.append(CTxIn(COutPoint(b23.vtx[1].sha256, 0)))\n-        b23 = update_block(23, [tx])\n+        b23 = self.update_block(23, [tx])\n         # Make sure the math above worked out to produce a max-sized block\n         assert_equal(len(b23.serialize()), MAX_BLOCK_BASE_SIZE)\n-        yield accepted()\n-        save_spendable_output()\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Make the next block one byte bigger and check that it fails\n-        tip(15)\n-        b24 = block(24, spend=out[6])\n+        self.move_tip(15)\n+        b24 = self.next_block(24, spend=out[6])\n         script_length = MAX_BLOCK_BASE_SIZE - len(b24.serialize()) - 69\n         script_output = CScript([b'\\x00' * (script_length + 1)])\n         tx.vout = [CTxOut(0, script_output)]\n-        b24 = update_block(24, [tx])\n+        b24 = self.update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n-        yield rejected(RejectResult(16, b'bad-blk-length'))\n+        yield self.rejected(RejectResult(16, b'bad-blk-length'))\n \n-        block(25, spend=out[7])\n-        yield rejected()\n+        self.next_block(25, spend=out[7])\n+        yield self.rejected()\n \n         # Create blocks with a coinbase input script size out of range\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b23 (6) -> b30 (7)\n         #                                                                           \\-> ... (6) -> ... (7)\n         #                      \\-> b3 (1) -> b4 (2)\n-        tip(15)\n-        b26 = block(26, spend=out[6])\n+        self.move_tip(15)\n+        b26 = self.next_block(26, spend=out[6])\n         b26.vtx[0].vin[0].scriptSig = b'\\x00'\n         b26.vtx[0].rehash()\n         # update_block causes the merkle root to get updated, even with no new\n         # transactions, and updates the required state.\n-        b26 = update_block(26, [])\n-        yield rejected(RejectResult(16, b'bad-cb-length'))\n+        b26 = self.update_block(26, [])\n+        yield self.rejected(RejectResult(16, b'bad-cb-length'))\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n-        block(27, spend=out[7])\n-        yield rejected(False)\n+        self.next_block(27, spend=out[7])\n+        yield self.rejected(False)\n \n         # Now try a too-large-coinbase script\n-        tip(15)\n-        b28 = block(28, spend=out[6])\n+        self.move_tip(15)\n+        b28 = self.next_block(28, spend=out[6])\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n-        b28 = update_block(28, [])\n-        yield rejected(RejectResult(16, b'bad-cb-length'))\n+        b28 = self.update_block(28, [])\n+        yield self.rejected(RejectResult(16, b'bad-cb-length'))\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n-        block(29, spend=out[7])\n-        yield rejected(False)\n+        self.next_block(29, spend=out[7])\n+        yield self.rejected(False)\n \n         # b30 has a max-sized coinbase scriptSig.\n-        tip(23)\n-        b30 = block(30)\n+        self.move_tip(23)\n+        b30 = self.next_block(30)\n         b30.vtx[0].vin[0].scriptSig = b'\\x00' * 100\n         b30.vtx[0].rehash()\n-        b30 = update_block(30, [])\n-        yield accepted()\n-        save_spendable_output()\n+        b30 = self.update_block(30, [])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # b31 - b35 - check sigops of OP_CHECKMULTISIG / OP_CHECKMULTISIGVERIFY / OP_CHECKSIGVERIFY\n         #\n@@ -459,38 +356,38 @@ def update_block(block_number, new_transactions):\n \n         # MULTISIG: each op code counts as 20 sigops.  To create the edge case, pack another 19 sigops at the end.\n         lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n-        b31 = block(31, spend=out[8], script=lots_of_multisigs)\n+        b31 = self.next_block(31, spend=out[8], script=lots_of_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b31), MAX_BLOCK_SIGOPS)\n-        yield accepted()\n-        save_spendable_output()\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # this goes over the limit because the coinbase has one sigop\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n-        b32 = block(32, spend=out[9], script=too_many_multisigs)\n+        b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # CHECKMULTISIGVERIFY\n-        tip(31)\n+        self.move_tip(31)\n         lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n-        block(33, spend=out[9], script=lots_of_multisigs)\n-        yield accepted()\n-        save_spendable_output()\n+        self.next_block(33, spend=out[9], script=lots_of_multisigs)\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n-        block(34, spend=out[10], script=too_many_multisigs)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.next_block(34, spend=out[10], script=too_many_multisigs)\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # CHECKSIGVERIFY\n-        tip(33)\n+        self.move_tip(33)\n         lots_of_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS - 1))\n-        b35 = block(35, spend=out[10], script=lots_of_checksigs)\n-        yield accepted()\n-        save_spendable_output()\n+        b35 = self.next_block(35, spend=out[10], script=lots_of_checksigs)\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n-        block(36, spend=out[11], script=too_many_checksigs)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.next_block(36, spend=out[11], script=too_many_checksigs)\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # Check spending of a transaction in a block which failed to connect\n         #\n@@ -501,17 +398,17 @@ def update_block(block_number, new_transactions):\n         #\n \n         # save 37's spendable output, but then double-spend out11 to invalidate the block\n-        tip(35)\n-        b37 = block(37, spend=out[11])\n+        self.move_tip(35)\n+        b37 = self.next_block(37, spend=out[11])\n         txout_b37 = PreviousSpendableOutput(b37.vtx[1], 0)\n-        tx = create_and_sign_tx(out[11].tx, out[11].n, 0)\n-        b37 = update_block(37, [tx])\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        tx = self.create_and_sign_transaction(out[11].tx, out[11].n, 0)\n+        b37 = self.update_block(37, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n-        tip(35)\n-        block(38, spend=txout_b37)\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.move_tip(35)\n+        self.next_block(38, spend=txout_b37)\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # Check P2SH SigOp counting\n         #\n@@ -524,8 +421,8 @@ def update_block(block_number, new_transactions):\n         #           redeem_script = COINBASE_PUBKEY, (OP_2DUP+OP_CHECKSIGVERIFY) * 5, OP_CHECKSIG\n         #           p2sh_script = OP_HASH160, ripemd160(sha256(script)), OP_EQUAL\n         #\n-        tip(35)\n-        b39 = block(39)\n+        self.move_tip(35)\n+        b39 = self.next_block(39)\n         b39_outputs = 0\n         b39_sigops_per_output = 6\n \n@@ -537,19 +434,19 @@ def update_block(block_number, new_transactions):\n         # Create a transaction that spends one satoshi to the p2sh_script, the rest to OP_TRUE\n         # This must be signed because it is spending a coinbase\n         spend = out[11]\n-        tx = create_tx(spend.tx, spend.n, 1, p2sh_script)\n+        tx = self.create_tx(spend.tx, spend.n, 1, p2sh_script)\n         tx.vout.append(CTxOut(spend.tx.vout[spend.n].nValue - 1, CScript([OP_TRUE])))\n         self.sign_tx(tx, spend.tx, spend.n)\n         tx.rehash()\n-        b39 = update_block(39, [tx])\n+        b39 = self.update_block(39, [tx])\n         b39_outputs += 1\n \n         # Until block is full, add tx's with 1 satoshi to p2sh_script, the rest to OP_TRUE\n         tx_new = None\n         tx_last = tx\n         total_size = len(b39.serialize())\n         while(total_size < MAX_BLOCK_BASE_SIZE):\n-            tx_new = create_tx(tx_last, 1, 1, p2sh_script)\n+            tx_new = self.create_tx(tx_last, 1, 1, p2sh_script)\n             tx_new.vout.append(CTxOut(tx_last.vout[1].nValue - 1, CScript([OP_TRUE])))\n             tx_new.rehash()\n             total_size += len(tx_new.serialize())\n@@ -559,9 +456,9 @@ def update_block(block_number, new_transactions):\n             tx_last = tx_new\n             b39_outputs += 1\n \n-        b39 = update_block(39, [])\n-        yield accepted()\n-        save_spendable_output()\n+        b39 = self.update_block(39, [])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test sigops in P2SH redeem scripts\n         #\n@@ -570,8 +467,8 @@ def update_block(block_number, new_transactions):\n         #\n         # b41 does the same, less one, so it has the maximum sigops permitted.\n         #\n-        tip(39)\n-        b40 = block(40, spend=out[12])\n+        self.move_tip(39)\n+        b40 = self.next_block(40, spend=out[12])\n         sigops = get_legacy_sigopcount_block(b40)\n         numTxes = (MAX_BLOCK_SIGOPS - sigops) // b39_sigops_per_output\n         assert_equal(numTxes <= b39_outputs, True)\n@@ -600,34 +497,34 @@ def update_block(block_number, new_transactions):\n         tx.vout.append(CTxOut(1, CScript([OP_CHECKSIG] * b40_sigops_to_fill)))\n         tx.rehash()\n         new_txs.append(tx)\n-        update_block(40, new_txs)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.update_block(40, new_txs)\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # same as b40, but one less sigop\n-        tip(39)\n-        block(41, spend=None)\n-        update_block(41, b40.vtx[1:-1])\n+        self.move_tip(39)\n+        self.next_block(41, spend=None)\n+        self.update_block(41, b40.vtx[1:-1])\n         b41_sigops_to_fill = b40_sigops_to_fill - 1\n         tx = CTransaction()\n         tx.vin.append(CTxIn(lastOutpoint, b''))\n         tx.vout.append(CTxOut(1, CScript([OP_CHECKSIG] * b41_sigops_to_fill)))\n         tx.rehash()\n-        update_block(41, [tx])\n-        yield accepted()\n+        self.update_block(41, [tx])\n+        yield self.accepted()\n \n         # Fork off of b39 to create a constant base again\n         #\n         # b23 (6) -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13)\n         #                                                                  \\-> b41 (12)\n         #\n-        tip(39)\n-        block(42, spend=out[12])\n-        yield rejected()\n-        save_spendable_output()\n+        self.move_tip(39)\n+        self.next_block(42, spend=out[12])\n+        yield self.rejected()\n+        self.save_spendable_output()\n \n-        block(43, spend=out[13])\n-        yield accepted()\n-        save_spendable_output()\n+        self.next_block(43, spend=out[13])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test a number of really invalid scenarios\n         #\n@@ -648,10 +545,10 @@ def update_block(block_number, new_transactions):\n         self.tip = b44\n         self.block_heights[b44.sha256] = height\n         self.blocks[44] = b44\n-        yield accepted()\n+        yield self.accepted()\n \n         # A block with a non-coinbase as the first tx\n-        non_coinbase = create_tx(out[15].tx, out[15].n, 1)\n+        non_coinbase = self.create_tx(out[15].tx, out[15].n, 1)\n         b45 = CBlock()\n         b45.nTime = self.tip.nTime + 1\n         b45.hashPrevBlock = self.tip.sha256\n@@ -663,10 +560,10 @@ def update_block(block_number, new_transactions):\n         self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n-        yield rejected(RejectResult(16, b'bad-cb-missing'))\n+        yield self.rejected(RejectResult(16, b'bad-cb-missing'))\n \n         # A block with no txns\n-        tip(44)\n+        self.move_tip(44)\n         b46 = CBlock()\n         b46.nTime = b44.nTime + 1\n         b46.hashPrevBlock = b44.sha256\n@@ -678,75 +575,75 @@ def update_block(block_number, new_transactions):\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        yield rejected(RejectResult(16, b'bad-blk-length'))\n+        yield self.rejected(RejectResult(16, b'bad-blk-length'))\n \n         # A block with invalid work\n-        tip(44)\n-        b47 = block(47, solve=False)\n+        self.move_tip(44)\n+        b47 = self.next_block(47, solve=False)\n         target = uint256_from_compact(b47.nBits)\n         while b47.sha256 < target:  # changed > to <\n             b47.nNonce += 1\n             b47.rehash()\n-        yield rejected(RejectResult(16, b'high-hash'))\n+        yield self.rejected(RejectResult(16, b'high-hash'))\n \n         # A block with timestamp > 2 hrs in the future\n-        tip(44)\n-        b48 = block(48, solve=False)\n+        self.move_tip(44)\n+        b48 = self.next_block(48, solve=False)\n         b48.nTime = int(time.time()) + 60 * 60 * 3\n         b48.solve()\n-        yield rejected(RejectResult(16, b'time-too-new'))\n+        yield self.rejected(RejectResult(16, b'time-too-new'))\n \n         # A block with an invalid merkle hash\n-        tip(44)\n-        b49 = block(49)\n+        self.move_tip(44)\n+        b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n-        yield rejected(RejectResult(16, b'bad-txnmrklroot'))\n+        yield self.rejected(RejectResult(16, b'bad-txnmrklroot'))\n \n         # A block with an incorrect POW limit\n-        tip(44)\n-        b50 = block(50)\n+        self.move_tip(44)\n+        b50 = self.next_block(50)\n         b50.nBits = b50.nBits - 1\n         b50.solve()\n-        yield rejected(RejectResult(16, b'bad-diffbits'))\n+        yield self.rejected(RejectResult(16, b'bad-diffbits'))\n \n         # A block with two coinbase txns\n-        tip(44)\n-        block(51)\n+        self.move_tip(44)\n+        self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n-        update_block(51, [cb2])\n-        yield rejected(RejectResult(16, b'bad-cb-multiple'))\n+        self.update_block(51, [cb2])\n+        yield self.rejected(RejectResult(16, b'bad-cb-multiple'))\n \n         # A block w/ duplicate txns\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n-        tip(44)\n-        b52 = block(52, spend=out[15])\n-        tx = create_tx(b52.vtx[1], 0, 1)\n-        b52 = update_block(52, [tx, tx])\n-        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.move_tip(44)\n+        b52 = self.next_block(52, spend=out[15])\n+        tx = self.create_tx(b52.vtx[1], 0, 1)\n+        b52 = self.update_block(52, [tx, tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n \n         # Test block timestamps\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n         #                                                                                   \\-> b54 (15)\n         #\n-        tip(43)\n-        block(53, spend=out[14])\n-        yield rejected()  # rejected since b44 is at same height\n-        save_spendable_output()\n+        self.move_tip(43)\n+        self.next_block(53, spend=out[14])\n+        yield self.rejected()  # rejected since b44 is at same height\n+        self.save_spendable_output()\n \n         # invalid timestamp (b35 is 5 blocks back, so its time is MedianTimePast)\n-        b54 = block(54, spend=out[15])\n+        b54 = self.next_block(54, spend=out[15])\n         b54.nTime = b35.nTime - 1\n         b54.solve()\n-        yield rejected(RejectResult(16, b'time-too-old'))\n+        yield self.rejected(RejectResult(16, b'time-too-old'))\n \n         # valid timestamp\n-        tip(53)\n-        b55 = block(55, spend=out[15])\n+        self.move_tip(53)\n+        b55 = self.next_block(55, spend=out[15])\n         b55.nTime = b35.nTime\n-        update_block(55, [])\n-        yield accepted()\n-        save_spendable_output()\n+        self.update_block(55, [])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test CVE-2012-2459\n         #\n@@ -776,46 +673,46 @@ def update_block(block_number, new_transactions):\n         #  that the error was caught early, avoiding a DOS vulnerability.)\n \n         # b57 - a good block with 2 txs, don't submit until end\n-        tip(55)\n-        b57 = block(57)\n-        tx = create_and_sign_tx(out[16].tx, out[16].n, 1)\n-        tx1 = create_tx(tx, 0, 1)\n-        b57 = update_block(57, [tx, tx1])\n+        self.move_tip(55)\n+        b57 = self.next_block(57)\n+        tx = self.create_and_sign_transaction(out[16].tx, out[16].n, 1)\n+        tx1 = self.create_tx(tx, 0, 1)\n+        b57 = self.update_block(57, [tx, tx1])\n \n         # b56 - copy b57, add a duplicate tx\n-        tip(55)\n+        self.move_tip(55)\n         b56 = copy.deepcopy(b57)\n         self.blocks[56] = b56\n         assert_equal(len(b56.vtx), 3)\n-        b56 = update_block(56, [tx1])\n+        b56 = self.update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n-        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n \n         # b57p2 - a good block with 6 tx'es, don't submit until end\n-        tip(55)\n-        b57p2 = block(\"57p2\")\n-        tx = create_and_sign_tx(out[16].tx, out[16].n, 1)\n-        tx1 = create_tx(tx, 0, 1)\n-        tx2 = create_tx(tx1, 0, 1)\n-        tx3 = create_tx(tx2, 0, 1)\n-        tx4 = create_tx(tx3, 0, 1)\n-        b57p2 = update_block(\"57p2\", [tx, tx1, tx2, tx3, tx4])\n+        self.move_tip(55)\n+        b57p2 = self.next_block(\"57p2\")\n+        tx = self.create_and_sign_transaction(out[16].tx, out[16].n, 1)\n+        tx1 = self.create_tx(tx, 0, 1)\n+        tx2 = self.create_tx(tx1, 0, 1)\n+        tx3 = self.create_tx(tx2, 0, 1)\n+        tx4 = self.create_tx(tx3, 0, 1)\n+        b57p2 = self.update_block(\"57p2\", [tx, tx1, tx2, tx3, tx4])\n \n         # b56p2 - copy b57p2, duplicate two non-consecutive tx's\n-        tip(55)\n+        self.move_tip(55)\n         b56p2 = copy.deepcopy(b57p2)\n         self.blocks[\"b56p2\"] = b56p2\n         assert_equal(b56p2.hash, b57p2.hash)\n         assert_equal(len(b56p2.vtx), 6)\n-        b56p2 = update_block(\"b56p2\", [tx3, tx4])\n-        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        b56p2 = self.update_block(\"b56p2\", [tx3, tx4])\n+        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n \n-        tip(\"57p2\")\n-        yield accepted()\n+        self.move_tip(\"57p2\")\n+        yield self.accepted()\n \n-        tip(57)\n-        yield rejected()  # rejected because 57p2 seen first\n-        save_spendable_output()\n+        self.move_tip(57)\n+        yield self.rejected()  # rejected because 57p2 seen first\n+        self.save_spendable_output()\n \n         # Test a few invalid tx types\n         #\n@@ -824,28 +721,28 @@ def update_block(block_number, new_transactions):\n         #\n \n         # tx with prevout.n out of range\n-        tip(57)\n-        block(58, spend=out[17])\n+        self.move_tip(57)\n+        self.next_block(58, spend=out[17])\n         tx = CTransaction()\n         assert(len(out[17].tx.vout) < 42)\n         tx.vin.append(CTxIn(COutPoint(out[17].tx.sha256, 42), CScript([OP_TRUE]), 0xffffffff))\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n-        update_block(58, [tx])\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.update_block(58, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # tx with output value > input value out of range\n-        tip(57)\n-        block(59)\n-        tx = create_and_sign_tx(out[17].tx, out[17].n, 51 * COIN)\n-        update_block(59, [tx])\n-        yield rejected(RejectResult(16, b'bad-txns-in-belowout'))\n+        self.move_tip(57)\n+        self.next_block(59)\n+        tx = self.create_and_sign_transaction(out[17].tx, out[17].n, 51 * COIN)\n+        self.update_block(59, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-in-belowout'))\n \n         # reset to good chain\n-        tip(57)\n-        b60 = block(60, spend=out[17])\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(57)\n+        b60 = self.next_block(60, spend=out[17])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test BIP30\n         #\n@@ -856,43 +753,43 @@ def update_block(block_number, new_transactions):\n         # not-fully-spent transaction in the same chain. To test, make identical coinbases;\n         # the second one should be rejected.\n         #\n-        tip(60)\n-        b61 = block(61, spend=out[18])\n+        self.move_tip(60)\n+        b61 = self.next_block(61, spend=out[18])\n         b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  # equalize the coinbases\n         b61.vtx[0].rehash()\n-        b61 = update_block(61, [])\n+        b61 = self.update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n-        yield rejected(RejectResult(16, b'bad-txns-BIP30'))\n+        yield self.rejected(RejectResult(16, b'bad-txns-BIP30'))\n \n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n         #                                                                                     \\-> b62 (18)\n         #\n-        tip(60)\n-        block(62)\n+        self.move_tip(60)\n+        self.next_block(62)\n         tx = CTransaction()\n         tx.nLockTime = 0xffffffff  # this locktime is non-final\n         assert(out[18].n < len(out[18].tx.vout))\n         tx.vin.append(CTxIn(COutPoint(out[18].tx.sha256, out[18].n)))  # don't set nSequence\n         tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n-        update_block(62, [tx])\n-        yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+        self.update_block(62, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-nonfinal'))\n \n         # Test a non-final coinbase is also rejected\n         #\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n         #                                                                                     \\-> b63 (-)\n         #\n-        tip(60)\n-        b63 = block(63)\n+        self.move_tip(60)\n+        b63 = self.next_block(63)\n         b63.vtx[0].nLockTime = 0xffffffff\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n-        b63 = update_block(63, [])\n-        yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+        b63 = self.update_block(63, [])\n+        yield self.rejected(RejectResult(16, b'bad-txns-nonfinal'))\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -908,8 +805,8 @@ def update_block(block_number, new_transactions):\n         #  b64a is a bloated block (non-canonical varint)\n         #  b64 is a good block (same as b64 but w/ canonical varint)\n         #\n-        tip(60)\n-        regular_block = block(\"64a\", spend=out[18])\n+        self.move_tip(60)\n+        regular_block = self.next_block(\"64a\", spend=out[18])\n \n         # make it a \"broken_block,\" with non-canonical serialization\n         b64a = CBrokenBlock(regular_block)\n@@ -923,59 +820,59 @@ def update_block(block_number, new_transactions):\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n-        b64a = update_block(\"64a\", [tx])\n+        b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n         yield TestInstance([[self.tip, None]])\n \n         # comptool workaround: to make sure b64 is delivered, manually erase b64a from blockstore\n         self.test.block_store.erase(b64a.sha256)\n \n-        tip(60)\n+        self.move_tip(60)\n         b64 = CBlock(b64a)\n         b64.vtx = copy.deepcopy(b64a.vtx)\n         assert_equal(b64.hash, b64a.hash)\n         assert_equal(len(b64.serialize()), MAX_BLOCK_BASE_SIZE)\n         self.blocks[64] = b64\n-        update_block(64, [])\n-        yield accepted()\n-        save_spendable_output()\n+        self.update_block(64, [])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Spend an output created in the block itself\n         #\n         # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n         #\n-        tip(64)\n-        block(65)\n-        tx1 = create_and_sign_tx(out[19].tx, out[19].n, out[19].tx.vout[0].nValue)\n-        tx2 = create_and_sign_tx(tx1, 0, 0)\n-        update_block(65, [tx1, tx2])\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(64)\n+        self.next_block(65)\n+        tx1 = self.create_and_sign_transaction(out[19].tx, out[19].n, out[19].tx.vout[0].nValue)\n+        tx2 = self.create_and_sign_transaction(tx1, 0, 0)\n+        self.update_block(65, [tx1, tx2])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Attempt to spend an output created later in the same block\n         #\n         # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n         #                                                                                    \\-> b66 (20)\n-        tip(65)\n-        block(66)\n-        tx1 = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n-        tx2 = create_and_sign_tx(tx1, 0, 1)\n-        update_block(66, [tx2, tx1])\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.move_tip(65)\n+        self.next_block(66)\n+        tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n+        tx2 = self.create_and_sign_transaction(tx1, 0, 1)\n+        self.update_block(66, [tx2, tx1])\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # Attempt to double-spend a transaction created in a block\n         #\n         # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n         #                                                                                    \\-> b67 (20)\n         #\n         #\n-        tip(65)\n-        block(67)\n-        tx1 = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n-        tx2 = create_and_sign_tx(tx1, 0, 1)\n-        tx3 = create_and_sign_tx(tx1, 0, 2)\n-        update_block(67, [tx1, tx2, tx3])\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.move_tip(65)\n+        self.next_block(67)\n+        tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n+        tx2 = self.create_and_sign_transaction(tx1, 0, 1)\n+        tx3 = self.create_and_sign_transaction(tx1, 0, 2)\n+        self.update_block(67, [tx1, tx2, tx3])\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # More tests of block subsidy\n         #\n@@ -989,33 +886,33 @@ def update_block(block_number, new_transactions):\n         # b69 - coinbase with extra 10 satoshis, and a tx that gives a 10 satoshi fee\n         #       this succeeds\n         #\n-        tip(65)\n-        block(68, additional_coinbase_value=10)\n-        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 9)\n-        update_block(68, [tx])\n-        yield rejected(RejectResult(16, b'bad-cb-amount'))\n+        self.move_tip(65)\n+        self.next_block(68, additional_coinbase_value=10)\n+        tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 9)\n+        self.update_block(68, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n \n-        tip(65)\n-        b69 = block(69, additional_coinbase_value=10)\n-        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 10)\n-        update_block(69, [tx])\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(65)\n+        b69 = self.next_block(69, additional_coinbase_value=10)\n+        tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 10)\n+        self.update_block(69, [tx])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test spending the outpoint of a non-existent transaction\n         #\n         # -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20)\n         #                                                                                    \\-> b70 (21)\n         #\n-        tip(69)\n-        block(70, spend=out[21])\n+        self.move_tip(69)\n+        self.next_block(70, spend=out[21])\n         bogus_tx = CTransaction()\n         bogus_tx.sha256 = uint256_from_str(b\"23c70ed7c0506e9178fc1a987f40a33946d4ad4c962b5ae3a52546da53af0c5c\")\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n         tx.vout.append(CTxOut(1, b\"\"))\n-        update_block(70, [tx])\n-        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.update_block(70, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n@@ -1025,11 +922,11 @@ def update_block(block_number, new_transactions):\n         # b72 is a good block.\n         # b71 is a copy of 72, but re-adds one of its transactions.  However, it has the same hash as b71.\n         #\n-        tip(69)\n-        b72 = block(72)\n-        tx1 = create_and_sign_tx(out[21].tx, out[21].n, 2)\n-        tx2 = create_and_sign_tx(tx1, 0, 1)\n-        b72 = update_block(72, [tx1, tx2])  # now tip is 72\n+        self.move_tip(69)\n+        b72 = self.next_block(72)\n+        tx1 = self.create_and_sign_transaction(out[21].tx, out[21].n, 2)\n+        tx2 = self.create_and_sign_transaction(tx1, 0, 1)\n+        b72 = self.update_block(72, [tx1, tx2])  # now tip is 72\n         b71 = copy.deepcopy(b72)\n         b71.vtx.append(tx2)   # add duplicate tx2\n         self.block_heights[b71.sha256] = self.block_heights[b69.sha256] + 1  # b71 builds off b69\n@@ -1039,11 +936,11 @@ def update_block(block_number, new_transactions):\n         assert_equal(len(b72.vtx), 3)\n         assert_equal(b72.sha256, b71.sha256)\n \n-        tip(71)\n-        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n-        tip(72)\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(71)\n+        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.move_tip(72)\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test some invalid scripts and MAX_BLOCK_SIGOPS\n         #\n@@ -1062,8 +959,8 @@ def update_block(block_number, new_transactions):\n         #       bytearray[20,004-20,525]: unread data (script_element)\n         #       bytearray[20,526]       : OP_CHECKSIG (this puts us over the limit)\n         #\n-        tip(72)\n-        b73 = block(73)\n+        self.move_tip(72)\n+        b73 = self.next_block(73)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS - 1] = int(\"4e\", 16)  # OP_PUSHDATA4\n@@ -1074,10 +971,10 @@ def update_block(block_number, new_transactions):\n         a[MAX_BLOCK_SIGOPS + 2] = 0\n         a[MAX_BLOCK_SIGOPS + 3] = 0\n \n-        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n-        b73 = update_block(73, [tx])\n+        tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n+        b73 = self.update_block(73, [tx])\n         assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n         #          but sigops after the element are not counted.\n@@ -1091,43 +988,43 @@ def update_block(block_number, new_transactions):\n         #       b75 succeeds because we put MAX_BLOCK_SIGOPS before the element\n         #\n         #\n-        tip(72)\n-        block(74)\n+        self.move_tip(72)\n+        self.next_block(74)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42  # total = 20,561\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS] = 0x4e\n         a[MAX_BLOCK_SIGOPS + 1] = 0xfe\n         a[MAX_BLOCK_SIGOPS + 2] = 0xff\n         a[MAX_BLOCK_SIGOPS + 3] = 0xff\n         a[MAX_BLOCK_SIGOPS + 4] = 0xff\n-        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n-        update_block(74, [tx])\n-        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+        tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n+        self.update_block(74, [tx])\n+        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n-        tip(72)\n-        block(75)\n+        self.move_tip(72)\n+        self.next_block(75)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS - 1] = 0x4e\n         a[MAX_BLOCK_SIGOPS] = 0xff\n         a[MAX_BLOCK_SIGOPS + 1] = 0xff\n         a[MAX_BLOCK_SIGOPS + 2] = 0xff\n         a[MAX_BLOCK_SIGOPS + 3] = 0xff\n-        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n-        update_block(75, [tx])\n-        yield accepted()\n-        save_spendable_output()\n+        tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n+        self.update_block(75, [tx])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Check that if we push an element filled with CHECKSIGs, they are not counted\n-        tip(75)\n-        block(76)\n+        self.move_tip(75)\n+        self.next_block(76)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS - 1] = 0x4e  # PUSHDATA4, but leave the following bytes as just checksigs\n-        tx = create_and_sign_tx(out[23].tx, 0, 1, CScript(a))\n-        update_block(76, [tx])\n-        yield accepted()\n-        save_spendable_output()\n+        tx = self.create_and_sign_transaction(out[23].tx, 0, 1, CScript(a))\n+        self.update_block(76, [tx])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Test transaction resurrection\n         #\n@@ -1147,38 +1044,38 @@ def update_block(block_number, new_transactions):\n         #    spend to OP_TRUE.  If the standard-ness rules change, this test would need to be\n         #    updated.  (Perhaps to spend to a P2SH OP_TRUE script)\n         #\n-        tip(76)\n-        block(77)\n-        tx77 = create_and_sign_tx(out[24].tx, out[24].n, 10 * COIN)\n-        update_block(77, [tx77])\n-        yield accepted()\n-        save_spendable_output()\n+        self.move_tip(76)\n+        self.next_block(77)\n+        tx77 = self.create_and_sign_transaction(out[24].tx, out[24].n, 10 * COIN)\n+        self.update_block(77, [tx77])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n-        block(78)\n-        tx78 = create_tx(tx77, 0, 9 * COIN)\n-        update_block(78, [tx78])\n-        yield accepted()\n+        self.next_block(78)\n+        tx78 = self.create_tx(tx77, 0, 9 * COIN)\n+        self.update_block(78, [tx78])\n+        yield self.accepted()\n \n-        block(79)\n-        tx79 = create_tx(tx78, 0, 8 * COIN)\n-        update_block(79, [tx79])\n-        yield accepted()\n+        self.next_block(79)\n+        tx79 = self.create_tx(tx78, 0, 8 * COIN)\n+        self.update_block(79, [tx79])\n+        yield self.accepted()\n \n         # mempool should be empty\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n-        tip(77)\n-        block(80, spend=out[25])\n-        yield rejected()\n-        save_spendable_output()\n+        self.move_tip(77)\n+        self.next_block(80, spend=out[25])\n+        yield self.rejected()\n+        self.save_spendable_output()\n \n-        block(81, spend=out[26])\n-        yield rejected()  # other chain is same length\n-        save_spendable_output()\n+        self.next_block(81, spend=out[26])\n+        yield self.rejected()  # other chain is same length\n+        self.save_spendable_output()\n \n-        block(82, spend=out[27])\n-        yield accepted()  # now this chain is longer, triggers re-org\n-        save_spendable_output()\n+        self.next_block(82, spend=out[27])\n+        yield self.accepted()  # now this chain is longer, triggers re-org\n+        self.save_spendable_output()\n \n         # now check that tx78 and tx79 have been put back into the peer's mempool\n         mempool = self.nodes[0].getrawmempool()\n@@ -1190,112 +1087,204 @@ def update_block(block_number, new_transactions):\n         #\n         #  -> b81 (26) -> b82 (27) -> b83 (28)\n         #\n-        block(83)\n+        self.next_block(83)\n         op_codes = [OP_IF, OP_INVALIDOPCODE, OP_ELSE, OP_TRUE, OP_ENDIF]\n         script = CScript(op_codes)\n-        tx1 = create_and_sign_tx(out[28].tx, out[28].n, out[28].tx.vout[0].nValue, script)\n+        tx1 = self.create_and_sign_transaction(out[28].tx, out[28].n, out[28].tx.vout[0].nValue, script)\n \n-        tx2 = create_and_sign_tx(tx1, 0, 0, CScript([OP_TRUE]))\n+        tx2 = self.create_and_sign_transaction(tx1, 0, 0, CScript([OP_TRUE]))\n         tx2.vin[0].scriptSig = CScript([OP_FALSE])\n         tx2.rehash()\n \n-        update_block(83, [tx1, tx2])\n-        yield accepted()\n-        save_spendable_output()\n+        self.update_block(83, [tx1, tx2])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # Reorg on/off blocks that have OP_RETURN in them (and try to spend them)\n         #\n         #  -> b81 (26) -> b82 (27) -> b83 (28) -> b84 (29) -> b87 (30) -> b88 (31)\n         #                                    \\-> b85 (29) -> b86 (30)            \\-> b89a (32)\n         #\n         #\n-        block(84)\n-        tx1 = create_tx(out[29].tx, out[29].n, 0, CScript([OP_RETURN]))\n+        self.next_block(84)\n+        tx1 = self.create_tx(out[29].tx, out[29].n, 0, CScript([OP_RETURN]))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         tx1.calc_sha256()\n         self.sign_tx(tx1, out[29].tx, out[29].n)\n         tx1.rehash()\n-        tx2 = create_tx(tx1, 1, 0, CScript([OP_RETURN]))\n+        tx2 = self.create_tx(tx1, 1, 0, CScript([OP_RETURN]))\n         tx2.vout.append(CTxOut(0, CScript([OP_RETURN])))\n-        tx3 = create_tx(tx1, 2, 0, CScript([OP_RETURN]))\n+        tx3 = self.create_tx(tx1, 2, 0, CScript([OP_RETURN]))\n         tx3.vout.append(CTxOut(0, CScript([OP_TRUE])))\n-        tx4 = create_tx(tx1, 3, 0, CScript([OP_TRUE]))\n+        tx4 = self.create_tx(tx1, 3, 0, CScript([OP_TRUE]))\n         tx4.vout.append(CTxOut(0, CScript([OP_RETURN])))\n-        tx5 = create_tx(tx1, 4, 0, CScript([OP_RETURN]))\n+        tx5 = self.create_tx(tx1, 4, 0, CScript([OP_RETURN]))\n \n-        update_block(84, [tx1, tx2, tx3, tx4, tx5])\n-        yield accepted()\n-        save_spendable_output()\n+        self.update_block(84, [tx1, tx2, tx3, tx4, tx5])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n-        tip(83)\n-        block(85, spend=out[29])\n-        yield rejected()\n+        self.move_tip(83)\n+        self.next_block(85, spend=out[29])\n+        yield self.rejected()\n \n-        block(86, spend=out[30])\n-        yield accepted()\n+        self.next_block(86, spend=out[30])\n+        yield self.accepted()\n \n-        tip(84)\n-        block(87, spend=out[30])\n-        yield rejected()\n-        save_spendable_output()\n+        self.move_tip(84)\n+        self.next_block(87, spend=out[30])\n+        yield self.rejected()\n+        self.save_spendable_output()\n \n-        block(88, spend=out[31])\n-        yield accepted()\n-        save_spendable_output()\n+        self.next_block(88, spend=out[31])\n+        yield self.accepted()\n+        self.save_spendable_output()\n \n         # trying to spend the OP_RETURN output is rejected\n-        block(\"89a\", spend=out[32])\n-        tx = create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n-        update_block(\"89a\", [tx])\n-        yield rejected()\n-\n-        #  Test re-org of a week's worth of blocks (1088 blocks)\n-        #  This test takes a minute or two and can be accomplished in memory\n-        #\n-        if self.options.runbarelyexpensive:\n-            tip(88)\n-            LARGE_REORG_SIZE = 1088\n-            test1 = TestInstance(sync_every_block=False)\n-            spend = out[32]\n-            for i in range(89, LARGE_REORG_SIZE + 89):\n-                b = block(i, spend)\n-                tx = CTransaction()\n-                script_length = MAX_BLOCK_BASE_SIZE - len(b.serialize()) - 69\n-                script_output = CScript([b'\\x00' * script_length])\n-                tx.vout.append(CTxOut(0, script_output))\n-                tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n-                b = update_block(i, [tx])\n-                assert_equal(len(b.serialize()), MAX_BLOCK_BASE_SIZE)\n-                test1.blocks_and_transactions.append([self.tip, True])\n-                save_spendable_output()\n-                spend = get_spendable_output()\n-\n-            yield test1\n-            chain1_tip = i\n-\n-            # now create alt chain of same length\n-            tip(88)\n-            test2 = TestInstance(sync_every_block=False)\n-            for i in range(89, LARGE_REORG_SIZE + 89):\n-                block(\"alt\" + str(i))\n-                test2.blocks_and_transactions.append([self.tip, False])\n-            yield test2\n-\n-            # extend alt chain to trigger re-org\n-            block(\"alt\" + str(chain1_tip + 1))\n-            yield accepted()\n-\n-            # ... and re-org back to the first chain\n-            tip(chain1_tip)\n-            block(chain1_tip + 1)\n-            yield rejected()\n-            block(chain1_tip + 2)\n-            yield accepted()\n-\n-            chain1_tip += 2\n+        self.next_block(\"89a\", spend=out[32])\n+        tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n+        self.update_block(\"89a\", [tx])\n+        yield self.rejected()\n+\n+        self.move_tip(88)\n+        LARGE_REORG_SIZE = 1088\n+        test1 = TestInstance(sync_every_block=False)\n+        spend = out[32]\n+        for i in range(89, LARGE_REORG_SIZE + 89):\n+            b = self.next_block(i, spend)\n+            tx = CTransaction()\n+            script_length = MAX_BLOCK_BASE_SIZE - len(b.serialize()) - 69\n+            script_output = CScript([b'\\x00' * script_length])\n+            tx.vout.append(CTxOut(0, script_output))\n+            tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n+            b = self.update_block(i, [tx])\n+            assert_equal(len(b.serialize()), MAX_BLOCK_BASE_SIZE)\n+            test1.blocks_and_transactions.append([self.tip, True])\n+            self.save_spendable_output()\n+            spend = self.get_spendable_output()\n+\n+        yield test1\n+        chain1_tip = i\n+\n+        # now create alt chain of same length\n+        self.move_tip(88)\n+        test2 = TestInstance(sync_every_block=False)\n+        for i in range(89, LARGE_REORG_SIZE + 89):\n+            self.next_block(\"alt\" + str(i))\n+            test2.blocks_and_transactions.append([self.tip, False])\n+        yield test2\n+\n+        # extend alt chain to trigger re-org\n+        self.next_block(\"alt\" + str(chain1_tip + 1))\n+        yield self.accepted()\n+\n+        # ... and re-org back to the first chain\n+        self.move_tip(chain1_tip)\n+        self.next_block(chain1_tip + 1)\n+        yield self.rejected()\n+        self.next_block(chain1_tip + 2)\n+        yield self.accepted()\n+\n+        chain1_tip += 2\n+\n+    # Helper methods\n+    ################\n+\n+    def add_transactions_to_block(self, block, tx_list):\n+        [tx.rehash() for tx in tx_list]\n+        block.vtx.extend(tx_list)\n+\n+    # this is a little handier to use than the version in blocktools.py\n+    def create_tx(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n+        tx = create_transaction(spend_tx, n, b\"\", value, script)\n+        return tx\n+\n+    # sign a transaction, using the key we know about\n+    # this signs input 0 in tx, which is assumed to be spending output n in spend_tx\n+    def sign_tx(self, tx, spend_tx, n):\n+        scriptPubKey = bytearray(spend_tx.vout[n].scriptPubKey)\n+        if (scriptPubKey[0] == OP_TRUE):  # an anyone-can-spend\n+            tx.vin[0].scriptSig = CScript()\n+            return\n+        (sighash, err) = SignatureHash(spend_tx.vout[n].scriptPubKey, tx, 0, SIGHASH_ALL)\n+        tx.vin[0].scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n+\n+    def create_and_sign_transaction(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n+        tx = self.create_tx(spend_tx, n, value, script)\n+        self.sign_tx(tx, spend_tx, n)\n+        tx.rehash()\n+        return tx\n+\n+    def next_block(self, number, spend=None, additional_coinbase_value=0, script=CScript([OP_TRUE]), solve=True):\n+        if self.tip is None:\n+            base_block_hash = self.genesis_hash\n+            block_time = int(time.time()) + 1\n+        else:\n+            base_block_hash = self.tip.sha256\n+            block_time = self.tip.nTime + 1\n+        # First create the coinbase\n+        height = self.block_heights[base_block_hash] + 1\n+        coinbase = create_coinbase(height, self.coinbase_pubkey)\n+        coinbase.vout[0].nValue += additional_coinbase_value\n+        coinbase.rehash()\n+        if spend is None:\n+            block = create_block(base_block_hash, coinbase, block_time)\n+        else:\n+            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1  # all but one satoshi to fees\n+            coinbase.rehash()\n+            block = create_block(base_block_hash, coinbase, block_time)\n+            tx = create_transaction(spend.tx, spend.n, b\"\", 1, script)  # spend 1 satoshi\n+            self.sign_tx(tx, spend.tx, spend.n)\n+            self.add_transactions_to_block(block, [tx])\n+            block.hashMerkleRoot = block.calc_merkle_root()\n+        if solve:\n+            block.solve()\n+        self.tip = block\n+        self.block_heights[block.sha256] = height\n+        assert number not in self.blocks\n+        self.blocks[number] = block\n+        return block\n+\n+    # save the current tip so it can be spent by a later block\n+    def save_spendable_output(self):\n+        self.spendable_outputs.append(self.tip)\n+\n+    # get an output that we previously marked as spendable\n+    def get_spendable_output(self):\n+        return PreviousSpendableOutput(self.spendable_outputs.pop(0).vtx[0], 0)\n+\n+    # returns a test case that asserts that the current tip was accepted\n+    def accepted(self):\n+        return TestInstance([[self.tip, True]])\n+\n+    # returns a test case that asserts that the current tip was rejected\n+    def rejected(self, reject=None):\n+        if reject is None:\n+            return TestInstance([[self.tip, False]])\n+        else:\n+            return TestInstance([[self.tip, reject]])\n+\n+    # move the tip back to a previous block\n+    def move_tip(self, number):\n+        self.tip = self.blocks[number]\n+\n+    # adds transactions to the block and updates state\n+    def update_block(self, block_number, new_transactions):\n+        block = self.blocks[block_number]\n+        self.add_transactions_to_block(block, new_transactions)\n+        old_sha256 = block.sha256\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.solve()\n+        # Update the internal state just like in next_block\n+        self.tip = block\n+        if block.sha256 != old_sha256:\n+            self.block_heights[block.sha256] = self.block_heights[old_sha256]\n+            del self.block_heights[old_sha256]\n+        self.blocks[block_number] = block\n+        return block\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "fc02c12ae915ac040f64860048912d1624b921fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzAyYzEyYWU5MTVhYzA0MGY2NDg2MDA0ODkxMmQxNjI0YjkyMWZi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T19:07:26Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-19T13:33:37Z"
      },
      "message": "[tests] Add logging to feature_block.py",
      "tree": {
        "sha": "f00ac689e08a70d2158fe66aa2e420c54ff91f2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f00ac689e08a70d2158fe66aa2e420c54ff91f2b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc02c12ae915ac040f64860048912d1624b921fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc02c12ae915ac040f64860048912d1624b921fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc02c12ae915ac040f64860048912d1624b921fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc02c12ae915ac040f64860048912d1624b921fb/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3898c4f3d7afa0abf876831bf479c3b8f1514070",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3898c4f3d7afa0abf876831bf479c3b8f1514070",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3898c4f3d7afa0abf876831bf479c3b8f1514070"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 58,
      "deletions": 19
    },
    "files": [
      {
        "sha": "ad6b9eb21860a42c67164cb92faf08ae2c3269f2",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 58,
        "deletions": 19,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc02c12ae915ac040f64860048912d1624b921fb/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc02c12ae915ac040f64860048912d1624b921fb/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=fc02c12ae915ac040f64860048912d1624b921fb",
        "patch": "@@ -145,6 +145,7 @@ def get_tests(self):\n         #                      \\-> b3 (1)\n         #\n         # Nothing should happen at this point. We saw b2 first so it takes priority.\n+        self.log.info(\"Don't reorg to a chain of the same length\")\n         self.move_tip(1)\n         b3 = self.next_block(3, spend=out[1])\n         txout_b3 = PreviousSpendableOutput(b3.vtx[1], 0)\n@@ -154,6 +155,7 @@ def get_tests(self):\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reorg to a longer chain\")\n         self.next_block(4, spend=out[2])\n         yield self.accepted()\n \n@@ -165,13 +167,15 @@ def get_tests(self):\n         self.save_spendable_output()\n         yield self.rejected()\n \n+        self.log.info(\"Reorg back to the original chain\")\n         self.next_block(6, spend=out[3])\n         yield self.accepted()\n \n         # Try to create a fork that double-spends\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                          \\-> b7 (2) -> b8 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a chain with a double spend, even if it is longer\")\n         self.move_tip(5)\n         self.next_block(7, spend=out[2])\n         yield self.rejected()\n@@ -183,6 +187,7 @@ def get_tests(self):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                                    \\-> b9 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block where the miner creates too much coinbase reward\")\n         self.move_tip(6)\n         self.next_block(9, spend=out[4], additional_coinbase_value=1)\n         yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n@@ -191,6 +196,7 @@ def get_tests(self):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b10 (3) -> b11 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a chain where the miner creates too much coinbase reward, even if the chain is longer\")\n         self.move_tip(5)\n         self.next_block(10, spend=out[3])\n         yield self.rejected()\n@@ -203,6 +209,7 @@ def get_tests(self):\n         #                                          \\-> b12 (3) -> b13 (4) -> b14 (5)\n         #                                              (b12 added last)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a chain where the miner creates too much coinbase reward, even if the chain is longer (on a forked chain)\")\n         self.move_tip(5)\n         b12 = self.next_block(12, spend=out[3])\n         self.save_spendable_output()\n@@ -223,15 +230,14 @@ def get_tests(self):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b16 (6)\n         #                      \\-> b3 (1) -> b4 (2)\n-\n-        # Test that a block with a lot of checksigs is okay\n+        self.log.info(\"Accept a block with lots of checksigs\")\n         lots_of_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS - 1))\n         self.move_tip(13)\n         self.next_block(15, spend=out[5], script=lots_of_checksigs)\n         yield self.accepted()\n         self.save_spendable_output()\n \n-        # Test that a block with too many checksigs is rejected\n+        self.log.info(\"Reject a block with too many checksigs\")\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n         self.next_block(16, spend=out[6], script=too_many_checksigs)\n         yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n@@ -240,6 +246,7 @@ def get_tests(self):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b17 (b3.vtx[1])\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block with a spend from a re-org'ed out tx\")\n         self.move_tip(15)\n         self.next_block(17, spend=txout_b3)\n         yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n@@ -249,6 +256,7 @@ def get_tests(self):\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5)\n         #                                                                \\-> b18 (b3.vtx[1]) -> b19 (6)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block with a spend from a re-org'ed out tx (on a forked chain)\")\n         self.move_tip(13)\n         self.next_block(18, spend=txout_b3)\n         yield self.rejected()\n@@ -260,6 +268,7 @@ def get_tests(self):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b20 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         self.next_block(20, spend=out[7])\n         yield self.rejected(RejectResult(16, b'bad-txns-premature-spend-of-coinbase'))\n@@ -269,6 +278,7 @@ def get_tests(self):\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5)\n         #                                                                \\-> b21 (6) -> b22 (5)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block spending an immature coinbase (on a forked chain)\")\n         self.move_tip(13)\n         self.next_block(21, spend=out[6])\n         yield self.rejected()\n@@ -281,6 +291,7 @@ def get_tests(self):\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b23 (6)\n         #                                                                           \\-> b24 (6) -> b25 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Accept a block of size MAX_BLOCK_BASE_SIZE\")\n         self.move_tip(15)\n         b23 = self.next_block(23, spend=out[6])\n         tx = CTransaction()\n@@ -294,7 +305,7 @@ def get_tests(self):\n         yield self.accepted()\n         self.save_spendable_output()\n \n-        # Make the next block one byte bigger and check that it fails\n+        self.log.info(\"Reject a block of size MAX_BLOCK_BASE_SIZE + 1\")\n         self.move_tip(15)\n         b24 = self.next_block(24, spend=out[6])\n         script_length = MAX_BLOCK_BASE_SIZE - len(b24.serialize()) - 69\n@@ -312,6 +323,7 @@ def get_tests(self):\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b23 (6) -> b30 (7)\n         #                                                                           \\-> ... (6) -> ... (7)\n         #                      \\-> b3 (1) -> b4 (2)\n+        self.log.info(\"Reject a block with coinbase input script size out of range\")\n         self.move_tip(15)\n         b26 = self.next_block(26, spend=out[6])\n         b26.vtx[0].vin[0].scriptSig = b'\\x00'\n@@ -355,36 +367,42 @@ def get_tests(self):\n         #\n \n         # MULTISIG: each op code counts as 20 sigops.  To create the edge case, pack another 19 sigops at the end.\n+        self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIG sigops\")\n         lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n         b31 = self.next_block(31, spend=out[8], script=lots_of_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b31), MAX_BLOCK_SIGOPS)\n         yield self.accepted()\n         self.save_spendable_output()\n \n         # this goes over the limit because the coinbase has one sigop\n+        self.log.info(\"Reject a block with too many OP_CHECKMULTISIG sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n         yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # CHECKMULTISIGVERIFY\n+        self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIGVERIFY sigops\")\n         self.move_tip(31)\n         lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n         self.next_block(33, spend=out[9], script=lots_of_multisigs)\n         yield self.accepted()\n         self.save_spendable_output()\n \n+        self.log.info(\"Reject a block with too many OP_CHECKMULTISIGVERIFY sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n         self.next_block(34, spend=out[10], script=too_many_multisigs)\n         yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # CHECKSIGVERIFY\n+        self.log.info(\"Accept a block with the max number of OP_CHECKSIGVERIFY sigops\")\n         self.move_tip(33)\n         lots_of_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS - 1))\n         b35 = self.next_block(35, spend=out[10], script=lots_of_checksigs)\n         yield self.accepted()\n         self.save_spendable_output()\n \n+        self.log.info(\"Reject a block with too many OP_CHECKSIGVERIFY sigops\")\n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n         self.next_block(36, spend=out[11], script=too_many_checksigs)\n         yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n@@ -398,6 +416,7 @@ def get_tests(self):\n         #\n \n         # save 37's spendable output, but then double-spend out11 to invalidate the block\n+        self.log.info(\"Reject a block spending transaction from a block which failed to connect\")\n         self.move_tip(35)\n         b37 = self.next_block(37, spend=out[11])\n         txout_b37 = PreviousSpendableOutput(b37.vtx[1], 0)\n@@ -421,6 +440,7 @@ def get_tests(self):\n         #           redeem_script = COINBASE_PUBKEY, (OP_2DUP+OP_CHECKSIGVERIFY) * 5, OP_CHECKSIG\n         #           p2sh_script = OP_HASH160, ripemd160(sha256(script)), OP_EQUAL\n         #\n+        self.log.info(\"Check P2SH SIGOPS are correctly counted\")\n         self.move_tip(35)\n         b39 = self.next_block(39)\n         b39_outputs = 0\n@@ -467,6 +487,7 @@ def get_tests(self):\n         #\n         # b41 does the same, less one, so it has the maximum sigops permitted.\n         #\n+        self.log.info(\"Reject a block with too many P2SH sigops\")\n         self.move_tip(39)\n         b40 = self.next_block(40, spend=out[12])\n         sigops = get_legacy_sigopcount_block(b40)\n@@ -501,6 +522,7 @@ def get_tests(self):\n         yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n \n         # same as b40, but one less sigop\n+        self.log.info(\"Accept a block with the max number of P2SH sigops\")\n         self.move_tip(39)\n         self.next_block(41, spend=None)\n         self.update_block(41, b40.vtx[1:-1])\n@@ -533,6 +555,7 @@ def get_tests(self):\n \n         # The next few blocks are going to be created \"by hand\" since they'll do funky things, such as having\n         # the first transaction be non-coinbase, etc.  The purpose of b44 is to make sure this works.\n+        self.log.info(\"Build block 44 manually\")\n         height = self.block_heights[self.tip.sha256] + 1\n         coinbase = create_coinbase(height, self.coinbase_pubkey)\n         b44 = CBlock()\n@@ -547,7 +570,7 @@ def get_tests(self):\n         self.blocks[44] = b44\n         yield self.accepted()\n \n-        # A block with a non-coinbase as the first tx\n+        self.log.info(\"Reject a block with a non-coinbase as the first tx\")\n         non_coinbase = self.create_tx(out[15].tx, out[15].n, 1)\n         b45 = CBlock()\n         b45.nTime = self.tip.nTime + 1\n@@ -562,7 +585,7 @@ def get_tests(self):\n         self.blocks[45] = b45\n         yield self.rejected(RejectResult(16, b'bad-cb-missing'))\n \n-        # A block with no txns\n+        self.log.info(\"Reject a block with no transactions\")\n         self.move_tip(44)\n         b46 = CBlock()\n         b46.nTime = b44.nTime + 1\n@@ -577,7 +600,7 @@ def get_tests(self):\n         self.blocks[46] = b46\n         yield self.rejected(RejectResult(16, b'bad-blk-length'))\n \n-        # A block with invalid work\n+        self.log.info(\"Reject a block with invalid work\")\n         self.move_tip(44)\n         b47 = self.next_block(47, solve=False)\n         target = uint256_from_compact(b47.nBits)\n@@ -586,35 +609,35 @@ def get_tests(self):\n             b47.rehash()\n         yield self.rejected(RejectResult(16, b'high-hash'))\n \n-        # A block with timestamp > 2 hrs in the future\n+        self.log.info(\"Reject a block with a timestamp >2 hours in the future\")\n         self.move_tip(44)\n         b48 = self.next_block(48, solve=False)\n         b48.nTime = int(time.time()) + 60 * 60 * 3\n         b48.solve()\n         yield self.rejected(RejectResult(16, b'time-too-new'))\n \n-        # A block with an invalid merkle hash\n+        self.log.info(\"Reject a block with invalid merkle hash\")\n         self.move_tip(44)\n         b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n         yield self.rejected(RejectResult(16, b'bad-txnmrklroot'))\n \n-        # A block with an incorrect POW limit\n+        self.log.info(\"Reject a block with incorrect POW limit\")\n         self.move_tip(44)\n         b50 = self.next_block(50)\n         b50.nBits = b50.nBits - 1\n         b50.solve()\n         yield self.rejected(RejectResult(16, b'bad-diffbits'))\n \n-        # A block with two coinbase txns\n+        self.log.info(\"Reject a block with two coinbase transactions\")\n         self.move_tip(44)\n         self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n         self.update_block(51, [cb2])\n         yield self.rejected(RejectResult(16, b'bad-cb-multiple'))\n \n-        # A block w/ duplicate txns\n+        self.log.info(\"Reject a block with duplicate transactions\")\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n         self.move_tip(44)\n         b52 = self.next_block(52, spend=out[15])\n@@ -631,7 +654,7 @@ def get_tests(self):\n         yield self.rejected()  # rejected since b44 is at same height\n         self.save_spendable_output()\n \n-        # invalid timestamp (b35 is 5 blocks back, so its time is MedianTimePast)\n+        self.log.info(\"Reject a block with timestamp before MedianTimePast\")\n         b54 = self.next_block(54, spend=out[15])\n         b54.nTime = b35.nTime - 1\n         b54.solve()\n@@ -680,6 +703,7 @@ def get_tests(self):\n         b57 = self.update_block(57, [tx, tx1])\n \n         # b56 - copy b57, add a duplicate tx\n+        self.log.info(\"Reject a block with a duplicate transaction in the Merkle Tree (but with a valid Merkle Root)\")\n         self.move_tip(55)\n         b56 = copy.deepcopy(b57)\n         self.blocks[56] = b56\n@@ -699,6 +723,7 @@ def get_tests(self):\n         b57p2 = self.update_block(\"57p2\", [tx, tx1, tx2, tx3, tx4])\n \n         # b56p2 - copy b57p2, duplicate two non-consecutive tx's\n+        self.log.info(\"Reject a block with two duplicate transactions in the Merkle Tree (but with a valid Merkle Root)\")\n         self.move_tip(55)\n         b56p2 = copy.deepcopy(b57p2)\n         self.blocks[\"b56p2\"] = b56p2\n@@ -721,6 +746,7 @@ def get_tests(self):\n         #\n \n         # tx with prevout.n out of range\n+        self.log.info(\"Reject a block with a transaction with prevout.n out of range\")\n         self.move_tip(57)\n         self.next_block(58, spend=out[17])\n         tx = CTransaction()\n@@ -732,6 +758,7 @@ def get_tests(self):\n         yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n         # tx with output value > input value out of range\n+        self.log.info(\"Reject a block with a transaction with outputs > inputs\")\n         self.move_tip(57)\n         self.next_block(59)\n         tx = self.create_and_sign_transaction(out[17].tx, out[17].n, 51 * COIN)\n@@ -753,6 +780,7 @@ def get_tests(self):\n         # not-fully-spent transaction in the same chain. To test, make identical coinbases;\n         # the second one should be rejected.\n         #\n+        self.log.info(\"Reject a block with a transaction with a duplicate hash of a previous transaction (BIP30)\")\n         self.move_tip(60)\n         b61 = self.next_block(61, spend=out[18])\n         b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  # equalize the coinbases\n@@ -766,6 +794,7 @@ def get_tests(self):\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n         #                                                                                     \\-> b62 (18)\n         #\n+        self.log.info(\"Reject a block with a transaction with a nonfinal locktime\")\n         self.move_tip(60)\n         self.next_block(62)\n         tx = CTransaction()\n@@ -783,6 +812,7 @@ def get_tests(self):\n         #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n         #                                                                                     \\-> b63 (-)\n         #\n+        self.log.info(\"Reject a block with a coinbase transaction with a nonfinal locktime\")\n         self.move_tip(60)\n         b63 = self.next_block(63)\n         b63.vtx[0].nLockTime = 0xffffffff\n@@ -805,6 +835,7 @@ def get_tests(self):\n         #  b64a is a bloated block (non-canonical varint)\n         #  b64 is a good block (same as b64 but w/ canonical varint)\n         #\n+        self.log.info(\"Accept a valid block even if a bloated version of the block has previously been sent\")\n         self.move_tip(60)\n         regular_block = self.next_block(\"64a\", spend=out[18])\n \n@@ -841,6 +872,7 @@ def get_tests(self):\n         #\n         # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n         #\n+        self.log.info(\"Accept a block with a transaction spending an output created in the same block\")\n         self.move_tip(64)\n         self.next_block(65)\n         tx1 = self.create_and_sign_transaction(out[19].tx, out[19].n, out[19].tx.vout[0].nValue)\n@@ -853,6 +885,7 @@ def get_tests(self):\n         #\n         # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n         #                                                                                    \\-> b66 (20)\n+        self.log.info(\"Reject a block with a transaction spending an output created later in the same block\")\n         self.move_tip(65)\n         self.next_block(66)\n         tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n@@ -866,6 +899,7 @@ def get_tests(self):\n         #                                                                                    \\-> b67 (20)\n         #\n         #\n+        self.log.info(\"Reject a block with a transaction double spending a transaction creted in the same block\")\n         self.move_tip(65)\n         self.next_block(67)\n         tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n@@ -886,12 +920,14 @@ def get_tests(self):\n         # b69 - coinbase with extra 10 satoshis, and a tx that gives a 10 satoshi fee\n         #       this succeeds\n         #\n+        self.log.info(\"Reject a block trying to claim too much subsidy in the coinbase transaction\")\n         self.move_tip(65)\n         self.next_block(68, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 9)\n         self.update_block(68, [tx])\n         yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n \n+        self.log.info(\"Accept a block claiming the correct subsidy in the coinbase transaction\")\n         self.move_tip(65)\n         b69 = self.next_block(69, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 10)\n@@ -904,6 +940,7 @@ def get_tests(self):\n         # -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20)\n         #                                                                                    \\-> b70 (21)\n         #\n+        self.log.info(\"Reject a block containing a transaction spending from a non-existent input\")\n         self.move_tip(69)\n         self.next_block(70, spend=out[21])\n         bogus_tx = CTransaction()\n@@ -921,7 +958,7 @@ def get_tests(self):\n         #\n         # b72 is a good block.\n         # b71 is a copy of 72, but re-adds one of its transactions.  However, it has the same hash as b71.\n-        #\n+        self.log.info(\"Reject a block containing a duplicate transaction but with the same Merkle root (Merkle tree malleability\")\n         self.move_tip(69)\n         b72 = self.next_block(72)\n         tx1 = self.create_and_sign_transaction(out[21].tx, out[21].n, 2)\n@@ -958,7 +995,7 @@ def get_tests(self):\n         #       bytearray[20,000-20,003]: 521  (max_script_element_size+1, in little-endian format)\n         #       bytearray[20,004-20,525]: unread data (script_element)\n         #       bytearray[20,526]       : OP_CHECKSIG (this puts us over the limit)\n-        #\n+        self.log.info(\"Reject a block containing too many sigops after a large script element\")\n         self.move_tip(72)\n         b73 = self.next_block(73)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1\n@@ -986,8 +1023,7 @@ def get_tests(self):\n         #\n         #       b74 fails because we put MAX_BLOCK_SIGOPS+1 before the element\n         #       b75 succeeds because we put MAX_BLOCK_SIGOPS before the element\n-        #\n-        #\n+        self.log.info(\"Check sigops are counted correctly after an invalid script element\")\n         self.move_tip(72)\n         self.next_block(74)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42  # total = 20,561\n@@ -1043,7 +1079,7 @@ def get_tests(self):\n         #    To get around this issue, we construct transactions which are not signed and which\n         #    spend to OP_TRUE.  If the standard-ness rules change, this test would need to be\n         #    updated.  (Perhaps to spend to a P2SH OP_TRUE script)\n-        #\n+        self.log.info(\"Test transaction resurrection during a re-org\")\n         self.move_tip(76)\n         self.next_block(77)\n         tx77 = self.create_and_sign_transaction(out[24].tx, out[24].n, 10 * COIN)\n@@ -1087,6 +1123,7 @@ def get_tests(self):\n         #\n         #  -> b81 (26) -> b82 (27) -> b83 (28)\n         #\n+        self.log.info(\"Accept a block with invalid opcodes in dead execution paths\")\n         self.next_block(83)\n         op_codes = [OP_IF, OP_INVALIDOPCODE, OP_ELSE, OP_TRUE, OP_ENDIF]\n         script = CScript(op_codes)\n@@ -1105,7 +1142,7 @@ def get_tests(self):\n         #  -> b81 (26) -> b82 (27) -> b83 (28) -> b84 (29) -> b87 (30) -> b88 (31)\n         #                                    \\-> b85 (29) -> b86 (30)            \\-> b89a (32)\n         #\n-        #\n+        self.log.info(\"Test re-orging blocks with OP_RETURN in them\")\n         self.next_block(84)\n         tx1 = self.create_tx(out[29].tx, out[29].n, 0, CScript([OP_RETURN]))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n@@ -1149,6 +1186,8 @@ def get_tests(self):\n         self.update_block(\"89a\", [tx])\n         yield self.rejected()\n \n+        self.log.info(\"Test a re-org of one week's worth of blocks (1088 blocks)\")\n+\n         self.move_tip(88)\n         LARGE_REORG_SIZE = 1088\n         test1 = TestInstance(sync_every_block=False)"
      }
    ]
  },
  {
    "sha": "ebf053ac6135941907ecfebccc778da34b585fac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYmYwNTNhYzYxMzU5NDE5MDdlY2ZlYmNjYzc3OGRhMzRiNTg1ZmFj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-04-08T19:59:04Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-19T18:26:09Z"
      },
      "message": "[tests] Change feature_block.py to use BitcoinTestFramework",
      "tree": {
        "sha": "128d5198d14c4e61fd77e725b511374d2e702bbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/128d5198d14c4e61fd77e725b511374d2e702bbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ebf053ac6135941907ecfebccc778da34b585fac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebf053ac6135941907ecfebccc778da34b585fac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ebf053ac6135941907ecfebccc778da34b585fac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebf053ac6135941907ecfebccc778da34b585fac/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc02c12ae915ac040f64860048912d1624b921fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc02c12ae915ac040f64860048912d1624b921fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc02c12ae915ac040f64860048912d1624b921fb"
      }
    ],
    "stats": {
      "total": 477,
      "additions": 234,
      "deletions": 243
    },
    "files": [
      {
        "sha": "181c7f336941634b660c2d7a7b530bdfd946d818",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 234,
        "deletions": 243,
        "changes": 477,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebf053ac6135941907ecfebccc778da34b585fac/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebf053ac6135941907ecfebccc778da34b585fac/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=ebf053ac6135941907ecfebccc778da34b585fac",
        "patch": "@@ -8,11 +8,9 @@\n import time\n \n from test_framework.blocktools import create_block, create_coinbase, create_transaction, get_legacy_sigopcount_block\n-from test_framework.comptool import RejectResult, TestInstance, TestManager\n from test_framework.key import CECKey\n from test_framework.messages import (\n     CBlock,\n-    CBlockHeader,\n     COIN,\n     COutPoint,\n     CTransaction,\n@@ -22,7 +20,7 @@\n     uint256_from_compact,\n     uint256_from_str,\n )\n-from test_framework.mininode import network_thread_start\n+from test_framework.mininode import P2PDataStore, network_thread_start, network_thread_join\n from test_framework.script import (\n     CScript,\n     MAX_SCRIPT_ELEMENT_SIZE,\n@@ -44,14 +42,8 @@\n     SignatureHash,\n     hash160,\n )\n-from test_framework.test_framework import ComparisonTestFramework\n-from test_framework.util import *\n-from test_framework.comptool import TestManager, TestInstance, RejectResult\n-from test_framework.blocktools import *\n-import time\n-from test_framework.key import CECKey\n-from test_framework.script import *\n-import struct\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n \n MAX_BLOCK_SIGOPS = 20000\n \n@@ -63,9 +55,6 @@ def __init__(self, tx=CTransaction(), n=-1):\n #  Use this class for tests that require behavior other than normal \"mininode\" behavior.\n #  For now, it is used to serialize a bloated varint (b64).\n class CBrokenBlock(CBlock):\n-    def __init__(self, header=None):\n-        super(CBrokenBlock, self).__init__(header)\n-\n     def initialize(self, base_block):\n         self.vtx = copy.deepcopy(base_block.vtx)\n         self.hashMerkleRoot = self.calc_merkle_root()\n@@ -82,46 +71,43 @@ def serialize(self, with_witness=False):\n         return r\n \n     def normal_serialize(self):\n-        r = b\"\"\n-        r += super(CBrokenBlock, self).serialize()\n-        return r\n+        return super().serialize()\n \n-class FullBlockTest(ComparisonTestFramework):\n-    # Can either run this test as 1 node with expected answers, or two and compare them.\n-    # Change the \"outcome\" variable from each TestInstance object to only do the comparison.\n+class FullBlockTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n+        self.extra_args = [[]]\n+\n+    def run_test(self):\n+        node = self.nodes[0]  # convenience reference to the node\n+\n+        # reconnect_p2p() expects the network thread to be running\n+        network_thread_start()\n+\n+        self.reconnect_p2p()\n+\n         self.block_heights = {}\n         self.coinbase_key = CECKey()\n         self.coinbase_key.set_secretbytes(b\"horsebattery\")\n         self.coinbase_pubkey = self.coinbase_key.get_pubkey()\n         self.tip = None\n         self.blocks = {}\n-\n-    def run_test(self):\n-        self.test = TestManager(self, self.options.tmpdir)\n-        self.test.add_all_connections(self.nodes)\n-        network_thread_start()\n-        self.test.run()\n-\n-    def get_tests(self):\n         self.genesis_hash = int(self.nodes[0].getbestblockhash(), 16)\n         self.block_heights[self.genesis_hash] = 0\n         self.spendable_outputs = []\n \n         # Create a new block\n-        self.next_block(0)\n+        b0 = self.next_block(0)\n         self.save_spendable_output()\n-        yield self.accepted()\n+        self.sync_blocks([b0])\n \n-        #  Now we need that block to mature so we can spend the coinbase.\n-        test = TestInstance(sync_every_block=False)\n+        # Allow the block to mature\n+        blocks = []\n         for i in range(99):\n-            self.next_block(5000 + i)\n-            test.blocks_and_transactions.append([self.tip, True])\n+            blocks.append(self.next_block(5000 + i))\n             self.save_spendable_output()\n-        yield test\n+        self.sync_blocks(blocks)\n \n         # collect spendable outputs now to avoid cluttering the code later on\n         out = []\n@@ -131,15 +117,15 @@ def get_tests(self):\n         # Start by building a couple of blocks on top (which output is spent is\n         # in parentheses):\n         #     genesis -> b1 (0) -> b2 (1)\n-        self.next_block(1, spend=out[0])\n+        b1 = self.next_block(1, spend=out[0])\n         self.save_spendable_output()\n-        yield self.accepted()\n \n-        self.next_block(2, spend=out[1])\n-        yield self.accepted()\n+        b2 = self.next_block(2, spend=out[1])\n         self.save_spendable_output()\n \n-        # so fork like this:\n+        self.sync_blocks([b1, b2])\n+\n+        # Fork like this:\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1)\n@@ -149,82 +135,76 @@ def get_tests(self):\n         self.move_tip(1)\n         b3 = self.next_block(3, spend=out[1])\n         txout_b3 = PreviousSpendableOutput(b3.vtx[1], 0)\n-        yield self.rejected()\n+        self.sync_blocks([b3], False)\n \n         # Now we add another block to make the alternative chain longer.\n         #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reorg to a longer chain\")\n-        self.next_block(4, spend=out[2])\n-        yield self.accepted()\n+        b4 = self.next_block(4, spend=out[2])\n+        self.sync_blocks([b4])\n \n         # ... and back to the first chain.\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.move_tip(2)\n-        self.next_block(5, spend=out[2])\n+        b5 = self.next_block(5, spend=out[2])\n         self.save_spendable_output()\n-        yield self.rejected()\n+        self.sync_blocks([b5], False)\n \n         self.log.info(\"Reorg back to the original chain\")\n-        self.next_block(6, spend=out[3])\n-        yield self.accepted()\n+        b6 = self.next_block(6, spend=out[3])\n+        self.sync_blocks([b6], True)\n \n         # Try to create a fork that double-spends\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                          \\-> b7 (2) -> b8 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a chain with a double spend, even if it is longer\")\n         self.move_tip(5)\n-        self.next_block(7, spend=out[2])\n-        yield self.rejected()\n+        b7 = self.next_block(7, spend=out[2])\n+        self.sync_blocks([b7], False)\n \n-        self.next_block(8, spend=out[4])\n-        yield self.rejected()\n+        b8 = self.next_block(8, spend=out[4])\n+        self.sync_blocks([b8], False, reconnect=True)\n \n         # Try to create a block that has too much fee\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                                    \\-> b9 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a block where the miner creates too much coinbase reward\")\n         self.move_tip(6)\n-        self.next_block(9, spend=out[4], additional_coinbase_value=1)\n-        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n+        b9 = self.next_block(9, spend=out[4], additional_coinbase_value=1)\n+        self.sync_blocks([b9], False, 16, b'bad-cb-amount', reconnect=True)\n \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b10 (3) -> b11 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a chain where the miner creates too much coinbase reward, even if the chain is longer\")\n         self.move_tip(5)\n-        self.next_block(10, spend=out[3])\n-        yield self.rejected()\n+        b10 = self.next_block(10, spend=out[3])\n+        self.sync_blocks([b10], False)\n \n-        self.next_block(11, spend=out[4], additional_coinbase_value=1)\n-        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n+        b11 = self.next_block(11, spend=out[4], additional_coinbase_value=1)\n+        self.sync_blocks([b11], False, 16, b'bad-cb-amount', reconnect=True)\n \n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b14 (5)\n-        #                                              (b12 added last)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a chain where the miner creates too much coinbase reward, even if the chain is longer (on a forked chain)\")\n         self.move_tip(5)\n         b12 = self.next_block(12, spend=out[3])\n         self.save_spendable_output()\n         b13 = self.next_block(13, spend=out[4])\n-        # Deliver the block header for b12, and the block b13.\n-        # b13 should be accepted but the tip won't advance until b12 is delivered.\n-        yield TestInstance([[CBlockHeader(b12), None], [b13, False]])\n-\n         self.save_spendable_output()\n-        # b14 is invalid, but the node won't know that until it tries to connect\n-        # Tip still can't advance because b12 is missing\n-        self.next_block(14, spend=out[5], additional_coinbase_value=1)\n-        yield self.rejected()\n+        b14 = self.next_block(14, spend=out[5], additional_coinbase_value=1)\n+        self.sync_blocks([b12, b13, b14], False, 16, b'bad-cb-amount', reconnect=True)\n \n-        yield TestInstance([[b12, True, b13.sha256]])  # New tip should be b13.\n+        # New tip should be b13.\n+        assert_equal(node.getbestblockhash(), b13.hash)\n \n         # Add a block with MAX_BLOCK_SIGOPS and one with one more sigop\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -233,23 +213,23 @@ def get_tests(self):\n         self.log.info(\"Accept a block with lots of checksigs\")\n         lots_of_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS - 1))\n         self.move_tip(13)\n-        self.next_block(15, spend=out[5], script=lots_of_checksigs)\n-        yield self.accepted()\n+        b15 = self.next_block(15, spend=out[5], script=lots_of_checksigs)\n         self.save_spendable_output()\n+        self.sync_blocks([b15], True)\n \n         self.log.info(\"Reject a block with too many checksigs\")\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n-        self.next_block(16, spend=out[6], script=too_many_checksigs)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        b16 = self.next_block(16, spend=out[6], script=too_many_checksigs)\n+        self.sync_blocks([b16], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b17 (b3.vtx[1])\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a block with a spend from a re-org'ed out tx\")\n         self.move_tip(15)\n-        self.next_block(17, spend=txout_b3)\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b17 = self.next_block(17, spend=txout_b3)\n+        self.sync_blocks([b17], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -258,20 +238,20 @@ def get_tests(self):\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a block with a spend from a re-org'ed out tx (on a forked chain)\")\n         self.move_tip(13)\n-        self.next_block(18, spend=txout_b3)\n-        yield self.rejected()\n+        b18 = self.next_block(18, spend=txout_b3)\n+        self.sync_blocks([b18], False)\n \n-        self.next_block(19, spend=out[6])\n-        yield self.rejected()\n+        b19 = self.next_block(19, spend=out[6])\n+        self.sync_blocks([b19], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b20 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n-        self.next_block(20, spend=out[7])\n-        yield self.rejected(RejectResult(16, b'bad-txns-premature-spend-of-coinbase'))\n+        b20 = self.next_block(20, spend=out[7])\n+        self.sync_blocks([b20], False, 16, b'bad-txns-premature-spend-of-coinbase')\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -280,11 +260,11 @@ def get_tests(self):\n         #                      \\-> b3 (1) -> b4 (2)\n         self.log.info(\"Reject a block spending an immature coinbase (on a forked chain)\")\n         self.move_tip(13)\n-        self.next_block(21, spend=out[6])\n-        yield self.rejected()\n+        b21 = self.next_block(21, spend=out[6])\n+        self.sync_blocks([b21], False)\n \n-        self.next_block(22, spend=out[5])\n-        yield self.rejected()\n+        b22 = self.next_block(22, spend=out[5])\n+        self.sync_blocks([b22], False, 16, b'bad-txns-premature-spend-of-coinbase')\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -302,7 +282,7 @@ def get_tests(self):\n         b23 = self.update_block(23, [tx])\n         # Make sure the math above worked out to produce a max-sized block\n         assert_equal(len(b23.serialize()), MAX_BLOCK_BASE_SIZE)\n-        yield self.accepted()\n+        self.sync_blocks([b23], True)\n         self.save_spendable_output()\n \n         self.log.info(\"Reject a block of size MAX_BLOCK_BASE_SIZE + 1\")\n@@ -313,10 +293,10 @@ def get_tests(self):\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = self.update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n-        yield self.rejected(RejectResult(16, b'bad-blk-length'))\n+        self.sync_blocks([b24], False, 16, b'bad-blk-length', reconnect=True)\n \n-        self.next_block(25, spend=out[7])\n-        yield self.rejected()\n+        b25 = self.next_block(25, spend=out[7])\n+        self.sync_blocks([b25], False)\n \n         # Create blocks with a coinbase input script size out of range\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -331,31 +311,31 @@ def get_tests(self):\n         # update_block causes the merkle root to get updated, even with no new\n         # transactions, and updates the required state.\n         b26 = self.update_block(26, [])\n-        yield self.rejected(RejectResult(16, b'bad-cb-length'))\n+        self.sync_blocks([b26], False, 16, b'bad-cb-length', reconnect=True)\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n-        self.next_block(27, spend=out[7])\n-        yield self.rejected(False)\n+        b27 = self.next_block(27, spend=out[7])\n+        self.sync_blocks([b27], False)\n \n         # Now try a too-large-coinbase script\n         self.move_tip(15)\n         b28 = self.next_block(28, spend=out[6])\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n         b28 = self.update_block(28, [])\n-        yield self.rejected(RejectResult(16, b'bad-cb-length'))\n+        self.sync_blocks([b28], False, 16, b'bad-cb-length', reconnect=True)\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n-        self.next_block(29, spend=out[7])\n-        yield self.rejected(False)\n+        b29 = self.next_block(29, spend=out[7])\n+        self.sync_blocks([b29], False)\n \n         # b30 has a max-sized coinbase scriptSig.\n         self.move_tip(23)\n         b30 = self.next_block(30)\n         b30.vtx[0].vin[0].scriptSig = b'\\x00' * 100\n         b30.vtx[0].rehash()\n         b30 = self.update_block(30, [])\n-        yield self.accepted()\n+        self.sync_blocks([b30], True)\n         self.save_spendable_output()\n \n         # b31 - b35 - check sigops of OP_CHECKMULTISIG / OP_CHECKMULTISIGVERIFY / OP_CHECKSIGVERIFY\n@@ -371,41 +351,41 @@ def get_tests(self):\n         lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n         b31 = self.next_block(31, spend=out[8], script=lots_of_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b31), MAX_BLOCK_SIGOPS)\n-        yield self.accepted()\n+        self.sync_blocks([b31], True)\n         self.save_spendable_output()\n \n         # this goes over the limit because the coinbase has one sigop\n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIG sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.sync_blocks([b32], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # CHECKMULTISIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIGVERIFY sigops\")\n         self.move_tip(31)\n         lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS - 1) // 20) + [OP_CHECKSIG] * 19)\n-        self.next_block(33, spend=out[9], script=lots_of_multisigs)\n-        yield self.accepted()\n+        b33 = self.next_block(33, spend=out[9], script=lots_of_multisigs)\n+        self.sync_blocks([b33], True)\n         self.save_spendable_output()\n \n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIGVERIFY sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n-        self.next_block(34, spend=out[10], script=too_many_multisigs)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        b34 = self.next_block(34, spend=out[10], script=too_many_multisigs)\n+        self.sync_blocks([b34], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # CHECKSIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKSIGVERIFY sigops\")\n         self.move_tip(33)\n         lots_of_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS - 1))\n         b35 = self.next_block(35, spend=out[10], script=lots_of_checksigs)\n-        yield self.accepted()\n+        self.sync_blocks([b35], True)\n         self.save_spendable_output()\n \n         self.log.info(\"Reject a block with too many OP_CHECKSIGVERIFY sigops\")\n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n-        self.next_block(36, spend=out[11], script=too_many_checksigs)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        b36 = self.next_block(36, spend=out[11], script=too_many_checksigs)\n+        self.sync_blocks([b36], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # Check spending of a transaction in a block which failed to connect\n         #\n@@ -422,12 +402,12 @@ def get_tests(self):\n         txout_b37 = PreviousSpendableOutput(b37.vtx[1], 0)\n         tx = self.create_and_sign_transaction(out[11].tx, out[11].n, 0)\n         b37 = self.update_block(37, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        self.sync_blocks([b37], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n-        self.next_block(38, spend=txout_b37)\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b38 = self.next_block(38, spend=txout_b37)\n+        self.sync_blocks([b38], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Check P2SH SigOp counting\n         #\n@@ -477,7 +457,7 @@ def get_tests(self):\n             b39_outputs += 1\n \n         b39 = self.update_block(39, [])\n-        yield self.accepted()\n+        self.sync_blocks([b39], True)\n         self.save_spendable_output()\n \n         # Test sigops in P2SH redeem scripts\n@@ -519,34 +499,33 @@ def get_tests(self):\n         tx.rehash()\n         new_txs.append(tx)\n         self.update_block(40, new_txs)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.sync_blocks([b40], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # same as b40, but one less sigop\n         self.log.info(\"Accept a block with the max number of P2SH sigops\")\n         self.move_tip(39)\n-        self.next_block(41, spend=None)\n+        b41 = self.next_block(41, spend=None)\n         self.update_block(41, b40.vtx[1:-1])\n         b41_sigops_to_fill = b40_sigops_to_fill - 1\n         tx = CTransaction()\n         tx.vin.append(CTxIn(lastOutpoint, b''))\n         tx.vout.append(CTxOut(1, CScript([OP_CHECKSIG] * b41_sigops_to_fill)))\n         tx.rehash()\n         self.update_block(41, [tx])\n-        yield self.accepted()\n+        self.sync_blocks([b41], True)\n \n         # Fork off of b39 to create a constant base again\n         #\n         # b23 (6) -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13)\n         #                                                                  \\-> b41 (12)\n         #\n         self.move_tip(39)\n-        self.next_block(42, spend=out[12])\n-        yield self.rejected()\n+        b42 = self.next_block(42, spend=out[12])\n         self.save_spendable_output()\n \n-        self.next_block(43, spend=out[13])\n-        yield self.accepted()\n+        b43 = self.next_block(43, spend=out[13])\n         self.save_spendable_output()\n+        self.sync_blocks([b42, b43], True)\n \n         # Test a number of really invalid scenarios\n         #\n@@ -568,7 +547,7 @@ def get_tests(self):\n         self.tip = b44\n         self.block_heights[b44.sha256] = height\n         self.blocks[44] = b44\n-        yield self.accepted()\n+        self.sync_blocks([b44], True)\n \n         self.log.info(\"Reject a block with a non-coinbase as the first tx\")\n         non_coinbase = self.create_tx(out[15].tx, out[15].n, 1)\n@@ -583,7 +562,7 @@ def get_tests(self):\n         self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n-        yield self.rejected(RejectResult(16, b'bad-cb-missing'))\n+        self.sync_blocks([b45], False, 16, b'bad-cb-missing', reconnect=True)\n \n         self.log.info(\"Reject a block with no transactions\")\n         self.move_tip(44)\n@@ -598,77 +577,77 @@ def get_tests(self):\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        yield self.rejected(RejectResult(16, b'bad-blk-length'))\n+        self.sync_blocks([b46], False, 16, b'bad-blk-length', reconnect=True)\n \n         self.log.info(\"Reject a block with invalid work\")\n         self.move_tip(44)\n         b47 = self.next_block(47, solve=False)\n         target = uint256_from_compact(b47.nBits)\n-        while b47.sha256 < target:  # changed > to <\n+        while b47.sha256 < target:\n             b47.nNonce += 1\n             b47.rehash()\n-        yield self.rejected(RejectResult(16, b'high-hash'))\n+        self.sync_blocks([b47], False, request_block=False)\n \n         self.log.info(\"Reject a block with a timestamp >2 hours in the future\")\n         self.move_tip(44)\n         b48 = self.next_block(48, solve=False)\n         b48.nTime = int(time.time()) + 60 * 60 * 3\n         b48.solve()\n-        yield self.rejected(RejectResult(16, b'time-too-new'))\n+        self.sync_blocks([b48], False, request_block=False)\n \n         self.log.info(\"Reject a block with invalid merkle hash\")\n         self.move_tip(44)\n         b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n-        yield self.rejected(RejectResult(16, b'bad-txnmrklroot'))\n+        self.sync_blocks([b49], False, 16, b'bad-txnmrklroot', reconnect=True)\n \n         self.log.info(\"Reject a block with incorrect POW limit\")\n         self.move_tip(44)\n         b50 = self.next_block(50)\n         b50.nBits = b50.nBits - 1\n         b50.solve()\n-        yield self.rejected(RejectResult(16, b'bad-diffbits'))\n+        self.sync_blocks([b50], False, request_block=False, reconnect=True)\n \n         self.log.info(\"Reject a block with two coinbase transactions\")\n         self.move_tip(44)\n-        self.next_block(51)\n+        b51 = self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n-        self.update_block(51, [cb2])\n-        yield self.rejected(RejectResult(16, b'bad-cb-multiple'))\n+        b51 = self.update_block(51, [cb2])\n+        self.sync_blocks([b51], False, 16, b'bad-cb-multiple', reconnect=True)\n \n         self.log.info(\"Reject a block with duplicate transactions\")\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n         self.move_tip(44)\n         b52 = self.next_block(52, spend=out[15])\n         tx = self.create_tx(b52.vtx[1], 0, 1)\n         b52 = self.update_block(52, [tx, tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.sync_blocks([b52], False, 16, b'bad-txns-duplicate', reconnect=True)\n \n         # Test block timestamps\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n         #                                                                                   \\-> b54 (15)\n         #\n         self.move_tip(43)\n-        self.next_block(53, spend=out[14])\n-        yield self.rejected()  # rejected since b44 is at same height\n+        b53 = self.next_block(53, spend=out[14])\n+        self.sync_blocks([b53], False)\n         self.save_spendable_output()\n \n         self.log.info(\"Reject a block with timestamp before MedianTimePast\")\n         b54 = self.next_block(54, spend=out[15])\n         b54.nTime = b35.nTime - 1\n         b54.solve()\n-        yield self.rejected(RejectResult(16, b'time-too-old'))\n+        self.sync_blocks([b54], False, request_block=False)\n \n         # valid timestamp\n         self.move_tip(53)\n         b55 = self.next_block(55, spend=out[15])\n         b55.nTime = b35.nTime\n         self.update_block(55, [])\n-        yield self.accepted()\n+        self.sync_blocks([b55], True)\n         self.save_spendable_output()\n \n-        # Test CVE-2012-2459\n+        # Test Merkle tree malleability\n         #\n         # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57p2 (16)\n         #                                                \\-> b57   (16)\n@@ -710,7 +689,7 @@ def get_tests(self):\n         assert_equal(len(b56.vtx), 3)\n         b56 = self.update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n-        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.sync_blocks([b56], False, 16, b'bad-txns-duplicate', reconnect=True)\n \n         # b57p2 - a good block with 6 tx'es, don't submit until end\n         self.move_tip(55)\n@@ -730,13 +709,13 @@ def get_tests(self):\n         assert_equal(b56p2.hash, b57p2.hash)\n         assert_equal(len(b56p2.vtx), 6)\n         b56p2 = self.update_block(\"b56p2\", [tx3, tx4])\n-        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.sync_blocks([b56p2], False, 16, b'bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(\"57p2\")\n-        yield self.accepted()\n+        self.sync_blocks([b57p2], True)\n \n         self.move_tip(57)\n-        yield self.rejected()  # rejected because 57p2 seen first\n+        self.sync_blocks([b57], False)  # The tip is not updated because 57p2 seen first\n         self.save_spendable_output()\n \n         # Test a few invalid tx types\n@@ -748,27 +727,27 @@ def get_tests(self):\n         # tx with prevout.n out of range\n         self.log.info(\"Reject a block with a transaction with prevout.n out of range\")\n         self.move_tip(57)\n-        self.next_block(58, spend=out[17])\n+        b58 = self.next_block(58, spend=out[17])\n         tx = CTransaction()\n         assert(len(out[17].tx.vout) < 42)\n         tx.vin.append(CTxIn(COutPoint(out[17].tx.sha256, 42), CScript([OP_TRUE]), 0xffffffff))\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n-        self.update_block(58, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b58 = self.update_block(58, [tx])\n+        self.sync_blocks([b58], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n-        # tx with output value > input value out of range\n+        # tx with output value > input value\n         self.log.info(\"Reject a block with a transaction with outputs > inputs\")\n         self.move_tip(57)\n-        self.next_block(59)\n+        b59 = self.next_block(59)\n         tx = self.create_and_sign_transaction(out[17].tx, out[17].n, 51 * COIN)\n-        self.update_block(59, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-in-belowout'))\n+        b59 = self.update_block(59, [tx])\n+        self.sync_blocks([b59], False, 16, b'bad-txns-in-belowout', reconnect=True)\n \n         # reset to good chain\n         self.move_tip(57)\n         b60 = self.next_block(60, spend=out[17])\n-        yield self.accepted()\n+        self.sync_blocks([b60], True)\n         self.save_spendable_output()\n \n         # Test BIP30\n@@ -783,11 +762,11 @@ def get_tests(self):\n         self.log.info(\"Reject a block with a transaction with a duplicate hash of a previous transaction (BIP30)\")\n         self.move_tip(60)\n         b61 = self.next_block(61, spend=out[18])\n-        b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  # equalize the coinbases\n+        b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  # Equalize the coinbases\n         b61.vtx[0].rehash()\n         b61 = self.update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n-        yield self.rejected(RejectResult(16, b'bad-txns-BIP30'))\n+        self.sync_blocks([b61], False, 16, b'bad-txns-BIP30', reconnect=True)\n \n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n@@ -796,16 +775,16 @@ def get_tests(self):\n         #\n         self.log.info(\"Reject a block with a transaction with a nonfinal locktime\")\n         self.move_tip(60)\n-        self.next_block(62)\n+        b62 = self.next_block(62)\n         tx = CTransaction()\n         tx.nLockTime = 0xffffffff  # this locktime is non-final\n         assert(out[18].n < len(out[18].tx.vout))\n         tx.vin.append(CTxIn(COutPoint(out[18].tx.sha256, out[18].n)))  # don't set nSequence\n         tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n-        self.update_block(62, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+        b62 = self.update_block(62, [tx])\n+        self.sync_blocks([b62], False, 16, b'bad-txns-nonfinal')\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -819,7 +798,7 @@ def get_tests(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        yield self.rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+        self.sync_blocks([b63], False, 16, b'bad-txns-nonfinal')\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -853,19 +832,23 @@ def get_tests(self):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n-        yield TestInstance([[self.tip, None]])\n+        self.sync_blocks([b64a], False, 1, b'error parsing message')\n \n-        # comptool workaround: to make sure b64 is delivered, manually erase b64a from blockstore\n-        self.test.block_store.erase(b64a.sha256)\n+        # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n+        # resend the header message, it won't send us the getdata message again. Just\n+        # disconnect and reconnect and then call sync_blocks.\n+        # TODO: improve this test to be less dependent on P2P DOS behaviour.\n+        node.disconnect_p2ps()\n+        self.reconnect_p2p()\n \n         self.move_tip(60)\n         b64 = CBlock(b64a)\n         b64.vtx = copy.deepcopy(b64a.vtx)\n         assert_equal(b64.hash, b64a.hash)\n         assert_equal(len(b64.serialize()), MAX_BLOCK_BASE_SIZE)\n         self.blocks[64] = b64\n-        self.update_block(64, [])\n-        yield self.accepted()\n+        b64 = self.update_block(64, [])\n+        self.sync_blocks([b64], True)\n         self.save_spendable_output()\n \n         # Spend an output created in the block itself\n@@ -874,11 +857,11 @@ def get_tests(self):\n         #\n         self.log.info(\"Accept a block with a transaction spending an output created in the same block\")\n         self.move_tip(64)\n-        self.next_block(65)\n+        b65 = self.next_block(65)\n         tx1 = self.create_and_sign_transaction(out[19].tx, out[19].n, out[19].tx.vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 0, 0)\n-        self.update_block(65, [tx1, tx2])\n-        yield self.accepted()\n+        b65 = self.update_block(65, [tx1, tx2])\n+        self.sync_blocks([b65], True)\n         self.save_spendable_output()\n \n         # Attempt to spend an output created later in the same block\n@@ -887,11 +870,11 @@ def get_tests(self):\n         #                                                                                    \\-> b66 (20)\n         self.log.info(\"Reject a block with a transaction spending an output created later in the same block\")\n         self.move_tip(65)\n-        self.next_block(66)\n+        b66 = self.next_block(66)\n         tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 0, 1)\n-        self.update_block(66, [tx2, tx1])\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b66 = self.update_block(66, [tx2, tx1])\n+        self.sync_blocks([b66], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to double-spend a transaction created in a block\n         #\n@@ -901,12 +884,12 @@ def get_tests(self):\n         #\n         self.log.info(\"Reject a block with a transaction double spending a transaction creted in the same block\")\n         self.move_tip(65)\n-        self.next_block(67)\n+        b67 = self.next_block(67)\n         tx1 = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 0, 1)\n         tx3 = self.create_and_sign_transaction(tx1, 0, 2)\n-        self.update_block(67, [tx1, tx2, tx3])\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b67 = self.update_block(67, [tx1, tx2, tx3])\n+        self.sync_blocks([b67], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # More tests of block subsidy\n         #\n@@ -922,17 +905,17 @@ def get_tests(self):\n         #\n         self.log.info(\"Reject a block trying to claim too much subsidy in the coinbase transaction\")\n         self.move_tip(65)\n-        self.next_block(68, additional_coinbase_value=10)\n+        b68 = self.next_block(68, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 9)\n-        self.update_block(68, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-cb-amount'))\n+        b68 = self.update_block(68, [tx])\n+        self.sync_blocks([b68], False, 16, b'bad-cb-amount', reconnect=True)\n \n         self.log.info(\"Accept a block claiming the correct subsidy in the coinbase transaction\")\n         self.move_tip(65)\n         b69 = self.next_block(69, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20].tx, out[20].n, out[20].tx.vout[0].nValue - 10)\n         self.update_block(69, [tx])\n-        yield self.accepted()\n+        self.sync_blocks([b69], True)\n         self.save_spendable_output()\n \n         # Test spending the outpoint of a non-existent transaction\n@@ -942,22 +925,22 @@ def get_tests(self):\n         #\n         self.log.info(\"Reject a block containing a transaction spending from a non-existent input\")\n         self.move_tip(69)\n-        self.next_block(70, spend=out[21])\n+        b70 = self.next_block(70, spend=out[21])\n         bogus_tx = CTransaction()\n         bogus_tx.sha256 = uint256_from_str(b\"23c70ed7c0506e9178fc1a987f40a33946d4ad4c962b5ae3a52546da53af0c5c\")\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n         tx.vout.append(CTxOut(1, b\"\"))\n-        self.update_block(70, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+        b70 = self.update_block(70, [tx])\n+        self.sync_blocks([b70], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n         #  -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20) -> b72 (21)\n         #                                                                                      \\-> b71 (21)\n         #\n         # b72 is a good block.\n-        # b71 is a copy of 72, but re-adds one of its transactions.  However, it has the same hash as b71.\n+        # b71 is a copy of 72, but re-adds one of its transactions.  However, it has the same hash as b72.\n         self.log.info(\"Reject a block containing a duplicate transaction but with the same Merkle root (Merkle tree malleability\")\n         self.move_tip(69)\n         b72 = self.next_block(72)\n@@ -974,9 +957,10 @@ def get_tests(self):\n         assert_equal(b72.sha256, b71.sha256)\n \n         self.move_tip(71)\n-        yield self.rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        self.sync_blocks([b71], False, 16, b'bad-txns-duplicate', reconnect=True)\n+\n         self.move_tip(72)\n-        yield self.accepted()\n+        self.sync_blocks([b72], True)\n         self.save_spendable_output()\n \n         # Test some invalid scripts and MAX_BLOCK_SIGOPS\n@@ -1011,7 +995,7 @@ def get_tests(self):\n         tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n         b73 = self.update_block(73, [tx])\n         assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        self.sync_blocks([b73], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n         #          but sigops after the element are not counted.\n@@ -1025,7 +1009,7 @@ def get_tests(self):\n         #       b75 succeeds because we put MAX_BLOCK_SIGOPS before the element\n         self.log.info(\"Check sigops are counted correctly after an invalid script element\")\n         self.move_tip(72)\n-        self.next_block(74)\n+        b74 = self.next_block(74)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42  # total = 20,561\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS] = 0x4e\n@@ -1034,11 +1018,11 @@ def get_tests(self):\n         a[MAX_BLOCK_SIGOPS + 3] = 0xff\n         a[MAX_BLOCK_SIGOPS + 4] = 0xff\n         tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n-        self.update_block(74, [tx])\n-        yield self.rejected(RejectResult(16, b'bad-blk-sigops'))\n+        b74 = self.update_block(74, [tx])\n+        self.sync_blocks([b74], False, 16, b'bad-blk-sigops', reconnect=True)\n \n         self.move_tip(72)\n-        self.next_block(75)\n+        b75 = self.next_block(75)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS - 1] = 0x4e\n@@ -1047,19 +1031,19 @@ def get_tests(self):\n         a[MAX_BLOCK_SIGOPS + 2] = 0xff\n         a[MAX_BLOCK_SIGOPS + 3] = 0xff\n         tx = self.create_and_sign_transaction(out[22].tx, 0, 1, CScript(a))\n-        self.update_block(75, [tx])\n-        yield self.accepted()\n+        b75 = self.update_block(75, [tx])\n+        self.sync_blocks([b75], True)\n         self.save_spendable_output()\n \n         # Check that if we push an element filled with CHECKSIGs, they are not counted\n         self.move_tip(75)\n-        self.next_block(76)\n+        b76 = self.next_block(76)\n         size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5\n         a = bytearray([OP_CHECKSIG] * size)\n         a[MAX_BLOCK_SIGOPS - 1] = 0x4e  # PUSHDATA4, but leave the following bytes as just checksigs\n         tx = self.create_and_sign_transaction(out[23].tx, 0, 1, CScript(a))\n-        self.update_block(76, [tx])\n-        yield self.accepted()\n+        b76 = self.update_block(76, [tx])\n+        self.sync_blocks([b76], True)\n         self.save_spendable_output()\n \n         # Test transaction resurrection\n@@ -1081,36 +1065,36 @@ def get_tests(self):\n         #    updated.  (Perhaps to spend to a P2SH OP_TRUE script)\n         self.log.info(\"Test transaction resurrection during a re-org\")\n         self.move_tip(76)\n-        self.next_block(77)\n+        b77 = self.next_block(77)\n         tx77 = self.create_and_sign_transaction(out[24].tx, out[24].n, 10 * COIN)\n-        self.update_block(77, [tx77])\n-        yield self.accepted()\n+        b77 = self.update_block(77, [tx77])\n+        self.sync_blocks([b77], True)\n         self.save_spendable_output()\n \n-        self.next_block(78)\n+        b78 = self.next_block(78)\n         tx78 = self.create_tx(tx77, 0, 9 * COIN)\n-        self.update_block(78, [tx78])\n-        yield self.accepted()\n+        b78 = self.update_block(78, [tx78])\n+        self.sync_blocks([b78], True)\n \n-        self.next_block(79)\n+        b79 = self.next_block(79)\n         tx79 = self.create_tx(tx78, 0, 8 * COIN)\n-        self.update_block(79, [tx79])\n-        yield self.accepted()\n+        b79 = self.update_block(79, [tx79])\n+        self.sync_blocks([b79], True)\n \n         # mempool should be empty\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.move_tip(77)\n-        self.next_block(80, spend=out[25])\n-        yield self.rejected()\n+        b80 = self.next_block(80, spend=out[25])\n+        self.sync_blocks([b80], False, request_block=False)\n         self.save_spendable_output()\n \n-        self.next_block(81, spend=out[26])\n-        yield self.rejected()  # other chain is same length\n+        b81 = self.next_block(81, spend=out[26])\n+        self.sync_blocks([b81], False, request_block=False)  # other chain is same length\n         self.save_spendable_output()\n \n-        self.next_block(82, spend=out[27])\n-        yield self.accepted()  # now this chain is longer, triggers re-org\n+        b82 = self.next_block(82, spend=out[27])\n+        self.sync_blocks([b82], True)  # now this chain is longer, triggers re-org\n         self.save_spendable_output()\n \n         # now check that tx78 and tx79 have been put back into the peer's mempool\n@@ -1124,7 +1108,7 @@ def get_tests(self):\n         #  -> b81 (26) -> b82 (27) -> b83 (28)\n         #\n         self.log.info(\"Accept a block with invalid opcodes in dead execution paths\")\n-        self.next_block(83)\n+        b83 = self.next_block(83)\n         op_codes = [OP_IF, OP_INVALIDOPCODE, OP_ELSE, OP_TRUE, OP_ENDIF]\n         script = CScript(op_codes)\n         tx1 = self.create_and_sign_transaction(out[28].tx, out[28].n, out[28].tx.vout[0].nValue, script)\n@@ -1133,8 +1117,8 @@ def get_tests(self):\n         tx2.vin[0].scriptSig = CScript([OP_FALSE])\n         tx2.rehash()\n \n-        self.update_block(83, [tx1, tx2])\n-        yield self.accepted()\n+        b83 = self.update_block(83, [tx1, tx2])\n+        self.sync_blocks([b83], True)\n         self.save_spendable_output()\n \n         # Reorg on/off blocks that have OP_RETURN in them (and try to spend them)\n@@ -1143,7 +1127,7 @@ def get_tests(self):\n         #                                    \\-> b85 (29) -> b86 (30)            \\-> b89a (32)\n         #\n         self.log.info(\"Test re-orging blocks with OP_RETURN in them\")\n-        self.next_block(84)\n+        b84 = self.next_block(84)\n         tx1 = self.create_tx(out[29].tx, out[29].n, 0, CScript([OP_RETURN]))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n@@ -1160,37 +1144,37 @@ def get_tests(self):\n         tx4.vout.append(CTxOut(0, CScript([OP_RETURN])))\n         tx5 = self.create_tx(tx1, 4, 0, CScript([OP_RETURN]))\n \n-        self.update_block(84, [tx1, tx2, tx3, tx4, tx5])\n-        yield self.accepted()\n+        b84 = self.update_block(84, [tx1, tx2, tx3, tx4, tx5])\n+        self.sync_blocks([b84], True)\n         self.save_spendable_output()\n \n         self.move_tip(83)\n-        self.next_block(85, spend=out[29])\n-        yield self.rejected()\n+        b85 = self.next_block(85, spend=out[29])\n+        self.sync_blocks([b85], False)  # other chain is same length\n \n-        self.next_block(86, spend=out[30])\n-        yield self.accepted()\n+        b86 = self.next_block(86, spend=out[30])\n+        self.sync_blocks([b86], True)\n \n         self.move_tip(84)\n-        self.next_block(87, spend=out[30])\n-        yield self.rejected()\n+        b87 = self.next_block(87, spend=out[30])\n+        self.sync_blocks([b87], False)  # other chain is same length\n         self.save_spendable_output()\n \n-        self.next_block(88, spend=out[31])\n-        yield self.accepted()\n+        b88 = self.next_block(88, spend=out[31])\n+        self.sync_blocks([b88], True)\n         self.save_spendable_output()\n \n         # trying to spend the OP_RETURN output is rejected\n-        self.next_block(\"89a\", spend=out[32])\n+        b89a = self.next_block(\"89a\", spend=out[32])\n         tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n-        self.update_block(\"89a\", [tx])\n-        yield self.rejected()\n+        b89a = self.update_block(\"89a\", [tx])\n+        self.sync_blocks([b89a], False, 16, b'bad-txns-inputs-missingorspent', reconnect=True)\n \n         self.log.info(\"Test a re-org of one week's worth of blocks (1088 blocks)\")\n \n         self.move_tip(88)\n         LARGE_REORG_SIZE = 1088\n-        test1 = TestInstance(sync_every_block=False)\n+        blocks = []\n         spend = out[32]\n         for i in range(89, LARGE_REORG_SIZE + 89):\n             b = self.next_block(i, spend)\n@@ -1201,33 +1185,30 @@ def get_tests(self):\n             tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n             b = self.update_block(i, [tx])\n             assert_equal(len(b.serialize()), MAX_BLOCK_BASE_SIZE)\n-            test1.blocks_and_transactions.append([self.tip, True])\n+            blocks.append(b)\n             self.save_spendable_output()\n             spend = self.get_spendable_output()\n \n-        yield test1\n+        self.sync_blocks(blocks, True, timeout=180)\n         chain1_tip = i\n \n         # now create alt chain of same length\n         self.move_tip(88)\n-        test2 = TestInstance(sync_every_block=False)\n+        blocks2 = []\n         for i in range(89, LARGE_REORG_SIZE + 89):\n-            self.next_block(\"alt\" + str(i))\n-            test2.blocks_and_transactions.append([self.tip, False])\n-        yield test2\n+            blocks2.append(self.next_block(\"alt\" + str(i)))\n+        self.sync_blocks(blocks2, False, request_block=False)\n \n         # extend alt chain to trigger re-org\n-        self.next_block(\"alt\" + str(chain1_tip + 1))\n-        yield self.accepted()\n+        block = self.next_block(\"alt\" + str(chain1_tip + 1))\n+        self.sync_blocks([block], True, timeout=180)\n \n         # ... and re-org back to the first chain\n         self.move_tip(chain1_tip)\n-        self.next_block(chain1_tip + 1)\n-        yield self.rejected()\n-        self.next_block(chain1_tip + 2)\n-        yield self.accepted()\n-\n-        chain1_tip += 2\n+        block = self.next_block(chain1_tip + 1)\n+        self.sync_blocks([block], False, request_block=False)\n+        block = self.next_block(chain1_tip + 2)\n+        self.sync_blocks([block], True, timeout=180)\n \n     # Helper methods\n     ################\n@@ -1238,8 +1219,7 @@ def add_transactions_to_block(self, block, tx_list):\n \n     # this is a little handier to use than the version in blocktools.py\n     def create_tx(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n-        tx = create_transaction(spend_tx, n, b\"\", value, script)\n-        return tx\n+        return create_transaction(spend_tx, n, b\"\", value, script)\n \n     # sign a transaction, using the key we know about\n     # this signs input 0 in tx, which is assumed to be spending output n in spend_tx\n@@ -1289,23 +1269,14 @@ def next_block(self, number, spend=None, additional_coinbase_value=0, script=CSc\n \n     # save the current tip so it can be spent by a later block\n     def save_spendable_output(self):\n+        self.log.debug(\"saving spendable output %s\" % self.tip.vtx[0])\n         self.spendable_outputs.append(self.tip)\n \n     # get an output that we previously marked as spendable\n     def get_spendable_output(self):\n+        self.log.debug(\"getting spendable output %s\" % self.spendable_outputs[0].vtx[0])\n         return PreviousSpendableOutput(self.spendable_outputs.pop(0).vtx[0], 0)\n \n-    # returns a test case that asserts that the current tip was accepted\n-    def accepted(self):\n-        return TestInstance([[self.tip, True]])\n-\n-    # returns a test case that asserts that the current tip was rejected\n-    def rejected(self, reject=None):\n-        if reject is None:\n-            return TestInstance([[self.tip, False]])\n-        else:\n-            return TestInstance([[self.tip, reject]])\n-\n     # move the tip back to a previous block\n     def move_tip(self, number):\n         self.tip = self.blocks[number]\n@@ -1325,6 +1296,26 @@ def update_block(self, block_number, new_transactions):\n         self.blocks[block_number] = block\n         return block\n \n+    def reconnect_p2p(self):\n+        \"\"\"Add a P2P connection to the node.\n+\n+        The node gets disconnected several times in this test. This helper\n+        method reconnects the p2p and restarts the network thread.\"\"\"\n+\n+        network_thread_join()\n+        self.nodes[0].disconnect_p2ps()\n+        self.nodes[0].add_p2p_connection(P2PDataStore())\n+        network_thread_start()\n+        self.nodes[0].p2p.wait_for_verack()\n+\n+    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True, reconnect=False, timeout=60):\n+        \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n+\n+        Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block, timeout=timeout)\n+\n+        if reconnect:\n+            self.reconnect_p2p()\n \n if __name__ == '__main__':\n     FullBlockTest().main()"
      }
    ]
  },
  {
    "sha": "265d7c44b1aae06aee93f745a865807732218a73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjVkN2M0NGIxYWFlMDZhZWU5M2Y3NDVhODY1ODA3NzMyMjE4YTcz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-12-13T19:39:44Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-19T18:26:12Z"
      },
      "message": "[tests] Improve assert message when wait_until() fails",
      "tree": {
        "sha": "87b07c01384fd6403576cb3f7e14e30f0be50cc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87b07c01384fd6403576cb3f7e14e30f0be50cc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/265d7c44b1aae06aee93f745a865807732218a73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/265d7c44b1aae06aee93f745a865807732218a73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/265d7c44b1aae06aee93f745a865807732218a73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/265d7c44b1aae06aee93f745a865807732218a73/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ebf053ac6135941907ecfebccc778da34b585fac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebf053ac6135941907ecfebccc778da34b585fac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ebf053ac6135941907ecfebccc778da34b585fac"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 9,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e676805f3d531497639ef20f7f7d990e1fe1cf2b",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/265d7c44b1aae06aee93f745a865807732218a73/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/265d7c44b1aae06aee93f745a865807732218a73/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=265d7c44b1aae06aee93f745a865807732218a73",
        "patch": "@@ -8,6 +8,7 @@\n from binascii import hexlify, unhexlify\n from decimal import Decimal, ROUND_DOWN\n import hashlib\n+import inspect\n import json\n import logging\n import os\n@@ -204,9 +205,9 @@ def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf'), lock=N\n     if attempts == float('inf') and timeout == float('inf'):\n         timeout = 60\n     attempt = 0\n-    timeout += time.time()\n+    time_end = time.time() + timeout\n \n-    while attempt < attempts and time.time() < timeout:\n+    while attempt < attempts and time.time() < time_end:\n         if lock:\n             with lock:\n                 if predicate():\n@@ -218,8 +219,12 @@ def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf'), lock=N\n         time.sleep(0.05)\n \n     # Print the cause of the timeout\n-    assert_greater_than(attempts, attempt)\n-    assert_greater_than(timeout, time.time())\n+    predicate_source = inspect.getsourcelines(predicate)\n+    logger.error(\"wait_until() failed. Predicate: {}\".format(predicate_source))\n+    if attempt >= attempts:\n+        raise AssertionError(\"Predicate {} not true after {} attempts\".format(predicate_source, attempts))\n+    elif time.time() >= time_end:\n+        raise AssertionError(\"Predicate {} not true after {} seconds\".format(predicate_source, timeout))\n     raise RuntimeError('Unreachable')\n \n # RPC/P2P connection constants and functions"
      }
    ]
  }
]