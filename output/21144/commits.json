[
  {
    "sha": "520e7799b556807c818eb05b5380c389a470ae3b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjBlNzc5OWI1NTY4MDdjODE4ZWIwNWI1MzgwYzM4OWE0NzBhZTNi",
    "commit": {
      "author": {
        "name": "Dan Benjamin",
        "email": "danben@gmail.com",
        "date": "2021-02-05T17:33:24Z"
      },
      "committer": {
        "name": "Dan Benjamin",
        "email": "danben@gmail.com",
        "date": "2021-02-19T16:14:41Z"
      },
      "message": "test: convert feature_bip_sequence.py to use MiniWallet\n\nThis is within the scope of issue #20078.\nChanges:\n - Removed skip_if_no_wallet and all uses of wallet RPCs from feature_bip_sequence.py\n - Added new functionality to wallet.py\n   - generate_random_outputs, a function that will create a multi-output transaction based on a single utxo in the wallet\n   - get_confirmations, a function that returns the number of confirmations for a given (confirmed) utxo\n   - get_utxos, a function that removes and returns the last n transactions in the wallet\n - Changed existing functionality in wallet.py\n   - send_self_transfer now accepts the following parameters: send_values, nSequence and nVersion\n   - send_self_transfer will now create a transaction with multiple outputs, if multiple send_values are specified",
      "tree": {
        "sha": "5be6cb32df8ad981a1d93717cb284510b56b2e85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5be6cb32df8ad981a1d93717cb284510b56b2e85"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/520e7799b556807c818eb05b5380c389a470ae3b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/520e7799b556807c818eb05b5380c389a470ae3b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/520e7799b556807c818eb05b5380c389a470ae3b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/520e7799b556807c818eb05b5380c389a470ae3b/comments",
    "author": {
      "login": "danben",
      "id": 253639,
      "node_id": "MDQ6VXNlcjI1MzYzOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/253639?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danben",
      "html_url": "https://github.com/danben",
      "followers_url": "https://api.github.com/users/danben/followers",
      "following_url": "https://api.github.com/users/danben/following{/other_user}",
      "gists_url": "https://api.github.com/users/danben/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danben/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danben/subscriptions",
      "organizations_url": "https://api.github.com/users/danben/orgs",
      "repos_url": "https://api.github.com/users/danben/repos",
      "events_url": "https://api.github.com/users/danben/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danben/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danben",
      "id": 253639,
      "node_id": "MDQ6VXNlcjI1MzYzOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/253639?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danben",
      "html_url": "https://github.com/danben",
      "followers_url": "https://api.github.com/users/danben/followers",
      "following_url": "https://api.github.com/users/danben/following{/other_user}",
      "gists_url": "https://api.github.com/users/danben/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danben/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danben/subscriptions",
      "organizations_url": "https://api.github.com/users/danben/orgs",
      "repos_url": "https://api.github.com/users/danben/repos",
      "events_url": "https://api.github.com/users/danben/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danben/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c46fe4d1073cd220b55ec8d55da2605529ea57a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c46fe4d1073cd220b55ec8d55da2605529ea57a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c46fe4d1073cd220b55ec8d55da2605529ea57a5"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 102,
      "deletions": 97
    },
    "files": [
      {
        "sha": "e002a014e50da79b8ce83bfa1b25d88db4d64de0",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 50,
        "deletions": 84,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/520e7799b556807c818eb05b5380c389a470ae3b/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/520e7799b556807c818eb05b5380c389a470ae3b/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=520e7799b556807c818eb05b5380c389a470ae3b",
        "patch": "@@ -4,19 +4,21 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP68 implementation.\"\"\"\n \n+import random\n import time\n \n from test_framework.blocktools import create_block, NORMAL_GBT_REQUEST_PARAMS, add_witness_commitment\n-from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, ToHex\n+from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, ToHex\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n-    satoshi_round,\n     softfork_active,\n )\n+from test_framework.script import CScript, OP_TRUE\n from test_framework.script_util import DUMMY_P2WPKH_SCRIPT\n+from test_framework.wallet import MiniWallet\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n@@ -37,14 +39,13 @@ def set_test_params(self):\n             [\"-acceptnonstdtxn=0\"],\n         ]\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n     def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[0])\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n \n         # Generate some coins\n-        self.nodes[0].generate(110)\n+        self.wallet.generate(10)\n+        self.nodes[0].generate(100)\n \n         self.log.info(\"Running test disable flag\")\n         self.test_disable_flag()\n@@ -70,45 +71,28 @@ def run_test(self):\n     # Test that BIP68 is not in effect if tx version is 1, or if\n     # the first sequence bit is set.\n     def test_disable_flag(self):\n-        # Create some unconfirmed inputs\n-        new_addr = self.nodes[0].getnewaddress()\n-        self.nodes[0].sendtoaddress(new_addr, 2) # send 2 BTC\n-\n-        utxos = self.nodes[0].listunspent(0, 0)\n-        assert len(utxos) > 0\n-\n-        utxo = utxos[0]\n-\n-        tx1 = CTransaction()\n-        value = int(satoshi_round(utxo[\"amount\"] - self.relayfee)*COIN)\n+        # Create an unconfirmed input\n+        sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n+        self.wallet.send_self_transfer(from_node=self.nodes[0], nSequence=sequence_value)\n \n         # Check that the disable flag disables relative locktime.\n         # If sequence locks were used, this would require 1 block for the\n         # input to mature.\n-        sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n-        tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)]\n-        tx1.vout = [CTxOut(value, DUMMY_P2WPKH_SCRIPT)]\n-\n-        tx1_signed = self.nodes[0].signrawtransactionwithwallet(ToHex(tx1))[\"hex\"]\n-        tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n-        tx1_id = int(tx1_id, 16)\n \n         # This transaction will enable sequence-locks, so this transaction should\n         # fail\n-        tx2 = CTransaction()\n-        tx2.nVersion = 2\n+        utxo = self.wallet.get_utxo()\n         sequence_value = sequence_value & 0x7fffffff\n-        tx2.vin = [CTxIn(COutPoint(tx1_id, 0), nSequence=sequence_value)]\n-        tx2.vout = [CTxOut(int(value - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx2.rehash()\n-\n-        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.wallet.send_self_transfer, from_node=self.nodes[0],\n+                utxo_to_spend=utxo, nSequence=sequence_value, nVersion=2)\n \n         # Setting the version back down to 1 should disable the sequence lock,\n         # so this should be accepted.\n-        tx2.nVersion = 1\n+        self.wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo, nSequence=sequence_value,\n+                nVersion=1)\n \n-        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        # Clean up so as not to interfere with future tests\n+        self.wallet.get_utxo()\n \n     # Calculate the median time past of a prior block (\"confirmations\" before\n     # the current tip).\n@@ -118,23 +102,12 @@ def get_median_time_past(self, confirmations):\n \n     # Test that sequence locks are respected for transactions spending confirmed inputs.\n     def test_sequence_lock_confirmed_inputs(self):\n-        # Create lots of confirmed utxos, and use them to generate lots of random\n-        # transactions.\n-        max_outputs = 50\n-        addresses = []\n-        while len(addresses) < max_outputs:\n-            addresses.append(self.nodes[0].getnewaddress())\n-        while len(self.nodes[0].listunspent()) < 200:\n-            import random\n-            random.shuffle(addresses)\n-            num_outputs = random.randint(1, max_outputs)\n-            outputs = {}\n-            for i in range(num_outputs):\n-                outputs[addresses[i]] = random.randint(1, 20)*0.01\n-            self.nodes[0].sendmany(\"\", outputs)\n-            self.nodes[0].generate(1)\n-\n-        utxos = self.nodes[0].listunspent()\n+        # Using the coinbase outputs already in the wallet, create lots of confirmed utxos\n+        # with varying numbers of confirmations.\n+        utxos = []\n+        for _ in range(4):\n+            self.wallet.generate_random_outputs(self.wallet.get_utxo(), 50)\n+            utxos += self.wallet.get_utxos(50)\n \n         # Try creating a lot of random transactions.\n         # Each time, choose a random number of inputs, and randomly set\n@@ -164,7 +137,8 @@ def test_sequence_lock_confirmed_inputs(self):\n \n                     # 10% of the time, make the input sequence value pass\n                     input_will_pass = (random.randint(1,10) == 1)\n-                    sequence_value = utxos[j][\"confirmations\"]\n+                    confirmations = self.wallet.get_confirmations(utxos[j])\n+                    sequence_value = confirmations\n                     if not input_will_pass:\n                         sequence_value += 1\n                         should_pass = False\n@@ -173,7 +147,7 @@ def test_sequence_lock_confirmed_inputs(self):\n                     # Note that if an input has N confirmations, we're going back N blocks\n                     # from the tip so that we're looking up MTP of the block\n                     # PRIOR to the one the input appears in, as per the BIP68 spec.\n-                    orig_time = self.get_median_time_past(utxos[j][\"confirmations\"])\n+                    orig_time = self.get_median_time_past(confirmations)\n                     cur_time = self.get_median_time_past(0) # MTP of the tip\n \n                     # can only timelock this input if it's not too old -- otherwise use height\n@@ -191,19 +165,21 @@ def test_sequence_lock_confirmed_inputs(self):\n                             sequence_value = ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY)+1\n                         sequence_value |= SEQUENCE_LOCKTIME_TYPE_FLAG\n                 tx.vin.append(CTxIn(COutPoint(int(utxos[j][\"txid\"], 16), utxos[j][\"vout\"]), nSequence=sequence_value))\n-                value += utxos[j][\"amount\"]*COIN\n+                tx.wit.vtxinwit.append(CTxInWitness())\n+                tx.wit.vtxinwit[-1].scriptWitness.stack = [CScript([OP_TRUE])]\n+                value += utxos[j][\"value\"]*COIN\n             # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n             tx_size = len(ToHex(tx))//2 + 120*num_inputs + 50\n             tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), DUMMY_P2WPKH_SCRIPT))\n-            rawtx = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n+            rawtx = tx.serialize().hex()\n \n             if (using_sequence_locks and not should_pass):\n                 # This transaction should be rejected\n                 assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, rawtx)\n             else:\n                 # This raw transaction should be accepted\n                 self.nodes[0].sendrawtransaction(rawtx)\n-                utxos = self.nodes[0].listunspent()\n+                utxos = utxos[num_inputs:]\n \n     # Test that sequence locks on unconfirmed inputs must have nSequence\n     # height or time of 0 to be accepted.\n@@ -213,21 +189,18 @@ def test_sequence_lock_unconfirmed_inputs(self):\n         # Store height so we can easily reset the chain at the end of the test\n         cur_height = self.nodes[0].getblockcount()\n \n-        # Create a mempool tx.\n-        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n-        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n-        tx1.rehash()\n+        tx1 = self.wallet.get_utxo()\n \n         # Anyone-can-spend mempool tx.\n         # Sequence lock of 0 should pass.\n         tx2 = CTransaction()\n         tx2.nVersion = 2\n-        tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n-        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n-        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.vin = [CTxIn(COutPoint(int(tx1['txid'], 16), 0), nSequence=0)]\n+        tx2.vout = [CTxOut(int((tx1['value'] - self.relayfee)*COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx2.wit.vtxinwit = [CTxInWitness()]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx2_raw = tx2.serialize().hex()\n         tx2.rehash()\n-\n         self.nodes[0].sendrawtransaction(tx2_raw)\n \n         # Create a spend of the 0th output of orig_tx with a sequence lock\n@@ -296,10 +269,12 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         tx5 = test_nonzero_locks(tx4, self.nodes[0], self.relayfee, use_height_lock=True)\n         assert tx5.hash not in self.nodes[0].getrawmempool()\n \n-        utxos = self.nodes[0].listunspent()\n-        tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n-        tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n-        raw_tx5 = self.nodes[0].signrawtransactionwithwallet(ToHex(tx5))[\"hex\"]\n+        utxo = self.wallet.get_utxo()\n+        tx5.vin.append(CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=1))\n+        tx5.vout[0].nValue += int(utxo[\"value\"]*COIN)\n+        tx5.wit.vtxinwit = [CTxInWitness()]\n+        tx5.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        raw_tx5 = tx5.serialize().hex()\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n \n@@ -346,23 +321,21 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n     # this test should be moved to run earlier, or deleted.\n     def test_bip68_not_consensus(self):\n         assert not softfork_active(self.nodes[0], 'csv')\n-        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n \n-        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx0 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(tx0[\"txid\"]))\n         tx1.rehash()\n \n         # Make an anyone-can-spend transaction\n         tx2 = CTransaction()\n         tx2.nVersion = 1\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n         tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n-\n-        # sign tx2\n-        tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n-        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.wit.vtxinwit = [CTxInWitness()]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx2_hex = tx2.serialize().hex()\n         tx2.rehash()\n-\n-        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        self.nodes[0].sendrawtransaction(tx2_hex)\n \n         # Now make an invalid spend of tx2 according to BIP68\n         sequence_value = 100 # 100 block relative locktime\n@@ -400,14 +373,7 @@ def activateCSV(self):\n \n     # Use self.nodes[1] to test that version 2 transactions are standard.\n     def test_version2_relay(self):\n-        inputs = [ ]\n-        outputs = { self.nodes[1].getnewaddress() : 1.0 }\n-        rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n-        rawtxfund = self.nodes[1].fundrawtransaction(rawtx)['hex']\n-        tx = FromHex(CTransaction(), rawtxfund)\n-        tx.nVersion = 2\n-        tx_signed = self.nodes[1].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n-        self.nodes[1].sendrawtransaction(tx_signed)\n+        self.wallet.send_self_transfer(from_node=self.nodes[1], nVersion=2)\n \n if __name__ == '__main__':\n     BIP68Test().main()"
      },
      {
        "sha": "53eebf3e2c9f04d3aa09c270fd94cc70e3f9992e",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 52,
        "deletions": 13,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/520e7799b556807c818eb05b5380c389a470ae3b/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/520e7799b556807c818eb05b5380c389a470ae3b/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=520e7799b556807c818eb05b5380c389a470ae3b",
        "patch": "@@ -37,9 +37,31 @@ def generate(self, num_blocks):\n         blocks = self._test_node.generatetoaddress(num_blocks, self._address)\n         for b in blocks:\n             cb_tx = self._test_node.getblock(blockhash=b, verbosity=2)['tx'][0]\n-            self._utxos.append({'txid': cb_tx['txid'], 'vout': 0, 'value': cb_tx['vout'][0]['value']})\n+            self._utxos.append({'txid': cb_tx['txid'], 'vout': 0, 'value': cb_tx['vout'][0]['value'], 'blockhash':b})\n         return blocks\n \n+    def generate_random_outputs(self, utxo, num_outputs, confirmed=True):\n+        \"\"\"Split up a utxo to create multiple outputs\"\"\"\n+        import random\n+        total_value = utxo['value']\n+        send_values = []\n+        for i in range(num_outputs):\n+            if i == num_outputs - 1:\n+                val = total_value\n+            else:\n+                val = satoshi_round(total_value * Decimal((1 / (num_outputs - i)) * random.uniform(0.5, 1.5)))\n+            send_values.append(val)\n+            total_value -= val\n+        self.send_self_transfer(from_node=self._test_node, utxo_to_spend=utxo, send_values=send_values)\n+        if confirmed:\n+            blockhash = self._test_node.generatetoaddress(1, self._address)[0]\n+            # Ignore the coinbase output since we only want confirmed outputs\n+            for i in range(num_outputs):\n+                self._utxos[-(i+1)]['blockhash'] = blockhash\n+\n+    def get_confirmations(self, utxo):\n+        return self._test_node.getblock(blockhash=utxo['blockhash'], verbosity=1)['confirmations']\n+\n     def get_utxo(self, *, txid=''):\n         \"\"\"\n         Returns a utxo and marks it as spent (pops it from the internal list)\n@@ -55,25 +77,42 @@ def get_utxo(self, *, txid=''):\n             index = self._utxos.index(utxo)\n         return self._utxos.pop(index)\n \n-    def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None):\n+    def get_utxos(self, amount):\n+        \"\"\"Removes and returns the last {amount} utxos from the wallet\"\"\"\n+        assert amount <= len(self._utxos)\n+        ret = self._utxos[-amount:]\n+        self._utxos = self._utxos[:-amount]\n+        return ret\n+\n+    def send_self_transfer(self, *, fee_rate=Decimal(\"0.00003\"), from_node, utxo_to_spend=None, send_values=None, nSequence=0, nVersion=1):\n         \"\"\"Create and send a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n         self._utxos = sorted(self._utxos, key=lambda k: k['value'])\n         utxo_to_spend = utxo_to_spend or self._utxos.pop()  # Pick the largest utxo (if none provided) and hope it covers the fee\n-        vsize = Decimal(96)\n-        send_value = satoshi_round(utxo_to_spend['value'] - fee_rate * (vsize / 1000))\n-        fee = utxo_to_spend['value'] - send_value\n-        assert send_value > 0\n-\n+        send_values = send_values or [utxo_to_spend['value']]\n+        assert sum(send_values) <= utxo_to_spend['value']\n+        vsize = Decimal(53 + 43 * len(send_values))\n         tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']))]\n-        tx.vout = [CTxOut(int(send_value * COIN), self._scriptPubKey)]\n+        tx.nVersion = nVersion\n+        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']), nSequence=nSequence)]\n+\n+        # Distribute the fee evenly among all outputs\n+        fee_per_output = satoshi_round(fee_rate * vsize / 1000 / len(send_values))\n+\n+        total_sent = 0\n+        for send_value in send_values:\n+            output_value = satoshi_round(send_value - fee_per_output)\n+            total_sent += output_value\n+            tx.vout.append(CTxOut(int(output_value * COIN), self._scriptPubKey))\n+\n         tx.wit.vtxinwit = [CTxInWitness()]\n         tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n         tx_hex = tx.serialize().hex()\n \n         tx_info = from_node.testmempoolaccept([tx_hex])[0]\n-        self._utxos.append({'txid': tx_info['txid'], 'vout': 0, 'value': send_value})\n-        from_node.sendrawtransaction(tx_hex)\n+        for i, send_value in enumerate(send_values):\n+            self._utxos.append({'txid': tx_info['txid'], 'vout': i, 'value': satoshi_round(send_value - fee_per_output)})\n+\n+        assert_equal(tx_info['txid'], from_node.sendrawtransaction(tx_hex))\n         assert_equal(tx_info['vsize'], vsize)\n-        assert_equal(tx_info['fees']['base'], fee)\n-        return {'txid': tx_info['txid'], 'wtxid': tx_info['wtxid'], 'hex': tx_hex}\n+        assert_equal(tx_info['fees']['base'], fee_per_output * len(send_values))\n+        return {'txid': tx_info['txid'], 'wtxid': tx_info['wtxid'], 'hex': tx_hex, 'value': sum(send_values)}"
      }
    ]
  }
]