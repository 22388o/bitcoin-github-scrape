[
  {
    "sha": "e74290e1d76ad21d9272a543862fa352a7c95cfa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzQyOTBlMWQ3NmFkMjFkOTI3MmE1NDM4NjJmYTM1MmE3Yzk1Y2Zh",
    "commit": {
      "author": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-08-31T19:19:27Z"
      },
      "committer": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-09-08T19:37:43Z"
      },
      "message": "Simplify CNetAddr method for setting raw IPv4/6 address\n\nInstead of having SetRaw() which asserts on the Network type to only be IPv4 or IPv6, which has two different implementations for the two cases anyway, just define two different methods SetRawIPv4 and SetRawIPv6. The only advantage of having a generic SetRaw accepting a Network type parameter would be for simplifying code in callers of the SetRaw method which are oblivious of the Network type, but there aren't even currently any calls to the SetRaw method from outside of the CNetAddr class.\n\nThis is a preparation for the next commits will also need this change since we are going to use std::array instead of raw C-arrays, which means the parameter types of SetRawIPv4 and SetRawIPv6 will no longer be the same since they would be std::arrays of different length.\n\nIn this commit we also change the parameter type of the SetRawIPv4/6 methods to be an unsigned char* instead of uint8_t*, since we pass in an aliased in_addr, and aliasing it to uint8_t* is non-standard. There's also no reason to use uint8_t anyway since we copy it into an unsigned char array.",
      "tree": {
        "sha": "6677862eb4320dbce7d556cfc5d8b06777994f30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6677862eb4320dbce7d556cfc5d8b06777994f30"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e74290e1d76ad21d9272a543862fa352a7c95cfa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e74290e1d76ad21d9272a543862fa352a7c95cfa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e74290e1d76ad21d9272a543862fa352a7c95cfa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e74290e1d76ad21d9272a543862fa352a7c95cfa/comments",
    "author": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3255d6347b1f9eccbec3d6d93d4a424087a3b35b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3255d6347b1f9eccbec3d6d93d4a424087a3b35b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3255d6347b1f9eccbec3d6d93d4a424087a3b35b"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 12,
      "deletions": 17
    },
    "files": [
      {
        "sha": "e37bdeb8273850b43cd218b423809f59693faa7e",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 15,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e74290e1d76ad21d9272a543862fa352a7c95cfa/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e74290e1d76ad21d9272a543862fa352a7c95cfa/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e74290e1d76ad21d9272a543862fa352a7c95cfa",
        "patch": "@@ -29,20 +29,15 @@ void CNetAddr::SetIP(const CNetAddr& ipIn)\n     memcpy(ip, ipIn.ip, sizeof(ip));\n }\n \n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n+void CNetAddr::SetRawIPv4(const unsigned char *ip_in)\n {\n-    switch(network)\n-    {\n-        case NET_IPV4:\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n-    }\n+    memcpy(ip, pchIPv4, 12);\n+    memcpy(ip+12, ip_in, 4);\n+}\n+\n+void CNetAddr::SetRawIPv6(const unsigned char *ip_in)\n+{\n+    memcpy(ip, ip_in, 16);\n }\n \n bool CNetAddr::SetInternal(const std::string &name)\n@@ -78,12 +73,12 @@ CNetAddr::CNetAddr()\n \n CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n {\n-    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n+    SetRawIPv4((const unsigned char*)&ipv4Addr);\n }\n \n CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n {\n-    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n+    SetRawIPv6((const unsigned char*)&ipv6Addr);\n     scopeId = scope;\n }\n "
      },
      {
        "sha": "e63e609d0f62b6da6ee160ea74fde1589c0aab40",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e74290e1d76ad21d9272a543862fa352a7c95cfa/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e74290e1d76ad21d9272a543862fa352a7c95cfa/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=e74290e1d76ad21d9272a543862fa352a7c95cfa",
        "patch": "@@ -42,9 +42,9 @@ class CNetAddr\n \n         /**\n          * Set raw IPv4 or IPv6 address (in network byte order)\n-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n          */\n-        void SetRaw(Network network, const uint8_t *data);\n+        void SetRawIPv4(const unsigned char *data);\n+        void SetRawIPv6(const unsigned char *data);\n \n         /**\n           * Transform an arbitrary string into a non-routable ipv6 address."
      }
    ]
  },
  {
    "sha": "5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Nzk4Nzc3YTQ2MmI3YjgxZmQxZmZhNDJjOGJiYzliY2Q2MTFlODUx",
    "commit": {
      "author": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-08-31T20:55:11Z"
      },
      "committer": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-09-08T19:37:43Z"
      },
      "message": "Simplify and cleanup CNetAddr::SetSpecial() implementation",
      "tree": {
        "sha": "cf78a2a01c0a9bf32b985f2955cbaca39ea2b6f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cf78a2a01c0a9bf32b985f2955cbaca39ea2b6f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5798777a462b7b81fd1ffa42c8bbc9bcd611e851/comments",
    "author": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e74290e1d76ad21d9272a543862fa352a7c95cfa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e74290e1d76ad21d9272a543862fa352a7c95cfa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e74290e1d76ad21d9272a543862fa352a7c95cfa"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 16,
      "deletions": 9
    },
    "files": [
      {
        "sha": "e5ff6d267af0d60d6a8d77526d4457e94cf18178",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5798777a462b7b81fd1ffa42c8bbc9bcd611e851/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5798777a462b7b81fd1ffa42c8bbc9bcd611e851/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
        "patch": "@@ -12,6 +12,8 @@\n #include \"utilstrencodings.h\"\n #include \"tinyformat.h\"\n \n+#include <boost/algorithm/string/predicate.hpp>\n+\n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n \n@@ -54,16 +56,21 @@ bool CNetAddr::SetInternal(const std::string &name)\n \n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n-        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n-            return false;\n-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n-        return true;\n+    if (!boost::algorithm::ends_with(strName, \".onion\")) {\n+        return false;\n     }\n-    return false;\n+\n+    std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n+    if (vchAddr.size() != 16-sizeof(pchOnionCat)) {\n+        return false;\n+    }\n+\n+    memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n+    for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++) {\n+        ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n+    }\n+\n+    return true;\n }\n \n CNetAddr::CNetAddr()"
      }
    ]
  },
  {
    "sha": "6d2af299df1fbe6521f8945033ab8e8704ea6840",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDJhZjI5OWRmMWZiZTY1MjFmODk0NTAzM2FiOGU4NzA0ZWE2ODQw",
    "commit": {
      "author": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-08-31T23:16:11Z"
      },
      "committer": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-09-08T19:37:43Z"
      },
      "message": "Change CNetAddr code to modern C++ instead of C\n\n- Use std::array instead of C arrays.\n- Use algorithms where appropriate.\n- Use auto\n- Specify reinterpret_cast where it is done\n\nThe above changes make the code safer and simplify most of the implementation.\n\nAlso, some code was DRYed during the refactor, specifically sizeof is used where it makes sense instead of repeating hard-coded lengths of ips and ip prefixes.",
      "tree": {
        "sha": "8ead5db7fbd8a387e98c820d45d28f0c036ce8c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ead5db7fbd8a387e98c820d45d28f0c036ce8c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d2af299df1fbe6521f8945033ab8e8704ea6840",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2af299df1fbe6521f8945033ab8e8704ea6840",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d2af299df1fbe6521f8945033ab8e8704ea6840",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2af299df1fbe6521f8945033ab8e8704ea6840/comments",
    "author": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5798777a462b7b81fd1ffa42c8bbc9bcd611e851",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5798777a462b7b81fd1ffa42c8bbc9bcd611e851"
      }
    ],
    "stats": {
      "total": 233,
      "additions": 125,
      "deletions": 108
    },
    "files": [
      {
        "sha": "9392b9e461e557752a5200949195305e1b194230",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 118,
        "deletions": 102,
        "changes": 220,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d2af299df1fbe6521f8945033ab8e8704ea6840/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d2af299df1fbe6521f8945033ab8e8704ea6840/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=6d2af299df1fbe6521f8945033ab8e8704ea6840",
        "patch": "@@ -8,67 +8,70 @@\n #endif\n \n #include \"netaddress.h\"\n+\n #include \"hash.h\"\n-#include \"utilstrencodings.h\"\n #include \"tinyformat.h\"\n+#include \"utilstrencodings.h\"\n \n-#include <boost/algorithm/string/predicate.hpp>\n+#include <algorithm>\n+#include <utility>\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+static const std::array<unsigned char, 12> IPV4_IP_PREFIX = {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff }};\n+static const std::array<unsigned char, 6> ONION_IP_PREFIX = {{ 0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43 }};\n \n // 0xFD + sha256(\"bitcoin\")[0:5]\n-static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n+static const std::array<unsigned char, 6> INTERNAL_IP_PREFIX = {{ 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 }};\n+\n+static const std::string ONION_ADDRESS_SUFFIX {\".onion\"};\n \n void CNetAddr::Init()\n {\n-    memset(ip, 0, sizeof(ip));\n+    ip.fill(0);\n     scopeId = 0;\n }\n \n-void CNetAddr::SetIP(const CNetAddr& ipIn)\n+void CNetAddr::SetIP(CNetAddr ipIn)\n {\n-    memcpy(ip, ipIn.ip, sizeof(ip));\n+    ip = ipIn.ip;\n }\n \n-void CNetAddr::SetRawIPv4(const unsigned char *ip_in)\n+void CNetAddr::SetRawIPv4(const std::array<unsigned char, 4>& ip_in)\n {\n-    memcpy(ip, pchIPv4, 12);\n-    memcpy(ip+12, ip_in, 4);\n+    assert(IPV4_IP_PREFIX.size() + ip_in.size() == ip.size());\n+    auto it = std::copy(IPV4_IP_PREFIX.begin(), IPV4_IP_PREFIX.end(), ip.begin());\n+    std::copy(ip_in.begin(), ip_in.end(), it);\n }\n \n-void CNetAddr::SetRawIPv6(const unsigned char *ip_in)\n+void CNetAddr::SetRawIPv6(const std::array<unsigned char, 16>& ip_in)\n {\n-    memcpy(ip, ip_in, 16);\n+    ip = ip_in;\n }\n \n bool CNetAddr::SetInternal(const std::string &name)\n {\n     if (name.empty()) {\n         return false;\n     }\n-    unsigned char hash[32] = {};\n-    CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n-    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n-    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\n+    std::array<unsigned char, 32> hash {};\n+    CSHA256().Write(reinterpret_cast<const unsigned char*>(name.data()), name.size()).Finalize(hash.data());\n+    auto it = std::copy(INTERNAL_IP_PREFIX.begin(), INTERNAL_IP_PREFIX.end(), ip.begin());\n+    std::copy(hash.begin(), hash.begin() + (ip.size() - INTERNAL_IP_PREFIX.size()), it);\n     return true;\n }\n \n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n-    if (!boost::algorithm::ends_with(strName, \".onion\")) {\n+    if (strName.size() <= ONION_ADDRESS_SUFFIX.size() || !std::equal(ONION_ADDRESS_SUFFIX.begin(), ONION_ADDRESS_SUFFIX.end(), strName.end() - ONION_ADDRESS_SUFFIX.size())) {\n         return false;\n     }\n \n-    std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-    if (vchAddr.size() != 16-sizeof(pchOnionCat)) {\n+    const auto vchAddr = DecodeBase32(strName.substr(0, strName.size() - ONION_ADDRESS_SUFFIX.size()).c_str());\n+    if (vchAddr.size() != ip.size() - ONION_IP_PREFIX.size()) {\n         return false;\n     }\n \n-    memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-    for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++) {\n-        ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n-    }\n+    auto it = std::copy(ONION_IP_PREFIX.begin(), ONION_IP_PREFIX.end(), ip.begin());\n+    std::copy(vchAddr.begin(), vchAddr.end(), it);\n \n     return true;\n }\n@@ -80,23 +83,29 @@ CNetAddr::CNetAddr()\n \n CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n {\n-    SetRawIPv4((const unsigned char*)&ipv4Addr);\n+    std::array<unsigned char, 4> ipAr;\n+    const auto* ipv4AddrBytes = reinterpret_cast<const unsigned char*>(&ipv4Addr);\n+    std::copy(ipv4AddrBytes, ipv4AddrBytes + ipAr.size(), ipAr.begin());\n+    SetRawIPv4(ipAr);\n }\n \n CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n {\n-    SetRawIPv6((const unsigned char*)&ipv6Addr);\n+    std::array<unsigned char, 16> ipAr;\n+    const auto* ipv6AddrBytes = reinterpret_cast<const unsigned char*>(&ipv6Addr);\n+    std::copy(ipv6AddrBytes, ipv6AddrBytes + ipAr.size(), ipAr.begin());\n+    SetRawIPv6(ipAr);\n     scopeId = scope;\n }\n \n-unsigned int CNetAddr::GetByte(int n) const\n+unsigned int CNetAddr::GetByte(unsigned int n) const\n {\n-    return ip[15-n];\n+    return *(ip.end() - (n+1));\n }\n \n bool CNetAddr::IsIPv4() const\n {\n-    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n+    return std::equal(IPV4_IP_PREFIX.begin(), IPV4_IP_PREFIX.end(), ip.begin());\n }\n \n bool CNetAddr::IsIPv6() const\n@@ -146,8 +155,8 @@ bool CNetAddr::IsRFC3964() const\n \n bool CNetAddr::IsRFC6052() const\n {\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+    static const std::array<unsigned char, 12> RFC6052_IP_PREFIX {{ 0, 0x64, 0xFF, 0x9B, 0, 0, 0, 0, 0, 0, 0, 0}};\n+    return std::equal(RFC6052_IP_PREFIX.begin(), RFC6052_IP_PREFIX.end(), ip.begin());\n }\n \n bool CNetAddr::IsRFC4380() const\n@@ -157,8 +166,8 @@ bool CNetAddr::IsRFC4380() const\n \n bool CNetAddr::IsRFC4862() const\n {\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+    static const std::array<unsigned char, 8> RFC4862_IP_PREFIX {{ 0xFE, 0x80, 0, 0, 0, 0, 0, 0 }};\n+    return std::equal(RFC4862_IP_PREFIX.begin(), RFC4862_IP_PREFIX.end(), ip.begin());\n }\n \n bool CNetAddr::IsRFC4193() const\n@@ -168,8 +177,8 @@ bool CNetAddr::IsRFC4193() const\n \n bool CNetAddr::IsRFC6145() const\n {\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n-    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+    static const std::array<unsigned char, 12> RFC6145_IP_PREFIX = {{ 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0, 0 }};\n+    return std::equal(RFC6145_IP_PREFIX.begin(), RFC6145_IP_PREFIX.end(), ip.begin());\n }\n \n bool CNetAddr::IsRFC4843() const\n@@ -179,7 +188,7 @@ bool CNetAddr::IsRFC4843() const\n \n bool CNetAddr::IsTor() const\n {\n-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n+    return std::equal(ONION_IP_PREFIX.begin(), ONION_IP_PREFIX.end(), ip.begin());\n }\n \n bool CNetAddr::IsLocal() const\n@@ -189,11 +198,8 @@ bool CNetAddr::IsLocal() const\n        return true;\n \n    // IPv6 loopback (::1/128)\n-   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-   if (memcmp(ip, pchLocal, 16) == 0)\n-       return true;\n-\n-   return false;\n+   static const std::array<unsigned char, 16> LOOPBACK_IP {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }};\n+   return ip == LOOPBACK_IP;\n }\n \n bool CNetAddr::IsValid() const\n@@ -204,32 +210,34 @@ bool CNetAddr::IsValid() const\n     // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n     // so if the first length field is garbled, it reads the second batch\n     // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+    if (std::equal(IPV4_IP_PREFIX.begin() + 3, IPV4_IP_PREFIX.end(), ip.begin())) {\n         return false;\n+    }\n \n     // unspecified IPv6 address (::/128)\n-    unsigned char ipNone6[16] = {};\n-    if (memcmp(ip, ipNone6, 16) == 0)\n+    if (std::all_of(ip.begin(), ip.end(), [](unsigned char x){ return x == 0; })) {\n         return false;\n+    }\n \n     // documentation IPv6 address\n-    if (IsRFC3849())\n+    if (IsRFC3849()) {\n         return false;\n+    }\n \n-    if (IsInternal())\n+    if (IsInternal()) {\n         return false;\n+    }\n \n-    if (IsIPv4())\n-    {\n+    if (IsIPv4()) {\n+        const auto ipv4_begin = ip.begin() + IPV4_IP_PREFIX.size();\n         // INADDR_NONE\n-        uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+        if (std::all_of(ipv4_begin, ip.end(), [](unsigned char x){ return x == 0xff; })) {\n             return false;\n-\n+        }\n         // 0\n-        ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+        if (std::all_of(ipv4_begin, ip.end(), [](unsigned char x){ return x == 0; })) {\n             return false;\n+        }\n     }\n \n     return true;\n@@ -242,7 +250,7 @@ bool CNetAddr::IsRoutable() const\n \n bool CNetAddr::IsInternal() const\n {\n-   return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n+   return std::equal(INTERNAL_IP_PREFIX.begin(), INTERNAL_IP_PREFIX.end(), ip.begin());\n }\n \n enum Network CNetAddr::GetNetwork() const\n@@ -264,10 +272,12 @@ enum Network CNetAddr::GetNetwork() const\n \n std::string CNetAddr::ToStringIP() const\n {\n-    if (IsTor())\n-        return EncodeBase32(&ip[6], 10) + \".onion\";\n-    if (IsInternal())\n-        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\n+    if (IsTor()) {\n+        return EncodeBase32(ip.data() + ONION_IP_PREFIX.size(), ip.size() - ONION_IP_PREFIX.size()) + ONION_ADDRESS_SUFFIX;\n+    }\n+    if (IsInternal()) {\n+        return EncodeBase32(ip.data() + INTERNAL_IP_PREFIX.size(), ip.size() - INTERNAL_IP_PREFIX.size()) + \".internal\";\n+    }\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n@@ -293,30 +303,31 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n+    return a.ip == b.ip;\n }\n \n bool operator!=(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) != 0);\n+    return !(a == b);\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n+    return a.ip < b.ip;\n }\n \n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n {\n-    if (!IsIPv4())\n+    if (!IsIPv4()) {\n         return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n+    }\n+    std::copy(ip.begin() + IPV4_IP_PREFIX.size(), ip.end(), reinterpret_cast<unsigned char*>(pipv4Addr));\n     return true;\n }\n \n bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n {\n-    memcpy(pipv6Addr, ip, 16);\n+    std::copy(ip.begin(), ip.end(), reinterpret_cast<unsigned char*>(pipv6Addr));\n     return true;\n }\n \n@@ -339,8 +350,8 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     if (IsInternal())\n     {\n         nClass = NET_INTERNAL;\n-        nStartByte = sizeof(g_internal_prefix);\n-        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n+        nStartByte = INTERNAL_IP_PREFIX.size();\n+        nBits = (ip.size() - INTERNAL_IP_PREFIX.size()) * 8;\n     }\n     // all other unroutable addresses belong to the same group\n     else if (!IsRoutable())\n@@ -353,7 +364,7 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n     {\n         nClass = NET_IPV4;\n-        nStartByte = 12;\n+        nStartByte = IPV4_IP_PREFIX.size();\n     }\n     // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n     else if (IsRFC3964())\n@@ -372,7 +383,7 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     else if (IsTor())\n     {\n         nClass = NET_TOR;\n-        nStartByte = 6;\n+        nStartByte = ONION_IP_PREFIX.size();\n         nBits = 4;\n     }\n     // for he.net, use /36 groups\n@@ -383,21 +394,21 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nBits = 32;\n \n     vchRet.push_back(nClass);\n-    while (nBits >= 8)\n-    {\n-        vchRet.push_back(GetByte(15 - nStartByte));\n+    while (nBits >= 8) {\n+        vchRet.push_back(GetByte(ip.size() - 1 - nStartByte));\n         nStartByte++;\n         nBits -= 8;\n     }\n-    if (nBits > 0)\n-        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n+    if (nBits > 0) {\n+        vchRet.push_back(GetByte(ip.size() - 1 - nStartByte) | ((1 << (8 - nBits)) - 1));\n+    }\n \n     return vchRet;\n }\n \n uint64_t CNetAddr::GetHash() const\n {\n-    uint256 hash = Hash(&ip[0], &ip[16]);\n+    uint256 hash = Hash(ip.begin(), ip.end());\n     uint64_t nRet;\n     memcpy(&nRet, &hash, sizeof(nRet));\n     return nRet;\n@@ -511,10 +522,10 @@ bool CService::SetSockAddr(const struct sockaddr *paddr)\n {\n     switch (paddr->sa_family) {\n     case AF_INET:\n-        *this = CService(*(const struct sockaddr_in*)paddr);\n+        *this = CService(*reinterpret_cast<const struct sockaddr_in*>(paddr));\n         return true;\n     case AF_INET6:\n-        *this = CService(*(const struct sockaddr_in6*)paddr);\n+        *this = CService(*reinterpret_cast<const struct sockaddr_in6*>(paddr));\n         return true;\n     default:\n         return false;\n@@ -547,7 +558,7 @@ bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n             return false;\n         *addrlen = sizeof(struct sockaddr_in);\n-        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n+        auto *paddrin = reinterpret_cast<struct sockaddr_in*>(paddr);\n         memset(paddrin, 0, *addrlen);\n         if (!GetInAddr(&paddrin->sin_addr))\n             return false;\n@@ -559,7 +570,7 @@ bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n             return false;\n         *addrlen = sizeof(struct sockaddr_in6);\n-        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n+        auto *paddrin6 = reinterpret_cast<struct sockaddr_in6*>(paddr);\n         memset(paddrin6, 0, *addrlen);\n         if (!GetIn6Addr(&paddrin6->sin6_addr))\n             return false;\n@@ -575,7 +586,7 @@ std::vector<unsigned char> CService::GetKey() const\n {\n      std::vector<unsigned char> vKey;\n      vKey.resize(18);\n-     memcpy(vKey.data(), ip, 16);\n+     std::copy(ip.begin(), ip.end(), vKey.begin());\n      vKey[16] = port / 0x100;\n      vKey[17] = port & 0x0FF;\n      return vKey;\n@@ -600,18 +611,19 @@ std::string CService::ToString() const\n     return ToStringIPPort();\n }\n \n-CSubNet::CSubNet():\n-    valid(false)\n+CSubNet::CSubNet()\n+: netmask {}\n+, valid {false}\n {\n-    memset(netmask, 0, sizeof(netmask));\n+    // Empty\n }\n \n CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n {\n     valid = true;\n     network = addr;\n     // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n+    std::fill(netmask.begin(), netmask.end(), 255);\n \n     // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n     const int astartofs = network.IsIPv4() ? 12 : 0;\n@@ -627,46 +639,47 @@ CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n         valid = false;\n \n     // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n+    std::transform(network.ip.begin(), network.ip.end(), netmask.begin(), network.ip.begin(),\n+        [](unsigned char ip_byte, unsigned char mask_byte) { return ip_byte & mask_byte; });\n }\n \n CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n {\n     valid = true;\n     network = addr;\n     // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n+    std::fill(netmask.begin(), netmask.end(), 255);\n \n     // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-    const int astartofs = network.IsIPv4() ? 12 : 0;\n+    const size_t astartofs = network.IsIPv4() ? IPV4_IP_PREFIX.size() : 0;\n \n-    for(int x=astartofs; x<16; ++x)\n-        netmask[x] = mask.ip[x];\n+    std::copy(mask.ip.begin() + astartofs, mask.ip.end(), netmask.begin() + astartofs);\n \n     // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n+    std::transform(network.ip.begin(), network.ip.end(), netmask.begin(), network.ip.begin(),\n+        [](unsigned char ip_byte, unsigned char mask_byte) { return ip_byte & mask_byte; });\n }\n \n CSubNet::CSubNet(const CNetAddr &addr):\n     valid(addr.IsValid())\n {\n-    memset(netmask, 255, sizeof(netmask));\n+    std::fill(netmask.begin(), netmask.end(), 255);\n     network = addr;\n }\n \n bool CSubNet::Match(const CNetAddr &addr) const\n {\n     if (!valid || !addr.IsValid())\n         return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n+    for (size_t x = 0; x < addr.ip.size(); ++x) {\n+        if ((addr.ip[x] & netmask[x]) != network.ip[x]) {\n             return false;\n+        }\n+    }\n     return true;\n }\n \n-static inline int NetmaskBits(uint8_t x)\n+static inline int NetmaskBits(unsigned char x)\n {\n     switch(x) {\n     case 0x00: return 0; break;\n@@ -687,20 +700,23 @@ std::string CSubNet::ToString() const\n     /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n     int cidr = 0;\n     bool valid_cidr = true;\n-    int n = network.IsIPv4() ? 12 : 0;\n-    for (; n < 16 && netmask[n] == 0xff; ++n)\n+    size_t n = network.IsIPv4() ? IPV4_IP_PREFIX.size() : 0;\n+    for (; n < netmask.size() && netmask[n] == 0xff; ++n) {\n         cidr += 8;\n-    if (n < 16) {\n+    }\n+    if (n < netmask.size()) {\n         int bits = NetmaskBits(netmask[n]);\n         if (bits < 0)\n             valid_cidr = false;\n         else\n             cidr += bits;\n         ++n;\n     }\n-    for (; n < 16 && valid_cidr; ++n)\n-        if (netmask[n] != 0x00)\n+    for (; n < netmask.size() && valid_cidr; ++n) {\n+        if (netmask[n] != 0x00) {\n             valid_cidr = false;\n+        }\n+    }\n \n     /* Format output */\n     std::string strNetmask;\n@@ -727,7 +743,7 @@ bool CSubNet::IsValid() const\n \n bool operator==(const CSubNet& a, const CSubNet& b)\n {\n-    return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n+    return a.valid == b.valid && a.network == b.network && a.netmask == b.netmask;\n }\n \n bool operator!=(const CSubNet& a, const CSubNet& b)\n@@ -737,5 +753,5 @@ bool operator!=(const CSubNet& a, const CSubNet& b)\n \n bool operator<(const CSubNet& a, const CSubNet& b)\n {\n-    return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n+    return a.network < b.network || (a.network == b.network && a.netmask < b.netmask);\n }"
      },
      {
        "sha": "cab33a7d4be47fccfce1a9486cf23a328735f4c8",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d2af299df1fbe6521f8945033ab8e8704ea6840/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d2af299df1fbe6521f8945033ab8e8704ea6840/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=6d2af299df1fbe6521f8945033ab8e8704ea6840",
        "patch": "@@ -12,6 +12,7 @@\n #include \"compat.h\"\n #include \"serialize.h\"\n \n+#include <array>\n #include <stdint.h>\n #include <string>\n #include <vector>\n@@ -31,20 +32,20 @@ enum Network\n class CNetAddr\n {\n     protected:\n-        unsigned char ip[16]; // in network byte order\n+        std::array<unsigned char, 16> ip; // in network byte order\n         uint32_t scopeId; // for scoped/link-local ipv6 addresses\n \n     public:\n         CNetAddr();\n         explicit CNetAddr(const struct in_addr& ipv4Addr);\n         void Init();\n-        void SetIP(const CNetAddr& ip);\n+        void SetIP(CNetAddr ip);\n \n         /**\n          * Set raw IPv4 or IPv6 address (in network byte order)\n          */\n-        void SetRawIPv4(const unsigned char *data);\n-        void SetRawIPv6(const unsigned char *data);\n+        void SetRawIPv4(const std::array<unsigned char, 4>&);\n+        void SetRawIPv6(const std::array<unsigned char, 16>&);\n \n         /**\n           * Transform an arbitrary string into a non-routable ipv6 address.\n@@ -76,7 +77,7 @@ class CNetAddr\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;\n-        unsigned int GetByte(int n) const;\n+        unsigned int GetByte(unsigned int n) const;\n         uint64_t GetHash() const;\n         bool GetInAddr(struct in_addr* pipv4Addr) const;\n         std::vector<unsigned char> GetGroup() const;\n@@ -105,7 +106,7 @@ class CSubNet\n         /// Network (base) address\n         CNetAddr network;\n         /// Netmask, in network byte order\n-        uint8_t netmask[16];\n+        std::array<unsigned char, 16> netmask;\n         /// Is this value valid? (only used to signal parse errors)\n         bool valid;\n "
      }
    ]
  },
  {
    "sha": "e45306fa34b70a0a20eb8ca609c5d29b0ff7073c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDUzMDZmYTM0YjcwYTBhMjBlYjhjYTYwOWM1ZDI5YjBmZjcwNzNj",
    "commit": {
      "author": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-09-01T21:54:48Z"
      },
      "committer": {
        "name": "Dan Raviv",
        "email": "dan@soundradix.com",
        "date": "2017-09-08T19:37:43Z"
      },
      "message": "Misc style fixes according to Developer Notes",
      "tree": {
        "sha": "5d1ea4dda5e0ef7ccd9c812289bad83e23cd99a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5d1ea4dda5e0ef7ccd9c812289bad83e23cd99a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c/comments",
    "author": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "danra",
      "id": 84245,
      "node_id": "MDQ6VXNlcjg0MjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/84245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danra",
      "html_url": "https://github.com/danra",
      "followers_url": "https://api.github.com/users/danra/followers",
      "following_url": "https://api.github.com/users/danra/following{/other_user}",
      "gists_url": "https://api.github.com/users/danra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danra/subscriptions",
      "organizations_url": "https://api.github.com/users/danra/orgs",
      "repos_url": "https://api.github.com/users/danra/repos",
      "events_url": "https://api.github.com/users/danra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d2af299df1fbe6521f8945033ab8e8704ea6840",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2af299df1fbe6521f8945033ab8e8704ea6840",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d2af299df1fbe6521f8945033ab8e8704ea6840"
      }
    ],
    "stats": {
      "total": 172,
      "additions": 89,
      "deletions": 83
    },
    "files": [
      {
        "sha": "e19a72a3acc0e1ae35146c14a6a7b141eddbeb7a",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 83,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e45306fa34b70a0a20eb8ca609c5d29b0ff7073c/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e45306fa34b70a0a20eb8ca609c5d29b0ff7073c",
        "patch": "@@ -110,15 +110,15 @@ bool CNetAddr::IsIPv4() const\n \n bool CNetAddr::IsIPv6() const\n {\n-    return (!IsIPv4() && !IsTor() && !IsInternal());\n+    return !IsIPv4() && !IsTor() && !IsInternal();\n }\n \n bool CNetAddr::IsRFC1918() const\n {\n     return IsIPv4() && (\n         GetByte(3) == 10 ||\n         (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+        (GetByte(3) == 172 && GetByte(2) >= 16 && GetByte(2) <= 31));\n }\n \n bool CNetAddr::IsRFC2544() const\n@@ -128,7 +128,7 @@ bool CNetAddr::IsRFC2544() const\n \n bool CNetAddr::IsRFC3927() const\n {\n-    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+    return IsIPv4() && GetByte(3) == 169 && GetByte(2) == 254;\n }\n \n bool CNetAddr::IsRFC6598() const\n@@ -138,7 +138,8 @@ bool CNetAddr::IsRFC6598() const\n \n bool CNetAddr::IsRFC5737() const\n {\n-    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n+    return IsIPv4() && (\n+        (GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n         (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n         (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n }\n@@ -150,7 +151,7 @@ bool CNetAddr::IsRFC3849() const\n \n bool CNetAddr::IsRFC3964() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x02;\n }\n \n bool CNetAddr::IsRFC6052() const\n@@ -161,7 +162,7 @@ bool CNetAddr::IsRFC6052() const\n \n bool CNetAddr::IsRFC4380() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0;\n }\n \n bool CNetAddr::IsRFC4862() const\n@@ -172,7 +173,7 @@ bool CNetAddr::IsRFC4862() const\n \n bool CNetAddr::IsRFC4193() const\n {\n-    return ((GetByte(15) & 0xFE) == 0xFC);\n+    return (GetByte(15) & 0xFE) == 0xFC;\n }\n \n bool CNetAddr::IsRFC6145() const\n@@ -183,7 +184,7 @@ bool CNetAddr::IsRFC6145() const\n \n bool CNetAddr::IsRFC4843() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10;\n }\n \n bool CNetAddr::IsTor() const\n@@ -194,8 +195,9 @@ bool CNetAddr::IsTor() const\n bool CNetAddr::IsLocal() const\n {\n     // IPv4 loopback\n-   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0)) {\n        return true;\n+   }\n \n    // IPv6 loopback (::1/128)\n    static const std::array<unsigned char, 16> LOOPBACK_IP {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }};\n@@ -255,18 +257,10 @@ bool CNetAddr::IsInternal() const\n \n enum Network CNetAddr::GetNetwork() const\n {\n-    if (IsInternal())\n-        return NET_INTERNAL;\n-\n-    if (!IsRoutable())\n-        return NET_UNROUTABLE;\n-\n-    if (IsIPv4())\n-        return NET_IPV4;\n-\n-    if (IsTor())\n-        return NET_TOR;\n-\n+    if (IsInternal())   return NET_INTERNAL;\n+    if (!IsRoutable())  return NET_UNROUTABLE;\n+    if (IsIPv4())       return NET_IPV4;\n+    if (IsTor())        return NET_TOR;\n     return NET_IPV6;\n }\n \n@@ -275,25 +269,31 @@ std::string CNetAddr::ToStringIP() const\n     if (IsTor()) {\n         return EncodeBase32(ip.data() + ONION_IP_PREFIX.size(), ip.size() - ONION_IP_PREFIX.size()) + ONION_ADDRESS_SUFFIX;\n     }\n+\n     if (IsInternal()) {\n         return EncodeBase32(ip.data() + INTERNAL_IP_PREFIX.size(), ip.size() - INTERNAL_IP_PREFIX.size()) + \".internal\";\n     }\n-    CService serv(*this, 0);\n-    struct sockaddr_storage sockaddr;\n-    socklen_t socklen = sizeof(sockaddr);\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n-        char name[1025] = \"\";\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\n-            return std::string(name);\n+\n+    {\n+        CService serv(*this, 0);\n+        struct sockaddr_storage sockaddr;\n+        socklen_t socklen = sizeof(sockaddr);\n+        if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n+            char name[1025] = \"\";\n+            if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\n+                return std::string(name);\n+        }\n     }\n-    if (IsIPv4())\n+\n+    if (IsIPv4()) {\n         return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n-    else\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+    }\n+\n+    return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                     GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+                     GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+                     GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+                     GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n }\n \n std::string CNetAddr::ToString() const\n@@ -341,57 +341,52 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     int nBits = 16;\n \n     // all local addresses belong to the same group\n-    if (IsLocal())\n-    {\n+    if (IsLocal()) {\n         nClass = 255;\n         nBits = 0;\n     }\n     // all internal-usage addresses get their own group\n-    if (IsInternal())\n-    {\n+    if (IsInternal()) {\n         nClass = NET_INTERNAL;\n         nStartByte = INTERNAL_IP_PREFIX.size();\n         nBits = (ip.size() - INTERNAL_IP_PREFIX.size()) * 8;\n     }\n     // all other unroutable addresses belong to the same group\n-    else if (!IsRoutable())\n-    {\n+    else if (!IsRoutable()) {\n         nClass = NET_UNROUTABLE;\n         nBits = 0;\n     }\n     // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n     // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n-    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n-    {\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052()) {\n         nClass = NET_IPV4;\n         nStartByte = IPV4_IP_PREFIX.size();\n     }\n     // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n-    else if (IsRFC3964())\n-    {\n+    else if (IsRFC3964()) {\n         nClass = NET_IPV4;\n         nStartByte = 2;\n     }\n     // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n-    else if (IsRFC4380())\n-    {\n+    else if (IsRFC4380()) {\n         vchRet.push_back(NET_IPV4);\n         vchRet.push_back(GetByte(3) ^ 0xFF);\n         vchRet.push_back(GetByte(2) ^ 0xFF);\n         return vchRet;\n     }\n-    else if (IsTor())\n-    {\n+    else if (IsTor()) {\n         nClass = NET_TOR;\n         nStartByte = ONION_IP_PREFIX.size();\n         nBits = 4;\n     }\n     // for he.net, use /36 groups\n-    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70) {\n         nBits = 36;\n+    }\n     // for the rest of the IPv6 network, use /32 groups\n-    else\n+    else {\n         nBits = 32;\n+    }\n \n     vchRet.push_back(nClass);\n     while (nBits >= 8) {\n@@ -420,10 +415,8 @@ static const int NET_UNKNOWN = NET_MAX + 0;\n static const int NET_TEREDO  = NET_MAX + 1;\n int static GetExtNetwork(const CNetAddr *addr)\n {\n-    if (addr == nullptr)\n-        return NET_UNKNOWN;\n-    if (addr->IsRFC4380())\n-        return NET_TEREDO;\n+    if (addr == nullptr)    return NET_UNKNOWN;\n+    if (addr->IsRFC4380())  return NET_TEREDO;\n     return addr->GetNetwork();\n }\n \n@@ -440,8 +433,9 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n         REACH_PRIVATE\n     };\n \n-    if (!IsRoutable() || IsInternal())\n+    if (!IsRoutable() || IsInternal()) {\n         return REACH_UNREACHABLE;\n+    }\n \n     int ourNet = GetExtNetwork(this);\n     int theirNet = GetExtNetwork(paddrPartner);\n@@ -498,14 +492,17 @@ CService::CService()\n \n CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n {\n+    // Empty\n }\n \n CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n {\n+    // Empty\n }\n \n CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n {\n+    // Empty\n }\n \n CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n@@ -555,25 +552,29 @@ bool operator<(const CService& a, const CService& b)\n bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n {\n     if (IsIPv4()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in)) {\n             return false;\n+        }\n         *addrlen = sizeof(struct sockaddr_in);\n         auto *paddrin = reinterpret_cast<struct sockaddr_in*>(paddr);\n         memset(paddrin, 0, *addrlen);\n-        if (!GetInAddr(&paddrin->sin_addr))\n+        if (!GetInAddr(&paddrin->sin_addr)) {\n             return false;\n+        }\n         paddrin->sin_family = AF_INET;\n         paddrin->sin_port = htons(port);\n         return true;\n     }\n     if (IsIPv6()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6)) {\n             return false;\n+        }\n         *addrlen = sizeof(struct sockaddr_in6);\n         auto *paddrin6 = reinterpret_cast<struct sockaddr_in6*>(paddr);\n         memset(paddrin6, 0, *addrlen);\n-        if (!GetIn6Addr(&paddrin6->sin6_addr))\n+        if (!GetIn6Addr(&paddrin6->sin6_addr)) {\n             return false;\n+        }\n         paddrin6->sin6_scope_id = scopeId;\n         paddrin6->sin6_family = AF_INET6;\n         paddrin6->sin6_port = htons(port);\n@@ -601,9 +602,8 @@ std::string CService::ToStringIPPort() const\n {\n     if (IsIPv4() || IsTor() || IsInternal()) {\n         return ToStringIP() + \":\" + ToStringPort();\n-    } else {\n-        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n     }\n+    return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n }\n \n std::string CService::ToString() const\n@@ -629,14 +629,15 @@ CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n     const int astartofs = network.IsIPv4() ? 12 : 0;\n \n     int32_t n = mask;\n-    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n-    {\n+    if (n >= 0 && n <= (128 - astartofs*8)) { // Only valid if in range of bits of address\n         n += astartofs*8;\n         // Clear bits [n..127]\n-        for (; n < 128; ++n)\n+        for (; n < 128; ++n) {\n             netmask[n>>3] &= ~(1<<(7-(n&7)));\n-    } else\n+        }\n+    } else {\n         valid = false;\n+    }\n \n     // Normalize network according to netmask\n     std::transform(network.ip.begin(), network.ip.end(), netmask.begin(), network.ip.begin(),\n@@ -660,17 +661,18 @@ CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n         [](unsigned char ip_byte, unsigned char mask_byte) { return ip_byte & mask_byte; });\n }\n \n-CSubNet::CSubNet(const CNetAddr &addr):\n-    valid(addr.IsValid())\n+CSubNet::CSubNet(const CNetAddr &addr)\n+: valid(addr.IsValid())\n {\n     std::fill(netmask.begin(), netmask.end(), 255);\n     network = addr;\n }\n \n bool CSubNet::Match(const CNetAddr &addr) const\n {\n-    if (!valid || !addr.IsValid())\n+    if (!valid || !addr.IsValid()) {\n         return false;\n+    }\n     for (size_t x = 0; x < addr.ip.size(); ++x) {\n         if ((addr.ip[x] & netmask[x]) != network.ip[x]) {\n             return false;\n@@ -682,16 +684,16 @@ bool CSubNet::Match(const CNetAddr &addr) const\n static inline int NetmaskBits(unsigned char x)\n {\n     switch(x) {\n-    case 0x00: return 0; break;\n-    case 0x80: return 1; break;\n-    case 0xc0: return 2; break;\n-    case 0xe0: return 3; break;\n-    case 0xf0: return 4; break;\n-    case 0xf8: return 5; break;\n-    case 0xfc: return 6; break;\n-    case 0xfe: return 7; break;\n-    case 0xff: return 8; break;\n-    default: return -1; break;\n+    case 0x00: return 0;\n+    case 0x80: return 1;\n+    case 0xc0: return 2;\n+    case 0xe0: return 3;\n+    case 0xf0: return 4;\n+    case 0xf8: return 5;\n+    case 0xfc: return 6;\n+    case 0xfe: return 7;\n+    case 0xff: return 8;\n+    default: return -1;\n     }\n }\n \n@@ -706,10 +708,12 @@ std::string CSubNet::ToString() const\n     }\n     if (n < netmask.size()) {\n         int bits = NetmaskBits(netmask[n]);\n-        if (bits < 0)\n+        if (bits < 0) {\n             valid_cidr = false;\n-        else\n+        }\n+        else {\n             cidr += bits;\n+        }\n         ++n;\n     }\n     for (; n < netmask.size() && valid_cidr; ++n) {\n@@ -723,14 +727,16 @@ std::string CSubNet::ToString() const\n     if (valid_cidr) {\n         strNetmask = strprintf(\"%u\", cidr);\n     } else {\n-        if (network.IsIPv4())\n+        if (network.IsIPv4()) {\n             strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n-        else\n+        }\n+        else {\n             strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                              netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n                              netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n                              netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n                              netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+        }\n     }\n \n     return network.ToString() + \"/\" + strNetmask;"
      }
    ]
  }
]