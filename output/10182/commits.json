[
  {
    "sha": "8d09e96151a73be25605d687c9ddb06379407e46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZDA5ZTk2MTUxYTczYmUyNTYwNWQ2ODdjOWRkYjA2Mzc5NDA3ZTQ2",
    "commit": {
      "author": {
        "name": "Thomas Snider",
        "email": "tjps636@gmail.com",
        "date": "2017-04-11T06:25:25Z"
      },
      "committer": {
        "name": "Thomas Snider",
        "email": "tjps636@gmail.com",
        "date": "2017-04-11T07:50:27Z"
      },
      "message": "[scheduler] Switched CScheduler to C++11 threading primitives",
      "tree": {
        "sha": "9a2acbf904a93357f2dd2f72cdb75dd12a5a6a09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a2acbf904a93357f2dd2f72cdb75dd12a5a6a09"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d09e96151a73be25605d687c9ddb06379407e46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d09e96151a73be25605d687c9ddb06379407e46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8d09e96151a73be25605d687c9ddb06379407e46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d09e96151a73be25605d687c9ddb06379407e46/comments",
    "author": {
      "login": "tjps",
      "id": 7519582,
      "node_id": "MDQ6VXNlcjc1MTk1ODI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7519582?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tjps",
      "html_url": "https://github.com/tjps",
      "followers_url": "https://api.github.com/users/tjps/followers",
      "following_url": "https://api.github.com/users/tjps/following{/other_user}",
      "gists_url": "https://api.github.com/users/tjps/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tjps/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tjps/subscriptions",
      "organizations_url": "https://api.github.com/users/tjps/orgs",
      "repos_url": "https://api.github.com/users/tjps/repos",
      "events_url": "https://api.github.com/users/tjps/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tjps/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "tjps",
      "id": 7519582,
      "node_id": "MDQ6VXNlcjc1MTk1ODI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7519582?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tjps",
      "html_url": "https://github.com/tjps",
      "followers_url": "https://api.github.com/users/tjps/followers",
      "following_url": "https://api.github.com/users/tjps/following{/other_user}",
      "gists_url": "https://api.github.com/users/tjps/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tjps/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tjps/subscriptions",
      "organizations_url": "https://api.github.com/users/tjps/orgs",
      "repos_url": "https://api.github.com/users/tjps/repos",
      "events_url": "https://api.github.com/users/tjps/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tjps/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67023e9004ba843218bee16bc821e955faf0d394",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67023e9004ba843218bee16bc821e955faf0d394",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67023e9004ba843218bee16bc821e955faf0d394"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 68,
      "deletions": 85
    },
    "files": [
      {
        "sha": "05b7c1cc2e49d5ccf6a575c70a94c7d9fe58cd65",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d09e96151a73be25605d687c9ddb06379407e46/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d09e96151a73be25605d687c9ddb06379407e46/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8d09e96151a73be25605d687c9ddb06379407e46",
        "patch": "@@ -35,6 +35,7 @@\n \n #include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n+#include <boost/thread.hpp>\n \n class CAddrMan;\n class CScheduler;"
      },
      {
        "sha": "b4c655c786139189ca74bade9584dd6c93fc823c",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 36,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d09e96151a73be25605d687c9ddb06379407e46/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d09e96151a73be25605d687c9ddb06379407e46/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=8d09e96151a73be25605d687c9ddb06379407e46",
        "patch": "@@ -7,8 +7,6 @@\n #include \"reverselock.h\"\n \n #include <assert.h>\n-#include <boost/bind.hpp>\n-#include <utility>\n \n CScheduler::CScheduler() : nThreadsServicingQueue(0), stopRequested(false), stopWhenEmpty(false)\n {\n@@ -17,21 +15,14 @@ CScheduler::CScheduler() : nThreadsServicingQueue(0), stopRequested(false), stop\n CScheduler::~CScheduler()\n {\n     assert(nThreadsServicingQueue == 0);\n+    if (stopWhenEmpty) {\n+        assert(taskQueue.empty());\n+    }\n }\n \n-\n-#if BOOST_VERSION < 105000\n-static boost::system_time toPosixTime(const boost::chrono::system_clock::time_point& t)\n-{\n-    // Creating the posix_time using from_time_t loses sub-second precision. So rather than exporting the time_point to time_t,\n-    // start with a posix_time at the epoch (0) and add the milliseconds that have passed since then.\n-    return boost::posix_time::from_time_t(0) + boost::posix_time::milliseconds(boost::chrono::duration_cast<boost::chrono::milliseconds>(t.time_since_epoch()).count());\n-}\n-#endif\n-\n void CScheduler::serviceQueue()\n {\n-    boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+    std::unique_lock<std::mutex> lock(newTaskMutex);\n     ++nThreadsServicingQueue;\n \n     // newTaskMutex is locked throughout this loop EXCEPT\n@@ -46,22 +37,11 @@ void CScheduler::serviceQueue()\n \n             // Wait until either there is a new task, or until\n             // the time of the first item on the queue:\n-\n-// wait_until needs boost 1.50 or later; older versions have timed_wait:\n-#if BOOST_VERSION < 105000\n-            while (!shouldStop() && !taskQueue.empty() &&\n-                   newTaskScheduled.timed_wait(lock, toPosixTime(taskQueue.begin()->first))) {\n-                // Keep waiting until timeout\n-            }\n-#else\n-            // Some boost versions have a conflicting overload of wait_until that returns void.\n-            // Explicitly use a template here to avoid hitting that overload.\n             while (!shouldStop() && !taskQueue.empty()) {\n-                boost::chrono::system_clock::time_point timeToWaitFor = taskQueue.begin()->first;\n-                if (newTaskScheduled.wait_until<>(lock, timeToWaitFor) == boost::cv_status::timeout)\n+                std::chrono::system_clock::time_point timeToWaitFor = taskQueue.begin()->first;\n+                if (newTaskScheduled.wait_until(lock, timeToWaitFor) == std::cv_status::timeout)\n                     break; // Exit loop after timeout, it means we reached the time of the event\n             }\n-#endif\n             // If there are multiple threads, the queue can empty while we're waiting (another\n             // thread may service the task we were waiting on).\n             if (shouldStop() || taskQueue.empty())\n@@ -73,7 +53,7 @@ void CScheduler::serviceQueue()\n             {\n                 // Unlock before calling f, so it can reschedule itself or another task\n                 // without deadlocking:\n-                reverse_lock<boost::unique_lock<boost::mutex> > rlock(lock);\n+                reverse_lock<std::unique_lock<std::mutex> > rlock(lock);\n                 f();\n             }\n         } catch (...) {\n@@ -88,7 +68,7 @@ void CScheduler::serviceQueue()\n void CScheduler::stop(bool drain)\n {\n     {\n-        boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+        std::unique_lock<std::mutex> lock(newTaskMutex);\n         if (drain)\n             stopWhenEmpty = true;\n         else\n@@ -97,35 +77,35 @@ void CScheduler::stop(bool drain)\n     newTaskScheduled.notify_all();\n }\n \n-void CScheduler::schedule(CScheduler::Function f, boost::chrono::system_clock::time_point t)\n+void CScheduler::schedule(CScheduler::Function f, std::chrono::system_clock::time_point t)\n {\n     {\n-        boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+        std::unique_lock<std::mutex> lock(newTaskMutex);\n         taskQueue.insert(std::make_pair(t, f));\n     }\n     newTaskScheduled.notify_one();\n }\n \n void CScheduler::scheduleFromNow(CScheduler::Function f, int64_t deltaMilliSeconds)\n {\n-    schedule(f, boost::chrono::system_clock::now() + boost::chrono::milliseconds(deltaMilliSeconds));\n+    schedule(f, std::chrono::system_clock::now() + std::chrono::milliseconds(deltaMilliSeconds));\n }\n \n static void Repeat(CScheduler* s, CScheduler::Function f, int64_t deltaMilliSeconds)\n {\n     f();\n-    s->scheduleFromNow(boost::bind(&Repeat, s, f, deltaMilliSeconds), deltaMilliSeconds);\n+    s->scheduleFromNow(std::bind(&Repeat, s, f, deltaMilliSeconds), deltaMilliSeconds);\n }\n \n void CScheduler::scheduleEvery(CScheduler::Function f, int64_t deltaMilliSeconds)\n {\n-    scheduleFromNow(boost::bind(&Repeat, this, f, deltaMilliSeconds), deltaMilliSeconds);\n+    scheduleFromNow(std::bind(&Repeat, this, f, deltaMilliSeconds), deltaMilliSeconds);\n }\n \n-size_t CScheduler::getQueueInfo(boost::chrono::system_clock::time_point &first,\n-                             boost::chrono::system_clock::time_point &last) const\n+size_t CScheduler::getQueueInfo(std::chrono::system_clock::time_point &first,\n+                                std::chrono::system_clock::time_point &last) const\n {\n-    boost::unique_lock<boost::mutex> lock(newTaskMutex);\n+    std::unique_lock<std::mutex> lock(newTaskMutex);\n     size_t result = taskQueue.size();\n     if (!taskQueue.empty()) {\n         first = taskQueue.begin()->first;"
      },
      {
        "sha": "5bd717d3bde3587c972fdb09fc05bfb446ba7d7f",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 27,
        "deletions": 28,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d09e96151a73be25605d687c9ddb06379407e46/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d09e96151a73be25605d687c9ddb06379407e46/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=8d09e96151a73be25605d687c9ddb06379407e46",
        "patch": "@@ -5,31 +5,31 @@\n #ifndef BITCOIN_SCHEDULER_H\n #define BITCOIN_SCHEDULER_H\n \n-//\n-// NOTE:\n-// boost::thread / boost::function / boost::chrono should be ported to\n-// std::thread / std::function / std::chrono when we support C++11.\n-//\n-#include <boost/chrono/chrono.hpp>\n-#include <boost/thread.hpp>\n+#include <condition_variable>\n+#include <chrono>\n+#include <functional>\n #include <map>\n+#include <mutex>\n \n //\n // Simple class for background tasks that should be run\n // periodically or once \"after a while\"\n //\n // Usage:\n //\n-// CScheduler* s = new CScheduler();\n-// s->scheduleFromNow(doSomething, 11); // Assuming a: void doSomething() { }\n-// s->scheduleFromNow(std::bind(Class::func, this, argument), 3);\n-// boost::thread* t = new boost::thread(boost::bind(CScheduler::serviceQueue, s));\n+//   CScheduler s;\n+//   s.scheduleFromNow(doSomething, 11); // Assuming a: void doSomething() { }\n+//   s.scheduleFromNow(std::bind(Class::func, this, argument), 3);\n+//   std::thread* t = new std::thread(std::bind(CScheduler::serviceQueue, &s));\n+//\n+// then at program shutdown, stop the scheduler (optionally draining the queue):\n+//\n+//   s.stop(/*drain?*/);\n+//\n+// and join the queue servicing thread:\n //\n-// ... then at program shutdown, clean up the thread running serviceQueue:\n-// t->interrupt();\n-// t->join();\n-// delete t;\n-// delete s; // Must be done after thread is interrupted/joined.\n+//   t->join();\n+//   delete t;\n //\n \n class CScheduler\n@@ -41,22 +41,21 @@ class CScheduler\n     typedef std::function<void(void)> Function;\n \n     // Call func at/after time t\n-    void schedule(Function f, boost::chrono::system_clock::time_point t);\n+    void schedule(Function f, std::chrono::system_clock::time_point t);\n \n-    // Convenience method: call f once deltaSeconds from now\n+    // Convenience method: call f once deltaMilliSeconds from now\n     void scheduleFromNow(Function f, int64_t deltaMilliSeconds);\n \n     // Another convenience method: call f approximately\n-    // every deltaSeconds forever, starting deltaSeconds from now.\n+    // every deltaMilliSeconds forever, starting deltaMilliSeconds from now.\n     // To be more precise: every time f is finished, it\n-    // is rescheduled to run deltaSeconds later. If you\n+    // is rescheduled to run deltaMilliSeconds later. If you\n     // need more accurate scheduling, don't use this method.\n     void scheduleEvery(Function f, int64_t deltaMilliSeconds);\n \n     // To keep things as simple as possible, there is no unschedule.\n \n-    // Services the queue 'forever'. Should be run in a thread,\n-    // and interrupted using boost::interrupt_thread\n+    // Service items in the queue until stop() is called.\n     void serviceQueue();\n \n     // Tell any threads running serviceQueue to stop as soon as they're\n@@ -66,17 +65,17 @@ class CScheduler\n \n     // Returns number of tasks waiting to be serviced,\n     // and first and last task times\n-    size_t getQueueInfo(boost::chrono::system_clock::time_point &first,\n-                        boost::chrono::system_clock::time_point &last) const;\n+    size_t getQueueInfo(std::chrono::system_clock::time_point &first,\n+                        std::chrono::system_clock::time_point &last) const;\n \n private:\n-    std::multimap<boost::chrono::system_clock::time_point, Function> taskQueue;\n-    boost::condition_variable newTaskScheduled;\n-    mutable boost::mutex newTaskMutex;\n+    std::multimap<std::chrono::system_clock::time_point, Function> taskQueue;\n+    std::condition_variable newTaskScheduled;\n+    mutable std::mutex newTaskMutex;\n     int nThreadsServicingQueue;\n     bool stopRequested;\n     bool stopWhenEmpty;\n-    bool shouldStop() { return stopRequested || (stopWhenEmpty && taskQueue.empty()); }\n+    bool shouldStop() const { return stopRequested || (stopWhenEmpty && taskQueue.empty()); }\n };\n \n #endif"
      },
      {
        "sha": "35be5480dba35f95f1932e14d7758ed06ce7f987",
        "filename": "src/test/scheduler_tests.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 21,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d09e96151a73be25605d687c9ddb06379407e46/src/test/scheduler_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d09e96151a73be25605d687c9ddb06379407e46/src/test/scheduler_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scheduler_tests.cpp?ref=8d09e96151a73be25605d687c9ddb06379407e46",
        "patch": "@@ -7,23 +7,24 @@\n \n #include \"test/test_bitcoin.h\"\n \n-#include <boost/bind.hpp>\n+#include <vector>\n+\n #include <boost/random/mersenne_twister.hpp>\n #include <boost/random/uniform_int_distribution.hpp>\n #include <boost/thread.hpp>\n #include <boost/test/unit_test.hpp>\n \n BOOST_AUTO_TEST_SUITE(scheduler_tests)\n \n-static void microTask(CScheduler& s, boost::mutex& mutex, int& counter, int delta, boost::chrono::system_clock::time_point rescheduleTime)\n+static void microTask(CScheduler& s, std::mutex& mutex, int& counter, int delta, std::chrono::system_clock::time_point rescheduleTime)\n {\n     {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n+        std::unique_lock<std::mutex> lock(mutex);\n         counter += delta;\n     }\n-    boost::chrono::system_clock::time_point noTime = boost::chrono::system_clock::time_point::min();\n+    std::chrono::system_clock::time_point noTime = std::chrono::system_clock::time_point::min();\n     if (rescheduleTime != noTime) {\n-        CScheduler::Function f = boost::bind(&microTask, boost::ref(s), boost::ref(mutex), boost::ref(counter), -delta + 1, noTime);\n+        CScheduler::Function f = std::bind(&microTask, std::ref(s), std::ref(mutex), std::ref(counter), -delta + 1, noTime);\n         s.schedule(f, rescheduleTime);\n     }\n }\n@@ -54,25 +55,25 @@ BOOST_AUTO_TEST_CASE(manythreads)\n     // counters should sum to the number of initial tasks performed.\n     CScheduler microTasks;\n \n-    boost::mutex counterMutex[10];\n+    std::mutex counterMutex[10];\n     int counter[10] = { 0 };\n     boost::random::mt19937 rng(42);\n     boost::random::uniform_int_distribution<> zeroToNine(0, 9);\n     boost::random::uniform_int_distribution<> randomMsec(-11, 1000);\n     boost::random::uniform_int_distribution<> randomDelta(-1000, 1000);\n \n-    boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();\n-    boost::chrono::system_clock::time_point now = start;\n-    boost::chrono::system_clock::time_point first, last;\n+    std::chrono::system_clock::time_point start = std::chrono::system_clock::now();\n+    std::chrono::system_clock::time_point now = start;\n+    std::chrono::system_clock::time_point first, last;\n     size_t nTasks = microTasks.getQueueInfo(first, last);\n     BOOST_CHECK(nTasks == 0);\n \n     for (int i = 0; i < 100; i++) {\n-        boost::chrono::system_clock::time_point t = now + boost::chrono::microseconds(randomMsec(rng));\n-        boost::chrono::system_clock::time_point tReschedule = now + boost::chrono::microseconds(500 + randomMsec(rng));\n+        std::chrono::system_clock::time_point t = now + std::chrono::microseconds(randomMsec(rng));\n+        std::chrono::system_clock::time_point tReschedule = now + std::chrono::microseconds(500 + randomMsec(rng));\n         int whichCounter = zeroToNine(rng);\n-        CScheduler::Function f = boost::bind(&microTask, boost::ref(microTasks),\n-                                             boost::ref(counterMutex[whichCounter]), boost::ref(counter[whichCounter]),\n+        CScheduler::Function f = std::bind(&microTask, std::ref(microTasks),\n+                                             std::ref(counterMutex[whichCounter]), std::ref(counter[whichCounter]),\n                                              randomDelta(rng), tReschedule);\n         microTasks.schedule(f, t);\n     }\n@@ -84,21 +85,21 @@ BOOST_AUTO_TEST_CASE(manythreads)\n     // As soon as these are created they will start running and servicing the queue\n     boost::thread_group microThreads;\n     for (int i = 0; i < 5; i++)\n-        microThreads.create_thread(boost::bind(&CScheduler::serviceQueue, &microTasks));\n+        microThreads.create_thread(std::bind(&CScheduler::serviceQueue, &microTasks));\n \n     MicroSleep(600);\n-    now = boost::chrono::system_clock::now();\n+    now = std::chrono::system_clock::now();\n \n     // More threads and more tasks:\n     for (int i = 0; i < 5; i++)\n-        microThreads.create_thread(boost::bind(&CScheduler::serviceQueue, &microTasks));\n+        microThreads.create_thread(std::bind(&CScheduler::serviceQueue, &microTasks));\n     for (int i = 0; i < 100; i++) {\n-        boost::chrono::system_clock::time_point t = now + boost::chrono::microseconds(randomMsec(rng));\n-        boost::chrono::system_clock::time_point tReschedule = now + boost::chrono::microseconds(500 + randomMsec(rng));\n+        std::chrono::system_clock::time_point t = now + std::chrono::microseconds(randomMsec(rng));\n+        std::chrono::system_clock::time_point tReschedule = now + std::chrono::microseconds(500 + randomMsec(rng));\n         int whichCounter = zeroToNine(rng);\n-        CScheduler::Function f = boost::bind(&microTask, boost::ref(microTasks),\n-                                             boost::ref(counterMutex[whichCounter]), boost::ref(counter[whichCounter]),\n-                                             randomDelta(rng), tReschedule);\n+        CScheduler::Function f = std::bind(&microTask, std::ref(microTasks),\n+                                           std::ref(counterMutex[whichCounter]), std::ref(counter[whichCounter]),\n+                                           randomDelta(rng), tReschedule);\n         microTasks.schedule(f, t);\n     }\n "
      },
      {
        "sha": "80ef013dcda94228fab9ba4856c5ed3a7ebf3005",
        "filename": "src/torcontrol.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d09e96151a73be25605d687c9ddb06379407e46/src/torcontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d09e96151a73be25605d687c9ddb06379407e46/src/torcontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.h?ref=8d09e96151a73be25605d687c9ddb06379407e46",
        "patch": "@@ -10,6 +10,8 @@\n \n #include \"scheduler.h\"\n \n+#include <boost/thread.hpp>\n+\n extern const std::string DEFAULT_TOR_CONTROL;\n static const bool DEFAULT_LISTEN_ONION = true;\n "
      }
    ]
  }
]