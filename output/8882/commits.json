[
  {
    "sha": "6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OTc2ZGIyZjQ2ODdkNTc1ZTFiNGJlZTVhYWYxZDkzYTc5NGYyM2Mz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-10-04T19:17:19Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-10-04T19:17:19Z"
      },
      "message": "[qa] Another attempt to fix race condition in p2p-compactblocks.py\n\nsync_with_ping() only guarantees that the node has processed messages\nit's received from the peer, not that block announcements from the node have\nmade it back to the peer.  Replace sync_with_ping() with an explicit check that\nthe node's tip has been announced.",
      "tree": {
        "sha": "02d59847d8ce037294e08aaf1e654dc8bf6fce0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02d59847d8ce037294e08aaf1e654dc8bf6fce0d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6976db2f4687d575e1b4bee5aaf1d93a794f23c3/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a7e5cbb209d4aeb8c2e4c58c92bf214759998056",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7e5cbb209d4aeb8c2e4c58c92bf214759998056",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a7e5cbb209d4aeb8c2e4c58c92bf214759998056"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 22,
      "deletions": 2
    },
    "files": [
      {
        "sha": "cd680437696a6b3e5be70703ce652dc7b83a9d98",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 22,
        "deletions": 2,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6976db2f4687d575e1b4bee5aaf1d93a794f23c3/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6976db2f4687d575e1b4bee5aaf1d93a794f23c3/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
        "patch": "@@ -28,6 +28,10 @@ def __init__(self):\n         self.last_getblocktxn = None\n         self.last_block = None\n         self.last_blocktxn = None\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.set_announced_blockhashes = set()\n \n     def on_sendcmpct(self, conn, message):\n         self.last_sendcmpct = message\n@@ -38,14 +42,22 @@ def on_block(self, conn, message):\n     def on_cmpctblock(self, conn, message):\n         self.last_cmpctblock = message\n         self.block_announced = True\n+        self.last_cmpctblock.header_and_shortids.header.calc_sha256()\n+        self.set_announced_blockhashes.add(self.last_cmpctblock.header_and_shortids.header.sha256)\n \n     def on_headers(self, conn, message):\n         self.last_headers = message\n         self.block_announced = True\n+        for x in self.last_headers.headers:\n+            x.calc_sha256()\n+            self.set_announced_blockhashes.add(x.sha256)\n \n     def on_inv(self, conn, message):\n         self.last_inv = message\n-        self.block_announced = True\n+        for x in self.last_inv.inv:\n+            if x.type == 2:\n+                self.block_announced = True\n+                self.set_announced_blockhashes.add(x.hash)\n \n     def on_getdata(self, conn, message):\n         self.last_getdata = message\n@@ -85,6 +97,12 @@ def request_headers_and_sync(self, locator, hashstop=0):\n         assert(self.received_block_announcement())\n         self.clear_block_announcement()\n \n+    # Block until a block announcement for a particular block hash is\n+    # received.\n+    def wait_for_block_announcement(self, block_hash, timeout=30):\n+        def received_hash():\n+            return (block_hash in self.set_announced_blockhashes)\n+        return wait_until(received_hash, timeout=timeout)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -237,7 +255,9 @@ def test_compactblock_construction(self):\n         for i in range(num_transactions):\n             self.nodes[0].sendtoaddress(address, 0.1)\n \n-        self.test_node.sync_with_ping()\n+        # Wait until we've seen the block announcement for the resulting tip\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+        assert(self.test_node.wait_for_block_announcement(tip))\n \n         # Now mine a block, and look at the resulting compact block.\n         self.test_node.clear_block_announcement()"
      }
    ]
  },
  {
    "sha": "b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTVkOTQxMWU3ZTFhYTM2ZGRhYmJhM2I5NDJmMmUxYzczNmMxYmQ5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-10-06T18:21:11Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-10-06T18:21:11Z"
      },
      "message": "[qa] Fix race condition in sendheaders.py\n\nAlso de-duplicates code that has been moved to mininode",
      "tree": {
        "sha": "2ee99777cf59821acc804491a08cbd69d8f47076",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ee99777cf59821acc804491a08cbd69d8f47076"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6976db2f4687d575e1b4bee5aaf1d93a794f23c3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6976db2f4687d575e1b4bee5aaf1d93a794f23c3"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 26,
      "deletions": 42
    },
    "files": [
      {
        "sha": "81b2442e6ae6713ca6aa7f65099460d76a0f15c3",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "modified",
        "additions": 26,
        "deletions": 42,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=b55d9411e7e1aa36ddabba3b942f2e1c736c1bd9",
        "patch": "@@ -80,30 +80,26 @@\n    Expect: disconnect.\n '''\n \n-class BaseNode(NodeConnCB):\n+direct_fetch_response_time = 0.05\n+\n+class BaseNode(SingleNodeConnCB):\n     def __init__(self):\n-        NodeConnCB.__init__(self)\n-        self.connection = None\n+        SingleNodeConnCB.__init__(self)\n         self.last_inv = None\n         self.last_headers = None\n         self.last_block = None\n-        self.ping_counter = 1\n-        self.last_pong = msg_pong(0)\n         self.last_getdata = None\n-        self.sleep_time = 0.05\n         self.block_announced = False\n         self.last_getheaders = None\n         self.disconnected = False\n+        self.last_blockhash_announced = None\n \n     def clear_last_announcement(self):\n         with mininode_lock:\n             self.block_announced = False\n             self.last_inv = None\n             self.last_headers = None\n \n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n     # Request data for a list of block hashes\n     def get_data(self, block_hashes):\n         msg = msg_getdata()\n@@ -122,17 +118,17 @@ def send_block_inv(self, blockhash):\n         msg.inv = [CInv(2, blockhash)]\n         self.connection.send_message(msg)\n \n-    # Wrapper for the NodeConn's send_message function\n-    def send_message(self, message):\n-        self.connection.send_message(message)\n-\n     def on_inv(self, conn, message):\n         self.last_inv = message\n         self.block_announced = True\n+        self.last_blockhash_announced = message.inv[-1].hash\n \n     def on_headers(self, conn, message):\n         self.last_headers = message\n-        self.block_announced = True\n+        if len(message.headers):\n+            self.block_announced = True\n+            message.headers[-1].calc_sha256()\n+            self.last_blockhash_announced = message.headers[-1].sha256\n \n     def on_block(self, conn, message):\n         self.last_block = message.block\n@@ -141,9 +137,6 @@ def on_block(self, conn, message):\n     def on_getdata(self, conn, message):\n         self.last_getdata = message\n \n-    def on_pong(self, conn, message):\n-        self.last_pong = message\n-\n     def on_getheaders(self, conn, message):\n         self.last_getheaders = message\n \n@@ -157,7 +150,7 @@ def check_last_announcement(self, headers=None, inv=None):\n         expect_headers = headers if headers != None else []\n         expect_inv = inv if inv != None else []\n         test_function = lambda: self.block_announced\n-        self.sync(test_function)\n+        assert(wait_until(test_function, timeout=60))\n         with mininode_lock:\n             self.block_announced = False\n \n@@ -180,43 +173,32 @@ def check_last_announcement(self, headers=None, inv=None):\n         return success\n \n     # Syncing helpers\n-    def sync(self, test_function, timeout=60):\n-        while timeout > 0:\n-            with mininode_lock:\n-                if test_function():\n-                    return\n-            time.sleep(self.sleep_time)\n-            timeout -= self.sleep_time\n-        raise AssertionError(\"Sync failed to complete\")\n-        \n-    def sync_with_ping(self, timeout=60):\n-        self.send_message(msg_ping(nonce=self.ping_counter))\n-        test_function = lambda: self.last_pong.nonce == self.ping_counter\n-        self.sync(test_function, timeout)\n-        self.ping_counter += 1\n-        return\n-\n     def wait_for_block(self, blockhash, timeout=60):\n         test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n-        self.sync(test_function, timeout)\n+        assert(wait_until(test_function, timeout=timeout))\n         return\n \n     def wait_for_getheaders(self, timeout=60):\n         test_function = lambda: self.last_getheaders != None\n-        self.sync(test_function, timeout)\n+        assert(wait_until(test_function, timeout=timeout))\n         return\n \n     def wait_for_getdata(self, hash_list, timeout=60):\n         if hash_list == []:\n             return\n \n         test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n-        self.sync(test_function, timeout)\n+        assert(wait_until(test_function, timeout=timeout))\n         return\n \n     def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: self.disconnected\n-        self.sync(test_function, timeout)\n+        assert(wait_until(test_function, timeout=timeout))\n+        return\n+\n+    def wait_for_block_announcement(self, block_hash, timeout=60):\n+        test_function = lambda: self.last_blockhash_announced == block_hash\n+        assert(wait_until(test_function, timeout=timeout))\n         return\n \n     def send_header_for_blocks(self, new_blocks):\n@@ -266,7 +248,9 @@ def mine_blocks(self, count):\n     def mine_reorg(self, length):\n         self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n         sync_blocks(self.nodes, wait=0.1)\n-        [x.clear_last_announcement() for x in self.p2p_connections]\n+        for x in self.p2p_connections:\n+            x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n+            x.clear_last_announcement()\n \n         tip_height = self.nodes[1].getblockcount()\n         hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n@@ -495,7 +479,7 @@ def run_test(self):\n \n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=test_node.sleep_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=direct_fetch_response_time)\n \n         [ test_node.send_message(msg_block(x)) for x in blocks ]\n \n@@ -526,13 +510,13 @@ def run_test(self):\n         # both blocks (same work as tip)\n         test_node.send_header_for_blocks(blocks[1:2])\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks[0:2]], timeout=test_node.sleep_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[0:2]], timeout=direct_fetch_response_time)\n \n         # Announcing 16 more headers should trigger direct fetch for 14 more\n         # blocks\n         test_node.send_header_for_blocks(blocks[2:18])\n         test_node.sync_with_ping()\n-        test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=test_node.sleep_time)\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=direct_fetch_response_time)\n \n         # Announcing 1 more header should not trigger any response\n         test_node.last_getdata = None"
      }
    ]
  }
]