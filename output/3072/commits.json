[
  {
    "sha": "f0bc89e011eda6620ec091523773c82d09398c82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMGJjODllMDExZWRhNjYyMGVjMDkxNTIzNzczYzgyZDA5Mzk4Yzgy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2013-10-09T07:33:02Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2013-10-11T12:12:47Z"
      },
      "message": "Add separate bitcoin-rpc client\n\nThis adds an executable `bitcoin-rpc` that only serves as a Bitcoin RPC\nclient.\nThe commit does not remove RPC functionality from the `bitcoind` yet,\nthis functionality should be deprecated but is left for a later version\nto give users some time to switch.",
      "tree": {
        "sha": "1865c215cb521d48acb62410fa430153d731c113",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1865c215cb521d48acb62410fa430153d731c113"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0bc89e011eda6620ec091523773c82d09398c82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0bc89e011eda6620ec091523773c82d09398c82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f0bc89e011eda6620ec091523773c82d09398c82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0bc89e011eda6620ec091523773c82d09398c82/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56c0ba7a0f893c71eb871b95f36c18e37407bf00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c0ba7a0f893c71eb871b95f36c18e37407bf00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56c0ba7a0f893c71eb871b95f36c18e37407bf00"
      }
    ],
    "stats": {
      "total": 1552,
      "additions": 863,
      "deletions": 689
    },
    "files": [
      {
        "sha": "45722cffc45ef317d36cdc617fb6d0570ac16643",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -5,6 +5,7 @@ src/*.exe\n src/*/*.exe\n src/bitcoin\n src/bitcoind\n+src/bitcoin-rpc\n src/test/test_bitcoin\n src/qt/test/test_bitcoin-qt\n "
      },
      {
        "sha": "0959831881f59fa94bce75ca3a57d5714c58d460",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 15,
        "deletions": 4,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -6,7 +6,7 @@ AM_LDFLAGS = $(PTHREAD_CFLAGS)\n \n noinst_LIBRARIES = libbitcoin.a\n \n-bin_PROGRAMS = bitcoind\n+bin_PROGRAMS = bitcoind bitcoin-rpc\n \n SUBDIRS = . $(BUILD_QT) $(BUILD_TEST)\n DIST_SUBDIRS = . qt test\n@@ -31,11 +31,11 @@ obj/build.h: FORCE\n \t  $(abs_top_srcdir)\n version.o: obj/build.h\n \n-libbitcoin_a_SOURCES = addrman.cpp alert.cpp allocators.cpp bitcoinrpc.cpp bloom.cpp \\\n+libbitcoin_a_SOURCES = addrman.cpp alert.cpp allocators.cpp bloom.cpp \\\n   chainparams.cpp checkpoints.cpp core.cpp crypter.cpp db.cpp hash.cpp \\\n   init.cpp key.cpp keystore.cpp leveldb.cpp main.cpp miner.cpp \\\n-  netbase.cpp net.cpp noui.cpp protocol.cpp rpcblockchain.cpp rpcdump.cpp \\\n-  rpcmining.cpp rpcnet.cpp rpcrawtransaction.cpp rpcwallet.cpp script.cpp \\\n+  netbase.cpp net.cpp noui.cpp protocol.cpp rpcblockchain.cpp rpcclient.cpp rpcdump.cpp \\\n+  rpcmining.cpp rpcnet.cpp rpcprotocol.cpp rpcrawtransaction.cpp rpcserver.cpp rpcwallet.cpp script.cpp \\\n   sync.cpp txdb.cpp util.cpp version.cpp wallet.cpp walletdb.cpp $(JSON_H) \\\n   $(BITCOIN_CORE_H)\n \n@@ -55,6 +55,17 @@ endif\n AM_CPPFLAGS += $(BDB_CPPFLAGS)\n bitcoind_LDADD += $(BDB_LIBS)\n \n+# bitcoin-rpc binary #\n+bitcoin_rpc_LDADD = libbitcoin.a leveldb/libleveldb.a leveldb/libmemenv.a \\\n+  $(BOOST_LIBS)\n+bitcoin_rpc_SOURCES = bitcoin-rpc.cpp\n+#\n+\n+if TARGET_WINDOWS\n+bitcoin_rpc_SOURCES += bitcoin-rpc-res.rc\n+endif\n+bitcoin_rpc_LDADD += $(BDB_LIBS)\n+\n leveldb/libleveldb.a: leveldb/libmemenv.a\n \n leveldb/%.a:"
      },
      {
        "sha": "609d202ed43495865f5878fe89f56844d5550fec",
        "filename": "src/bitcoin-rpc-res.rc",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoin-rpc-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoin-rpc-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-rpc-res.rc?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -0,0 +1,36 @@\n+#include <windows.h>             // needed for VERSIONINFO\n+#include \"clientversion.h\"       // holds the needed client version information\n+\n+#define VER_PRODUCTVERSION     CLIENT_VERSION_MAJOR,CLIENT_VERSION_MINOR,CLIENT_VERSION_REVISION,CLIENT_VERSION_BUILD\n+#define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n+#define VER_FILEVERSION        VER_PRODUCTVERSION\n+#define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n+#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin developers\"\n+\n+VS_VERSION_INFO VERSIONINFO\n+FILEVERSION     VER_FILEVERSION\n+PRODUCTVERSION  VER_PRODUCTVERSION\n+FILEOS          VOS_NT_WINDOWS32\n+FILETYPE        VFT_APP\n+BEGIN\n+    BLOCK \"StringFileInfo\"\n+    BEGIN\n+        BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n+        BEGIN\n+            VALUE \"CompanyName\",        \"Bitcoin\"\n+            VALUE \"FileDescription\",    \"Bitcoin-rpc (OSS RPC client for Bitcoin)\"\n+            VALUE \"FileVersion\",        VER_FILEVERSION_STR\n+            VALUE \"InternalName\",       \"bitcoin-rpc\"\n+            VALUE \"LegalCopyright\",     COPYRIGHT_STR\n+            VALUE \"LegalTrademarks1\",   \"Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n+            VALUE \"OriginalFilename\",   \"bitcoin-rpc.exe\"\n+            VALUE \"ProductName\",        \"Bitcoin-rpc\"\n+            VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n+        END\n+    END\n+\n+    BLOCK \"VarFileInfo\"\n+    BEGIN\n+        VALUE \"Translation\", 0x0, 1252 // language neutral - multilingual (decimal)\n+    END\n+END"
      },
      {
        "sha": "666c03a4720cdecb2c1916a321d5078eea76bbb5",
        "filename": "src/bitcoin-rpc.cpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoin-rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoin-rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-rpc.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"bitcoinrpc.h\"\n+#include \"ui_interface.h\" /* for _(...) */\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// Start\n+//\n+static bool AppInitRPC(int argc, char* argv[])\n+{\n+    //\n+    // Parameters\n+    //\n+    ParseParameters(argc, argv);\n+    if (!boost::filesystem::is_directory(GetDataDir(false)))\n+    {\n+        fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n+        return false;\n+    }\n+    ReadConfigFile(mapArgs, mapMultiArgs);\n+\n+    if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n+    {\n+        // First part of help message is specific to RPC client\n+        std::string strUsage = _(\"Bitcoin RPC client version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+            _(\"Usage:\") + \"\\n\" +\n+              \"  bitcoin-rpc [options] <command> [params]  \" + _(\"Send command to -server or bitcoind\") + \"\\n\" +\n+              \"  bitcoin-rpc [options] help                \" + _(\"List commands\") + \"\\n\" +\n+              \"  bitcoin-rpc [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+\n+        strUsage += \"\\n\" + HelpMessage(HMM_BITCOIN_RPC);\n+\n+        fprintf(stdout, \"%s\", strUsage.c_str());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+int main(int argc, char* argv[])\n+{\n+    try\n+    {\n+        if(!AppInitRPC(argc, argv))\n+            return 1;\n+    }\n+    catch (std::exception& e) {\n+        PrintExceptionContinue(&e, \"AppInitRPC()\");\n+    } catch (...) {\n+        PrintExceptionContinue(NULL, \"AppInitRPC()\");\n+    }\n+\n+    try\n+    {\n+        if(!CommandLineRPC(argc, argv))\n+            return 1;\n+    }\n+    catch (std::exception& e) {\n+        PrintExceptionContinue(&e, \"CommandLineRPC()\");\n+    } catch (...) {\n+        PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n+    }\n+    return 0;\n+}"
      },
      {
        "sha": "36ffd7b444eafa4a18671ebe7179b8c587523e72",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -62,7 +62,7 @@ bool AppInit(int argc, char* argv[])\n                   \"  bitcoind [options] help                \" + _(\"List commands\") + \"\\n\" +\n                   \"  bitcoind [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessage();\n+            strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n \n             fprintf(stdout, \"%s\", strUsage.c_str());\n             return false;"
      },
      {
        "sha": "9de6ba5b2b5aaeeea5ab01095039343a9eefbced",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -10,6 +10,11 @@\n #include <list>\n #include <map>\n \n+#include <boost/asio.hpp>\n+#include <boost/asio/ssl.hpp>\n+#include <boost/iostreams/concepts.hpp>\n+#include <boost/iostreams/stream.hpp>\n+\n class CBlockIndex;\n class CReserveKey;\n \n@@ -224,4 +229,88 @@ extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value verifychain(const json_spirit::Array& params, bool fHelp);\n \n+//\n+// rpcprotocol.cpp\n+//\n+\n+//\n+// IOStream device that speaks SSL but can also speak non-SSL\n+//\n+template <typename Protocol>\n+class SSLIOStreamDevice : public boost::iostreams::device<boost::iostreams::bidirectional> {\n+public:\n+    SSLIOStreamDevice(boost::asio::ssl::stream<typename Protocol::socket> &streamIn, bool fUseSSLIn) : stream(streamIn)\n+    {\n+        fUseSSL = fUseSSLIn;\n+        fNeedHandshake = fUseSSLIn;\n+    }\n+\n+    void handshake(boost::asio::ssl::stream_base::handshake_type role)\n+    {\n+        if (!fNeedHandshake) return;\n+        fNeedHandshake = false;\n+        stream.handshake(role);\n+    }\n+    std::streamsize read(char* s, std::streamsize n)\n+    {\n+        handshake(boost::asio::ssl::stream_base::server); // HTTPS servers read first\n+        if (fUseSSL) return stream.read_some(boost::asio::buffer(s, n));\n+        return stream.next_layer().read_some(boost::asio::buffer(s, n));\n+    }\n+    std::streamsize write(const char* s, std::streamsize n)\n+    {\n+        handshake(boost::asio::ssl::stream_base::client); // HTTPS clients write first\n+        if (fUseSSL) return boost::asio::write(stream, boost::asio::buffer(s, n));\n+        return boost::asio::write(stream.next_layer(), boost::asio::buffer(s, n));\n+    }\n+    bool connect(const std::string& server, const std::string& port)\n+    {\n+        boost::asio::ip::tcp::resolver resolver(stream.get_io_service());\n+        boost::asio::ip::tcp::resolver::query query(server.c_str(), port.c_str());\n+        boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n+        boost::asio::ip::tcp::resolver::iterator end;\n+        boost::system::error_code error = boost::asio::error::host_not_found;\n+        while (error && endpoint_iterator != end)\n+        {\n+            stream.lowest_layer().close();\n+            stream.lowest_layer().connect(*endpoint_iterator++, error);\n+        }\n+        if (error)\n+            return false;\n+        return true;\n+    }\n+\n+private:\n+    bool fNeedHandshake;\n+    bool fUseSSL;\n+    boost::asio::ssl::stream<typename Protocol::socket>& stream;\n+};\n+\n+class JSONRequest\n+{\n+public:\n+    json_spirit::Value id;\n+    std::string strMethod;\n+    json_spirit::Array params;\n+\n+    JSONRequest() { id = json_spirit::Value::null; }\n+    void parse(const json_spirit::Value& valRequest);\n+};\n+\n+std::string HTTPPost(const std::string& strMsg, const std::map<std::string,std::string>& mapRequestHeaders);\n+std::string rfc1123Time();\n+std::string HTTPReply(int nStatus, const std::string& strMsg, bool keepalive);\n+bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n+                         std::string& http_method, std::string& http_uri);\n+int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto);\n+int ReadHTTPHeaders(std::basic_istream<char>& stream, std::map<std::string, std::string>& mapHeadersRet);\n+int ReadHTTPMessage(std::basic_istream<char>& stream, std::map<std::string,\n+                    std::string>& mapHeadersRet, std::string& strMessageRet,\n+                    int nProto);\n+json_spirit::Object JSONRPCError(int code, const std::string& message);\n+std::string JSONRPCRequest(const std::string& strMethod, const json_spirit::Array& params, const json_spirit::Value& id);\n+json_spirit::Object JSONRPCReplyObj(const json_spirit::Value& result, const json_spirit::Value& error, const json_spirit::Value& id);\n+std::string JSONRPCReply(const json_spirit::Value& result, const json_spirit::Value& error, const json_spirit::Value& id);\n+void ErrorReply(std::ostream& stream, const json_spirit::Object& objError, const json_spirit::Value& id);\n+\n #endif"
      },
      {
        "sha": "0708ca13ca50beca9d6ef8eec1a692c8a94a87fd",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 92,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -171,98 +171,6 @@ bool static Bind(const CService &addr, unsigned int flags) {\n     return true;\n }\n \n-// Core-specific options shared between UI and daemon\n-std::string HelpMessage()\n-{\n-    string strUsage = _(\"Options:\") + \"\\n\";\n-    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-    strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n-    strUsage += \"  -pid=<file>            \" + _(\"Specify pid file (default: bitcoind.pid)\") + \"\\n\";\n-    strUsage += \"  -gen                   \" + _(\"Generate coins (default: 0)\") + \"\\n\";\n-    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \"\\n\";\n-    strUsage += \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\";\n-    strUsage += \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\";\n-    strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\";\n-    strUsage += \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\";\n-    strUsage += \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\";\n-    strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\";\n-    strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\";\n-    strUsage += \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\";\n-    strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n-    strUsage += \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\";\n-    strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n-    strUsage += \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\";\n-    strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\";\n-    strUsage += \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\";\n-    strUsage += \"  -checkpoints           \" + _(\"Only accept block chain matching built-in checkpoints (default: 1)\") + \"\\n\";\n-    strUsage += \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n-    strUsage += \"  -bind=<addr>           \" + _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n-    strUsage += \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1 unless -connect)\") + \"\\n\";\n-    strUsage += \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\";\n-    strUsage += \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\";\n-    strUsage += \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\";\n-    strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\";\n-#ifdef USE_UPNP\n-#if USE_UPNP\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\";\n-#else\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\";\n-#endif\n-#endif\n-    strUsage += \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\";\n-    if (fHaveGUI)\n-        strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n-#if !defined(WIN32)\n-    if (fHaveGUI)\n-        strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n-#endif\n-    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-    strUsage += \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\";\n-    strUsage += \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\";\n-    strUsage += \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\";\n-    strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n-    strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n-    strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n-#ifdef WIN32\n-    strUsage += \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\";\n-#endif\n-    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\";\n-    if (!fHaveGUI)\n-        strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n-    strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n-    strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n-    strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n-    strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n-    strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\";\n-    strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n-    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\";\n-    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\";\n-    strUsage += \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 288, 0 = all)\") + \"\\n\";\n-    strUsage += \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-4, default: 3)\") + \"\\n\";\n-    strUsage += \"  -txindex               \" + _(\"Maintain a full transaction index (default: 0)\") + \"\\n\";\n-    strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \"\\n\";\n-    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \"\\n\";\n-    strUsage += \"  -par=<n>               \" + _(\"Set the number of script verification threads (up to 16, 0 = auto, <0 = leave that many cores free, default: 0)\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n-    strUsage += \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\";\n-    strUsage += \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\";\n-    strUsage += \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\";\n-    strUsage += \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\";\n-    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n-\n-    return strUsage;\n-}\n-\n struct CImportingNow\n {\n     CImportingNow() {"
      },
      {
        "sha": "af9da1479bf39cf59e5845fe4633ab0187f320cd",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -14,6 +14,5 @@ void StartShutdown();\n bool ShutdownRequested();\n void Shutdown();\n bool AppInit2(boost::thread_group& threadGroup);\n-std::string HelpMessage();\n \n #endif"
      },
      {
        "sha": "b65348548b28042fe7adbe1d22bde9f56ea0ec9a",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -527,7 +527,7 @@ HelpMessageBox::HelpMessageBox(QWidget *parent) :\n         tr(\"Usage:\") + \"\\n\" +\n         \"  bitcoin-qt [\" + tr(\"command-line options\") + \"]                     \" + \"\\n\";\n \n-    coreOptions = QString::fromStdString(HelpMessage());\n+    coreOptions = QString::fromStdString(HelpMessage(HMM_BITCOIN_QT));\n \n     uiOptions = tr(\"UI options\") + \":\\n\" +\n         \"  -lang=<lang>           \" + tr(\"Set language, for example \\\"de_DE\\\" (default: system locale)\") + \"\\n\" +"
      },
      {
        "sha": "f84d20bb6b31e6c88f7c494128fcb04c25460929",
        "filename": "src/rpcclient.cpp",
        "status": "added",
        "additions": 241,
        "deletions": 0,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -0,0 +1,241 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"init.h\"\n+#include \"util.h\"\n+#include \"sync.h\"\n+#include \"ui_interface.h\"\n+#include \"base58.h\"\n+#include \"bitcoinrpc.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/asio.hpp>\n+#include <boost/asio/ip/v6_only.hpp>\n+#include <boost/asio/ssl.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/filesystem.hpp>\n+#include <boost/filesystem/fstream.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/iostreams/concepts.hpp>\n+#include <boost/iostreams/stream.hpp>\n+#include <boost/lexical_cast.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <list>\n+\n+using namespace std;\n+using namespace boost;\n+using namespace boost::asio;\n+using namespace json_spirit;\n+\n+Object CallRPC(const string& strMethod, const Array& params)\n+{\n+    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n+        throw runtime_error(strprintf(\n+            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n+              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n+                GetConfigFile().string().c_str()));\n+\n+    // Connect to localhost\n+    bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n+    asio::io_service io_service;\n+    ssl::context context(io_service, ssl::context::sslv23);\n+    context.set_options(ssl::context::no_sslv2);\n+    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n+    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n+    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n+    if (!d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(Params().RPCPort()))))\n+        throw runtime_error(\"couldn't connect to server\");\n+\n+    // HTTP basic authentication\n+    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n+    map<string, string> mapRequestHeaders;\n+    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n+\n+    // Send request\n+    string strRequest = JSONRPCRequest(strMethod, params, 1);\n+    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n+    stream << strPost << std::flush;\n+\n+    // Receive HTTP reply status\n+    int nProto = 0;\n+    int nStatus = ReadHTTPStatus(stream, nProto);\n+\n+    // Receive HTTP reply message headers and body\n+    map<string, string> mapHeaders;\n+    string strReply;\n+    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n+\n+    if (nStatus == HTTP_UNAUTHORIZED)\n+        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n+    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n+        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n+    else if (strReply.empty())\n+        throw runtime_error(\"no response from server\");\n+\n+    // Parse reply\n+    Value valReply;\n+    if (!read_string(strReply, valReply))\n+        throw runtime_error(\"couldn't parse reply from server\");\n+    const Object& reply = valReply.get_obj();\n+    if (reply.empty())\n+        throw runtime_error(\"expected reply to have result, error and id properties\");\n+\n+    return reply;\n+}\n+\n+\n+\n+\n+template<typename T>\n+void ConvertTo(Value& value, bool fAllowNull=false)\n+{\n+    if (fAllowNull && value.type() == null_type)\n+        return;\n+    if (value.type() == str_type)\n+    {\n+        // reinterpret string as unquoted json value\n+        Value value2;\n+        string strJSON = value.get_str();\n+        if (!read_string(strJSON, value2))\n+            throw runtime_error(string(\"Error parsing JSON:\")+strJSON);\n+        ConvertTo<T>(value2, fAllowNull);\n+        value = value2;\n+    }\n+    else\n+    {\n+        value = value.get_value<T>();\n+    }\n+}\n+\n+// Convert strings to command-specific RPC representation\n+Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n+{\n+    Array params;\n+    BOOST_FOREACH(const std::string &param, strParams)\n+        params.push_back(param);\n+\n+    int n = params.size();\n+\n+    //\n+    // Special case non-string parameter types\n+    //\n+    if (strMethod == \"stop\"                   && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"getaddednodeinfo\"       && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"getnetworkhashps\"       && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"getnetworkhashps\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n+    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n+    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n+    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n+    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n+    if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n+    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n+    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n+    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"walletpassphrase\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"getblocktemplate\"       && n > 0) ConvertTo<Object>(params[0]);\n+    if (strMethod == \"listsinceblock\"         && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"sendmany\"               && n > 1) ConvertTo<Object>(params[1]);\n+    if (strMethod == \"sendmany\"               && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+    if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n+    if (strMethod == \"createmultisig\"         && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"createmultisig\"         && n > 1) ConvertTo<Array>(params[1]);\n+    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n+    if (strMethod == \"getblock\"               && n > 1) ConvertTo<bool>(params[1]);\n+    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n+    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n+    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n+    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n+    if (strMethod == \"sendrawtransaction\"     && n > 1) ConvertTo<bool>(params[1], true);\n+    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n+    if (strMethod == \"lockunspent\"            && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"lockunspent\"            && n > 1) ConvertTo<Array>(params[1]);\n+    if (strMethod == \"importprivkey\"          && n > 2) ConvertTo<bool>(params[2]);\n+    if (strMethod == \"verifychain\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"verifychain\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"keypoolrefill\"          && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+\n+    return params;\n+}\n+\n+int CommandLineRPC(int argc, char *argv[])\n+{\n+    string strPrint;\n+    int nRet = 0;\n+    try\n+    {\n+        // Skip switches\n+        while (argc > 1 && IsSwitchChar(argv[1][0]))\n+        {\n+            argc--;\n+            argv++;\n+        }\n+\n+        // Method\n+        if (argc < 2)\n+            throw runtime_error(\"too few parameters\");\n+        string strMethod = argv[1];\n+\n+        // Parameters default to strings\n+        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n+        Array params = RPCConvertValues(strMethod, strParams);\n+\n+        // Execute\n+        Object reply = CallRPC(strMethod, params);\n+\n+        // Parse reply\n+        const Value& result = find_value(reply, \"result\");\n+        const Value& error  = find_value(reply, \"error\");\n+\n+        if (error.type() != null_type)\n+        {\n+            // Error\n+            strPrint = \"error: \" + write_string(error, false);\n+            int code = find_value(error.get_obj(), \"code\").get_int();\n+            nRet = abs(code);\n+        }\n+        else\n+        {\n+            // Result\n+            if (result.type() == null_type)\n+                strPrint = \"\";\n+            else if (result.type() == str_type)\n+                strPrint = result.get_str();\n+            else\n+                strPrint = write_string(result, true);\n+        }\n+    }\n+    catch (boost::thread_interrupted) {\n+        throw;\n+    }\n+    catch (std::exception& e) {\n+        strPrint = string(\"error: \") + e.what();\n+        nRet = 87;\n+    }\n+    catch (...) {\n+        PrintException(NULL, \"CommandLineRPC()\");\n+    }\n+\n+    if (strPrint != \"\")\n+    {\n+        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n+    }\n+    return nRet;\n+}"
      },
      {
        "sha": "e8d0109113149d1872d2a5f2a163adc3adf3a4ec",
        "filename": "src/rpcprotocol.cpp",
        "status": "added",
        "additions": 291,
        "deletions": 0,
        "changes": 291,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -0,0 +1,291 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+// Base HTTP/RPC protocol functions shared between to RPC client and server\n+\n+#include \"init.h\"\n+#include \"util.h\"\n+#include \"ui_interface.h\"\n+#include \"bitcoinrpc.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+using namespace std;\n+using namespace boost;\n+using namespace json_spirit;\n+\n+//\n+// HTTP protocol\n+//\n+// This ain't Apache.  We're just using HTTP header for the length field\n+// and to be compatible with other JSON-RPC implementations.\n+//\n+\n+string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n+{\n+    ostringstream s;\n+    s << \"POST / HTTP/1.1\\r\\n\"\n+      << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n+      << \"Host: 127.0.0.1\\r\\n\"\n+      << \"Content-Type: application/json\\r\\n\"\n+      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n+      << \"Connection: close\\r\\n\"\n+      << \"Accept: application/json\\r\\n\";\n+    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n+        s << item.first << \": \" << item.second << \"\\r\\n\";\n+    s << \"\\r\\n\" << strMsg;\n+\n+    return s.str();\n+}\n+\n+string rfc1123Time()\n+{\n+    char buffer[64];\n+    time_t now;\n+    time(&now);\n+    struct tm* now_gmt = gmtime(&now);\n+    string locale(setlocale(LC_TIME, NULL));\n+    setlocale(LC_TIME, \"C\"); // we want POSIX (aka \"C\") weekday/month strings\n+    strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S +0000\", now_gmt);\n+    setlocale(LC_TIME, locale.c_str());\n+    return string(buffer);\n+}\n+\n+string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n+{\n+    if (nStatus == HTTP_UNAUTHORIZED)\n+        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n+            \"Date: %s\\r\\n\"\n+            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n+            \"Content-Type: text/html\\r\\n\"\n+            \"Content-Length: 296\\r\\n\"\n+            \"\\r\\n\"\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n+            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n+            \"<HTML>\\r\\n\"\n+            \"<HEAD>\\r\\n\"\n+            \"<TITLE>Error</TITLE>\\r\\n\"\n+            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n+            \"</HEAD>\\r\\n\"\n+            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n+            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n+    const char *cStatus;\n+         if (nStatus == HTTP_OK) cStatus = \"OK\";\n+    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n+    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n+    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n+    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n+    else cStatus = \"\";\n+    return strprintf(\n+            \"HTTP/1.1 %d %s\\r\\n\"\n+            \"Date: %s\\r\\n\"\n+            \"Connection: %s\\r\\n\"\n+            \"Content-Length: %\"PRIszu\"\\r\\n\"\n+            \"Content-Type: application/json\\r\\n\"\n+            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+            \"\\r\\n\"\n+            \"%s\",\n+        nStatus,\n+        cStatus,\n+        rfc1123Time().c_str(),\n+        keepalive ? \"keep-alive\" : \"close\",\n+        strMsg.size(),\n+        FormatFullVersion().c_str(),\n+        strMsg.c_str());\n+}\n+\n+bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n+                         string& http_method, string& http_uri)\n+{\n+    string str;\n+    getline(stream, str);\n+\n+    // HTTP request line is space-delimited\n+    vector<string> vWords;\n+    boost::split(vWords, str, boost::is_any_of(\" \"));\n+    if (vWords.size() < 2)\n+        return false;\n+\n+    // HTTP methods permitted: GET, POST\n+    http_method = vWords[0];\n+    if (http_method != \"GET\" && http_method != \"POST\")\n+        return false;\n+\n+    // HTTP URI must be an absolute path, relative to current host\n+    http_uri = vWords[1];\n+    if (http_uri.size() == 0 || http_uri[0] != '/')\n+        return false;\n+\n+    // parse proto, if present\n+    string strProto = \"\";\n+    if (vWords.size() > 2)\n+        strProto = vWords[2];\n+\n+    proto = 0;\n+    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n+    if (ver != NULL)\n+        proto = atoi(ver+7);\n+\n+    return true;\n+}\n+\n+int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n+{\n+    string str;\n+    getline(stream, str);\n+    vector<string> vWords;\n+    boost::split(vWords, str, boost::is_any_of(\" \"));\n+    if (vWords.size() < 2)\n+        return HTTP_INTERNAL_SERVER_ERROR;\n+    proto = 0;\n+    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n+    if (ver != NULL)\n+        proto = atoi(ver+7);\n+    return atoi(vWords[1].c_str());\n+}\n+\n+int ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n+{\n+    int nLen = 0;\n+    while (true)\n+    {\n+        string str;\n+        std::getline(stream, str);\n+        if (str.empty() || str == \"\\r\")\n+            break;\n+        string::size_type nColon = str.find(\":\");\n+        if (nColon != string::npos)\n+        {\n+            string strHeader = str.substr(0, nColon);\n+            boost::trim(strHeader);\n+            boost::to_lower(strHeader);\n+            string strValue = str.substr(nColon+1);\n+            boost::trim(strValue);\n+            mapHeadersRet[strHeader] = strValue;\n+            if (strHeader == \"content-length\")\n+                nLen = atoi(strValue.c_str());\n+        }\n+    }\n+    return nLen;\n+}\n+\n+int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n+                    string>& mapHeadersRet, string& strMessageRet,\n+                    int nProto)\n+{\n+    mapHeadersRet.clear();\n+    strMessageRet = \"\";\n+\n+    // Read header\n+    int nLen = ReadHTTPHeaders(stream, mapHeadersRet);\n+    if (nLen < 0 || nLen > (int)MAX_SIZE)\n+        return HTTP_INTERNAL_SERVER_ERROR;\n+\n+    // Read message\n+    if (nLen > 0)\n+    {\n+        vector<char> vch(nLen);\n+        stream.read(&vch[0], nLen);\n+        strMessageRet = string(vch.begin(), vch.end());\n+    }\n+\n+    string sConHdr = mapHeadersRet[\"connection\"];\n+\n+    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n+    {\n+        if (nProto >= 1)\n+            mapHeadersRet[\"connection\"] = \"keep-alive\";\n+        else\n+            mapHeadersRet[\"connection\"] = \"close\";\n+    }\n+\n+    return HTTP_OK;\n+}\n+\n+//\n+// JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n+// but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n+// unspecified (HTTP errors and contents of 'error').\n+//\n+// 1.0 spec: http://json-rpc.org/wiki/specification\n+// 1.2 spec: http://groups.google.com/group/json-rpc/web/json-rpc-over-http\n+// http://www.codeproject.com/KB/recipes/JSON_Spirit.aspx\n+//\n+Object JSONRPCError(int code, const string& message)\n+{\n+    Object error;\n+    error.push_back(Pair(\"code\", code));\n+    error.push_back(Pair(\"message\", message));\n+    return error;\n+}\n+\n+string JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)\n+{\n+    Object request;\n+    request.push_back(Pair(\"method\", strMethod));\n+    request.push_back(Pair(\"params\", params));\n+    request.push_back(Pair(\"id\", id));\n+    return write_string(Value(request), false) + \"\\n\";\n+}\n+\n+Object JSONRPCReplyObj(const Value& result, const Value& error, const Value& id)\n+{\n+    Object reply;\n+    if (error.type() != null_type)\n+        reply.push_back(Pair(\"result\", Value::null));\n+    else\n+        reply.push_back(Pair(\"result\", result));\n+    reply.push_back(Pair(\"error\", error));\n+    reply.push_back(Pair(\"id\", id));\n+    return reply;\n+}\n+\n+string JSONRPCReply(const Value& result, const Value& error, const Value& id)\n+{\n+    Object reply = JSONRPCReplyObj(result, error, id);\n+    return write_string(Value(reply), false) + \"\\n\";\n+}\n+\n+void ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n+{\n+    // Send error reply from json-rpc error object\n+    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n+    int code = find_value(objError, \"code\").get_int();\n+    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n+    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n+    string strReply = JSONRPCReply(Value::null, objError, id);\n+    stream << HTTPReply(nStatus, strReply, false) << std::flush;\n+}\n+\n+void JSONRequest::parse(const Value& valRequest)\n+{\n+    // Parse request\n+    if (valRequest.type() != obj_type)\n+        throw JSONRPCError(RPC_INVALID_REQUEST, \"Invalid Request object\");\n+    const Object& request = valRequest.get_obj();\n+\n+    // Parse id now so errors from here on will have the id\n+    id = find_value(request, \"id\");\n+\n+    // Parse method\n+    Value valMethod = find_value(request, \"method\");\n+    if (valMethod.type() == null_type)\n+        throw JSONRPCError(RPC_INVALID_REQUEST, \"Missing method\");\n+    if (valMethod.type() != str_type)\n+        throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n+    strMethod = valMethod.get_str();\n+    if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n+        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+\n+    // Parse params\n+    Value valParams = find_value(request, \"params\");\n+    if (valParams.type() == array_type)\n+        params = valParams.get_array();\n+    else if (valParams.type() == null_type)\n+        params = Array();\n+    else\n+        throw JSONRPCError(RPC_INVALID_REQUEST, \"Params must be an array\");\n+}"
      },
      {
        "sha": "e620ec7e969936d34baff982f3b0f001eb4e2e55",
        "filename": "src/rpcserver.cpp",
        "status": "renamed",
        "additions": 0,
        "deletions": 590,
        "changes": 590,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -39,14 +39,6 @@ static map<string, boost::shared_ptr<deadline_timer> > deadlineTimers;\n static ssl::context* rpc_ssl_context = NULL;\n static boost::thread_group* rpc_worker_group = NULL;\n \n-Object JSONRPCError(int code, const string& message)\n-{\n-    Object error;\n-    error.push_back(Pair(\"code\", code));\n-    error.push_back(Pair(\"message\", message));\n-    return error;\n-}\n-\n void RPCTypeCheck(const Array& params,\n                   const list<Value_type>& typesExpected,\n                   bool fAllowNull)\n@@ -314,195 +306,6 @@ const CRPCCommand *CRPCTable::operator[](string name) const\n     return (*it).second;\n }\n \n-//\n-// HTTP protocol\n-//\n-// This ain't Apache.  We're just using HTTP header for the length field\n-// and to be compatible with other JSON-RPC implementations.\n-//\n-\n-string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n-{\n-    ostringstream s;\n-    s << \"POST / HTTP/1.1\\r\\n\"\n-      << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n-      << \"Host: 127.0.0.1\\r\\n\"\n-      << \"Content-Type: application/json\\r\\n\"\n-      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n-      << \"Connection: close\\r\\n\"\n-      << \"Accept: application/json\\r\\n\";\n-    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n-        s << item.first << \": \" << item.second << \"\\r\\n\";\n-    s << \"\\r\\n\" << strMsg;\n-\n-    return s.str();\n-}\n-\n-string rfc1123Time()\n-{\n-    char buffer[64];\n-    time_t now;\n-    time(&now);\n-    struct tm* now_gmt = gmtime(&now);\n-    string locale(setlocale(LC_TIME, NULL));\n-    setlocale(LC_TIME, \"C\"); // we want POSIX (aka \"C\") weekday/month strings\n-    strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S +0000\", now_gmt);\n-    setlocale(LC_TIME, locale.c_str());\n-    return string(buffer);\n-}\n-\n-static string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n-{\n-    if (nStatus == HTTP_UNAUTHORIZED)\n-        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n-            \"Content-Type: text/html\\r\\n\"\n-            \"Content-Length: 296\\r\\n\"\n-            \"\\r\\n\"\n-            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n-            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n-            \"<HTML>\\r\\n\"\n-            \"<HEAD>\\r\\n\"\n-            \"<TITLE>Error</TITLE>\\r\\n\"\n-            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n-            \"</HEAD>\\r\\n\"\n-            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n-    const char *cStatus;\n-         if (nStatus == HTTP_OK) cStatus = \"OK\";\n-    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n-    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n-    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n-    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n-    else cStatus = \"\";\n-    return strprintf(\n-            \"HTTP/1.1 %d %s\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Connection: %s\\r\\n\"\n-            \"Content-Length: %\"PRIszu\"\\r\\n\"\n-            \"Content-Type: application/json\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"\\r\\n\"\n-            \"%s\",\n-        nStatus,\n-        cStatus,\n-        rfc1123Time().c_str(),\n-        keepalive ? \"keep-alive\" : \"close\",\n-        strMsg.size(),\n-        FormatFullVersion().c_str(),\n-        strMsg.c_str());\n-}\n-\n-bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n-                         string& http_method, string& http_uri)\n-{\n-    string str;\n-    getline(stream, str);\n-\n-    // HTTP request line is space-delimited\n-    vector<string> vWords;\n-    boost::split(vWords, str, boost::is_any_of(\" \"));\n-    if (vWords.size() < 2)\n-        return false;\n-\n-    // HTTP methods permitted: GET, POST\n-    http_method = vWords[0];\n-    if (http_method != \"GET\" && http_method != \"POST\")\n-        return false;\n-\n-    // HTTP URI must be an absolute path, relative to current host\n-    http_uri = vWords[1];\n-    if (http_uri.size() == 0 || http_uri[0] != '/')\n-        return false;\n-\n-    // parse proto, if present\n-    string strProto = \"\";\n-    if (vWords.size() > 2)\n-        strProto = vWords[2];\n-\n-    proto = 0;\n-    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n-    if (ver != NULL)\n-        proto = atoi(ver+7);\n-\n-    return true;\n-}\n-\n-int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n-{\n-    string str;\n-    getline(stream, str);\n-    vector<string> vWords;\n-    boost::split(vWords, str, boost::is_any_of(\" \"));\n-    if (vWords.size() < 2)\n-        return HTTP_INTERNAL_SERVER_ERROR;\n-    proto = 0;\n-    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n-    if (ver != NULL)\n-        proto = atoi(ver+7);\n-    return atoi(vWords[1].c_str());\n-}\n-\n-int ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n-{\n-    int nLen = 0;\n-    while (true)\n-    {\n-        string str;\n-        std::getline(stream, str);\n-        if (str.empty() || str == \"\\r\")\n-            break;\n-        string::size_type nColon = str.find(\":\");\n-        if (nColon != string::npos)\n-        {\n-            string strHeader = str.substr(0, nColon);\n-            boost::trim(strHeader);\n-            boost::to_lower(strHeader);\n-            string strValue = str.substr(nColon+1);\n-            boost::trim(strValue);\n-            mapHeadersRet[strHeader] = strValue;\n-            if (strHeader == \"content-length\")\n-                nLen = atoi(strValue.c_str());\n-        }\n-    }\n-    return nLen;\n-}\n-\n-int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n-                    string>& mapHeadersRet, string& strMessageRet,\n-                    int nProto)\n-{\n-    mapHeadersRet.clear();\n-    strMessageRet = \"\";\n-\n-    // Read header\n-    int nLen = ReadHTTPHeaders(stream, mapHeadersRet);\n-    if (nLen < 0 || nLen > (int)MAX_SIZE)\n-        return HTTP_INTERNAL_SERVER_ERROR;\n-\n-    // Read message\n-    if (nLen > 0)\n-    {\n-        vector<char> vch(nLen);\n-        stream.read(&vch[0], nLen);\n-        strMessageRet = string(vch.begin(), vch.end());\n-    }\n-\n-    string sConHdr = mapHeadersRet[\"connection\"];\n-\n-    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n-    {\n-        if (nProto >= 1)\n-            mapHeadersRet[\"connection\"] = \"keep-alive\";\n-        else\n-            mapHeadersRet[\"connection\"] = \"close\";\n-    }\n-\n-    return HTTP_OK;\n-}\n-\n bool HTTPAuthorized(map<string, string>& mapHeaders)\n {\n     string strAuth = mapHeaders[\"authorization\"];\n@@ -513,54 +316,6 @@ bool HTTPAuthorized(map<string, string>& mapHeaders)\n     return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n }\n \n-//\n-// JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n-// but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n-// unspecified (HTTP errors and contents of 'error').\n-//\n-// 1.0 spec: http://json-rpc.org/wiki/specification\n-// 1.2 spec: http://groups.google.com/group/json-rpc/web/json-rpc-over-http\n-// http://www.codeproject.com/KB/recipes/JSON_Spirit.aspx\n-//\n-\n-string JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)\n-{\n-    Object request;\n-    request.push_back(Pair(\"method\", strMethod));\n-    request.push_back(Pair(\"params\", params));\n-    request.push_back(Pair(\"id\", id));\n-    return write_string(Value(request), false) + \"\\n\";\n-}\n-\n-Object JSONRPCReplyObj(const Value& result, const Value& error, const Value& id)\n-{\n-    Object reply;\n-    if (error.type() != null_type)\n-        reply.push_back(Pair(\"result\", Value::null));\n-    else\n-        reply.push_back(Pair(\"result\", result));\n-    reply.push_back(Pair(\"error\", error));\n-    reply.push_back(Pair(\"id\", id));\n-    return reply;\n-}\n-\n-string JSONRPCReply(const Value& result, const Value& error, const Value& id)\n-{\n-    Object reply = JSONRPCReplyObj(result, error, id);\n-    return write_string(Value(reply), false) + \"\\n\";\n-}\n-\n-void ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n-{\n-    // Send error reply from json-rpc error object\n-    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n-    int code = find_value(objError, \"code\").get_int();\n-    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n-    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n-    string strReply = JSONRPCReply(Value::null, objError, id);\n-    stream << HTTPReply(nStatus, strReply, false) << std::flush;\n-}\n-\n bool ClientAllowed(const boost::asio::ip::address& address)\n {\n     // Make sure that IPv4-compatible and IPv4-mapped IPv6 addresses are treated as IPv4 addresses\n@@ -584,59 +339,6 @@ bool ClientAllowed(const boost::asio::ip::address& address)\n     return false;\n }\n \n-//\n-// IOStream device that speaks SSL but can also speak non-SSL\n-//\n-template <typename Protocol>\n-class SSLIOStreamDevice : public iostreams::device<iostreams::bidirectional> {\n-public:\n-    SSLIOStreamDevice(asio::ssl::stream<typename Protocol::socket> &streamIn, bool fUseSSLIn) : stream(streamIn)\n-    {\n-        fUseSSL = fUseSSLIn;\n-        fNeedHandshake = fUseSSLIn;\n-    }\n-\n-    void handshake(ssl::stream_base::handshake_type role)\n-    {\n-        if (!fNeedHandshake) return;\n-        fNeedHandshake = false;\n-        stream.handshake(role);\n-    }\n-    std::streamsize read(char* s, std::streamsize n)\n-    {\n-        handshake(ssl::stream_base::server); // HTTPS servers read first\n-        if (fUseSSL) return stream.read_some(asio::buffer(s, n));\n-        return stream.next_layer().read_some(asio::buffer(s, n));\n-    }\n-    std::streamsize write(const char* s, std::streamsize n)\n-    {\n-        handshake(ssl::stream_base::client); // HTTPS clients write first\n-        if (fUseSSL) return asio::write(stream, asio::buffer(s, n));\n-        return asio::write(stream.next_layer(), asio::buffer(s, n));\n-    }\n-    bool connect(const std::string& server, const std::string& port)\n-    {\n-        ip::tcp::resolver resolver(stream.get_io_service());\n-        ip::tcp::resolver::query query(server.c_str(), port.c_str());\n-        ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n-        ip::tcp::resolver::iterator end;\n-        boost::system::error_code error = asio::error::host_not_found;\n-        while (error && endpoint_iterator != end)\n-        {\n-            stream.lowest_layer().close();\n-            stream.lowest_layer().connect(*endpoint_iterator++, error);\n-        }\n-        if (error)\n-            return false;\n-        return true;\n-    }\n-\n-private:\n-    bool fNeedHandshake;\n-    bool fUseSSL;\n-    asio::ssl::stream<typename Protocol::socket>& stream;\n-};\n-\n class AcceptedConnection\n {\n public:\n@@ -906,47 +608,6 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n }\n \n \n-class JSONRequest\n-{\n-public:\n-    Value id;\n-    string strMethod;\n-    Array params;\n-\n-    JSONRequest() { id = Value::null; }\n-    void parse(const Value& valRequest);\n-};\n-\n-void JSONRequest::parse(const Value& valRequest)\n-{\n-    // Parse request\n-    if (valRequest.type() != obj_type)\n-        throw JSONRPCError(RPC_INVALID_REQUEST, \"Invalid Request object\");\n-    const Object& request = valRequest.get_obj();\n-\n-    // Parse id now so errors from here on will have the id\n-    id = find_value(request, \"id\");\n-\n-    // Parse method\n-    Value valMethod = find_value(request, \"method\");\n-    if (valMethod.type() == null_type)\n-        throw JSONRPCError(RPC_INVALID_REQUEST, \"Missing method\");\n-    if (valMethod.type() != str_type)\n-        throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n-    strMethod = valMethod.get_str();\n-    if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n-        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n-\n-    // Parse params\n-    Value valParams = find_value(request, \"params\");\n-    if (valParams.type() == array_type)\n-        params = valParams.get_array();\n-    else if (valParams.type() == null_type)\n-        params = Array();\n-    else\n-        throw JSONRPCError(RPC_INVALID_REQUEST, \"Params must be an array\");\n-}\n-\n static Object JSONRPCExecOne(const Value& req)\n {\n     Object rpc_result;\n@@ -1100,255 +761,4 @@ json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_s\n     }\n }\n \n-\n-Object CallRPC(const string& strMethod, const Array& params)\n-{\n-    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n-        throw runtime_error(strprintf(\n-            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n-                GetConfigFile().string().c_str()));\n-\n-    // Connect to localhost\n-    bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n-    asio::io_service io_service;\n-    ssl::context context(io_service, ssl::context::sslv23);\n-    context.set_options(ssl::context::no_sslv2);\n-    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n-    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n-    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n-    if (!d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(Params().RPCPort()))))\n-        throw runtime_error(\"couldn't connect to server\");\n-\n-    // HTTP basic authentication\n-    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n-    map<string, string> mapRequestHeaders;\n-    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n-\n-    // Send request\n-    string strRequest = JSONRPCRequest(strMethod, params, 1);\n-    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n-    stream << strPost << std::flush;\n-\n-    // Receive HTTP reply status\n-    int nProto = 0;\n-    int nStatus = ReadHTTPStatus(stream, nProto);\n-\n-    // Receive HTTP reply message headers and body\n-    map<string, string> mapHeaders;\n-    string strReply;\n-    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n-\n-    if (nStatus == HTTP_UNAUTHORIZED)\n-        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n-    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n-        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n-    else if (strReply.empty())\n-        throw runtime_error(\"no response from server\");\n-\n-    // Parse reply\n-    Value valReply;\n-    if (!read_string(strReply, valReply))\n-        throw runtime_error(\"couldn't parse reply from server\");\n-    const Object& reply = valReply.get_obj();\n-    if (reply.empty())\n-        throw runtime_error(\"expected reply to have result, error and id properties\");\n-\n-    return reply;\n-}\n-\n-\n-\n-\n-template<typename T>\n-void ConvertTo(Value& value, bool fAllowNull=false)\n-{\n-    if (fAllowNull && value.type() == null_type)\n-        return;\n-    if (value.type() == str_type)\n-    {\n-        // reinterpret string as unquoted json value\n-        Value value2;\n-        string strJSON = value.get_str();\n-        if (!read_string(strJSON, value2))\n-            throw runtime_error(string(\"Error parsing JSON:\")+strJSON);\n-        ConvertTo<T>(value2, fAllowNull);\n-        value = value2;\n-    }\n-    else\n-    {\n-        value = value.get_value<T>();\n-    }\n-}\n-\n-// Convert strings to command-specific RPC representation\n-Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n-{\n-    Array params;\n-    BOOST_FOREACH(const std::string &param, strParams)\n-        params.push_back(param);\n-\n-    int n = params.size();\n-\n-    //\n-    // Special case non-string parameter types\n-    //\n-    if (strMethod == \"stop\"                   && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"getaddednodeinfo\"       && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"getnetworkhashps\"       && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"getnetworkhashps\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n-    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n-    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n-    if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n-    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n-    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n-    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n-    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"walletpassphrase\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"getblocktemplate\"       && n > 0) ConvertTo<Object>(params[0]);\n-    if (strMethod == \"listsinceblock\"         && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"sendmany\"               && n > 1) ConvertTo<Object>(params[1]);\n-    if (strMethod == \"sendmany\"               && n > 2) ConvertTo<boost::int64_t>(params[2]);\n-    if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"createmultisig\"         && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"createmultisig\"         && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n-    if (strMethod == \"getblock\"               && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n-    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n-    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n-    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n-    if (strMethod == \"sendrawtransaction\"     && n > 1) ConvertTo<bool>(params[1], true);\n-    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n-    if (strMethod == \"lockunspent\"            && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"lockunspent\"            && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"importprivkey\"          && n > 2) ConvertTo<bool>(params[2]);\n-    if (strMethod == \"verifychain\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"verifychain\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"keypoolrefill\"          && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-\n-    return params;\n-}\n-\n-int CommandLineRPC(int argc, char *argv[])\n-{\n-    string strPrint;\n-    int nRet = 0;\n-    try\n-    {\n-        // Skip switches\n-        while (argc > 1 && IsSwitchChar(argv[1][0]))\n-        {\n-            argc--;\n-            argv++;\n-        }\n-\n-        // Method\n-        if (argc < 2)\n-            throw runtime_error(\"too few parameters\");\n-        string strMethod = argv[1];\n-\n-        // Parameters default to strings\n-        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n-        Array params = RPCConvertValues(strMethod, strParams);\n-\n-        // Execute\n-        Object reply = CallRPC(strMethod, params);\n-\n-        // Parse reply\n-        const Value& result = find_value(reply, \"result\");\n-        const Value& error  = find_value(reply, \"error\");\n-\n-        if (error.type() != null_type)\n-        {\n-            // Error\n-            strPrint = \"error: \" + write_string(error, false);\n-            int code = find_value(error.get_obj(), \"code\").get_int();\n-            nRet = abs(code);\n-        }\n-        else\n-        {\n-            // Result\n-            if (result.type() == null_type)\n-                strPrint = \"\";\n-            else if (result.type() == str_type)\n-                strPrint = result.get_str();\n-            else\n-                strPrint = write_string(result, true);\n-        }\n-    }\n-    catch (boost::thread_interrupted) {\n-        throw;\n-    }\n-    catch (std::exception& e) {\n-        strPrint = string(\"error: \") + e.what();\n-        nRet = 87;\n-    }\n-    catch (...) {\n-        PrintException(NULL, \"CommandLineRPC()\");\n-    }\n-\n-    if (strPrint != \"\")\n-    {\n-        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n-    }\n-    return nRet;\n-}\n-\n-\n-\n-\n-#ifdef TEST\n-int main(int argc, char *argv[])\n-{\n-#ifdef _MSC_VER\n-    // Turn off Microsoft heap dump noise\n-    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n-    _CrtSetReportFile(_CRT_WARN, CreateFile(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n-#endif\n-    setbuf(stdin, NULL);\n-    setbuf(stdout, NULL);\n-    setbuf(stderr, NULL);\n-\n-    try\n-    {\n-        if (argc >= 2 && string(argv[1]) == \"-server\")\n-        {\n-            LogPrintf(\"server ready\\n\");\n-            ThreadRPCServer(NULL);\n-        }\n-        else\n-        {\n-            return CommandLineRPC(argc, argv);\n-        }\n-    }\n-    catch (boost::thread_interrupted) {\n-        throw;\n-    }\n-    catch (std::exception& e) {\n-        PrintException(&e, \"main()\");\n-    } catch (...) {\n-        PrintException(NULL, \"main()\");\n-    }\n-    return 0;\n-}\n-#endif\n-\n const CRPCTable tableRPC;",
        "previous_filename": "src/bitcoinrpc.cpp"
      },
      {
        "sha": "639d53067a46afc1b87d0f7f3a5b727a7680c430",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -1478,3 +1478,113 @@ void RenameThread(const char* name)\n     (void)name;\n #endif\n }\n+\n+// Core-specific options shared between UI, daemon and RPC client\n+std::string HelpMessage(HelpMessageMode hmm)\n+{\n+    string strUsage = _(\"Options:\") + \"\\n\";\n+    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n+    strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n+    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n+    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n+\n+    if(hmm == HMM_BITCOIND || hmm == HMM_BITCOIN_QT)\n+    {\n+        strUsage += \"  -pid=<file>            \" + _(\"Specify pid file (default: bitcoind.pid)\") + \"\\n\";\n+        strUsage += \"  -gen                   \" + _(\"Generate coins (default: 0)\") + \"\\n\";\n+        strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \"\\n\";\n+        strUsage += \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\";\n+        strUsage += \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\";\n+        strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\";\n+        strUsage += \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\";\n+        strUsage += \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\";\n+        strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\";\n+        strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\";\n+        strUsage += \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\";\n+        strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n+        strUsage += \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\";\n+        strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n+        strUsage += \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\";\n+        strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\";\n+        strUsage += \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\";\n+        strUsage += \"  -checkpoints           \" + _(\"Only accept block chain matching built-in checkpoints (default: 1)\") + \"\\n\";\n+        strUsage += \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n+        strUsage += \"  -bind=<addr>           \" + _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n+        strUsage += \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1 unless -connect)\") + \"\\n\";\n+        strUsage += \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\";\n+        strUsage += \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\";\n+        strUsage += \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\";\n+        strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\";\n+#ifdef USE_UPNP\n+#if USE_UPNP\n+        strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\";\n+#else\n+        strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\";\n+#endif\n+#endif\n+        strUsage += \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\";\n+        strUsage += \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\";\n+        strUsage += \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\";\n+        strUsage += \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\";\n+        strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n+        strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n+        strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n+                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+#ifdef WIN32\n+        strUsage += \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\";\n+#endif\n+    }\n+\n+    if (hmm == HMM_BITCOIN_QT)\n+    {\n+        strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n+    }\n+\n+    if (hmm == HMM_BITCOIND)\n+    {\n+#if !defined(WIN32)\n+        strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n+#endif\n+    }\n+\n+    if (hmm == HMM_BITCOIND || hmm == HMM_BITCOIN_RPC)\n+    {\n+        strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n+    }\n+\n+    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n+    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n+    strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n+\n+    if(hmm == HMM_BITCOIND || hmm == HMM_BITCOIN_QT)\n+    {\n+        strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\";\n+        strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n+        strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n+        strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n+        strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n+        strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\";\n+        strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n+        strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\";\n+        strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\";\n+        strUsage += \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 288, 0 = all)\") + \"\\n\";\n+        strUsage += \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-4, default: 3)\") + \"\\n\";\n+        strUsage += \"  -txindex               \" + _(\"Maintain a full transaction index (default: 0)\") + \"\\n\";\n+        strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \"\\n\";\n+        strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \"\\n\";\n+        strUsage += \"  -par=<n>               \" + _(\"Set the number of script verification threads (up to 16, 0 = auto, <0 = leave that many cores free, default: 0)\") + \"\\n\";\n+\n+        strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n+        strUsage += \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\";\n+        strUsage += \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\";\n+        strUsage += \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\";\n+    }\n+\n+    strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n+    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n+    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\";\n+    strUsage += \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\";\n+    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n+\n+    return strUsage;\n+}"
      },
      {
        "sha": "d96edc366da58f0db8642437cc1c1454a3aa6445",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0bc89e011eda6620ec091523773c82d09398c82/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0bc89e011eda6620ec091523773c82d09398c82/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=f0bc89e011eda6620ec091523773c82d09398c82",
        "patch": "@@ -599,4 +599,14 @@ template <typename Callable> void TraceThread(const char* name,  Callable func)\n     }\n }\n \n+/* The help message mode determines what help message to show */\n+enum HelpMessageMode\n+{\n+    HMM_BITCOIND,\n+    HMM_BITCOIN_QT,\n+    HMM_BITCOIN_RPC\n+};\n+\n+std::string HelpMessage(HelpMessageMode mode);\n+\n #endif"
      }
    ]
  }
]