[
  {
    "sha": "3b40bff9880e9ae2817136b7d14989afccfc1937",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYjQwYmZmOTg4MGU5YWUyODE3MTM2YjdkMTQ5ODlhZmNjZmMxOTM3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-07T02:08:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-16T06:36:05Z"
      },
      "message": "Descriptor checksum",
      "tree": {
        "sha": "65325ad0dbdda14e32704dfff400196aa13d04b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65325ad0dbdda14e32704dfff400196aa13d04b8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3b40bff9880e9ae2817136b7d14989afccfc1937",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b40bff9880e9ae2817136b7d14989afccfc1937",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3b40bff9880e9ae2817136b7d14989afccfc1937",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b40bff9880e9ae2817136b7d14989afccfc1937/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "743c2f461c0e7c58b1e5c6ddfeaf4f0ff6e6ca85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/743c2f461c0e7c58b1e5c6ddfeaf4f0ff6e6ca85",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/743c2f461c0e7c58b1e5c6ddfeaf4f0ff6e6ca85"
      }
    ],
    "stats": {
      "total": 271,
      "additions": 251,
      "deletions": 20
    },
    "files": [
      {
        "sha": "43448d7222e29898178a638ff340dd6117447e66",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 3,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -20,6 +20,125 @@\n \n namespace {\n \n+////////////////////////////////////////////////////////////////////////////\n+// Checksum                                                               //\n+////////////////////////////////////////////////////////////////////////////\n+\n+// This section implements a checksum algorithm for descriptors with the\n+// following properties:\n+// * Mistakes in a descriptor string are measured in \"symbol errors\". The higher\n+//   the number of symbol errors, the harder it is to detect:\n+//   * An error substituting a character from 0123456789()[],'/*abcdefgh@:$%{} for\n+//     another in that set always counts as 1 symbol error.\n+//     * Note that hex encoded keys are covered by these characters. Xprvs and\n+//       xpubs use other characters too, but already have their own checksum\n+//       mechanism.\n+//     * Function names like \"multi()\" use other characters, but mistakes in\n+//       these would generally result in an unparseable descriptor.\n+//   * A case error always counts as 1 symbol error.\n+//   * Any other 1 character substitution error counts as 1 or 2 symbol errors.\n+// * Any 1 symbol error is always detected.\n+// * Any 2 or 3 symbol error in a descriptor of up to 49154 characters is always detected.\n+// * Any 4 symbol error in a descriptor of up to 507 characters is always detected.\n+// * Any 5 symbol error in a descriptor of up to 77 characters is always detected.\n+// * Is optimized to minimize the chance a 5 symbol error in a descriptor up to 387 characters is undetected\n+// * Random errors have a chance of 1 in 2**40 of being undetected.\n+//\n+// These properties are achieved by expanding every group of 3 (non checksum) characters into\n+// 4 GF(32) symbols, over which a cyclic code is defined.\n+\n+/*\n+ * Interprets c as 8 groups of 5 bits which are the coefficients of a degree 8 polynomial over GF(32),\n+ * multiplies that polynomial by x, computes its remainder modulo a generator, and adds the constant term val.\n+ *\n+ * This generator is G(x) = x^8 + {30}x^7 + {23}x^6 + {15}x^5 + {14}x^4 + {10}x^3 + {6}x^2 + {12}x + {9}.\n+ * It is chosen to define an cyclic error detecting code which is selected by:\n+ * - Starting from all BCH codes over GF(32) of degree 8 and below, which by construction guarantee detecting\n+ *   3 errors in windows up to 19000 symbols.\n+ * - Taking all those generators, and for degree 7 ones, extend them to degree 8 by adding all degree-1 factors.\n+ * - Selecting just the set of generators that guarantee detecting 4 errors in a window of length 512.\n+ * - Selecting one of those with best worst-case behavior for 5 errors in windows of length up to 512.\n+ *\n+ * The generator and the constants to implement it can be verified using this Sage code:\n+ *   B = GF(2) # Binary field\n+ *   BP.<b> = B[] # Polynomials over the binary field\n+ *   F_mod = b**5 + b**3 + 1\n+ *   F.<f> = GF(32, modulus=F_mod, repr='int') # GF(32) definition\n+ *   FP.<x> = F[] # Polynomials over GF(32)\n+ *   E_mod = x**3 + x + F.fetch_int(8)\n+ *   E.<e> = F.extension(E_mod) # Extension field definition\n+ *   alpha = e**2743 # Choice of an element in extension field\n+ *   for p in divisors(E.order() - 1): # Verify alpha has order 32767.\n+ *       assert((alpha**p == 1) == (p % 32767 == 0))\n+ *   G = lcm([(alpha**i).minpoly() for i in [1056,1057,1058]] + [x + 1])\n+ *   print(G) # Print out the generator\n+ *   for i in [1,2,4,8,16]: # Print out {1,2,4,8,16}*(G mod x^8), packed in hex integers.\n+ *       v = 0\n+ *       for coef in reversed((F.fetch_int(i)*(G % x**8)).coefficients(sparse=True)):\n+ *           v = v*32 + coef.integer_representation()\n+ *       print(\"0x%x\" % v)\n+ */\n+uint64_t PolyMod(uint64_t c, int val)\n+{\n+    uint8_t c0 = c >> 35;\n+    c = ((c & 0x7ffffffff) << 5) ^ val;\n+    if (c0 & 1) c ^= 0xf5dee51989;\n+    if (c0 & 2) c ^= 0xa9fdca3312;\n+    if (c0 & 4) c ^= 0x1bab10e32d;\n+    if (c0 & 8) c ^= 0x3706b1677a;\n+    if (c0 & 16) c ^= 0x644d626ffd;\n+    return c;\n+}\n+\n+std::string DescriptorChecksum(const Span<const char>& span)\n+{\n+    /** A character set designed such that:\n+     *  - The most common 'unprotected' descriptor characters (hex, keypaths) are in the first group of 32.\n+     *  - Case errors cause an offset that's a multiple of 32.\n+     *  - As many alphabetic characters are in the same group (while following the above restrictions).\n+     *\n+     * If p(x) gives the position of a character c in this character set, every group of 3 characters\n+     * (a,b,c) is encoded as the 4 symbols (p(a) & 31, p(b) & 31, p(c) & 31, (p(a) / 32) + 3 * (p(b) / 32) + 9 * (p(c) / 32).\n+     * This means that changes that only affect the lower 5 bits of the position, or only the higher 2 bits, will just\n+     * affect a single symbol.\n+     *\n+     * As a result, within-group-of-32 errors count as 1 symbol, as do cross-group errors that don't affect\n+     * the position within the groups.\n+     */\n+    static std::string INPUT_CHARSET =\n+        \"0123456789()[],'/*abcdefgh@:$%{}\"\n+        \"IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~\"\n+        \"ijklmnopqrstuvwxyzABCDEFGH`#\\\"\\\\ \";\n+\n+    /** The character set for the checksum itself (same as bech32). */\n+    static std::string CHECKSUM_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n+\n+    uint64_t c = 1;\n+    int cls = 0;\n+    int clscount = 0;\n+    for (auto ch : span) {\n+        auto pos = INPUT_CHARSET.find(ch);\n+        if (pos == std::string::npos) return \"\";\n+        c = PolyMod(c, pos & 31); // Emit a symbol for the position inside the group, for every character.\n+        cls = cls * 3 + (pos >> 5); // Accumulate the group numbers\n+        if (++clscount == 3) {\n+            // Emit an extra symbol representing the group numbers, for every 3 characters.\n+            c = PolyMod(c, cls);\n+            cls = 0;\n+            clscount = 0;\n+        }\n+    }\n+    if (clscount > 0) c = PolyMod(c, cls);\n+    for (int j = 0; j < 8; ++j) c = PolyMod(c, 0); // Shift further to determine the checksum.\n+    c ^= 1; // Prevent appending zeroes from not affecting the checksum.\n+\n+    std::string ret(8, ' ');\n+    for (int j = 0; j < 8; ++j) ret[j] = CHECKSUM_CHARSET[(c >> (5 * (7 - j))) & 31];\n+    return ret;\n+}\n+\n+std::string AddChecksum(const std::string& str) { return str + \"#\" + DescriptorChecksum(MakeSpan(str)); }\n+\n ////////////////////////////////////////////////////////////////////////////\n // Internal representation                                                //\n ////////////////////////////////////////////////////////////////////////////\n@@ -273,10 +392,15 @@ class DescriptorImpl : public Descriptor\n     {\n         std::string ret;\n         ToStringHelper(nullptr, ret, false);\n-        return ret;\n+        return AddChecksum(ret);\n     }\n \n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final\n+    {\n+        bool ret = ToStringHelper(&arg, out, true);\n+        out = AddChecksum(out);\n+        return ret;\n+    }\n \n     bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n@@ -751,11 +875,25 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n     return MakeUnique<RawDescriptor>(script);\n }\n \n+\n } // namespace\n \n-std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out)\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out, bool require_checksum)\n {\n     Span<const char> sp(descriptor.data(), descriptor.size());\n+\n+    // Checksum checks\n+    auto check_split = Split(sp, '#');\n+    if (check_split.size() > 2) return nullptr; // Multiple '#' symbols\n+    if (check_split.size() == 1 && require_checksum) return nullptr; // Missing checksum\n+    if (check_split.size() == 2) {\n+        if (check_split[1].size() != 8) return nullptr; // Unexpected length for checksum\n+        auto checksum = DescriptorChecksum(check_split[0]);\n+        if (checksum.empty()) return nullptr; // Invalid characters in payload\n+        if (!std::equal(checksum.begin(), checksum.end(), check_split[1].begin())) return nullptr; // Checksum mismatch\n+    }\n+    sp = check_split[0];\n+\n     auto ret = ParseScript(sp, ParseScriptContext::TOP, out);\n     if (sp.size() == 0 && ret) return std::unique_ptr<Descriptor>(std::move(ret));\n     return nullptr;"
      },
      {
        "sha": "907a102284c54af4bc9f0ffcfae7bbf6080e7c52",
        "filename": "src/script/descriptor.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/src/script/descriptor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/src/script/descriptor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.h?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -62,8 +62,15 @@ struct Descriptor {\n     virtual bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n };\n \n-/** Parse a descriptor string. Included private keys are put in out. Returns nullptr if parsing fails. */\n-std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out);\n+/** Parse a descriptor string. Included private keys are put in out.\n+ *\n+ * If the descriptor has a checksum, it must be valid. If require_checksum\n+ * is set, the checksum is mandatory - otherwise it is optional.\n+ *\n+ * If a parse error occurs, or the checksum is missing/invalid, or anything\n+ * else is wrong, nullptr is returned.\n+ */\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out, bool require_checksum = false);\n \n /** Find a descriptor for the specified script, using information from provider where possible.\n  *"
      },
      {
        "sha": "ff2b8d4fc93431e8ec26972c12eb123d18352cde",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 6,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -18,8 +18,8 @@ void CheckUnparsable(const std::string& prv, const std::string& pub)\n     FlatSigningProvider keys_priv, keys_pub;\n     auto parse_priv = Parse(prv, keys_priv);\n     auto parse_pub = Parse(pub, keys_pub);\n-    BOOST_CHECK(!parse_priv);\n-    BOOST_CHECK(!parse_pub);\n+    BOOST_CHECK_MESSAGE(!parse_priv, prv);\n+    BOOST_CHECK_MESSAGE(!parse_pub, pub);\n }\n \n constexpr int DEFAULT = 0;\n@@ -28,13 +28,26 @@ constexpr int HARDENED = 2; // Derivation needs access to private keys\n constexpr int UNSOLVABLE = 4; // This descriptor is not expected to be solvable\n constexpr int SIGNABLE = 8; // We can sign with this descriptor (this is not true when actual BIP32 derivation is used, as that's not integrated in our signing code)\n \n+/** Compare two descriptors. If only one of them has a checksum, the checksum is ignored. */\n+bool EqualDescriptor(std::string a, std::string b)\n+{\n+    bool a_check = (a.size() > 9 && a[a.size() - 9] == '#');\n+    bool b_check = (b.size() > 9 && b[b.size() - 9] == '#');\n+    if (a_check != b_check) {\n+        if (a_check) a = a.substr(0, a.size() - 9);\n+        if (b_check) b = b.substr(0, b.size() - 9);\n+    }\n+    return a == b;\n+}\n+\n std::string MaybeUseHInsteadOfApostrophy(std::string ret)\n {\n     if (InsecureRandBool()) {\n         while (true) {\n             auto it = ret.find(\"'\");\n             if (it != std::string::npos) {\n                 ret[it] = 'h';\n+                if (ret.size() > 9 && ret[ret.size() - 9] == '#') ret = ret.substr(0, ret.size() - 9); // Changing apostrophe to h breaks the checksum\n             } else {\n                 break;\n             }\n@@ -63,16 +76,16 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n     // Check that both versions serialize back to the public version.\n     std::string pub1 = parse_priv->ToString();\n     std::string pub2 = parse_pub->ToString();\n-    BOOST_CHECK_EQUAL(pub, pub1);\n-    BOOST_CHECK_EQUAL(pub, pub2);\n+    BOOST_CHECK(EqualDescriptor(pub, pub1));\n+    BOOST_CHECK(EqualDescriptor(pub, pub2));\n \n     // Check that both can be serialized with private key back to the private version, but not without private key.\n     std::string prv1;\n     BOOST_CHECK(parse_priv->ToPrivateString(keys_priv, prv1));\n-    BOOST_CHECK_EQUAL(prv, prv1);\n+    BOOST_CHECK(EqualDescriptor(prv, prv1));\n     BOOST_CHECK(!parse_priv->ToPrivateString(keys_pub, prv1));\n     BOOST_CHECK(parse_pub->ToPrivateString(keys_priv, prv1));\n-    BOOST_CHECK_EQUAL(prv, prv1);\n+    BOOST_CHECK(EqualDescriptor(prv, prv1));\n     BOOST_CHECK(!parse_pub->ToPrivateString(keys_pub, prv1));\n \n     // Check whether IsRange on both returns the expected result\n@@ -210,6 +223,15 @@ BOOST_AUTO_TEST_CASE(descriptor_test)\n     CheckUnparsable(\"wsh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\"); // Cannot embed P2SH inside P2WSH\n     CheckUnparsable(\"sh(sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"sh(sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\"); // Cannot embed P2SH inside P2SH\n     CheckUnparsable(\"wsh(wsh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))\", \"wsh(wsh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))\"); // Cannot embed P2WSH inside P2WSH\n+\n+    // Checksums\n+    Check(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxfy\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5t\", DEFAULT, {{\"a91445a9a622a8b0a1269944be477640eedc447bbd8487\"}}, {{0x8000006FUL,222},{0}});\n+    Check(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))\", DEFAULT, {{\"a91445a9a622a8b0a1269944be477640eedc447bbd8487\"}}, {{0x8000006FUL,222},{0}});\n+    CheckUnparsable(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#\"); // Empty checksum\n+    CheckUnparsable(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxfyq\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5tq\"); // Too long checksum\n+    CheckUnparsable(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxf\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5\"); // Too short checksum\n+    CheckUnparsable(\"sh(multi(3,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggrsrxfy\", \"sh(multi(3,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjg09x5t\"); // Error in payload\n+    CheckUnparsable(\"sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))#ggssrxfy\", \"sh(multi(2,[00000000/111'/222]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0))#tjq09x4t\"); // Error in checksum\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "29074c6af3f0bdc8134b06432778af2d458dccc6",
        "filename": "test/functional/rpc_scantxoutset.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/rpc_scantxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/rpc_scantxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_scantxoutset.py?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -97,9 +97,9 @@ def run_test(self):\n         assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": 1500}])['total_amount'], Decimal(\"28.672\"))\n \n         # Test the reported descriptors for a few matches\n-        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/*)\", \"range\": 1499}])), [\"pkh([0c5f9a1e/0'/0'/0]026dbd8b2315f296d36e6b6920b1579ca75569464875c7ebe869b536a7d9503c8c)\", \"pkh([0c5f9a1e/0'/0'/1]033e6f25d76c00bedb3a8993c7d5739ee806397f0529b1b31dda31ef890f19a60c)\"])\n-        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"])), [\"pkh([0c5f9a1e/1/1/0]03e1c5b6e650966971d7e71ef2674f80222752740fc1dfd63bbbd220d2da9bd0fb)\"])\n-        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": 1500}])), ['pkh([0c5f9a1e/1/1/0]03e1c5b6e650966971d7e71ef2674f80222752740fc1dfd63bbbd220d2da9bd0fb)', 'pkh([0c5f9a1e/1/1/1500]03832901c250025da2aebae2bfb38d5c703a57ab66ad477f9c578bfbcd78abca6f)', 'pkh([0c5f9a1e/1/1/1]030d820fc9e8211c4169be8530efbc632775d8286167afd178caaf1089b77daba7)'])\n+        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/*)\", \"range\": 1499}])), [\"pkh([0c5f9a1e/0'/0'/0]026dbd8b2315f296d36e6b6920b1579ca75569464875c7ebe869b536a7d9503c8c)#dzxw429x\", \"pkh([0c5f9a1e/0'/0'/1]033e6f25d76c00bedb3a8993c7d5739ee806397f0529b1b31dda31ef890f19a60c)#43rvceed\"])\n+        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"])), [\"pkh([0c5f9a1e/1/1/0]03e1c5b6e650966971d7e71ef2674f80222752740fc1dfd63bbbd220d2da9bd0fb)#cxmct4w8\"])\n+        assert_equal(descriptors(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/*)\", \"range\": 1500}])), ['pkh([0c5f9a1e/1/1/0]03e1c5b6e650966971d7e71ef2674f80222752740fc1dfd63bbbd220d2da9bd0fb)#cxmct4w8', 'pkh([0c5f9a1e/1/1/1500]03832901c250025da2aebae2bfb38d5c703a57ab66ad477f9c578bfbcd78abca6f)#vchwd07g', 'pkh([0c5f9a1e/1/1/1]030d820fc9e8211c4169be8530efbc632775d8286167afd178caaf1089b77daba7)#z2t3ypsa'])\n \n if __name__ == '__main__':\n     ScantxoutsetTest().main()"
      },
      {
        "sha": "29482ce01e17cf96c219f424349fcbb814013a45",
        "filename": "test/functional/test_framework/descriptors.py",
        "status": "added",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/test_framework/descriptors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/test_framework/descriptors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/descriptors.py?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -0,0 +1,55 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 Pieter Wuille\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Utility functions related to output descriptors\"\"\"\n+\n+INPUT_CHARSET = \"0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\\\"\\\\ \"\n+CHECKSUM_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n+GENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a, 0x644d626ffd]\n+\n+def descsum_polymod(symbols):\n+    \"\"\"Internal function that computes the descriptor checksum.\"\"\"\n+    chk = 1\n+    for value in symbols:\n+        top = chk >> 35\n+        chk = (chk & 0x7ffffffff) << 5 ^ value\n+        for i in range(5):\n+            chk ^= GENERATOR[i] if ((top >> i) & 1) else 0\n+    return chk\n+\n+def descsum_expand(s):\n+    \"\"\"Internal function that does the character to symbol expansion\"\"\"\n+    groups = []\n+    symbols = []\n+    for c in s:\n+        if not c in INPUT_CHARSET:\n+            return None\n+        v = INPUT_CHARSET.find(c)\n+        symbols.append(v & 31)\n+        groups.append(v >> 5)\n+        if len(groups) == 3:\n+            symbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])\n+            groups = []\n+    if len(groups) == 1:\n+        symbols.append(groups[0])\n+    elif len(groups) == 2:\n+        symbols.append(groups[0] * 3 + groups[1])\n+    return symbols\n+\n+def descsum_create(s):\n+    \"\"\"Add a checksum to a descriptor without\"\"\"\n+    symbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]\n+    checksum = descsum_polymod(symbols) ^ 1\n+    return s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 - i))) & 31] for i in range(8))\n+\n+def descsum_check(s, require=True):\n+    \"\"\"Verify that the checksum is correct in a descriptor\"\"\"\n+    if not '#' in s:\n+        return not require\n+    if s[-9] != '#':\n+        return False\n+    if not all(x in CHECKSUM_CHARSET for x in s[-8:]):\n+        return False\n+    symbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x in s[-8:]]\n+    return descsum_polymod(symbols) == 1"
      },
      {
        "sha": "027229111e092a3ce6f3ef75c565d91cfcb96d83",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b40bff9880e9ae2817136b7d14989afccfc1937/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=3b40bff9880e9ae2817136b7d14989afccfc1937",
        "patch": "@@ -54,6 +54,10 @@\n import itertools\n \n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.descriptors import (\n+    descsum_create,\n+    descsum_check,\n+)\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n@@ -167,24 +171,29 @@ def test_desc(self, node, address, multisig, typ, utxo):\n             assert_equal(deriv['path'][0], 'm')\n             key_descs[deriv['pubkey']] = '[' + deriv['master_fingerprint'] + deriv['path'][1:] + ']' + deriv['pubkey']\n \n+        # Verify the descriptor checksum against the Python implementation\n+        assert(descsum_check(info['desc']))\n+        # Verify that stripping the checksum and recreating it using Python roundtrips\n+        assert(info['desc'] == descsum_create(info['desc'][:-9]))\n+\n         if not multisig and typ == 'legacy':\n             # P2PKH\n-            assert_equal(info['desc'], \"pkh(%s)\" % key_descs[info['pubkey']])\n+            assert_equal(info['desc'], descsum_create(\"pkh(%s)\" % key_descs[info['pubkey']]))\n         elif not multisig and typ == 'p2sh-segwit':\n             # P2SH-P2WPKH\n-            assert_equal(info['desc'], \"sh(wpkh(%s))\" % key_descs[info['pubkey']])\n+            assert_equal(info['desc'], descsum_create(\"sh(wpkh(%s))\" % key_descs[info['pubkey']]))\n         elif not multisig and typ == 'bech32':\n             # P2WPKH\n-            assert_equal(info['desc'], \"wpkh(%s)\" % key_descs[info['pubkey']])\n+            assert_equal(info['desc'], descsum_create(\"wpkh(%s)\" % key_descs[info['pubkey']]))\n         elif typ == 'legacy':\n             # P2SH-multisig\n-            assert_equal(info['desc'], \"sh(multi(2,%s,%s))\" % (key_descs[info['pubkeys'][0]], key_descs[info['pubkeys'][1]]))\n+            assert_equal(info['desc'], descsum_create(\"sh(multi(2,%s,%s))\" % (key_descs[info['pubkeys'][0]], key_descs[info['pubkeys'][1]])))\n         elif typ == 'p2sh-segwit':\n             # P2SH-P2WSH-multisig\n-            assert_equal(info['desc'], \"sh(wsh(multi(2,%s,%s)))\" % (key_descs[info['embedded']['pubkeys'][0]], key_descs[info['embedded']['pubkeys'][1]]))\n+            assert_equal(info['desc'], descsum_create(\"sh(wsh(multi(2,%s,%s)))\" % (key_descs[info['embedded']['pubkeys'][0]], key_descs[info['embedded']['pubkeys'][1]])))\n         elif typ == 'bech32':\n             # P2WSH-multisig\n-            assert_equal(info['desc'], \"wsh(multi(2,%s,%s))\" % (key_descs[info['pubkeys'][0]], key_descs[info['pubkeys'][1]]))\n+            assert_equal(info['desc'], descsum_create(\"wsh(multi(2,%s,%s))\" % (key_descs[info['pubkeys'][0]], key_descs[info['pubkeys'][1]])))\n         else:\n             # Unknown type\n             assert(False)"
      }
    ]
  },
  {
    "sha": "b52cb6368869c9f6dd2cd8f309b3000de514d439",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTJjYjYzNjg4NjljOWY2ZGQyY2Q4ZjMwOWIzMDAwZGU1MTRkNDM5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-07T23:09:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-16T06:36:05Z"
      },
      "message": "Add getdescriptorinfo to compute checksum",
      "tree": {
        "sha": "0279131129fc6effa9b55d08a2e5c71eb1be1694",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0279131129fc6effa9b55d08a2e5c71eb1be1694"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b52cb6368869c9f6dd2cd8f309b3000de514d439",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b52cb6368869c9f6dd2cd8f309b3000de514d439",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b52cb6368869c9f6dd2cd8f309b3000de514d439",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b52cb6368869c9f6dd2cd8f309b3000de514d439/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3b40bff9880e9ae2817136b7d14989afccfc1937",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b40bff9880e9ae2817136b7d14989afccfc1937",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3b40bff9880e9ae2817136b7d14989afccfc1937"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 43,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bfb86aa12b8ff6452853243885d2a3d4a5757510",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b52cb6368869c9f6dd2cd8f309b3000de514d439/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b52cb6368869c9f6dd2cd8f309b3000de514d439/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=b52cb6368869c9f6dd2cd8f309b3000de514d439",
        "patch": "@@ -143,6 +143,46 @@ static UniValue createmultisig(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue getdescriptorinfo(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1) {\n+        throw std::runtime_error(\n+            RPCHelpMan{\"getdescriptorinfo\",\n+            {\"\\nAnalyses a descriptor.\\n\"},\n+            {\n+                {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The descriptor.\"},\n+            },\n+            RPCResult{\n+            \"{\\n\"\n+            \"  \\\"descriptor\\\" : \\\"desc\\\",         (string) The descriptor in canonical form, without private keys\\n\"\n+            \"  \\\"isrange\\\" : true|false,        (boolean) Whether the descriptor is ranged\\n\"\n+            \"  \\\"issolvable\\\" : true|false,     (boolean) Whether the descriptor is solvable\\n\"\n+            \"  \\\"hasprivatekeys\\\" : true|false, (boolean) Whether the input descriptor contained at least one private key\\n\"\n+            \"}\\n\"\n+            },\n+            RPCExamples{\n+                \"Analyse a descriptor\\n\" +\n+                HelpExampleCli(\"getdescriptorinfo\", \"\\\"wpkh([d34db33f/84h/0h/0h]0279be667ef9dcbbac55a06295Ce870b07029Bfcdb2dce28d959f2815b16f81798)\\\"\")\n+            }}.ToString()\n+        );\n+    }\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    FlatSigningProvider provider;\n+    auto desc = Parse(request.params[0].get_str(), provider);\n+    if (!desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid descriptor\"));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"descriptor\", desc->ToString());\n+    result.pushKV(\"isrange\", desc->IsRange());\n+    result.pushKV(\"issolvable\", desc->IsSolvable());\n+    result.pushKV(\"hasprivatekeys\", provider.keys.size() > 0);\n+    return result;\n+}\n+\n UniValue deriveaddresses(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.empty() || request.params.size() > 3) {\n@@ -564,6 +604,7 @@ static const CRPCCommand commands[] =\n     { \"util\",               \"validateaddress\",        &validateaddress,        {\"address\"} },\n     { \"util\",               \"createmultisig\",         &createmultisig,         {\"nrequired\",\"keys\",\"address_type\"} },\n     { \"util\",               \"deriveaddresses\",        &deriveaddresses,        {\"descriptor\", \"begin\", \"end\"} },\n+    { \"util\",               \"getdescriptorinfo\",      &getdescriptorinfo,      {\"descriptor\"} },\n     { \"util\",               \"verifymessage\",          &verifymessage,          {\"address\",\"signature\",\"message\"} },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, {\"privkey\",\"message\"} },\n "
      },
      {
        "sha": "380dd9c0ade0199254ab7fa5659f700521b5b936",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b52cb6368869c9f6dd2cd8f309b3000de514d439/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b52cb6368869c9f6dd2cd8f309b3000de514d439/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=b52cb6368869c9f6dd2cd8f309b3000de514d439",
        "patch": "@@ -175,6 +175,8 @@ def test_desc(self, node, address, multisig, typ, utxo):\n         assert(descsum_check(info['desc']))\n         # Verify that stripping the checksum and recreating it using Python roundtrips\n         assert(info['desc'] == descsum_create(info['desc'][:-9]))\n+        # Verify that stripping the checksum and feeding it to getdescriptorinfo roundtrips\n+        assert(info['desc'] == self.nodes[0].getdescriptorinfo(info['desc'][:-9])['descriptor'])\n \n         if not multisig and typ == 'legacy':\n             # P2PKH"
      }
    ]
  },
  {
    "sha": "be62903c417293f6217e124669e62fd2172a18f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTYyOTAzYzQxNzI5M2Y2MjE3ZTEyNDY2OWU2MmZkMjE3MmExOGYx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-13T02:56:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-16T06:36:05Z"
      },
      "message": "Make descriptor checksums mandatory in deriveaddresses and importmulti",
      "tree": {
        "sha": "c2d6f7b222060e5a466fe933d18fd07f8ea4083b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2d6f7b222060e5a466fe933d18fd07f8ea4083b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be62903c417293f6217e124669e62fd2172a18f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be62903c417293f6217e124669e62fd2172a18f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be62903c417293f6217e124669e62fd2172a18f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be62903c417293f6217e124669e62fd2172a18f1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b52cb6368869c9f6dd2cd8f309b3000de514d439",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b52cb6368869c9f6dd2cd8f309b3000de514d439",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b52cb6368869c9f6dd2cd8f309b3000de514d439"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 45,
      "deletions": 31
    },
    "files": [
      {
        "sha": "999a307e2b2e1b8c8ef2cbd492f7f49ff6753e35",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be62903c417293f6217e124669e62fd2172a18f1/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be62903c417293f6217e124669e62fd2172a18f1/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=be62903c417293f6217e124669e62fd2172a18f1",
        "patch": "@@ -207,7 +207,7 @@ UniValue deriveaddresses(const JSONRPCRequest& request)\n             },\n             RPCExamples{\n                 \"First three native segwit receive addresses\\n\" +\n-                HelpExampleCli(\"deriveaddresses\", \"\\\"wpkh([d34db33f/84h/0h/0h]xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/*)\\\" 0 2\")\n+                HelpExampleCli(\"deriveaddresses\", \"\\\"wpkh([d34db33f/84h/0h/0h]xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/*)#trd0mf0l\\\" 0 2\")\n             }}.ToString()\n         );\n     }\n@@ -233,7 +233,7 @@ UniValue deriveaddresses(const JSONRPCRequest& request)\n     }\n \n     FlatSigningProvider provider;\n-    auto desc = Parse(desc_str, provider);\n+    auto desc = Parse(desc_str, provider, /* require_checksum = */ true);\n     if (!desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid descriptor\"));\n     }"
      },
      {
        "sha": "66a52c1270bfb06b97764b423a829df42e665511",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be62903c417293f6217e124669e62fd2172a18f1/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be62903c417293f6217e124669e62fd2172a18f1/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=be62903c417293f6217e124669e62fd2172a18f1",
        "patch": "@@ -1117,7 +1117,7 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n \n     const std::string& descriptor = data[\"desc\"].get_str();\n     FlatSigningProvider keys;\n-    auto parsed_desc = Parse(descriptor, keys);\n+    auto parsed_desc = Parse(descriptor, keys, /* require_checksum = */ true);\n     if (!parsed_desc) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n     }"
      },
      {
        "sha": "c8b58cfc74c8a73338fc491372979e5208ef00fa",
        "filename": "test/functional/rpc_deriveaddresses.py",
        "status": "modified",
        "additions": 15,
        "deletions": 13,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be62903c417293f6217e124669e62fd2172a18f1/test/functional/rpc_deriveaddresses.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be62903c417293f6217e124669e62fd2172a18f1/test/functional/rpc_deriveaddresses.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deriveaddresses.py?ref=be62903c417293f6217e124669e62fd2172a18f1",
        "patch": "@@ -4,6 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the deriveaddresses rpc call.\"\"\"\n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.descriptors import descsum_create\n from test_framework.util import assert_equal, assert_raises_rpc_error\n \n class DeriveaddressesTest(BitcoinTestFramework):\n@@ -14,36 +15,37 @@ def set_test_params(self):\n     def run_test(self):\n         assert_raises_rpc_error(-5, \"Invalid descriptor\", self.nodes[0].deriveaddresses, \"a\")\n \n-        descriptor = \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"\n+        descriptor = \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)#t6wfjs64\"\n         address = \"bcrt1qjqmxmkpmxt80xz4y3746zgt0q3u3ferr34acd5\"\n-\n         assert_equal(self.nodes[0].deriveaddresses(descriptor), [address])\n \n-        descriptor_pubkey = \"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/0)\"\n-        address = \"bcrt1qjqmxmkpmxt80xz4y3746zgt0q3u3ferr34acd5\"\n+        descriptor = descriptor[:-9]\n+        assert_raises_rpc_error(-5, \"Invalid descriptor\", self.nodes[0].deriveaddresses, descriptor)\n \n+        descriptor_pubkey = \"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/0)#s9ga3alw\"\n+        address = \"bcrt1qjqmxmkpmxt80xz4y3746zgt0q3u3ferr34acd5\"\n         assert_equal(self.nodes[0].deriveaddresses(descriptor_pubkey), [address])\n \n-        ranged_descriptor = \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"\n+        ranged_descriptor = \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)#kft60nuy\"\n         assert_equal(self.nodes[0].deriveaddresses(ranged_descriptor, 0, 2), [address, \"bcrt1qhku5rq7jz8ulufe2y6fkcpnlvpsta7rq4442dy\", \"bcrt1qpgptk2gvshyl0s9lqshsmx932l9ccsv265tvaq\"])\n \n-        assert_raises_rpc_error(-8, \"Range should not be specified for an un-ranged descriptor\", self.nodes[0].deriveaddresses, \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\", 0, 2)\n+        assert_raises_rpc_error(-8, \"Range should not be specified for an un-ranged descriptor\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"), 0, 2)\n \n-        assert_raises_rpc_error(-8, \"Range must be specified for a ranged descriptor\", self.nodes[0].deriveaddresses, \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\")\n+        assert_raises_rpc_error(-8, \"Range must be specified for a ranged descriptor\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"))\n \n-        assert_raises_rpc_error(-8, \"Missing range end parameter\", self.nodes[0].deriveaddresses, \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\", 0)\n+        assert_raises_rpc_error(-8, \"Missing range end parameter\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"), 0)\n \n-        assert_raises_rpc_error(-8, \"Range end should be equal to or greater than begin\", self.nodes[0].deriveaddresses, \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\", 2, 0)\n+        assert_raises_rpc_error(-8, \"Range end should be equal to or greater than begin\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"), 2, 0)\n \n-        assert_raises_rpc_error(-8, \"Range should be greater or equal than 0\", self.nodes[0].deriveaddresses, \"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\", -1, 0)\n+        assert_raises_rpc_error(-8, \"Range should be greater or equal than 0\", self.nodes[0].deriveaddresses, descsum_create(\"wpkh(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*)\"), -1, 0)\n \n-        combo_descriptor = \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"\n+        combo_descriptor = descsum_create(\"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\")\n         assert_equal(self.nodes[0].deriveaddresses(combo_descriptor), [\"mtfUoUax9L4tzXARpw1oTGxWyoogp52KhJ\", \"mtfUoUax9L4tzXARpw1oTGxWyoogp52KhJ\", address, \"2NDvEwGfpEqJWfybzpKPHF2XH3jwoQV3D7x\"])\n \n-        hardened_without_privkey_descriptor = \"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1'/1/0)\"\n+        hardened_without_privkey_descriptor = descsum_create(\"wpkh(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1'/1/0)\")\n         assert_raises_rpc_error(-5, \"Cannot derive script without private keys\", self.nodes[0].deriveaddresses, hardened_without_privkey_descriptor)\n \n-        bare_multisig_descriptor = \"multi(1, tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/0, tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/1)\"\n+        bare_multisig_descriptor = descsum_create(\"multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/0,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/1)\")\n         assert_raises_rpc_error(-5, \"Descriptor does not have a corresponding address\", self.nodes[0].deriveaddresses, bare_multisig_descriptor)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "8e25aa7337aa4277bcf21331fd2cd04e88b1401b",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 27,
        "deletions": 15,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be62903c417293f6217e124669e62fd2172a18f1/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be62903c417293f6217e124669e62fd2172a18f1/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=be62903c417293f6217e124669e62fd2172a18f1",
        "patch": "@@ -20,6 +20,7 @@\n     OP_NOP,\n )\n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.descriptors import descsum_create\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n@@ -545,11 +546,22 @@ def run_test(self):\n \n         # Test importing of a P2SH-P2WPKH address via descriptor + private key\n         key = get_key(self.nodes[0])\n-        self.log.info(\"Should import a p2sh-p2wpkh address from descriptor and private key\")\n+        self.log.info(\"Should not import a p2sh-p2wpkh address from descriptor without checksum and private key\")\n         self.test_importmulti({\"desc\": \"sh(wpkh(\" + key.pubkey + \"))\",\n                                \"timestamp\": \"now\",\n                                \"label\": \"Descriptor import test\",\n                                \"keys\": [key.privkey]},\n+                              success=False,\n+                              error_code=-5,\n+                              error_message=\"Descriptor is invalid\")\n+\n+        # Test importing of a P2SH-P2WPKH address via descriptor + private key\n+        key = get_key(self.nodes[0])\n+        self.log.info(\"Should import a p2sh-p2wpkh address from descriptor and private key\")\n+        self.test_importmulti({\"desc\": descsum_create(\"sh(wpkh(\" + key.pubkey + \"))\"),\n+                               \"timestamp\": \"now\",\n+                               \"label\": \"Descriptor import test\",\n+                               \"keys\": [key.privkey]},\n                               success=True)\n         test_address(self.nodes[1],\n                      key.p2sh_p2wpkh_addr,\n@@ -562,15 +574,15 @@ def run_test(self):\n         addresses = [\"2N7yv4p8G8yEaPddJxY41kPihnWvs39qCMf\", \"2MsHxyb2JS3pAySeNUsJ7mNnurtpeenDzLA\"] # hdkeypath=m/0'/0'/0' and 1'\n         desc = \"sh(wpkh(\" + xpriv + \"/0'/0'/*'\" + \"))\"\n         self.log.info(\"Ranged descriptor import should fail without a specified range\")\n-        self.test_importmulti({\"desc\": desc,\n+        self.test_importmulti({\"desc\": descsum_create(desc),\n                                \"timestamp\": \"now\"},\n                               success=False,\n                               error_code=-8,\n                               error_message='Descriptor is ranged, please specify the range')\n \n         # Test importing of a ranged descriptor without keys\n         self.log.info(\"Should import the ranged descriptor with specified range as solvable\")\n-        self.test_importmulti({\"desc\": desc,\n+        self.test_importmulti({\"desc\": descsum_create(desc),\n                                \"timestamp\": \"now\",\n                                \"range\": {\"end\": 1}},\n                               success=True,\n@@ -583,7 +595,7 @@ def run_test(self):\n         # Test importing of a P2PKH address via descriptor\n         key = get_key(self.nodes[0])\n         self.log.info(\"Should import a p2pkh address from descriptor\")\n-        self.test_importmulti({\"desc\": \"pkh(\" + key.pubkey + \")\",\n+        self.test_importmulti({\"desc\": descsum_create(\"pkh(\" + key.pubkey + \")\"),\n                                \"timestamp\": \"now\",\n                                \"label\": \"Descriptor import test\"},\n                               True,\n@@ -597,7 +609,7 @@ def run_test(self):\n         # Test import fails if both desc and scriptPubKey are provided\n         key = get_key(self.nodes[0])\n         self.log.info(\"Import should fail if both scriptPubKey and desc are provided\")\n-        self.test_importmulti({\"desc\": \"pkh(\" + key.pubkey + \")\",\n+        self.test_importmulti({\"desc\": descsum_create(\"pkh(\" + key.pubkey + \")\"),\n                                \"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=False,\n@@ -616,7 +628,7 @@ def run_test(self):\n         key1 = get_key(self.nodes[0])\n         key2 = get_key(self.nodes[0])\n         self.log.info(\"Should import a 1-of-2 bare multisig from descriptor\")\n-        self.test_importmulti({\"desc\": \"multi(1,\" + key1.pubkey + \",\" + key2.pubkey + \")\",\n+        self.test_importmulti({\"desc\": descsum_create(\"multi(1,\" + key1.pubkey + \",\" + key2.pubkey + \")\"),\n                                \"timestamp\": \"now\"},\n                               success=True)\n         self.log.info(\"Should not treat individual keys from the imported bare multisig as watchonly\")\n@@ -635,7 +647,7 @@ def run_test(self):\n         pub_fpr = info['hdmasterfingerprint']\n         result = self.nodes[0].importmulti(\n             [{\n-                'desc' : \"wpkh([\" + pub_fpr + pub_keypath[1:] +\"]\" + pub + \")\",\n+                'desc' : descsum_create(\"wpkh([\" + pub_fpr + pub_keypath[1:] +\"]\" + pub + \")\"),\n                 \"timestamp\": \"now\",\n             }]\n         )\n@@ -653,7 +665,7 @@ def run_test(self):\n         priv_fpr = info['hdmasterfingerprint']\n         result = self.nodes[0].importmulti(\n             [{\n-                'desc' : \"wpkh([\" + priv_fpr + priv_keypath[1:] + \"]\" + priv + \")\",\n+                'desc' : descsum_create(\"wpkh([\" + priv_fpr + priv_keypath[1:] + \"]\" + priv + \")\"),\n                 \"timestamp\": \"now\",\n             }]\n         )\n@@ -701,12 +713,12 @@ def run_test(self):\n         pub2 = self.nodes[0].getaddressinfo(addr2)['pubkey']\n         result = wrpc.importmulti(\n             [{\n-                'desc': 'wpkh(' + pub1 + ')',\n+                'desc': descsum_create('wpkh(' + pub1 + ')'),\n                 'keypool': True,\n                 \"timestamp\": \"now\",\n             },\n             {\n-                'desc': 'wpkh(' + pub2 + ')',\n+                'desc': descsum_create('wpkh(' + pub2 + ')'),\n                 'keypool': True,\n                 \"timestamp\": \"now\",\n             }]\n@@ -727,13 +739,13 @@ def run_test(self):\n         pub2 = self.nodes[0].getaddressinfo(addr2)['pubkey']\n         result = wrpc.importmulti(\n             [{\n-                'desc': 'wpkh(' + pub1 + ')',\n+                'desc': descsum_create('wpkh(' + pub1 + ')'),\n                 'keypool': True,\n                 'internal': True,\n                 \"timestamp\": \"now\",\n             },\n             {\n-                'desc': 'wpkh(' + pub2 + ')',\n+                'desc': descsum_create('wpkh(' + pub2 + ')'),\n                 'keypool': True,\n                 'internal': True,\n                 \"timestamp\": \"now\",\n@@ -755,7 +767,7 @@ def run_test(self):\n         pub2 = self.nodes[0].getaddressinfo(addr2)['pubkey']\n         result = wrpc.importmulti(\n             [{\n-                'desc': 'wsh(multi(2,' + pub1 + ',' + pub2 + '))',\n+                'desc': descsum_create('wsh(multi(2,' + pub1 + ',' + pub2 + '))'),\n                 'keypool': True,\n                 \"timestamp\": \"now\",\n             }]\n@@ -769,7 +781,7 @@ def run_test(self):\n         assert wrpc.getwalletinfo()['private_keys_enabled']\n         result = wrpc.importmulti(\n             [{\n-                'desc': 'wpkh(' + pub1 + ')',\n+                'desc': descsum_create('wpkh(' + pub1 + ')'),\n                 'keypool': True,\n                 \"timestamp\": \"now\",\n             }]\n@@ -792,7 +804,7 @@ def run_test(self):\n         ]\n         result = wrpc.importmulti(\n             [{\n-                'desc': 'wpkh([80002067/0h/0h]' + xpub + '/*)',\n+                'desc': descsum_create('wpkh([80002067/0h/0h]' + xpub + '/*)'),\n                 'keypool': True,\n                 'timestamp': 'now',\n                 'range' : {'start': 0, 'end': 4}"
      }
    ]
  },
  {
    "sha": "fd637be8d21a606e98c037b40b268c4a1fae2244",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDYzN2JlOGQyMWE2MDZlOThjMDM3YjQwYjI2OGM0YTFmYWUyMjQ0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-08T20:03:32Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-02-16T06:36:05Z"
      },
      "message": "Add checksums to descriptors.md",
      "tree": {
        "sha": "98328da74a98bd351fd526e3c04a78335432e5b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/98328da74a98bd351fd526e3c04a78335432e5b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd637be8d21a606e98c037b40b268c4a1fae2244",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd637be8d21a606e98c037b40b268c4a1fae2244",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd637be8d21a606e98c037b40b268c4a1fae2244",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd637be8d21a606e98c037b40b268c4a1fae2244/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be62903c417293f6217e124669e62fd2172a18f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be62903c417293f6217e124669e62fd2172a18f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be62903c417293f6217e124669e62fd2172a18f1"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 18,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5dbcd95e1d0e89dfb38522cfbaaf6f2fdb16bf01",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd637be8d21a606e98c037b40b268c4a1fae2244/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd637be8d21a606e98c037b40b268c4a1fae2244/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=fd637be8d21a606e98c037b40b268c4a1fae2244",
        "patch": "@@ -39,7 +39,7 @@ Output descriptors currently support:\n \n ## Reference\n \n-Descriptors consist of several types of expressions. The top level expression is always a `SCRIPT`.\n+Descriptors consist of several types of expressions. The top level expression is either a `SCRIPT`, or `SCRIPT#CHECKSUM` where `CHECKSUM` is an 8-character alphanumeric descriptor checksum.\n \n `SCRIPT` expressions:\n - `sh(SCRIPT)` (top level only): P2SH embed the argument.\n@@ -169,3 +169,20 @@ existing Bitcoin Core wallets, a convenience function `combo` is\n provided, which takes as input a public key, and describes a set of P2PK,\n P2PKH, P2WPKH, and P2SH-P2WPH scripts for that key. In case the key is\n uncompressed, the set only includes P2PK and P2PKH scripts.\n+\n+### Checksums\n+\n+Descriptors can optionally be suffixed with a checksum to protect against\n+typos or copy-paste errors.\n+\n+These checksums consist of 8 alphanumeric characters. As long as errors are\n+restricted to substituting characters in `0123456789()[],'/*abcdefgh@:$%{}`\n+for others in that set and changes in letter case, up to 4 errors will always\n+be detected in descriptors up to 501 characters, and up to 3 errors in longer\n+ones. For larger numbers of errors, or other types of errors, there is a\n+roughly 1 in a trillion chance of not detecting the errors.\n+\n+All RPCs in Bitcoin Core will include the checksum in their output. Only\n+certain RPCs require checksums on input, including `deriveaddress` and\n+`importmulti`. The checksum for a descriptor without one can be computed\n+using the `getdescriptorinfo` RPC."
      }
    ]
  }
]