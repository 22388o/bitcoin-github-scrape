[
  {
    "sha": "679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NzlmMTFmMGYwZTZhZjZmODRhYjNjY2Q2MDFlYTA4ZTFjMmJlNjNl",
    "commit": {
      "author": {
        "name": "John Bampton",
        "email": "jbampton@users.noreply.github.com",
        "date": "2019-09-30T21:06:33Z"
      },
      "committer": {
        "name": "John Bampton",
        "email": "jbampton@users.noreply.github.com",
        "date": "2019-09-30T21:06:33Z"
      },
      "message": "Remove trailing whitespace on blank line.\n\n I ran `autopep8 --in-place --select=W293  --recursive .` to find this.",
      "tree": {
        "sha": "ef4517be995758a1fa7459ca32e0d0ea0cc878d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef4517be995758a1fa7459ca32e0d0ea0cc878d8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e/comments",
    "author": {
      "login": "jbampton",
      "id": 418747,
      "node_id": "MDQ6VXNlcjQxODc0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/418747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbampton",
      "html_url": "https://github.com/jbampton",
      "followers_url": "https://api.github.com/users/jbampton/followers",
      "following_url": "https://api.github.com/users/jbampton/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbampton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbampton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbampton/subscriptions",
      "organizations_url": "https://api.github.com/users/jbampton/orgs",
      "repos_url": "https://api.github.com/users/jbampton/repos",
      "events_url": "https://api.github.com/users/jbampton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbampton/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jbampton",
      "id": 418747,
      "node_id": "MDQ6VXNlcjQxODc0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/418747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbampton",
      "html_url": "https://github.com/jbampton",
      "followers_url": "https://api.github.com/users/jbampton/followers",
      "following_url": "https://api.github.com/users/jbampton/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbampton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbampton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbampton/subscriptions",
      "organizations_url": "https://api.github.com/users/jbampton/orgs",
      "repos_url": "https://api.github.com/users/jbampton/repos",
      "events_url": "https://api.github.com/users/jbampton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbampton/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "696b5eb1799d9ac7d6dd72134ac30df87e9df222",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/696b5eb1799d9ac7d6dd72134ac30df87e9df222",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/696b5eb1799d9ac7d6dd72134ac30df87e9df222"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 64,
      "deletions": 64
    },
    "files": [
      {
        "sha": "2ea75ff11b12687c4f284d2d8a2864f6594d42e2",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 64,
        "deletions": 64,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=679f11f0f0e6af6f84ab3ccd601ea08e1c2be63e",
        "patch": "@@ -41,13 +41,13 @@ class FrameworkInfo(object):\n         self.sourceContentsDirectory = \"\"\n         self.destinationResourcesDirectory = \"\"\n         self.destinationVersionContentsDirectory = \"\"\n-    \n+\n     def __eq__(self, other):\n         if self.__class__ == other.__class__:\n             return self.__dict__ == other.__dict__\n         else:\n             return False\n-    \n+\n     def __str__(self):\n         return \"\"\" Framework name: {}\n  Framework directory: {}\n@@ -71,51 +71,51 @@ class FrameworkInfo(object):\n        self.deployedInstallName,\n        self.sourceFilePath,\n        self.destinationDirectory)\n-    \n+\n     def isDylib(self):\n         return self.frameworkName.endswith(\".dylib\")\n-    \n+\n     def isQtFramework(self):\n         if self.isDylib():\n             return self.frameworkName.startswith(\"libQt\")\n         else:\n             return self.frameworkName.startswith(\"Qt\")\n-    \n+\n     reOLine = re.compile(r'^(.+) \\(compatibility version [0-9.]+, current version [0-9.]+\\)$')\n     bundleFrameworkDirectory = \"Contents/Frameworks\"\n     bundleBinaryDirectory = \"Contents/MacOS\"\n-    \n+\n     @classmethod\n     def fromOtoolLibraryLine(cls, line: str) -> Optional['FrameworkInfo']:\n         # Note: line must be trimmed\n         if line == \"\":\n             return None\n-        \n+\n         # Don't deploy system libraries (exception for libQtuitools and libQtlucene).\n         if line.startswith(\"/System/Library/\") or line.startswith(\"@executable_path\") or (line.startswith(\"/usr/lib/\") and \"libQt\" not in line):\n             return None\n-        \n+\n         m = cls.reOLine.match(line)\n         if m is None:\n             raise RuntimeError(\"otool line could not be parsed: \" + line)\n-        \n+\n         path = m.group(1)\n-        \n+\n         info = cls()\n         info.sourceFilePath = path\n         info.installName = path\n-        \n+\n         if path.endswith(\".dylib\"):\n             dirname, filename = os.path.split(path)\n             info.frameworkName = filename\n             info.frameworkDirectory = dirname\n             info.frameworkPath = path\n-            \n+\n             info.binaryDirectory = dirname\n             info.binaryName = filename\n             info.binaryPath = path\n             info.version = \"-\"\n-            \n+\n             info.installName = path\n             info.deployedInstallName = \"@executable_path/../Frameworks/\" + info.binaryName\n             info.sourceFilePath = path\n@@ -130,25 +130,25 @@ class FrameworkInfo(object):\n                 i += 1\n             if i == len(parts):\n                 raise RuntimeError(\"Could not find .framework or .dylib in otool line: \" + line)\n-            \n+\n             info.frameworkName = parts[i]\n             info.frameworkDirectory = \"/\".join(parts[:i])\n             info.frameworkPath = os.path.join(info.frameworkDirectory, info.frameworkName)\n-            \n+\n             info.binaryName = parts[i+3]\n             info.binaryDirectory = \"/\".join(parts[i+1:i+3])\n             info.binaryPath = os.path.join(info.binaryDirectory, info.binaryName)\n             info.version = parts[i+2]\n-            \n+\n             info.deployedInstallName = \"@executable_path/../Frameworks/\" + os.path.join(info.frameworkName, info.binaryPath)\n             info.destinationDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, info.binaryDirectory)\n-            \n+\n             info.sourceResourcesDirectory = os.path.join(info.frameworkPath, \"Resources\")\n             info.sourceContentsDirectory = os.path.join(info.frameworkPath, \"Contents\")\n             info.sourceVersionContentsDirectory = os.path.join(info.frameworkPath, \"Versions\", info.version, \"Contents\")\n             info.destinationResourcesDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, \"Resources\")\n             info.destinationVersionContentsDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, \"Versions\", info.version, \"Contents\")\n-        \n+\n         return info\n \n class ApplicationBundleInfo(object):\n@@ -166,7 +166,7 @@ class DeploymentInfo(object):\n         self.qtPath = None\n         self.pluginPath = None\n         self.deployedFrameworks = []\n-    \n+\n     def detectQtPath(self, frameworkDirectory: str):\n         parentDir = os.path.dirname(frameworkDirectory)\n         if os.path.exists(os.path.join(parentDir, \"translations\")):\n@@ -179,7 +179,7 @@ class DeploymentInfo(object):\n             pluginPath = os.path.join(self.qtPath, \"plugins\")\n             if os.path.exists(pluginPath):\n                 self.pluginPath = pluginPath\n-    \n+\n     def usesFramework(self, name: str) -> bool:\n         nameDot = \"{}.\".format(name)\n         libNameDot = \"lib{}.\".format(name)\n@@ -208,7 +208,7 @@ def getFrameworks(binaryPath: str, verbose: int) -> List[FrameworkInfo]:\n     otoolLines.pop(0) # First line is the inspected binary\n     if \".framework\" in binaryPath or binaryPath.endswith(\".dylib\"):\n         otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.\n-    \n+\n     libraries = []\n     for line in otoolLines:\n         line = line.replace(\"@loader_path\", os.path.dirname(binaryPath))\n@@ -218,7 +218,7 @@ def getFrameworks(binaryPath: str, verbose: int) -> List[FrameworkInfo]:\n                 print(\"Found framework:\")\n                 print(info)\n             libraries.append(info)\n-    \n+\n     return libraries\n \n def runInstallNameTool(action: str, *args):\n@@ -255,16 +255,16 @@ def copyFramework(framework: FrameworkInfo, path: str, verbose: int) -> Optional\n         fromPath = framework.sourceFilePath\n     toDir = os.path.join(path, framework.destinationDirectory)\n     toPath = os.path.join(toDir, framework.binaryName)\n-    \n+\n     if not os.path.exists(fromPath):\n         raise RuntimeError(\"No file at \" + fromPath)\n-    \n+\n     if os.path.exists(toPath):\n         return None # Already there\n-    \n+\n     if not os.path.exists(toDir):\n         os.makedirs(toDir)\n-    \n+\n     shutil.copy2(fromPath, toPath)\n     if verbose >= 3:\n         print(\"Copied:\", fromPath)\n@@ -306,53 +306,53 @@ def copyFramework(framework: FrameworkInfo, path: str, verbose: int) -> Optional\n             if verbose >= 3:\n                 print(\"Copied for libQtGui:\", qtMenuNibSourcePath)\n                 print(\" to:\", qtMenuNibDestinationPath)\n-    \n+\n     return toPath\n \n def deployFrameworks(frameworks: List[FrameworkInfo], bundlePath: str, binaryPath: str, strip: bool, verbose: int, deploymentInfo: Optional[DeploymentInfo] = None) -> DeploymentInfo:\n     if deploymentInfo is None:\n         deploymentInfo = DeploymentInfo()\n-    \n+\n     while len(frameworks) > 0:\n         framework = frameworks.pop(0)\n         deploymentInfo.deployedFrameworks.append(framework.frameworkName)\n-        \n+\n         if verbose >= 2:\n             print(\"Processing\", framework.frameworkName, \"...\")\n-        \n+\n         # Get the Qt path from one of the Qt frameworks\n         if deploymentInfo.qtPath is None and framework.isQtFramework():\n             deploymentInfo.detectQtPath(framework.frameworkDirectory)\n-        \n+\n         if framework.installName.startswith(\"@executable_path\") or framework.installName.startswith(bundlePath):\n             if verbose >= 2:\n                 print(framework.frameworkName, \"already deployed, skipping.\")\n             continue\n-        \n+\n         # install_name_tool the new id into the binary\n         changeInstallName(framework.installName, framework.deployedInstallName, binaryPath, verbose)\n-        \n+\n         # Copy framework to app bundle.\n         deployedBinaryPath = copyFramework(framework, bundlePath, verbose)\n         # Skip the rest if already was deployed.\n         if deployedBinaryPath is None:\n             continue\n-        \n+\n         if strip:\n             runStrip(deployedBinaryPath, verbose)\n-        \n+\n         # install_name_tool it a new id.\n         changeIdentification(framework.deployedInstallName, deployedBinaryPath, verbose)\n         # Check for framework dependencies\n         dependencies = getFrameworks(deployedBinaryPath, verbose)\n-        \n+\n         for dependency in dependencies:\n             changeInstallName(dependency.installName, dependency.deployedInstallName, deployedBinaryPath, verbose)\n-            \n+\n             # Deploy framework if necessary.\n             if dependency.frameworkName not in deploymentInfo.deployedFrameworks and dependency not in frameworks:\n                 frameworks.append(dependency)\n-    \n+\n     return deploymentInfo\n \n def deployFrameworksForAppBundle(applicationBundle: ApplicationBundleInfo, strip: bool, verbose: int) -> DeploymentInfo:\n@@ -475,30 +475,30 @@ def deployPlugins(appBundleInfo: ApplicationBundleInfo, deploymentInfo: Deployme\n                     continue\n \n             plugins.append((pluginDirectory, pluginName))\n-    \n+\n     for pluginDirectory, pluginName in plugins:\n         if verbose >= 2:\n             print(\"Processing plugin\", os.path.join(pluginDirectory, pluginName), \"...\")\n-        \n+\n         sourcePath = os.path.join(deploymentInfo.pluginPath, pluginDirectory, pluginName)\n         destinationDirectory = os.path.join(appBundleInfo.pluginPath, pluginDirectory)\n         if not os.path.exists(destinationDirectory):\n             os.makedirs(destinationDirectory)\n-        \n+\n         destinationPath = os.path.join(destinationDirectory, pluginName)\n         shutil.copy2(sourcePath, destinationPath)\n         if verbose >= 3:\n             print(\"Copied:\", sourcePath)\n             print(\" to:\", destinationPath)\n-        \n+\n         if strip:\n             runStrip(destinationPath, verbose)\n-        \n+\n         dependencies = getFrameworks(destinationPath, verbose)\n-        \n+\n         for dependency in dependencies:\n             changeInstallName(dependency.installName, dependency.deployedInstallName, destinationPath, verbose)\n-            \n+\n             # Deploy framework if necessary.\n             if dependency.frameworkName not in deploymentInfo.deployedFrameworks:\n                 deployFrameworks([dependency], appBundleInfo.path, destinationPath, strip, verbose, deploymentInfo)\n@@ -576,22 +576,22 @@ if len(config.fancy) == 1:\n         if verbose >= 1:\n             sys.stderr.write(\"Error: Could not import plistlib which is required for fancy disk images.\\n\")\n         sys.exit(1)\n-    \n+\n     p = config.fancy[0]\n     if verbose >= 3:\n         print(\"Fancy: Loading \\\"{}\\\"...\".format(p))\n     if not os.path.exists(p):\n         if verbose >= 1:\n             sys.stderr.write(\"Error: Could not find fancy disk image plist at \\\"{}\\\"\\n\".format(p))\n         sys.exit(1)\n-    \n+\n     try:\n         fancy = plistlib.readPlist(p)\n     except:\n         if verbose >= 1:\n             sys.stderr.write(\"Error: Could not parse fancy disk image plist at \\\"{}\\\"\\n\".format(p))\n         sys.exit(1)\n-    \n+\n     try:\n         assert \"window_bounds\" not in fancy or (isinstance(fancy[\"window_bounds\"], list) and len(fancy[\"window_bounds\"]) == 4)\n         assert \"background_picture\" not in fancy or isinstance(fancy[\"background_picture\"], str)\n@@ -605,7 +605,7 @@ if len(config.fancy) == 1:\n         if verbose >= 1:\n             sys.stderr.write(\"Error: Bad format of fancy disk image plist at \\\"{}\\\"\\n\".format(p))\n         sys.exit(1)\n-    \n+\n     if \"background_picture\" in fancy:\n         bp = fancy[\"background_picture\"]\n         if verbose >= 3:\n@@ -626,7 +626,7 @@ else:\n if os.path.exists(\"dist\"):\n     if verbose >= 2:\n         print(\"+ Removing old dist folder +\")\n-    \n+\n     shutil.rmtree(\"dist\")\n \n # ------------------------------------------------\n@@ -673,7 +673,7 @@ except RuntimeError as e:\n if config.plugins:\n     if verbose >= 2:\n         print(\"+ Deploying plugins +\")\n-    \n+\n     try:\n         deployPlugins(applicationBundle, deploymentInfo, config.strip, verbose)\n     except RuntimeError as e:\n@@ -760,26 +760,26 @@ if config.dmg is not None:\n             elif verbose >= 3:\n                 hdiutil_args.append(\"-verbose\")\n             run = subprocess.check_call\n-        \n+\n         for key, value in kwargs.items():\n             hdiutil_args.append(\"-\" + key)\n             if value is not True:\n                 hdiutil_args.append(str(value))\n-        \n+\n         return run(hdiutil_args, universal_newlines=True)\n-    \n+\n     if verbose >= 2:\n         if fancy is None:\n             print(\"+ Creating .dmg disk image +\")\n         else:\n             print(\"+ Preparing .dmg disk image +\")\n-    \n+\n     if config.dmg != \"\":\n         dmg_name = config.dmg\n     else:\n         spl = app_bundle_name.split(\" \")\n         dmg_name = spl[0] + \"\".join(p.capitalize() for p in spl[1:])\n-    \n+\n     if fancy is None:\n         try:\n             runHDIUtil(\"create\", dmg_name, srcfolder=\"dist\", format=\"UDBZ\", volname=volname, ov=True)\n@@ -793,14 +793,14 @@ if config.dmg is not None:\n             for file in files:\n                 size += os.path.getsize(os.path.join(path, file))\n         size += int(size * 0.15)\n-        \n+\n         if verbose >= 3:\n             print(\"Creating temp image for modification...\")\n         try:\n             runHDIUtil(\"create\", dmg_name + \".temp\", srcfolder=\"dist\", format=\"UDRW\", size=size, volname=volname, ov=True)\n         except subprocess.CalledProcessError as e:\n             sys.exit(e.returncode)\n-        \n+\n         if verbose >= 3:\n             print(\"Attaching temp image...\")\n         try:\n@@ -811,10 +811,10 @@ if config.dmg is not None:\n         m = re.search(r\"/Volumes/(.+$)\", output)\n         disk_root = m.group(0)\n         disk_name = m.group(1)\n-        \n+\n         if verbose >= 2:\n             print(\"+ Applying fancy settings +\")\n-        \n+\n         if \"background_picture\" in fancy:\n             bg_path = os.path.join(disk_root, \".background\", os.path.basename(fancy[\"background_picture\"]))\n             os.mkdir(os.path.dirname(bg_path))\n@@ -823,10 +823,10 @@ if config.dmg is not None:\n             shutil.copy2(fancy[\"background_picture\"], bg_path)\n         else:\n             bg_path = None\n-        \n+\n         if fancy.get(\"applications_symlink\", False):\n             os.symlink(\"/Applications\", os.path.join(disk_root, \"Applications\"))\n-        \n+\n         # The Python appscript package broke with OSX 10.8 and isn't being fixed.\n         # So we now build up an AppleScript string and use the osascript command\n         # to make the .dmg file pretty:\n@@ -892,12 +892,12 @@ if config.dmg is not None:\n         if verbose >= 2:\n             print(\"+ Finalizing .dmg disk image +\")\n             time.sleep(5)\n-        \n+\n         try:\n             runHDIUtil(\"convert\", dmg_name + \".temp\", format=\"UDBZ\", o=dmg_name + \".dmg\", ov=True)\n         except subprocess.CalledProcessError as e:\n             sys.exit(e.returncode)\n-        \n+\n         os.unlink(dmg_name + \".temp.dmg\")\n \n # ------------------------------------------------"
      }
    ]
  }
]