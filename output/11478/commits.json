[
  {
    "sha": "45742e20074424c50d8d5e95f0f61516dae17061",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTc0MmUyMDA3NDQyNGM1MGQ4ZDVlOTVmMGY2MTUxNmRhZTE3MDYx",
    "commit": {
      "author": {
        "name": "Pierre Rochard",
        "email": "pierre@rochard.org",
        "date": "2017-10-11T02:30:47Z"
      },
      "committer": {
        "name": "Pierre Rochard",
        "email": "pierre@rochard.org",
        "date": "2017-10-11T02:30:47Z"
      },
      "message": "Attempting to compile with ODB",
      "tree": {
        "sha": "13fa02666fd1a8da76c1da2c728688f490351f01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13fa02666fd1a8da76c1da2c728688f490351f01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45742e20074424c50d8d5e95f0f61516dae17061",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45742e20074424c50d8d5e95f0f61516dae17061",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/45742e20074424c50d8d5e95f0f61516dae17061",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45742e20074424c50d8d5e95f0f61516dae17061/comments",
    "author": {
      "login": "PierreRochard",
      "id": 6299681,
      "node_id": "MDQ6VXNlcjYyOTk2ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6299681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PierreRochard",
      "html_url": "https://github.com/PierreRochard",
      "followers_url": "https://api.github.com/users/PierreRochard/followers",
      "following_url": "https://api.github.com/users/PierreRochard/following{/other_user}",
      "gists_url": "https://api.github.com/users/PierreRochard/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PierreRochard/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PierreRochard/subscriptions",
      "organizations_url": "https://api.github.com/users/PierreRochard/orgs",
      "repos_url": "https://api.github.com/users/PierreRochard/repos",
      "events_url": "https://api.github.com/users/PierreRochard/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PierreRochard/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "PierreRochard",
      "id": 6299681,
      "node_id": "MDQ6VXNlcjYyOTk2ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6299681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PierreRochard",
      "html_url": "https://github.com/PierreRochard",
      "followers_url": "https://api.github.com/users/PierreRochard/followers",
      "following_url": "https://api.github.com/users/PierreRochard/following{/other_user}",
      "gists_url": "https://api.github.com/users/PierreRochard/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PierreRochard/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PierreRochard/subscriptions",
      "organizations_url": "https://api.github.com/users/PierreRochard/orgs",
      "repos_url": "https://api.github.com/users/PierreRochard/repos",
      "events_url": "https://api.github.com/users/PierreRochard/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PierreRochard/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e022463a4b238750476430d08b45bc9171791e6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e022463a4b238750476430d08b45bc9171791e6f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e022463a4b238750476430d08b45bc9171791e6f"
      }
    ],
    "stats": {
      "total": 1207,
      "additions": 1207,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8b4f8ee7f4e8e60fc361b7b5b13c0a7c9bebb2f9",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -168,6 +168,9 @@ BITCOIN_CORE_H = \\\n   wallet/rpcwallet.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n+  wallet/sql/database.h \\\n+  wallet/sql/transactions.h \\\n+  wallet/sql/transactions.hxx \\\n   warnings.h \\\n   zmq/zmqabstractnotifier.h \\\n   zmq/zmqconfig.h\\"
      },
      {
        "sha": "71b398bdea4b4a013aa692761928a9df9796e646",
        "filename": "src/wallet/sql/database.h",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/database.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/database.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/database.h?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,21 @@\n+#ifndef ENTERPRISE_DATABASE_H\n+#define ENTERPRISE_DATABASE_H\n+\n+#include <odb/database.hxx>\n+#include <odb/pgsql/database.hxx>\n+\n+inline std::auto_ptr<odb::database>\n+create_database ()\n+{\n+    using namespace std;\n+    using namespace odb::core;\n+\n+    int argc(5);\n+    char *argv[] = {\"./driver\", \"--user\", \"odb_test\", \"--database\", \"odb_test\"};\n+\n+    auto_ptr<database> db (new odb::pgsql::database (argc, argv));\n+\n+    return db;\n+}\n+\n+#endif\n\\ No newline at end of file"
      },
      {
        "sha": "1c6bed9704c22cecc7263a849a019a8637dfafd2",
        "filename": "src/wallet/sql/transactions-odb.cxx",
        "status": "added",
        "additions": 750,
        "deletions": 0,
        "changes": 750,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.cxx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.cxx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/transactions-odb.cxx?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,750 @@\n+// This file was generated by ODB, object-relational mapping (ORM)\n+// compiler for C++.\n+//\n+\n+#include <odb/pre.hxx>\n+\n+#include \"transactions-odb.hxx\"\n+\n+#include <cassert>\n+#include <cstring>  // std::memcpy\n+\n+\n+#include <odb/pgsql/traits.hxx>\n+#include <odb/pgsql/database.hxx>\n+#include <odb/pgsql/transaction.hxx>\n+#include <odb/pgsql/connection.hxx>\n+#include <odb/pgsql/statement.hxx>\n+#include <odb/pgsql/statement-cache.hxx>\n+#include <odb/pgsql/simple-object-statements.hxx>\n+#include <odb/pgsql/container-statements.hxx>\n+#include <odb/pgsql/exceptions.hxx>\n+#include <odb/pgsql/simple-object-result.hxx>\n+\n+namespace odb\n+{\n+  // transaction\n+  //\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  persist_statement_name[] = \"persist_transaction\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  find_statement_name[] = \"find_transaction\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  update_statement_name[] = \"update_transaction\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  erase_statement_name[] = \"erase_transaction\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  query_statement_name[] = \"query_transaction\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::\n+  erase_query_statement_name[] = \"erase_query_transaction\";\n+\n+  const unsigned int access::object_traits_impl< ::transaction, id_pgsql >::\n+  persist_statement_types[] =\n+  {\n+    pgsql::text_oid,\n+    pgsql::int4_oid\n+  };\n+\n+  const unsigned int access::object_traits_impl< ::transaction, id_pgsql >::\n+  find_statement_types[] =\n+  {\n+    pgsql::int4_oid\n+  };\n+\n+  const unsigned int access::object_traits_impl< ::transaction, id_pgsql >::\n+  update_statement_types[] =\n+  {\n+    pgsql::text_oid,\n+    pgsql::int4_oid,\n+    pgsql::int4_oid\n+  };\n+\n+  struct access::object_traits_impl< ::transaction, id_pgsql >::extra_statement_cache_type\n+  {\n+    extra_statement_cache_type (\n+      pgsql::connection&,\n+      image_type&,\n+      id_image_type&,\n+      pgsql::binding&,\n+      pgsql::binding&,\n+      pgsql::native_binding&,\n+      const unsigned int*)\n+    {\n+    }\n+  };\n+\n+  access::object_traits_impl< ::transaction, id_pgsql >::id_type\n+  access::object_traits_impl< ::transaction, id_pgsql >::\n+  id (const id_image_type& i)\n+  {\n+    pgsql::database* db (0);\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    id_type id;\n+    {\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_value (\n+        id,\n+        i.id_value,\n+        i.id_null);\n+    }\n+\n+    return id;\n+  }\n+\n+  access::object_traits_impl< ::transaction, id_pgsql >::id_type\n+  access::object_traits_impl< ::transaction, id_pgsql >::\n+  id (const image_type& i)\n+  {\n+    pgsql::database* db (0);\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    id_type id;\n+    {\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_value (\n+        id,\n+        i.id_value,\n+        i.id_null);\n+    }\n+\n+    return id;\n+  }\n+\n+  bool access::object_traits_impl< ::transaction, id_pgsql >::\n+  grow (image_type& i,\n+        bool* t)\n+  {\n+    ODB_POTENTIALLY_UNUSED (i);\n+    ODB_POTENTIALLY_UNUSED (t);\n+\n+    bool grew (false);\n+\n+    // id_\n+    //\n+    t[0UL] = 0;\n+\n+    // txid_\n+    //\n+    if (t[1UL])\n+    {\n+      i.txid_value.capacity (i.txid_size);\n+      grew = true;\n+    }\n+\n+    // satoshis_\n+    //\n+    t[2UL] = 0;\n+\n+    return grew;\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  bind (pgsql::bind* b,\n+        image_type& i,\n+        pgsql::statement_kind sk)\n+  {\n+    ODB_POTENTIALLY_UNUSED (sk);\n+\n+    using namespace pgsql;\n+\n+    std::size_t n (0);\n+\n+    // id_\n+    //\n+    if (sk != statement_insert && sk != statement_update)\n+    {\n+      b[n].type = pgsql::bind::integer;\n+      b[n].buffer = &i.id_value;\n+      b[n].is_null = &i.id_null;\n+      n++;\n+    }\n+\n+    // txid_\n+    //\n+    b[n].type = pgsql::bind::text;\n+    b[n].buffer = i.txid_value.data ();\n+    b[n].capacity = i.txid_value.capacity ();\n+    b[n].size = &i.txid_size;\n+    b[n].is_null = &i.txid_null;\n+    n++;\n+\n+    // satoshis_\n+    //\n+    b[n].type = pgsql::bind::integer;\n+    b[n].buffer = &i.satoshis_value;\n+    b[n].is_null = &i.satoshis_null;\n+    n++;\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  bind (pgsql::bind* b, id_image_type& i)\n+  {\n+    std::size_t n (0);\n+    b[n].type = pgsql::bind::integer;\n+    b[n].buffer = &i.id_value;\n+    b[n].is_null = &i.id_null;\n+  }\n+\n+  bool access::object_traits_impl< ::transaction, id_pgsql >::\n+  init (image_type& i,\n+        const object_type& o,\n+        pgsql::statement_kind sk)\n+  {\n+    ODB_POTENTIALLY_UNUSED (i);\n+    ODB_POTENTIALLY_UNUSED (o);\n+    ODB_POTENTIALLY_UNUSED (sk);\n+\n+    using namespace pgsql;\n+\n+    bool grew (false);\n+\n+    // txid_\n+    //\n+    {\n+      ::std::string const& v =\n+        o.txid_;\n+\n+      bool is_null (false);\n+      std::size_t size (0);\n+      std::size_t cap (i.txid_value.capacity ());\n+      pgsql::value_traits<\n+          ::std::string,\n+          pgsql::id_string >::set_image (\n+        i.txid_value,\n+        size,\n+        is_null,\n+        v);\n+      i.txid_null = is_null;\n+      i.txid_size = size;\n+      grew = grew || (cap != i.txid_value.capacity ());\n+    }\n+\n+    // satoshis_\n+    //\n+    {\n+      unsigned int const& v =\n+        o.satoshis_;\n+\n+      bool is_null (false);\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_image (\n+        i.satoshis_value, is_null, v);\n+      i.satoshis_null = is_null;\n+    }\n+\n+    return grew;\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  init (object_type& o,\n+        const image_type& i,\n+        database* db)\n+  {\n+    ODB_POTENTIALLY_UNUSED (o);\n+    ODB_POTENTIALLY_UNUSED (i);\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    // id_\n+    //\n+    {\n+      unsigned int& v =\n+        o.id_;\n+\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_value (\n+        v,\n+        i.id_value,\n+        i.id_null);\n+    }\n+\n+    // txid_\n+    //\n+    {\n+      ::std::string& v =\n+        o.txid_;\n+\n+      pgsql::value_traits<\n+          ::std::string,\n+          pgsql::id_string >::set_value (\n+        v,\n+        i.txid_value,\n+        i.txid_size,\n+        i.txid_null);\n+    }\n+\n+    // satoshis_\n+    //\n+    {\n+      unsigned int& v =\n+        o.satoshis_;\n+\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_value (\n+        v,\n+        i.satoshis_value,\n+        i.satoshis_null);\n+    }\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  init (id_image_type& i, const id_type& id)\n+  {\n+    {\n+      bool is_null (false);\n+      pgsql::value_traits<\n+          unsigned int,\n+          pgsql::id_integer >::set_image (\n+        i.id_value, is_null, id);\n+      i.id_null = is_null;\n+    }\n+  }\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::persist_statement[] =\n+  \"INSERT INTO \\\"transaction\\\" \"\n+  \"(\\\"id\\\", \"\n+  \"\\\"txid\\\", \"\n+  \"\\\"satoshis\\\") \"\n+  \"VALUES \"\n+  \"(DEFAULT, $1, $2) \"\n+  \"RETURNING \\\"id\\\"\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::find_statement[] =\n+  \"SELECT \"\n+  \"\\\"transaction\\\".\\\"id\\\", \"\n+  \"\\\"transaction\\\".\\\"txid\\\", \"\n+  \"\\\"transaction\\\".\\\"satoshis\\\" \"\n+  \"FROM \\\"transaction\\\" \"\n+  \"WHERE \\\"transaction\\\".\\\"id\\\"=$1\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::update_statement[] =\n+  \"UPDATE \\\"transaction\\\" \"\n+  \"SET \"\n+  \"\\\"txid\\\"=$1, \"\n+  \"\\\"satoshis\\\"=$2 \"\n+  \"WHERE \\\"id\\\"=$3\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::erase_statement[] =\n+  \"DELETE FROM \\\"transaction\\\" \"\n+  \"WHERE \\\"id\\\"=$1\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::query_statement[] =\n+  \"SELECT \"\n+  \"\\\"transaction\\\".\\\"id\\\", \"\n+  \"\\\"transaction\\\".\\\"txid\\\", \"\n+  \"\\\"transaction\\\".\\\"satoshis\\\" \"\n+  \"FROM \\\"transaction\\\"\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::erase_query_statement[] =\n+  \"DELETE FROM \\\"transaction\\\"\";\n+\n+  const char access::object_traits_impl< ::transaction, id_pgsql >::table_name[] =\n+  \"\\\"transaction\\\"\";\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  persist (database& db, object_type& obj)\n+  {\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    using namespace pgsql;\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    callback (db,\n+              static_cast<const object_type&> (obj),\n+              callback_event::pre_persist);\n+\n+    image_type& im (sts.image ());\n+    binding& imb (sts.insert_image_binding ());\n+\n+    if (init (im, obj, statement_insert))\n+      im.version++;\n+\n+    if (im.version != sts.insert_image_version () ||\n+        imb.version == 0)\n+    {\n+      bind (imb.bind, im, statement_insert);\n+      sts.insert_image_version (im.version);\n+      imb.version++;\n+    }\n+\n+    {\n+      id_image_type& i (sts.id_image ());\n+      binding& b (sts.id_image_binding ());\n+      if (i.version != sts.id_image_version () || b.version == 0)\n+      {\n+        bind (b.bind, i);\n+        sts.id_image_version (i.version);\n+        b.version++;\n+      }\n+    }\n+\n+    insert_statement& st (sts.persist_statement ());\n+    if (!st.execute ())\n+      throw object_already_persistent ();\n+\n+    obj.id_ = id (sts.id_image ());\n+\n+    callback (db,\n+              static_cast<const object_type&> (obj),\n+              callback_event::post_persist);\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  update (database& db, const object_type& obj)\n+  {\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    using namespace pgsql;\n+    using pgsql::update_statement;\n+\n+    callback (db, obj, callback_event::pre_update);\n+\n+    pgsql::transaction& tr (pgsql::transaction::current ());\n+    pgsql::connection& conn (tr.connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    const id_type& id (\n+      obj.id_);\n+    id_image_type& idi (sts.id_image ());\n+    init (idi, id);\n+\n+    image_type& im (sts.image ());\n+    if (init (im, obj, statement_update))\n+      im.version++;\n+\n+    bool u (false);\n+    binding& imb (sts.update_image_binding ());\n+    if (im.version != sts.update_image_version () ||\n+        imb.version == 0)\n+    {\n+      bind (imb.bind, im, statement_update);\n+      sts.update_image_version (im.version);\n+      imb.version++;\n+      u = true;\n+    }\n+\n+    binding& idb (sts.id_image_binding ());\n+    if (idi.version != sts.update_id_image_version () ||\n+        idb.version == 0)\n+    {\n+      if (idi.version != sts.id_image_version () ||\n+          idb.version == 0)\n+      {\n+        bind (idb.bind, idi);\n+        sts.id_image_version (idi.version);\n+        idb.version++;\n+      }\n+\n+      sts.update_id_image_version (idi.version);\n+\n+      if (!u)\n+        imb.version++;\n+    }\n+\n+    update_statement& st (sts.update_statement ());\n+    if (st.execute () == 0)\n+      throw object_not_persistent ();\n+\n+    callback (db, obj, callback_event::post_update);\n+    pointer_cache_traits::update (db, obj);\n+  }\n+\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  erase (database& db, const id_type& id)\n+  {\n+    using namespace pgsql;\n+\n+    ODB_POTENTIALLY_UNUSED (db);\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    id_image_type& i (sts.id_image ());\n+    init (i, id);\n+\n+    binding& idb (sts.id_image_binding ());\n+    if (i.version != sts.id_image_version () || idb.version == 0)\n+    {\n+      bind (idb.bind, i);\n+      sts.id_image_version (i.version);\n+      idb.version++;\n+    }\n+\n+    if (sts.erase_statement ().execute () != 1)\n+      throw object_not_persistent ();\n+\n+    pointer_cache_traits::erase (db, id);\n+  }\n+\n+  access::object_traits_impl< ::transaction, id_pgsql >::pointer_type\n+  access::object_traits_impl< ::transaction, id_pgsql >::\n+  find (database& db, const id_type& id)\n+  {\n+    using namespace pgsql;\n+\n+    {\n+      pointer_type p (pointer_cache_traits::find (db, id));\n+\n+      if (!pointer_traits::null_ptr (p))\n+        return p;\n+    }\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    statements_type::auto_lock l (sts);\n+\n+    if (l.locked ())\n+    {\n+      if (!find_ (sts, &id))\n+        return pointer_type ();\n+    }\n+\n+    pointer_type p (\n+      access::object_factory<object_type, pointer_type>::create ());\n+    pointer_traits::guard pg (p);\n+\n+    pointer_cache_traits::insert_guard ig (\n+      pointer_cache_traits::insert (db, id, p));\n+\n+    object_type& obj (pointer_traits::get_ref (p));\n+\n+    if (l.locked ())\n+    {\n+      select_statement& st (sts.find_statement ());\n+      ODB_POTENTIALLY_UNUSED (st);\n+\n+      callback (db, obj, callback_event::pre_load);\n+      init (obj, sts.image (), &db);\n+      load_ (sts, obj, false);\n+      sts.load_delayed (0);\n+      l.unlock ();\n+      callback (db, obj, callback_event::post_load);\n+      pointer_cache_traits::load (ig.position ());\n+    }\n+    else\n+      sts.delay_load (id, obj, ig.position ());\n+\n+    ig.release ();\n+    pg.release ();\n+    return p;\n+  }\n+\n+  bool access::object_traits_impl< ::transaction, id_pgsql >::\n+  find (database& db, const id_type& id, object_type& obj)\n+  {\n+    using namespace pgsql;\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    statements_type::auto_lock l (sts);\n+\n+    if (!find_ (sts, &id))\n+      return false;\n+\n+    select_statement& st (sts.find_statement ());\n+    ODB_POTENTIALLY_UNUSED (st);\n+\n+    reference_cache_traits::position_type pos (\n+      reference_cache_traits::insert (db, id, obj));\n+    reference_cache_traits::insert_guard ig (pos);\n+\n+    callback (db, obj, callback_event::pre_load);\n+    init (obj, sts.image (), &db);\n+    load_ (sts, obj, false);\n+    sts.load_delayed (0);\n+    l.unlock ();\n+    callback (db, obj, callback_event::post_load);\n+    reference_cache_traits::load (pos);\n+    ig.release ();\n+    return true;\n+  }\n+\n+  bool access::object_traits_impl< ::transaction, id_pgsql >::\n+  reload (database& db, object_type& obj)\n+  {\n+    using namespace pgsql;\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    statements_type::auto_lock l (sts);\n+\n+    const id_type& id  (\n+      obj.id_);\n+\n+    if (!find_ (sts, &id))\n+      return false;\n+\n+    select_statement& st (sts.find_statement ());\n+    ODB_POTENTIALLY_UNUSED (st);\n+\n+    callback (db, obj, callback_event::pre_load);\n+    init (obj, sts.image (), &db);\n+    load_ (sts, obj, true);\n+    sts.load_delayed (0);\n+    l.unlock ();\n+    callback (db, obj, callback_event::post_load);\n+    return true;\n+  }\n+\n+  bool access::object_traits_impl< ::transaction, id_pgsql >::\n+  find_ (statements_type& sts,\n+         const id_type* id)\n+  {\n+    using namespace pgsql;\n+\n+    id_image_type& i (sts.id_image ());\n+    init (i, *id);\n+\n+    binding& idb (sts.id_image_binding ());\n+    if (i.version != sts.id_image_version () || idb.version == 0)\n+    {\n+      bind (idb.bind, i);\n+      sts.id_image_version (i.version);\n+      idb.version++;\n+    }\n+\n+    image_type& im (sts.image ());\n+    binding& imb (sts.select_image_binding ());\n+\n+    if (im.version != sts.select_image_version () ||\n+        imb.version == 0)\n+    {\n+      bind (imb.bind, im, statement_select);\n+      sts.select_image_version (im.version);\n+      imb.version++;\n+    }\n+\n+    select_statement& st (sts.find_statement ());\n+\n+    st.execute ();\n+    auto_result ar (st);\n+    select_statement::result r (st.fetch ());\n+\n+    if (r == select_statement::truncated)\n+    {\n+      if (grow (im, sts.select_image_truncated ()))\n+        im.version++;\n+\n+      if (im.version != sts.select_image_version ())\n+      {\n+        bind (imb.bind, im, statement_select);\n+        sts.select_image_version (im.version);\n+        imb.version++;\n+        st.refetch ();\n+      }\n+    }\n+\n+    return r != select_statement::no_data;\n+  }\n+\n+  result< access::object_traits_impl< ::transaction, id_pgsql >::object_type >\n+  access::object_traits_impl< ::transaction, id_pgsql >::\n+  query (database&, const query_base_type& q)\n+  {\n+    using namespace pgsql;\n+    using odb::details::shared;\n+    using odb::details::shared_ptr;\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+\n+    statements_type& sts (\n+      conn.statement_cache ().find_object<object_type> ());\n+\n+    image_type& im (sts.image ());\n+    binding& imb (sts.select_image_binding ());\n+\n+    if (im.version != sts.select_image_version () ||\n+        imb.version == 0)\n+    {\n+      bind (imb.bind, im, statement_select);\n+      sts.select_image_version (im.version);\n+      imb.version++;\n+    }\n+\n+    std::string text (query_statement);\n+    if (!q.empty ())\n+    {\n+      text += \" \";\n+      text += q.clause ();\n+    }\n+\n+    q.init_parameters ();\n+    shared_ptr<select_statement> st (\n+      new (shared) select_statement (\n+        sts.connection (),\n+        query_statement_name,\n+        text,\n+        false,\n+        true,\n+        q.parameter_types (),\n+        q.parameter_count (),\n+        q.parameters_binding (),\n+        imb));\n+\n+    st->execute ();\n+    st->deallocate ();\n+\n+    shared_ptr< odb::object_result_impl<object_type> > r (\n+      new (shared) pgsql::object_result_impl<object_type> (\n+        q, st, sts, 0));\n+\n+    return result<object_type> (r);\n+  }\n+\n+  unsigned long long access::object_traits_impl< ::transaction, id_pgsql >::\n+  erase_query (database&, const query_base_type& q)\n+  {\n+    using namespace pgsql;\n+\n+    pgsql::connection& conn (\n+      pgsql::transaction::current ().connection ());\n+\n+    std::string text (erase_query_statement);\n+    if (!q.empty ())\n+    {\n+      text += ' ';\n+      text += q.clause ();\n+    }\n+\n+    q.init_parameters ();\n+    delete_statement st (\n+      conn,\n+      erase_query_statement_name,\n+      text,\n+      q.parameter_types (),\n+      q.parameter_count (),\n+      q.parameters_binding ());\n+\n+    return st.execute ();\n+  }\n+}\n+\n+#include <odb/post.hxx>"
      },
      {
        "sha": "7c607d5a3033b80535c75fc3603c8dbdd544f1c9",
        "filename": "src/wallet/sql/transactions-odb.hxx",
        "status": "added",
        "additions": 308,
        "deletions": 0,
        "changes": 308,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.hxx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.hxx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/transactions-odb.hxx?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,308 @@\n+// This file was generated by ODB, object-relational mapping (ORM)\n+// compiler for C++.\n+//\n+\n+#ifndef TRANSACTIONS_ODB_HXX\n+#define TRANSACTIONS_ODB_HXX\n+\n+#include <odb/version.hxx>\n+\n+#if (ODB_VERSION != 20400UL)\n+#error ODB runtime version mismatch\n+#endif\n+\n+#include <odb/pre.hxx>\n+\n+#include \"transactions.h\"\n+\n+#include <memory>\n+#include <cstddef>\n+\n+#include <odb/core.hxx>\n+#include <odb/traits.hxx>\n+#include <odb/callback.hxx>\n+#include <odb/wrapper-traits.hxx>\n+#include <odb/pointer-traits.hxx>\n+#include <odb/container-traits.hxx>\n+#include <odb/no-op-cache-traits.hxx>\n+#include <odb/result.hxx>\n+#include <odb/simple-object-result.hxx>\n+\n+#include <odb/details/unused.hxx>\n+#include <odb/details/shared-ptr.hxx>\n+\n+namespace odb\n+{\n+  // transaction\n+  //\n+  template <>\n+  struct class_traits< ::transaction >\n+  {\n+    static const class_kind kind = class_object;\n+  };\n+\n+  template <>\n+  class access::object_traits< ::transaction >\n+  {\n+    public:\n+    typedef ::transaction object_type;\n+    typedef ::transaction* pointer_type;\n+    typedef odb::pointer_traits<pointer_type> pointer_traits;\n+\n+    static const bool polymorphic = false;\n+\n+    typedef unsigned int id_type;\n+\n+    static const bool auto_id = true;\n+\n+    static const bool abstract = false;\n+\n+    static id_type\n+    id (const object_type&);\n+\n+    typedef\n+    no_op_pointer_cache_traits<pointer_type>\n+    pointer_cache_traits;\n+\n+    typedef\n+    no_op_reference_cache_traits<object_type>\n+    reference_cache_traits;\n+\n+    static void\n+    callback (database&, object_type&, callback_event);\n+\n+    static void\n+    callback (database&, const object_type&, callback_event);\n+  };\n+}\n+\n+#include <odb/details/buffer.hxx>\n+\n+#include <odb/pgsql/version.hxx>\n+#include <odb/pgsql/forward.hxx>\n+#include <odb/pgsql/binding.hxx>\n+#include <odb/pgsql/pgsql-types.hxx>\n+#include <odb/pgsql/query.hxx>\n+\n+namespace odb\n+{\n+  // transaction\n+  //\n+  template <typename A>\n+  struct query_columns< ::transaction, id_pgsql, A >\n+  {\n+    // id\n+    //\n+    typedef\n+    pgsql::query_column<\n+      pgsql::value_traits<\n+        unsigned int,\n+        pgsql::id_integer >::query_type,\n+      pgsql::id_integer >\n+    id_type_;\n+\n+    static const id_type_ id;\n+\n+    // txid\n+    //\n+    typedef\n+    pgsql::query_column<\n+      pgsql::value_traits<\n+        ::std::string,\n+        pgsql::id_string >::query_type,\n+      pgsql::id_string >\n+    txid_type_;\n+\n+    static const txid_type_ txid;\n+\n+    // satoshis\n+    //\n+    typedef\n+    pgsql::query_column<\n+      pgsql::value_traits<\n+        unsigned int,\n+        pgsql::id_integer >::query_type,\n+      pgsql::id_integer >\n+    satoshis_type_;\n+\n+    static const satoshis_type_ satoshis;\n+  };\n+\n+  template <typename A>\n+  const typename query_columns< ::transaction, id_pgsql, A >::id_type_\n+  query_columns< ::transaction, id_pgsql, A >::\n+  id (A::table_name, \"\\\"id\\\"\", 0);\n+\n+  template <typename A>\n+  const typename query_columns< ::transaction, id_pgsql, A >::txid_type_\n+  query_columns< ::transaction, id_pgsql, A >::\n+  txid (A::table_name, \"\\\"txid\\\"\", 0);\n+\n+  template <typename A>\n+  const typename query_columns< ::transaction, id_pgsql, A >::satoshis_type_\n+  query_columns< ::transaction, id_pgsql, A >::\n+  satoshis (A::table_name, \"\\\"satoshis\\\"\", 0);\n+\n+  template <typename A>\n+  struct pointer_query_columns< ::transaction, id_pgsql, A >:\n+    query_columns< ::transaction, id_pgsql, A >\n+  {\n+  };\n+\n+  template <>\n+  class access::object_traits_impl< ::transaction, id_pgsql >:\n+    public access::object_traits< ::transaction >\n+  {\n+    public:\n+    struct id_image_type\n+    {\n+      int id_value;\n+      bool id_null;\n+\n+      std::size_t version;\n+    };\n+\n+    struct image_type\n+    {\n+      // id_\n+      //\n+      int id_value;\n+      bool id_null;\n+\n+      // txid_\n+      //\n+      details::buffer txid_value;\n+      std::size_t txid_size;\n+      bool txid_null;\n+\n+      // satoshis_\n+      //\n+      int satoshis_value;\n+      bool satoshis_null;\n+\n+      std::size_t version;\n+    };\n+\n+    struct extra_statement_cache_type;\n+\n+    using object_traits<object_type>::id;\n+\n+    static id_type\n+    id (const id_image_type&);\n+\n+    static id_type\n+    id (const image_type&);\n+\n+    static bool\n+    grow (image_type&,\n+          bool*);\n+\n+    static void\n+    bind (pgsql::bind*,\n+          image_type&,\n+          pgsql::statement_kind);\n+\n+    static void\n+    bind (pgsql::bind*, id_image_type&);\n+\n+    static bool\n+    init (image_type&,\n+          const object_type&,\n+          pgsql::statement_kind);\n+\n+    static void\n+    init (object_type&,\n+          const image_type&,\n+          database*);\n+\n+    static void\n+    init (id_image_type&, const id_type&);\n+\n+    typedef pgsql::object_statements<object_type> statements_type;\n+\n+    typedef pgsql::query_base query_base_type;\n+\n+    static const std::size_t column_count = 3UL;\n+    static const std::size_t id_column_count = 1UL;\n+    static const std::size_t inverse_column_count = 0UL;\n+    static const std::size_t readonly_column_count = 0UL;\n+    static const std::size_t managed_optimistic_column_count = 0UL;\n+\n+    static const std::size_t separate_load_column_count = 0UL;\n+    static const std::size_t separate_update_column_count = 0UL;\n+\n+    static const bool versioned = false;\n+\n+    static const char persist_statement[];\n+    static const char find_statement[];\n+    static const char update_statement[];\n+    static const char erase_statement[];\n+    static const char query_statement[];\n+    static const char erase_query_statement[];\n+\n+    static const char table_name[];\n+\n+    static void\n+    persist (database&, object_type&);\n+\n+    static pointer_type\n+    find (database&, const id_type&);\n+\n+    static bool\n+    find (database&, const id_type&, object_type&);\n+\n+    static bool\n+    reload (database&, object_type&);\n+\n+    static void\n+    update (database&, const object_type&);\n+\n+    static void\n+    erase (database&, const id_type&);\n+\n+    static void\n+    erase (database&, const object_type&);\n+\n+    static result<object_type>\n+    query (database&, const query_base_type&);\n+\n+    static unsigned long long\n+    erase_query (database&, const query_base_type&);\n+\n+    static const char persist_statement_name[];\n+    static const char find_statement_name[];\n+    static const char update_statement_name[];\n+    static const char erase_statement_name[];\n+    static const char query_statement_name[];\n+    static const char erase_query_statement_name[];\n+\n+    static const unsigned int persist_statement_types[];\n+    static const unsigned int find_statement_types[];\n+    static const unsigned int update_statement_types[];\n+\n+    public:\n+    static bool\n+    find_ (statements_type&,\n+           const id_type*);\n+\n+    static void\n+    load_ (statements_type&,\n+           object_type&,\n+           bool reload);\n+  };\n+\n+  template <>\n+  class access::object_traits_impl< ::transaction, id_common >:\n+    public access::object_traits_impl< ::transaction, id_pgsql >\n+  {\n+  };\n+\n+  // transaction\n+  //\n+}\n+\n+#include \"transactions-odb.ixx\"\n+\n+#include <odb/post.hxx>\n+\n+#endif // TRANSACTIONS_ODB_HXX"
      },
      {
        "sha": "febc495d1210a9c1ccdedeec1e4bc6f134e3b967",
        "filename": "src/wallet/sql/transactions-odb.ixx",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.ixx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions-odb.ixx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/transactions-odb.ixx?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,61 @@\n+// This file was generated by ODB, object-relational mapping (ORM)\n+// compiler for C++.\n+//\n+\n+namespace odb\n+{\n+  // transaction\n+  //\n+\n+  inline\n+  access::object_traits< ::transaction >::id_type\n+  access::object_traits< ::transaction >::\n+  id (const object_type& o)\n+  {\n+    return o.id_;\n+  }\n+\n+  inline\n+  void access::object_traits< ::transaction >::\n+  callback (database& db, object_type& x, callback_event e)\n+  {\n+    ODB_POTENTIALLY_UNUSED (db);\n+    ODB_POTENTIALLY_UNUSED (x);\n+    ODB_POTENTIALLY_UNUSED (e);\n+  }\n+\n+  inline\n+  void access::object_traits< ::transaction >::\n+  callback (database& db, const object_type& x, callback_event e)\n+  {\n+    ODB_POTENTIALLY_UNUSED (db);\n+    ODB_POTENTIALLY_UNUSED (x);\n+    ODB_POTENTIALLY_UNUSED (e);\n+  }\n+}\n+\n+namespace odb\n+{\n+  // transaction\n+  //\n+\n+  inline\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  erase (database& db, const object_type& obj)\n+  {\n+    callback (db, obj, callback_event::pre_erase);\n+    erase (db, id (obj));\n+    callback (db, obj, callback_event::post_erase);\n+  }\n+\n+  inline\n+  void access::object_traits_impl< ::transaction, id_pgsql >::\n+  load_ (statements_type& sts,\n+         object_type& obj,\n+         bool)\n+  {\n+    ODB_POTENTIALLY_UNUSED (sts);\n+    ODB_POTENTIALLY_UNUSED (obj);\n+  }\n+}\n+"
      },
      {
        "sha": "306970f1ef8f1726293b744f4d9e65e4da41d4aa",
        "filename": "src/wallet/sql/transactions.h",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/transactions.h?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,37 @@\n+#ifndef ENTERPRISE_TRANSACTIONS_H\n+#define ENTERPRISE_TRANSACTIONS_H\n+\n+#include <odb/core.hxx>\n+\n+#pragma db object\n+\n+class transaction {\n+public:\n+    transaction(const std::string &txid,\n+                unsigned int satoshis)\n+            : txid_(txid), satoshis_(satoshis) {\n+    }\n+\n+    const std::string &\n+    txid() const {\n+        return txid_;\n+    }\n+\n+    unsigned int\n+    satoshis() const {\n+        return satoshis_;\n+    }\n+\n+private:\n+    friend class odb::access;\n+\n+    transaction() {}\n+\n+#pragma db id auto\n+    unsigned int id_;\n+\n+    std::string txid_;\n+    unsigned int satoshis_;\n+};\n+\n+#endif //ENTERPRISE_TRANSACTIONS_H"
      },
      {
        "sha": "e7f61308ccd38dd960a78d769f05682198f69e9b",
        "filename": "src/wallet/sql/transactions.sql",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions.sql",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/sql/transactions.sql",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sql/transactions.sql?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -0,0 +1,11 @@\n+/* This file was generated by ODB, object-relational mapping (ORM)\n+ * compiler for C++.\n+ */\n+\n+DROP TABLE IF EXISTS \"transaction\" CASCADE;\n+\n+CREATE TABLE \"transaction\" (\n+  \"id\" SERIAL NOT NULL PRIMARY KEY,\n+  \"txid\" TEXT NOT NULL,\n+  \"satoshis\" INTEGER NOT NULL);\n+"
      },
      {
        "sha": "c1730419a605c40d9599f39aa49f8cad482fe44c",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45742e20074424c50d8d5e95f0f61516dae17061/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=45742e20074424c50d8d5e95f0f61516dae17061",
        "patch": "@@ -15,11 +15,19 @@\n #include \"util.h\"\n #include \"utiltime.h\"\n #include \"wallet/wallet.h\"\n+#include \"wallet/sql/database.h\"\n+#include \"wallet/sql/transactions.h\"\n+#include \"wallet/sql/transactions-odb.hxx\"\n \n #include <atomic>\n \n #include <boost/thread.hpp>\n \n+#include <odb/database.hxx>\n+#include <odb/transaction.hxx>\n+\n+using namespace odb::core;\n+\n //\n // CWalletDB\n //\n@@ -48,6 +56,14 @@ bool CWalletDB::ErasePurpose(const std::string& strAddress)\n \n bool CWalletDB::WriteTx(const CWalletTx& wtx)\n {\n+    std::auto_ptr <database> db(create_database());\n+    {\n+        transactions bt(std::string(\"tx\"), 0);\n+        transaction t(db->begin());\n+        db->persist(bt);\n+        t.commit();\n+    }\n+\n     return WriteIC(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n }\n "
      }
    ]
  }
]