[
  {
    "sha": "7f63a2ec745b95f327330a93f3a1ce50a255a307",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjYzYTJlYzc0NWI5NWYzMjczMzBhOTNmM2ExY2U1MGEyNTVhMzA3",
    "commit": {
      "author": {
        "name": "Lucas Betschart",
        "email": "lucasbetschart@gmail.com",
        "date": "2015-10-16T19:55:59Z"
      },
      "committer": {
        "name": "Lucas Betschart",
        "email": "lucasbetschart@gmail.com",
        "date": "2015-12-03T15:39:25Z"
      },
      "message": "[REST] Add send raw transaction",
      "tree": {
        "sha": "2c04b98881be4215d3b97c3bddea1ca69572bb57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c04b98881be4215d3b97c3bddea1ca69572bb57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f63a2ec745b95f327330a93f3a1ce50a255a307",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niEYEABECAAYFAlZgYi0ACgkQsmXiu1DbFJQ51QCfQ8csXX02u+e8lEdnw8QwWqTJ\npLEAnRsiklSDNOABXc2mUdpNGTsPsz0A\n=1PKE\n-----END PGP SIGNATURE-----",
        "payload": "tree 2c04b98881be4215d3b97c3bddea1ca69572bb57\nparent d78a880900c15c7a28ae81e6632090f25fea7fce\nauthor Lucas Betschart <lucasbetschart@gmail.com> 1445025359 +0200\ncommitter Lucas Betschart <lucasbetschart@gmail.com> 1449157165 +0100\n\n[REST] Add send raw transaction\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f63a2ec745b95f327330a93f3a1ce50a255a307",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f63a2ec745b95f327330a93f3a1ce50a255a307",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f63a2ec745b95f327330a93f3a1ce50a255a307/comments",
    "author": {
      "login": "lclc",
      "id": 1846033,
      "node_id": "MDQ6VXNlcjE4NDYwMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1846033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lclc",
      "html_url": "https://github.com/lclc",
      "followers_url": "https://api.github.com/users/lclc/followers",
      "following_url": "https://api.github.com/users/lclc/following{/other_user}",
      "gists_url": "https://api.github.com/users/lclc/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lclc/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lclc/subscriptions",
      "organizations_url": "https://api.github.com/users/lclc/orgs",
      "repos_url": "https://api.github.com/users/lclc/repos",
      "events_url": "https://api.github.com/users/lclc/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lclc/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lclc",
      "id": 1846033,
      "node_id": "MDQ6VXNlcjE4NDYwMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1846033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lclc",
      "html_url": "https://github.com/lclc",
      "followers_url": "https://api.github.com/users/lclc/followers",
      "following_url": "https://api.github.com/users/lclc/following{/other_user}",
      "gists_url": "https://api.github.com/users/lclc/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lclc/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lclc/subscriptions",
      "organizations_url": "https://api.github.com/users/lclc/orgs",
      "repos_url": "https://api.github.com/users/lclc/repos",
      "events_url": "https://api.github.com/users/lclc/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lclc/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d78a880900c15c7a28ae81e6632090f25fea7fce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d78a880900c15c7a28ae81e6632090f25fea7fce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d78a880900c15c7a28ae81e6632090f25fea7fce"
      }
    ],
    "stats": {
      "total": 179,
      "additions": 177,
      "deletions": 2
    },
    "files": [
      {
        "sha": "97db9fba1247c4ab7e28907ad44df78797cfa87b",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f63a2ec745b95f327330a93f3a1ce50a255a307/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f63a2ec745b95f327330a93f3a1ce50a255a307/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=7f63a2ec745b95f327330a93f3a1ce50a255a307",
        "patch": "@@ -13,6 +13,15 @@ Given a transaction hash: returns a transaction in binary, hex-encoded binary, o\n \n For full TX query capability, one must enable the transaction index via \"txindex=1\" command line / configuration option.\n \n+####Send raw transaction\n+`POST /rest/tx.<bin|hex|json>`\n+\n+Parameter: transaction=\\<signed transaction\\>\n+\n+Submits transaction (serialized, hex-encoded or binary) to local node and network.\n+\n+Returns transaction id in binary, hex-encoded binary, or JSON formats, or an error if the transaction is invalid for any reason.\n+\n ####Blocks\n `GET /rest/block/<BLOCK-HASH>.<bin|hex|json>`\n `GET /rest/block/notxdetails/<BLOCK-HASH>.<bin|hex|json>`"
      },
      {
        "sha": "9f089b0b399acfdb741ceb6e21135006b57e3a9c",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f63a2ec745b95f327330a93f3a1ce50a255a307/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f63a2ec745b95f327330a93f3a1ce50a255a307/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=7f63a2ec745b95f327330a93f3a1ce50a255a307",
        "patch": "@@ -339,5 +339,91 @@ def run_test(self):\n         json_obj = json.loads(json_string)\n         assert_equal(json_obj['bestblockhash'], bb_hash)\n \n+\n+        ######################################\n+        # POST /rest/tx/: Send raw transactions\n+        ######################################\n+        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1}]\n+        outputs = { self.nodes[0].getnewaddress() : 4.99995 }\n+        raw_tx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        raw_tx   = self.nodes[2].signrawtransaction(raw_tx)\n+\n+        #########\n+        # sendrawtransaction with missing input\n+        #########\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"hex\", raw_tx['hex'], True)\n+        assert_equal(response.status, 400)\n+        error_str = response.read()\n+        assert_equal(\"Missing inputs\" in error_str, True);\n+\n+        #########\n+        # sendrawtransaction with invalid raw tx\n+        #########\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"hex\", \"invalidrawtx\", True)\n+        assert_equal(response.status, 400)\n+        error_str = response.read()\n+        assert_equal(\"TX decode failed invalidrawtx\" in error_str, True);\n+\n+        #########\n+        # sendrawtransaction as hex, requesting result as hex\n+        #########\n+        txId = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 5)\n+        self.sync_all()\n+        self.nodes[0].generate(5)\n+        self.sync_all()\n+        inputs  = [ {'txid' : txId, 'vout' : 1}]\n+        outputs = { self.nodes[0].getnewaddress() : 4.99995 }\n+        raw_tx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        raw_tx   = self.nodes[2].signrawtransaction(raw_tx)\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"hex\", raw_tx['hex'] , True)\n+        assert_equal(response.status, 200)\n+        response_str = response.read()\n+        assert_equal(self.nodes[2].sendrawtransaction(raw_tx['hex']) in response_str, True);\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        #########\n+        # sendrawtransaction with transaction that is already in the block chain\n+        #########\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"hex\", raw_tx['hex'] , True)\n+        assert_equal(response.status, 400)\n+        response_str = response.read()\n+        assert_equal(\"Transaction already in block chain\" in response_str, True);\n+\n+        #########\n+        # sendrawtransaction as hex, requesting result as json\n+        #########\n+        txId = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 5)\n+        inputs  = [ {'txid' : txId, 'vout' : 1}]\n+        outputs = { self.nodes[0].getnewaddress() : 4.99995 }\n+        raw_tx   = self.nodes[0].createrawtransaction(inputs, outputs)\n+        raw_tx   = self.nodes[0].signrawtransaction(raw_tx)\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"json\", raw_tx['hex'] , True)\n+        response_str = response.read()\n+        assert_equal(response.status, 200)\n+        assert_equal( \"{ \\\"txid\\\" : \\\"\" +self.nodes[0].sendrawtransaction(raw_tx['hex']) + \"\\\" }\" in response_str, True);\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        self.nodes[2].generate(2)\n+        self.sync_all()\n+\n+        #########\n+        # sendrawtransaction as binary, requesting result as binary\n+        #########\n+        txId = self.nodes[2].sendtoaddress(self.nodes[2].getnewaddress(), 5.0)\n+        inputs  = [ {'txid' : txId, 'vout' : 1}]\n+        outputs = { self.nodes[2].getnewaddress() : 4.99995 }\n+        raw_tx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        raw_tx   = self.nodes[2].signrawtransaction(raw_tx)\n+\n+        binaryRequest = binascii.unhexlify(raw_tx['hex'])\n+        response = http_post_call(url.hostname, url.port, '/rest/tx'+self.FORMAT_SEPARATOR+\"bin\", binaryRequest , True)\n+\n+        assert_equal(response.status, 200)\n+        response_str = binascii.hexlify(response.read())\n+        assert_equal(self.nodes[2].sendrawtransaction(raw_tx['hex']) in response_str, True);\n+\n if __name__ == '__main__':\n     RESTTest ().main ()"
      },
      {
        "sha": "d2f3bacb38fa72943fb592ee63b94290b48ada9e",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 2,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f63a2ec745b95f327330a93f3a1ce50a255a307/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f63a2ec745b95f327330a93f3a1ce50a255a307/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=7f63a2ec745b95f327330a93f3a1ce50a255a307",
        "patch": "@@ -14,6 +14,8 @@\n #include \"txmempool.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n+#include \"core_io.h\"\n+#include \"consensus/validation.h\"\n \n #include <boost/algorithm/string.hpp>\n #include <boost/dynamic_bitset.hpp>\n@@ -391,12 +393,89 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     default: {\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"Output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n+    }\n+    // not reached\n+    return true;\n+}\n+\n+\n+static bool rest_tx_sendrawtx(HTTPRequest* req, const std::string& strURIPart)\n+{\n+    if (!CheckWarmup(req))\n+        return false;\n+    std::string hashStr;\n+    const RetFormat rf = ParseDataFormat(hashStr, strURIPart);\n+\n+    std::string strTx = req->ReadBody();\n+\n+    // parse parameter\n+    CTransaction tx;\n+    if(rf == RF_BINARY)\n+    {\n+        try {\n+            CDataStream bin(SER_NETWORK, PROTOCOL_VERSION);\n+            bin << strTx;\n+            bin >> tx;\n+        }\n+        catch (const std::exception&) {\n+            return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"TX decode failed %s\",strTx));\n+        }\n+    }\n+    else\n+    {\n+        if (!DecodeHexTx(tx, strTx))\n+            return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"TX decode failed %s\",strTx));\n+    }\n+    uint256 hashTx = tx.GetHash();\n+\n+    CCoinsViewCache &view = *pcoinsTip;\n+    const CCoins* existingCoins = view.AccessCoins(hashTx);\n+    bool fHaveMempool = mempool.exists(hashTx);\n+    bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;\n+    if (!fHaveMempool && !fHaveChain) {\n+        // push to local node and sync with wallets\n+        CValidationState state;\n+        bool fMissingInputs;\n+        if (!AcceptToMemoryPool(mempool, state, tx, false, &fMissingInputs, true)) {\n+            if (state.IsInvalid()) {\n+                return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n+            } else {\n+                if (fMissingInputs) {\n+                    return RESTERR(req, HTTP_BAD_REQUEST, \"Missing inputs\");\n+                }\n+                return RESTERR(req, HTTP_BAD_REQUEST, state.GetRejectReason());\n+            }\n+        }\n+    } else if (fHaveChain) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Transaction already in block chain\");\n+    }\n+    RelayTransaction(tx);\n+\n+    switch (rf) {\n+    case RF_BINARY: {\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, strprintf(\"%c\", hashTx.begin()));\n+        return true;\n+    }\n+    case RF_HEX: {\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, hashTx.GetHex() + \"\\n\");\n+        return true;\n+    }\n+    case RF_JSON: {\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strprintf(\"{ \\\"txid\\\" : \\\"%s\\\" }\", hashTx.GetHex()));\n+        return true;\n+    }\n+    default: {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Output format not found (available: .bin, .hex, .json)\");\n     }\n     }\n \n     // not reached\n-    return true; // continue to process further HTTP reqs on this cxn\n+    return true;\n }\n \n static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n@@ -600,6 +679,7 @@ static const struct {\n     bool (*handler)(HTTPRequest* req, const std::string& strReq);\n } uri_prefixes[] = {\n       {\"/rest/tx/\", rest_tx},\n+      {\"/rest/tx\", rest_tx_sendrawtx},\n       {\"/rest/block/notxdetails/\", rest_block_notxdetails},\n       {\"/rest/block/\", rest_block_extended},\n       {\"/rest/chaininfo\", rest_chaininfo},"
      }
    ]
  }
]