[
  {
    "sha": "1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYmY0YTYyY2I2MWJkNGI5MWQ5Y2Q0ZTM3OWZlYTJiOTE0Nzg2MzQy",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-06T18:12:13Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-13T20:40:56Z"
      },
      "message": "scripted-diff: rename some variables\n\nactual_target -> selection_target\nnChange -> change_and_fee\n\n-BEGIN VERIFY SCRIPT-\nsed -i -e 's/actual_target/selection_target/g' src/wallet/coinselection.cpp\nsed -i -e '2801,3691s/nChange /change_and_fee /g' src/wallet/wallet.cpp\nsed -i -e '2801,3691s/nChange,/change_and_fee,/g' src/wallet/wallet.cpp\nsed -i -e '2801,3691s/nChange;/change_and_fee;/g' src/wallet/wallet.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "3bdc8fa6615092678bf756dfcb33a3ee2eed7a78",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bdc8fa6615092678bf756dfcb33a3ee2eed7a78"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bf4a62cb61bd4b91d9cd4e379fea2b914786342/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b34bf2b42caaee7c8714c1229e877128916d914a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b34bf2b42caaee7c8714c1229e877128916d914a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b34bf2b42caaee7c8714c1229e877128916d914a"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "2228536f29b98cf5a8dd19bb36714ebafca511e5",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1bf4a62cb61bd4b91d9cd4e379fea2b914786342/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1bf4a62cb61bd4b91d9cd4e379fea2b914786342/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
        "patch": "@@ -70,7 +70,7 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_v\n \n     std::vector<bool> curr_selection; // select the utxo at this index\n     curr_selection.reserve(utxo_pool.size());\n-    CAmount actual_target = not_input_fees + target_value;\n+    CAmount selection_target = not_input_fees + target_value;\n \n     // Calculate curr_available_value\n     CAmount curr_available_value = 0;\n@@ -79,7 +79,7 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_v\n         assert(utxo.effective_value > 0);\n         curr_available_value += utxo.effective_value;\n     }\n-    if (curr_available_value < actual_target) {\n+    if (curr_available_value < selection_target) {\n         return false;\n     }\n \n@@ -94,12 +94,12 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_v\n     for (size_t i = 0; i < TOTAL_TRIES; ++i) {\n         // Conditions for starting a backtrack\n         bool backtrack = false;\n-        if (curr_value + curr_available_value < actual_target ||                // Cannot possibly reach target with the amount remaining in the curr_available_value.\n-            curr_value > actual_target + cost_of_change ||    // Selected value is out of range, go back and try other branch\n+        if (curr_value + curr_available_value < selection_target ||                // Cannot possibly reach target with the amount remaining in the curr_available_value.\n+            curr_value > selection_target + cost_of_change ||    // Selected value is out of range, go back and try other branch\n             (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing\n             backtrack = true;\n-        } else if (curr_value >= actual_target) {       // Selected value is within range\n-            curr_waste += (curr_value - actual_target); // This is the excess value which is added to the waste for the below comparison\n+        } else if (curr_value >= selection_target) {       // Selected value is within range\n+            curr_waste += (curr_value - selection_target); // This is the excess value which is added to the waste for the below comparison\n             // Adding another UTXO after this check could bring the waste down if the long term fee is higher than the current fee.\n             // However we are not going to explore that because this optimization for the waste is only done when we have hit our target\n             // value. Adding any more UTXOs will be just burning the UTXO; it will go entirely to fees. Thus we aren't going to\n@@ -112,7 +112,7 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_v\n                     break;\n                 }\n             }\n-            curr_waste -= (curr_value - actual_target); // Remove the excess value as we will be selecting different coins now\n+            curr_waste -= (curr_value - selection_target); // Remove the excess value as we will be selecting different coins now\n             backtrack = true;\n         }\n "
      },
      {
        "sha": "35805bc4c944494831189e2486c7ffbffea77cfb",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1bf4a62cb61bd4b91d9cd4e379fea2b914786342/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1bf4a62cb61bd4b91d9cd4e379fea2b914786342/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
        "patch": "@@ -2990,19 +2990,19 @@ bool CWallet::CreateTransactionInternal(\n                     bnb_used = false;\n                 }\n \n-                const CAmount nChange = nValueIn - nValueToSelect;\n-                if (nChange > 0)\n+                const CAmount change_and_fee = nValueIn - nValueToSelect;\n+                if (change_and_fee > 0)\n                 {\n                     // Fill a vout to ourself\n-                    CTxOut newTxOut(nChange, scriptChange);\n+                    CTxOut newTxOut(change_and_fee, scriptChange);\n \n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    // The nChange when BnB is used is always going to go to fees.\n+                    // The change_and_fee when BnB is used is always going to go to fees.\n                     if (IsDust(newTxOut, coin_selection_params.m_discard_feerate) || bnb_used)\n                     {\n                         nChangePosInOut = -1;\n-                        nFeeRet += nChange;\n+                        nFeeRet += change_and_fee;\n                     }\n                     else\n                     {"
      }
    ]
  },
  {
    "sha": "af5867c89688b06173b295b7c32a42845ea455da",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjU4NjdjODk2ODhiMDYxNzNiMjk1YjdjMzJhNDI4NDVlYTQ1NWRh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-06T17:52:28Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-13T20:40:56Z"
      },
      "message": "Move some calculations to common code in SelectCoinsMinConf\n\nTo prepare for KnapsackSolver to use effective values, these\ncalculations are moved out of the BnB if block to allow for them to be\nshared with KnapsackSolver in the future.",
      "tree": {
        "sha": "af3c3308cae9c28c2138d0aa2343e3c857116f20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af3c3308cae9c28c2138d0aa2343e3c857116f20"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af5867c89688b06173b295b7c32a42845ea455da",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5867c89688b06173b295b7c32a42845ea455da",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af5867c89688b06173b295b7c32a42845ea455da",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5867c89688b06173b295b7c32a42845ea455da/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bf4a62cb61bd4b91d9cd4e379fea2b914786342",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1bf4a62cb61bd4b91d9cd4e379fea2b914786342"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 19,
      "deletions": 13
    },
    "files": [
      {
        "sha": "b6dc867dcb2eb77321db1b3b5630b33b15c2dc69",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af5867c89688b06173b295b7c32a42845ea455da/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af5867c89688b06173b295b7c32a42845ea455da/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=af5867c89688b06173b295b7c32a42845ea455da",
        "patch": "@@ -2399,24 +2399,30 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    if (coin_selection_params.use_bnb) {\n-        // Get the feerate for effective value.\n-        // When subtracting the fee from the outputs, we want the effective feerate to be 0\n-        CFeeRate effective_feerate{0};\n-        if (!coin_selection_params.m_subtract_fee_outputs) {\n-            effective_feerate = coin_selection_params.m_effective_feerate;\n-        }\n+    // Calculate the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n+    // Get the feerate for effective value.\n+    // When subtracting the fee from the outputs, we want the effective feerate to be 0\n+    CFeeRate effective_feerate{0};\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        effective_feerate = coin_selection_params.m_effective_feerate;\n+    }\n \n-        // Calculate cost of change\n-        CAmount cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    const CAmount change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    const CAmount cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + change_fee;\n \n-        // Calculate the fees for things that aren't inputs\n-        CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    if (coin_selection_params.use_bnb) {\n+        std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n         bnb_used = true;\n-        return SelectCoinsBnB(groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+        return SelectCoinsBnB(positive_groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n+        // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n+        // The knapsack solver currently does not use effective values, so we give GroupOutputs feerates of 0 so it sets the effective values to be the same as the real value.\n         std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n \n         bnb_used = false;"
      }
    ]
  },
  {
    "sha": "d97d25d95006725e705635530b27643363d6b2a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOTdkMjVkOTUwMDY3MjVlNzA1NjM1NTMwYjI3NjQzMzYzZDZiMmE0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-07T22:13:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-13T20:40:56Z"
      },
      "message": "Make cost_of_change part of CoinSelectionParams",
      "tree": {
        "sha": "8dff6f3264db0f87fa0c303765172cafc982c433",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8dff6f3264db0f87fa0c303765172cafc982c433"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d97d25d95006725e705635530b27643363d6b2a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d97d25d95006725e705635530b27643363d6b2a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d97d25d95006725e705635530b27643363d6b2a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d97d25d95006725e705635530b27643363d6b2a4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af5867c89688b06173b295b7c32a42845ea455da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af5867c89688b06173b295b7c32a42845ea455da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af5867c89688b06173b295b7c32a42845ea455da"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 23,
      "deletions": 16
    },
    "files": [
      {
        "sha": "e848145a51475858f89a8bf3b610a9e750361d8a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d97d25d95006725e705635530b27643363d6b2a4/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d97d25d95006725e705635530b27643363d6b2a4/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d97d25d95006725e705635530b27643363d6b2a4",
        "patch": "@@ -2409,17 +2409,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         effective_feerate = coin_selection_params.m_effective_feerate;\n     }\n \n-    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-    // For creating the change output now, we use the effective feerate.\n-    // For spending the change output in the future, we use the discard feerate for now.\n-    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-    const CAmount change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-    const CAmount cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + change_fee;\n-\n     if (coin_selection_params.use_bnb) {\n         std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n         bnb_used = true;\n-        return SelectCoinsBnB(positive_groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+        return SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n         // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n         // The knapsack solver currently does not use effective values, so we give GroupOutputs feerates of 0 so it sets the effective values to be the same as the real value.\n@@ -2885,6 +2878,16 @@ bool CWallet::CreateTransactionInternal(\n             CTxOut change_prototype_txout(0, scriptChange);\n             coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n \n+            // Get size of spending the change output\n+            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+            // as lower-bound to allow BnB to do it's thing\n+            if (change_spend_size == -1) {\n+                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+            } else {\n+                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+            }\n+\n             // Set discard feerate\n             coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n \n@@ -2907,6 +2910,14 @@ bool CWallet::CreateTransactionInternal(\n             cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n             coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n+            // Calculate the cost of change\n+            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+            // For creating the change output now, we use the effective feerate.\n+            // For spending the change output in the future, we use the discard feerate for now.\n+            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n             nFeeRet = 0;\n             bool pick_new_inputs = true;\n             CAmount nValueIn = 0;\n@@ -2972,14 +2983,6 @@ bool CWallet::CreateTransactionInternal(\n                 if (pick_new_inputs) {\n                     nValueIn = 0;\n                     setCoins.clear();\n-                    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-                    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-                    // as lower-bound to allow BnB to do it's thing\n-                    if (change_spend_size == -1) {\n-                        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-                    } else {\n-                        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-                    }\n                     if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n                         // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack."
      },
      {
        "sha": "242aea67153a05b2e02c77329ab7d7ad718ed1d8",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d97d25d95006725e705635530b27643363d6b2a4/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d97d25d95006725e705635530b27643363d6b2a4/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d97d25d95006725e705635530b27643363d6b2a4",
        "patch": "@@ -621,6 +621,10 @@ struct CoinSelectionParams\n     size_t change_output_size = 0;\n     /** Size of the input to spend a change output in virtual bytes. */\n     size_t change_spend_size = 0;\n+    /** Cost of creating the change output. */\n+    CAmount m_change_fee{0};\n+    /** Cost of creating the change output + cost of spending the change output in the future. */\n+    CAmount m_cost_of_change{0};\n     /** The targeted feerate of the transaction being built. */\n     CFeeRate m_effective_feerate;\n     /** The feerate estimate used to estimate an upper bound on what should be sufficient to spend"
      }
    ]
  },
  {
    "sha": "cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzNmMTRiMjdjMDZiN2EwZGExNDcyZjVjNzEwMGMzZjBiNzZmZDk4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-08T00:53:48Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T17:22:27Z"
      },
      "message": "Move output reductions for fee to after coin selection\n\nSimplifies CreateTransactionInternal without changing behavior. Removes\nthe pick_new_inputs variable by moving the subtract fee from amount\nimplementation to later in the loop to where it is possible to calculate\nthe fee for the transaction. This allows the fee to be subtracted from\nthe outputs within a single iteration, instead of calculating the fee in\nthe first iteration, and subtracting the fee in the second.\n\nThis also removes another scenario where a second iteration of the loop\nfinds a smaller input set (and thus smaller fees than the first\niteration) with no change and so a third iteration of the loop is done in order to make\na change output that contains the excess fees.\n\nTo handle these cases, we always create a change output which contains\nthe difference between selected input values and the recipient amounts.\nOnce the transaction fee is calculated, the change output is reduced (in\nthe normal case) or the recipient amounts are reduced (in the subtract\nfee from amount case). All of this is done in a single iteration of the\nloop.",
      "tree": {
        "sha": "242d69a5ec147c416a71e1ca56123de54940866c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/242d69a5ec147c416a71e1ca56123de54940866c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d97d25d95006725e705635530b27643363d6b2a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d97d25d95006725e705635530b27643363d6b2a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d97d25d95006725e705635530b27643363d6b2a4"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 94,
      "deletions": 130
    },
    "files": [
      {
        "sha": "51ff683c2ec146dc82663223f638e596a6e3a9a4",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 130,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
        "patch": "@@ -2834,7 +2834,6 @@ bool CWallet::CreateTransactionInternal(\n \n     CMutableTransaction txNew;\n     FeeCalculation feeCalc;\n-    CAmount nFeeNeeded;\n     std::pair<int64_t, int64_t> tx_sizes;\n     int nBytes;\n     {\n@@ -2919,7 +2918,6 @@ bool CWallet::CreateTransactionInternal(\n             coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n             nFeeRet = 0;\n-            bool pick_new_inputs = true;\n             CAmount nValueIn = 0;\n \n             // BnB selector is the only selector used when this is true.\n@@ -2932,7 +2930,6 @@ bool CWallet::CreateTransactionInternal(\n                 nChangePosInOut = nChangePosRequest;\n                 txNew.vin.clear();\n                 txNew.vout.clear();\n-                bool fFirst = true;\n \n                 CAmount nValueToSelect = nValue;\n                 if (nSubtractFeeFromAmount == 0)\n@@ -2946,169 +2943,136 @@ bool CWallet::CreateTransactionInternal(\n                 {\n                     CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        assert(nSubtractFeeFromAmount != 0);\n-                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n-                        }\n-                    }\n-                    // Include the fee cost for outputs. Note this is only used for BnB right now\n+                    // Include the fee cost for outputs.\n                     if (!coin_selection_params.m_subtract_fee_outputs) {\n                         coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n                     }\n \n                     if (IsDust(txout, chain().relayDustFee()))\n                     {\n-                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n-                        {\n-                            if (txout.nValue < 0)\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            else\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                        }\n-                        else\n-                            error = _(\"Transaction amount too small\");\n+                        error = _(\"Transaction amount too small\");\n                         return false;\n                     }\n                     txNew.vout.push_back(txout);\n                 }\n \n                 // Choose coins to use\n                 bool bnb_used = false;\n-                if (pick_new_inputs) {\n-                    nValueIn = 0;\n-                    setCoins.clear();\n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n-                    {\n-                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n-                        if (bnb_used) {\n-                            coin_selection_params.use_bnb = false;\n-                            continue;\n-                        }\n-                        else {\n-                            error = _(\"Insufficient funds\");\n-                            return false;\n-                        }\n+                nValueIn = 0;\n+                setCoins.clear();\n+                if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n+                {\n+                    // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n+                    if (bnb_used) {\n+                        coin_selection_params.use_bnb = false;\n+                        continue;\n+                    }\n+                    else {\n+                        error = _(\"Insufficient funds\");\n+                        return false;\n                     }\n-                } else {\n-                    bnb_used = false;\n                 }\n \n-                const CAmount change_and_fee = nValueIn - nValueToSelect;\n-                if (change_and_fee > 0)\n-                {\n-                    // Fill a vout to ourself\n-                    CTxOut newTxOut(change_and_fee, scriptChange);\n-\n-                    // Never create dust outputs; if we would, just\n-                    // add the dust to the fee.\n-                    // The change_and_fee when BnB is used is always going to go to fees.\n-                    if (IsDust(newTxOut, coin_selection_params.m_discard_feerate) || bnb_used)\n-                    {\n-                        nChangePosInOut = -1;\n-                        nFeeRet += change_and_fee;\n-                    }\n-                    else\n-                    {\n-                        if (nChangePosInOut == -1)\n-                        {\n-                            // Insert change txn at random position:\n-                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                        }\n-                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                        {\n-                            error = _(\"Change index out of range\");\n-                            return false;\n-                        }\n+                // Always make a change output\n+                // We will reduce the fee from this change output later, and remove the output if it is too small.\n+                const CAmount change_and_fee = nValueIn - nValue;\n+                assert(change_and_fee >= 0);\n+                CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n-                        txNew.vout.insert(position, newTxOut);\n-                    }\n-                } else {\n-                    nChangePosInOut = -1;\n+                if (nChangePosInOut == -1)\n+                {\n+                    // Insert change txn at random position:\n+                    nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                 }\n+                else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+                {\n+                    error = _(\"Change index out of range\");\n+                    return false;\n+                }\n+\n+                assert(nChangePosInOut != -1);\n+                auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n                 // Dummy fill vin for maximum size estimation\n                 //\n                 for (const auto& coin : setCoins) {\n                     txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n                 }\n \n+                // Calculate the transaction fee\n                 tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n                 nBytes = tx_sizes.first;\n                 if (nBytes < 0) {\n                     error = _(\"Signing transaction failed\");\n                     return false;\n                 }\n+                nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-                nFeeNeeded = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-                if (nFeeRet >= nFeeNeeded) {\n-                    // Reduce fee to only the needed amount if possible. This\n-                    // prevents potential overpayment in fees if the coins\n-                    // selected to meet nFeeNeeded result in a transaction that\n-                    // requires less fee than the prior iteration.\n-\n-                    // If we have no change and a big enough excess fee, then\n-                    // try to construct transaction again only without picking\n-                    // new inputs. We now know we only need the smaller fee\n-                    // (because of reduced tx size) and so we should add a\n-                    // change output. Only try this once.\n-                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = coin_selection_params.m_effective_feerate.GetFee(tx_size_with_change);\n-                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, coin_selection_params.m_discard_feerate);\n-                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n-                            pick_new_inputs = false;\n-                            nFeeRet = fee_needed_with_change;\n-                            continue;\n-                        }\n-                    }\n-\n-                    // If we have change output already, just increase it\n-                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                        change_position->nValue += extraFeePaid;\n-                        nFeeRet -= extraFeePaid;\n-                    }\n-                    break; // Done, enough fee included.\n-                }\n-                else if (!pick_new_inputs) {\n-                    // This shouldn't happen, we should have had enough excess\n-                    // fee to pay for the new output and still meet nFeeNeeded\n-                    // Or we should have just subtracted fee from recipients and\n-                    // nFeeNeeded should not have changed\n-                    error = _(\"Transaction fee and change calculation failed\");\n-                    return false;\n+                // Subtract fee from the change output if not subtrating it from recipient outputs\n+                CAmount fee_needed = nFeeRet;\n+                if (nSubtractFeeFromAmount == 0) {\n+                    change_position->nValue -= fee_needed;\n                 }\n \n-                // Try to reduce change to include necessary fee\n-                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n-                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                    // Only reduce change if remaining amount is still a large enough output.\n-                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n-                        change_position->nValue -= additionalFeeNeeded;\n-                        nFeeRet += additionalFeeNeeded;\n-                        break; // Done, able to increase fee from change\n-                    }\n+                // We want to drop the change to fees if:\n+                // 1. The change output would be dust\n+                // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+                CAmount change_amount = change_position->nValue;\n+                if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+                {\n+                    nChangePosInOut = -1;\n+                    change_amount = 0;\n+                    txNew.vout.erase(change_position);\n+\n+                    // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n+                    tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+                    nBytes = tx_sizes.first;\n+                    fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n                 }\n \n-                // If subtracting fee from recipients, we now know what fee we\n-                // need to subtract, we have no reason to reselect inputs\n-                if (nSubtractFeeFromAmount > 0) {\n-                    pick_new_inputs = false;\n+                // If the fee is covered, there's no need to loop or subtract from recipients\n+                if (fee_needed <= change_and_fee - change_amount) {\n+                    nFeeRet = change_and_fee - change_amount;\n+                    break;\n                 }\n \n-                // Include more fee and try again.\n-                nFeeRet = nFeeNeeded;\n-                coin_selection_params.use_bnb = false;\n-                continue;\n+                // Reduce output values for subtractFeeFromAmount\n+                if (nSubtractFeeFromAmount != 0) {\n+                    CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+                    int i = 0;\n+                    bool fFirst = true;\n+                    for (const auto& recipient : vecSend)\n+                    {\n+                        if (i == nChangePosInOut) {\n+                            ++i;\n+                        }\n+                        CTxOut& txout = txNew.vout[i];\n+\n+                        if (recipient.fSubtractFeeFromAmount)\n+                        {\n+                            txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n+\n+                            if (fFirst) // first receiver pays the remainder not divisible by output count\n+                            {\n+                                fFirst = false;\n+                                txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                            }\n+\n+                            // Error if this output is reduced to be below dust\n+                            if (IsDust(txout, chain().relayDustFee())) {\n+                                if (txout.nValue < 0) {\n+                                    error = _(\"The transaction amount is too small to pay the fee\");\n+                                } else {\n+                                    error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                                }\n+                                return false;\n+                            }\n+                        }\n+                        ++i;\n+                    }\n+                    nFeeRet = fee_needed;\n+                    break; // The fee has been deducted from the recipients, nothing left to do here\n+                }\n             }\n \n             // Give up if change keypool ran out and change is required\n@@ -3170,8 +3134,8 @@ bool CWallet::CreateTransactionInternal(\n     reservedest.KeepDestination();\n     fee_calc_out = feeCalc;\n \n-    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n-              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n+    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+              nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n               feeCalc.est.pass.start, feeCalc.est.pass.end,\n               (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) > 0.0 ? 100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) : 0.0,\n               feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,"
      }
    ]
  },
  {
    "sha": "bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZjI2ZTAxOGRlMzMyMTZkNmYwZWQwZDZmZjgyMmI5MzUzNmY3Y2Mx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-30T22:41:13Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T17:33:31Z"
      },
      "message": "Roll static tx fees into nValueToSelect instead of having it be separate\n\nThe fees for transaction overhead and recipient outputs are now included\nin nTargetValue instead of being a separate parameter. For the coin\nselection algorithms, it doesn't matter that these are separate as in\neither case, the algorithm needs to select enough to cover these fees.\n\nNote that setting nValueToSelect is changed as it now includes\nnot_input_fees. Without the change to how nValueToSelect is increased\nfor KnapsackSolver, this would result in overpaying fees. The change to\nincrease by the difference between nFeeRet and not_input_fees allows\nthis to have the same behavior as previously.\n\nAdditionally, because we assume that KnapsackSolver will always find a\nsolution that requires change (we assume that BnB always finds a\nnon-change solution), we also include the fee for the change output in\nKnapsackSolver's target. As part of this, we also use the changeless\nnFeeRet when iterating for KnapsackSolver. This is because we include\nthe change fee when doing KnapsackSolver, so nFeeRet on further\niterations won't include the change fee.",
      "tree": {
        "sha": "1e6324db98a9734b40e8b2e15961758b3bd8cdf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e6324db98a9734b40e8b2e15961758b3bd8cdf8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc3f14b27c06b7a0da1472f5c7100c3f0b76fd98"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 35,
      "deletions": 34
    },
    "files": [
      {
        "sha": "b42939ffdce28481ad37fc07ab7f190250fb60de",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "patch": "@@ -101,12 +101,11 @@ static void BnBExhaustion(benchmark::Bench& bench)\n     std::vector<OutputGroup> utxo_pool;\n     CoinSet selection;\n     CAmount value_ret = 0;\n-    CAmount not_input_fees = 0;\n \n     bench.run([&] {\n         // Benchmark\n         CAmount target = make_hard_case(17, utxo_pool);\n-        SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n+        SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret); // Should exhaust\n \n         // Cleanup\n         utxo_pool.clear();"
      },
      {
        "sha": "db770f6a457ea7d3f26fe5348908b8555c8e08ee",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "patch": "@@ -49,28 +49,25 @@ struct {\n  * @param const std::vector<CInputCoin>& utxo_pool The set of UTXOs that we are choosing from.\n  *        These UTXOs will be sorted in descending order by effective value and the CInputCoins'\n  *        values are their effective values.\n- * @param const CAmount& target_value This is the value that we want to select. It is the lower\n+ * @param const CAmount& selection_target This is the value that we want to select. It is the lower\n  *        bound of the range.\n  * @param const CAmount& cost_of_change This is the cost of creating and spending a change output.\n- *        This plus target_value is the upper bound of the range.\n+ *        This plus selection_target is the upper bound of the range.\n  * @param std::set<CInputCoin>& out_set -> This is an output parameter for the set of CInputCoins\n  *        that have been selected.\n  * @param CAmount& value_ret -> This is an output parameter for the total value of the CInputCoins\n  *        that were selected.\n- * @param CAmount not_input_fees -> The fees that need to be paid for the outputs and fixed size\n- *        overhead (version, locktime, marker and flag)\n  */\n \n static const size_t TOTAL_TRIES = 100000;\n \n-bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees)\n+bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selection_target, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret)\n {\n     out_set.clear();\n     CAmount curr_value = 0;\n \n     std::vector<bool> curr_selection; // select the utxo at this index\n     curr_selection.reserve(utxo_pool.size());\n-    CAmount selection_target = not_input_fees + target_value;\n \n     // Calculate curr_available_value\n     CAmount curr_available_value = 0;"
      },
      {
        "sha": "af23178d047bc304c9937c576e20f7a0e7d9725b",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "patch": "@@ -120,7 +120,7 @@ struct OutputGroup\n     bool EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const;\n };\n \n-bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n+bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selection_target, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret);\n \n // Original coin selection algorithm as a fallback\n bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& groups, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);"
      },
      {
        "sha": "1a2454479d051945a44769b366a69c3fb361ec92",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "patch": "@@ -148,14 +148,13 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     CoinSet selection;\n     CoinSet actual_selection;\n     CAmount value_ret = 0;\n-    CAmount not_input_fees = 0;\n \n     /////////////////////////\n     // Known Outcome tests //\n     /////////////////////////\n \n     // Empty utxo pool\n-    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 0.5 * CENT, selection, value_ret));\n     selection.clear();\n \n     // Add utxos\n@@ -166,15 +165,15 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n     // Select 1 Cent\n     add_coin(1 * CENT, 1, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 0.5 * CENT, selection, value_ret));\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n     BOOST_CHECK_EQUAL(value_ret, 1 * CENT);\n     actual_selection.clear();\n     selection.clear();\n \n     // Select 2 Cent\n     add_coin(2 * CENT, 2, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 2 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 2 * CENT, 0.5 * CENT, selection, value_ret));\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n     BOOST_CHECK_EQUAL(value_ret, 2 * CENT);\n     actual_selection.clear();\n@@ -183,27 +182,27 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     // Select 5 Cent\n     add_coin(4 * CENT, 4, actual_selection);\n     add_coin(1 * CENT, 1, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 5 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 5 * CENT, 0.5 * CENT, selection, value_ret));\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n     BOOST_CHECK_EQUAL(value_ret, 5 * CENT);\n     actual_selection.clear();\n     selection.clear();\n \n     // Select 11 Cent, not possible\n-    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 11 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 11 * CENT, 0.5 * CENT, selection, value_ret));\n     actual_selection.clear();\n     selection.clear();\n \n     // Cost of change is greater than the difference between target value and utxo sum\n     add_coin(1 * CENT, 1, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0.5 * CENT, selection, value_ret));\n     BOOST_CHECK_EQUAL(value_ret, 1 * CENT);\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n     actual_selection.clear();\n     selection.clear();\n \n     // Cost of change is less than the difference between target value and utxo sum\n-    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0, selection, value_ret));\n     actual_selection.clear();\n     selection.clear();\n \n@@ -212,7 +211,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     add_coin(5 * CENT, 5, actual_selection);\n     add_coin(4 * CENT, 4, actual_selection);\n     add_coin(1 * CENT, 1, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 10 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 10 * CENT, 0.5 * CENT, selection, value_ret));\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n     BOOST_CHECK_EQUAL(value_ret, 10 * CENT);\n     actual_selection.clear();\n@@ -223,21 +222,21 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     add_coin(5 * CENT, 5, actual_selection);\n     add_coin(3 * CENT, 3, actual_selection);\n     add_coin(2 * CENT, 2, actual_selection);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 10 * CENT, 5000, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 10 * CENT, 5000, selection, value_ret));\n     BOOST_CHECK_EQUAL(value_ret, 10 * CENT);\n     // FIXME: this test is redundant with the above, because 1 Cent is selected, not \"too small\"\n     // BOOST_CHECK(equal_sets(selection, actual_selection));\n \n     // Select 0.25 Cent, not possible\n-    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.25 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.25 * CENT, 0.5 * CENT, selection, value_ret));\n     actual_selection.clear();\n     selection.clear();\n \n     // Iteration exhaustion test\n     CAmount target = make_hard_case(17, utxo_pool);\n-    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), target, 0, selection, value_ret, not_input_fees)); // Should exhaust\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), target, 0, selection, value_ret)); // Should exhaust\n     target = make_hard_case(14, utxo_pool);\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), target, 0, selection, value_ret, not_input_fees)); // Should not exhaust\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), target, 0, selection, value_ret)); // Should not exhaust\n \n     // Test same value early bailout optimization\n     utxo_pool.clear();\n@@ -254,7 +253,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     for (int i = 0; i < 50000; ++i) {\n         add_coin(5 * CENT, 7, utxo_pool);\n     }\n-    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 30 * CENT, 5000, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(utxo_pool), 30 * CENT, 5000, selection, value_ret));\n     BOOST_CHECK_EQUAL(value_ret, 30 * CENT);\n     BOOST_CHECK(equal_sets(selection, actual_selection));\n \n@@ -268,7 +267,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n     // Run 100 times, to make sure it is never finding a solution\n     for (int i = 0; i < 100; ++i) {\n-        BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 2 * CENT, selection, value_ret, not_input_fees));\n+        BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 2 * CENT, selection, value_ret));\n     }\n \n     // Make sure that effective value is working in SelectCoinsMinConf when BnB is used"
      },
      {
        "sha": "3383b3e96b3b9780d667620a1f7fd706388b2136",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 10,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf26e018de33216d6f0ed0d6ff822b93536f7cc1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "patch": "@@ -2399,9 +2399,6 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    // Calculate the fees for things that aren't inputs, excluding the change output\n-    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-\n     // Get the feerate for effective value.\n     // When subtracting the fee from the outputs, we want the effective feerate to be 0\n     CFeeRate effective_feerate{0};\n@@ -2412,14 +2409,17 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     if (coin_selection_params.use_bnb) {\n         std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n         bnb_used = true;\n-        return SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+        // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n+        return SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet);\n     } else {\n         // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n         // The knapsack solver currently does not use effective values, so we give GroupOutputs feerates of 0 so it sets the effective values to be the same as the real value.\n         std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n \n         bnb_used = false;\n-        return KnapsackSolver(nTargetValue, groups, setCoinsRet, nValueRet);\n+        // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n+        // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n+        return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, groups, setCoinsRet, nValueRet);\n     }\n }\n \n@@ -2931,10 +2931,6 @@ bool CWallet::CreateTransactionInternal(\n                 txNew.vin.clear();\n                 txNew.vout.clear();\n \n-                CAmount nValueToSelect = nValue;\n-                if (nSubtractFeeFromAmount == 0)\n-                    nValueToSelect += nFeeRet;\n-\n                 // vouts to the payees\n                 if (!coin_selection_params.m_subtract_fee_outputs) {\n                     coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n@@ -2956,11 +2952,21 @@ bool CWallet::CreateTransactionInternal(\n                     txNew.vout.push_back(txout);\n                 }\n \n+                // Include the fees for things that aren't inputs, excluding the change output\n+                const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+                CAmount nValueToSelect = nValue + not_input_fees;\n+\n+                // For KnapsackSolver, when we are not subtracting the fee from the recipients, we also want to include the fees for the\n+                // inputs that we found in the previous iteration.\n+                if (!coin_selection_params.use_bnb && nSubtractFeeFromAmount == 0) {\n+                    nValueToSelect += std::max(CAmount(0), nFeeRet - not_input_fees);\n+                }\n+\n                 // Choose coins to use\n                 bool bnb_used = false;\n                 nValueIn = 0;\n                 setCoins.clear();\n-                if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n+                if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                 {\n                     // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n                     if (bnb_used) {"
      }
    ]
  },
  {
    "sha": "01dc8ebda50a382d45d3d169b2c3f3965869dcae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMWRjOGViZGE1MGEzODJkNDVkM2QxNjliMmMzZjM5NjU4NjlkY2Fl",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-06T17:54:22Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T18:25:06Z"
      },
      "message": "Have KnapsackSolver actually use effective values\n\nAlthough the CreateTransaction loop currently remains, it should be\nlargely unused. KnapsackSolver will now account for transaction fees\nwhen doing its selection.\n\nIn the previous commit, SelectCoinsMinConf was refactored to have some\ncalculations become shared for KnapsackSolver and SelectCoinsBnB. In\nthis commit, KnapsackSolver will now use the not_input_fees and\neffective_feerate so that it include the fee for non-input things\n(excluding a change output) so that the algorithm will select enough to\ncover those fees. This is necessary for selecting on effective values.\n\nAdditionally, the OutputGroups\ncreated for KnapsackSolver will actually have their effective values\ncalculated and set, and KnapsackSolver will do its selection on those\neffective values.\n\nLastly, SelectCoins is modified to use the same value for preselected\ninputs for BnB and KnapsackSolver. While it will still use the real\nvalue when subtracting the fee from outputs, this behavior will be\nthe same regardless of the algo used for selecting additional inputs.",
      "tree": {
        "sha": "1a39944833be7f010cd400536e1984b7be5e970f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a39944833be7f010cd400536e1984b7be5e970f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/01dc8ebda50a382d45d3d169b2c3f3965869dcae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01dc8ebda50a382d45d3d169b2c3f3965869dcae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/01dc8ebda50a382d45d3d169b2c3f3965869dcae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01dc8ebda50a382d45d3d169b2c3f3965869dcae/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf26e018de33216d6f0ed0d6ff822b93536f7cc1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bf26e018de33216d6f0ed0d6ff822b93536f7cc1"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 10,
      "deletions": 18
    },
    "files": [
      {
        "sha": "af88bf85dda2a0f4ec171237027940dfa60c9e2a",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01dc8ebda50a382d45d3d169b2c3f3965869dcae/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01dc8ebda50a382d45d3d169b2c3f3965869dcae/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=01dc8ebda50a382d45d3d169b2c3f3965869dcae",
        "patch": "@@ -227,14 +227,14 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     Shuffle(groups.begin(), groups.end(), FastRandomContext());\n \n     for (const OutputGroup& group : groups) {\n-        if (group.m_value == nTargetValue) {\n+        if (group.effective_value == nTargetValue) {\n             util::insert(setCoinsRet, group.m_outputs);\n             nValueRet += group.m_value;\n             return true;\n-        } else if (group.m_value < nTargetValue + MIN_CHANGE) {\n+        } else if (group.effective_value < nTargetValue + MIN_CHANGE) {\n             applicable_groups.push_back(group);\n-            nTotalLower += group.m_value;\n-        } else if (!lowest_larger || group.m_value < lowest_larger->m_value) {\n+            nTotalLower += group.effective_value;\n+        } else if (!lowest_larger || group.effective_value < lowest_larger->effective_value) {\n             lowest_larger = group;\n         }\n     }\n@@ -267,7 +267,7 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n     //                                   or the next bigger coin is closer), return the bigger coin\n     if (lowest_larger &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->m_value <= nBest)) {\n+        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->effective_value <= nBest)) {\n         util::insert(setCoinsRet, lowest_larger->m_outputs);\n         nValueRet += lowest_larger->m_value;\n     } else {"
      },
      {
        "sha": "b229d8ad63c07d70e22b756aa9eb1d04700b9b84",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 13,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01dc8ebda50a382d45d3d169b2c3f3965869dcae/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01dc8ebda50a382d45d3d169b2c3f3965869dcae/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=01dc8ebda50a382d45d3d169b2c3f3965869dcae",
        "patch": "@@ -2413,13 +2413,11 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         return SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet);\n     } else {\n         // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-        // The knapsack solver currently does not use effective values, so we give GroupOutputs feerates of 0 so it sets the effective values to be the same as the real value.\n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n-\n+        std::vector<OutputGroup> all_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, false /* positive_only */);\n         bnb_used = false;\n         // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n         // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n-        return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, groups, setCoinsRet, nValueRet);\n+        return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n     }\n }\n \n@@ -2467,10 +2465,10 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n                 return false; // Not solvable, can't estimate size for fee\n             }\n             coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n-            if (coin_selection_params.use_bnb) {\n-                value_to_select -= coin.effective_value;\n-            } else {\n+            if (coin_selection_params.m_subtract_fee_outputs) {\n                 value_to_select -= coin.txout.nValue;\n+            } else {\n+                value_to_select -= coin.effective_value;\n             }\n             setPresetCoins.insert(coin);\n         } else {\n@@ -2956,12 +2954,6 @@ bool CWallet::CreateTransactionInternal(\n                 const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n                 CAmount nValueToSelect = nValue + not_input_fees;\n \n-                // For KnapsackSolver, when we are not subtracting the fee from the recipients, we also want to include the fees for the\n-                // inputs that we found in the previous iteration.\n-                if (!coin_selection_params.use_bnb && nSubtractFeeFromAmount == 0) {\n-                    nValueToSelect += std::max(CAmount(0), nFeeRet - not_input_fees);\n-                }\n-\n                 // Choose coins to use\n                 bool bnb_used = false;\n                 nValueIn = 0;"
      }
    ]
  },
  {
    "sha": "de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTI2ZWIwZTFmYTJiNmYwM2M1OGJhMTA0ZDAwZjdhOGZmZWFkMzlj",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-30T20:08:55Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T18:31:28Z"
      },
      "message": "Do both BnB and Knapsack coin selection in SelectCoinsMinConf\n\nInstead of switching which algorithm to use based on use_bnb, just run\nboth in SelectCoinsMinConf. If BnB fails, do Knapsack.",
      "tree": {
        "sha": "6319485fa3f62439863ae8f5aefd828a1df2bea1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6319485fa3f62439863ae8f5aefd828a1df2bea1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "01dc8ebda50a382d45d3d169b2c3f3965869dcae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01dc8ebda50a382d45d3d169b2c3f3965869dcae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/01dc8ebda50a382d45d3d169b2c3f3965869dcae"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 21,
      "deletions": 22
    },
    "files": [
      {
        "sha": "55b73cd1f05102a84cab0426580a4cbe52037604",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
        "patch": "@@ -287,9 +287,9 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     empty_wallet();\n     add_coin(1 * CENT);\n     vCoins.at(0).nInputBytes = 40;\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n     coin_selection_params_bnb.m_subtract_fee_outputs = true;\n     BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(bnb_used);\n     BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n     // Make sure that can use BnB when there are preset inputs\n@@ -549,17 +549,19 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n           for (int i = 0; i < RUN_TESTS; i++) {\n             // picking 50 from 100 coins doesn't depend on the shuffle,\n             // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(KnapsackSolver(50 * COIN, GroupCoins(vCoins), setCoinsRet, nValueRet));\n+            BOOST_CHECK(KnapsackSolver(50 * COIN, GroupCoins(vCoins), setCoinsRet2, nValueRet));\n             BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n \n             int fails = 0;\n             for (int j = 0; j < RANDOM_REPEATS; j++)\n             {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                // Test that the KnapsackSolver selects randomly from equivalent coins (same value and same input size).\n+                // When choosing 1 from 100 identical coins, 1% of the time, this test will choose the same coin twice\n+                // which will cause it to fail.\n+                // To avoid that issue, run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(KnapsackSolver(COIN, GroupCoins(vCoins), setCoinsRet, nValueRet));\n+                BOOST_CHECK(KnapsackSolver(COIN, GroupCoins(vCoins), setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -579,10 +581,8 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n             int fails = 0;\n             for (int j = 0; j < RANDOM_REPEATS; j++)\n             {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(KnapsackSolver(90*CENT, GroupCoins(vCoins), setCoinsRet, nValueRet));\n+                BOOST_CHECK(KnapsackSolver(90*CENT, GroupCoins(vCoins), setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }"
      },
      {
        "sha": "a5b9c844c7db018059a7520e4472570eb2aca42b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 11,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
        "patch": "@@ -2406,19 +2406,18 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         effective_feerate = coin_selection_params.m_effective_feerate;\n     }\n \n-    if (coin_selection_params.use_bnb) {\n-        std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n+    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n+    // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n+    if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n         bnb_used = true;\n-        // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n-        return SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet);\n-    } else {\n-        // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-        std::vector<OutputGroup> all_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, false /* positive_only */);\n-        bnb_used = false;\n-        // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n-        // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n-        return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n+        return true;\n     }\n+    // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n+    std::vector<OutputGroup> all_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, false /* positive_only */);\n+    bnb_used = false;\n+    // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n+    // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n+    return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n }\n \n bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const"
      }
    ]
  },
  {
    "sha": "6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZjBkNTE4OWFmNGM4ODFmZThiOTdhMGMyOGNlMWZmYTMzNDgwNzE1",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-30T20:28:46Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T18:37:17Z"
      },
      "message": "Remove use_bnb and bnb_used\n\nThese booleans are no longer needed",
      "tree": {
        "sha": "05973000cde2d46f58074dca3b16b03bcc943a24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05973000cde2d46f58074dca3b16b03bcc943a24"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de26eb0e1fa2b6f03c58ba104d00f7a8ffead39c"
      }
    ],
    "stats": {
      "total": 143,
      "additions": 58,
      "deletions": 85
    },
    "files": [
      {
        "sha": "c279a9af2f75fc9aa4ea3297cce07f8fe1475c2b",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "patch": "@@ -49,15 +49,14 @@ static void CoinSelection(benchmark::Bench& bench)\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n-    const CoinSelectionParams coin_selection_params(/* use_bnb= */ true, /* change_output_size= */ 34,\n+    const CoinSelectionParams coin_selection_params(/* change_output_size= */ 34,\n                                                     /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n                                                     /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n                                                     /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool bnb_used;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "26e17eeb8af1c2b3652345b4c863c29533bc7ed6",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 47,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "patch": "@@ -35,7 +35,7 @@ static CAmount balance = 0;\n CoinEligibilityFilter filter_standard(1, 6, 0);\n CoinEligibilityFilter filter_confirmed(1, 1, 0);\n CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-CoinSelectionParams coin_selection_params(/* use_bnb= */ false, /* change_output_size= */ 0,\n+CoinSelectionParams coin_selection_params(/* change_output_size= */ 0,\n                                           /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(0),\n                                           /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n                                           /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n@@ -271,25 +271,23 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n \n     // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n-    CoinSelectionParams coin_selection_params_bnb(/* use_bnb= */ true, /* change_output_size= */ 0,\n+    CoinSelectionParams coin_selection_params_bnb(/* change_output_size= */ 0,\n                                                   /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(3000),\n                                                   /* long_term_feerate= */ CFeeRate(1000), /* discard_feerate= */ CFeeRate(1000),\n                                                   /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n-    bool bnb_used;\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n \n     // Test fees subtracted from output:\n     empty_wallet();\n     add_coin(1 * CENT);\n     vCoins.at(0).nInputBytes = 40;\n     coin_selection_params_bnb.m_subtract_fee_outputs = true;\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n-    BOOST_CHECK(bnb_used);\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n     BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n     // Make sure that can use BnB when there are preset inputs\n@@ -307,17 +305,14 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.fAllowOtherInputs = true;\n         coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(0);\n-        BOOST_CHECK(wallet->SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb, bnb_used));\n-        BOOST_CHECK(bnb_used);\n-        BOOST_CHECK(coin_selection_params_bnb.use_bnb);\n+        BOOST_CHECK(wallet->SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb));\n     }\n }\n \n BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n {\n     CoinSet setCoinsRet, setCoinsRet2;\n     CAmount nValueRet;\n-    bool bnb_used;\n \n     LOCK(testWallet.cs_wallet);\n     testWallet.SetupLegacyScriptPubKeyMan();\n@@ -328,24 +323,24 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -355,33 +350,33 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -395,30 +390,30 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -427,11 +422,11 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -446,22 +441,22 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see https://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -470,7 +465,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -483,7 +478,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -493,7 +488,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -504,12 +499,12 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n       }\n@@ -523,7 +518,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n            // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.\n            for (int i = 0; i < RUN_TESTS; i++) {\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n@@ -597,7 +592,6 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n {\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n-    bool bnb_used;\n \n     LOCK(testWallet.cs_wallet);\n     testWallet.SetupLegacyScriptPubKeyMan();\n@@ -609,7 +603,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -644,19 +638,18 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n \n         // Perform selection\n-        CoinSelectionParams coin_selection_params_knapsack(/* use_bnb= */ false, /* change_output_size= */ 34,\n+        CoinSelectionParams coin_selection_params_knapsack(/* change_output_size= */ 34,\n                                                            /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n                                                            /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n                                                            /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n-        CoinSelectionParams coin_selection_params_bnb(/* use_bnb= */ true, /* change_output_size= */ 34,\n+        CoinSelectionParams coin_selection_params_bnb(/* change_output_size= */ 34,\n                                                       /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n                                                       /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n                                                       /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n         CoinSet out_set;\n         CAmount out_value = 0;\n-        bool bnb_used = false;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "c1e58a949f8c867618c024fcbbdac286a0626cb2",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 29,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "patch": "@@ -2394,7 +2394,7 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n }\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -2409,25 +2409,20 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n     // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n     if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n-        bnb_used = true;\n         return true;\n     }\n     // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n     std::vector<OutputGroup> all_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, false /* positive_only */);\n-    bnb_used = false;\n     // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n     // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n     return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n     CAmount value_to_select = nTargetValue;\n \n-    // Default to bnb was not used. If we use it, we set it later\n-    bnb_used = false;\n-\n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n     if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n     {\n@@ -2509,42 +2504,42 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n         // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n         // confirmations on outputs received from other wallets and only spend confirmed change.\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n \n         // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n         // possible) if we cannot fund the transaction otherwise.\n         if (m_spend_zero_conf_change) {\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n             if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n             // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n             // in their entirety.\n             if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n             // received from other wallets.\n             if (coin_control.m_include_unsafe_inputs\n                 && SelectCoinsMinConf(value_to_select,\n                     CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n-                    vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unlimited ancestors/descendants. The transaction will still need to meet\n             // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n             // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n             if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n                                       CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n-                                      vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                                      vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n         }\n@@ -2917,9 +2912,6 @@ bool CWallet::CreateTransactionInternal(\n             nFeeRet = 0;\n             CAmount nValueIn = 0;\n \n-            // BnB selector is the only selector used when this is true.\n-            // That should only happen on the first pass through the loop.\n-            coin_selection_params.use_bnb = true;\n             coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n             // Start with no fee and loop until there is enough fee\n             while (true)\n@@ -2954,20 +2946,12 @@ bool CWallet::CreateTransactionInternal(\n                 CAmount nValueToSelect = nValue + not_input_fees;\n \n                 // Choose coins to use\n-                bool bnb_used = false;\n                 nValueIn = 0;\n                 setCoins.clear();\n-                if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n+                if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params))\n                 {\n-                    // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n-                    if (bnb_used) {\n-                        coin_selection_params.use_bnb = false;\n-                        continue;\n-                    }\n-                    else {\n-                        error = _(\"Insufficient funds\");\n-                        return false;\n-                    }\n+                    error = _(\"Insufficient funds\");\n+                    return false;\n                 }\n \n                 // Always make a change output"
      },
      {
        "sha": "028131174f26665107961dfb44c64422ccac8424",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f0d5189af4c881fe8b97a0c28ce1ffa33480715/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "patch": "@@ -615,8 +615,6 @@ class COutput\n /** Parameters for one iteration of Coin Selection. */\n struct CoinSelectionParams\n {\n-    /** Toggles use of Branch and Bound instead of Knapsack solver. */\n-    bool use_bnb = true;\n     /** Size of a change output in bytes, determined by the output type. */\n     size_t change_output_size = 0;\n     /** Size of the input to spend a change output in virtual bytes. */\n@@ -642,9 +640,8 @@ struct CoinSelectionParams\n      * reuse. Dust outputs are not eligible to be added to output groups and thus not considered. */\n     bool m_avoid_partial_spends = false;\n \n-    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n+    CoinSelectionParams(size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n                         CFeeRate long_term_feerate, CFeeRate discard_feerate, size_t tx_noinputs_size, bool avoid_partial) :\n-        use_bnb(use_bnb),\n         change_output_size(change_output_size),\n         change_spend_size(change_spend_size),\n         m_effective_feerate(effective_feerate),\n@@ -789,7 +786,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      *                                  from coin_control and Coin Selection if successful.\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n@@ -878,7 +875,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * param@[out]  nValueRet       Used to return the total value of selected coins.\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n "
      }
    ]
  },
  {
    "sha": "9d3bd74ab4430532d6e53eef8cf77ad999044b14",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDNiZDc0YWI0NDMwNTMyZDZlNTNlZWY4Y2Y3N2FkOTk5MDQ0YjE0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-30T20:39:59Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T18:58:03Z"
      },
      "message": "Remove CreateTransaction while loop and some related variables\n\nRemove the CreateTransaction while loop. Removes variables that were\nonly needed because of that loop. Also renames a few variables and\nmoves their declarations to where they are used.\n\nSome subtractFeeFromOutputs handling is moved to after coin selection\nin order to reduce their amounts once the fee is known.\n\nIf subtracting the fee reduces the change to dust, we will also now\nremove the change output",
      "tree": {
        "sha": "c973d7c32a34f0dff676fc7a3743ec38780e1d01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c973d7c32a34f0dff676fc7a3743ec38780e1d01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d3bd74ab4430532d6e53eef8cf77ad999044b14",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d3bd74ab4430532d6e53eef8cf77ad999044b14",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d3bd74ab4430532d6e53eef8cf77ad999044b14",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d3bd74ab4430532d6e53eef8cf77ad999044b14/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f0d5189af4c881fe8b97a0c28ce1ffa33480715",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f0d5189af4c881fe8b97a0c28ce1ffa33480715"
      }
    ],
    "stats": {
      "total": 221,
      "additions": 104,
      "deletions": 117
    },
    "files": [
      {
        "sha": "303823695eeccea8a24b5c5e5db877c997cda9a2",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 117,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d3bd74ab4430532d6e53eef8cf77ad999044b14/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d3bd74ab4430532d6e53eef8cf77ad999044b14/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=9d3bd74ab4430532d6e53eef8cf77ad999044b14",
        "patch": "@@ -2804,7 +2804,6 @@ bool CWallet::CreateTransactionInternal(\n     CAmount nValue = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    int nChangePosRequest = nChangePosInOut;\n     unsigned int nSubtractFeeFromAmount = 0;\n     for (const auto& recipient : vecSend)\n     {\n@@ -2909,151 +2908,139 @@ bool CWallet::CreateTransactionInternal(\n             coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n             coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-            nFeeRet = 0;\n-            CAmount nValueIn = 0;\n-\n             coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n-            // Start with no fee and loop until there is enough fee\n-            while (true)\n+\n+            // vouts to the payees\n+            if (!coin_selection_params.m_subtract_fee_outputs) {\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            }\n+            for (const auto& recipient : vecSend)\n             {\n-                nChangePosInOut = nChangePosRequest;\n-                txNew.vin.clear();\n-                txNew.vout.clear();\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-                // vouts to the payees\n+                // Include the fee cost for outputs.\n                 if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n                 }\n-                for (const auto& recipient : vecSend)\n+\n+                if (IsDust(txout, chain().relayDustFee()))\n                 {\n-                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+                    error = _(\"Transaction amount too small\");\n+                    return false;\n+                }\n+                txNew.vout.push_back(txout);\n+            }\n \n-                    // Include the fee cost for outputs.\n-                    if (!coin_selection_params.m_subtract_fee_outputs) {\n-                        coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                    }\n+            // Include the fees for things that aren't inputs, excluding the change output\n+            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+            CAmount nValueToSelect = nValue + not_input_fees;\n \n-                    if (IsDust(txout, chain().relayDustFee()))\n-                    {\n-                        error = _(\"Transaction amount too small\");\n-                        return false;\n-                    }\n-                    txNew.vout.push_back(txout);\n-                }\n+            // Choose coins to use\n+            CAmount inputs_sum = 0;\n+            setCoins.clear();\n+            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n+            {\n+                error = _(\"Insufficient funds\");\n+                return false;\n+            }\n \n-                // Include the fees for things that aren't inputs, excluding the change output\n-                const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-                CAmount nValueToSelect = nValue + not_input_fees;\n+            // Always make a change output\n+            // We will reduce the fee from this change output later, and remove the output if it is too small.\n+            const CAmount change_and_fee = inputs_sum - nValue;\n+            assert(change_and_fee >= 0);\n+            CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Choose coins to use\n-                nValueIn = 0;\n-                setCoins.clear();\n-                if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params))\n-                {\n-                    error = _(\"Insufficient funds\");\n-                    return false;\n-                }\n+            if (nChangePosInOut == -1)\n+            {\n+                // Insert change txn at random position:\n+                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+            }\n+            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+            {\n+                error = _(\"Change index out of range\");\n+                return false;\n+            }\n \n-                // Always make a change output\n-                // We will reduce the fee from this change output later, and remove the output if it is too small.\n-                const CAmount change_and_fee = nValueIn - nValue;\n-                assert(change_and_fee >= 0);\n-                CTxOut newTxOut(change_and_fee, scriptChange);\n+            assert(nChangePosInOut != -1);\n+            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-                if (nChangePosInOut == -1)\n-                {\n-                    // Insert change txn at random position:\n-                    nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                }\n-                else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                {\n-                    error = _(\"Change index out of range\");\n-                    return false;\n-                }\n+            // Dummy fill vin for maximum size estimation\n+            //\n+            for (const auto& coin : setCoins) {\n+                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+            }\n \n-                assert(nChangePosInOut != -1);\n-                auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+            // Calculate the transaction fee\n+            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+            nBytes = tx_sizes.first;\n+            if (nBytes < 0) {\n+                error = _(\"Signing transaction failed\");\n+                return false;\n+            }\n+            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-                // Dummy fill vin for maximum size estimation\n-                //\n-                for (const auto& coin : setCoins) {\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-                }\n+            // Subtract fee from the change output if not subtrating it from recipient outputs\n+            CAmount fee_needed = nFeeRet;\n+            if (nSubtractFeeFromAmount == 0) {\n+                change_position->nValue -= fee_needed;\n+            }\n \n-                // Calculate the transaction fee\n+            // We want to drop the change to fees if:\n+            // 1. The change output would be dust\n+            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+            CAmount change_amount = change_position->nValue;\n+            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            {\n+                nChangePosInOut = -1;\n+                change_amount = 0;\n+                txNew.vout.erase(change_position);\n+\n+                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n                 tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n                 nBytes = tx_sizes.first;\n-                if (nBytes < 0) {\n-                    error = _(\"Signing transaction failed\");\n-                    return false;\n-                }\n-                nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+            }\n \n-                // Subtract fee from the change output if not subtrating it from recipient outputs\n-                CAmount fee_needed = nFeeRet;\n-                if (nSubtractFeeFromAmount == 0) {\n-                    change_position->nValue -= fee_needed;\n-                }\n+            // Update nFeeRet in case fee_needed changed due to dropping the change output\n+            if (fee_needed <= change_and_fee - change_amount) {\n+                nFeeRet = change_and_fee - change_amount;\n+            }\n \n-                // We want to drop the change to fees if:\n-                // 1. The change output would be dust\n-                // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-                CAmount change_amount = change_position->nValue;\n-                if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            // Reduce output values for subtractFeeFromAmount\n+            if (nSubtractFeeFromAmount != 0) {\n+                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+                int i = 0;\n+                bool fFirst = true;\n+                for (const auto& recipient : vecSend)\n                 {\n-                    nChangePosInOut = -1;\n-                    change_amount = 0;\n-                    txNew.vout.erase(change_position);\n-\n-                    // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                    tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                    nBytes = tx_sizes.first;\n-                    fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-                }\n-\n-                // If the fee is covered, there's no need to loop or subtract from recipients\n-                if (fee_needed <= change_and_fee - change_amount) {\n-                    nFeeRet = change_and_fee - change_amount;\n-                    break;\n-                }\n+                    if (i == nChangePosInOut) {\n+                        ++i;\n+                    }\n+                    CTxOut& txout = txNew.vout[i];\n \n-                // Reduce output values for subtractFeeFromAmount\n-                if (nSubtractFeeFromAmount != 0) {\n-                    CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                    int i = 0;\n-                    bool fFirst = true;\n-                    for (const auto& recipient : vecSend)\n+                    if (recipient.fSubtractFeeFromAmount)\n                     {\n-                        if (i == nChangePosInOut) {\n-                            ++i;\n-                        }\n-                        CTxOut& txout = txNew.vout[i];\n+                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n \n-                        if (recipient.fSubtractFeeFromAmount)\n+                        if (fFirst) // first receiver pays the remainder not divisible by output count\n                         {\n-                            txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                            if (fFirst) // first receiver pays the remainder not divisible by output count\n-                            {\n-                                fFirst = false;\n-                                txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                            }\n+                            fFirst = false;\n+                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                        }\n \n-                            // Error if this output is reduced to be below dust\n-                            if (IsDust(txout, chain().relayDustFee())) {\n-                                if (txout.nValue < 0) {\n-                                    error = _(\"The transaction amount is too small to pay the fee\");\n-                                } else {\n-                                    error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                                }\n-                                return false;\n+                        // Error if this output is reduced to be below dust\n+                        if (IsDust(txout, chain().relayDustFee())) {\n+                            if (txout.nValue < 0) {\n+                                error = _(\"The transaction amount is too small to pay the fee\");\n+                            } else {\n+                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                             }\n+                            return false;\n                         }\n-                        ++i;\n                     }\n-                    nFeeRet = fee_needed;\n-                    break; // The fee has been deducted from the recipients, nothing left to do here\n+                    ++i;\n                 }\n+                nFeeRet = fee_needed;\n             }\n \n             // Give up if change keypool ran out and change is required"
      }
    ]
  },
  {
    "sha": "6d6d2784759878ef0c4ac128d12aac68add1edca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDZkMjc4NDc1OTg3OGVmMGM0YWMxMjhkMTJhYWM2OGFkZDFlZGNh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-11-16T21:57:29Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T19:03:49Z"
      },
      "message": "Change SelectCoins_test to actually test SelectCoins\n\nThis was originally modified to use SelectCoinsMinConf in order to test\nboth BnB and Knapsack at the same time. But since SelectCoins does both\nnow, this is no longer necessary and we can revert back to actually\ntesting SelectCoins.",
      "tree": {
        "sha": "47da51e1dd812bc3e174b25c6a207b2dbcdfb9ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47da51e1dd812bc3e174b25c6a207b2dbcdfb9ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d6d2784759878ef0c4ac128d12aac68add1edca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d6d2784759878ef0c4ac128d12aac68add1edca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d6d2784759878ef0c4ac128d12aac68add1edca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d6d2784759878ef0c4ac128d12aac68add1edca/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d3bd74ab4430532d6e53eef8cf77ad999044b14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d3bd74ab4430532d6e53eef8cf77ad999044b14",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d3bd74ab4430532d6e53eef8cf77ad999044b14"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 7,
      "deletions": 10
    },
    "files": [
      {
        "sha": "ad6a4351db2b7c781d62dee173f78fff952d19a7",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d6d2784759878ef0c4ac128d12aac68add1edca/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d6d2784759878ef0c4ac128d12aac68add1edca/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=6d6d2784759878ef0c4ac128d12aac68add1edca",
        "patch": "@@ -613,6 +613,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n // Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n BOOST_AUTO_TEST_CASE(SelectCoins_test)\n {\n+    LOCK(testWallet.cs_wallet);\n     testWallet.SetupLegacyScriptPubKeyMan();\n \n     // Random generator stuff\n@@ -638,18 +639,14 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n \n         // Perform selection\n-        CoinSelectionParams coin_selection_params_knapsack(/* change_output_size= */ 34,\n-                                                           /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n-                                                           /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n-                                                           /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n-        CoinSelectionParams coin_selection_params_bnb(/* change_output_size= */ 34,\n-                                                      /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n-                                                      /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n-                                                      /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+        CoinSelectionParams cs_params(/* change_output_size= */ 34,\n+                                      /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n+                                      /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n+                                      /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n         CoinSet out_set;\n         CAmount out_value = 0;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack));\n+        CCoinControl cc;\n+        BOOST_CHECK(testWallet.SelectCoins(vCoins, target, out_set, out_value, cc, cs_params));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      }
    ]
  },
  {
    "sha": "51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MWEzYWMyNDJjOTJlNjliNTlkZjI2ZjhmOWUyODdiMzFlNWMzYjBm",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-04-23T19:14:41Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-19T19:35:11Z"
      },
      "message": "Have OutputGroup determine the value to use\n\nInstead of hijacking the effective_feerate to use the correct value\nduring coin selection, have OutputGroup be aware of whether we are\nsubtracting the fee from the outputs and provide the correct value to\nuse for selection.\n\nTo do this, OutputGroup now takes CoinSelectionParams and has a new\nfunction GetSelectionAmount().",
      "tree": {
        "sha": "bcdd8ea4f69744deab78032d16d448971b587411",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bcdd8ea4f69744deab78032d16d448971b587411"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d6d2784759878ef0c4ac128d12aac68add1edca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d6d2784759878ef0c4ac128d12aac68add1edca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d6d2784759878ef0c4ac128d12aac68add1edca"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 78,
      "deletions": 75
    },
    "files": [
      {
        "sha": "6d502e1df1730713f1e0ad7e7dd556385b6b0160",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 13,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
        "patch": "@@ -14,7 +14,7 @@\n struct {\n     bool operator()(const OutputGroup& a, const OutputGroup& b) const\n     {\n-        return a.effective_value > b.effective_value;\n+        return a.GetSelectionAmount() > b.GetSelectionAmount();\n     }\n } descending;\n \n@@ -73,8 +73,8 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selectio\n     CAmount curr_available_value = 0;\n     for (const OutputGroup& utxo : utxo_pool) {\n         // Assert that this utxo is not negative. It should never be negative, effective value calculation should have removed it\n-        assert(utxo.effective_value > 0);\n-        curr_available_value += utxo.effective_value;\n+        assert(utxo.GetSelectionAmount() > 0);\n+        curr_available_value += utxo.GetSelectionAmount();\n     }\n     if (curr_available_value < selection_target) {\n         return false;\n@@ -118,7 +118,7 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selectio\n             // Walk backwards to find the last included UTXO that still needs to have its omission branch traversed.\n             while (!curr_selection.empty() && !curr_selection.back()) {\n                 curr_selection.pop_back();\n-                curr_available_value += utxo_pool.at(curr_selection.size()).effective_value;\n+                curr_available_value += utxo_pool.at(curr_selection.size()).GetSelectionAmount();\n             }\n \n             if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched\n@@ -128,24 +128,24 @@ bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selectio\n             // Output was included on previous iterations, try excluding now.\n             curr_selection.back() = false;\n             OutputGroup& utxo = utxo_pool.at(curr_selection.size() - 1);\n-            curr_value -= utxo.effective_value;\n+            curr_value -= utxo.GetSelectionAmount();\n             curr_waste -= utxo.fee - utxo.long_term_fee;\n         } else { // Moving forwards, continuing down this branch\n             OutputGroup& utxo = utxo_pool.at(curr_selection.size());\n \n             // Remove this utxo from the curr_available_value utxo amount\n-            curr_available_value -= utxo.effective_value;\n+            curr_available_value -= utxo.GetSelectionAmount();\n \n             // Avoid searching a branch if the previous UTXO has the same value and same waste and was excluded. Since the ratio of fee to\n             // long term fee is the same, we only need to check if one of those values match in order to know that the waste is the same.\n             if (!curr_selection.empty() && !curr_selection.back() &&\n-                utxo.effective_value == utxo_pool.at(curr_selection.size() - 1).effective_value &&\n+                utxo.GetSelectionAmount() == utxo_pool.at(curr_selection.size() - 1).GetSelectionAmount() &&\n                 utxo.fee == utxo_pool.at(curr_selection.size() - 1).fee) {\n                 curr_selection.push_back(false);\n             } else {\n                 // Inclusion branch first (Largest First Exploration)\n                 curr_selection.push_back(true);\n-                curr_value += utxo.effective_value;\n+                curr_value += utxo.GetSelectionAmount();\n                 curr_waste += utxo.fee - utxo.long_term_fee;\n             }\n         }\n@@ -227,14 +227,14 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     Shuffle(groups.begin(), groups.end(), FastRandomContext());\n \n     for (const OutputGroup& group : groups) {\n-        if (group.effective_value == nTargetValue) {\n+        if (group.GetSelectionAmount() == nTargetValue) {\n             util::insert(setCoinsRet, group.m_outputs);\n             nValueRet += group.m_value;\n             return true;\n-        } else if (group.effective_value < nTargetValue + MIN_CHANGE) {\n+        } else if (group.GetSelectionAmount() < nTargetValue + MIN_CHANGE) {\n             applicable_groups.push_back(group);\n-            nTotalLower += group.effective_value;\n-        } else if (!lowest_larger || group.effective_value < lowest_larger->effective_value) {\n+            nTotalLower += group.GetSelectionAmount();\n+        } else if (!lowest_larger || group.GetSelectionAmount() < lowest_larger->GetSelectionAmount()) {\n             lowest_larger = group;\n         }\n     }\n@@ -267,7 +267,7 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n     //                                   or the next bigger coin is closer), return the bigger coin\n     if (lowest_larger &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->effective_value <= nBest)) {\n+        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->GetSelectionAmount() <= nBest)) {\n         util::insert(setCoinsRet, lowest_larger->m_outputs);\n         nValueRet += lowest_larger->m_value;\n     } else {\n@@ -336,3 +336,8 @@ bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter& eligibility_f\n         && m_ancestors <= eligibility_filter.max_ancestors\n         && m_descendants <= eligibility_filter.max_descendants;\n }\n+\n+CAmount OutputGroup::GetSelectionAmount() const\n+{\n+    return m_subtract_fee_outputs ? m_value : effective_value;\n+}"
      },
      {
        "sha": "7a3fb82139d9cb44a56499ca26c84169595a28f7",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 49,
        "deletions": 3,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
        "patch": "@@ -57,6 +57,47 @@ class CInputCoin {\n     }\n };\n \n+/** Parameters for one iteration of Coin Selection. */\n+struct CoinSelectionParams\n+{\n+    /** Size of a change output in bytes, determined by the output type. */\n+    size_t change_output_size = 0;\n+    /** Size of the input to spend a change output in virtual bytes. */\n+    size_t change_spend_size = 0;\n+    /** Cost of creating the change output. */\n+    CAmount m_change_fee{0};\n+    /** Cost of creating the change output + cost of spending the change output in the future. */\n+    CAmount m_cost_of_change{0};\n+    /** The targeted feerate of the transaction being built. */\n+    CFeeRate m_effective_feerate;\n+    /** The feerate estimate used to estimate an upper bound on what should be sufficient to spend\n+     * the change output sometime in the future. */\n+    CFeeRate m_long_term_feerate;\n+    /** If the cost to spend a change output at the discard feerate exceeds its value, drop it to fees. */\n+    CFeeRate m_discard_feerate;\n+    /** Size of the transaction before coin selection, consisting of the header and recipient\n+     * output(s), excluding the inputs and change output(s). */\n+    size_t tx_noinputs_size = 0;\n+    /** Indicate that we are subtracting the fee from outputs */\n+    bool m_subtract_fee_outputs = false;\n+    /** When true, always spend all (up to OUTPUT_GROUP_MAX_ENTRIES) or none of the outputs\n+     * associated with the same address. This helps reduce privacy leaks resulting from address\n+     * reuse. Dust outputs are not eligible to be added to output groups and thus not considered. */\n+    bool m_avoid_partial_spends = false;\n+\n+    CoinSelectionParams(size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n+                        CFeeRate long_term_feerate, CFeeRate discard_feerate, size_t tx_noinputs_size, bool avoid_partial) :\n+        change_output_size(change_output_size),\n+        change_spend_size(change_spend_size),\n+        m_effective_feerate(effective_feerate),\n+        m_long_term_feerate(long_term_feerate),\n+        m_discard_feerate(discard_feerate),\n+        tx_noinputs_size(tx_noinputs_size),\n+        m_avoid_partial_spends(avoid_partial)\n+    {}\n+    CoinSelectionParams() {}\n+};\n+\n /** Parameters for filtering which OutputGroups we may use in coin selection.\n  * We start by being very selective and requiring multiple confirmations and\n  * then get more permissive if we cannot fund the transaction. */\n@@ -109,15 +150,20 @@ struct OutputGroup\n      * a lower feerate). Calculated using long term fee estimate. This is used to decide whether\n      * it could be economical to create a change output. */\n     CFeeRate m_long_term_feerate{0};\n+    /** Indicate that we are subtracting the fee from outputs.\n+     * When true, the value that is used for coin selection is the UTXO's real value rather than effective value */\n+    bool m_subtract_fee_outputs{false};\n \n     OutputGroup() {}\n-    OutputGroup(const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) :\n-        m_effective_feerate(effective_feerate),\n-        m_long_term_feerate(long_term_feerate)\n+    OutputGroup(const CoinSelectionParams& params) :\n+        m_effective_feerate(params.m_effective_feerate),\n+        m_long_term_feerate(params.m_long_term_feerate),\n+        m_subtract_fee_outputs(params.m_subtract_fee_outputs)\n     {}\n \n     void Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants, bool positive_only);\n     bool EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const;\n+    CAmount GetSelectionAmount() const;\n };\n \n bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selection_target, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret);"
      },
      {
        "sha": "78243a0136872ccf4d1d399936f7fcd057247ad9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 17,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
        "patch": "@@ -2399,20 +2399,13 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    // Get the feerate for effective value.\n-    // When subtracting the fee from the outputs, we want the effective feerate to be 0\n-    CFeeRate effective_feerate{0};\n-    if (!coin_selection_params.m_subtract_fee_outputs) {\n-        effective_feerate = coin_selection_params.m_effective_feerate;\n-    }\n-\n-    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, true /* positive_only */);\n     // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n+    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n     if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n         return true;\n     }\n     // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-    std::vector<OutputGroup> all_groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, coin_selection_params.m_long_term_feerate, eligibility_filter, false /* positive_only */);\n+    std::vector<OutputGroup> all_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n     // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n     // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n     return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n@@ -4223,12 +4216,12 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool separate_coins, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const\n {\n     std::vector<OutputGroup> groups_out;\n \n-    if (separate_coins) {\n-        // Single coin means no grouping. Each COutput gets its own OutputGroup.\n+    if (!coin_sel_params.m_avoid_partial_spends) {\n+        // Allowing partial spends  means no grouping. Each COutput gets its own OutputGroup.\n         for (const COutput& output : outputs) {\n             // Skip outputs we cannot spend\n             if (!output.fSpendable) continue;\n@@ -4238,11 +4231,11 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n             CInputCoin input_coin = output.GetInputCoin();\n \n             // Make an OutputGroup containing just this output\n-            OutputGroup group{effective_feerate, long_term_feerate};\n+            OutputGroup group{coin_sel_params};\n             group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n \n             // Check the OutputGroup's eligibility. Only add the eligible ones.\n-            if (positive_only && group.effective_value <= 0) continue;\n+            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n             if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n         }\n         return groups_out;\n@@ -4268,7 +4261,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n \n         if (groups.size() == 0) {\n             // No OutputGroups for this scriptPubKey yet, add one\n-            groups.emplace_back(effective_feerate, long_term_feerate);\n+            groups.emplace_back(coin_sel_params);\n         }\n \n         // Get the last OutputGroup in the vector so that we can add the CInputCoin to it\n@@ -4279,7 +4272,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n         // to avoid surprising users with very high fees.\n         if (group->m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n             // The last output group is full, add a new group to the vector and use that group for the insertion\n-            groups.emplace_back(effective_feerate, long_term_feerate);\n+            groups.emplace_back(coin_sel_params);\n             group = &groups.back();\n         }\n \n@@ -4301,7 +4294,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n             }\n \n             // Check the OutputGroup's eligibility. Only add the eligible ones.\n-            if (positive_only && group.effective_value <= 0) continue;\n+            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n             if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n         }\n     }"
      },
      {
        "sha": "1f4150b70259f6d3ad1af767f98daff2560005d1",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 42,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a3ac242c92e69b59df26f8f9e287b31e5c3b0f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=51a3ac242c92e69b59df26f8f9e287b31e5c3b0f",
        "patch": "@@ -612,47 +612,6 @@ class COutput\n     }\n };\n \n-/** Parameters for one iteration of Coin Selection. */\n-struct CoinSelectionParams\n-{\n-    /** Size of a change output in bytes, determined by the output type. */\n-    size_t change_output_size = 0;\n-    /** Size of the input to spend a change output in virtual bytes. */\n-    size_t change_spend_size = 0;\n-    /** Cost of creating the change output. */\n-    CAmount m_change_fee{0};\n-    /** Cost of creating the change output + cost of spending the change output in the future. */\n-    CAmount m_cost_of_change{0};\n-    /** The targeted feerate of the transaction being built. */\n-    CFeeRate m_effective_feerate;\n-    /** The feerate estimate used to estimate an upper bound on what should be sufficient to spend\n-     * the change output sometime in the future. */\n-    CFeeRate m_long_term_feerate;\n-    /** If the cost to spend a change output at the discard feerate exceeds its value, drop it to fees. */\n-    CFeeRate m_discard_feerate;\n-    /** Size of the transaction before coin selection, consisting of the header and recipient\n-     * output(s), excluding the inputs and change output(s). */\n-    size_t tx_noinputs_size = 0;\n-    /** Indicate that we are subtracting the fee from outputs */\n-    bool m_subtract_fee_outputs = false;\n-    /** When true, always spend all (up to OUTPUT_GROUP_MAX_ENTRIES) or none of the outputs\n-     * associated with the same address. This helps reduce privacy leaks resulting from address\n-     * reuse. Dust outputs are not eligible to be added to output groups and thus not considered. */\n-    bool m_avoid_partial_spends = false;\n-\n-    CoinSelectionParams(size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n-                        CFeeRate long_term_feerate, CFeeRate discard_feerate, size_t tx_noinputs_size, bool avoid_partial) :\n-        change_output_size(change_output_size),\n-        change_spend_size(change_spend_size),\n-        m_effective_feerate(effective_feerate),\n-        m_long_term_feerate(long_term_feerate),\n-        m_discard_feerate(discard_feerate),\n-        tx_noinputs_size(tx_noinputs_size),\n-        m_avoid_partial_spends(avoid_partial)\n-    {}\n-    CoinSelectionParams() {}\n-};\n-\n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /**\n  * A CWallet maintains a set of transactions and balances, and provides the ability to create new transactions.\n@@ -883,7 +842,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool separate_coins, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const;\n \n     /** Display address on an external signer. Returns false if external signer support is not compiled */\n     bool DisplayAddress(const CTxDestination& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  }
]