skeees,2018-04-20T15:27:36Z,Updated to address reviewer comments and fix a bug that this test seems to have uncovered,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-383132743,383132743,
sdaftuar,2018-04-26T15:53:13Z,"Thanks for opening this PR.  I thought it would be helpful for other reviewers to clarify the (IMO significant) bug here, so that we can properly evaluate fixes.\n\nIf ActivateBestChain is invoked simultaneously in separate threads, then we can end up at a lower-work tip, and remain stuck until the next block comes in.\n\n * Suppose in thread 1, we have just been delivered a block that causes ",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-384693081,384693081,
sdaftuar,2018-04-27T15:22:24Z,"I have a branch where I changed the test you wrote to produce invalid blocks that would be detected in ConnectBlock, and where I have an alternate fix for the bug you found here, as well as a fix for the bug I mentioned in #13092: https://github.com/sdaftuar/bitcoin/commits/2018-04-alternate-abc-fix.  \n\nFor fixing the bug here, rather than invoke `FindMostWorkChain` on every loop iteration (wh",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-385003478,385003478,
skeees,2018-04-27T16:29:15Z,Nice - thanks for this. I wonder if it might be a bit more readable to explore feasibility of caching results internally in findmostworkchain instead of doing it in the activatebestchain loop - the control flow there is getting harder and harder to follow. I'm happy to explore that.,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-385023004,385023004,
sdaftuar,2018-04-27T18:07:04Z,"@TheBlueMatt and I discussed that idea offline (of rewriting `FindMostWorkChain` to use `g_failed_blocks`, our internal data structure for caching invalid blocks, to speed it up) but our initial reaction was that the review overhead to ensure correctness might be very high.  I'm open to other ideas though (and if you think reworking FMWC is practical please feel free to take a shot at it).",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-385049827,385049827,
skeees,2018-05-04T15:57:25Z,"@sdaftuar - pulled in your commits.\n\nIts still hard for me to convince myself that the set of conditions you've defined are the only cases in which `pindexMostWork` needs to be refreshed. Maybe I'm just not familiar enough with those areas - I'll leave it to the people with more experience in that area to review.\n\nJust wanted to throw out one alternate way to do determine when to refresh m",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386645842,386645842,
MarcoFalke,2018-05-04T18:04:03Z,"Copy of travis output:\n\n```\nRunning tests: validation_block_tests from test/validation_block_tests.cpp\nRunning 1 test case...\nTest cases order is shuffled using seed: 1374948318\nEntering test module ""Bitcoin Test Suite""\ntest/validation_block_tests.cpp(24): Entering test suite ""validation_block_tests""\ntest/validation_block_tests.cpp(125): Entering test case ""processnewblock_signals_",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386686703,386686703,
sdaftuar,2018-05-04T19:11:25Z,"From some quick web searching, it seems that BOOST_CHECK may not be thread safe, so invoking it in each thread is likely the problem here.  Perhaps we should just `assert()` on the return value from `ProcessNewBlock()` (at line 160).",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386704093,386704093,
sdaftuar,2018-05-04T19:42:47Z,"I do occasionally see this failure when I run validation_block_tests in a tight loop (after fixing the BOOST_CHECK issue above):\n```\ntest/validation_block_tests.cpp(38): error in ""processnewblock_signals_ordering"": check m_expected_tip == block->hashPrevBlock failed [0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206 != 000000000000000000000000000000000000000000000000000000000000",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386712331,386712331,
skeees,2018-05-04T19:53:02Z,Hmmm thats the genesis block which connects through a different path I believe,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386714663,386714663,
skeees,2018-05-04T20:07:54Z,@sdaftuar - thats the genesis block getting activated. Feels like it may be more of a test artefact (wasn't there a recent change that randomizes test case execution order) than a threading issue?  I think solution for that is to just call PNB(genesis) at the very beginning.,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386719151,386719151,
sdaftuar,2018-05-04T20:08:55Z,"@skeees My reasoning is this:\n * Assume ABC never releases cs_main until the new tip has work >= that of the old tip..\n * Then it should be safe to always try to connect to pindexMostWork as long as it is still a candidate to be our tip (ie it's still in setBlockIndexCandidates).  Since we prune entries from setBlockIndexCandidates in ABCStep, if an entry is in setBlockIndexCandidates, then wo",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-386719376,386719376,
skeees,2018-05-07T19:44:03Z,@sipa - commits now correctly ordered and `m_cs_cs` renamed to `m_cs_chainstate`,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-387180410,387180410,
sdaftuar,2018-05-07T19:47:13Z,re-ACK ed1828c202c9f4376492c173e361814320a01ffa ,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-387181234,387181234,
TheBlueMatt,2018-05-14T16:33:55Z,"utACK non-test changes through a3ae8e68739023e5dba9e5cb190e707ed4603316, a3070a861bb3a76303b7859c4dd96ba886029111 would be fine with some release/acquire atomics, and 51539506577e5439c58b2e36c07d84f33bb4d4c5 looks awesome, though I haven't reviewed it fully.",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-388880844,388880844,
skeees,2018-05-14T18:02:10Z,"I will follow up offline in case I'm totally missing something - but I feel pretty strongly that sequential consistency should be guaranteed by the `SingleThreadedSchedulerClient` - whether the callbacks are actually run by one or multiple threads internally, it should feel single threaded (it's even named that way) and the caller shouldn't have to worry about it. Otherwise you open up a ton of su",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-388908666,388908666,
TheBlueMatt,2018-05-14T18:05:48Z,"@skeees hmm, maybe we're talking past each other, but my point was that you can fully guarantee both ordering and only one callback executing at once *without* implying seq_cst/rel_acq in the C++ memory model. I dont think the memory consistency of a client should be implied by an API as it can impose runtime cost.",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-388909727,388909727,
skeees,2018-05-14T20:19:16Z,Ok - I finally understand what you're saying. I still disagree. I think it makes the API pretty unusable if you drop that guarantee - and the theoretical (because its single threaded right now) performance tradeoff is worth the usability - and certainly it should not be called SingleThreaded anything since it drops the single threaded memory model. But in the interest of not delaying 0.16.1 I've r,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-388949034,388949034,
TheBlueMatt,2018-05-15T19:49:53Z,"utACK 7b4be5089938b188ecca86742aa6aa4d2ec0c40e, though I didn't review the last test in detail (thanks for making that!).",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-389291443,389291443,
laanwj,2018-05-16T11:56:19Z,"Compiling this locally gives me:\n```\n/.../bitcoin/src/test/validation_block_tests.cpp:73:13: error: use of undeclared identifier 'CheckProofOfWork'\n    while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n            ^\n1 error generated.\n```\n\nAdding `#include <pow.h>` fixes it.\n",https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-389492587,389492587,
skeees,2018-05-16T12:29:25Z,thanks @laanwj - updated,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-389500956,389500956,
laanwj,2018-05-16T16:24:51Z,utACK dd435ad40267f5c50ff17533c696f9302829a6a6,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-389580929,389580929,
fanquake,2018-05-28T09:37:01Z,Backported in #13317,https://github.com/bitcoin/bitcoin/pull/13023#issuecomment-392475570,392475570,
jamesob,2018-04-18T20:11:28Z,Looks like there's an alphabetic ordering here that may be good to preserve.,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182554249,182554249,src/Makefile.test.include
jamesob,2018-04-18T20:13:05Z,> should *be* required here,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182554703,182554703,src/test/scheduler_tests.cpp
jamesob,2018-04-18T20:23:58Z,"Could be worth parameterizing `Block` with a `bool make_invalid` option to avoid the duplication here, but that's your call.",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182557843,182557843,src/test/validation_block_tests.cpp
jamesob,2018-04-18T20:24:55Z,"I know we don't have columnar limits in the styleguide, but this line's pretty long...",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182558115,182558115,src/test/validation_block_tests.cpp
jamesob,2018-04-18T20:25:49Z,Braces needed.,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182558380,182558380,src/test/validation_block_tests.cpp
Empact,2018-04-18T21:37:33Z,clang-format would put those in I believe,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182577318,182577318,src/test/validation_block_tests.cpp
Empact,2018-04-18T21:37:45Z,Calling this `ignored` might be more straightforward,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r182577357,182577357,src/test/validation_block_tests.cpp
skeees,2018-04-20T15:25:02Z,Extracted into FinalizeBlock - its probably worth refactoring BlockAssembler into a builder style class - would make unit tests much easier to write ... maybe one day,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183086368,183086368,src/test/validation_block_tests.cpp
skeees,2018-04-20T15:25:05Z,i agree with you - i originally had this on two lines - and then the linter put it all back on one,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183086382,183086382,src/test/validation_block_tests.cpp
skeees,2018-04-20T15:25:09Z,it doesn't! but i put them in now,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183086405,183086405,src/test/validation_block_tests.cpp
jamesob,2018-04-20T17:14:09Z,"Yep, definitely agree. ",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183115412,183115412,src/test/validation_block_tests.cpp
ryanofsky,2018-04-23T18:07:38Z,Might be good to add a comment here saying why it's important to recompute pindexMostWork each loop iteration (how sync could get stuck otherwise).,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183487818,183487818,src/validation.cpp
ryanofsky,2018-04-23T18:13:15Z,"I'd think this could be written more simply as:\n\n```\nauto block = make_shared<CBlock>(ptemplate->block);\nblock->hashPrevBlock = ...\nreturn block;\n```\n\nIt looks like pblock is leaked currently, or is this not the case?",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r183489473,183489473,src/test/validation_block_tests.cpp
sdaftuar,2018-04-26T16:13:33Z,"This might cause substantial slow-down during IBD or reindex, because currently FindMostWorkChain walks from the candidate tip to the fork point on the current chain to ensure none of the blocks are invalid.  We may be able to optimize that, but we also might want to consider another solution.",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r184447870,184447870,src/validation.cpp
sdaftuar,2018-04-26T16:28:47Z,"This method of constructing a bad block is not ideal, because this kind of invalidity is detected well before ConnectBlock.  In order to get better code coverage, I think it would be better to generate different kinds of invalid blocks, to test failure at different points in the validation process.\n\n(As it is,  I believe this method of making an invalid block is detectable in CheckBlock (merkl",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r184452863,184452863,src/test/validation_block_tests.cpp
sdaftuar,2018-05-05T00:35:55Z,"As discussed on IRC, there's a race condition where callbacks scheduled prior to a client subscribing to callbacks can be delivered to those clients, if the scheduler didn't finish draining its queue before the new subscriber is added.\n\nThat causes this test to (rarely) fail, because we initialize the TestSubscriber with the genesis block, even though it might be notified of the genesis block'",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r186246920,186246920,src/test/validation_block_tests.cpp
sipa,2018-05-07T17:46:00Z,I believe it may be worth adding 16 bytes to the source code to give this the mildly less confusing name `m_chainstate_cs` instead.,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r186495495,186495495,src/validation.cpp
sdaftuar,2018-05-07T18:38:15Z,"nit: I think it's worth commenting here with some explanation of the types of race conditions that this is designed to protect (along the lines of what is in the commit message, perhaps)",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r186510101,186510101,src/validation.cpp
sdaftuar,2018-05-07T18:55:17Z,nit: perhaps add a comment explaining why this is added?  (guessing it's because you want to use uint256's in BOOST_CHECK_EQUAL()),https://github.com/bitcoin/bitcoin/pull/13023#discussion_r186515013,186515013,src/test/test_bitcoin.h
sdaftuar,2018-05-07T19:06:13Z,"nit: doesn't seem like these includes are necessary at all, am I missing some dependency?",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r186518125,186518125,src/test/validation_block_tests.cpp
jamesob,2018-05-11T19:31:02Z,nit: `if (...`,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187711869,187711869,src/validation.cpp
jamesob,2018-05-11T19:34:48Z,"> must be held when modifying this ChainState\n\nSeems like this statement is too broad; many aspects of this object are modified without this lock held (e.g. `g_failed_blocks`, `setBlockIndexCandidates`).",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187712808,187712808,src/validation.cpp
jamesob,2018-05-11T19:35:33Z,"I had a bit of trouble parsing this comment initially - might be easier to read if you wrote ""expensive-to-calculate"" instead?",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187712965,187712965,src/validation.cpp
TheBlueMatt,2018-05-11T19:40:19Z,"Not sure if this is my fault or not, but this definitely needs to be finding the fork since starting_tip for the notifications, not just since the last loop iteration. Also, we should probably move the UpdatedBlockTip callback generation inside the pindexFork != pindexNewTip check as otherwise you'll get rather nonsense callbacks (and none of the callers seem to rely on any specific behavior). Eit",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187714139,187714139,src/validation.cpp
TheBlueMatt,2018-05-11T19:41:43Z,"nit: comment is slightly wrong now, we dont release cs_main during large reorgs, only large connects.",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187714426,187714426,src/validation.cpp
TheBlueMatt,2018-05-11T19:57:26Z,"This isnt sufficient - just because two things are ordered does not mean they have a consistent view into memory unless there was something that triggered a flush. In practice I believe the lock inside of the SingleThreadedSchedulerClient provides this, but that's certainly not guaranteed in the future. A release-acquire should be sufficient, however.",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187718074,187718074,src/test/scheduler_tests.cpp
skeees,2018-05-12T18:04:16Z,don't quite understand what you mean here - isn't the whole purpose of SingleThreadedSchedulerClient to ensure internally consistent ordering/views of callbacks on a single client? if a memory barrier is somehow necessary to achieve this (like you I think the lock is sufficient for now) then that should be done in the SingleThreadedSchedulerClient and not be the caller's responsibility. This test ,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187779292,187779292,src/test/scheduler_tests.cpp
TheBlueMatt,2018-05-13T16:35:47Z,"The C++ memory model does not provide any ordering guarantees across variables at different memory locations unless you have a) some operation dependency tree which creates such an order, or b) a rel_acq/seq_cst operation somewhere which implicitly creates such an order (which a mutex lock/unlock essentially implicitly creates). So if, eg, the SingleThreadedSchedulerClient used only relaxed operat",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187806582,187806582,src/test/scheduler_tests.cpp
skeees,2018-05-14T14:35:56Z,"oh hmm - but each client only interacts with its own ""counter"" there's no sharing across clients in this tests. I'm simply checking that for each client, its own callbacks are processed sequentially - which i think is something that the singlethreadedschedulerclient api is supposed to guarantee (otherwise might as well just use the raw scheduler) - and no current test existed",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r187976777,187976777,src/test/scheduler_tests.cpp
TheBlueMatt,2018-05-14T16:29:43Z,"Ugh, my memory of the C++ memory model was slightly faulty, I've updated the comment above, though its much less a concern now (however should sitll be fixed). You could use relaxed operations to try to optimistically fetch the next callback to execute, succeed, and then have one thread run a callback, the other thread run a second callback but for the same client, and create no dependancy. On man",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r188017471,188017471,src/test/scheduler_tests.cpp
sdaftuar,2018-05-16T13:57:27Z,"nit: This is not a very good variable name, as ABCStep can return true even if no blocks were connected.",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r188634716,188634716,src/validation.cpp
sdaftuar,2018-05-16T14:03:03Z,"I believe this means we'll infinite loop if we ever had a bug like the race condition that this PR fixes, that could cause us to invoke ABCStep with a pindexMostWork that is less work than our tip.\n\nI think an infinite loop would be strictly worse than an assert failure, so could we also add an assert above that pindexMostWork has more work than chainActive.Tip(), before we invoke ABCStep?",https://github.com/bitcoin/bitcoin/pull/13023#discussion_r188636798,188636798,src/validation.cpp
sdaftuar,2018-05-16T19:18:17Z,I agree -- this is more of a lock on the logic in ABC than any particular data structure.  The comment in ABC itself is pretty good though.,https://github.com/bitcoin/bitcoin/pull/13023#discussion_r188742314,188742314,src/validation.cpp
