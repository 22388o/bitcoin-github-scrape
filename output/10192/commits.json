[
  {
    "sha": "6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDIyYjJiMTdiNzg1MmJiM2RjMzJkYmJiZjJmNWRmZjRmYjk4NjQ4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-11T20:04:37Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-07T15:02:36Z"
      },
      "message": "Pull script verify flags calculation out of ConnectBlock",
      "tree": {
        "sha": "8f65c29525917f1b99aed88154fcce503ccfe025",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f65c29525917f1b99aed88154fcce503ccfe025"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75e898c094eea533d1dfaf141c6afccc3072c49f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75e898c094eea533d1dfaf141c6afccc3072c49f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75e898c094eea533d1dfaf141c6afccc3072c49f"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 40,
      "deletions": 22
    },
    "files": [
      {
        "sha": "5b746229c9541b41cf06f17e37839ff5b2ee8207",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 22,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
        "patch": "@@ -312,6 +312,9 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n+// Returns the script flags which should be checked for a given block\n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n+\n static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -1475,6 +1478,41 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n // Protected by cs_main\n static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];\n \n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) {\n+    AssertLockHeld(cs_main);\n+\n+    // BIP16 didn't become active until Apr 1 2012\n+    int64_t nBIP16SwitchTime = 1333238400;\n+    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n+\n+    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n+\n+    // Start enforcing the DERSIG (BIP66) rule\n+    if (pindex->nHeight >= consensusparams.BIP66Height) {\n+        flags |= SCRIPT_VERIFY_DERSIG;\n+    }\n+\n+    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n+    if (pindex->nHeight >= consensusparams.BIP65Height) {\n+        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+    }\n+\n+    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+    }\n+\n+    // Start enforcing WITNESS rules using versionbits logic.\n+    if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n+        flags |= SCRIPT_VERIFY_WITNESS;\n+        flags |= SCRIPT_VERIFY_NULLDUMMY;\n+    }\n+\n+    return flags;\n+}\n+\n+\n+\n static int64_t nTimeCheck = 0;\n static int64_t nTimeForks = 0;\n static int64_t nTimeVerify = 0;\n@@ -1578,34 +1616,14 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         }\n     }\n \n-    // BIP16 didn't become active until Apr 1 2012\n-    int64_t nBIP16SwitchTime = 1333238400;\n-    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n-\n-    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n-\n-    // Start enforcing the DERSIG (BIP66) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {\n-        flags |= SCRIPT_VERIFY_DERSIG;\n-    }\n-\n-    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {\n-        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n-    }\n-\n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n     if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n-        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n-    // Start enforcing WITNESS rules using versionbits logic.\n-    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {\n-        flags |= SCRIPT_VERIFY_WITNESS;\n-        flags |= SCRIPT_VERIFY_NULLDUMMY;\n-    }\n+    // Get the script flags for this block\n+    unsigned int flags = GetBlockScriptFlags(pindex, chainparams.GetConsensus());\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);"
      }
    ]
  },
  {
    "sha": "b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNWZlYThkMGNjYzgxMTc2NDRhNGVhMTEyNTZiYzUzMWI2MGZkOWEz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-11T20:46:39Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-07T15:02:36Z"
      },
      "message": "Cache full script execution results in addition to signatures\n\nThis adds a new CuckooCache in validation, caching whether all of a\ntransaction's scripts were valid with a given set of script flags.\n\nUnlike previous attempts at caching an entire transaction's\nvalidity, which have nearly universally introduced consensus\nfailures, this only caches the validity of a transaction's\nscriptSigs. As these are pure functions of the transaction and\ndata it commits to, this should be much safer.\n\nThis is somewhat duplicative with the sigcache, as entries in the\nnew cache will also have several entries in the sigcache. However,\nthe sigcache is kept both as ATMP relies on it and because it\nprevents malleability-based DoS attacks on the new higher-level\ncache. Instead, the -sigcachesize option is re-used - cutting the\nsigcache size in half and using the newly freed memory for the\nscript execution cache.\n\nTransactions which match the script execution cache never even have\nentries in the script check thread's workqueue created.\n\nNote that the cache is indexed only on the script execution flags\nand the transaction's witness hash. While this is sufficient to\nmake the CScriptCheck() calls pure functions, this introduces\ndependancies on the mempool calculating things such as the\nPrecomputedTransactionData object, filling the CCoinsViewCache, etc\nin the exact same way as ConnectBlock. I belive this is a reasonable\nassumption, but should be noted carefully.\n\nIn a rather naive benchmark (reindex-chainstate up to block 284k\nwith cuckoocache always returning true for contains(),\n-assumevalid=0 and a very large dbcache), this connected blocks\n~1.7x faster.",
      "tree": {
        "sha": "fc7c8e2b82d0d7f3651fd1ddc314e36dc0f731bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc7c8e2b82d0d7f3651fd1ddc314e36dc0f731bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d22b2b17b7852bb3dc32dbbbf2f5dff4fb98648"
      }
    ],
    "stats": {
      "total": 75,
      "additions": 61,
      "deletions": 14
    },
    "files": [
      {
        "sha": "aab5670115256ec980471074c906f3b2677e6129",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "patch": "@@ -1211,6 +1211,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     InitSignatureCache();\n+    InitScriptExecutionCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {"
      },
      {
        "sha": "bf0e006068107bfbf1de8953eb93167feee02f0a",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "patch": "@@ -74,7 +74,7 @@ void InitSignatureCache()\n {\n     // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n     // setup_bytes creates the minimum possible cache (2 elements).\n-    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE)), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = signatureCache.setup_bytes(nMaxCacheSize);\n     LogPrintf(\"Using %zu MiB out of %zu requested for signature cache, able to store %zu elements\\n\",\n             (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);"
      },
      {
        "sha": "c6a5b12a974301c7e1b5c0d80a545d4c389ea4f2",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "patch": "@@ -39,6 +39,7 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n         SetupEnvironment();\n         SetupNetworking();\n         InitSignatureCache();\n+        InitScriptExecutionCache();\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         fCheckBlockIndex = true;\n         SelectParams(chainName);"
      },
      {
        "sha": "9a02e9684a226bd0afe2d474342a9b859cdf7312",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 13,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "patch": "@@ -14,6 +14,7 @@\n #include \"consensus/merkle.h\"\n #include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n+#include \"cuckoocache.h\"\n #include \"fs.h\"\n #include \"hash.h\"\n #include \"init.h\"\n@@ -189,7 +190,7 @@ enum FlushStateMode {\n static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n@@ -752,29 +753,36 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)) {\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n         }\n \n-        // Check again against just the consensus-critical mandatory script\n-        // verification flags, in case of bugs in the standard flags that cause\n+        // Check again against the current block tip's script verification\n+        // flags to cache our script execution flags. This is, of course,\n+        // useless if the next block has different script flags from the\n+        // previous one, but because the cache tracks script flags for us it\n+        // will auto-invalidate and we'll just have a few blocks of extra\n+        // misses on soft-fork activation.\n+        //\n+        // This is also useful in case of bugs in the standard flags that cause\n         // transactions to pass as valid when they're actually invalid. For\n         // instance the STRICTENC flag was incorrectly allowing certain\n         // CHECKSIG NOT scripts to pass, even though they were invalid.\n         //\n         // There is a similar check in CreateNewBlock() to prevent creating\n-        // invalid blocks, however allowing such transactions into the mempool\n-        // can be exploited as a DoS attack.\n-        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata))\n+        // invalid blocks (using TestBlockValidity), however allowing such\n+        // transactions into the mempool can be exploited as a DoS attack.\n+        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), Params().GetConsensus());\n+        if (!CheckInputs(tx, state, view, true, currentBlockScriptVerifyFlags, true, true, txdata))\n         {\n             return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n                 __func__, hash.ToString(), FormatStateMessage(state));\n@@ -1152,12 +1160,25 @@ int GetSpendHeight(const CCoinsViewCache& inputs)\n     return pindexPrev->nHeight + 1;\n }\n \n+\n+static CuckooCache::cache<uint256, SignatureCacheHasher> scriptExecutionCache;\n+static uint256 scriptExecutionCacheNonce(GetRandHash());\n+\n+void InitScriptExecutionCache() {\n+    // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n+    // setup_bytes creates the minimum possible cache (2 elements).\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nElems = scriptExecutionCache.setup_bytes(nMaxCacheSize);\n+    LogPrintf(\"Using %zu MiB out of %zu requested for script execution cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);\n+}\n+\n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n  * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n  * instead of being performed inline.\n  */\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1177,6 +1198,21 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n         // Of course, if an assumed valid block is invalid due to false scriptSigs\n         // this optimization would allow an invalid chain to be accepted.\n         if (fScriptChecks) {\n+            // First check if script executions have been cached with the same\n+            // flags. Note that this assumes that the inputs provided are\n+            // correct (ie that the transaction hash which is in tx's prevouts\n+            // properly commits to the scriptPubKey in the inputs view of that\n+            // transaction).\n+            uint256 hashCacheEntry;\n+            // We only use the first 19 bytes of nonce to avoid a second SHA\n+            // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n+            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n+            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n+            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n+            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n+                return true;\n+            }\n+\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n@@ -1191,7 +1227,7 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                 const CAmount amount = coin.out.nValue;\n \n                 // Verify signature\n-                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);\n+                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheSigStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1204,7 +1240,7 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n                         CScriptCheck check2(scriptPubKey, amount, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n+                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n@@ -1218,6 +1254,12 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                     return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n+\n+            if (cacheFullScriptStore && !pvChecks) {\n+                // We executed all of the provided scripts, and were told to\n+                // cache the result. Do so now.\n+                scriptExecutionCache.insert(hashCacheEntry);\n+            }\n         }\n     }\n \n@@ -1684,7 +1726,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);"
      },
      {
        "sha": "d09734312631f7f90650003068013cef9ce13d65",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "patch": "@@ -394,6 +394,9 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+/** Initializes the script-execution cache */\n+void InitScriptExecutionCache();\n+\n \n /** Functions for disk access for blocks */\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);"
      }
    ]
  },
  {
    "sha": "eada04e778435574198b5778bf6ccc72cfcba7be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYWRhMDRlNzc4NDM1NTc0MTk4YjU3NzhiZjZjY2M3MmNmY2JhN2Jl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-27T15:45:29Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-07T15:02:36Z"
      },
      "message": "Do not print soft-fork-script warning with -promiscuousmempool",
      "tree": {
        "sha": "a348b990f7bf3af62d6b98919cdd4e7f3bb7949f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a348b990f7bf3af62d6b98919cdd4e7f3bb7949f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eada04e778435574198b5778bf6ccc72cfcba7be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eada04e778435574198b5778bf6ccc72cfcba7be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eada04e778435574198b5778bf6ccc72cfcba7be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eada04e778435574198b5778bf6ccc72cfcba7be/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b5fea8d0ccc8117644a4ea11256bc531b60fd9a3"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 14,
      "deletions": 2
    },
    "files": [
      {
        "sha": "621077bcba9cbde24a91302c9f50e8dfbe838c1d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eada04e778435574198b5778bf6ccc72cfcba7be/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eada04e778435574198b5778bf6ccc72cfcba7be/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=eada04e778435574198b5778bf6ccc72cfcba7be",
        "patch": "@@ -784,8 +784,20 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), Params().GetConsensus());\n         if (!CheckInputs(tx, state, view, true, currentBlockScriptVerifyFlags, true, true, txdata))\n         {\n-            return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n-                __func__, hash.ToString(), FormatStateMessage(state));\n+            // If we're using promiscuousmempoolflags, we may hit this normally\n+            // Check if current block has some flags that scriptVerifyFlags\n+            // does not before printing an ominous warning\n+            if (!(~scriptVerifyFlags & currentBlockScriptVerifyFlags)) {\n+                return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against latest-block but not STANDARD flags %s, %s\",\n+                    __func__, hash.ToString(), FormatStateMessage(state));\n+            } else {\n+                if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, false, txdata)) {\n+                    return error(\"%s: ConnectInputs failed against MANDATORY but not STANDARD flags due to promiscuous mempool %s, %s\",\n+                        __func__, hash.ToString(), FormatStateMessage(state));\n+                } else {\n+                    LogPrintf(\"Warning: -promiscuousmempool flags set to not include currently enforced soft forks, this may break mining or otherwise cause instability!\\n\");\n+                }\n+            }\n         }\n \n         // Remove conflicting transactions from the mempool"
      }
    ]
  },
  {
    "sha": "b014668e27b496bd6ad30985294f3d6971311910",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDE0NjY4ZTI3YjQ5NmJkNmFkMzA5ODUyOTRmM2Q2OTcxMzExOTEw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-06T00:46:23Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-22T16:21:09Z"
      },
      "message": "Add CheckInputs wrapper CCoinsViewMemPool -> non-consensus-critical\n\nThis wraps CheckInputs in ATMP's cache-inputs call to check that\neach scriptPubKey the CCoinsViewCache provides is the one which\nwas committed to by the input's transaction hash.",
      "tree": {
        "sha": "9236fe0b456f308f413791efe72fa6b9733f7d02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9236fe0b456f308f413791efe72fa6b9733f7d02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b014668e27b496bd6ad30985294f3d6971311910",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b014668e27b496bd6ad30985294f3d6971311910",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b014668e27b496bd6ad30985294f3d6971311910",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b014668e27b496bd6ad30985294f3d6971311910/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eada04e778435574198b5778bf6ccc72cfcba7be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eada04e778435574198b5778bf6ccc72cfcba7be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eada04e778435574198b5778bf6ccc72cfcba7be"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 37,
      "deletions": 1
    },
    "files": [
      {
        "sha": "463c16c11fa918c7cf9aaa0914c715464ed62245",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 1,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b014668e27b496bd6ad30985294f3d6971311910/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b014668e27b496bd6ad30985294f3d6971311910/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b014668e27b496bd6ad30985294f3d6971311910",
        "patch": "@@ -399,6 +399,42 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n     LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n \n+// Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n+// were somehow broken and returning the wrong scriptPubKeys\n+static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, CTxMemPool& pool,\n+                 unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) {\n+    AssertLockHeld(cs_main);\n+\n+    // pool.cs should be locked already, but go ahead and re-take the lock here\n+    // to enforce that mempool doesn't change between when we check the view\n+    // and when we actually call through to CheckInputs\n+    LOCK(pool.cs);\n+\n+    assert(!tx.IsCoinBase());\n+    for (const CTxIn& txin : tx.vin) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+\n+        // At this point we haven't actually checked if the coins are all\n+        // available (or shouldn't assume we have, since CheckInputs does).\n+        // So we just return failure if the inputs are not available here,\n+        // and then only have to check equivalence for available inputs.\n+        if (coin.IsSpent()) return false;\n+\n+        const CTransactionRef& txFrom = pool.get(txin.prevout.hash);\n+        if (txFrom) {\n+            assert(txFrom->GetHash() == txin.prevout.hash);\n+            assert(txFrom->vout.size() > txin.prevout.n);\n+            assert(txFrom->vout[txin.prevout.n] == coin.out);\n+        } else {\n+            const Coin& coinFromDisk = pcoinsTip->AccessCoin(txin.prevout);\n+            assert(!coinFromDisk.IsSpent());\n+            assert(coinFromDisk.out == coin.out);\n+        }\n+    }\n+\n+    return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n+}\n+\n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n@@ -782,7 +818,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // invalid blocks (using TestBlockValidity), however allowing such\n         // transactions into the mempool can be exploited as a DoS attack.\n         unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), Params().GetConsensus());\n-        if (!CheckInputs(tx, state, view, true, currentBlockScriptVerifyFlags, true, true, txdata))\n+        if (!CheckInputsFromMempoolAndCache(tx, state, view, pool, currentBlockScriptVerifyFlags, true, txdata))\n         {\n             // If we're using promiscuousmempoolflags, we may hit this normally\n             // Check if current block has some flags that scriptVerifyFlags"
      }
    ]
  },
  {
    "sha": "309ee1ae7b288deabe6601b054474393f31e1fe7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMDllZTFhZTdiMjg4ZGVhYmU2NjAxYjA1NDQ3NDM5M2YzMWUxZmU3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-21T20:38:12Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-22T16:21:09Z"
      },
      "message": "Update -maxsigcachesize doc clarify init logprints for it",
      "tree": {
        "sha": "20239fbd4b7bc256a02e4f129e56143f5ab9641e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20239fbd4b7bc256a02e4f129e56143f5ab9641e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/309ee1ae7b288deabe6601b054474393f31e1fe7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309ee1ae7b288deabe6601b054474393f31e1fe7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/309ee1ae7b288deabe6601b054474393f31e1fe7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309ee1ae7b288deabe6601b054474393f31e1fe7/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b014668e27b496bd6ad30985294f3d6971311910",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b014668e27b496bd6ad30985294f3d6971311910",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b014668e27b496bd6ad30985294f3d6971311910"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "df6a762a7a8074c87f5c6ce491487d8e58658002",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309ee1ae7b288deabe6601b054474393f31e1fe7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309ee1ae7b288deabe6601b054474393f31e1fe7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=309ee1ae7b288deabe6601b054474393f31e1fe7",
        "patch": "@@ -461,7 +461,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n         strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit size of signature cache to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n         strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n     }\n     strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),"
      },
      {
        "sha": "66aa7ad3e3bb2c2295a09880c35af53b49b68c1d",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309ee1ae7b288deabe6601b054474393f31e1fe7/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309ee1ae7b288deabe6601b054474393f31e1fe7/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=309ee1ae7b288deabe6601b054474393f31e1fe7",
        "patch": "@@ -76,8 +76,8 @@ void InitSignatureCache()\n     // setup_bytes creates the minimum possible cache (2 elements).\n     size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = signatureCache.setup_bytes(nMaxCacheSize);\n-    LogPrintf(\"Using %zu MiB out of %zu requested for signature cache, able to store %zu elements\\n\",\n-            (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for signature cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const"
      },
      {
        "sha": "baddb84be6485a3212727c501f26d49deda3a681",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309ee1ae7b288deabe6601b054474393f31e1fe7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309ee1ae7b288deabe6601b054474393f31e1fe7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=309ee1ae7b288deabe6601b054474393f31e1fe7",
        "patch": "@@ -1217,8 +1217,8 @@ void InitScriptExecutionCache() {\n     // setup_bytes creates the minimum possible cache (2 elements).\n     size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = scriptExecutionCache.setup_bytes(nMaxCacheSize);\n-    LogPrintf(\"Using %zu MiB out of %zu requested for script execution cache, able to store %zu elements\\n\",\n-            (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for script execution cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n /**"
      }
    ]
  },
  {
    "sha": "a3543af3cc878f2f24ada8b80198c8e4572c06eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMzU0M2FmM2NjODc4ZjJmMjRhZGE4YjgwMTk4YzhlNDU3MmMwNmVi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-07T15:05:34Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-22T16:21:09Z"
      },
      "message": "Better document CheckInputs parameter meanings",
      "tree": {
        "sha": "70a84ffbcba3b6fd4f091cd088085d4823e37da4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70a84ffbcba3b6fd4f091cd088085d4823e37da4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a3543af3cc878f2f24ada8b80198c8e4572c06eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3543af3cc878f2f24ada8b80198c8e4572c06eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a3543af3cc878f2f24ada8b80198c8e4572c06eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3543af3cc878f2f24ada8b80198c8e4572c06eb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "309ee1ae7b288deabe6601b054474393f31e1fe7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309ee1ae7b288deabe6601b054474393f31e1fe7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/309ee1ae7b288deabe6601b054474393f31e1fe7"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 9,
      "deletions": 2
    },
    "files": [
      {
        "sha": "945d39876c88a599e515516f7373e7b7dc89be75",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a3543af3cc878f2f24ada8b80198c8e4572c06eb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a3543af3cc878f2f24ada8b80198c8e4572c06eb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a3543af3cc878f2f24ada8b80198c8e4572c06eb",
        "patch": "@@ -1223,8 +1223,15 @@ void InitScriptExecutionCache() {\n \n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n- * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n- * instead of being performed inline.\n+ * This does not modify the UTXO set.\n+ *\n+ * If pvChecks is not NULL, script checks are pushed onto it instead of being performed inline. Any\n+ * script checks which are not necessary (eg due to script execution cache hits) are, obviously,\n+ * not pushed onto pvChecks/run.\n+ *\n+ * Setting cacheSigStore/cacheFullScriptStore to false will remove elements from the corresponding cache\n+ * which are matched. This is useful for checking blocks where we will likely never need the cache\n+ * entry again.\n  */\n static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {"
      }
    ]
  },
  {
    "sha": "e3f9c05b966622146e090f2a01a913516ccb874a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2Y5YzA1Yjk2NjYyMjE0NmUwOTBmMmEwMWE5MTM1MTZjY2I4NzRh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-06-23T20:23:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-27T20:05:04Z"
      },
      "message": "Add CheckInputs() unit tests\n\nCheck that cached script execution results are only valid for the same\nscript flags; that script execution checks are returned for non-cached\ntransactions; and that cached results are only valid for transactions\nwith the same witness hash.",
      "tree": {
        "sha": "7d9642a50d9d0473f87fbe1046dcebb372364c43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d9642a50d9d0473f87fbe1046dcebb372364c43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3f9c05b966622146e090f2a01a913516ccb874a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f9c05b966622146e090f2a01a913516ccb874a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3f9c05b966622146e090f2a01a913516ccb874a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f9c05b966622146e090f2a01a913516ccb874a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a3543af3cc878f2f24ada8b80198c8e4572c06eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3543af3cc878f2f24ada8b80198c8e4572c06eb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a3543af3cc878f2f24ada8b80198c8e4572c06eb"
      }
    ],
    "stats": {
      "total": 290,
      "additions": 288,
      "deletions": 2
    },
    "files": [
      {
        "sha": "a74f40251aa3ee1427742e657ce2c3dd98232813",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 284,
        "deletions": 0,
        "changes": 284,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3f9c05b966622146e090f2a01a913516ccb874a/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3f9c05b966622146e090f2a01a913516ccb874a/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=e3f9c05b966622146e090f2a01a913516ccb874a",
        "patch": "@@ -10,11 +10,17 @@\n #include \"txmempool.h\"\n #include \"random.h\"\n #include \"script/standard.h\"\n+#include \"script/sign.h\"\n #include \"test/test_bitcoin.h\"\n #include \"utiltime.h\"\n+#include \"core_io.h\"\n+#include \"keystore.h\"\n+#include \"policy/policy.h\"\n \n #include <boost/test/unit_test.hpp>\n \n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+\n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n static bool\n@@ -84,4 +90,282 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0);\n }\n \n+// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n+// flags.  Test that CheckInputs passes for all flags that don't overlap with\n+// the failing_flags argument, but otherwise fails.\n+// CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n+// get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\n+// the script flags used contain DISCOURAGE_UPGRADABLE_NOPS but don't contain\n+// CHECKLOCKTIMEVERIFY (or CHECKSEQUENCEVERIFY), but the script does contain\n+// OP_CHECKLOCKTIMEVERIFY (or OP_CHECKSEQUENCEVERIFY), then script execution\n+// should fail.\n+// Capture this interaction with the upgraded_nop argument: set it when evaluating\n+// any script flag that is implemented as an upgraded NOP code.\n+void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache, bool upgraded_nop)\n+{\n+    PrecomputedTransactionData txdata(tx);\n+    // If we add many more flags, this loop can get too expensive, but we can\n+    // rewrite in the future to randomly pick a set of flags to evaluate.\n+    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n+        CValidationState state;\n+        // Filter out incompatible flag choices\n+        if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n+            // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\n+            // script/interpreter.cpp\n+            test_flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n+        }\n+        if ((test_flags & SCRIPT_VERIFY_WITNESS)) {\n+            // WITNESS requires P2SH\n+            test_flags |= SCRIPT_VERIFY_P2SH;\n+        }\n+        bool ret = CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, nullptr);\n+        // CheckInputs should succeed iff test_flags doesn't intersect with\n+        // failing_flags\n+        bool expected_return_value = !(test_flags & failing_flags);\n+        if (expected_return_value && upgraded_nop) {\n+            // If the script flag being tested corresponds to an upgraded NOP,\n+            // then script execution should fail if DISCOURAGE_UPGRADABLE_NOPS\n+            // is set.\n+            expected_return_value = !(test_flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n+        }\n+        BOOST_CHECK_EQUAL(ret, expected_return_value);\n+\n+        // Test the caching\n+        if (ret && add_to_cache) {\n+            // Check that we get a cache hit if the tx was valid\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(scriptchecks.empty());\n+        } else {\n+            // Check that we get script executions to check, if the transaction\n+            // was invalid, or we didn't add to cache.\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n+{\n+    // Test that passing CheckInputs with one set of script flags doesn't imply\n+    // that we would pass again with a different set of flags.\n+    InitScriptExecutionCache();\n+\n+    CScript p2pk_scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    CScript p2sh_scriptPubKey = GetScriptForDestination(CScriptID(p2pk_scriptPubKey));\n+    CScript p2pkh_scriptPubKey = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n+    CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\n+\n+    CBasicKeyStore keystore;\n+    keystore.AddKey(coinbaseKey);\n+    keystore.AddCScript(p2pk_scriptPubKey);\n+\n+    // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\n+\n+    // Create 2 outputs that match the three scripts above, spending the first\n+    // coinbase tx.\n+    CMutableTransaction spend_tx;\n+\n+    spend_tx.nVersion = 1;\n+    spend_tx.vin.resize(1);\n+    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n+    spend_tx.vin[0].prevout.n = 0;\n+    spend_tx.vout.resize(4);\n+    spend_tx.vout[0].nValue = 11*CENT;\n+    spend_tx.vout[0].scriptPubKey = p2sh_scriptPubKey;\n+    spend_tx.vout[1].nValue = 11*CENT;\n+    spend_tx.vout[1].scriptPubKey = p2wpkh_scriptPubKey;\n+    spend_tx.vout[2].nValue = 11*CENT;\n+    spend_tx.vout[2].scriptPubKey = CScript() << OP_CHECKLOCKTIMEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    spend_tx.vout[3].nValue = 11*CENT;\n+    spend_tx.vout[3].scriptPubKey = CScript() << OP_CHECKSEQUENCEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+\n+    // Sign, with a non-DER signature\n+    {\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        spend_tx.vin[0].scriptSig << vchSig;\n+    }\n+\n+    LOCK(cs_main);\n+\n+    // Test that invalidity under a set of flags doesn't preclude validity\n+    // under other (eg consensus) flags.\n+    // spend_tx is invalid according to DERSIG\n+    CValidationState state;\n+    {\n+        PrecomputedTransactionData ptd_spend_tx(spend_tx);\n+\n+        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+\n+        // If we call again asking for scriptchecks (as happens in\n+        // ConnectBlock), we should add a script check object for this -- we're\n+        // not caching invalidity (if that changes, delete this test case).\n+        std::vector<CScriptCheck> scriptchecks;\n+        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\n+\n+        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n+        // not present.  Don't add these checks to the cache, so that we can\n+        // test later that block validation works fine in the absence of cached\n+        // successes.\n+        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false, false);\n+\n+        // And if we produce a block with this tx, it should be valid (DERSIG not\n+        // enabled yet), even though there's no cache entry.\n+        CBlock block;\n+\n+        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n+        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+    }\n+\n+    // Test P2SH: construct a transaction that is valid without P2SH, and\n+    // then test validity with P2SH.\n+    {\n+        CMutableTransaction invalid_under_p2sh_tx;\n+        invalid_under_p2sh_tx.nVersion = 1;\n+        invalid_under_p2sh_tx.vin.resize(1);\n+        invalid_under_p2sh_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_under_p2sh_tx.vin[0].prevout.n = 0;\n+        invalid_under_p2sh_tx.vout.resize(1);\n+        invalid_under_p2sh_tx.vout[0].nValue = 11*CENT;\n+        invalid_under_p2sh_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+        std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n+        invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n+\n+        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true, false);\n+    }\n+\n+    // Test CHECKLOCKTIMEVERIFY\n+    {\n+        CMutableTransaction invalid_with_cltv_tx;\n+        invalid_with_cltv_tx.nVersion = 1;\n+        invalid_with_cltv_tx.nLockTime = 100;\n+        invalid_with_cltv_tx.vin.resize(1);\n+        invalid_with_cltv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_cltv_tx.vin[0].prevout.n = 2;\n+        invalid_with_cltv_tx.vin[0].nSequence = 0;\n+        invalid_with_cltv_tx.vout.resize(1);\n+        invalid_with_cltv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_cltv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TEST CHECKSEQUENCEVERIFY\n+    {\n+        CMutableTransaction invalid_with_csv_tx;\n+        invalid_with_csv_tx.nVersion = 2;\n+        invalid_with_csv_tx.vin.resize(1);\n+        invalid_with_csv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_csv_tx.vin[0].prevout.n = 3;\n+        invalid_with_csv_tx.vin[0].nSequence = 100;\n+        invalid_with_csv_tx.vout.resize(1);\n+        invalid_with_csv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_csv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_csv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TODO: add tests for remaining script flags\n+\n+    // Test that passing CheckInputs with a valid witness doesn't imply success\n+    // for the same tx with a different witness.\n+    {\n+        CMutableTransaction valid_with_witness_tx;\n+        valid_with_witness_tx.nVersion = 1;\n+        valid_with_witness_tx.vin.resize(1);\n+        valid_with_witness_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        valid_with_witness_tx.vin[0].prevout.n = 1;\n+        valid_with_witness_tx.vout.resize(1);\n+        valid_with_witness_tx.vout[0].nValue = 11*CENT;\n+        valid_with_witness_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        SignatureData sigdata;\n+        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n+        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n+\n+        // This should be valid under all script flags.\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true, false);\n+\n+        // Remove the witness, and check that it is now invalid.\n+        valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true, false);\n+    }\n+\n+    {\n+        // Test a transaction with multiple inputs.\n+        CMutableTransaction tx;\n+\n+        tx.nVersion = 1;\n+        tx.vin.resize(2);\n+        tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        tx.vin[0].prevout.n = 0;\n+        tx.vin[1].prevout.hash = spend_tx.GetHash();\n+        tx.vin[1].prevout.n = 1;\n+        tx.vout.resize(1);\n+        tx.vout[0].nValue = 22*CENT;\n+        tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        for (int i=0; i<2; ++i) {\n+            SignatureData sigdata;\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n+            UpdateTransaction(tx, i, sigdata);\n+        }\n+\n+        // This should be valid under all script flags\n+        ValidateCheckInputsForAllFlags(tx, 0, true, false);\n+\n+        // Check that if the second input is invalid, but the first input is\n+        // valid, the transaction is not cached.\n+        // Invalidate vin[1]\n+        tx.vin[1].scriptWitness.SetNull();\n+\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(tx);\n+        // This transaction is now invalid under segwit, because of the second input.\n+        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+\n+        std::vector<CScriptCheck> scriptchecks;\n+        // Make sure this transaction was not cached (ie because the first\n+        // input was valid)\n+        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        // Should get 2 script checks back -- caching is on a whole-transaction basis.\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d32ba6933696e79c2a1a23168e00f945f9207b93",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3f9c05b966622146e090f2a01a913516ccb874a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3f9c05b966622146e090f2a01a913516ccb874a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e3f9c05b966622146e090f2a01a913516ccb874a",
        "patch": "@@ -190,7 +190,7 @@ enum FlushStateMode {\n static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n@@ -1232,8 +1232,10 @@ void InitScriptExecutionCache() {\n  * Setting cacheSigStore/cacheFullScriptStore to false will remove elements from the corresponding cache\n  * which are matched. This is useful for checking blocks where we will likely never need the cache\n  * entry again.\n+ *\n+ * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {"
      }
    ]
  }
]